[
    {
        "title": "Shortest Path in Binary Matrix",
        "question_content": "Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\nA clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\n\n\tAll the visited cells of the path are 0.\n\tAll the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\n\nThe length of a clear path is the number of visited cells of this path.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,1],[1,0]]\nOutput: 2\n\nExample 2:\n\nInput: grid = [[0,0,0],[1,1,0],[1,1,0]]\nOutput: 4\n\nExample 3:\n\nInput: grid = [[1,0,0],[1,1,0],[1,1,0]]\nOutput: -1\n\n&nbsp;\nConstraints:\n\n\tn == grid.length\n\tn == grid[i].length\n\t1 <= n <= 100\n\tgrid[i][j] is 0 or 1",
        "solutions": [
            {
                "id": 313347,
                "title": "a-search-in-python",
                "content": "An A* search is like a breadth-first seach, except that in each iteration, instead of expanding the cell with the shortest path from the origin, we expand the cell with the lowest overall estimated path length -- this is the distance so far, plus a heuristic (rule-of-thumb) estimate of the remaining distance. As long as the heuristic is [consistent](https://en.wikipedia.org/wiki/Consistent_heuristic), an A* graph-search will find the shortest path. This can be somewhat more efficient than breadth-first-search as we typically don\\'t have to visit nearly as many cells. Intuitively, an A* search has an approximate sense of direction, and uses this sense to guide it towards the target.\\n\\n# Example\\n\\n```\\n[\\n\\t[0,0,0,1,0,0,1,0],\\n\\t[0,0,0,0,0,0,0,0],\\n\\t[1,0,0,1,1,0,1,0],\\n\\t[0,1,1,1,0,0,0,0],\\n\\t[0,0,0,0,0,1,1,1],\\n\\t[1,0,1,0,0,0,0,0],\\n\\t[1,1,0,0,0,1,0,0],\\n\\t[0,0,0,0,0,1,0,0]\\n]\\n```\\n\\nWith this grid, an A* search will expolore only the green cells in this animation:\\n\\n![image](https://assets.leetcode.com/static_assets/posts/giphy.gif)\\n\\nWhereas a BFS will visit *every* cell:\\n\\n![image](https://assets.leetcode.com/users/lxnn/image_1560734489.png)\\n\\n# Implementation\\n\\nWe perform an A* search to find the shortest path, then return it\\'s length, if there is one. Note: I chose to deal with the special case, that the starting cell is a blocking cell, here rather than complicate the search implementation.\\n\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid):\\n        shortest_path = a_star_graph_search(\\n            start              = (0, 0), \\n            goal_function      = get_goal_function(grid),\\n            successor_function = get_successor_function(grid),\\n            heuristic          = get_heuristic(grid)\\n        )\\n        if shortest_path is None or grid[0][0] == 1:\\n            return -1\\n        else:\\n            return len(shortest_path)\\n```\\n\\n## A* search function\\n\\nThis implementation is somewhat general and will work for other constant-cost search problems, as long as you provide a suitable goal function, successor function, and heuristic.\\n\\n```python\\ndef a_star_graph_search(\\n            start,\\n            goal_function,\\n            successor_function,\\n            heuristic\\n\\t):\\n    visited = set()\\n    came_from = dict()\\n    distance = {start: 0}\\n    frontier = PriorityQueue()\\n    frontier.add(start)\\n    while frontier:\\n        node = frontier.pop()\\n        if node in visited:\\n            continue\\n        if goal_function(node):\\n            return reconstruct_path(came_from, start, node)\\n        visited.add(node)\\n        for successor in successor_function(node):\\n            frontier.add(\\n                successor,\\n                priority = distance[node] + 1 + heuristic(successor)\\n            )\\n            if (successor not in distance\\n                or distance[node] + 1 < distance[successor]):\\n                distance[successor] = distance[node] + 1\\n                came_from[successor] = node\\n    return None\\n\\ndef reconstruct_path(came_from, start, end):\\n    \"\"\"\\n    >>> came_from = {\\'b\\': \\'a\\', \\'c\\': \\'a\\', \\'d\\': \\'c\\', \\'e\\': \\'d\\', \\'f\\': \\'d\\'}\\n    >>> reconstruct_path(came_from, \\'a\\', \\'e\\')\\n    [\\'a\\', \\'c\\', \\'d\\', \\'e\\']\\n    \"\"\"\\n    reverse_path = [end]\\n    while end != start:\\n        end = came_from[end]\\n        reverse_path.append(end)\\n    return list(reversed(reverse_path))\\n```\\n\\n## Goal function\\n\\nWe need a function to check whether we have reached the goal cell:\\n\\n```python\\ndef get_goal_function(grid):\\n    \"\"\"\\n    >>> f = get_goal_function([[0, 0], [0, 0]])\\n    >>> f((0, 0))\\n    False\\n    >>> f((0, 1))\\n    False\\n    >>> f((1, 1))\\n    True\\n    \"\"\"\\n    M = len(grid)\\n    N = len(grid[0])\\n    def is_bottom_right(cell):\\n        return cell == (M-1, N-1)\\n    return is_bottom_right\\n```\\n\\n## Successor function\\n\\nWe also need a function to find the cells adjacent to the current cell:\\n\\n```python\\ndef get_successor_function(grid):\\n    \"\"\"\\n    >>> f = get_successor_function([[0, 0, 0], [0, 1, 0], [1, 0, 0]])\\n    >>> sorted(f((1, 2)))\\n    [(0, 1), (0, 2), (2, 1), (2, 2)]\\n    >>> sorted(f((2, 1)))\\n    [(1, 0), (1, 2), (2, 2)]\\n    \"\"\"\\n    def get_clear_adjacent_cells(cell):\\n        i, j = cell\\n        return (\\n            (i + a, j + b)\\n            for a in (-1, 0, 1)\\n            for b in (-1, 0, 1)\\n            if a != 0 or b != 0\\n            if 0 <= i + a < len(grid)\\n            if 0 <= j + b < len(grid[0])\\n            if grid[i + a][j + b] == 0\\n        )\\n    return get_clear_adjacent_cells\\n```\\n\\n## Heuristic\\n\\nThe chosen heuristic is simply the distance to the goal in a clear grid of the same size. This turns out to be the maximum of the x-distance and y-distance from the goal. This heuristic is [admissible](https://en.wikipedia.org/wiki/Admissible_heuristic) and [consistent](https://en.wikipedia.org/wiki/Consistent_heuristic).\\n\\n```python\\ndef get_heuristic(grid):\\n    \"\"\"\\n    >>> f = get_heuristic([[0, 0], [0, 0]])\\n    >>> f((0, 0))\\n    1\\n    >>> f((0, 1))\\n    1\\n    >>> f((1, 1))\\n    0\\n    \"\"\"\\n    M, N = len(grid), len(grid[0])\\n    (a, b) = goal_cell = (M - 1, N - 1)\\n    def get_clear_path_distance_from_goal(cell):\\n        (i, j) = cell\\n        return max(abs(a - i), abs(b - j))\\n    return get_clear_path_distance_from_goal\\n```\\n\\n## Priority queue\\n\\nThe Python standard library provides a heap data structure, but not a priority-queue, so we need to implement one ourselves.\\n\\n```python\\nfrom heapq import heappush, heappop\\n\\nclass PriorityQueue:\\n    \\n    def __init__(self, iterable=[]):\\n        self.heap = []\\n        for value in iterable:\\n            heappush(self.heap, (0, value))\\n    \\n    def add(self, value, priority=0):\\n        heappush(self.heap, (priority, value))\\n    \\n    def pop(self):\\n        priority, value = heappop(self.heap)\\n        return value\\n    \\n    def __len__(self):\\n        return len(self.heap)\\n```\\n\\nAnd that\\'s it. \\n\\n# Breadth-first search\\n\\nHere is a breadth-first-search implementation, for comparison:\\n\\n```python\\nfrom collections import deque\\n\\ndef breadth_first_search(grid):\\n    N = len(grid)\\n\\n    def is_clear(cell):\\n        return grid[cell[0]][cell[1]] == 0\\n\\n    def get_neighbours(cell):\\n        (i, j) = cell\\n        return (\\n            (i + a, j + b)\\n            for a in (-1, 0, 1)\\n            for b in (-1, 0, 1)\\n            if a != 0 or b != 0\\n            if 0 <= i + a < N\\n            if 0 <= j + b < N\\n            if is_clear( (i + a, j + b) )\\n        )\\n\\n    start = (0, 0)\\n    goal = (N - 1, N - 1)\\n\\n    queue = deque()\\n    if is_clear(start):\\n        queue.append(start)\\n    visited = set()\\n    path_len = {start: 1}\\n\\n    while queue:\\n        cell = queue.popleft()\\n        if cell in visited:\\n            continue\\n        if cell == goal:\\n            return path_len[cell]\\n        visited.add(cell)\\n        for neighbour in get_neighbours(cell):\\n            if neighbour not in path_len:\\n                path_len[neighbour] = path_len[cell] + 1\\n            queue.append(neighbour)\\n\\n    return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n[\\n\\t[0,0,0,1,0,0,1,0],\\n\\t[0,0,0,0,0,0,0,0],\\n\\t[1,0,0,1,1,0,1,0],\\n\\t[0,1,1,1,0,0,0,0],\\n\\t[0,0,0,0,0,1,1,1],\\n\\t[1,0,1,0,0,0,0,0],\\n\\t[1,1,0,0,0,1,0,0],\\n\\t[0,0,0,0,0,1,0,0]\\n]\\n```\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid):\\n        shortest_path = a_star_graph_search(\\n            start              = (0, 0), \\n            goal_function      = get_goal_function(grid),\\n            successor_function = get_successor_function(grid),\\n            heuristic          = get_heuristic(grid)\\n        )\\n        if shortest_path is None or grid[0][0] == 1:\\n            return -1\\n        else:\\n            return len(shortest_path)\\n```\n```python\\ndef a_star_graph_search(\\n            start,\\n            goal_function,\\n            successor_function,\\n            heuristic\\n\\t):\\n    visited = set()\\n    came_from = dict()\\n    distance = {start: 0}\\n    frontier = PriorityQueue()\\n    frontier.add(start)\\n    while frontier:\\n        node = frontier.pop()\\n        if node in visited:\\n            continue\\n        if goal_function(node):\\n            return reconstruct_path(came_from, start, node)\\n        visited.add(node)\\n        for successor in successor_function(node):\\n            frontier.add(\\n                successor,\\n                priority = distance[node] + 1 + heuristic(successor)\\n            )\\n            if (successor not in distance\\n                or distance[node] + 1 < distance[successor]):\\n                distance[successor] = distance[node] + 1\\n                came_from[successor] = node\\n    return None\\n\\ndef reconstruct_path(came_from, start, end):\\n    \"\"\"\\n    >>> came_from = {\\'b\\': \\'a\\', \\'c\\': \\'a\\', \\'d\\': \\'c\\', \\'e\\': \\'d\\', \\'f\\': \\'d\\'}\\n    >>> reconstruct_path(came_from, \\'a\\', \\'e\\')\\n    [\\'a\\', \\'c\\', \\'d\\', \\'e\\']\\n    \"\"\"\\n    reverse_path = [end]\\n    while end != start:\\n        end = came_from[end]\\n        reverse_path.append(end)\\n    return list(reversed(reverse_path))\\n```\n```python\\ndef get_goal_function(grid):\\n    \"\"\"\\n    >>> f = get_goal_function([[0, 0], [0, 0]])\\n    >>> f((0, 0))\\n    False\\n    >>> f((0, 1))\\n    False\\n    >>> f((1, 1))\\n    True\\n    \"\"\"\\n    M = len(grid)\\n    N = len(grid[0])\\n    def is_bottom_right(cell):\\n        return cell == (M-1, N-1)\\n    return is_bottom_right\\n```\n```python\\ndef get_successor_function(grid):\\n    \"\"\"\\n    >>> f = get_successor_function([[0, 0, 0], [0, 1, 0], [1, 0, 0]])\\n    >>> sorted(f((1, 2)))\\n    [(0, 1), (0, 2), (2, 1), (2, 2)]\\n    >>> sorted(f((2, 1)))\\n    [(1, 0), (1, 2), (2, 2)]\\n    \"\"\"\\n    def get_clear_adjacent_cells(cell):\\n        i, j = cell\\n        return (\\n            (i + a, j + b)\\n            for a in (-1, 0, 1)\\n            for b in (-1, 0, 1)\\n            if a != 0 or b != 0\\n            if 0 <= i + a < len(grid)\\n            if 0 <= j + b < len(grid[0])\\n            if grid[i + a][j + b] == 0\\n        )\\n    return get_clear_adjacent_cells\\n```\n```python\\ndef get_heuristic(grid):\\n    \"\"\"\\n    >>> f = get_heuristic([[0, 0], [0, 0]])\\n    >>> f((0, 0))\\n    1\\n    >>> f((0, 1))\\n    1\\n    >>> f((1, 1))\\n    0\\n    \"\"\"\\n    M, N = len(grid), len(grid[0])\\n    (a, b) = goal_cell = (M - 1, N - 1)\\n    def get_clear_path_distance_from_goal(cell):\\n        (i, j) = cell\\n        return max(abs(a - i), abs(b - j))\\n    return get_clear_path_distance_from_goal\\n```\n```python\\nfrom heapq import heappush, heappop\\n\\nclass PriorityQueue:\\n    \\n    def __init__(self, iterable=[]):\\n        self.heap = []\\n        for value in iterable:\\n            heappush(self.heap, (0, value))\\n    \\n    def add(self, value, priority=0):\\n        heappush(self.heap, (priority, value))\\n    \\n    def pop(self):\\n        priority, value = heappop(self.heap)\\n        return value\\n    \\n    def __len__(self):\\n        return len(self.heap)\\n```\n```python\\nfrom collections import deque\\n\\ndef breadth_first_search(grid):\\n    N = len(grid)\\n\\n    def is_clear(cell):\\n        return grid[cell[0]][cell[1]] == 0\\n\\n    def get_neighbours(cell):\\n        (i, j) = cell\\n        return (\\n            (i + a, j + b)\\n            for a in (-1, 0, 1)\\n            for b in (-1, 0, 1)\\n            if a != 0 or b != 0\\n            if 0 <= i + a < N\\n            if 0 <= j + b < N\\n            if is_clear( (i + a, j + b) )\\n        )\\n\\n    start = (0, 0)\\n    goal = (N - 1, N - 1)\\n\\n    queue = deque()\\n    if is_clear(start):\\n        queue.append(start)\\n    visited = set()\\n    path_len = {start: 1}\\n\\n    while queue:\\n        cell = queue.popleft()\\n        if cell in visited:\\n            continue\\n        if cell == goal:\\n            return path_len[cell]\\n        visited.add(cell)\\n        for neighbour in get_neighbours(cell):\\n            if neighbour not in path_len:\\n                path_len[neighbour] = path_len[cell] + 1\\n            queue.append(neighbour)\\n\\n    return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312827,
                "title": "python-concise-bfs",
                "content": "Since it\\'s BFS, we can securely set the visited grid as non-empty to avoid revisiting.\\n```\\ndef shortestPathBinaryMatrix(grid):\\n\\tn = len(grid)\\n\\tif grid[0][0] or grid[n-1][n-1]:\\n\\t\\treturn -1\\n\\tq = [(0, 0, 1)]\\n\\tgrid[0][0] = 1\\n\\tfor i, j, d in q:\\n\\t\\tif i == n-1 and j == n-1: return d\\n\\t\\tfor x, y in ((i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)):\\n\\t\\t\\tif 0 <= x < n and 0 <= y < n and not grid[x][y]:\\n\\t\\t\\t\\tgrid[x][y] = 1\\n\\t\\t\\t\\tq.append((x, y, d+1))\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef shortestPathBinaryMatrix(grid):\\n\\tn = len(grid)\\n\\tif grid[0][0] or grid[n-1][n-1]:\\n\\t\\treturn -1\\n\\tq = [(0, 0, 1)]\\n\\tgrid[0][0] = 1\\n\\tfor i, j, d in q:\\n\\t\\tif i == n-1 and j == n-1: return d\\n\\t\\tfor x, y in ((i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)):\\n\\t\\t\\tif 0 <= x < n and 0 <= y < n and not grid[x][y]:\\n\\t\\t\\t\\tgrid[x][y] = 1\\n\\t\\t\\t\\tq.append((x, y, d+1))\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 667137,
                "title": "why-does-dp-not-work",
                "content": "When I approached this problem, I first thought it was a dp problem and found what I thought to be a dp formula:\\n1. dp[0][0] = 1 if grid[0][0] == 0, else infinity/INT_MAX\\n2. dp[i][j] = infinity/INT_MAX if grid[i][j] == 1, else min of it\\'s surrounding neighbors + 1\\n\\nAt the end, return the value at dp[-1][-1] if it is a finite number, else return -1.\\nMy thinking was that for every cell except top left, the number of steps it takes to reach that cell is the minimum of its neighbor + 1 if it\\'s reachable\\n\\nHere is the Python implementation below:\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        dp = [[float(\\'inf\\')] * len(grid[0]) for _ in range(len(grid))]\\n        \\n        def valid(i, j):\\n            return 0 <= i and i < len(grid) and 0 <= j and j < len(grid[row])\\n\\n        def helper(row, col):\\n            i = row - 1\\n            res = float(\\'inf\\')\\n            while i <= row + 1:\\n                j = col - 1\\n                while j <= col + 1:\\n                    if valid(i, j):\\n                        res = min(dp[i][j], res)\\n                    j += 1\\n                i += 1\\n            return res\\n        \\n        if grid[0][0] == 0:\\n            dp[0][0] = 1       \\n        for row in range(len(dp)):\\n            for col in range(len(dp[row])):\\n                if row == 0 and col == 0:\\n                    continue\\n                if grid[row][col] == 0:\\n                    dp[row][col] = helper(row, col) + 1\\n        \\n        return -1 if dp[-1][-1] == float(\\'inf\\') else dp[-1][-1]\\n```\\n\\nIt passes 82/84 test cases and fails https://leetcode.com/submissions/detail/348206665/testcase/, returning -1 when it should return 146. With a test case that big, I can\\'t possibly go through the test case and see where it is going wrong. Can someone explain why my approach doesn\\'t work?",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        dp = [[float(\\'inf\\')] * len(grid[0]) for _ in range(len(grid))]\\n        \\n        def valid(i, j):\\n            return 0 <= i and i < len(grid) and 0 <= j and j < len(grid[row])\\n\\n        def helper(row, col):\\n            i = row - 1\\n            res = float(\\'inf\\')\\n            while i <= row + 1:\\n                j = col - 1\\n                while j <= col + 1:\\n                    if valid(i, j):\\n                        res = min(dp[i][j], res)\\n                    j += 1\\n                i += 1\\n            return res\\n        \\n        if grid[0][0] == 0:\\n            dp[0][0] = 1       \\n        for row in range(len(dp)):\\n            for col in range(len(dp[row])):\\n                if row == 0 and col == 0:\\n                    continue\\n                if grid[row][col] == 0:\\n                    dp[row][col] = helper(row, col) + 1\\n        \\n        return -1 if dp[-1][-1] == float(\\'inf\\') else dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312706,
                "title": "java-bfs",
                "content": "```\\nprivate int dir[][] = new int[][]{{0,1},{0,-1},{1,0},{-1,0},{1,-1},{-1,1},{-1,-1},{1,1}};\\n\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        if(grid[0][0]==1 || grid[m-1][n-1]==1) {\\n            return -1;\\n        }\\n\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n\\n        int ans=0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i=0;i<size;i++) {\\n                int[] pop = queue.remove();\\n                if(pop[0]==m-1 && pop[1]==n-1) {\\n                    return ans+1;\\n                }\\n                for (int k=0;k<8;k++) {\\n                    int nextX = dir[k][0]+pop[0];\\n                    int nextY = dir[k][1]+pop[1];\\n\\n                    if(nextX>=0 && nextX<m && nextY>=0 && nextY<n && !visited[nextX][nextY] && grid[nextX][nextY]==0) {\\n                        queue.add(new int[]{nextX,nextY});\\n                        visited[nextX][nextY]=true;\\n                    }\\n\\n                }\\n            }\\n            ans++;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate int dir[][] = new int[][]{{0,1},{0,-1},{1,0},{-1,0},{1,-1},{-1,1},{-1,-1},{1,1}};\\n\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        if(grid[0][0]==1 || grid[m-1][n-1]==1) {\\n            return -1;\\n        }\\n\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n\\n        int ans=0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i=0;i<size;i++) {\\n                int[] pop = queue.remove();\\n                if(pop[0]==m-1 && pop[1]==n-1) {\\n                    return ans+1;\\n                }\\n                for (int k=0;k<8;k++) {\\n                    int nextX = dir[k][0]+pop[0];\\n                    int nextY = dir[k][1]+pop[1];\\n\\n                    if(nextX>=0 && nextX<m && nextY>=0 && nextY<n && !visited[nextX][nextY] && grid[nextX][nextY]==0) {\\n                        queue.add(new int[]{nextX,nextY});\\n                        visited[nextX][nextY]=true;\\n                    }\\n\\n                }\\n            }\\n            ans++;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 312814,
                "title": "simple-bfs-c",
                "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 1;\\n        int row = grid.size();\\n        if (row == 0) return -1;\\n        int col = grid[0].size();\\n        if (col == 0 ) return -1;\\n        if (grid[0][0] != 0 | grid[row-1][col-1] != 0) return -1;\\n        \\n        queue<pair<int, int>> queue;\\n        queue.push(make_pair(0,0));\\n        vector<vector<int>> directions = {{1,1}, {0,1},{1,0},{0,-1},{-1,0},{-1, -1},{1, -1},{-1, 1}};\\n        grid[0][0] = 1;\\n        while(!queue.empty()){\\n            auto curr = queue.front();\\n            int x = curr.first, y = curr.second;\\n            if( x == row -1 && y == col -1) return grid[x][y];\\n            \\n            for(auto direction : directions){\\n                int nx = x + direction[0];\\n                int ny = y + direction[1];\\n                if(nx >= 0 && nx < row && ny >= 0 && ny < col && grid[nx][ny] == 0){\\n                    queue.push(make_pair(nx,ny));\\n                    grid[nx][ny] = grid[x][y] + 1;\\n                }\\n            }\\n            queue.pop();\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 1;\\n        int row = grid.size();\\n        if (row == 0) return -1;\\n        int col = grid[0].size();\\n        if (col == 0 ) return -1;\\n        if (grid[0][0] != 0 | grid[row-1][col-1] != 0) return -1;\\n        \\n        queue<pair<int, int>> queue;\\n        queue.push(make_pair(0,0));\\n        vector<vector<int>> directions = {{1,1}",
                "codeTag": "Java"
            },
            {
                "id": 1063734,
                "title": "c-optimised-bfs-vs-dfs-fastest-solution-to-date-100-time-35ms-99-space-18-3mb",
                "content": "Handbook maze exploration problem and we know we might be better served with a BFS in this case; and if you want to practice more of it, please also [check this somehow similar problem](https://leetcode.com/problems/is-graph-bipartite/), that I discussed [here](https://leetcode.com/problems/is-graph-bipartite/discuss/1065215/).\\n\\nTo do so, we will first of all rule out the edge case in which either the start or target cell are unreachable, to save needless computation and be sure later of some loop invariants.\\n\\nIf that was not the case, then we will declare a few support variables:\\n* `res`, initialised to `2`, since it would normally at least take 2 steps to move from start to target;\\n* `len`, the length of our queue, preset to the value of `1`;\\n* `maxX` and `maxY` as the extremes of our grid (I know it is a square one, but allow me to immolate a couple of bytes to make this solution more general);\\n* `q`, a queue of pairs of integers representing the coordinates and that we will initially set to contain the starting point, pushing `{0, 0}` into it, provided we are not in a single cell maze.\\n\\nIf that is the case (`!maxX && !maxY`), we will then return `1 - (grid[0][0] << 1)`, which is just a cool way to write `grid[0][0] ? -1 : 1`, which in turn means we will have the edge case of a single step only if our single cell is empty, impossible path (`-1`) otherwise.\\n\\nIf that was not the case, we will also then mark the first cell as visited and move on with our main BFS loop, that will run as long as we have elements in the queue (`len !=0`) and that will:\\n* have another inner loop running `len` times in which we:\\n\\t* extract `cx` and `cy` from the top of the queue;\\n\\t* pop the top;\\n\\t* use `cx` and `cy` to loop around all the neighbours, setting the initial value of `x` and `y` to the the maximum between `0` and the current value (`cx` or `cy`, respectively) `- 1`, and the upper limit of the loop as the minimum value between the current value `+ 1` and either `maxX` or `maxY`, included, then:\\n\\t\\t* we computed `maxX` and `maxY` smaller than one step from the actual size to have an easier life here - we will return `res` when `x == maxX && y == maxY` - meaning we reached the target;\\n\\t\\t* alternatively, we will check if `grid[y][x]` is still unexplored and if so, we will mark it and push it into q for the the next loop;\\n* increase `res` by `1`;\\n* update `len` with the current length of the queue.\\n\\nIf we leave the loop, it means no path was found, so we can safely return `-1` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        // support variables\\n        int res = 2, len = 1, maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        queue<pair<int, int>> q;\\n        // edge case: single cell matrix\\n        if (!maxX && !maxY) return 1 - (grid[0][0] << 1);\\n        // adding the starting point\\n        q.push({0, 0});\\n        // marking start as visited\\n        grid[0][0] = -1;\\n        while (len) {\\n            while (len--) {\\n                // reading and popping the coordinates on the front of the queue\\n                auto [cx, cy] = q.front();\\n                q.pop();\\n                for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n                    for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                        // check if we reached the target\\n                        if (x == maxX && y == maxY) return res;\\n                        // marking it as visited and adding it to the q if it was still a valid cell\\n                        if (!grid[y][x]) {\\n                            grid[y][x] = -1;\\n                            q.push({x, y});\\n                        }\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            len = q.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThe brag \\uD83D\\uDE0E :\\n\\n![image](https://assets.leetcode.com/users/images/f0252a59-1383-4aa0-b90a-791f18aac0cc_1613219437.2042842.png)\\n\\nThe fun - getting it with also with a backtracking DFS!\\n\\nLet me anticipate that it just TLEs on bigger maps, but it was still nice to practice with it.\\n\\nNotice that we moved all the support variables to be private class variables and we do need also some less logic to handle edge cases in our main function, which is now limited to assigning values to both `maxX` and `maxY`, then computing the shortest path.\\n\\nMost of the logic goes into our `dfs` helper that will first of all return the current value of  our coordinates and, if they are the ones of the target, then we just  `return res`; otherwise, we:\\n* declare `partRes` as `INT_MAX`;\\n* mark the current cell as visited;\\n* increase `res` by one;\\n* loop through all the visitable adjacent cells and, for each available one, call `dfs` on it and assigning to `partRes` the smaller value between the current one and what was found on that path;\\n* finally we backtrack, specularly to our first operations, unmarking the current cell as visited and\\n* decreasing `res` by `1`.\\n\\nBack in our main function, we overwrite `res` with the final result and return `-1` if it is still `INT_MAX` (ie: no paths found), `res` itself otherwise :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    // support variables\\n    int maxX, maxY, res = 1;\\n    int dfs(vector<vector<int>>& grid, int cx = 0, int cy = 0) {\\n        // check if we reached the target\\n        if (cx == maxX && cy == maxY) return res;\\n        // support variable\\n        int partRes = INT_MAX;\\n        // marking the cell as visited and increasing res\\n        grid[cy][cx] = -1;\\n        res++;\\n        for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n            for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                if (!grid[y][x]) {\\n                    partRes = min(partRes, dfs(grid, x, y));\\n                }\\n            }\\n        }\\n        // backtracking the cell as non-visited and decreasing res\\n        grid[cy][cx] = 0;\\n        res--;\\n        return partRes;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // searching from the starting point\\n        res = dfs(grid);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```\\n\\nI guess we might have had a better luck with a double-ended BFS, moving to diagonals first and stopping as soon as we find a path, though\\uD83E\\uDD14\\n\\nEdit: no, going through diagonal first fails - consider this case for example: `[[0,0,0],[0,1,0],[0,0,0]]`; and then run it with this code:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    // support variables\\n    int maxX, maxY, res = 1, x, y;\\n    bool found = false;\\n    pair<int, int> dirs[8] = {{1, 1}, {-1, 1}, {1, -1}, {-1, -1}, {0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    void dfs(vector<vector<int>>& grid, int cx = 0, int cy = 0) {\\n        // check if we reached the target\\n        if (cx == maxX && cy == maxY) {\\n            found = true;\\n            return;\\n        }\\n        // marking the cell as visited and increasing res\\n        res++;\\n        grid[cy][cx] = -1;\\n        for (auto dir: dirs) {\\n            x = cx + dir.first, y = cy + dir.second;\\n            if (x >= 0 && x <= maxX && y >= 0 && y <= maxY && !grid[y][x]) {\\n                dfs(grid, x, y);\\n                if (found) return;\\n            }\\n        }\\n        // backtracking the cell as non-visited and decreasing res\\n        grid[cy][cx] = 0;\\n        res--;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // searching from the starting point\\n        dfs(grid);\\n        return found ? res : -1;\\n    }\\n};\\n```\\n\\nTo fix it would require going back to that cumbersome, heavy backtracking we had above.\\n\\nThe double BFS idea worked better instead and it allowed me to improve both performance and memory usage - same logic as the first example, but despite using 2 queues, we end up filling them up less:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        // support variables\\n        int res = 2, len = 1, maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        queue<pair<int, int>> q1, q2;\\n        bool isStartTurn = true;\\n        // edge case: single cell matrix\\n        if (!maxX && !maxY) return 1 - (grid[0][0] << 1);\\n        // adding the start and ending points\\n        q1.push({0, 0});\\n        q2.push({maxX, maxY});\\n        // marking start and ending points as visited\\n        grid[0][0] = -1;\\n        grid[maxY][maxX] = -2;\\n        while (len) {\\n            while (len--) {\\n                // reading and popping the coordinates on the front of the queue\\n                auto [cx, cy] = (isStartTurn ? q1 : q2).front();\\n                (isStartTurn ? q1 : q2).pop();\\n                for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n                    for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                        // check if we reached an already visited cell fromm the other side\\n                        if (grid[y][x] == (isStartTurn ? -2 : -1)) return res;\\n                        // marking it as visited and adding it to the q if it was still a valid cell\\n                        if (!grid[y][x]) {\\n                            grid[y][x] = isStartTurn ? -1 : -2;\\n                            (isStartTurn ? q1 : q2).push({x, y});\\n                        }\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            isStartTurn = !isStartTurn;\\n            len = (isStartTurn ? q1 : q2).size();\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nToday I forgot I did this already, so I re-coded it from scratch, trying to optimise it in the computation of adjacent cells, going for diagonal firsts, marking them immediately as explored and thus not storing duplicated cells in my queue; it worked pretty well, despite some verbose/duplicated code to check only the necessary condition for out of boundaries cases:\\n\\n```cpp\\nusing pathType = pair<int, int>;\\n\\nclass Solution {\\n    void markAndAdd(vector<vector<int>> &grid, queue<pathType> &q, int x, int y) {\\n        // marking the current node as visited and adding it to q\\n        grid[y][x] = 1;\\n        q.push({x, y});\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid) {\\n        int res = 0, t = grid.size() - 1, qLen = 1, cx, cy, x, y;\\n        if (grid[0][0] || grid[t][t]) return -1;\\n        queue<pathType> q{{{0, 0}}};\\n        // marking the start as visited\\n        grid[0][0] = 1;\\n        while (qLen) {\\n            res++;\\n            // increasing the counter\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                auto &front = q.front();\\n                cx = front.first;\\n                cy = front.second;\\n                // checking if we had a match\\n                if (cx == t && cy == t) return res;\\n                q.pop();\\n                // adding adjacent unexplored nodes to the queue\\n                // diagonals:\\n                // upper left\\n                x = cx - 1, y = cy - 1;\\n                if (x >= 0 && y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // upper right\\n                x = cx + 1;\\n                if (x <= t && y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower right\\n                y = cy + 1;\\n                if (x <= t && y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower left\\n                x = cx - 1;\\n                if (x >= 0 && y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // adjacent ones:\\n                // mid left\\n                y = cy;\\n                if (x >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // mid right\\n                x = cx + 1;\\n                if (x <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // upper mid\\n                x = cx, y = cy - 1;\\n                if (y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower mid\\n                y = cy + 1;\\n                if (y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n            }\\n            qLen = q.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nBut, wait a moment... We had that sweet double ended BFS idea in mind, right?\\n\\nWell, turns out it works even better with my uber-optimised solutions; and since one year ago, I can do even better, just avoiding painful ternary operators all the time and just swapping queues and markers as we go; `res` is also initialised to be `1` (since we already do one extra step marking `{t, t}` too), unless `t == 0`.\\n\\nThe updated code:\\n\\n```cpp\\nusing pathType = pair<int, int>;\\n\\nclass Solution {\\n    int startMark = -1, endMark = -2;\\n    queue<pathType> q1{{{0, 0}}}, q2;\\n    void markAndAdd(vector<vector<int>> &grid, int x, int y) {\\n        // marking the current node as visited and adding it to q\\n        grid[y][x] = startMark;\\n        q1.push({x, y});\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid) {\\n        int t = grid.size() - 1, res = bool(t), qLen = 1, cx, cy, x, y, currVal;\\n        if (grid[0][0] || grid[t][t]) return -1;\\n        // marking the start end end as visited\\n        q2.push({t, t});\\n        grid[0][0] = startMark;\\n        grid[t][t] = endMark;\\n        while (qLen) {\\n            // increasing the counter\\n            res++;\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                auto &front = q1.front();\\n                cx = front.first;\\n                cy = front.second;\\n                // checking if we had a match\\n                if (grid[cy][cx] == endMark) return res;\\n                q1.pop();\\n                // adding adjacent unexplored nodes to the queue\\n                // diagonals:\\n                // upper left\\n                x = cx - 1, y = cy - 1;\\n                if (x >= 0 && y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // upper right\\n                x = cx + 1;\\n                if (x <= t && y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower right\\n                y = cy + 1;\\n                if (x <= t && y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower left\\n                x = cx - 1;\\n                if (x >= 0 && y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // adjacent ones:\\n                // mid left\\n                y = cy;\\n                if (x >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // mid right\\n                x = cx + 1;\\n                if (x <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // upper mid\\n                x = cx, y = cy - 1;\\n                if (y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower mid\\n                y = cy + 1;\\n                if (y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n            }\\n            swap(q1, q2);\\n            swap(startMark, endMark);\\n            qLen = q1.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThe updated brag:\\n![image](https://assets.leetcode.com/users/images/a6d26f34-fb51-43d4-b962-dd30df623ff1_1652735140.3896632.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        // support variables\\n        int res = 2, len = 1, maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        queue<pair<int, int>> q;\\n        // edge case: single cell matrix\\n        if (!maxX && !maxY) return 1 - (grid[0][0] << 1);\\n        // adding the starting point\\n        q.push({0, 0});\\n        // marking start as visited\\n        grid[0][0] = -1;\\n        while (len) {\\n            while (len--) {\\n                // reading and popping the coordinates on the front of the queue\\n                auto [cx, cy] = q.front();\\n                q.pop();\\n                for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n                    for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                        // check if we reached the target\\n                        if (x == maxX && y == maxY) return res;\\n                        // marking it as visited and adding it to the q if it was still a valid cell\\n                        if (!grid[y][x]) {\\n                            grid[y][x] = -1;\\n                            q.push({x, y});\\n                        }\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            len = q.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    // support variables\\n    int maxX, maxY, res = 1;\\n    int dfs(vector<vector<int>>& grid, int cx = 0, int cy = 0) {\\n        // check if we reached the target\\n        if (cx == maxX && cy == maxY) return res;\\n        // support variable\\n        int partRes = INT_MAX;\\n        // marking the cell as visited and increasing res\\n        grid[cy][cx] = -1;\\n        res++;\\n        for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n            for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                if (!grid[y][x]) {\\n                    partRes = min(partRes, dfs(grid, x, y));\\n                }\\n            }\\n        }\\n        // backtracking the cell as non-visited and decreasing res\\n        grid[cy][cx] = 0;\\n        res--;\\n        return partRes;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // searching from the starting point\\n        res = dfs(grid);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    // support variables\\n    int maxX, maxY, res = 1, x, y;\\n    bool found = false;\\n    pair<int, int> dirs[8] = {{1, 1}, {-1, 1}, {1, -1}, {-1, -1}, {0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    void dfs(vector<vector<int>>& grid, int cx = 0, int cy = 0) {\\n        // check if we reached the target\\n        if (cx == maxX && cy == maxY) {\\n            found = true;\\n            return;\\n        }\\n        // marking the cell as visited and increasing res\\n        res++;\\n        grid[cy][cx] = -1;\\n        for (auto dir: dirs) {\\n            x = cx + dir.first, y = cy + dir.second;\\n            if (x >= 0 && x <= maxX && y >= 0 && y <= maxY && !grid[y][x]) {\\n                dfs(grid, x, y);\\n                if (found) return;\\n            }\\n        }\\n        // backtracking the cell as non-visited and decreasing res\\n        grid[cy][cx] = 0;\\n        res--;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // searching from the starting point\\n        dfs(grid);\\n        return found ? res : -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        // support variables\\n        int res = 2, len = 1, maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        queue<pair<int, int>> q1, q2;\\n        bool isStartTurn = true;\\n        // edge case: single cell matrix\\n        if (!maxX && !maxY) return 1 - (grid[0][0] << 1);\\n        // adding the start and ending points\\n        q1.push({0, 0});\\n        q2.push({maxX, maxY});\\n        // marking start and ending points as visited\\n        grid[0][0] = -1;\\n        grid[maxY][maxX] = -2;\\n        while (len) {\\n            while (len--) {\\n                // reading and popping the coordinates on the front of the queue\\n                auto [cx, cy] = (isStartTurn ? q1 : q2).front();\\n                (isStartTurn ? q1 : q2).pop();\\n                for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n                    for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                        // check if we reached an already visited cell fromm the other side\\n                        if (grid[y][x] == (isStartTurn ? -2 : -1)) return res;\\n                        // marking it as visited and adding it to the q if it was still a valid cell\\n                        if (!grid[y][x]) {\\n                            grid[y][x] = isStartTurn ? -1 : -2;\\n                            (isStartTurn ? q1 : q2).push({x, y});\\n                        }\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            isStartTurn = !isStartTurn;\\n            len = (isStartTurn ? q1 : q2).size();\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nusing pathType = pair<int, int>;\\n\\nclass Solution {\\n    void markAndAdd(vector<vector<int>> &grid, queue<pathType> &q, int x, int y) {\\n        // marking the current node as visited and adding it to q\\n        grid[y][x] = 1;\\n        q.push({x, y});\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid) {\\n        int res = 0, t = grid.size() - 1, qLen = 1, cx, cy, x, y;\\n        if (grid[0][0] || grid[t][t]) return -1;\\n        queue<pathType> q{{{0, 0}}};\\n        // marking the start as visited\\n        grid[0][0] = 1;\\n        while (qLen) {\\n            res++;\\n            // increasing the counter\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                auto &front = q.front();\\n                cx = front.first;\\n                cy = front.second;\\n                // checking if we had a match\\n                if (cx == t && cy == t) return res;\\n                q.pop();\\n                // adding adjacent unexplored nodes to the queue\\n                // diagonals:\\n                // upper left\\n                x = cx - 1, y = cy - 1;\\n                if (x >= 0 && y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // upper right\\n                x = cx + 1;\\n                if (x <= t && y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower right\\n                y = cy + 1;\\n                if (x <= t && y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower left\\n                x = cx - 1;\\n                if (x >= 0 && y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // adjacent ones:\\n                // mid left\\n                y = cy;\\n                if (x >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // mid right\\n                x = cx + 1;\\n                if (x <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // upper mid\\n                x = cx, y = cy - 1;\\n                if (y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower mid\\n                y = cy + 1;\\n                if (y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n            }\\n            qLen = q.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nusing pathType = pair<int, int>;\\n\\nclass Solution {\\n    int startMark = -1, endMark = -2;\\n    queue<pathType> q1{{{0, 0}}}, q2;\\n    void markAndAdd(vector<vector<int>> &grid, int x, int y) {\\n        // marking the current node as visited and adding it to q\\n        grid[y][x] = startMark;\\n        q1.push({x, y});\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid) {\\n        int t = grid.size() - 1, res = bool(t), qLen = 1, cx, cy, x, y, currVal;\\n        if (grid[0][0] || grid[t][t]) return -1;\\n        // marking the start end end as visited\\n        q2.push({t, t});\\n        grid[0][0] = startMark;\\n        grid[t][t] = endMark;\\n        while (qLen) {\\n            // increasing the counter\\n            res++;\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                auto &front = q1.front();\\n                cx = front.first;\\n                cy = front.second;\\n                // checking if we had a match\\n                if (grid[cy][cx] == endMark) return res;\\n                q1.pop();\\n                // adding adjacent unexplored nodes to the queue\\n                // diagonals:\\n                // upper left\\n                x = cx - 1, y = cy - 1;\\n                if (x >= 0 && y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // upper right\\n                x = cx + 1;\\n                if (x <= t && y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower right\\n                y = cy + 1;\\n                if (x <= t && y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower left\\n                x = cx - 1;\\n                if (x >= 0 && y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // adjacent ones:\\n                // mid left\\n                y = cy;\\n                if (x >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // mid right\\n                x = cx + 1;\\n                if (x <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // upper mid\\n                x = cx, y = cy - 1;\\n                if (y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower mid\\n                y = cy + 1;\\n                if (y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n            }\\n            swap(q1, q2);\\n            swap(startMark, endMark);\\n            qLen = q1.size();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312711,
                "title": "c-bfs",
                "content": "BFS gives us the shortest path, so we will just do that.\\n```\\nint shortestPathBinaryMatrix(vector<vector<int>>& g, int steps = 0) {\\n  queue<pair<int, int>> q;\\n  q.push({ 0, 0 });\\n  while (!q.empty()) {\\n    ++steps;\\n    queue<pair<int, int>> q1;\\n    while (!q.empty()) {\\n      auto c = q.front();\\n      q.pop();\\n      if (c.first >= 0 && c.second >= 0 && c.first < g.size() && c.second < g.size() && !g[c.first][c.second]) {\\n        g[c.first][c.second] = 1;\\n        if (c.first == g.size() - 1 && c.second == g.size() - 1) return steps;\\n        for (auto i = -1; i < 2; ++i)\\n          for (auto j = -1; j < 2; ++j)\\n            if (i != 0 || j != 0) q1.push({ c.first + i, c.second + j });\\n      }\\n    }\\n    swap(q, q1);\\n  }\\n  return -1;\\n}\\n```\\nWe can also check the coordinates before adding them to the queue; it can save some memory and runtinme:\\n```\\nint shortestPathBinaryMatrix(vector<vector<int>>& g, int steps = 0) {\\n  queue<pair<int, int>> q;\\n  q.push({ 0, 0 });\\n  while (!q.empty()) {\\n    ++steps;\\n    queue<pair<int, int>> q1;\\n    while (!q.empty()) {\\n      auto c = q.front();\\n      q.pop();\\n      if (exchange(g[c.first][c.second], 1) == 1) continue;\\n      if (c.first == g.size() - 1 && c.second == g.size() - 1) return steps;\\n      for (auto i = c.first - 1; i <= c.first + 1; ++i)\\n        for (auto j = c.second - 1; j <= c.second + 1; ++j)\\n          if (i != c.first || j != c.second) {\\n            if (i >= 0 && j >= 0 && i < g.size() && j < g.size() && !g[i][j]) {\\n              q1.push({ i, j });\\n            }\\n          }\\n    }\\n    swap(q, q1);\\n  }\\n  return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint shortestPathBinaryMatrix(vector<vector<int>>& g, int steps = 0) {\\n  queue<pair<int, int>> q;\\n  q.push({ 0, 0 });\\n  while (!q.empty()) {\\n    ++steps;\\n    queue<pair<int, int>> q1;\\n    while (!q.empty()) {\\n      auto c = q.front();\\n      q.pop();\\n      if (c.first >= 0 && c.second >= 0 && c.first < g.size() && c.second < g.size() && !g[c.first][c.second]) {\\n        g[c.first][c.second] = 1;\\n        if (c.first == g.size() - 1 && c.second == g.size() - 1) return steps;\\n        for (auto i = -1; i < 2; ++i)\\n          for (auto j = -1; j < 2; ++j)\\n            if (i != 0 || j != 0) q1.push({ c.first + i, c.second + j });\\n      }\\n    }\\n    swap(q, q1);\\n  }\\n  return -1;\\n}\\n```\n```\\nint shortestPathBinaryMatrix(vector<vector<int>>& g, int steps = 0) {\\n  queue<pair<int, int>> q;\\n  q.push({ 0, 0 });\\n  while (!q.empty()) {\\n    ++steps;\\n    queue<pair<int, int>> q1;\\n    while (!q.empty()) {\\n      auto c = q.front();\\n      q.pop();\\n      if (exchange(g[c.first][c.second], 1) == 1) continue;\\n      if (c.first == g.size() - 1 && c.second == g.size() - 1) return steps;\\n      for (auto i = c.first - 1; i <= c.first + 1; ++i)\\n        for (auto j = c.second - 1; j <= c.second + 1; ++j)\\n          if (i != c.first || j != c.second) {\\n            if (i >= 0 && j >= 0 && i < g.size() && j < g.size() && !g[i][j]) {\\n              q1.push({ i, j });\\n            }\\n          }\\n    }\\n    swap(q, q1);\\n  }\\n  return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2043319,
                "title": "why-use-bfs-search-every-possible-path-vs-search-a-possible-path",
                "content": "[Leetcode](https://leetcode.com/) [1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix).\\n\\n# Intuition\\n\\n1. If we want to find **a possible path**, **DFS** will be more efficient. Because DFS will return a possible path if found, while it may not the shortest path.  \\n\\n2. **BFS** will try **every possible path** at the same time. \\n\\n3. If we want to find the shortest of all possible paths, **BFS is more efficient**. It\\'s impossible for DFS to determine which is the shortest before trying all possible paths. \\n\\n# BFS\\n\\nUse BFS to **Level Traversal**.\\n\\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        if (grid[0][0] == 1 || grid[row - 1][col - 1] == 1) {\\n            return -1;\\n        }\\n\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        boolean[][] visited = new boolean[row][col];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            ans++;\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] curPos = queue.poll();\\n\\n                if (curPos[0] == row - 1 && curPos[1] == col - 1) {\\n                    return ans;\\n                }\\n\\n                for (int[] dir : dirs) {\\n                    int nextX = curPos[0] + dir[0];\\n                    int nextY = curPos[1] + dir[1];\\n\\n                    if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col || visited[nextX][nextY] || grid[nextX][nextY] == 1) {\\n                        continue;\\n                    }\\n\\n                    visited[nextX][nextY] = true;\\n                    queue.offer(new int[]{nextX, nextY});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$.\\n- **Space Complexity**: $O(n^2)$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        if (grid[0][0] == 1 || grid[row - 1][col - 1] == 1) {\\n            return -1;\\n        }\\n\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        boolean[][] visited = new boolean[row][col];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            ans++;\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] curPos = queue.poll();\\n\\n                if (curPos[0] == row - 1 && curPos[1] == col - 1) {\\n                    return ans;\\n                }\\n\\n                for (int[] dir : dirs) {\\n                    int nextX = curPos[0] + dir[0];\\n                    int nextY = curPos[1] + dir[1];\\n\\n                    if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col || visited[nextX][nextY] || grid[nextX][nextY] == 1) {\\n                        continue;\\n                    }\\n\\n                    visited[nextX][nextY] = true;\\n                    queue.offer(new int[]{nextX, nextY});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063639,
                "title": "python-clean-bfs-explained",
                "content": "In this problem we need to find the shortest path in graph, so the first thing you should think about is **bfs** or breadth first search. We will keep tuples with `3` elements: `(distance, coordinate x, coordinate y)`. On each step we extract element from the left side of our `queue`, check if coordinates equal to ending point and if they are, we return distance. If not, for all `8` neighbours, we check if we can visite them: if we still inside grid, if value of grid is equal to `0` and if it was not visited previously. We add new node to `visited` set and to the end of our queue. (Note, that there is alternative way, where we directly change our grid without using visited set)\\n\\n**Complexity**: time complexity is `O(N^2)`: number of nodes in our graph. If we use visited set, space complexity is also `O(N^2)`. If not, it is just `O(N)`, because during traversal there will always be only nodes with distances `x` and `x+1` any given moment and there can be `O(N)` nodes with every distance.\\n\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid):\\n        N = len(grid)\\n        neibs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]\\n        queue = deque([(1, 0, 0)]) if grid[0][0] == 0 else deque()\\n        visited = set()\\n        \\n        while queue:\\n            dist, x, y = queue.popleft()\\n            if (x, y) == (N-1, N-1): return dist\\n            for dx, dy in neibs:\\n                if 0<=x+dx<N and 0<=y+dy<N and grid[x+dx][y+dy] == 0 and (x+dx, y+dy) not in visited:\\n                    visited.add((x+dx,y+dy))\\n                    queue.append((dist + 1, x+dx, y+dy))\\n                \\n        return -1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid):\\n        N = len(grid)\\n        neibs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]\\n        queue = deque([(1, 0, 0)]) if grid[0][0] == 0 else deque()\\n        visited = set()\\n        \\n        while queue:\\n            dist, x, y = queue.popleft()\\n            if (x, y) == (N-1, N-1): return dist\\n            for dx, dy in neibs:\\n                if 0<=x+dx<N and 0<=y+dy<N and grid[x+dx][y+dy] == 0 and (x+dx, y+dy) not in visited:\\n                    visited.add((x+dx,y+dy))\\n                    queue.append((dist + 1, x+dx, y+dy))\\n                \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043347,
                "title": "c-bfs-not-a-dp-problem",
                "content": "* Use BFS approach to find shortest path like we solve for graph problems. You can think of adjacent cells with value = 0 having an undirected edge between them.\\n* Apply BFS and update counter at everly level.\\n* To track levels I have used `nodesPushed`. It is equal to number of nodes in current level.\\n* If you are able to reach `(n-1, n-1)` return its level otherwise return -1.\\n* **Little Optimization :** Rather than keeping visited vector, after we have pushed a node in the queue make its value in `grid` equal to 1. This would make it unavailable to process next time we encounter it. However this method will corrupt the memory. \\n* **DP will not work here** because the way we traverse the matrix in DP will not lead to formulation of correct solution or rather the optimal path. However, BFS will lead to an optimal path.\\n* We can also get our answer by **DFS** but it would be computationaly more expensive and might give TLE on large inputs.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j, int n, vector<vector<bool>>& visited){\\n        \\n        return (i>=0 and i<n and j>=0 and j<n and grid[i][j]==0 and !visited[i][j]);\\n        \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<vector<bool>> visited(n, vector<bool> (n, false));\\n        queue<pair<int, int>> q;\\n        int ans = 0;\\n        int nodesPushed;\\n        \\n        if(grid[0][0] == 0){\\n            q.push({0, 0});\\n            visited[0][0] = true;\\n        }\\n                \\n        while(!q.empty()){\\n            \\n            nodesPushed = q.size();\\n            ans++;\\n            \\n            for(int cnt = 0; cnt < nodesPushed; cnt++){\\n                \\n                pair<int, int> frontNode = q.front();\\n                q.pop();\\n            \\n                int i = frontNode.first, j = frontNode.second;\\n\\n                if(i==n-1 and j==n-1) return ans;\\n\\n                for(int k = i - 1; k <= i + 1 ; k++){\\n                    for(int l = j - 1; l <= j + 1; l++){\\n                        if(isValid(grid, k, l, n, visited)){\\n                            q.push({k, l});\\n                            visited[k][l] = true;\\n                        }\\n                    }\\n                }                \\n                \\n            }            \\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j, int n, vector<vector<bool>>& visited){\\n        \\n        return (i>=0 and i<n and j>=0 and j<n and grid[i][j]==0 and !visited[i][j]);\\n        \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<vector<bool>> visited(n, vector<bool> (n, false));\\n        queue<pair<int, int>> q;\\n        int ans = 0;\\n        int nodesPushed;\\n        \\n        if(grid[0][0] == 0){\\n            q.push({0, 0});\\n            visited[0][0] = true;\\n        }\\n                \\n        while(!q.empty()){\\n            \\n            nodesPushed = q.size();\\n            ans++;\\n            \\n            for(int cnt = 0; cnt < nodesPushed; cnt++){\\n                \\n                pair<int, int> frontNode = q.front();\\n                q.pop();\\n            \\n                int i = frontNode.first, j = frontNode.second;\\n\\n                if(i==n-1 and j==n-1) return ans;\\n\\n                for(int k = i - 1; k <= i + 1 ; k++){\\n                    for(int l = j - 1; l <= j + 1; l++){\\n                        if(isValid(grid, k, l, n, visited)){\\n                            q.push({k, l});\\n                            visited[k][l] = true;\\n                        }\\n                    }\\n                }                \\n                \\n            }            \\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065225,
                "title": "c-bfs-simple-and-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if point is in grid\\n    bool isValidPoint(int x, int y, int n, int m) {\\n        return x >= 0 && x <= n && y >= 0 && y <= m;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size()-1, m = grid[0].size()-1;\\n        if (grid[0][0] || grid[n][m]) \\n            return -1;\\n        \\n        queue<vector<int> > q;\\n        vector<int> curr;\\n        \\n        q.push({0, 0});\\n        grid[0][0] = 1;\\n        \\n        while (!q.empty() && !grid[n][m]) {\\n            curr = q.front();\\n            q.pop();\\n            \\n            for (int i = 0; i < 8; i++) {\\n                int x = curr[0] + x_points[i];\\n                int y = curr[1] + y_points[i];\\n                \\n                if (isValidPoint(x, y, n, m) && grid[x][y] == 0) {\\n                    grid[x][y] = grid[curr[0]][curr[1]] + 1;\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        return grid[n][m] ? grid[n][m] : -1;\\n    }\\n    \\nprivate:\\n    vector<int> x_points = {-1,-1,-1,0,0,1,1,1};\\n    vector<int> y_points = {-1,0,1,-1,1,-1,0,1};\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if point is in grid\\n    bool isValidPoint(int x, int y, int n, int m) {\\n        return x >= 0 && x <= n && y >= 0 && y <= m;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size()-1, m = grid[0].size()-1;\\n        if (grid[0][0] || grid[n][m]) \\n            return -1;\\n        \\n        queue<vector<int> > q;\\n        vector<int> curr;\\n        \\n        q.push({0, 0});\\n        grid[0][0] = 1;\\n        \\n        while (!q.empty() && !grid[n][m]) {\\n            curr = q.front();\\n            q.pop();\\n            \\n            for (int i = 0; i < 8; i++) {\\n                int x = curr[0] + x_points[i];\\n                int y = curr[1] + y_points[i];\\n                \\n                if (isValidPoint(x, y, n, m) && grid[x][y] == 0) {\\n                    grid[x][y] = grid[curr[0]][curr[1]] + 1;\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        return grid[n][m] ? grid[n][m] : -1;\\n    }\\n    \\nprivate:\\n    vector<int> x_points = {-1,-1,-1,0,0,1,1,1};\\n    vector<int> y_points = {-1,0,1,-1,1,-1,0,1};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312846,
                "title": "why-does-this-simple-bfs-give-tle",
                "content": "I wrote a simple BFS which gives TLE. I am seeing that this looks very similar to most of the posts under discussion but cant figure out why it gives TLE. Does anyone have an idea?\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0 || grid.back().back() == 1) return -1;\\n        \\n        queue<pair<int, int>> que;\\n        que.push({0, 0});\\n        int di = grid.size()-1, dj = grid[0].size()-1, l = 0;\\n        \\n        vector<pair<int, int>> dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}, {1,1}, {1,-1}, {-1,1}, {-1,-1}};\\n        while (!que.empty()) {\\n            int size = que.size();\\n            l++;\\n            for (int s = 0; s < size; s++) {\\n                auto curr = que.front(); que.pop();\\n                int i = curr.first, j = curr.second;\\n                grid[i][j] = 2;\\n                \\n                if (i == di && j == dj) return l;\\n\\n                for (auto& dir: dirs) {\\n                    int x = i + dir.first, y = j + dir.second;\\n                    if (0 <= x && x < grid.size() && 0 <= y && y < grid[0].size() && grid[x][y] == 0) que.push({x, y});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0 || grid.back().back() == 1) return -1;\\n        \\n        queue<pair<int, int>> que;\\n        que.push({0, 0});\\n        int di = grid.size()-1, dj = grid[0].size()-1, l = 0;\\n        \\n        vector<pair<int, int>> dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}, {1,1}, {1,-1}, {-1,1}, {-1,-1}};\\n        while (!que.empty()) {\\n            int size = que.size();\\n            l++;\\n            for (int s = 0; s < size; s++) {\\n                auto curr = que.front(); que.pop();\\n                int i = curr.first, j = curr.second;\\n                grid[i][j] = 2;\\n                \\n                if (i == di && j == dj) return l;\\n\\n                for (auto& dir: dirs) {\\n                    int x = i + dir.first, y = j + dir.second;\\n                    if (0 <= x && x < grid.size() && 0 <= y && y < grid[0].size() && grid[x][y] == 0) que.push({x, y});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046009,
                "title": "this-is-why-dp-and-memoization-fail-illustrated-example",
                "content": "Here\\'s an illustrated example of why memoizing our answers (\"dp top-down\") also won\\'t work. \\n\\nLet\\'s say we define a function **countCellsToTarget(i, j)**, that returns the **minimum number of \\'0\\' cells** that we need to go through in order to get from position (i, j) to our target position (n-1, n-1).\\n\\nGiven the following input: [[0,0,1,0,1,1],[1,0,0,1,0,0],[0,1,0,1,0,0],[1,0,1,0,0,0],[0,1,0,1,0,0],[0,0,0,0,0,0]], with an expected result of 6, depending on the **order** in which we move onto the adjacent cells, we might discover a long path before we actually discover the shortest one. Therefore, memoizing an incorrect result.\\n\\nIn the following example let\\'s imagine that, because of how we defined our directions array, we end up visiting our neighbors in a very strange order (red arrows):\\n\\n![image](https://assets.leetcode.com/users/images/374288bd-cc4a-4e15-874b-3a988a31aa1c_1652746083.7747693.png)\\n\\nEvery time twe visit a cell (painted in red) we mark it as visited, so that we don\\'t visit it again during the same path. Every time we hit a cell that we don\\'t have our result memoized, we start exploring all the different paths from there to our destination.\\n\\nLet\\'s just focus on cell (2,2). Once we get there, our only option is moving to the top. The reason behind this is that we\\'re actually using the **surrounding state** of the current path to calculate the answer to cell (2,2) (that is cells marked as already visited!)\\n\\nFrom cell (1,2) we\\'d start exploring different paths trying to get to the (n-1, n-1) cell:\\n1.  We\\'d first move to the top-left cell (0, 1) leading us to a dead end.\\n2.  Then, we\\'d backtrack to cell (1, 2), and then move to the top-right cell (0, 3) that would get us to the last cell in a path of total length 8 (highlighted in gray).\\n\\nAfter we reach to our target, the solution for cell (2, 2) appears to be 8. At that point we\\'d probably store this solution in our dp array and continue our exploration **based on this premise which is false**, leading us to a wrong answer.\\n\\nAs you can see here, in the shortest path, the solution for cell (2, 2) is actually 4\\n\\n![image](https://assets.leetcode.com/users/images/2e6a4a5f-f035-4222-b4ed-b5e1ce5c1c5f_1652746621.228863.png)\\n\\nThis is the reason why we can\\'t do better than exponential time complexity O(7^(n^2)) when doing a backtracking solution as we cannot get rid of duplicate work by memoizing our answers.\\n\\nUnlike BFS, DFS doesn\\'t guarantee that we choose the shortest path first. So, we might actually take the longest one first and end up finding a path based on the current state of the visited set, and then finding and memoizing an incorrect result.\\n\\nWith memoization enabled, this test case gives WA (returns 8 instead of 6). If we remove the memoization, the backtracking solution takes around 7 seconds to complete but it works fine:\\n\\n**WARNING: this solution is for example purposes only. It won\\'t pass all leetcode test cases!**\\n```\\nclass Solution:\\n    NO_CLEAR_PATH = -1\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dirs = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 0), (-1, 1), (0, 1), (1, 1)]\\n        dp = [[None] * n for _ in range(n)]\\n\\n        def countCellsToTarget(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= n or grid[i][j] == 1: return self.NO_CLEAR_PATH\\n            if (i, j) == (n-1, n-1): return 1\\n            #if dp[i][j] is not None: return dp[i][j] # memoization removed\\n\\n            result = math.inf\\n            grid[i][j] = 1\\n\\n            for di, dj in dirs:\\n                ii, jj = i + di, j + dj\\n\\n                cellsToTarget = countCellsToTarget(ii, jj)\\n                if cellsToTarget < 1: continue\\n                result = min(result, 1 + cellsToTarget)\\n\\n            if result == math.inf: result = self.NO_CLEAR_PATH\\n            grid[i][j] = 0\\n            dp[i][j] = result\\n            return result\\n        \\n        return countCellsToTarget(0, 0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    NO_CLEAR_PATH = -1\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dirs = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 0), (-1, 1), (0, 1), (1, 1)]\\n        dp = [[None] * n for _ in range(n)]\\n\\n        def countCellsToTarget(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= n or grid[i][j] == 1: return self.NO_CLEAR_PATH\\n            if (i, j) == (n-1, n-1): return 1\\n            #if dp[i][j] is not None: return dp[i][j] # memoization removed\\n\\n            result = math.inf\\n            grid[i][j] = 1\\n\\n            for di, dj in dirs:\\n                ii, jj = i + di, j + dj\\n\\n                cellsToTarget = countCellsToTarget(ii, jj)\\n                if cellsToTarget < 1: continue\\n                result = min(result, 1 + cellsToTarget)\\n\\n            if result == math.inf: result = self.NO_CLEAR_PATH\\n            grid[i][j] = 0\\n            dp[i][j] = result\\n            return result\\n        \\n        return countCellsToTarget(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584601,
                "title": "c-easy-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n=g.size();\\n        if(g[0][0] || g[n-1][n-1])return -1;\\n        g[0][0]=1;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int t=0;\\n        while(q.size()){\\n            int k=q.size();\\n            t++;\\n            while(k--){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                if(x==n-1 && y==n-1)return t;\\n                int dx[8]={1,-1,0,0,1,1,-1,-1};\\n                int dy[8]={0,0,1,-1,1,-1,1,-1};\\n                for(int i=0;i<8;i++){\\n                    int nx=x+dx[i];\\n                    int ny=y+dy[i];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<n && g[nx][ny]==0){\\n                        g[nx][ny]=1;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/4cfbed27-aa7a-4b04-aa83-47d4734d2c3b_1685596609.7438343.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n=g.size();\\n        if(g[0][0] || g[n-1][n-1])return -1;\\n        g[0][0]=1;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int t=0;\\n        while(q.size()){\\n            int k=q.size();\\n            t++;\\n            while(k--){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                if(x==n-1 && y==n-1)return t;\\n                int dx[8]={1,-1,0,0,1,1,-1,-1};\\n                int dy[8]={0,0,1,-1,1,-1,1,-1};\\n                for(int i=0;i<8;i++){\\n                    int nx=x+dx[i];\\n                    int ny=y+dy[i];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<n && g[nx][ny]==0){\\n                        g[nx][ny]=1;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312785,
                "title": "why-does-dfs-not-work",
                "content": "2 example test cases passed, but for             \\n\\t\\t\\t\\t{0,1,0,1,0},\\n                {1,0,0,0,1},\\n                {0,0,1,1,1},\\n                {0,0,0,0,0},\\n                {1,0,1,0,0}\\nit returns 7, however the solution is 6.\\n\\nhere is my java code:\\n```\\nclass Solution {\\n    int[][] dir = {{1,1},{1,-1},{-1,1},{-1,-1},{0,1},{0,-1},{1,0},{-1,0}};\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] != 0 || grid[grid.length-1][grid[0].length-1] != 0) return -1;\\n\\t\\t\\n        int n = grid.length, m = grid[0].length;\\n        int[] res = new int[]{Integer.MAX_VALUE};\\n        boolean[][] visited = new boolean[n][m];\\n        \\n        helper(grid, 0, 0, 1, visited, res);\\n        return res[0] == Integer.MAX_VALUE ? -1 : res[0];\\n    }\\n    private void helper(int[][] grid, int i, int j, int len, boolean[][] visited, int[] res) {\\n        int n = grid.length, m = grid[0].length;\\n        if (i == n-1 && j == m-1) {\\n            res[0] = Math.min(res[0], len);\\n            return;\\n        } \\n        if (i < 0 || i >= n || j < 0 ||j >= m || grid[i][j] == 1 || visited[i][j]) return;\\n        visited[i][j] = true;\\n        for (int[] d : dir) {\\n            helper(grid, i+d[0], j+d[1], len+1, visited, res);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{1,1},{1,-1},{-1,1},{-1,-1},{0,1},{0,-1},{1,0},{-1,0}};\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] != 0 || grid[grid.length-1][grid[0].length-1] != 0) return -1;\\n\\t\\t\\n        int n = grid.length, m = grid[0].length;\\n        int[] res = new int[]{Integer.MAX_VALUE};\\n        boolean[][] visited = new boolean[n][m];\\n        \\n        helper(grid, 0, 0, 1, visited, res);\\n        return res[0] == Integer.MAX_VALUE ? -1 : res[0];\\n    }\\n    private void helper(int[][] grid, int i, int j, int len, boolean[][] visited, int[] res) {\\n        int n = grid.length, m = grid[0].length;\\n        if (i == n-1 && j == m-1) {\\n            res[0] = Math.min(res[0], len);\\n            return;\\n        } \\n        if (i < 0 || i >= n || j < 0 ||j >= m || grid[i][j] == 1 || visited[i][j]) return;\\n        visited[i][j] = true;\\n        for (int[] d : dir) {\\n            helper(grid, i+d[0], j+d[1], len+1, visited, res);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063456,
                "title": "shortest-path-in-binary-matrix-js-python-java-c-bfs-solution-w-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nWhen we\\'re asked about finding the \"shortest path\", the first thing that should come to mind is a **breadth-first solution** (BFS) approach. In a standard graph BFS solution, we set up a **queue** (**q**) and fill it with our starting position (**grid[0][0]**). Then we keep pulling entries from **q**, figuring out the next moves from that position, and input those next moves back into **q**.\\n\\nWhen we\\'re ready to start, we can change **grid[0][0]** to **1**, then as we reach new cells, we can store the distance to that cell in the cell at the same time we add it to the queue. The distance will simply be one more than the distance to the cell we\\'re moving from. This will also eliminate duplicate queue entries by changing visited cells to a non-zero number.\\n\\nThrough the nature of a BFS approach to graph traversal (with non-weighted edges), the first time we reach the end location (**grid[n][n]**) will represent the best possible distance.\\n\\nSince **0 <= i, j <= 100**, both **i** and **j** will fit into **7 bits** each, so we can utilize **bit manipulation** to store both in one integer. With a **bitwise left shift** (**<<**) we can move the value of **j** to the left by **7 bits** before adding it to **i** to allow for both to fit in **14 bits** of an integer.\\n```js\\nBitwise shift example:\\n\\n   i  =  93 (base 10)  =  1011101 (base 2)\\n   j  =  75 (base 10)  =  1001011 (base 2)\\n\\n   j << 7  =  1001011<<<<<<<     // Bitwise left shift moves the value left\\n           =  10010110000000     // And fills in the space with 0s\\n\\n   i:                           1011101 \\n        j << 7:       +  10010110000000\\n                        ----------------\\n   i + (j << 7):      =  10010111011101 (base 2)\\n                      =            9693 (base 10)\\n```\\nTo read **i** from the first **7 bits** of our stored integer again, you can use **bitwise AND** (**&**) and a **bitmask** of **1111111**. The easiest way to get a bitmask of **1111111** is to shift a single bit to the left by **7** (**1 << 7 = 10000000**) and then subtract **1**, rolling it back to all **1**s.\\n```js\\nBitmask example:\\n\\n   1 << 7:               10000000\\n                      -         1\\n                        ----------\\n   (1 << 7) - 1:      =   1111111\\n```\\nThe bitwise AND will only keep any bits that have a **1** in both numbers, thus stripping away anything except the first **7 bits** of data.\\n```js\\nBitwise AND example:\\n\\n      10010111011101\\n   &         1111111\\n     ----------------\\n   =         1011101\\n```\\nTo read the **j** value from our integer, we can just shift it to the right by **7 bits**, which will throw away the first **7 bits** of data corresponding to the **i** value.\\n\\nIf **q** becomes empty without finding a path to the end, then **return -1**.\\n\\n---\\n\\n***Implementation:***\\n\\nIf either the starting point or the ending point are a **1**, then we quickly **return -1**.\\n\\nTo check which moves can be made, we can just iterate over a three-value range for each **i** and **j**, and to make sure that they remain in bounds, we can apply a **max** and **min** to the range.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **88ms / 42.3MB** (beats 100% / 100%).\\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {\\n    let n = grid.length - 1, q = [0]\\n    if (grid[0][0] || grid[n][n]) return -1\\n    grid[0][0] = 1\\n    while (q.length) {\\n        let curr = q.shift(), i = curr & (1 << 7) - 1, j = curr >> 7\\n        if (i === n && j === n) return grid[n][n]\\n        for (let a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n            for (let b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                if (grid[a][b] === 0)\\n                    grid[a][b] = grid[i][j] + 1, q.push(a + (b << 7))\\n    }\\n    return -1\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **656ms / 14.5MB** (beats 70% / 90%).\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n        q, grid[0][0] = [0], 1\\n        while len(q):\\n            curr = q.pop(0)\\n            i, j = curr & ((1 << 7) - 1), curr >> 7\\n            if i == n and j == n: return grid[n][n]\\n            for a in range(max(i-1,0),min(i+2,n+1)):\\n                for b in range(max(j-1,0),min(j+2,n+1)):\\n                    if grid[a][b] == 0:\\n                        grid[a][b] = grid[i][j] + 1\\n                        q.append(a + (b << 7))\\n        return -1\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **8ms / 40.0MB** (beats 100% / 90%).\\n```java\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        Queue<Integer> q = new ArrayDeque<Integer>();\\n        q.add(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.remove(), i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n                for (int b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.add(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **36 / 18.0MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nBitwise shift example:\\n\\n   i  =  93 (base 10)  =  1011101 (base 2)\\n   j  =  75 (base 10)  =  1001011 (base 2)\\n\\n   j << 7  =  1001011<<<<<<<     // Bitwise left shift moves the value left\\n           =  10010110000000     // And fills in the space with 0s\\n\\n   i:                           1011101 \\n        j << 7:       +  10010110000000\\n                        ----------------\\n   i + (j << 7):      =  10010111011101 (base 2)\\n                      =            9693 (base 10)\\n```\n```js\\nBitmask example:\\n\\n   1 << 7:               10000000\\n                      -         1\\n                        ----------\\n   (1 << 7) - 1:      =   1111111\\n```\n```js\\nBitwise AND example:\\n\\n      10010111011101\\n   &         1111111\\n     ----------------\\n   =         1011101\\n```\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {\\n    let n = grid.length - 1, q = [0]\\n    if (grid[0][0] || grid[n][n]) return -1\\n    grid[0][0] = 1\\n    while (q.length) {\\n        let curr = q.shift(), i = curr & (1 << 7) - 1, j = curr >> 7\\n        if (i === n && j === n) return grid[n][n]\\n        for (let a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n            for (let b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                if (grid[a][b] === 0)\\n                    grid[a][b] = grid[i][j] + 1, q.push(a + (b << 7))\\n    }\\n    return -1\\n};\\n```\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n        q, grid[0][0] = [0], 1\\n        while len(q):\\n            curr = q.pop(0)\\n            i, j = curr & ((1 << 7) - 1), curr >> 7\\n            if i == n and j == n: return grid[n][n]\\n            for a in range(max(i-1,0),min(i+2,n+1)):\\n                for b in range(max(j-1,0),min(j+2,n+1)):\\n                    if grid[a][b] == 0:\\n                        grid[a][b] = grid[i][j] + 1\\n                        q.append(a + (b << 7))\\n        return -1\\n```\n```java\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        Queue<Integer> q = new ArrayDeque<Integer>();\\n        q.add(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.remove(), i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n                for (int b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.add(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043228,
                "title": "python-simple-bfs-with-explanation",
                "content": "The code will be using **BFS** traversal approach to find the shortest distance to target. The advantage of using **BFS** is that we will be exploring and traversing all the possible paths from source simultaneously. \\n\\nThe below solution has comments included for better understanding\\n\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        # check if source and target are not clear cells\\n        if grid[0][0] != 0 or grid[-1][-1] != 0:\\n            return -1\\n        \\n        N = len(grid)            \\n        # offsets required for all 8 directions\\n        offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\\n        \\n        q = deque()\\n        q.append((0,0)) # starting point\\n        visited = {(0, 0)}\\n        \\n        \\n        # finds unvisited clear cells using 8 offsets\\n        def get_neighbours(x,y):\\n            for x_offset, y_offset in offsets:\\n                new_row = x + x_offset\\n                new_col = y + y_offset\\n                \\n                if 0 <= new_row < N and 0 <= new_col < N and not grid[new_row][new_col] and (new_row, new_col) not in visited:\\n                    yield (new_row, new_col)                                                \\n            \\n        \\n        current_distance = 1 # start with one clear cell\\n        # standard iterative BFS traversal\\n        while q:\\n            length = len(q)\\n            \\n            # loop through all the cells at the same distance\\n            for _ in range(length):\\n                row, col = q.popleft()\\n                \\n                if row == N-1 and col==N-1: # reached target\\n                    return current_distance\\n                \\n                # loop though all valid neignbours\\n                for p in get_neighbours(row, col):\\n                    visited.add(p)\\n                    q.append(p)\\n                                    \\n            current_distance+=1 # update the level or distance from source\\n        \\n        return -1                \\n        \\n```\\n\\n**Time - O(N)** where `N` is the number of cells and we visit each cells exactly once.\\n**Space - O(N)** where `N` is the number of cells. This is required for storing `visited`\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        # check if source and target are not clear cells\\n        if grid[0][0] != 0 or grid[-1][-1] != 0:\\n            return -1\\n        \\n        N = len(grid)            \\n        # offsets required for all 8 directions\\n        offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\\n        \\n        q = deque()\\n        q.append((0,0)) # starting point\\n        visited = {(0, 0)}\\n        \\n        \\n        # finds unvisited clear cells using 8 offsets\\n        def get_neighbours(x,y):\\n            for x_offset, y_offset in offsets:\\n                new_row = x + x_offset\\n                new_col = y + y_offset\\n                \\n                if 0 <= new_row < N and 0 <= new_col < N and not grid[new_row][new_col] and (new_row, new_col) not in visited:\\n                    yield (new_row, new_col)                                                \\n            \\n        \\n        current_distance = 1 # start with one clear cell\\n        # standard iterative BFS traversal\\n        while q:\\n            length = len(q)\\n            \\n            # loop through all the cells at the same distance\\n            for _ in range(length):\\n                row, col = q.popleft()\\n                \\n                if row == N-1 and col==N-1: # reached target\\n                    return current_distance\\n                \\n                # loop though all valid neignbours\\n                for p in get_neighbours(row, col):\\n                    visited.add(p)\\n                    q.append(p)\\n                                    \\n            current_distance+=1 # update the level or distance from source\\n        \\n        return -1                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461535,
                "title": "javascript-simple-solution-w-comments",
                "content": "```\\n/**\\n * BFS\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 108 ms, faster than 86.30% of JavaScript online submissions for Shortest Path in Binary Matrix.\\n// Memory Usage: 45.5 MB, less than 96.71% of JavaScript online submissions for Shortest Path in Binary Matrix.\\nconst shortestPathBinaryMatrix = grid => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t\\t[1, 1],\\n\\t\\t[1, -1],\\n\\t\\t[-1, 1],\\n\\t\\t[-1, -1],\\n\\t];\\n\\n\\tif (grid[0][0] === 1) return -1;\\n\\n\\tconst N = grid.length;\\n\\tconst queue = [[0, 0, 1]]; // [row, col, path]\\n\\n\\twhile (queue.length) {\\n\\t\\tconst [row, col, path] = queue.shift();\\n\\n\\t\\tif (row === N - 1 && col === N - 1) return path; // reached destination\\n\\n\\t\\tfor (const [dx, dy] of directions) { // traverse adjacents\\n\\t\\t\\tlet x = row + dx;\\n\\t\\t\\tlet y = col + dy;\\n\\n\\t\\t\\t// if invalid, continue\\n\\t\\t\\tif (x < 0 || x >= N) continue;\\n\\t\\t\\tif (y < 0 || y >= N) continue;\\n\\t\\t\\tif (grid[x][y] !== 0) continue;\\n\\n\\t\\t\\tqueue.push([x, y, path + 1]); // add new path to queue\\n\\t\\t\\tgrid[x][y] = 1; // mark visited\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * BFS\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 108 ms, faster than 86.30% of JavaScript online submissions for Shortest Path in Binary Matrix.\\n// Memory Usage: 45.5 MB, less than 96.71% of JavaScript online submissions for Shortest Path in Binary Matrix.\\nconst shortestPathBinaryMatrix = grid => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t\\t[1, 1],\\n\\t\\t[1, -1],\\n\\t\\t[-1, 1],\\n\\t\\t[-1, -1],\\n\\t];\\n\\n\\tif (grid[0][0] === 1) return -1;\\n\\n\\tconst N = grid.length;\\n\\tconst queue = [[0, 0, 1]]; // [row, col, path]\\n\\n\\twhile (queue.length) {\\n\\t\\tconst [row, col, path] = queue.shift();\\n\\n\\t\\tif (row === N - 1 && col === N - 1) return path; // reached destination\\n\\n\\t\\tfor (const [dx, dy] of directions) { // traverse adjacents\\n\\t\\t\\tlet x = row + dx;\\n\\t\\t\\tlet y = col + dy;\\n\\n\\t\\t\\t// if invalid, continue\\n\\t\\t\\tif (x < 0 || x >= N) continue;\\n\\t\\t\\tif (y < 0 || y >= N) continue;\\n\\t\\t\\tif (grid[x][y] !== 0) continue;\\n\\n\\t\\t\\tqueue.push([x, y, path + 1]); // add new path to queue\\n\\t\\t\\tgrid[x][y] = 1; // mark visited\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891250,
                "title": "easy-java-solution-using-bfs",
                "content": "class Solution {\\n    \\n    class Pair{\\n        int x;\\n        int y;\\n        int count;\\n        \\n        Pair(int x, int y, int count){\\n            this.x = x;\\n            this.y = y;\\n            this.count = count;\\n        }\\n    }\\n    \\n    \\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        return BFS(grid, 0, 0, grid.length-1, grid[0].length-1);\\n        \\n    }\\n    \\n    \\n    public int BFS(int grid[][], int start_x, int start_y , int target_x, int target_y){\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n      \\n        q.add(new Pair(start_x, start_y, 1));\\n        \\n        while(q.size()>0){\\n            \\n            Pair rem = q.remove();\\n            int x = rem.x;\\n            int y = rem.y;\\n            int count = rem.count;\\n           \\n    if(x>=0 && y>=0 && x<grid.length && y<grid[0].length && grid[x][y]!=1 ){\\n            \\n            grid[x][y] = 1;\\n                \\n            if(x==target_x && y== target_y)\\n                return rem.count;\\n            \\n            q.add(new Pair(x-1, y, count+1 ));\\n            q.add(new Pair(x-1, y+1, count+1));\\n            q.add(new Pair(x, y+1 , count+1));\\n            q.add(new Pair(x+1, y+1, count+1));\\n            q.add(new Pair(x+1, y, count+1));\\n            q.add(new Pair(x+1, y-1, count+1));\\n            q.add(new Pair(x, y-1, count+1));\\n            q.add(new Pair(x-1, y-1, count+1));\\n                \\n          }\\n    \\n       }\\n        return -1;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    \\n    class Pair{\\n        int x;\\n        int y;\\n        int count;\\n        \\n        Pair(int x, int y, int count){\\n            this.x = x;\\n            this.y = y;\\n            this.count = count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 313937,
                "title": "posting-my-java-dfs-solution-54ms-to-demonstrate-that-it-is-possible",
                "content": "The idea is to only go deeper if the dp value of one cell or its neibor is updated to a smaller value.\\nThis is one trick for designing DFS: we shall try to gain in each recursion.\\n\\n```\\n    // Transfer the dist value at (r,c) to or from neighbor cells.\\n    // Whenever a cell has a updated (smaller) dist value, a recursive call of grow() will be done on behalf of it.\\n    private void grow(int[][] grid, int[][] dist, int r, int c) {\\n        int m = grid.length, n = grid[0].length;\\n        int d0 = dist[r][c];\\n        for (int i = -1; i <= 1; i++) {\\n            for (int j = -1; j <= 1; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n                int x = r + i;\\n                int y = c + j;\\n                if (x >= 0 && x < m && y >= 0 && y < n) {\\n                    if (grid[x][y] == 1)\\n                        continue;\\n                    int d1 = dist[x][y];\\n                    if (d1 < d0-1) { // get a smaller value from a neighbor; then re-start the process.\\n                        dist[r][c] = d1+1;\\n                        grow(grid, dist, r, c); // TODO some optimization to avoid stack overflow\\n                        return;\\n                    } else if (d1 > d0+1) { // give a smaller value to a neighbor\\n                        dist[x][y] = d0+1;\\n                        grow(grid, dist, x, y);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n]; // dist[i][j]: distance of the cell (i,j) to (0,0)\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dist[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        dist[0][0] = 1;\\n        if (grid[0][0] == 1 || grid[m-1][n-1] == 1)\\n            return -1;\\n        grow(grid, dist, 0, 0);\\n        return (dist[m-1][n-1] != Integer.MAX_VALUE ? dist[m-1][n-1] : -1);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    // Transfer the dist value at (r,c) to or from neighbor cells.\\n    // Whenever a cell has a updated (smaller) dist value, a recursive call of grow() will be done on behalf of it.\\n    private void grow(int[][] grid, int[][] dist, int r, int c) {\\n        int m = grid.length, n = grid[0].length;\\n        int d0 = dist[r][c];\\n        for (int i = -1; i <= 1; i++) {\\n            for (int j = -1; j <= 1; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n                int x = r + i;\\n                int y = c + j;\\n                if (x >= 0 && x < m && y >= 0 && y < n) {\\n                    if (grid[x][y] == 1)\\n                        continue;\\n                    int d1 = dist[x][y];\\n                    if (d1 < d0-1) { // get a smaller value from a neighbor; then re-start the process.\\n                        dist[r][c] = d1+1;\\n                        grow(grid, dist, r, c); // TODO some optimization to avoid stack overflow\\n                        return;\\n                    } else if (d1 > d0+1) { // give a smaller value to a neighbor\\n                        dist[x][y] = d0+1;\\n                        grow(grid, dist, x, y);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n]; // dist[i][j]: distance of the cell (i,j) to (0,0)\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dist[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        dist[0][0] = 1;\\n        if (grid[0][0] == 1 || grid[m-1][n-1] == 1)\\n            return -1;\\n        grow(grid, dist, 0, 0);\\n        return (dist[m-1][n-1] != Integer.MAX_VALUE ? dist[m-1][n-1] : -1);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 312922,
                "title": "java-python-3-concise-bfs-and-dfs-codes-w-o-changing-input",
                "content": "**Method 1: BFS**\\nUpdate:\\nIn case you are not comfortable with the approach by encoding of the coordinates, here is another version (but input `grid` modified):\\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        Queue<Integer> q = new LinkedList<>();\\n        if (grid[0][0] == 0) // if starting point not blocked. \\n                q.offer(0);\\n        int n = grid.length;\\n        for (int steps = 1; !q.isEmpty(); ++steps) { // increase one per round of search.\\n            for (int sz = q.size(); sz > 0; --sz) { // breadth control.\\n                int x = q.peek() / n, y = q.poll() % n; // decode.\\n                if (x == n - 1 && y == n - 1) // find shortest path.\\n                    return steps; // return its length.\\n                for (int i = x - 1; i <= x + 1; ++i) {  // traverse 8 neighbors of (x, y)\\n                    for (int j = y - 1; j <= y + 1; ++j) { // (i, j) is neighbor\\'s coordinates.\\n                        if (i >= 0 && i < n && j >= 0 && j < n && grid[i][j] == 0) {\\n                            q.offer(i * n + j); // add it into queue if it is valid, and not blocked or visited.\\n                            grid[i][j] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\n----\\n\\n\\n1. Encode each cell coordinates `(x, y)` to `x * n + y`, where `n = grid[0].length`;\\n2. starting from `(0, 0)`, for each cell, if valid, neither blocked nor visited, put its encoded coordinates into a Queue and a HashSet, the latter of which is used to avoid duplicates.\\n3. BFS search based on the Queue; for each polled out encoded number, decode it and traverse its 8 neighbors.\\n4. repeat 2 and 3 till all cells are visited.\\n\\n**NOTE**: for case `(dx, dy) = (0,0)`, the neighbor is `(x, y)` itself, and it will be filtered out by HashSet and will not be added into Queue again.\\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        if (grid[0][0] == 1 || grid[N - 1][N - 1] == 1) // if starting/ending point blocked.\\n            return -1;\\n        Set<Integer> seen = new HashSet<>(Arrays.asList(0)); // avoid duplicates. \\n        Queue<Integer> q = new LinkedList<>(seen);\\n        for (int steps = 1; !q.isEmpty(); ++steps) { // increase one per round of search.\\n            for (int sz = q.size(); sz > 0; --sz) { // breadth control.\\n                int x = q.peek() / N, y = q.poll() % N; // decode.\\n                if (x == N - 1 && y == N - 1)  // find shortest path.\\n                    return steps; // return its length. \\n                for (int i = x - 1; i <= x + 1; ++i) {  // traverse 8 neighbors of (x, y)\\n                    for (int j = y - 1; j <= y + 1; ++j) { // (i, j) is neighbor\\'s coordinates.\\n                        if (i >= 0 && i < N && j >= 0 && j < N && grid[i][j] == 0 && seen.add(i * N + j)) {\\n                            q.offer(i * N + j); // add it into queue if it is valid, neither blocked nor visited.\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\nPut into queue the `tuple(rowNumber, colNumer, steps from source)`.\\n```python\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: \\n            return -1\\n        N, q, seen = len(grid), [(0, 0, 1)], set([0])\\n        for x, y, steps in q:\\n            if x == N - 1 and y == N - 1: \\n                return steps;\\n            for i in (x - 1, x, x + 1):\\n                for j in (y - 1, y, y + 1):\\n                    if i >= 0 and i < N and j >= 0 and j < N and grid[i][j] == 0 and i * N + j not in seen:\\n                        seen.add(i * N + j)\\n                        q.append((i, j, steps + 1))\\n        return -1\\n```\\n**Analysis**:\\n\\nTime & space: O(n ^ 2), n = grid.length.\\n\\n----\\n**Method 2: DFS**\\n\\n**Similar to wave propagation on water surface.**\\npropagates shortest path distance among neighbors. Idea inspired by @sunrenjie\\n\\n1. Use a 2d array to store currently found shortest distance from source to the visiting cell. \\n2. In DFS, compare the value of visiting cell with that of its neighbors, update bigger values with smaller values;\\n3. In above 2, keep recursing till the distance values difference between any 2 neighboring cells is no more than 1.\\n----\\n**Q & A:**\\nQ:\\nIn DFS method, why are you checking for this condition --> `Math.abs(d[x][y] - d[r][c]) > 1`\\nA:\\nIt\\'s the recursion termination condition: distance values difference between any 2 neighboring non-blocked cells is no more than 1;  Specifically, if the difference <= 1, then the visiting cell maintains the currently found shortest path distance value, and there is no way to make the distance shorter.\\n\\nFor any 2 neighbors `(x, y)` and `(r, c)`, if the difference between the distance from source `(0, 0)` is bigger than 1,  e.g., `dist[x][y] = 3, dist[r][c] = 7`, then we can change the corresponding path of `dist[r][c]` to the corresponding path of `dist[x][y]` plus the distance from `(x, y)` to its neighbor `(r, c)`. That is, updating `dist[r][c]` to the current shortest path distance: `dist[x][y] + 1 = 4`.\\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dist = new int[n][n];\\n        for (int[] row : dist) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        if (grid[0][0] == 0 && grid[n - 1][n - 1] == 0) // if both source and target are clear. \\n            dist[0][0] = 1; // initialize it with 1.\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                dfs(grid, dist, r, c);\\n            }\\n        }\\n        int v = dist[n - 1][n - 1]; // shorest distance from source to target.\\n        return v == Integer.MAX_VALUE ? -1 : v;\\n    }\\n    private void dfs(int[][] g, int[][] d, int x, int y) {\\n        for (int r = x - 1, n = g.length; r <= x + 1; ++r) {\\n            for (int c = y - 1; c <= y + 1; ++c) {\\n                if (r >= 0 && r < n && c >= 0 && c < n && g[r][c] == 0 && Math.abs(d[x][y] - d[r][c]) > 1) {\\n                    if (d[x][y] > d[r][c]) { d[x][y] = d[r][c] + 1; } // if source to (x, y) > source to (r, c ) + 1, update d[x][y].\\n                    else if (g[x][y] == 0) { d[r][c] = d[x][y] + 1; } // otherwise update d[r][c].\\n                    dfs(g, d, r, c);\\n                }\\n            }\\n        }        \\n    }\\n```\\n```python\\n   def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: \\n            return -1\\n        N = len(grid)\\n        dist = [[inf] * N for _ in range(N)]\\n        dist[0][0] = 1\\n        \\n        def dfs(grid: List[List[int]], dist: List[List[int]], x: int, y: int) -> None:\\n            for r in (x - 1, x, x + 1):\\n                for c in (y - 1, y, y + 1):\\n                    if r >= 0 and r < N and c >= 0 and c < N and grid[r][c] == 0 and abs(dist[x][y] - dist[r][c]) > 1:\\n                        if dist[x][y] > dist[r][c] + 1:\\n                            dist[x][y] = dist[r][c] + 1\\n                        elif grid[x][y] == 0:\\n                            dist[r][c] = dist[x][y] + 1\\n                        dfs(grid, dist, r, c)\\n                        \\n        for r in range(N):\\n            for c in range(N):     \\n                dfs(grid, dist, r, c)\\n        return dist[-1][-1] if dist[-1][-1] <= N * N else -1\\n```\\n\\n**Analysis**:\\n\\nTime & space: O(n ^ 2), n = grid.length.",
                "solutionTags": [],
                "code": "```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        Queue<Integer> q = new LinkedList<>();\\n        if (grid[0][0] == 0) // if starting point not blocked. \\n                q.offer(0);\\n        int n = grid.length;\\n        for (int steps = 1; !q.isEmpty(); ++steps) { // increase one per round of search.\\n            for (int sz = q.size(); sz > 0; --sz) { // breadth control.\\n                int x = q.peek() / n, y = q.poll() % n; // decode.\\n                if (x == n - 1 && y == n - 1) // find shortest path.\\n                    return steps; // return its length.\\n                for (int i = x - 1; i <= x + 1; ++i) {  // traverse 8 neighbors of (x, y)\\n                    for (int j = y - 1; j <= y + 1; ++j) { // (i, j) is neighbor\\'s coordinates.\\n                        if (i >= 0 && i < n && j >= 0 && j < n && grid[i][j] == 0) {\\n                            q.offer(i * n + j); // add it into queue if it is valid, and not blocked or visited.\\n                            grid[i][j] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        if (grid[0][0] == 1 || grid[N - 1][N - 1] == 1) // if starting/ending point blocked.\\n            return -1;\\n        Set<Integer> seen = new HashSet<>(Arrays.asList(0)); // avoid duplicates. \\n        Queue<Integer> q = new LinkedList<>(seen);\\n        for (int steps = 1; !q.isEmpty(); ++steps) { // increase one per round of search.\\n            for (int sz = q.size(); sz > 0; --sz) { // breadth control.\\n                int x = q.peek() / N, y = q.poll() % N; // decode.\\n                if (x == N - 1 && y == N - 1)  // find shortest path.\\n                    return steps; // return its length. \\n                for (int i = x - 1; i <= x + 1; ++i) {  // traverse 8 neighbors of (x, y)\\n                    for (int j = y - 1; j <= y + 1; ++j) { // (i, j) is neighbor\\'s coordinates.\\n                        if (i >= 0 && i < N && j >= 0 && j < N && grid[i][j] == 0 && seen.add(i * N + j)) {\\n                            q.offer(i * N + j); // add it into queue if it is valid, neither blocked nor visited.\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```python\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: \\n            return -1\\n        N, q, seen = len(grid), [(0, 0, 1)], set([0])\\n        for x, y, steps in q:\\n            if x == N - 1 and y == N - 1: \\n                return steps;\\n            for i in (x - 1, x, x + 1):\\n                for j in (y - 1, y, y + 1):\\n                    if i >= 0 and i < N and j >= 0 and j < N and grid[i][j] == 0 and i * N + j not in seen:\\n                        seen.add(i * N + j)\\n                        q.append((i, j, steps + 1))\\n        return -1\\n```\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dist = new int[n][n];\\n        for (int[] row : dist) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        if (grid[0][0] == 0 && grid[n - 1][n - 1] == 0) // if both source and target are clear. \\n            dist[0][0] = 1; // initialize it with 1.\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                dfs(grid, dist, r, c);\\n            }\\n        }\\n        int v = dist[n - 1][n - 1]; // shorest distance from source to target.\\n        return v == Integer.MAX_VALUE ? -1 : v;\\n    }\\n    private void dfs(int[][] g, int[][] d, int x, int y) {\\n        for (int r = x - 1, n = g.length; r <= x + 1; ++r) {\\n            for (int c = y - 1; c <= y + 1; ++c) {\\n                if (r >= 0 && r < n && c >= 0 && c < n && g[r][c] == 0 && Math.abs(d[x][y] - d[r][c]) > 1) {\\n                    if (d[x][y] > d[r][c]) { d[x][y] = d[r][c] + 1; } // if source to (x, y) > source to (r, c ) + 1, update d[x][y].\\n                    else if (g[x][y] == 0) { d[r][c] = d[x][y] + 1; } // otherwise update d[r][c].\\n                    dfs(g, d, r, c);\\n                }\\n            }\\n        }        \\n    }\\n```\n```python\\n   def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: \\n            return -1\\n        N = len(grid)\\n        dist = [[inf] * N for _ in range(N)]\\n        dist[0][0] = 1\\n        \\n        def dfs(grid: List[List[int]], dist: List[List[int]], x: int, y: int) -> None:\\n            for r in (x - 1, x, x + 1):\\n                for c in (y - 1, y, y + 1):\\n                    if r >= 0 and r < N and c >= 0 and c < N and grid[r][c] == 0 and abs(dist[x][y] - dist[r][c]) > 1:\\n                        if dist[x][y] > dist[r][c] + 1:\\n                            dist[x][y] = dist[r][c] + 1\\n                        elif grid[x][y] == 0:\\n                            dist[r][c] = dist[x][y] + 1\\n                        dfs(grid, dist, r, c)\\n                        \\n        for r in range(N):\\n            for c in range(N):     \\n                dfs(grid, dist, r, c)\\n        return dist[-1][-1] if dist[-1][-1] <= N * N else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1063562,
                "title": "bfs-clean-code-easy-to-understand-heavily-commented",
                "content": "**With Separate Visited Array**\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1) // check if starting cell itself is blocked -> -1\\n            return -1;\\n        \\n        int m = grid.length, n = grid[0].length; // m = n = N \\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n\\t\\t\\n\\t\\t// dx dy 8 directional vector\\n        int[] dx = new int[]{1, 1, 0, -1, -1, -1, 0, 1};\\n        int[] dy = new int[]{0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n\\t\\t// initialize from source top left cell\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        int level = 1;\\n        \\n        while(q.size() > 0) {\\n            for(int i = q.size(); i > 0; i--) { // iterate all cells in next level\\n                int[] xy = q.poll();\\n                if(xy[0] == m - 1 && xy[1] == n - 1) // check if reached bottom right most cell\\n                    return level;\\n                for(int j = 0; j < 8; j++) { // loop 8 directiona cells \\n                    int nx = xy[0] + dx[j];\\n                    int ny = xy[1] + dy[j];\\n                    if(nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] == 0) { // check if next cell coordinates valid\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            level++; // update level after processing level\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\n**TC - SC - O(mn)**\\n\\n**Without Separate Visited Array**\\nIf you see instead of using separate boolean[][] visited array we can re-use grid for visited mark to save the space.\\n\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1) // check if starting cell itself is blocked -> -1\\n            return -1;\\n        \\n        int m = grid.length, n = grid[0].length; // m = n = N \\n        Queue<int[]> q = new LinkedList<>();\\n        // boolean[][] visited = new boolean[m][n];\\n\\t\\t\\n\\t\\t// dx dy 8 directional vector\\n        int[] dx = new int[]{1, 1, 0, -1, -1, -1, 0, 1};\\n        int[] dy = new int[]{0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n\\t\\t// initialize from source top left cell\\n        q.add(new int[]{0, 0});\\n        grid[0][0] = 1;\\n        int level = 1;\\n        \\n        while(q.size() > 0) {\\n            for(int i = q.size(); i > 0; i--) { // iterate all cells in next level\\n                int[] xy = q.poll();\\n                if(xy[0] == m - 1 && xy[1] == n - 1) // check if reached bottom right most cell\\n                    return level;\\n                for(int j = 0; j < 8; j++) { // loop 8 directiona cells \\n                    int nx = xy[0] + dx[j];\\n                    int ny = xy[1] + dy[j];\\n                    if(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0) { // check if next cell coordinates valid\\n                        grid[nx][ny] = 1;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            level++; // update level after processing level\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\nIf you like solution **upvote**.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1) // check if starting cell itself is blocked -> -1\\n            return -1;\\n        \\n        int m = grid.length, n = grid[0].length; // m = n = N \\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n\\t\\t\\n\\t\\t// dx dy 8 directional vector\\n        int[] dx = new int[]{1, 1, 0, -1, -1, -1, 0, 1};\\n        int[] dy = new int[]{0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n\\t\\t// initialize from source top left cell\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        int level = 1;\\n        \\n        while(q.size() > 0) {\\n            for(int i = q.size(); i > 0; i--) { // iterate all cells in next level\\n                int[] xy = q.poll();\\n                if(xy[0] == m - 1 && xy[1] == n - 1) // check if reached bottom right most cell\\n                    return level;\\n                for(int j = 0; j < 8; j++) { // loop 8 directiona cells \\n                    int nx = xy[0] + dx[j];\\n                    int ny = xy[1] + dy[j];\\n                    if(nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] == 0) { // check if next cell coordinates valid\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            level++; // update level after processing level\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1) // check if starting cell itself is blocked -> -1\\n            return -1;\\n        \\n        int m = grid.length, n = grid[0].length; // m = n = N \\n        Queue<int[]> q = new LinkedList<>();\\n        // boolean[][] visited = new boolean[m][n];\\n\\t\\t\\n\\t\\t// dx dy 8 directional vector\\n        int[] dx = new int[]{1, 1, 0, -1, -1, -1, 0, 1};\\n        int[] dy = new int[]{0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n\\t\\t// initialize from source top left cell\\n        q.add(new int[]{0, 0});\\n        grid[0][0] = 1;\\n        int level = 1;\\n        \\n        while(q.size() > 0) {\\n            for(int i = q.size(); i > 0; i--) { // iterate all cells in next level\\n                int[] xy = q.poll();\\n                if(xy[0] == m - 1 && xy[1] == n - 1) // check if reached bottom right most cell\\n                    return level;\\n                for(int j = 0; j < 8; j++) { // loop 8 directiona cells \\n                    int nx = xy[0] + dx[j];\\n                    int ny = xy[1] + dy[j];\\n                    if(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0) { // check if next cell coordinates valid\\n                        grid[nx][ny] = 1;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            level++; // update level after processing level\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541087,
                "title": "easy-and-clear-java-bfs-solution-with-explanation",
                "content": "Why use BFS instead of DFS?\\nBecause it can explore every possible direction at the same time and with same speed, meaning that if any branch reaches the end, it must be the fastest one. So every point will only be visited once at most and we can exit anytime if we reach the end. (Even if there is a second route reaches the same point, it will not be as fast as the first one, so we do not need to think about detours -  which is very difficult to tackle in DFS solutions.)\\nIf total point number is N, Both time and space complexity is O(N).\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        //initialization for 8 directions, a map(map is the name, it is a Queue for BFS) and row-column boundaries\\n        int[][] dir = {{1,1},{1,0},{0,1},{1,-1},{-1,1},{-1,0},{0,-1},{-1,-1}};\\n        Queue<int[]> map =new LinkedList<>();\\n        int rMax = grid.length;\\n        int cMax = grid[0].length;\\n        \\n        //if start point is blocked, return -1, otherwise give map the start point\\n        if(grid[0][0]==1) return -1; \\n        \\n        //first two parameters are coordinates, third keep track of the distance\\n        map.offer(new int[] {0,0,1});\\n        \\n        while(!map.isEmpty()){\\n            //get current coordinates and distance travelled\\n            int[] location = map.poll();\\n            int r = location[0];\\n            int c = location[1];\\n            int distance = location[2];\\n            \\n            //return if reaches the destination\\n            if(r==rMax-1 && c==cMax-1) return distance;\\n            \\n            //search 8 directions for unexplored points around current point\\n            for(int[] d : dir){\\n                int r2 = r + d[0];\\n                int c2 = c + d[1];\\n                if(r2<rMax && r2>=0 && c2<cMax && c2>=0 && grid[r2][c2]==0){\\n                    //add unexplored point to map and increment distance by 1\\n                    map.offer(new int[] {r2,c2,distance+1});\\n\\t\\t\\t\\t\\t//set this point to 1 as explored\\n                    grid[r2][c2] = 1;\\n                }\\n            }\\n        }   \\n        // whole space searched, cannot reach destination\\n        return -1;\\n    }\\n}\\n```\\n\\nVersion without comments:\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int[][] dir = {{1,1},{1,0},{0,1},{1,-1},{-1,1},{-1,0},{0,-1},{-1,-1}};\\n        Queue<int[]> map =new LinkedList<>();\\n        int rMax = grid.length;\\n        int cMax = grid[0].length;\\n        if(grid[0][0]==1) return -1; \\n        map.offer(new int[] {0,0,1});\\n        while(!map.isEmpty()){\\n            int[] location = map.poll();\\n            int r = location[0];\\n            int c = location[1];\\n            int distance = location[2];\\n            if(r==rMax-1 && c==cMax-1) return distance;\\n            for(int[] d : dir){\\n                int r2 = r + d[0];\\n                int c2 = c + d[1];\\n                if(r2<rMax && r2>=0 && c2<cMax && c2>=0 && grid[r2][c2]==0){\\n                    map.offer(new int[] {r2,c2,distance+1});\\n                    grid[r2][c2] = 1;\\n                }\\n            }\\n        }   \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        //initialization for 8 directions, a map(map is the name, it is a Queue for BFS) and row-column boundaries\\n        int[][] dir = {{1,1},{1,0},{0,1},{1,-1},{-1,1},{-1,0},{0,-1},{-1,-1}};\\n        Queue<int[]> map =new LinkedList<>();\\n        int rMax = grid.length;\\n        int cMax = grid[0].length;\\n        \\n        //if start point is blocked, return -1, otherwise give map the start point\\n        if(grid[0][0]==1) return -1; \\n        \\n        //first two parameters are coordinates, third keep track of the distance\\n        map.offer(new int[] {0,0,1});\\n        \\n        while(!map.isEmpty()){\\n            //get current coordinates and distance travelled\\n            int[] location = map.poll();\\n            int r = location[0];\\n            int c = location[1];\\n            int distance = location[2];\\n            \\n            //return if reaches the destination\\n            if(r==rMax-1 && c==cMax-1) return distance;\\n            \\n            //search 8 directions for unexplored points around current point\\n            for(int[] d : dir){\\n                int r2 = r + d[0];\\n                int c2 = c + d[1];\\n                if(r2<rMax && r2>=0 && c2<cMax && c2>=0 && grid[r2][c2]==0){\\n                    //add unexplored point to map and increment distance by 1\\n                    map.offer(new int[] {r2,c2,distance+1});\\n\\t\\t\\t\\t\\t//set this point to 1 as explored\\n                    grid[r2][c2] = 1;\\n                }\\n            }\\n        }   \\n        // whole space searched, cannot reach destination\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int[][] dir = {{1,1},{1,0},{0,1},{1,-1},{-1,1},{-1,0},{0,-1},{-1,-1}};\\n        Queue<int[]> map =new LinkedList<>();\\n        int rMax = grid.length;\\n        int cMax = grid[0].length;\\n        if(grid[0][0]==1) return -1; \\n        map.offer(new int[] {0,0,1});\\n        while(!map.isEmpty()){\\n            int[] location = map.poll();\\n            int r = location[0];\\n            int c = location[1];\\n            int distance = location[2];\\n            if(r==rMax-1 && c==cMax-1) return distance;\\n            for(int[] d : dir){\\n                int r2 = r + d[0];\\n                int c2 = c + d[1];\\n                if(r2<rMax && r2>=0 && c2<cMax && c2>=0 && grid[r2][c2]==0){\\n                    map.offer(new int[] {r2,c2,distance+1});\\n                    grid[r2][c2] = 1;\\n                }\\n            }\\n        }   \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442676,
                "title": "python-bfs",
                "content": "A regular BFS question, remember to check the length of grid to be valid and check the start point and end point to be valid.\\n\\n\\n```\\n\\nimport collections\\nclass Solution(object):\\n    def shortestPathBinaryMatrix(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1\\n        visited = set((0, 0))\\n        queue = collections.deque([(0, 0, 1)])\\n        \\n        while queue:\\n            x, y, level = queue.popleft()\\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1): return level\\n            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]:\\n                if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]) and grid[x + dx][y + dy] == 0 and (x + dx, y + dy) not in visited:\\n                    visited.add((x + dx, y + dy))\\n                    queue.append((x + dx, y + dy, level + 1))\\n            \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "A regular BFS question, remember to check the length of grid to be valid and check the start point and end point to be valid.\\n\\n\\n```\\n\\nimport collections\\nclass Solution(object):\\n    def shortestPathBinaryMatrix(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1\\n        visited = set((0, 0))\\n        queue = collections.deque([(0, 0, 1)])\\n        \\n        while queue:\\n            x, y, level = queue.popleft()\\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1): return level\\n            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]:\\n                if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]) and grid[x + dx][y + dy] == 0 and (x + dx, y + dy) not in visited:\\n                    visited.add((x + dx, y + dy))\\n                    queue.append((x + dx, y + dy, level + 1))\\n            \\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2044691,
                "title": "c-bfs-explanation-with-comments-daily-leetcoding-challenge-may-day-16",
                "content": "![image](https://assets.leetcode.com/users/images/eb522a64-f2c8-4971-9a25-c646d875e39a_1652702897.407756.jpeg)\\n**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    /*\\n       8 moves, if you are at i,j\\n   \\n\\t   i-1,j-1    i-1,j    i-1,j+1\\n\\t   i,j-1      i,j      i,j+1\\n \\t   i+1,j+1    i+1,j    i+1,j+1\\n    */\\n    \\n    // just check that current i or j inside the boundary and also check it is not having value eqaul to zero\\n    // and also check it is not visited previously\\n    bool check(int i,int j,map<pair<int,int>,bool>& visited,vector<vector<int>>& grid)\\n    {\\n        int n = grid.size();\\n    \\n        // if current i and j follows the given conditions then return true\\n        if(i >= 0 && j >= 0 && i < n && j < n && grid[i][j] != 1 && (visited.find({i,j}) == visited.end()))\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        // if first element of our grid is not zero then return -1\\n        if(grid[0][0] == 1) return -1;\\n        \\n        int n = grid.size();\\n       \\n        // craeting a queue that will store the cordinates and their corresponding path value\\n        queue<vector<int>> Q;\\n        Q.push({0,0,0}); // i,j,dist\\n        \\n        // this map will take care of ecah cell that it is vidites or not\\n        // initially all the cells are false means not visited\\n        map<pair<int,int>,bool> visited;\\n        \\n        // making very first cell is true because we are going to start from here\\n        visited[{0,0}] = true;\\n        \\n        // BFS\\n        while(!Q.empty())\\n        {\\n            // take our the front vector from queue\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            // extracting the data information\\n            int i = curr[0],j = curr[1],dist = curr[2];\\n            \\n            // if we reach to the last cell then return the dist+1 because we will also consider current cell value as 1\\n            if(i == n-1 && j == n-1)\\n            {\\n                return dist+1;\\n            }\\n            \\n            // left(check it will be following or not)\\n            if(check(i,j-1,visited,grid))\\n            {\\n                visited[{i,j-1}] = true;\\n                Q.push({i,j-1,dist+1});\\n            }\\n            \\n            // right\\n            if(check(i,j+1,visited,grid))\\n            {\\n                visited[{i,j+1}] = true;\\n                Q.push({i,j+1,dist+1});\\n            }\\n            \\n            // up \\n            if(check(i-1,j,visited,grid))\\n            {\\n                visited[{i-1,j}] = true;\\n                Q.push({i-1,j,dist+1});\\n            }\\n            \\n            // down \\n            if(check(i+1,j,visited,grid))\\n            {\\n                visited[{i+1,j}] = true;\\n                Q.push({i+1,j,dist+1});\\n            }\\n            \\n            // leftUp\\n            if(check(i-1,j-1,visited,grid))\\n            {\\n                visited[{i-1,j-1}] = true;\\n                Q.push({i-1,j-1,dist+1});\\n            }\\n            \\n            // rightUp \\n            if(check(i-1,j+1,visited,grid))\\n            {\\n                visited[{i-1,j+1}] = true;\\n                Q.push({i-1,j+1,dist+1});\\n            }\\n            \\n            // leftDown \\n            if(check(i+1,j-1,visited,grid))\\n            {\\n                visited[{i+1,j-1}] = true;\\n                Q.push({i+1,j-1,dist+1});\\n            }\\n            \\n            // rightDown \\n            if(check(i+1,j+1,visited,grid))\\n            {\\n                visited[{i+1,j+1}] = true;\\n                Q.push({i+1,j+1,dist+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n       8 moves, if you are at i,j\\n   \\n\\t   i-1,j-1    i-1,j    i-1,j+1\\n\\t   i,j-1      i,j      i,j+1\\n \\t   i+1,j+1    i+1,j    i+1,j+1\\n    */\\n    \\n    // just check that current i or j inside the boundary and also check it is not having value eqaul to zero\\n    // and also check it is not visited previously\\n    bool check(int i,int j,map<pair<int,int>,bool>& visited,vector<vector<int>>& grid)\\n    {\\n        int n = grid.size();\\n    \\n        // if current i and j follows the given conditions then return true\\n        if(i >= 0 && j >= 0 && i < n && j < n && grid[i][j] != 1 && (visited.find({i,j}) == visited.end()))\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        // if first element of our grid is not zero then return -1\\n        if(grid[0][0] == 1) return -1;\\n        \\n        int n = grid.size();\\n       \\n        // craeting a queue that will store the cordinates and their corresponding path value\\n        queue<vector<int>> Q;\\n        Q.push({0,0,0}); // i,j,dist\\n        \\n        // this map will take care of ecah cell that it is vidites or not\\n        // initially all the cells are false means not visited\\n        map<pair<int,int>,bool> visited;\\n        \\n        // making very first cell is true because we are going to start from here\\n        visited[{0,0}] = true;\\n        \\n        // BFS\\n        while(!Q.empty())\\n        {\\n            // take our the front vector from queue\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            // extracting the data information\\n            int i = curr[0],j = curr[1],dist = curr[2];\\n            \\n            // if we reach to the last cell then return the dist+1 because we will also consider current cell value as 1\\n            if(i == n-1 && j == n-1)\\n            {\\n                return dist+1;\\n            }\\n            \\n            // left(check it will be following or not)\\n            if(check(i,j-1,visited,grid))\\n            {\\n                visited[{i,j-1}] = true;\\n                Q.push({i,j-1,dist+1});\\n            }\\n            \\n            // right\\n            if(check(i,j+1,visited,grid))\\n            {\\n                visited[{i,j+1}] = true;\\n                Q.push({i,j+1,dist+1});\\n            }\\n            \\n            // up \\n            if(check(i-1,j,visited,grid))\\n            {\\n                visited[{i-1,j}] = true;\\n                Q.push({i-1,j,dist+1});\\n            }\\n            \\n            // down \\n            if(check(i+1,j,visited,grid))\\n            {\\n                visited[{i+1,j}] = true;\\n                Q.push({i+1,j,dist+1});\\n            }\\n            \\n            // leftUp\\n            if(check(i-1,j-1,visited,grid))\\n            {\\n                visited[{i-1,j-1}] = true;\\n                Q.push({i-1,j-1,dist+1});\\n            }\\n            \\n            // rightUp \\n            if(check(i-1,j+1,visited,grid))\\n            {\\n                visited[{i-1,j+1}] = true;\\n                Q.push({i-1,j+1,dist+1});\\n            }\\n            \\n            // leftDown \\n            if(check(i+1,j-1,visited,grid))\\n            {\\n                visited[{i+1,j-1}] = true;\\n                Q.push({i+1,j-1,dist+1});\\n            }\\n            \\n            // rightDown \\n            if(check(i+1,j+1,visited,grid))\\n            {\\n                visited[{i+1,j+1}] = true;\\n                Q.push({i+1,j+1,dist+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901706,
                "title": "simple-c-with-explanation-and-why-it-s-not-rotten-oranges-problem",
                "content": "It\\'s a simple BFS problem. Basically, visit all the neighboring nodes first and then keep going till all the elements are visited at least once or if you reach the end node ie `(n, m)`\\n\\nWhy is this not a rotten oranges problem? **Major Spoiler alert** if you haven\\'t solved it yet!\\nIn rotten oranges, the key idea is to start from every rotten orange and go till every orange is rotten. Level/depth of the traversal is important. Here, it\\'s a simple BFS which begins at `(0, 0)` and ends at `(n,m)`.\\n\\n**Intuition:**\\nIt can be solved in two ways of the same time complexity. Both **`O(N * M)`**\\n\\n**One way**, is to remember the distance from `(0,0)` to `(n,m)` inside the queue along with the indices as the third element. Ex: `(0, 0, 1)` and thus keep on adding 1s until you reach `(n, m, shortestDistance)` and return `shortestDistance`.\\n\\nBecause I\\'m doing it in-place, I *don\\'t need `visited` array*.\\n\\n```\\n// For explanation check the next code snippet. Idea is exactly same.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector <vector <int>> moves = {{-1,-1}, {-1, 0}, {-1, 1}, {0, -1},{0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n        int n = grid.size() - 1;\\n        int m = grid[0].size() - 1;\\n        queue <vector <int>> que;\\n        if(grid[0][0] || grid[n][m])\\n            return -1;\\n        que.push({0, 0, 1});\\n        while(!que.empty()){\\n            vector <int> top = que.front();\\n            que.pop();\\n            if(top[0] == n && top[1] == m)\\n                return top[2];\\n            for(vector <int> move: moves){\\n                int x = top[0] + move[0], y = top[1] + move[1];\\n                if( 0 <= x && x <= n && 0 <= y && y <= m && grid[x][y] == 0){\\n                    grid[x][y] = 1;  // mark visted\\n                    que.push({x, y, top[2] + 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Another way**, is to propagate the distance to the neighbors based on my current distance. So, just add one to neighbors. This way, there is a slight improvement in memory. Simply do a BFS but for 8 steps with the first step already taken as 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector <vector <int>> moves = {{-1,-1}, {-1, 0}, {-1, 1}, {0, -1},{0, 1}, {1, -1}, {1, 0}, {1, 1}}; // The order doesn\\'t matter.\\n        int n = grid.size() - 1;\\n        int m = grid[0].size() - 1;\\n        queue <vector <int>> que;\\n        if(grid[0][0] || grid[n][m])\\n            return -1;\\n        que.push({0, 0});\\n        grid[0][0] = 1;\\n        while(!que.empty() && !grid[n][m]){ \\n\\t\\t/* If my last node is visited, I exit immediately.\\n\\t\\t* 1. The Fastest path is always the shortest path in BFS \\n\\t\\t*    Hence, The first path to reach the end is the shortest path.\\n\\t\\t*    Early termination is needed here. If there is a lot of\\n\\t\\t*    unvisited nodes in-between that don\\'t lead to the end node, it gives TLE.\\n\\t\\t* 2. Doing a level order(two loops) is also possible. But we don\\'t need to remember the level.\\n\\t\\t*    So one loop will do\\n\\t\\t*/\\n            vector <int> top = que.front();      // Do not use \\'auto\\' here. I gives TLE\\n            que.pop();\\n            for(vector <int> move: moves){       // Do not use \\'auto\\' here. I gives TLE\\n                int x = top[0] + move[0], y = top[1] + move[1];\\n                if(0 <= x && x <= n && 0 <= y && y <= m && grid[x][y] == 0){\\n                    grid[x][y] = grid[top[0]][top[1]] + 1;   // mark visted and propagate the distance\\n                    que.push({x, y});\\n                }\\n            }\\n        }\\n        return grid[n][m] == 0 ? -1 : grid[n][m];   // If the queue terminated without setting (n, m) to a value other than zero, it means it could never reach the end.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n// For explanation check the next code snippet. Idea is exactly same.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector <vector <int>> moves = {{-1,-1}, {-1, 0}, {-1, 1}, {0, -1},{0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n        int n = grid.size() - 1;\\n        int m = grid[0].size() - 1;\\n        queue <vector <int>> que;\\n        if(grid[0][0] || grid[n][m])\\n            return -1;\\n        que.push({0, 0, 1});\\n        while(!que.empty()){\\n            vector <int> top = que.front();\\n            que.pop();\\n            if(top[0] == n && top[1] == m)\\n                return top[2];\\n            for(vector <int> move: moves){\\n                int x = top[0] + move[0], y = top[1] + move[1];\\n                if( 0 <= x && x <= n && 0 <= y && y <= m && grid[x][y] == 0){\\n                    grid[x][y] = 1;  // mark visted\\n                    que.push({x, y, top[2] + 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector <vector <int>> moves = {{-1,-1}, {-1, 0}, {-1, 1}, {0, -1},{0, 1}, {1, -1}, {1, 0}, {1, 1}}; // The order doesn\\'t matter.\\n        int n = grid.size() - 1;\\n        int m = grid[0].size() - 1;\\n        queue <vector <int>> que;\\n        if(grid[0][0] || grid[n][m])\\n            return -1;\\n        que.push({0, 0});\\n        grid[0][0] = 1;\\n        while(!que.empty() && !grid[n][m]){ \\n\\t\\t/* If my last node is visited, I exit immediately.\\n\\t\\t* 1. The Fastest path is always the shortest path in BFS \\n\\t\\t*    Hence, The first path to reach the end is the shortest path.\\n\\t\\t*    Early termination is needed here. If there is a lot of\\n\\t\\t*    unvisited nodes in-between that don\\'t lead to the end node, it gives TLE.\\n\\t\\t* 2. Doing a level order(two loops) is also possible. But we don\\'t need to remember the level.\\n\\t\\t*    So one loop will do\\n\\t\\t*/\\n            vector <int> top = que.front();      // Do not use \\'auto\\' here. I gives TLE\\n            que.pop();\\n            for(vector <int> move: moves){       // Do not use \\'auto\\' here. I gives TLE\\n                int x = top[0] + move[0], y = top[1] + move[1];\\n                if(0 <= x && x <= n && 0 <= y && y <= m && grid[x][y] == 0){\\n                    grid[x][y] = grid[top[0]][top[1]] + 1;   // mark visted and propagate the distance\\n                    que.push({x, y});\\n                }\\n            }\\n        }\\n        return grid[n][m] == 0 ? -1 : grid[n][m];   // If the queue terminated without setting (n, m) to a value other than zero, it means it could never reach the end.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361508,
                "title": "c-dfs-tle-bfs-work",
                "content": "**Here `DFS` give `TLE` because we search for every path and then take min out of all that paths**\\n**But `BFS` work \\uD83E\\uDD14 why ?**\\n**because we do traverse in `DFS` manner so first time when we get target cell a[n-1][n-1] then this path is always minimum as we do `DFS`**\\n*Both solution are mentioned bellow*\\n****\\n**DFS ->TLE**\\n```\\nclass Solution {\\npublic:\\n\\tint shortestPathBinaryMatrix(vector<vector<int>>&a) {\\n\\t\\tint ans = INT_MAX;\\n\\t\\tint tempans = 0;\\n\\t\\tint n = a.size();\\n\\t\\tif (a[n - 1][n - 1] != 0)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tsolve(0, 0, n, a, tempans, ans);\\n\\n\\t\\tif (ans == INT_MAX)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn (ans + 1);\\n\\t}\\n\\n\\tvoid solve(int i, int j, int n, vector<vector<int>>&a, int &tempans, int &ans)\\n\\t{\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= n || a[i][j] == 1)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse if (i == n - 1 && j == n - 1)\\n\\t\\t{\\n\\t\\t\\tans = min(ans, tempans);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ta[i][j] = 1;\\n\\t\\ttempans++;\\n\\t\\tsolve(i + 1, j, n, a, tempans, ans);\\n\\t\\tsolve(i, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j, n, a, tempans, ans);\\n\\t\\tsolve(i, j - 1, n, a, tempans, ans);\\n\\t\\tsolve(i + 1, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i + 1, j - 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j - 1, n, a, tempans, ans);\\n\\t\\ttempans--;\\n\\t\\ta[i][j] = 0;\\n\\t}\\n};\\n```\\n\\n**BFS\\uD83D\\uDE03**\\n```\\nclass Solution {\\npublic:\\n\\n\\tint dirx[8] = {0, 0, 1, -1, 1, 1, -1, -1};\\n\\tint diry[8] = {1, -1, 0, 0, -1, 1, -1, 1};\\n\\n\\tint shortestPathBinaryMatrix(vector<vector<int>>& a) {\\n\\t\\tint n = a.size();\\n\\t\\tif (a[0][0] != 0 || a[n - 1][n - 1] != 0)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tqueue<pair<int, int>>q;\\n\\t\\tq.push({0, 0});\\n\\t\\tint step = 0;\\n\\t\\tint size = 0;\\n\\t\\tint x , y, newx, newy;\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tstep++;\\n\\t\\t\\tsize = q.size();\\n\\t\\t\\twhile (size--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tx = q.front().first;\\n\\t\\t\\t\\ty = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif (x == n - 1 && y == n - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn step;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int i = 0; i < 8; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewx = x + dirx[i];\\n\\t\\t\\t\\t\\tnewy = y + diry[i];\\n\\t\\t\\t\\t\\tif (newx >= 0 && newx < n && newy >= 0 && newy < n && a[newx][newy] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ta[newx][newy] = 1;\\n\\t\\t\\t\\t\\t\\tq.push({newx, newy});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n};\\n```\\n\\n**If find helpful upvote it\\u2714**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint shortestPathBinaryMatrix(vector<vector<int>>&a) {\\n\\t\\tint ans = INT_MAX;\\n\\t\\tint tempans = 0;\\n\\t\\tint n = a.size();\\n\\t\\tif (a[n - 1][n - 1] != 0)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tsolve(0, 0, n, a, tempans, ans);\\n\\n\\t\\tif (ans == INT_MAX)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn (ans + 1);\\n\\t}\\n\\n\\tvoid solve(int i, int j, int n, vector<vector<int>>&a, int &tempans, int &ans)\\n\\t{\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= n || a[i][j] == 1)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse if (i == n - 1 && j == n - 1)\\n\\t\\t{\\n\\t\\t\\tans = min(ans, tempans);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ta[i][j] = 1;\\n\\t\\ttempans++;\\n\\t\\tsolve(i + 1, j, n, a, tempans, ans);\\n\\t\\tsolve(i, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j, n, a, tempans, ans);\\n\\t\\tsolve(i, j - 1, n, a, tempans, ans);\\n\\t\\tsolve(i + 1, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i + 1, j - 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j - 1, n, a, tempans, ans);\\n\\t\\ttempans--;\\n\\t\\ta[i][j] = 0;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\tint dirx[8] = {0, 0, 1, -1, 1, 1, -1, -1};\\n\\tint diry[8] = {1, -1, 0, 0, -1, 1, -1, 1};\\n\\n\\tint shortestPathBinaryMatrix(vector<vector<int>>& a) {\\n\\t\\tint n = a.size();\\n\\t\\tif (a[0][0] != 0 || a[n - 1][n - 1] != 0)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tqueue<pair<int, int>>q;\\n\\t\\tq.push({0, 0});\\n\\t\\tint step = 0;\\n\\t\\tint size = 0;\\n\\t\\tint x , y, newx, newy;\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tstep++;\\n\\t\\t\\tsize = q.size();\\n\\t\\t\\twhile (size--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tx = q.front().first;\\n\\t\\t\\t\\ty = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif (x == n - 1 && y == n - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn step;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int i = 0; i < 8; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewx = x + dirx[i];\\n\\t\\t\\t\\t\\tnewy = y + diry[i];\\n\\t\\t\\t\\t\\tif (newx >= 0 && newx < n && newy >= 0 && newy < n && a[newx][newy] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ta[newx][newy] = 1;\\n\\t\\t\\t\\t\\t\\tq.push({newx, newy});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584016,
                "title": "java-bfs-beats-70-18-lines-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse BFS to traverse from the top left corner to the bottom right corner. Consider all 8 directions from the current cell for the next move. Only consider moving to cells with value `0`. Maintain a `seen` boolean map to keep track of cells that have already been added to the BFS queue so as to not process them again. Using BFS will ensure that we reach the bottom right corner in the minimum number of steps possible.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int shortestPathBinaryMatrix(int[][] grid) {\\n    if (grid[0][0] == 1) return -1;\\n\\n    var moves = new int[][] {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\\n    var n = grid.length;\\n    var seen = new boolean[n][n];\\n    var queue = new ArrayDeque<int[]>();\\n    queue.offer(new int[] {0, 0});\\n\\n    for (var cnt = 1; !queue.isEmpty(); cnt++) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var cell = queue.poll();\\n\\n        if (cell[0] == n-1 && cell[1] == n-1)\\n          return cnt;\\n\\n        for (var move : moves) {\\n          var x = cell[0] + move[0];\\n          var y = cell[1] + move[1];\\n\\n          if (x >= 0 && x < n && y >= 0 && y < n && !seen[x][y] && grid[x][y] == 0) {\\n            seen[x][y] = true;\\n            queue.offer(new int[] {x, y});\\n          }\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  public int shortestPathBinaryMatrix(int[][] grid) {\\n    if (grid[0][0] == 1) return -1;\\n\\n    var moves = new int[][] {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\\n    var n = grid.length;\\n    var seen = new boolean[n][n];\\n    var queue = new ArrayDeque<int[]>();\\n    queue.offer(new int[] {0, 0});\\n\\n    for (var cnt = 1; !queue.isEmpty(); cnt++) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var cell = queue.poll();\\n\\n        if (cell[0] == n-1 && cell[1] == n-1)\\n          return cnt;\\n\\n        for (var move : moves) {\\n          var x = cell[0] + move[0];\\n          var y = cell[1] + move[1];\\n\\n          if (x >= 0 && x < n && y >= 0 && y < n && !seen[x][y] && grid[x][y] == 0) {\\n            seen[x][y] = true;\\n            queue.offer(new int[] {x, y});\\n          }\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491524,
                "title": "python-bfs-to-find-shortest-path-in-non-weight-graph-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1\\n        \\n        q = deque([(0, 0)])  # pair of (r, c)\\n        dist = 1\\n        while q:\\n            for _ in range(len(q)):\\n                r, c = q.popleft()\\n                if r == m-1 and c == n-1: return dist\\n                for dr in range(-1, 2):\\n                    for dc in range(-1, 2):\\n                        if dr == 0 and dc == 0: continue\\n                        nr, nc = r + dr, c + dc\\n                        if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == 1: continue\\n                        grid[nr][nc] = 1  # marked as visited\\n                        q.append((nr, nc))\\n            dist += 1\\n        return -1\\n```\\n**Complexity**\\n- Time: `O(M * N)`, where `M <= 100` is the number of rows, `N <= 100` is number of columns in the matrix.\\n\\t- BFS cost `O(E + V)`, where `E = 8 * V` is number of edges, `V = M*N` is number of vertices.\\n\\t- So total complexity: `O(8V + V)` = `O(9V)` = `O(9 * M*N)` ~ `O(M*N)`\\n- Space: `O(M * N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1\\n        \\n        q = deque([(0, 0)])  # pair of (r, c)\\n        dist = 1\\n        while q:\\n            for _ in range(len(q)):\\n                r, c = q.popleft()\\n                if r == m-1 and c == n-1: return dist\\n                for dr in range(-1, 2):\\n                    for dc in range(-1, 2):\\n                        if dr == 0 and dc == 0: continue\\n                        nr, nc = r + dr, c + dc\\n                        if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == 1: continue\\n                        grid[nr][nc] = 1  # marked as visited\\n                        q.append((nr, nc))\\n            dist += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584102,
                "title": "beats-99-video-solution-java-c-python",
                "content": "# Intuition\\nWhenever the problem is about shortest path, the first thing that comes up is BFS.\\n\\n# Approach\\n1. Check if the top-left or bottom-right cell is blocked by checking if their values are 1. If either of these cells is blocked, we return -1 because there is no valid path.\\n2. Initialize the size of the grid and define two arrays, dx and dy, which represent the changes in the x and y coordinates when moving in different directions\\n3. Initiate queue. Each element in the queue is an array containing the x and y coordinates of a cell and the number of steps taken to reach that cell.\\n4. Add 0,0,1 to queue and mark grid[0][0] = 1\\n5. While the queue isnot empty, add all valid positions that can be visited from this cell and increase step by 1\\n6.  Mark all valid positions = 1 (No revisit)\\n7.  if cell = n-1, n-1 return steps\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/VNmujmu3UjA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] == 1 || grid[grid.length - 1][grid[0].length - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        int n = grid.length;\\n        int[]dx = {-1,0,1};\\n        int[]dy = {-1,0,1};\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0, 1});\\n        grid[0][0] = 1;\\n        \\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int x = curr[0];\\n            int y = curr[1];\\n            int steps = curr[2];\\n            \\n            if (x == n - 1 && y == n - 1) {\\n                return steps;\\n            }\\n            \\n            for(int i = 0;i<3;i++){\\n                for(int j = 0;j<3;j++){\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[j];\\n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                    queue.offer(new int[]{nx, ny, steps + 1});\\n                    grid[nx][ny] = 1;\\n                }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(std::vector<std::vector<int>>& grid) {\\n        if (grid[0][0] == 1 || grid[grid.size() - 1][grid[0].size() - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        int n = grid.size();\\n        std::vector<int> dx = {-1, 0, 1};\\n        std::vector<int> dy = {-1, 0, 1};\\n        \\n        std::queue<std::vector<int>> queue;\\n        queue.push({0, 0, 1});\\n        grid[0][0] = 1;\\n        \\n        while (!queue.empty()) {\\n            std::vector<int> curr = queue.front();\\n            queue.pop();\\n            int x = curr[0];\\n            int y = curr[1];\\n            int steps = curr[2];\\n            \\n            if (x == n - 1 && y == n - 1) {\\n                return steps;\\n            }\\n            \\n            for (int i = 0; i < 3; i++) {\\n                for (int j = 0; j < 3; j++) {\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[j];\\n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                        queue.push({nx, ny, steps + 1});\\n                        grid[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n\\n```\\nfrom typing import List\\nfrom queue import Queue\\n\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] == 1 or grid[-1][-1] == 1:\\n            return -1\\n        \\n        n = len(grid)\\n        dx = [-1, 0, 1]\\n        dy = [-1, 0, 1]\\n        \\n        queue = Queue()\\n        queue.put([0, 0, 1])\\n        grid[0][0] = 1\\n        \\n        while not queue.empty():\\n            x, y, steps = queue.get()\\n            \\n            if x == n - 1 and y == n - 1:\\n                return steps\\n            \\n            for i in range(3):\\n                for j in range(3):\\n                    nx = x + dx[i]\\n                    ny = y + dy[j]\\n                    \\n                    if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0:\\n                        queue.put([nx, ny, steps + 1])\\n                        grid[nx][ny] = 1\\n        \\n        return -1\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] == 1 || grid[grid.length - 1][grid[0].length - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        int n = grid.length;\\n        int[]dx = {-1,0,1};\\n        int[]dy = {-1,0,1};\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0, 1});\\n        grid[0][0] = 1;\\n        \\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int x = curr[0];\\n            int y = curr[1];\\n            int steps = curr[2];\\n            \\n            if (x == n - 1 && y == n - 1) {\\n                return steps;\\n            }\\n            \\n            for(int i = 0;i<3;i++){\\n                for(int j = 0;j<3;j++){\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[j];\\n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                    queue.offer(new int[]{nx, ny, steps + 1});\\n                    grid[nx][ny] = 1;\\n                }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(std::vector<std::vector<int>>& grid) {\\n        if (grid[0][0] == 1 || grid[grid.size() - 1][grid[0].size() - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        int n = grid.size();\\n        std::vector<int> dx = {-1, 0, 1};\\n        std::vector<int> dy = {-1, 0, 1};\\n        \\n        std::queue<std::vector<int>> queue;\\n        queue.push({0, 0, 1});\\n        grid[0][0] = 1;\\n        \\n        while (!queue.empty()) {\\n            std::vector<int> curr = queue.front();\\n            queue.pop();\\n            int x = curr[0];\\n            int y = curr[1];\\n            int steps = curr[2];\\n            \\n            if (x == n - 1 && y == n - 1) {\\n                return steps;\\n            }\\n            \\n            for (int i = 0; i < 3; i++) {\\n                for (int j = 0; j < 3; j++) {\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[j];\\n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                        queue.push({nx, ny, steps + 1});\\n                        grid[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\n```\\nfrom typing import List\\nfrom queue import Queue\\n\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] == 1 or grid[-1][-1] == 1:\\n            return -1\\n        \\n        n = len(grid)\\n        dx = [-1, 0, 1]\\n        dy = [-1, 0, 1]\\n        \\n        queue = Queue()\\n        queue.put([0, 0, 1])\\n        grid[0][0] = 1\\n        \\n        while not queue.empty():\\n            x, y, steps = queue.get()\\n            \\n            if x == n - 1 and y == n - 1:\\n                return steps\\n            \\n            for i in range(3):\\n                for j in range(3):\\n                    nx = x + dx[i]\\n                    ny = y + dy[j]\\n                    \\n                    if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0:\\n                        queue.put([nx, ny, steps + 1])\\n                        grid[nx][ny] = 1\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734015,
                "title": "bfs-tle-resolved",
                "content": "For those people getting TLE while applying bfs solution, your solution might be similar to:\\n(Language may differ but logic might be same i.e removing from queue and then marking it visited)\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        row=grid.length; \\n        col=grid[0].length;\\n\\t\\t\\n        if(grid[0][0]==1 || grid[row-1][col-1]==1) return -1;\\n        \\n\\t\\tint[] dirx={0,1,1,1,0,-1,-1,-1};\\n        int[] diry={-1,-1,0,1,1,1,0,-1};\\n        \\n\\t\\tQueue<Pair> q=new ArrayDeque<>();\\n        \\n\\t\\tif(row-1==0 && col-1==0) return 1;\\n        \\n\\t\\tboolean[][] visited=new boolean[row][col];\\n        \\n        q.add(new Pair(0,0,1));\\n        while(q.size()!=0){\\n            Pair p=q.remove();\\n            int cx=p.x;\\n            int cy=p.y;\\n            visited[cx][cy]=true;\\n            int dist=p.dist;\\n            for(int i=0;i<8;i++){\\n                int x=cx+dirx[i];\\n                int y=cy+diry[i];\\n                if(isValid(x,y) && grid[x][y]!=1 && !visited[x][y]){\\n                    if(x==grid.length-1 && y==grid[0].length-1) return dist+1;\\n                    q.add(new Pair(x,y,dist+1));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    public class Pair{\\n        int x;\\n        int y;\\n        int dist;\\n        Pair(int i,int j,int dist){\\n            x=i;\\n            y=j;\\n            this.dist=dist;\\n        }\\n    }\\n    int row;\\n    int col;\\n    public boolean isValid(int x,int y){\\n        if(x>=row || x<0 || y>=col || y<0) return false;\\n        return true;\\n    }\\n}\\n```\\nso now consider the following part of some large test case:\\n0 0 0\\n0 0 0\\n0 0 0\\nand suppose your visited array for this part to be:\\nT F F\\nF F F\\nF F F\\n\\nLet\\'s suppose you are at the middle element and you removed that element from queue and add all its unvisited neighbouring elements(in the order: N, N-E, E, S, S-E ,W ,N-W ). So for next iteration it will be the turn for mid element in top row (let say element x) , you remove it from queue and add its neighbour.\\n\\nImportant: Note that its left and right element although you have visited them in previous iteration but they are still in the queue and are unvisited in the visited array. Now while adding the neighbouring elements of element x you will again add its left and right element which is a repetetive task.\\n\\nIn large testcases this repetion will result in TLE.\\n\\nTo avoid this repetetion its better to first mark the element as visited and then adding it to the queue as follows:\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        row=grid.length;\\n        col=grid[0].length;\\n        \\n        if(grid[0][0]==1 || grid[row-1][col-1]==1) return -1;\\n        \\n        int[] dirx={0,1,1,1,0,-1,-1,-1};\\n        int[] diry={-1,-1,0,1,1,1,0,-1};\\n        \\n        Queue<Pair> q=new ArrayDeque<>();\\n        \\n        boolean[][] visited=new boolean[row][col];\\n        visited[0][0]=true;\\n        q.add(new Pair(0,0,1));\\n        while(q.size()!=0){\\n            Pair p=q.remove();\\n            int cx=p.x;\\n            int cy=p.y;\\n            if(cx==grid.length-1 && cy==grid[0].length-1) return p.dist;\\n            // visited[cx][cy]=true;    \\n            int dist=p.dist;\\n            for(int i=0;i<8;i++){\\n                int x=cx+dirx[i];\\n                int y=cy+diry[i];\\n                if(isValid(x,y) && grid[x][y]!=1 && !visited[x][y]){\\n                    \\n                    q.add(new Pair(x,y,dist+1));\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public class Pair{\\n        int x;\\n        int y;\\n        int dist;\\n        Pair(int i,int j,int dist){\\n            x=i;\\n            y=j;\\n            this.dist=dist;\\n        }\\n    }\\n    \\n    int row;\\n    int col;\\n    \\n    public boolean isValid(int x,int y){\\n        if(x>=row || x<0 || y>=col || y<0) return false;\\n        return true;\\n    }\\n}\\n```\\nHope it helps. If some corrections are required then you can share it comments. Thank You!",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        row=grid.length; \\n        col=grid[0].length;\\n\\t\\t\\n        if(grid[0][0]==1 || grid[row-1][col-1]==1) return -1;\\n        \\n\\t\\tint[] dirx={0,1,1,1,0,-1,-1,-1};\\n        int[] diry={-1,-1,0,1,1,1,0,-1};\\n        \\n\\t\\tQueue<Pair> q=new ArrayDeque<>();\\n        \\n\\t\\tif(row-1==0 && col-1==0) return 1;\\n        \\n\\t\\tboolean[][] visited=new boolean[row][col];\\n        \\n        q.add(new Pair(0,0,1));\\n        while(q.size()!=0){\\n            Pair p=q.remove();\\n            int cx=p.x;\\n            int cy=p.y;\\n            visited[cx][cy]=true;\\n            int dist=p.dist;\\n            for(int i=0;i<8;i++){\\n                int x=cx+dirx[i];\\n                int y=cy+diry[i];\\n                if(isValid(x,y) && grid[x][y]!=1 && !visited[x][y]){\\n                    if(x==grid.length-1 && y==grid[0].length-1) return dist+1;\\n                    q.add(new Pair(x,y,dist+1));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    public class Pair{\\n        int x;\\n        int y;\\n        int dist;\\n        Pair(int i,int j,int dist){\\n            x=i;\\n            y=j;\\n            this.dist=dist;\\n        }\\n    }\\n    int row;\\n    int col;\\n    public boolean isValid(int x,int y){\\n        if(x>=row || x<0 || y>=col || y<0) return false;\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        row=grid.length;\\n        col=grid[0].length;\\n        \\n        if(grid[0][0]==1 || grid[row-1][col-1]==1) return -1;\\n        \\n        int[] dirx={0,1,1,1,0,-1,-1,-1};\\n        int[] diry={-1,-1,0,1,1,1,0,-1};\\n        \\n        Queue<Pair> q=new ArrayDeque<>();\\n        \\n        boolean[][] visited=new boolean[row][col];\\n        visited[0][0]=true;\\n        q.add(new Pair(0,0,1));\\n        while(q.size()!=0){\\n            Pair p=q.remove();\\n            int cx=p.x;\\n            int cy=p.y;\\n            if(cx==grid.length-1 && cy==grid[0].length-1) return p.dist;\\n            // visited[cx][cy]=true;    \\n            int dist=p.dist;\\n            for(int i=0;i<8;i++){\\n                int x=cx+dirx[i];\\n                int y=cy+diry[i];\\n                if(isValid(x,y) && grid[x][y]!=1 && !visited[x][y]){\\n                    \\n                    q.add(new Pair(x,y,dist+1));\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public class Pair{\\n        int x;\\n        int y;\\n        int dist;\\n        Pair(int i,int j,int dist){\\n            x=i;\\n            y=j;\\n            this.dist=dist;\\n        }\\n    }\\n    \\n    int row;\\n    int col;\\n    \\n    public boolean isValid(int x,int y){\\n        if(x>=row || x<0 || y>=col || y<0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586015,
                "title": "video-explanation-from-basic-bfs-to-problem-simulation-step-by-step-java",
                "content": "# Approach\\nhttps://youtu.be/63z07AcXYhY\\n\\n# Similar Problems:\\nI recommend comparing these problems:\\n- [1102. Path With Maximum Minimum Value](https://leetcode.com/problems/path-with-maximum-minimum-value/)\\n- [1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/description/)\\n- [1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/description/)\\n- [1368. Minimum Cost to Make at Least One Valid Path in a Grid](https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description/)\\n- [2093. Minimum Cost to Reach City With Discounts](https://leetcode.com/problems/minimum-cost-to-reach-city-with-discounts/)\\n- [2247. Maximum Cost of Trip With K Highways](https://leetcode.com/problems/maximum-cost-of-trip-with-k-highways/)\\n\\nTheses are the most basic problems for Dijkstra\\'s. We should return to these problems whenever we forget or question why Dijkstra\\'s works.\\n- [787. Cheapest Flights Within K Stops\\n](https://leetcode.com/problems/cheapest-flights-within-k-stops/)\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\nEach cell was guaranteed to be enqueued at most once. This is because a condition for a cell to be enqueued was that it had a zero in the grid, and when enqueuing, we also permanently changed the cell\\'s grid value to be non-zero.\\nThe outer loop ran as long as there were still cells in the queue, dequeuing one each time. Therefore, it ran at most $$N$$ times, giving a time complexity of $$O(N)$$.\\nThe inner loop iterated over the unvisited neighbors of the cell that was dequeued by the outer loop. There were at most $$8$$ neighbors. Identifying the unvisited neighbors is an $$O(1)$$ operation because we treat the $$8$$ as a constant.\\nTherefore, we have a time complexity of $$O(N)$$.\\n\\n- Space complexity: $$O(N)$$\\nThe only additional space we used was the queue. We determined above that at most, we enqueued NNN cells. Therefore, an upper bound on the worst-case space complexity is $$O(N)$$.\\nGiven that BFS will have nodes of at most two unique distances on the queue at any one time, it would be reasonable to wonder if the worst-case space complexity is actually lower. But actually, it turns out that there are cases with massive grids where the number of cells at a single distance is proportional to $$N$$. So even with cells of a single distance on the queue, in the worst case, the space needed is $$O(N)$$.\\n\\n# Breadth-first Search (Overwriting the Input)\\n``` Java []\\nclass Solution {\\n    int ROW, COL;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        \\n        if (grid[0][0] != 0 || grid[ROW - 1][COL - 1] != 0) {\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] dirs = new int[][]{{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1}};\\n        q.offer(new int[]{0, 0});\\n        grid[0][0] = 1;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int row = cur[0];\\n            int col = cur[1];\\n            int distance = grid[row][col];\\n            if(row == ROW-1 && col == COL-1) {\\n                return distance;\\n            }\\n            for(int[] dir : dirs) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(isBound(newRow, newCol) && grid[newRow][newCol] == 0) {\\n                    q.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = distance + 1;\\n                }\\n            }\\n        }\\n        // destination unreachable\\n        return -1;\\n    }\\n\\n    boolean isBound(int row, int col) {\\n        return row>=0 && row<ROW && col>=0 && col<COL;\\n    }\\n}\\n```\\n\\n# Breadth-first Search (Without Overwriting the Input)\\n\\n``` Java []\\nclass Solution {\\n    int ROW, COL;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n\\n        boolean[][] visited = new boolean[ROW][COL];\\n        \\n        if (grid[0][0] != 0 || grid[ROW - 1][COL - 1] != 0) {\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] dirs = new int[][]{{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1}};\\n        q.offer(new int[]{0, 0, 1});\\n        visited[0][0] = true;\\n        // grid[0][0] = 1;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int row = cur[0];\\n            int col = cur[1];\\n            // int distance = grid[row][col];\\n            int distance = cur[2];\\n            if(row == ROW-1 && col == COL-1) {\\n                return distance;\\n            }\\n            for(int[] dir : dirs) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(isBound(newRow, newCol) && !visited[newRow][newCol] && grid[newRow][newCol] == 0) {\\n                    q.offer(new int[]{newRow, newCol, distance + 1});\\n                    // grid[newRow][newCol] = distance + 1;            \\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        // destination unreachable\\n        return -1;\\n    }\\n\\n    boolean isBound(int row, int col) {\\n        return row>=0 && row<ROW && col>=0 && col<COL;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "``` Java []\\nclass Solution {\\n    int ROW, COL;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        \\n        if (grid[0][0] != 0 || grid[ROW - 1][COL - 1] != 0) {\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] dirs = new int[][]{{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1}};\\n        q.offer(new int[]{0, 0});\\n        grid[0][0] = 1;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int row = cur[0];\\n            int col = cur[1];\\n            int distance = grid[row][col];\\n            if(row == ROW-1 && col == COL-1) {\\n                return distance;\\n            }\\n            for(int[] dir : dirs) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(isBound(newRow, newCol) && grid[newRow][newCol] == 0) {\\n                    q.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = distance + 1;\\n                }\\n            }\\n        }\\n        // destination unreachable\\n        return -1;\\n    }\\n\\n    boolean isBound(int row, int col) {\\n        return row>=0 && row<ROW && col>=0 && col<COL;\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    int ROW, COL;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n\\n        boolean[][] visited = new boolean[ROW][COL];\\n        \\n        if (grid[0][0] != 0 || grid[ROW - 1][COL - 1] != 0) {\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] dirs = new int[][]{{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1}};\\n        q.offer(new int[]{0, 0, 1});\\n        visited[0][0] = true;\\n        // grid[0][0] = 1;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int row = cur[0];\\n            int col = cur[1];\\n            // int distance = grid[row][col];\\n            int distance = cur[2];\\n            if(row == ROW-1 && col == COL-1) {\\n                return distance;\\n            }\\n            for(int[] dir : dirs) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(isBound(newRow, newCol) && !visited[newRow][newCol] && grid[newRow][newCol] == 0) {\\n                    q.offer(new int[]{newRow, newCol, distance + 1});\\n                    // grid[newRow][newCol] = distance + 1;            \\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        // destination unreachable\\n        return -1;\\n    }\\n\\n    boolean isBound(int row, int col) {\\n        return row>=0 && row<ROW && col>=0 && col<COL;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585112,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nWe need to find the shortest path starting from the top-left cell to the bottom-right cell and we can travel in 8 directions. We are using the shortest path approach called the Dijkstra\\'s Algorithm. It is a popular algorithm for finding the shortest paths in a weighted graph. It works by starting from a source node and iteratively expanding to neighboring nodes with the smallest known distances, until the shortest path to the target node is found or all reachable nodes have been visited.\\n\\n# Approach\\n\\n1) The function first checks if the starting cell (grid[0][0]) or the destination cell (grid[n-1][n-1]) is blocked (contains a value of 1). If either of them is blocked, it means there is no valid path from the start to the destination, so the function returns -1.\\n\\n\\n3) The starting cell (grid[0][0]) is marked as visited by setting its value to 1.\\n\\n4) A 2D vector neighbours is defined to represent the eight possible adjacent cells in the matrix.\\n\\n5) The while loop continues until the queue is empty. In each iteration, the front element of the queue is retrieved.\\n\\n6) The row (r), column (c), and result (distance) values are extracted from the current element.\\n\\n7) If the current cell is the destination cell (r == n-1 and c == n-1), the function returns the distance result as the shortest path length.\\n\\n8) If the current cell is not the destination, the function checks all eight possible neighbor cells using the neighbours vector.\\n\\n9) For each neighbor cell, if it is within the bounds of the matrix (row >= 0 and row < n and col >= 0 and col < n) and is unvisited (grid[row][col] == 0), it is marked as visited (grid[row][col] = 1) and added to the queue with an increased distance (result + 1).\\n\\n10) After processing all the neighbors, the loop continues until all possible cells are visited or the destination is reached.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\nUPVOTE. Glad to help.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0] or grid[n-1][n-1]) return -1;\\n        queue<vector<int>> queue;\\n        queue.push({0,0,1});\\n        grid[0][0]=1;\\n        vector<vector<int>> neighbours={{-1,-1},{-1,0},{-1,1},\\n        {0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n        while(!queue.empty()){\\n            auto curr=queue.front();\\n            queue.pop();\\n            int r=curr[0];\\n            int c=curr[1];\\n            int result=curr[2];\\n            if(r==n-1 and c==n-1){\\n                return result;\\n            }\\n\\n            for(int i=0;i<8;i++){\\n                int row=r+neighbours[i][0];\\n                int col=c+neighbours[i][1];\\n                if(row>=0 and row<n and col>=0 and col<n and grid[row][col]==0){\\n                    grid[row][col]=1;\\n                    queue.push({row,col,result+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0] or grid[n-1][n-1]) return -1;\\n        queue<vector<int>> queue;\\n        queue.push({0,0,1});\\n        grid[0][0]=1;\\n        vector<vector<int>> neighbours={{-1,-1},{-1,0},{-1,1},\\n        {0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n        while(!queue.empty()){\\n            auto curr=queue.front();\\n            queue.pop();\\n            int r=curr[0];\\n            int c=curr[1];\\n            int result=curr[2];\\n            if(r==n-1 and c==n-1){\\n                return result;\\n            }\\n\\n            for(int i=0;i<8;i++){\\n                int row=r+neighbours[i][0];\\n                int col=c+neighbours[i][1];\\n                if(row>=0 and row<n and col>=0 and col<n and grid[row][col]==0){\\n                    grid[row][col]=1;\\n                    queue.push({row,col,result+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045115,
                "title": "c-bfs-explanation-through-comments-easy-to-understand",
                "content": "**TC: O(NxN) SC: O(NxN)**\\n\\n```\\nclass Solution {\\npublic:\\n    //Use BFS \\n    \\n    bool isValid(int r, int c, int n, vector<vector<int>> &grid, vector<vector<bool>> &visited)\\n    {\\n        //check boundary condition and assure cell is not visited\\n        return (r>=0 && c>=0 && r<n && c<n && grid[r][c]==0 && !visited[r][c]);\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size();\\n        queue<pair<int, int>> q; //it stores visited cells \\n        int ans=0;\\n        vector<vector<bool>> visited(n, vector<bool> (n, false)); //it stores status of  the cell\\n        int size;\\n        \\n        if(!grid[0][0]) //if starting cell value is 0, put it into the queue\\n        {\\n            q.push({0,0});\\n            visited[0][0] = true;\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            size = q.size();\\n            ans++;\\n            \\n            //iterate until we cover all stored cells in the queue \\n            for(int cnt=0; cnt<size; cnt++) \\n            {\\n                auto node = q.front(); q.pop();\\n                int i = node.first, j=node.second; //get row and column of the cell\\n                \\n                if(i==n-1 && j==n-1) return ans; //if we reach end cell return ans\\n                \\n                //cover all 8-direction adjacent cell\\n                for(int r=i-1; r<=i+1; r++)\\n                {\\n                    for(int c=j-1; c<=j+1; c++)\\n                    {\\n                        //if cell is valid means not visited \\n                        //put it into the queue and mark visited\\n                        if(isValid(r, c, n, grid, visited))\\n                        {\\n                            q.push({r,c});\\n                            visited[r][c] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //if there is no path exists return -1\\n        return -1;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use BFS \\n    \\n    bool isValid(int r, int c, int n, vector<vector<int>> &grid, vector<vector<bool>> &visited)\\n    {\\n        //check boundary condition and assure cell is not visited\\n        return (r>=0 && c>=0 && r<n && c<n && grid[r][c]==0 && !visited[r][c]);\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size();\\n        queue<pair<int, int>> q; //it stores visited cells \\n        int ans=0;\\n        vector<vector<bool>> visited(n, vector<bool> (n, false)); //it stores status of  the cell\\n        int size;\\n        \\n        if(!grid[0][0]) //if starting cell value is 0, put it into the queue\\n        {\\n            q.push({0,0});\\n            visited[0][0] = true;\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            size = q.size();\\n            ans++;\\n            \\n            //iterate until we cover all stored cells in the queue \\n            for(int cnt=0; cnt<size; cnt++) \\n            {\\n                auto node = q.front(); q.pop();\\n                int i = node.first, j=node.second; //get row and column of the cell\\n                \\n                if(i==n-1 && j==n-1) return ans; //if we reach end cell return ans\\n                \\n                //cover all 8-direction adjacent cell\\n                for(int r=i-1; r<=i+1; r++)\\n                {\\n                    for(int c=j-1; c<=j+1; c++)\\n                    {\\n                        //if cell is valid means not visited \\n                        //put it into the queue and mark visited\\n                        if(isValid(r, c, n, grid, visited))\\n                        {\\n                            q.push({r,c});\\n                            visited[r][c] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //if there is no path exists return -1\\n        return -1;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395376,
                "title": "c-bfs-each-line-clearly-explained",
                "content": "# Feel free to post your doubts in comment section\\n* Apply BFS from source node \\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size(); // dimension of grid\\n        int shortestPathLength=INT_MAX;\\n        // return -1 if either sourse or destination is 1\\n        if(grid[0][0]==1 || grid[n-1][n-1]==1) return -1;\\n        \\n        queue<vector<int>> q; // queue for BFS, it store a vector of 3 integers ( row, column, distace from source)\\n        \\n        q.push( {0,0,1} ); // push the source node in queue\\n        grid[0][0]=1; // mark the source as visited \\n        int x[]={0,0,1,-1,1,1,-1,-1};\\n        int y[]={1,-1,0,0,1,-1,1,-1};\\n        while( !q.empty() ){\\n            auto f=q.front(); //front source of queue\\n            q.pop();\\n            // check all the 8 direction adjacent nodes\\n            for( int i=0; i<8; i++ ){\\n                int r=f[0]+x[i] , c=f[1]+y[i] , distance=f[2]+1;\\n                \\n                // check if it is a valid node not visited => not having 1\\n                if( r<0 || c<0 || r>=n || c>=n || grid[r][c]==1 ) continue;\\n                \\n                // push the valid adjacent node into the queue with increased distance      \\n                q.push( {r,c,distance} );\\n                grid[r][c]=1; // mark the node as visited\\n                if(r==n-1 && c==n-1) // store the shortest distance when we reach end node\\n                    shortestPathLength =  distance;\\n            }\\n        }\\n        if( grid[n-1][n-1] != 1 ) return -1; // if we did not reach the end cell\\n        if( n==1 ) return 1; // for the test case [[0]]\\n        return shortestPathLength;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size(); // dimension of grid\\n        int shortestPathLength=INT_MAX;\\n        // return -1 if either sourse or destination is 1\\n        if(grid[0][0]==1 || grid[n-1][n-1]==1) return -1;\\n        \\n        queue<vector<int>> q; // queue for BFS, it store a vector of 3 integers ( row, column, distace from source)\\n        \\n        q.push( {0,0,1} ); // push the source node in queue\\n        grid[0][0]=1; // mark the source as visited \\n        int x[]={0,0,1,-1,1,1,-1,-1};\\n        int y[]={1,-1,0,0,1,-1,1,-1};\\n        while( !q.empty() ){\\n            auto f=q.front(); //front source of queue\\n            q.pop();\\n            // check all the 8 direction adjacent nodes\\n            for( int i=0; i<8; i++ ){\\n                int r=f[0]+x[i] , c=f[1]+y[i] , distance=f[2]+1;\\n                \\n                // check if it is a valid node not visited => not having 1\\n                if( r<0 || c<0 || r>=n || c>=n || grid[r][c]==1 ) continue;\\n                \\n                // push the valid adjacent node into the queue with increased distance      \\n                q.push( {r,c,distance} );\\n                grid[r][c]=1; // mark the node as visited\\n                if(r==n-1 && c==n-1) // store the shortest distance when we reach end node\\n                    shortestPathLength =  distance;\\n            }\\n        }\\n        if( grid[n-1][n-1] != 1 ) return -1; // if we did not reach the end cell\\n        if( n==1 ) return 1; // for the test case [[0]]\\n        return shortestPathLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063876,
                "title": "c-bfs-easy-explanation",
                "content": "**EXPLANATION**\\n- If **starting** or **ending** cell is **blocked** then return -1.\\n- Do **BFS** traversal on grid in **8** directions, using **queue**.\\n- At each iteration, **add 1** to next **unblocked** cell, **```grid[nrow][ncol] = grid[row][col] + 1```**.\\n- If at any point **```row=n-1```** and **```col=n-1```**, that is destination is reached, then return the value of **```grid[n-1][n-1]```**.\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        // if starting or ending cell is blocked then return -1\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0,0)); // insert the starting cell\\n        vector<vector<int>> directions = {{1,1}, {0,1},{1,0},{0,-1},{-1,0},{-1, -1},{1, -1},{-1, 1}};\\n        grid[0][0] = 1; // initially  1 step (answer includes the starting cell)\\n\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n\\n            // if destination already reached then return curr grid cell value\\n            if( row == n -1 && col == n -1)\\n                return grid[row][col];\\n\\n            // iterate for all 8 directions\\n            for(auto direction : directions){\\n                int nrow = row + direction[0];\\n                int ncol = col + direction[1];\\n\\n                // check for valid direction and no obstacle condition\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && grid[nrow][ncol] == 0){\\n                    q.push(make_pair(nrow,ncol));\\n                    grid[nrow][ncol] = grid[row][col] + 1; // increase value for that cell\\n                }\\n            }\\n\\n            // remove the current row,col from queue as it has been processed completely\\n            q.pop(); \\n        }\\n\\n        // if destination not reached\\n        return -1;\\n    }\\n};\\n```\\n**TIME COMPLEXITY**\\n**O(8*n^2)=O(n^2)** [ *If all cells are \\'0\\', then worst case will happen* ]\\n\\n**SPACE COMPLEXITY**\\n**O(n)**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```grid[nrow][ncol] = grid[row][col] + 1```\n```row=n-1```\n```col=n-1```\n```grid[n-1][n-1]```\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        // if starting or ending cell is blocked then return -1\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0,0)); // insert the starting cell\\n        vector<vector<int>> directions = {{1,1}, {0,1},{1,0},{0,-1},{-1,0},{-1, -1},{1, -1},{-1, 1}};\\n        grid[0][0] = 1; // initially  1 step (answer includes the starting cell)\\n\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n\\n            // if destination already reached then return curr grid cell value\\n            if( row == n -1 && col == n -1)\\n                return grid[row][col];\\n\\n            // iterate for all 8 directions\\n            for(auto direction : directions){\\n                int nrow = row + direction[0];\\n                int ncol = col + direction[1];\\n\\n                // check for valid direction and no obstacle condition\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && grid[nrow][ncol] == 0){\\n                    q.push(make_pair(nrow,ncol));\\n                    grid[nrow][ncol] = grid[row][col] + 1; // increase value for that cell\\n                }\\n            }\\n\\n            // remove the current row,col from queue as it has been processed completely\\n            q.pop(); \\n        }\\n\\n        // if destination not reached\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373305,
                "title": "easy-peasy-bfs-python-solution",
                "content": "\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        if grid[0][0] == 1:\\n            return -1\\n        q = [(0, 0, 1)]\\n        while len(q) > 0:\\n            x, y, d = q.pop(0)\\n            if x == rows-1 and y == cols-1:\\n                return d\\n            for a, b in ((x-1, y-1), (x+1, y+1), (x-1, y), (x+1, y), (x, y-1), (x, y+1), (x-1, y+1), (x+1, y-1)):\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] == 0:\\n                    grid[a][b] = 1\\n                    q.append((a, b, d+1))\\n         \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        if grid[0][0] == 1:\\n            return -1\\n        q = [(0, 0, 1)]\\n        while len(q) > 0:\\n            x, y, d = q.pop(0)\\n            if x == rows-1 and y == cols-1:\\n                return d\\n            for a, b in ((x-1, y-1), (x+1, y+1), (x-1, y), (x+1, y), (x, y-1), (x, y+1), (x-1, y+1), (x+1, y-1)):\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] == 0:\\n                    grid[a][b] = 1\\n                    q.append((a, b, d+1))\\n         \\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 318906,
                "title": "a-search-algorithm-faster-than-99-85-of-python3-submissions",
                "content": "Most people use BFS algorithm, but if you need to find shortest path between just two points, then A* search shows better performance.\\n\\nFrom implementation perspective it the same code just swapping the queue with a priority queue.\\nOn each iteration you estimate minimum path to the goal by:\\n\\nf(i,j)=g(i,j)+h(i,j)\\n\\nWhere:\\ng(i,j) = shortest path length found so far from start to (i, j) \\nh(i,j) = estimation to reach goal - bottom-right cell. For cell (i, j) it is calculated simply by max(n - i - 1, n - j - 1).\\n\\nImportant for A* search is that h(i,j) does not overestimate the actual cost to get to the goal.\\n\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def getNeighbours(i, j):\\n            positions = [[-1,-1], [-1,0], [-1,1],[0,-1], [0,1], [1, -1], [1, 0], [1, 1]]            \\n            for pos in positions:\\n                i1, j1 = i + pos[0], j + pos[1]                \\n                if i1 >= 0 and i1 < n and j1 >= 0 and j1 < n and grid[i1][j1] == 0:\\n                    yield (i1, j1)\\n                    \\n        solution = [[999999] * n for _ in range(n)]\\n        solution[0][0] = 1\\n        if grid[0][0] != 0 or grid[n-1][n-1] != 0:\\n            return -1\\n        \\n        h = []\\n        heapq.heappush(h, (1, (0, 0, 1)))\\n        while h:\\n            est, (i, j, sp) = heapq.heappop(h)            \\n            solution[i][j] = sp\\n            if i == n - 1 and j == n - 1:\\n                break\\n            for i1, j1 in getNeighbours(i, j):\\n                if solution[i1][j1] > sp + 1:\\n                    heapq.heappush(h, (sp + 1 + max(n - i1 - 1, n - j1 - 1), (i1, j1, sp + 1)))\\n                    solution[i1][j1] = solution[i][j] + 1\\n        \\n        if solution[n-1][n-1] == 999999:\\n            return -1\\n        else:\\n            return solution[n-1][n-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def getNeighbours(i, j):\\n            positions = [[-1,-1], [-1,0], [-1,1],[0,-1], [0,1], [1, -1], [1, 0], [1, 1]]            \\n            for pos in positions:\\n                i1, j1 = i + pos[0], j + pos[1]                \\n                if i1 >= 0 and i1 < n and j1 >= 0 and j1 < n and grid[i1][j1] == 0:\\n                    yield (i1, j1)\\n                    \\n        solution = [[999999] * n for _ in range(n)]\\n        solution[0][0] = 1\\n        if grid[0][0] != 0 or grid[n-1][n-1] != 0:\\n            return -1\\n        \\n        h = []\\n        heapq.heappush(h, (1, (0, 0, 1)))\\n        while h:\\n            est, (i, j, sp) = heapq.heappop(h)            \\n            solution[i][j] = sp\\n            if i == n - 1 and j == n - 1:\\n                break\\n            for i1, j1 in getNeighbours(i, j):\\n                if solution[i1][j1] > sp + 1:\\n                    heapq.heappush(h, (sp + 1 + max(n - i1 - 1, n - j1 - 1), (i1, j1, sp + 1)))\\n                    solution[i1][j1] = solution[i][j] + 1\\n        \\n        if solution[n-1][n-1] == 999999:\\n            return -1\\n        else:\\n            return solution[n-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313252,
                "title": "javascript-solution-bfs",
                "content": "This is actually the question of finding shortest path beween source and distnation in a 2D-array.\\nInstead of moving on 4 direactions, we need to move to 8 directions for this question. \\n>`C_i` and `C_i + 1` are different and share an edge or **corner**\\n\\nWe need keep traking cells that have been visited. Usually we can create a same size 2D-array to mark visited cell, for this question, however, it didn\\'t mention that we can\\'t modifiy original 2D-array, so we can just flip 0 to 1 to mark it as visited.\\n\\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {  \\n  if (grid[0][0]) return -1;\\n  \\n  const queue = [{ coord: [0, 0], dist: 1 }];\\n  const directs = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];\\n  const N = grid.length;\\n  const isValidCoord = (x, y) => x >= 0 && x < N && y >= 0 && y < N;\\n  \\n  grid[0][0] = 1;\\n  \\n  while (queue.length) {\\n    const { coord: [x, y], dist } = queue.shift();\\n    \\n    if (x === N - 1 && y === N - 1) {\\n      return dist;\\n    }\\n    \\n    for (let [moveX, moveY] of directs) {\\n      const nextX = x + moveX;\\n      const nextY = y + moveY;\\n      \\n      if (isValidCoord(nextX, nextY) && grid[nextX][nextY] === 0) {\\n        queue.push({ coord: [nextX, nextY], dist: dist + 1 });\\n        grid[nextX][nextY] = 1;\\n      }\\n    }\\n  }\\n  \\n  return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar shortestPathBinaryMatrix = function(grid) {  \\n  if (grid[0][0]) return -1;\\n  \\n  const queue = [{ coord: [0, 0], dist: 1 }];\\n  const directs = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];\\n  const N = grid.length;\\n  const isValidCoord = (x, y) => x >= 0 && x < N && y >= 0 && y < N;\\n  \\n  grid[0][0] = 1;\\n  \\n  while (queue.length) {\\n    const { coord: [x, y], dist } = queue.shift();\\n    \\n    if (x === N - 1 && y === N - 1) {\\n      return dist;\\n    }\\n    \\n    for (let [moveX, moveY] of directs) {\\n      const nextX = x + moveX;\\n      const nextY = y + moveY;\\n      \\n      if (isValidCoord(nextX, nextY) && grid[nextX][nextY] === 0) {\\n        queue.push({ coord: [nextX, nextY], dist: dist + 1 });\\n        grid[nextX][nextY] = 1;\\n      }\\n    }\\n  }\\n  \\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584648,
                "title": "c-breadth-first-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0] != 0 || grid[n-1][n-1] != 0) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        pair<int,int>dirs[8] = {{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{1,1},{1,-1},{-1,1}};\\n        int dx,dy;\\n        grid[0][0] = 1;\\n        while(!q.empty()){\\n            pair<int,int> curr = q.front();\\n            q.pop();\\n            if(curr.first == n - 1 && curr.second == n-1) return grid[curr.first][curr.second];\\n            for(auto x:dirs){\\n                dx = x.first + curr.first;\\n                dy = x.second + curr.second;\\n                if(dx >= 0 && dy >= 0 && dx < n && dy < n && grid[dx][dy] == 0){\\n                    q.push({dx,dy});\\n                    grid[dx][dy]=grid[curr.first][curr.second]+1; \\n                }\\n            }\\n        }\\n        \\n       return -1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0] != 0 || grid[n-1][n-1] != 0) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        pair<int,int>dirs[8] = {{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{1,1},{1,-1},{-1,1}};\\n        int dx,dy;\\n        grid[0][0] = 1;\\n        while(!q.empty()){\\n            pair<int,int> curr = q.front();\\n            q.pop();\\n            if(curr.first == n - 1 && curr.second == n-1) return grid[curr.first][curr.second];\\n            for(auto x:dirs){\\n                dx = x.first + curr.first;\\n                dy = x.second + curr.second;\\n                if(dx >= 0 && dy >= 0 && dx < n && dy < n && grid[dx][dy] == 0){\\n                    q.push({dx,dy});\\n                    grid[dx][dy]=grid[curr.first][curr.second]+1; \\n                }\\n            }\\n        }\\n        \\n       return -1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043301,
                "title": "c-bfs-nice-solution",
                "content": "Solved live on stream. link in profile\\n\\n```\\nclass Solution {\\n    bool isOutOfBounds(vector<vector<int>>& grid, int r, int c) {\\n        if(r < 0 || r >= grid.size()) return true;\\n        if(c < 0 || c >= grid[r].size()) return true;    \\n        return false;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<vector<int>> dirs = {\\n            {-1,-1},    {-1,0},     {-1,1},\\n            {0,-1},                 {0,1},\\n            {1,-1},     {1,0},      {1,1}\\n        };\\n        using pii = pair<int,int>;\\n        int ROWS = grid.size();\\n        if(ROWS == 0) return 0;\\n        int COLS = grid[0].size();\\n        queue<pii> q;\\n        if(grid[0][0] == 0) \\n            q.push({0,0});\\n        int steps = 0;\\n        while(!q.empty()) {\\n            int qSize = q.size();\\n            steps++;\\n            for(int i = 0; i < qSize; i++) {\\n                auto [r, c] = q.front();\\n                q.pop();\\n                if(r == ROWS - 1 && c == COLS - 1) return steps;\\n                for(auto& dir : dirs) {\\n                    int dr = dir[0] + r;\\n                    int dc = dir[1] + c;\\n                    if(isOutOfBounds(grid, dr, dc)) continue;\\n                    if(grid[dr][dc] == 1) continue;\\n                    grid[dr][dc] = 1;\\n                    q.push({dr,dc});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isOutOfBounds(vector<vector<int>>& grid, int r, int c) {\\n        if(r < 0 || r >= grid.size()) return true;\\n        if(c < 0 || c >= grid[r].size()) return true;    \\n        return false;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<vector<int>> dirs = {\\n            {-1,-1},    {-1,0},     {-1,1},\\n            {0,-1},                 {0,1},\\n            {1,-1},     {1,0},      {1,1}\\n        };\\n        using pii = pair<int,int>;\\n        int ROWS = grid.size();\\n        if(ROWS == 0) return 0;\\n        int COLS = grid[0].size();\\n        queue<pii> q;\\n        if(grid[0][0] == 0) \\n            q.push({0,0});\\n        int steps = 0;\\n        while(!q.empty()) {\\n            int qSize = q.size();\\n            steps++;\\n            for(int i = 0; i < qSize; i++) {\\n                auto [r, c] = q.front();\\n                q.pop();\\n                if(r == ROWS - 1 && c == COLS - 1) return steps;\\n                for(auto& dir : dirs) {\\n                    int dr = dir[0] + r;\\n                    int dc = dir[1] + c;\\n                    if(isOutOfBounds(grid, dr, dc)) continue;\\n                    if(grid[dr][dc] == 1) continue;\\n                    grid[dr][dc] = 1;\\n                    q.push({dr,dc});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725237,
                "title": "java-90-faster-easy-to-understand",
                "content": "```\\n//upvote if you like\\nclass Solution {\\n    public class path{\\n        int x;\\n        int y;\\n        int steps;\\n        public path(int x,int y, int steps){\\n            this.x=x;\\n            this.y=y;\\n            this.steps=steps;\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n=grid.length;\\n        if(grid[0][0]==1 || grid[n-1][n-1]==1)\\n            return -1;\\n        \\n        int moves[][]={{0,-1},{0,1},{1,0},{-1,0},{-1,-1},{1,-1},{-1,1},{1,1}};\\n        \\n        Queue<path> q=new LinkedList<>();\\n        q.add(new path(0,0,1));\\n        while(!q.isEmpty()){\\n            path temp=q.poll();\\n            int x=temp.x;\\n            int y=temp.y;\\n            if(x==n-1 && y==n-1)\\n                return temp.steps;\\n            grid[x][y]=1;\\n            for(int i=0;i<8;i++){\\n                int new_x=x+moves[i][0];\\n                int new_y=y+moves[i][1];\\n                if(new_x>=0 && new_x<n && new_y>=0 && new_y<n && grid[new_x][new_y]==0){\\n                    q.add(new path(new_x,new_y,temp.steps+1));\\n                    grid[new_x][new_y]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n//upvote if you like\\nclass Solution {\\n    public class path{\\n        int x;\\n        int y;\\n        int steps;\\n        public path(int x,int y, int steps){\\n            this.x=x;\\n            this.y=y;\\n            this.steps=steps;\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n=grid.length;\\n        if(grid[0][0]==1 || grid[n-1][n-1]==1)\\n            return -1;\\n        \\n        int moves[][]={{0,-1},{0,1},{1,0},{-1,0},{-1,-1},{1,-1},{-1,1},{1,1}};\\n        \\n        Queue<path> q=new LinkedList<>();\\n        q.add(new path(0,0,1));\\n        while(!q.isEmpty()){\\n            path temp=q.poll();\\n            int x=temp.x;\\n            int y=temp.y;\\n            if(x==n-1 && y==n-1)\\n                return temp.steps;\\n            grid[x][y]=1;\\n            for(int i=0;i<8;i++){\\n                int new_x=x+moves[i][0];\\n                int new_y=y+moves[i][1];\\n                if(new_x>=0 && new_x<n && new_y>=0 && new_y<n && grid[new_x][new_y]==0){\\n                    q.add(new path(new_x,new_y,temp.steps+1));\\n                    grid[new_x][new_y]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310526,
                "title": "best-bfs-solution",
                "content": "# Approach\\nDijkstra\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if (n-1 == 0 && grid[0][0] == 0)\\n            return 1;\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        vector<vector<int>> dist(n, vector<int>(n, 1e9));\\n        queue <pair<int, int>> q;\\n        q.push({0, 0});\\n        dist[0][0] = 1;\\n        int drow[] = {-1, -1, 0, +1, +1, +1, 0, -1};\\n        int dcol[] = {0, +1, +1, +1, 0, -1, -1, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 8; i++) {\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && grid[nrow][ncol] == 0) {\\n                    if (dist[row][col] + 1 < dist[nrow][ncol]) {\\n                        dist[nrow][ncol] = dist[row][col] + 1;\\n                        if (nrow == n-1 && ncol == n-1)\\n                            return dist[n-1][n-1];\\n                        q.push({nrow, ncol});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if (n-1 == 0 && grid[0][0] == 0)\\n            return 1;\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        vector<vector<int>> dist(n, vector<int>(n, 1e9));\\n        queue <pair<int, int>> q;\\n        q.push({0, 0});\\n        dist[0][0] = 1;\\n        int drow[] = {-1, -1, 0, +1, +1, +1, 0, -1};\\n        int dcol[] = {0, +1, +1, +1, 0, -1, -1, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 8; i++) {\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && grid[nrow][ncol] == 0) {\\n                    if (dist[row][col] + 1 < dist[nrow][ncol]) {\\n                        dist[nrow][ncol] = dist[row][col] + 1;\\n                        if (nrow == n-1 && ncol == n-1)\\n                            return dist[n-1][n-1];\\n                        q.push({nrow, ncol});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044798,
                "title": "best-c-solution-single-traversal-east-bfs",
                "content": "**Best BFS Solution :**\\n\\n**T.C -> O(n)      // n = number of paths \\nS.C -> O(n)     // queue** \\n```\\n// Point is responsible to tell you the cnt value at every individual x,y cordinate \\nstruct Point{\\n    int x ;    // x cordinate \\n    int y ;    // y cordinate\\n    int cnt ;  // cnt is the number of cells included in the path at every cordinate x and y \\n};\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        // Since we can move in 8 directions\\n        int dx[8] = {1,1,1,-1,-1,-1,0,0};\\n        int dy[8] = {1,0,-1,1,-1,0,1,-1};\\n        \\n        // Base case : Starting cell is blocked we can\\'t move forward \\n        if( grid[0][0] == 1 ) return -1 ;\\n        \\n        int rows = grid.size() ;\\n        int columns = grid[0].size() ;\\n        \\n        queue<Point> q ;  \\n        q.push({0,0,1}) ;   // We are staring from (0,0) cordinate and the cnt value is 1 \\n        grid[0][0] = -1 ;    // Mark the visited cell as -1 \\n        \\n        while( !q.empty() ){\\n            \\n            Point p = q.front() ;  // BFS Traversal \\n            q.pop() ;\\n            \\n            if( p.x == rows-1 && p.y == columns-1 )  // if we have reached the last right corner \\n                return p.cnt ;\\n            \\n            // Traverse in all 8 directions \\n            for( int i=0 ; i<8 ; i++ ){\\n                \\n                int x = p.x + dx[i] ;     // Iterate in every direction in one by one\\n                int y = p.y + dy[i] ;\\n                \\n                // Always check the boundary limits \\n                if( x>=0 && y>=0 && x<rows && y<columns && grid[x][y]==0 ){\\n                    q.push({ x, y, p.cnt+1 });     // Since you are able to visit the next cell add it into ur path i.e cnt+1 \\n                    grid[x][y] = -1 ;      // Mark this cell as visited \\n                }\\n            }\\n        }  \\n\\t\\t// if we are not able to access any path \\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n// Point is responsible to tell you the cnt value at every individual x,y cordinate \\nstruct Point{\\n    int x ;    // x cordinate \\n    int y ;    // y cordinate\\n    int cnt ;  // cnt is the number of cells included in the path at every cordinate x and y \\n};\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        // Since we can move in 8 directions\\n        int dx[8] = {1,1,1,-1,-1,-1,0,0};\\n        int dy[8] = {1,0,-1,1,-1,0,1,-1};\\n        \\n        // Base case : Starting cell is blocked we can\\'t move forward \\n        if( grid[0][0] == 1 ) return -1 ;\\n        \\n        int rows = grid.size() ;\\n        int columns = grid[0].size() ;\\n        \\n        queue<Point> q ;  \\n        q.push({0,0,1}) ;   // We are staring from (0,0) cordinate and the cnt value is 1 \\n        grid[0][0] = -1 ;    // Mark the visited cell as -1 \\n        \\n        while( !q.empty() ){\\n            \\n            Point p = q.front() ;  // BFS Traversal \\n            q.pop() ;\\n            \\n            if( p.x == rows-1 && p.y == columns-1 )  // if we have reached the last right corner \\n                return p.cnt ;\\n            \\n            // Traverse in all 8 directions \\n            for( int i=0 ; i<8 ; i++ ){\\n                \\n                int x = p.x + dx[i] ;     // Iterate in every direction in one by one\\n                int y = p.y + dy[i] ;\\n                \\n                // Always check the boundary limits \\n                if( x>=0 && y>=0 && x<rows && y<columns && grid[x][y]==0 ){\\n                    q.push({ x, y, p.cnt+1 });     // Since you are able to visit the next cell add it into ur path i.e cnt+1 \\n                    grid[x][y] = -1 ;      // Mark this cell as visited \\n                }\\n            }\\n        }  \\n\\t\\t// if we are not able to access any path \\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043549,
                "title": "two-cpp-solution-bfs",
                "content": "**SOLUTION 1**\\n**Time**: O(mn)O(mn)\\n**Space**: O(mn)O(mn)\\n\\n```\\nclass Solution {\\n public:\\n  int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n    const int n = grid.size();\\n    if (grid[0][0] == 0 && n == 1)\\n      return 1;\\n    if (grid[0][0] == 1 || grid.back().back() == 1)\\n      return -1;\\n\\n    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\\n                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};\\n\\n    int ans = 0;\\n    queue<pair<int, int>> q{{{0, 0}}};\\n    vector<vector<bool>> seen(n, vector<bool>(n));\\n    seen[0][0] = true;\\n\\n    while (!q.empty()) {\\n      ++ans;\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const auto [i, j] = q.front();\\n        q.pop();\\n        for (const auto [dx, dy] : dirs) {\\n          const int x = i + dx;\\n          const int y = j + dy;\\n          if (x < 0 || x == n || y < 0 || y == n)\\n            continue;\\n          if (grid[x][y] != 0 || seen[x][y])\\n            continue;\\n          if (x == n - 1 && y == n - 1)\\n            return ans + 1;\\n          q.emplace(x, y);\\n          seen[x][y] = true;\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\n```\\n\\n**SOLUTION 2**\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n    const int n = grid.size();\\n    if (grid[0][0] == 0 && n == 1)\\n      return 1;\\n    if (grid[0][0] == 1 || grid.back().back() == 1)\\n      return -1;\\n\\n    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\\n                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};\\n\\n    int ans = 0;\\n    queue<pair<int, int>> q{{{0, 0}}};\\n    vector<vector<bool>> seen(n, vector<bool>(n));\\n    seen[0][0] = true;\\n\\n    while (!q.empty()) {\\n      ++ans;\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const auto [i, j] = q.front();\\n        q.pop();\\n        for (const auto [dx, dy] : dirs) {\\n          const int x = i + dx;\\n          const int y = j + dy;\\n          if (x < 0 || x == n || y < 0 || y == n)\\n            continue;\\n          if (grid[x][y] != 0 || seen[x][y])\\n            continue;\\n          if (x == n - 1 && y == n - 1)\\n            return ans + 1;\\n          q.emplace(x, y);\\n          seen[x][y] = true;\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876564,
                "title": "beat-all-bfs-and-100-clean-code-with-explanation-a-search",
                "content": "If we use BFS, we also can get the answer. But **A * search is far more efficient than BFS in this task** \\nbecause it **searches by priority**, not all nodes of level by level (expanding search space) like BFS. \\nI wrote the most understandable code for everyone and make some explanation in simple words.\\n\\n[A* search](https://en.wikipedia.org/wiki/A*_search_algorithm) is the combination of best-first search and Dijkstra\\'s algorithm.\\nIn my words, it searches by an **evaluation function E(i, j)** consisting of **cost function C(i, j)** and **distance function D(i, j)**\\n```\\nE(i, j) = C(i, j) + D(i, j)\\nC(i, j) : the minimal cost of the current (i, j) # in this task, cost is step\\nD(i, j) : the shortest distance of the current (i, j) to the end\\n```\\nWe use evaluation function to search the priority node first.\\n\\nThere are some tricks I applied.\\n\\n**First, about C(i, j),** \\nwe need to update the minimal cost of the each visited (i, j), \\nbut we don\\'t need to create a new DP table or something. \\nWe can just ***store negative number of cost in the same grid***. It can save some memory and code.\\n\\n**Second, about D(i, j),** \\nwe need to calculate the shortest distance of the current (i, j) to the end. \\nAs the diagonal move is accepted and \\nwe can just **search from the end (n, n),  the shortest distance to the new end (0, 0) becomes max(i, j)**, \\nso we almost don\\'t need calculate anything about distance.\\n\\nCode with clear comments step by step as below\\n```\\nclass Solution: # A* search, best 376 ms\\n    def shortestPathBinaryMatrix(self, grid):\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n\\t\\t# use iterator to create 8 directions\\n        directions = [x for x in product((-1, 0, 1), repeat=2) if x != (0,0)]\\n\\t\\t\\n        q = [(n + 1, 1, n, n)] # put (evaluation, step, i, j) into q\\n        grid[n][n] = -1 # the step of the start is 1 \\n\\n        while q:\\n            _, step, i, j = heappop(q)\\n            # arrive the end, return minimal step\\n            if (i, j) == (0, 0): return step          \\n\\t\\t\\t\\n            for di, dj in directions:\\n                newI, newJ = i+di, j+dj\\n                # Except grid[i][j] = 1, we need to search and update  \\n                if 0 <= newI <= n and 0 <= newJ <= n and grid[newI][newJ] < 1:\\n                    newStep = step + 1\\n                    # if we have new visit or can have fewer steps, update\\n                    if grid[newI][newJ] == 0 or grid[newI][newJ] < -newStep:\\n                        grid[newI][newJ] = -newStep # store new minimal step\\n                        evaluation = max(newI, newJ) + newStep\\n                        heappush(q, (evaluation, newStep, newI, newJ))\\n        return -1\\n```\\nIn conclusion,\\nwe almost do the same thing(code) as BFS,\\nbut we just add priority into queue and far improve the performance.\\n\\nWelcome suggestion, question, comments.\\nIf you think this post is helpful, ***please upvote. Thanks a lot.***",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nE(i, j) = C(i, j) + D(i, j)\\nC(i, j) : the minimal cost of the current (i, j) # in this task, cost is step\\nD(i, j) : the shortest distance of the current (i, j) to the end\\n```\n```\\nclass Solution: # A* search, best 376 ms\\n    def shortestPathBinaryMatrix(self, grid):\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n\\t\\t# use iterator to create 8 directions\\n        directions = [x for x in product((-1, 0, 1), repeat=2) if x != (0,0)]\\n\\t\\t\\n        q = [(n + 1, 1, n, n)] # put (evaluation, step, i, j) into q\\n        grid[n][n] = -1 # the step of the start is 1 \\n\\n        while q:\\n            _, step, i, j = heappop(q)\\n            # arrive the end, return minimal step\\n            if (i, j) == (0, 0): return step          \\n\\t\\t\\t\\n            for di, dj in directions:\\n                newI, newJ = i+di, j+dj\\n                # Except grid[i][j] = 1, we need to search and update  \\n                if 0 <= newI <= n and 0 <= newJ <= n and grid[newI][newJ] < 1:\\n                    newStep = step + 1\\n                    # if we have new visit or can have fewer steps, update\\n                    if grid[newI][newJ] == 0 or grid[newI][newJ] < -newStep:\\n                        grid[newI][newJ] = -newStep # store new minimal step\\n                        evaluation = max(newI, newJ) + newStep\\n                        heappush(q, (evaluation, newStep, newI, newJ))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489336,
                "title": "javascript-bfs",
                "content": "```js\\nfunction shortestPathBinaryMatrix(grid) {\\n  if (grid[0][0] === 1) {\\n    return -1;\\n  }\\n  let dirs = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];\\n  let q = [[0, 0, 1]];\\n  while (q.length) {\\n    let [i, j, length] = q.shift();\\n    if (i === grid.length - 1 && j === grid[0].length - 1) {\\n      return length;\\n    }\\n    for (let [iDiff, jDiff] of dirs) {\\n      let newI = i + iDiff;\\n      let newJ = j + jDiff;\\n      if (newI >= 0 && newJ >= 0 && newI < grid.length && newJ < grid[0].length && !grid[newI][newJ]) {\\n        q.push([newI, newJ, length + 1]);\\n        grid[newI][newJ] = 1;\\n      }\\n    }\\n  }\\n  return -1;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```js\\nfunction shortestPathBinaryMatrix(grid) {\\n  if (grid[0][0] === 1) {\\n    return -1;\\n  }\\n  let dirs = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];\\n  let q = [[0, 0, 1]];\\n  while (q.length) {\\n    let [i, j, length] = q.shift();\\n    if (i === grid.length - 1 && j === grid[0].length - 1) {\\n      return length;\\n    }\\n    for (let [iDiff, jDiff] of dirs) {\\n      let newI = i + iDiff;\\n      let newJ = j + jDiff;\\n      if (newI >= 0 && newJ >= 0 && newI < grid.length && newJ < grid[0].length && !grid[newI][newJ]) {\\n        q.push([newI, newJ, length + 1]);\\n        grid[newI][newJ] = 1;\\n      }\\n    }\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586842,
                "title": "easy-c-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nImagine you are in a maze and want to find the shortest path from the entrance to the exit. You can move in eight possible directions: up, down, left, right, and diagonals.\\n\\nTo solve the maze, you explore neighboring areas one by one, marking visited areas and moving forward. If you reach the exit, you have found the shortest path.\\n\\nIn this process, you use a queue to keep track of areas to explore. You continuously move through the maze, marking visited areas and enqueuing unvisited neighbors for exploration.\\n\\nIf you cannot reach the exit or the maze is blocked at the entrance, there is no valid path.\\n\\nThe code implements this maze-solving strategy using a binary matrix and the BFS algorithm to find the shortest path from the entrance to the exit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code aims to find the shortest path in a maze represented by a binary matrix. It starts from the top-left cell and tries to reach the bottom-right cell, considering eight possible directions of movement. The approach used is a breadth-first search (BFS) algorithm.\\n\\n\\n1. Initialize necessary variables: dimensions of the matrix, current distance from the source, and directions of movement.\\n\\n2. Start BFS from the top-left cell.\\n\\n3. If the starting cell is blocked, there is no valid path.\\n\\n4. Perform BFS until all possible paths are explored:\\n- Explore each cell\\'s neighbors in all eight directions.\\n- Keep track of the distance traveled.\\n- If the target cell is reached, return the distance as the shortest path.\\n- Mark visited cells and enqueue unvisited neighbors for exploration.\\n5. If the target cell is not reached, there is no valid path from the source to the target.\\n\\n# Complexity\\n- Time complexity:O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int level = 0;\\n        int dx[]={0,0,1,1,1,-1,-1,-1};\\n        int dy[]={1,-1,0,1,-1,0,1,-1};\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        if(grid[0][0]==1)\\n        {\\n            return -1;\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int l = q.size();\\n            level++;\\n            for(int i = 0; i<l; i++)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n\\n                if(x==n-1 && y == m-1)\\n                {\\n                    return level;\\n                }\\n                q.pop();\\n\\n                for(int i = 0; i<8; i++)\\n                {\\n                    int newrow = x+dx[i];\\n                    int newcol = y+dy[i];\\n\\n                    if(newrow>=0 && newrow<n && newcol>=0 && newcol<m && grid[newrow][newcol]==0)\\n                    {\\n                        grid[newrow][newcol]=1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int level = 0;\\n        int dx[]={0,0,1,1,1,-1,-1,-1};\\n        int dy[]={1,-1,0,1,-1,0,1,-1};\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        if(grid[0][0]==1)\\n        {\\n            return -1;\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int l = q.size();\\n            level++;\\n            for(int i = 0; i<l; i++)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n\\n                if(x==n-1 && y == m-1)\\n                {\\n                    return level;\\n                }\\n                q.pop();\\n\\n                for(int i = 0; i<8; i++)\\n                {\\n                    int newrow = x+dx[i];\\n                    int newcol = y+dy[i];\\n\\n                    if(newrow>=0 && newrow<n && newcol>=0 && newcol<m && grid[newrow][newcol]==0)\\n                    {\\n                        grid[newrow][newcol]=1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201825,
                "title": "easy-solution-without-dijkstra-only-bfs",
                "content": "# Intuition\\n    Find shortest distance from source(0,0) to all points \\n# Approach\\n Using bfs to find shortest distance from source to all points and in doing so we will find the distance from top left to bottom right corner point. \\n\\n# Complexity\\n- Time complexity:\\n   O(N*N)\\n\\n- Space complexity:\\n   O(N*N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n      if(grid[0][0]!=0) return -1;\\n      int r=grid.length,c=grid[0].length;\\n      int dist[][]=new int[r][c];\\n      for(int i=0;i<r;i++){\\n          for(int j=0;j<c;j++){\\n              dist[i][j]=(int)1e9;\\n          }\\n      }\\n      dist[0][0]=1;\\n      Queue<Trio> q=new LinkedList<>();\\n      q.add(new Trio(0,0,dist[0][0]));\\n        int dx[]={0,1,0,-1,1,-1,-1,1};\\n        int dy[]={1,0,-1,0,1,-1,1,-1};\\n      while(!q.isEmpty()){\\n          Trio temp=q.poll();\\n          int row=temp.ii;\\n          int col=temp.jj;\\n          int cdis=temp.dis;\\n        for(int i=0;i<8;i++){\\n            int nr=row+dx[i];\\n            int nc=col+dy[i];\\n\\n            if(nr>=0&&nr<r&&nc>=0&&nc<c&&grid[nr][nc]==0){\\n                if(cdis+1<dist[nr][nc]){\\n                    dist[nr][nc]=cdis+1;\\n                    q.add(new Trio(nr,nc,dist[nr][nc]));\\n                }\\n            }\\n        }\\n      }  \\n           return dist[r-1][c-1]<(int)1e9?dist[r-1][c-1]:-1; \\n    }\\n    public class Trio{\\n        int ii;\\n        int jj;\\n        int dis;\\n        public Trio(int i,int j,int dis){\\n            this.ii=i;\\n            this.jj=j;\\n            this.dis=dis;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n      if(grid[0][0]!=0) return -1;\\n      int r=grid.length,c=grid[0].length;\\n      int dist[][]=new int[r][c];\\n      for(int i=0;i<r;i++){\\n          for(int j=0;j<c;j++){\\n              dist[i][j]=(int)1e9;\\n          }\\n      }\\n      dist[0][0]=1;\\n      Queue<Trio> q=new LinkedList<>();\\n      q.add(new Trio(0,0,dist[0][0]));\\n        int dx[]={0,1,0,-1,1,-1,-1,1};\\n        int dy[]={1,0,-1,0,1,-1,1,-1};\\n      while(!q.isEmpty()){\\n          Trio temp=q.poll();\\n          int row=temp.ii;\\n          int col=temp.jj;\\n          int cdis=temp.dis;\\n        for(int i=0;i<8;i++){\\n            int nr=row+dx[i];\\n            int nc=col+dy[i];\\n\\n            if(nr>=0&&nr<r&&nc>=0&&nc<c&&grid[nr][nc]==0){\\n                if(cdis+1<dist[nr][nc]){\\n                    dist[nr][nc]=cdis+1;\\n                    q.add(new Trio(nr,nc,dist[nr][nc]));\\n                }\\n            }\\n        }\\n      }  \\n           return dist[r-1][c-1]<(int)1e9?dist[r-1][c-1]:-1; \\n    }\\n    public class Trio{\\n        int ii;\\n        int jj;\\n        int dis;\\n        public Trio(int i,int j,int dis){\\n            this.ii=i;\\n            this.jj=j;\\n            this.dis=dis;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904405,
                "title": "both-bfs-and-dfs-good-concepts-to-learn-from-dfs-beginner-friendly",
                "content": "first we will do through bfs\\nsimple bfs nothing to think for\\n\\n```\\nint shortestPathBinaryMatrix(vector<vector<int>>& a) {\\n        \\n        int n=a.size(),m=a[0].size();\\n//         int k=dfs(0,0,a);\\n//         return k<1e5 ?k:-1 ;\\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        \\n        queue<pair<int,int>>q;\\n        if(a[0][0]==1) return -1;\\n        q.push({0,0});int ans=0;vis[0][0]=1;\\n        \\n        while(!q.empty())\\n        { ans++;\\n            int s=q.size();\\n           while(s--)\\n            { \\n                auto[i,j]=q.front();q.pop();\\n             \\n                if(i==n-1 && j==m-1) return ans;\\n               \\n               // a[i][j]=1;\\n               \\n                for(int k=0;k<8;k++)\\n                {  \\n                    int ni=i+x[k];\\n                    int nj=j+y[k];\\n                    \\n                    if(ni>=0 && nj>=0 && ni<n && nj<m && a[ni][nj]==0 && vis[ni][nj]==0){q.push({ni,nj});vis[ni][nj]=1;}\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n```\\n\\nnow we will have a look at dfs approach\\nhere we will maintain a dist array which will store its distance from origin(0,0)\\nthen we will relax it as well as its adjoining neighbours \\n```\\nvoid dfs(int u,int v,vector<vector<int>>& g,vector<vector<int>>& dist)\\n    {\\n        int n=g.size(),m=g[0].size();\\n        \\n        int d0=dist[u][v];\\n        \\n       for (int x = -1; x <= 1; x++) {\\n            for (int y = -1; y <= 1; y++) {\\n                if (x == 0 && y == 0)\\n                    continue;   \\n            \\n                int i=u+x,j=v+y;\\n                \\n                \\n                \\n            if(i>=0 && i<n && j>=0 && j<m)\\n            {  if(g[i][j]==1)continue;\\n             \\n                int d1=dist[i][j];\\n            \\n            if(d0-1>d1)//checking if it is minimum for u,v\\n            {\\n                dist[u][v]=d1+1;\\n                dfs(u,v,g,dist);\\n            }\\n                else if(d0<d1-1){//checking if it is minimum for i,j\\n                    dist[i][j]=d0+1;\\n                    dfs(i,j,g,dist);\\n                }\\n             \\n            }\\n        \\n        }\\n           \\n       }\\n       \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        \\n        int i,j,n=g.size(),m=g[0].size();\\n        \\n        vector<vector<int>>dist(n,vector<int>(m,INT_MAX));//dist from ,i,j, to 0,0\\n        \\n        dist[0][0]=1;\\n        \\n            if(g[0][0]==1 || g[n-1][m-1]==1)\\n            {\\n                return -1;\\n            }\\n        \\n        dfs(0,0,g,dist);\\n        \\n        return dist[n-1][m-1]==INT_MAX ? -1:dist[n-1][m-1];\\n        \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nint shortestPathBinaryMatrix(vector<vector<int>>& a) {\\n        \\n        int n=a.size(),m=a[0].size();\\n//         int k=dfs(0,0,a);\\n//         return k<1e5 ?k:-1 ;\\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        \\n        queue<pair<int,int>>q;\\n        if(a[0][0]==1) return -1;\\n        q.push({0,0});int ans=0;vis[0][0]=1;\\n        \\n        while(!q.empty())\\n        { ans++;\\n            int s=q.size();\\n           while(s--)\\n            { \\n                auto[i,j]=q.front();q.pop();\\n             \\n                if(i==n-1 && j==m-1) return ans;\\n               \\n               // a[i][j]=1;\\n               \\n                for(int k=0;k<8;k++)\\n                {  \\n                    int ni=i+x[k];\\n                    int nj=j+y[k];\\n                    \\n                    if(ni>=0 && nj>=0 && ni<n && nj<m && a[ni][nj]==0 && vis[ni][nj]==0){q.push({ni,nj});vis[ni][nj]=1;}\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n```\n```\\nvoid dfs(int u,int v,vector<vector<int>>& g,vector<vector<int>>& dist)\\n    {\\n        int n=g.size(),m=g[0].size();\\n        \\n        int d0=dist[u][v];\\n        \\n       for (int x = -1; x <= 1; x++) {\\n            for (int y = -1; y <= 1; y++) {\\n                if (x == 0 && y == 0)\\n                    continue;   \\n            \\n                int i=u+x,j=v+y;\\n                \\n                \\n                \\n            if(i>=0 && i<n && j>=0 && j<m)\\n            {  if(g[i][j]==1)continue;\\n             \\n                int d1=dist[i][j];\\n            \\n            if(d0-1>d1)//checking if it is minimum for u,v\\n            {\\n                dist[u][v]=d1+1;\\n                dfs(u,v,g,dist);\\n            }\\n                else if(d0<d1-1){//checking if it is minimum for i,j\\n                    dist[i][j]=d0+1;\\n                    dfs(i,j,g,dist);\\n                }\\n             \\n            }\\n        \\n        }\\n           \\n       }\\n       \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        \\n        int i,j,n=g.size(),m=g[0].size();\\n        \\n        vector<vector<int>>dist(n,vector<int>(m,INT_MAX));//dist from ,i,j, to 0,0\\n        \\n        dist[0][0]=1;\\n        \\n            if(g[0][0]==1 || g[n-1][m-1]==1)\\n            {\\n                return -1;\\n            }\\n        \\n        dfs(0,0,g,dist);\\n        \\n        return dist[n-1][m-1]==INT_MAX ? -1:dist[n-1][m-1];\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063746,
                "title": "java-solution-with-a-search",
                "content": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        \\n        if (grid[0][0] != 0 || grid[N - 1][N - 1] != 0) {\\n            return -1;\\n        }\\n\\n        int directions[][] = {{-1,0},{1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        \\n        Queue<Attempt> attempts = new PriorityQueue<>();\\n        attempts.add(new Attempt(0, 0, 1));\\n        while (!attempts.isEmpty()) {\\n           Attempt attempt = attempts.poll();\\n            \\n           if (attempt.row == N - 1 && attempt.column == N - 1) {\\n               return attempt.step;\\n           } \\n            \\n           for (int[] direction : directions) {\\n               int row = attempt.row + direction[0];\\n               int column = attempt.column + direction[1];\\n               \\n               if (row >= 0 && row < N && column >= 0 && column < N && grid[row][column] == 0) {\\n                   attempts.add(new Attempt(row, column, attempt.step + 1));\\n                   grid[row][column] = -1; \\n                }  \\n           } \\n        }\\n        \\n        return -1;\\n    }\\n    \\n    class Attempt implements Comparable<Attempt> {\\n        int row;\\n        int column;\\n        int step;\\n        \\n        public Attempt (int row, int column, int step) {\\n            this.row = row;\\n            this.column = column;\\n            this.step = step;\\n        }\\n        \\n        @Override\\n        public int compareTo(Attempt other) {\\n            if (this.step == other.step) {\\n                return other.row + other.column - this.row - this.column;\\n            }\\n            \\n            return this.step - other.step;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        \\n        if (grid[0][0] != 0 || grid[N - 1][N - 1] != 0) {\\n            return -1;\\n        }\\n\\n        int directions[][] = {{-1,0},{1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        \\n        Queue<Attempt> attempts = new PriorityQueue<>();\\n        attempts.add(new Attempt(0, 0, 1));\\n        while (!attempts.isEmpty()) {\\n           Attempt attempt = attempts.poll();\\n            \\n           if (attempt.row == N - 1 && attempt.column == N - 1) {\\n               return attempt.step;\\n           } \\n            \\n           for (int[] direction : directions) {\\n               int row = attempt.row + direction[0];\\n               int column = attempt.column + direction[1];\\n               \\n               if (row >= 0 && row < N && column >= 0 && column < N && grid[row][column] == 0) {\\n                   attempts.add(new Attempt(row, column, attempt.step + 1));\\n                   grid[row][column] = -1; \\n                }  \\n           } \\n        }\\n        \\n        return -1;\\n    }\\n    \\n    class Attempt implements Comparable<Attempt> {\\n        int row;\\n        int column;\\n        int step;\\n        \\n        public Attempt (int row, int column, int step) {\\n            this.row = row;\\n            this.column = column;\\n            this.step = step;\\n        }\\n        \\n        @Override\\n        public int compareTo(Attempt other) {\\n            if (this.step == other.step) {\\n                return other.row + other.column - this.row - this.column;\\n            }\\n            \\n            return this.step - other.step;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063518,
                "title": "python-solution",
                "content": "My code:\\n\\n```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] != 0:\\n            return -1\\n        n = len(grid)\\n        if n == 1:\\n            if grid[0][0] == 0:\\n                return 1\\n\\n        dq = deque()\\n        dq.append([0, 0])\\n        length = 1\\n        while dq:\\n            length += 1\\n            for _ in range(len(dq)):\\n                x, y = dq.popleft()\\n                for i in [-1, 0, 1]:\\n                    for j in [-1, 0, 1]:\\n                        if i == 0 and j == 0:\\n                            continue\\n                        if 0 <= x + i < n and 0 <= y + j < n and grid[x + i][y + j] == 0:\\n                            if x + i == n - 1 and y + j == n - 1:\\n                                return length\\n                            dq.append([x + i, y + j])\\n                            grid[x + i][y + j] = 1\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] != 0:\\n            return -1\\n        n = len(grid)\\n        if n == 1:\\n            if grid[0][0] == 0:\\n                return 1\\n\\n        dq = deque()\\n        dq.append([0, 0])\\n        length = 1\\n        while dq:\\n            length += 1\\n            for _ in range(len(dq)):\\n                x, y = dq.popleft()\\n                for i in [-1, 0, 1]:\\n                    for j in [-1, 0, 1]:\\n                        if i == 0 and j == 0:\\n                            continue\\n                        if 0 <= x + i < n and 0 <= y + j < n and grid[x + i][y + j] == 0:\\n                            if x + i == n - 1 and y + j == n - 1:\\n                                return length\\n                            dq.append([x + i, y + j])\\n                            grid[x + i][y + j] = 1\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352787,
                "title": "easy-java-bfs-beats-cpu-95-and-mem-100",
                "content": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        if (grid[0][0] != 0 || grid[N-1][N-1] != 0) {\\n            return -1;\\n        }\\n        int len = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[] {0, 0});\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            len++;\\n            for (int i = 0; i < size; i++) {\\n                int[] n = q.poll();\\n                int r = n[0], c = n[1];\\n                if (r == N-1 && c == N - 1) {\\n                    return len;\\n                }\\n                for (int x = -1; x <= 1; x++) {\\n                    for (int y = -1; y <= 1; y++) {\\n                        int nr = r + x;\\n                        int nc = c + y;\\n                        if (nr >= 0 && nc >= 0 && nr < N && nc < N && grid[nr][nc] == 0) {\\n                            grid[nr][nc] = 2;\\n                            q.add(new int[] {nr, nc});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        if (grid[0][0] != 0 || grid[N-1][N-1] != 0) {\\n            return -1;\\n        }\\n        int len = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[] {0, 0});\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            len++;\\n            for (int i = 0; i < size; i++) {\\n                int[] n = q.poll();\\n                int r = n[0], c = n[1];\\n                if (r == N-1 && c == N - 1) {\\n                    return len;\\n                }\\n                for (int x = -1; x <= 1; x++) {\\n                    for (int y = -1; y <= 1; y++) {\\n                        int nr = r + x;\\n                        int nc = c + y;\\n                        if (nr >= 0 && nc >= 0 && nr < N && nc < N && grid[nr][nc] == 0) {\\n                            grid[nr][nc] = 2;\\n                            q.add(new int[] {nr, nc});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584090,
                "title": "shortest-path-in-binary-matrix-optimized-solution-daily-leetcode-challenge",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        // Check if the start or end cell is blocked\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        \\n        // Create a queue for BFS\\n        queue<pair<int, int>> q;\\n        q.push({0, 0}); // Start from the top-left cell\\n        grid[0][0] = 1; // Mark the start cell as visited\\n        \\n        // 8 possible directions to move\\n        vector<int> dx = {-1, -1, -1, 0, 0, 1, 1, 1};\\n        vector<int> dy = {-1, 0, 1, -1, 1, -1, 0, 1};\\n        \\n        // Perform BFS\\n        while (!q.empty()) {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            \\n            // Check if reached the end cell\\n            if (x == n - 1 && y == n - 1)\\n                return grid[x][y];\\n            \\n            // Explore the 8 adjacent cells\\n            for (int i = 0; i < 8; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n                // Check if the next cell is within the grid boundaries\\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                    q.push({nx, ny});\\n                    grid[nx][ny] = grid[x][y] + 1; // Mark the next cell as visited and update its distance\\n                }\\n            }\\n        }\\n        \\n        return -1; // No clear path found\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\nThe time complexity of this algorithm is O(n^2) because in the worst case, we may have to visit every cell in the grid. The space complexity is also O(n^2) because the queue can store at most n^2 cells in the worst case.\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        // Check if the start or end cell is blocked\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        \\n        // Create a queue for BFS\\n        queue<pair<int, int>> q;\\n        q.push({0, 0}); // Start from the top-left cell\\n        grid[0][0] = 1; // Mark the start cell as visited\\n        \\n        // 8 possible directions to move\\n        vector<int> dx = {-1, -1, -1, 0, 0, 1, 1, 1};\\n        vector<int> dy = {-1, 0, 1, -1, 1, -1, 0, 1};\\n        \\n        // Perform BFS\\n        while (!q.empty()) {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            \\n            // Check if reached the end cell\\n            if (x == n - 1 && y == n - 1)\\n                return grid[x][y];\\n            \\n            // Explore the 8 adjacent cells\\n            for (int i = 0; i < 8; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n                // Check if the next cell is within the grid boundaries\\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                    q.push({nx, ny});\\n                    grid[nx][ny] = grid[x][y] + 1; // Mark the next cell as visited and update its distance\\n                }\\n            }\\n        }\\n        \\n        return -1; // No clear path found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064056,
                "title": "by-using-dijsktra-algorithm-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid,pair<int,int>s,pair<int,int>d){\\n        if(grid[0][0]==1) return -1;\\n        if(s.first==d.first && s.second==d.second ){\\n            return 1;\\n        }\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        \\n        dist[0][0]=1;\\n        queue<pair<int,pair<int,int>>>q;\\n        int dr[]={-1,-1,0,1,1,1,0,-1};\\n        int dc[]={0,1,1,1,0,-1,-1,-1};\\n        q.push({1,{0,0}});\\n        while(q.empty()==false){\\n            auto it=q.front();\\n            int dis=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int nr=dr[i]+r;\\n                int nc=dc[i]+c;\\n                if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]==0 && dis+1<dist[nr][nc]){\\n                    dist[nr][nc]=dis+1;\\n                    if(nr==d.first && nc==d.second){\\n                        return dis+1;\\n                    }\\n                    q.push({1+dis,{nr,nc}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        pair<int,int>s={0,0};\\n        pair<int,int>d={n-1,n-1};\\n        return f(grid,s,d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid,pair<int,int>s,pair<int,int>d){\\n        if(grid[0][0]==1) return -1;\\n        if(s.first==d.first && s.second==d.second ){\\n            return 1;\\n        }\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        \\n        dist[0][0]=1;\\n        queue<pair<int,pair<int,int>>>q;\\n        int dr[]={-1,-1,0,1,1,1,0,-1};\\n        int dc[]={0,1,1,1,0,-1,-1,-1};\\n        q.push({1,{0,0}});\\n        while(q.empty()==false){\\n            auto it=q.front();\\n            int dis=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int nr=dr[i]+r;\\n                int nc=dc[i]+c;\\n                if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]==0 && dis+1<dist[nr][nc]){\\n                    dist[nr][nc]=dis+1;\\n                    if(nr==d.first && nc==d.second){\\n                        return dis+1;\\n                    }\\n                    q.push({1+dis,{nr,nc}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        pair<int,int>s={0,0};\\n        pair<int,int>d={n-1,n-1};\\n        return f(grid,s,d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962468,
                "title": "c-bfs-and-dfs-solution-explained-and-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Start the BFs from the cell (0,0)\\n2. Check the 8 directionally adjancent cells,if there are not visited take it into the queue.\\n3. The first time we encountered the cell (n-1,n-1) is the minium distance.\\n4. IF we don\\'t encounter the cell (n-1,n-1) then there is no clear path.\\n\\n\\n#### BFs Solution\\n```\\nclass Solution {\\nprivate : \\n    typedef vector<vector<int>> vvi; \\n    int xx[8] = {0,0,-1,1,-1,-1,1,1};\\n    int yy[8] = {1,-1,0,0,-1,1,1,-1}; \\n    \\n    \\n    int shortestPathBFs(vvi &grid,int n)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        //distance matrix keeps track of the minimum distance from the cell (0,0) to cell(i,j)\\n        vector<vector<int>> distance(n,vector<int>(n,0));\\n        //intial distance of cell (0,0) is 1\\n        distance[0][0] = 1;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            int dist = distance[x][y];\\n            q.pop();\\n            //checking the 8 directionally adjacent cells\\n            for(int i=0; i<8; i++)\\n            {\\n                int nx = x + xx[i],ny = y + yy[i];\\n            //IF the adjacent cell is valid,and it is zero and it is not yet visited,then take into queue.\\n                if(nx >= 0 && nx < n && ny >=0 && ny < n && !grid[nx][ny] && !distance[nx][ny])\\n                {  \\n                    /*If the last cell (n-1,n-1) is visited for the first time,then it is the minimum\\n                    distance so return the distance.*/\\n                    if(nx == n-1 && ny == n-1)\\n                      return dist+1;\\n                    /*updating the distance of current adjacent cell */\\n                    distance[nx][ny] = dist+1;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        /*Returning -1 as the cell (n-1,n-1) cannot be reached*/\\n        return -1;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0])\\n           return -1;\\n        if(n == 1) return 1;\\n        return shortestPathBFs(grid,n);\\n    }\\n};   \\n```\\n### Complexity\\nN is the no of cells in the grid.\\n- Time complexity: `O(8N)`\\nFor each cell there are 8 adjacent cells need to be checked. And the each cell is visited once or twice.\\n\\n- Space complexity: `O(N)`\\nSpace for the distance matrix and the queue.\\n\\n\\n### DFs Solution \\n**Verdict :** Time Limit Exceeded.\\n\\nTLE occurs because in DFs we explores all possible clear paths and takes the path with minimum distance. For finding the all paths, the cell needs to be visited multiple times, so it causes TLE.\\n```\\nclass Solution {\\nprivate : \\n    typedef vector<vector<int>> vvi; \\n    int xx[8] = {0,0,-1,1,-1,-1,1,1};\\n    int yy[8] = {1,-1,0,0,-1,1,1,-1}; \\n    \\n    int shortestPathDFs(int x,int y, vvi &grid,vvi &visited,int n, int cells)\\n    {\\n         if(x == n-1 && y == n-1)\\n           return cells;\\n         int minCells = INT_MAX;\\n         visited[x][y] = 1;\\n         for(int i=0; i<8; i++)\\n         {\\n             int nx = x + xx[i], ny = y + yy[i];\\n             if(nx < n && nx >= 0 && ny < n && ny >=0 && !grid[nx][ny] && !visited[nx][ny]) \\n                  minCells = min(minCells, shortestPathDFs(nx,ny,grid,visited,n,cells+1));\\n         }\\n         visited[x][y] = 0;\\n         return minCells;\\n    }\\n\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0])\\n           return -1;\\n        if(n == 1) return 1;\\n        vector<vector<int>> visited(n,vector<int>(n,0)); \\n        int ans = shortestPathDFs(0,0,grid,visited,n,1);\\n        return ans != INT_MAX ? ans : -1;\\n    }\\n};   \\n```\\nIf you feel it useful please upvote \\uD83D\\uDE0A\\uD83D\\uDE0A.\\nIn case of any queries or suggestions please let me know in the comment section.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nprivate : \\n    typedef vector<vector<int>> vvi; \\n    int xx[8] = {0,0,-1,1,-1,-1,1,1};\\n    int yy[8] = {1,-1,0,0,-1,1,1,-1}; \\n    \\n    \\n    int shortestPathBFs(vvi &grid,int n)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        //distance matrix keeps track of the minimum distance from the cell (0,0) to cell(i,j)\\n        vector<vector<int>> distance(n,vector<int>(n,0));\\n        //intial distance of cell (0,0) is 1\\n        distance[0][0] = 1;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            int dist = distance[x][y];\\n            q.pop();\\n            //checking the 8 directionally adjacent cells\\n            for(int i=0; i<8; i++)\\n            {\\n                int nx = x + xx[i],ny = y + yy[i];\\n            //IF the adjacent cell is valid,and it is zero and it is not yet visited,then take into queue.\\n                if(nx >= 0 && nx < n && ny >=0 && ny < n && !grid[nx][ny] && !distance[nx][ny])\\n                {  \\n                    /*If the last cell (n-1,n-1) is visited for the first time,then it is the minimum\\n                    distance so return the distance.*/\\n                    if(nx == n-1 && ny == n-1)\\n                      return dist+1;\\n                    /*updating the distance of current adjacent cell */\\n                    distance[nx][ny] = dist+1;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        /*Returning -1 as the cell (n-1,n-1) cannot be reached*/\\n        return -1;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0])\\n           return -1;\\n        if(n == 1) return 1;\\n        return shortestPathBFs(grid,n);\\n    }\\n};   \\n```\n```\\nclass Solution {\\nprivate : \\n    typedef vector<vector<int>> vvi; \\n    int xx[8] = {0,0,-1,1,-1,-1,1,1};\\n    int yy[8] = {1,-1,0,0,-1,1,1,-1}; \\n    \\n    int shortestPathDFs(int x,int y, vvi &grid,vvi &visited,int n, int cells)\\n    {\\n         if(x == n-1 && y == n-1)\\n           return cells;\\n         int minCells = INT_MAX;\\n         visited[x][y] = 1;\\n         for(int i=0; i<8; i++)\\n         {\\n             int nx = x + xx[i], ny = y + yy[i];\\n             if(nx < n && nx >= 0 && ny < n && ny >=0 && !grid[nx][ny] && !visited[nx][ny]) \\n                  minCells = min(minCells, shortestPathDFs(nx,ny,grid,visited,n,cells+1));\\n         }\\n         visited[x][y] = 0;\\n         return minCells;\\n    }\\n\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0])\\n           return -1;\\n        if(n == 1) return 1;\\n        vector<vector<int>> visited(n,vector<int>(n,0)); \\n        int ans = shortestPathDFs(0,0,grid,visited,n,1);\\n        return ans != INT_MAX ? ans : -1;\\n    }\\n};   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679636,
                "title": "simple-bfs-c-standard-code",
                "content": "```\\nint shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(grid[0][0]!=0)return -1;\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dist[0][0]=1;\\n        queue<pair<int,pair<int,int>>>pq;\\n        pq.push({1,{0,0}});\\n        int dx[8]={-1,-1,0,1,1,1,0,-1};\\n        int dy[8]={0,1,1,1,0,-1,-1,-1};\\n        while(!pq.empty()){\\n            auto top=pq.front();\\n            pq.pop();\\n            int currdis=top.first;\\n            int currx=top.second.first;\\n            int curry=top.second.second;\\n            if(currx==n-1 && curry==m-1)return currdis;\\n            for(int i=0;i<8;i++){\\n                int nextx=currx+dx[i];\\n                int nexty=curry+dy[i];\\n                if(nextx>=0 && nextx<n && nexty>=0 && nexty<m && grid[nextx][nexty]==0 && currdis+1<dist[nextx][nexty])                 {\\n                    //updated distance for current cell\\n                    dist[nextx][nexty]=currdis+1;\\n                    pq.push({currdis+1,{nextx,nexty}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(grid[0][0]!=0)return -1;\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dist[0][0]=1;\\n        queue<pair<int,pair<int,int>>>pq;\\n        pq.push({1,{0,0}});\\n        int dx[8]={-1,-1,0,1,1,1,0,-1};\\n        int dy[8]={0,1,1,1,0,-1,-1,-1};\\n        while(!pq.empty()){\\n            auto top=pq.front();\\n            pq.pop();\\n            int currdis=top.first;\\n            int currx=top.second.first;\\n            int curry=top.second.second;\\n            if(currx==n-1 && curry==m-1)return currdis;\\n            for(int i=0;i<8;i++){\\n                int nextx=currx+dx[i];\\n                int nexty=curry+dy[i];\\n                if(nextx>=0 && nextx<n && nexty>=0 && nexty<m && grid[nextx][nexty]==0 && currdis+1<dist[nextx][nexty])                 {\\n                    //updated distance for current cell\\n                    dist[nextx][nexty]=currdis+1;\\n                    pq.push({currdis+1,{nextx,nexty}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2044591,
                "title": "no-dp",
                "content": "as we can see simply that we have to reach the last block starting from first one,which is kinda similar to dp but it is not it is bfs or dfs, we have to find minnimum steps to reach last step, and we can move in all 8 directions , Now if we think more clearly this question is pretty standard bfs just like orange rotten and other,so moving on ahead, i did same\\n```\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int k[][]={{1,1},{1,0},{-1,-1},{-1,0},{0,-1},{0,1},{-1,1},{1,-1}};\\n      boolean vis[][]= new boolean[grid.length][grid[0].length];\\n        Queue<int[]>p=new LinkedList<>();\\n        if(grid[0][0]==1||grid[grid.length-1][grid[0].length-1]==1)return -1;\\n        int arr[]={0,0};\\n    vis[0][0]=true;\\n        \\n        p.add(arr);\\n       int ans=0;\\n        int l=0;\\n        while(!p.isEmpty()&&l==0){\\n            ans++;\\n            int n=p.size();\\n            for(int i=0;i<n;i++){\\n                for(int t=0;t<8;t++){\\n                    int x=p.peek()[0]+k[t][0];\\n                    int y=p.peek()[1]+k[t][1];\\n                    if(x<0||y<0||x>=grid.length||y>=grid[0].length||grid[x][y]==1||vis[x][y]==true)continue;\\n                    else{\\n                        \\n                        int z[]={x,y};\\n                        p.add(z);\\n                        vis[x][y]=true;\\n                        if(x==grid.length-1&&y==grid[0].length-1){\\n                            l=1;\\n                            ans++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                p.poll();\\n            }\\n        }\\n        //ans++;\\n        if(vis[grid.length-1][grid[0].length-1]!=true)return -1;\\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int k[][]={{1,1},{1,0},{-1,-1},{-1,0},{0,-1},{0,1},{-1,1},{1,-1}};\\n      boolean vis[][]= new boolean[grid.length][grid[0].length];\\n        Queue<int[]>p=new LinkedList<>();\\n        if(grid[0][0]==1||grid[grid.length-1][grid[0].length-1]==1)return -1;\\n        int arr[]={0,0};\\n    vis[0][0]=true;\\n        \\n        p.add(arr);\\n       int ans=0;\\n        int l=0;\\n        while(!p.isEmpty()&&l==0){\\n            ans++;\\n            int n=p.size();\\n            for(int i=0;i<n;i++){\\n                for(int t=0;t<8;t++){\\n                    int x=p.peek()[0]+k[t][0];\\n                    int y=p.peek()[1]+k[t][1];\\n                    if(x<0||y<0||x>=grid.length||y>=grid[0].length||grid[x][y]==1||vis[x][y]==true)continue;\\n                    else{\\n                        \\n                        int z[]={x,y};\\n                        p.add(z);\\n                        vis[x][y]=true;\\n                        if(x==grid.length-1&&y==grid[0].length-1){\\n                            l=1;\\n                            ans++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                p.poll();\\n            }\\n        }\\n        //ans++;\\n        if(vis[grid.length-1][grid[0].length-1]!=true)return -1;\\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044416,
                "title": "c-easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0] || grid.back().back())\\n            return -1;\\n        \\n        int start = 1, ans = 2;\\n        int xMax = grid[0].size() - 1;\\n        int yMax = grid.size() - 1;\\n        \\n        if(!xMax && !yMax)\\n            return 1 - (grid[0][0] << 1);\\n        \\n        grid[0][0] = -1;\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        while(start){\\n            while(start--){\\n                \\n                auto[x, y] = q.front();\\n                q.pop();\\n                \\n                for(int i = max(x - 1, 0), currX = min(x + 1, xMax); i <= currX; i++){\\n                    \\n                    for(int j = max(y - 1, 0), currY = min(y + 1, yMax); j <= currY; j++){\\n                        \\n                        if(i == xMax && j == yMax)\\n                            return ans;\\n                        \\n                        if(!grid[j][i]){\\n                            grid[j][i] = -1;\\n                            q.push({i, j});\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n            start = q.size();\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0] || grid.back().back())\\n            return -1;\\n        \\n        int start = 1, ans = 2;\\n        int xMax = grid[0].size() - 1;\\n        int yMax = grid.size() - 1;\\n        \\n        if(!xMax && !yMax)\\n            return 1 - (grid[0][0] << 1);\\n        \\n        grid[0][0] = -1;\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        while(start){\\n            while(start--){\\n                \\n                auto[x, y] = q.front();\\n                q.pop();\\n                \\n                for(int i = max(x - 1, 0), currX = min(x + 1, xMax); i <= currX; i++){\\n                    \\n                    for(int j = max(y - 1, 0), currY = min(y + 1, yMax); j <= currY; j++){\\n                        \\n                        if(i == xMax && j == yMax)\\n                            return ans;\\n                        \\n                        if(!grid[j][i]){\\n                            grid[j][i] = -1;\\n                            q.push({i, j});\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n            start = q.size();\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043369,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] g) {\\n        if(g[0][0]==1)\\n            return -1;\\n        int m=g.length,n=g[0].length,c=0;\\n        Queue<int[]> nm=new LinkedList<>();\\n        nm.offer(new int[] {0,0,1});\\n        int d[][]={{1,1},{-1,-1},{1,0},{-1,0},{0,1},{0,-1},{1,-1},{-1,1}};\\n        while(!(nm.isEmpty()))\\n        {\\n            int l=nm.size();\\n            while(l-->0)\\n            {\\n                int f[]=nm.poll();\\n                if(f[0]==m-1&&f[1]==n-1)\\n                    return f[2];\\n                for(int k[]: d)\\n                {\\n                    int i=f[0]+k[0];\\n                    int j=f[1]+k[1];\\n                    if(i>=0&&j>=0&&i<m&&j<n&&g[i][j]==0)\\n                    {\\n                        nm.offer(new int[] {i,j,f[2]+1});\\n                        g[i][j]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] g) {\\n        if(g[0][0]==1)\\n            return -1;\\n        int m=g.length,n=g[0].length,c=0;\\n        Queue<int[]> nm=new LinkedList<>();\\n        nm.offer(new int[] {0,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 823446,
                "title": "javascript-bfs-solution",
                "content": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar shortestPathBinaryMatrix = function(grid) {\\n  const m = grid.length || 0\\n  const n = m && grid[0].length || 0\\n  \\n  if (m === 0 || n === 0 || grid[0][0] !== 0) return -1\\n\\n  let step = 1\\n  const queue = [[0, 0]]\\n  const dires = [[-1, 0], [1, 0], [0, 1], [0, -1], [-1, 1], [-1, -1], [1, 1], [1, -1]]\\n  \\n  while (queue.length) {\\n    const size = queue.length\\n    for (let i = 0; i < size; i++) {\\n      const [x, y] = queue.shift()\\n      \\n      if (x === m - 1 && y === n - 1) return step\\n      \\n      for (const [dx, dy] of dires) {\\n        const newX = x + dx, newY = y + dy\\n        if (_withinBound(newX, newY, m, n) && grid[newX][newY] === 0) {\\n          grid[newX][newY] = 1\\n          queue.push([newX, newY])\\n        }\\n      }\\n    }\\n    \\n    step += 1\\n  }\\n  \\n  return -1\\n};\\n  \\nfunction _withinBound(x, y, m, n) {\\n  return 0 <= x && 0 <= y && x < m && y < n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar shortestPathBinaryMatrix = function(grid) {\\n  const m = grid.length || 0\\n  const n = m && grid[0].length || 0\\n  \\n  if (m === 0 || n === 0 || grid[0][0] !== 0) return -1\\n\\n  let step = 1\\n  const queue = [[0, 0]]\\n  const dires = [[-1, 0], [1, 0], [0, 1], [0, -1], [-1, 1], [-1, -1], [1, 1], [1, -1]]\\n  \\n  while (queue.length) {\\n    const size = queue.length\\n    for (let i = 0; i < size; i++) {\\n      const [x, y] = queue.shift()\\n      \\n      if (x === m - 1 && y === n - 1) return step\\n      \\n      for (const [dx, dy] of dires) {\\n        const newX = x + dx, newY = y + dy\\n        if (_withinBound(newX, newY, m, n) && grid[newX][newY] === 0) {\\n          grid[newX][newY] = 1\\n          queue.push([newX, newY])\\n        }\\n      }\\n    }\\n    \\n    step += 1\\n  }\\n  \\n  return -1\\n};\\n  \\nfunction _withinBound(x, y, m, n) {\\n  return 0 <= x && 0 <= y && x < m && y < n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585519,
                "title": "python-simple-python-solution-using-queue-and-bfs",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 785 ms, faster than 21.72% of Python3 online submissions for Shortest Path in Binary Matrix.\\n# Memory Usage: 18 MB, less than 12.33% of Python3 online submissions for Shortest Path in Binary Matrix.\\n\\n\\tclass Solution:\\n\\t\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tlength = len(grid)\\n\\n\\t\\t\\tif grid[0][0] == 1 or grid[length - 1][length - 1] == 1:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tvisited = set((0,0))\\n\\n\\t\\t\\tdirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, 1], [1, -1]]\\n\\n\\t\\t\\tqueue = collections.deque([(1,0,0)])\\n\\n\\t\\t\\twhile queue:\\n\\n\\t\\t\\t\\tcurrent_distance, current_position_x , current_position_y = queue.popleft()\\n\\n\\t\\t\\t\\tif current_position_x == length - 1 and current_position_y == length - 1:\\n\\t\\t\\t\\t\\treturn current_distance\\n\\n\\t\\t\\t\\tfor direction in directions:\\n\\n\\t\\t\\t\\t\\tx , y = direction\\n\\n\\t\\t\\t\\t\\tnext_position_x , next_position_y =  current_position_x + x , current_position_y + y\\n\\n\\t\\t\\t\\t\\tif 0 <= current_position_x < length and 0 <= current_position_y < length and grid[current_position_x][current_position_y] == 0 and (next_position_x , next_position_y) not in visited: \\n\\n\\t\\t\\t\\t\\t\\tqueue.append((current_distance + 1 , next_position_x , next_position_y))\\n\\t\\t\\t\\t\\t\\tvisited.add((next_position_x , next_position_y))\\n\\n\\t\\t\\treturn -1\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 785 ms, faster than 21.72% of Python3 online submissions for Shortest Path in Binary Matrix.\\n# Memory Usage: 18 MB, less than 12.33% of Python3 online submissions for Shortest Path in Binary Matrix.\\n\\n\\tclass Solution:\\n\\t\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tlength = len(grid)\\n\\n\\t\\t\\tif grid[0][0] == 1 or grid[length - 1][length - 1] == 1:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tvisited = set((0,0))\\n\\n\\t\\t\\tdirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, 1], [1, -1]]\\n\\n\\t\\t\\tqueue = collections.deque([(1,0,0)])\\n\\n\\t\\t\\twhile queue:\\n\\n\\t\\t\\t\\tcurrent_distance, current_position_x , current_position_y = queue.popleft()\\n\\n\\t\\t\\t\\tif current_position_x == length - 1 and current_position_y == length - 1:\\n\\t\\t\\t\\t\\treturn current_distance\\n\\n\\t\\t\\t\\tfor direction in directions:\\n\\n\\t\\t\\t\\t\\tx , y = direction\\n\\n\\t\\t\\t\\t\\tnext_position_x , next_position_y =  current_position_x + x , current_position_y + y\\n\\n\\t\\t\\t\\t\\tif 0 <= current_position_x < length and 0 <= current_position_y < length and grid[current_position_x][current_position_y] == 0 and (next_position_x , next_position_y) not in visited: \\n\\n\\t\\t\\t\\t\\t\\tqueue.append((current_distance + 1 , next_position_x , next_position_y))\\n\\t\\t\\t\\t\\t\\tvisited.add((next_position_x , next_position_y))\\n\\n\\t\\t\\treturn -1\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3584631,
                "title": "c-easy-understanding-queue-shortest-path-bfs",
                "content": "\\nSimply insert the start 0,0 in queue with distance 0. Traverse through valid neighbours in eight directions and having cell value 0 is a valid cell. Now if the previously stored distance is more then replace with distance of parent +1 and insert in queue with dist+1.\\nThe edge cases are that if the grid[0][0]=1 then we cannot start only so return -1.\\nif the stored distance at last grid is 1e9 then we cannot reach that cell so return -1.\\nAt last number of visited cells is distance of last cell +1.\\n\\n\\n**Please Upvote if you found this Useful !**\\n\\n\\n```\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        if(grid[0][0]!=0) return -1;\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dist[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int delrow[]={-1,-1,0,1,1,1,0,-1};\\n        int delcol[]={0,-1,-1,-1,0,1,1,1};\\n        while(!q.empty()){\\n            int dis= q.front().first;\\n            int row= q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            for(int i=0; i<8; i++){\\n                int nrow= row+delrow[i];\\n                int ncol= col+ delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==0 &&\\n                  dist[nrow][ncol]>1+dis){\\n                    dist[nrow][ncol]=1+dis;\\n                    q.push({dist[nrow][ncol],{nrow,ncol}});\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        if(dist[n-1][m-1]==1e9) return -1;\\n        return dist[n-1][m-1]+1;\\n        \\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "\\nSimply insert the start 0,0 in queue with distance 0. Traverse through valid neighbours in eight directions and having cell value 0 is a valid cell. Now if the previously stored distance is more then replace with distance of parent +1 and insert in queue with dist+1.\\nThe edge cases are that if the grid[0][0]=1 then we cannot start only so return -1.\\nif the stored distance at last grid is 1e9 then we cannot reach that cell so return -1.\\nAt last number of visited cells is distance of last cell +1.\\n\\n\\n**Please Upvote if you found this Useful !**\\n\\n\\n```\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        if(grid[0][0]!=0) return -1;\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dist[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int delrow[]={-1,-1,0,1,1,1,0,-1};\\n        int delcol[]={0,-1,-1,-1,0,1,1,1};\\n        while(!q.empty()){\\n            int dis= q.front().first;\\n            int row= q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            for(int i=0; i<8; i++){\\n                int nrow= row+delrow[i];\\n                int ncol= col+ delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==0 &&\\n                  dist[nrow][ncol]>1+dis){\\n                    dist[nrow][ncol]=1+dis;\\n                    q.push({dist[nrow][ncol],{nrow,ncol}});\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        if(dist[n-1][m-1]==1e9) return -1;\\n        return dist[n-1][m-1]+1;\\n        \\n        \\n        \\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3584182,
                "title": "here-s-why-dp-fails-clear-explanation",
                "content": "# C++ RECURSION CODE BUT IT FAILS !\\n```class Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, int i, int j, vector<vector<bool>>& visited) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1) {\\n            return INT_MAX;\\n        }\\n        \\n        if (i == m - 1 && j == n - 1) {\\n            return 1;\\n        }\\n        \\n        visited[i][j] = true;\\n        \\n        int diagonal = solve(grid, i + 1, j + 1, visited);\\n        int down = solve(grid, i + 1, j, visited);\\n        int right = solve(grid, i, j + 1, visited);\\n        \\n        visited[i][j] = false;\\n        \\n        int minPath = min(diagonal, min(down, right));\\n        return (minPath == INT_MAX) ? INT_MAX : minPath + 1;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {\\n            return -1; // Invalid path\\n        }\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        int ans = solve(grid, 0, 0, visited);\\n        return (ans == INT_MAX) ? -1 : ans;\\n    }\\n};\\n```\\n# EXPLANATIION WITH TESTCASE\\n![WhatsApp Image 2023-06-01 at 8.07.59 AM.jpeg](https://assets.leetcode.com/users/images/77fd038d-f8ab-4554-a269-496127da48c3_1685587494.6188555.jpeg)\\n\\nHope it will give you a clear understanding of why DP fails !",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, int i, int j, vector<vector<bool>>& visited) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1) {\\n            return INT_MAX;\\n        }\\n        \\n        if (i == m - 1 && j == n - 1) {\\n            return 1;\\n        }\\n        \\n        visited[i][j] = true;\\n        \\n        int diagonal = solve(grid, i + 1, j + 1, visited);\\n        int down = solve(grid, i + 1, j, visited);\\n        int right = solve(grid, i, j + 1, visited);\\n        \\n        visited[i][j] = false;\\n        \\n        int minPath = min(diagonal, min(down, right));\\n        return (minPath == INT_MAX) ? INT_MAX : minPath + 1;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {\\n            return -1; // Invalid path\\n        }\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        int ans = solve(grid, 0, 0, visited);\\n        return (ans == INT_MAX) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584062,
                "title": "easy-c-code-100-efficient-bfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> direction = {{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {-1,-1}, {1,-1}, {-1,1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(grid[0][0] == 1 or grid[m-1][n-1] == 1) return -1;\\n        grid[0][0] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        while(!q.empty()){\\n            auto [x, y] = q.front();\\n            q.pop();\\n            if(x == m-1 and y == n-1) return grid[x][y];\\n            for(auto [x1, y1] : direction){\\n                int newX = x + x1;\\n                int newY = y + y1;\\n                if(newX >= 0 and newX < m and newY >= 0 and newY < n and grid[newX][newY] == 0){\\n                    grid[newX][newY] = grid[x][y]+1;\\n                    q.push({newX, newY});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> direction = {{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {-1,-1}, {1,-1}, {-1,1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(grid[0][0] == 1 or grid[m-1][n-1] == 1) return -1;\\n        grid[0][0] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        while(!q.empty()){\\n            auto [x, y] = q.front();\\n            q.pop();\\n            if(x == m-1 and y == n-1) return grid[x][y];\\n            for(auto [x1, y1] : direction){\\n                int newX = x + x1;\\n                int newY = y + y1;\\n                if(newX >= 0 and newX < m and newY >= 0 and newY < n and grid[newX][newY] == 0){\\n                    grid[newX][newY] = grid[x][y]+1;\\n                    q.push({newX, newY});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158713,
                "title": "java-easy-to-understand-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    int second;\\n    int third;\\n    \\n    Pair(int fst,int scnd,int thrd){\\n        this.first=fst;\\n        this.second=scnd;\\n        this.third=thrd;\\n    }\\n}\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0]!=0) return -1;\\n\\n        \\n        \\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        if(grid[0][0]==grid[n-1][n-1] && n==1) return 1;\\n\\n        int dist[][]=new int[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dist[i][j]=(int)1e9;\\n            }\\n        }\\n        \\n        int delRow[]={1,-1,0,0,1,1,-1,-1};\\n        int delCol[]={0,0,1,-1,-1,1,-1,1};\\n        \\n        dist[0][0]=0;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(1,0,0));\\n        \\n        while(!q.isEmpty()){\\n            int dis=q.peek().first;\\n            int row=q.peek().second;\\n            int col=q.peek().third;\\n            q.poll();\\n            \\n            for(int i=0;i<8;i++){\\n                int nrow=row+delRow[i];\\n                int ncol=col+delCol[i];\\n                \\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==0 \\n                && dis+1<dist[nrow][ncol]){\\n                    \\n                    if(nrow==n-1 && ncol==n-1) return dis+1;\\n                    \\n                    q.add(new Pair(dis+1,nrow,ncol));\\n                    dist[nrow][ncol]=dis+1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    int second;\\n    int third;\\n    \\n    Pair(int fst,int scnd,int thrd){\\n        this.first=fst;\\n        this.second=scnd;\\n        this.third=thrd;\\n    }\\n}\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0]!=0) return -1;\\n\\n        \\n        \\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        if(grid[0][0]==grid[n-1][n-1] && n==1) return 1;\\n\\n        int dist[][]=new int[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dist[i][j]=(int)1e9;\\n            }\\n        }\\n        \\n        int delRow[]={1,-1,0,0,1,1,-1,-1};\\n        int delCol[]={0,0,1,-1,-1,1,-1,1};\\n        \\n        dist[0][0]=0;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(1,0,0));\\n        \\n        while(!q.isEmpty()){\\n            int dis=q.peek().first;\\n            int row=q.peek().second;\\n            int col=q.peek().third;\\n            q.poll();\\n            \\n            for(int i=0;i<8;i++){\\n                int nrow=row+delRow[i];\\n                int ncol=col+delCol[i];\\n                \\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==0 \\n                && dis+1<dist[nrow][ncol]){\\n                    \\n                    if(nrow==n-1 && ncol==n-1) return dis+1;\\n                    \\n                    q.add(new Pair(dis+1,nrow,ncol));\\n                    dist[nrow][ncol]=dis+1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127547,
                "title": "ezpz-py-soln-2023",
                "content": "\\n```\\nclass Solution:\\n\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\t\\trow, col, queue = len(grid), len(grid[0]), deque([(0,0,1)])\\n\\n\\t\\tif grid[0][0] == 1: return -1 # bruh, if it aint 0 then it aint gonna work\\n\\n\\t\\twhile queue:\\n\\t\\t\\tx, y, steps = queue.popleft()\\n\\t\\t\\tif x == row-1 and y == col-1:\\n\\t\\t\\t\\treturn steps\\n\\t\\t\\tfor nx,ny in [[x+1,y+1], [x-1,y-1], [x+1,y-1], [x-1,y+1], [x+1,y], [x-1,y], [x,y+1], [x,y-1]]:\\n\\t\\t\\t\\tif 0<=nx<row and 0<=ny<col and grid[nx][ny] == 0:\\n\\t\\t\\t\\t\\tgrid[nx][ny] = \"X\"\\n\\t\\t\\t\\t\\tqueue.append((nx, ny, steps+1))\\n\\n\\t\\treturn -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\t\\trow, col, queue = len(grid), len(grid[0]), deque([(0,0,1)])\\n\\n\\t\\tif grid[0][0] == 1: return -1 # bruh, if it aint 0 then it aint gonna work\\n\\n\\t\\twhile queue:\\n\\t\\t\\tx, y, steps = queue.popleft()\\n\\t\\t\\tif x == row-1 and y == col-1:\\n\\t\\t\\t\\treturn steps\\n\\t\\t\\tfor nx,ny in [[x+1,y+1], [x-1,y-1], [x+1,y-1], [x-1,y+1], [x+1,y], [x-1,y], [x,y+1], [x,y-1]]:\\n\\t\\t\\t\\tif 0<=nx<row and 0<=ny<col and grid[nx][ny] == 0:\\n\\t\\t\\t\\t\\tgrid[nx][ny] = \"X\"\\n\\t\\t\\t\\t\\tqueue.append((nx, ny, steps+1))\\n\\n\\t\\treturn -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554394,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass Solution {\\n    public class Pair{\\n        int x, y, count;\\n        public Pair(int x, int y, int count){\\n            this.x = x;\\n            this.y = y;\\n            this.count = count;\\n        }\\n    }\\n    \\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] != 0) return -1;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0, 1));\\n        \\n        int[] drow = {-1, 0, 1, 0, -1, 1, 1, -1};\\n        int[] dcol = {0, -1, 0, 1, -1, 1, -1, 1};\\n        \\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            while(s-- > 0){\\n                Pair curr = q.poll();\\n                int x = curr.x;\\n                int y = curr.y;\\n                int count = curr.count;\\n                \\n                if(x == n-1 && y == m-1)\\n                    return count;\\n                for(int i=0; i<8; i++){\\n                    int nrow = x + drow[i];\\n                    int ncol = y + dcol[i];\\n                    if(nrow >= 0 && ncol >= 0 && nrow < n && ncol < m && grid[nrow][ncol] == 0){\\n                        q.add(new Pair(nrow, ncol, count+1));\\n                        grid[nrow][ncol] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair{\\n        int x, y, count;\\n        public Pair(int x, int y, int count){\\n            this.x = x;\\n            this.y = y;\\n            this.count = count;\\n        }\\n    }\\n    \\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] != 0) return -1;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0, 1));\\n        \\n        int[] drow = {-1, 0, 1, 0, -1, 1, 1, -1};\\n        int[] dcol = {0, -1, 0, 1, -1, 1, -1, 1};\\n        \\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            while(s-- > 0){\\n                Pair curr = q.poll();\\n                int x = curr.x;\\n                int y = curr.y;\\n                int count = curr.count;\\n                \\n                if(x == n-1 && y == m-1)\\n                    return count;\\n                for(int i=0; i<8; i++){\\n                    int nrow = x + drow[i];\\n                    int ncol = y + dcol[i];\\n                    if(nrow >= 0 && ncol >= 0 && nrow < n && ncol < m && grid[nrow][ncol] == 0){\\n                        q.add(new Pair(nrow, ncol, count+1));\\n                        grid[nrow][ncol] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906805,
                "title": "template-for-these-kind-of-questions-python-bfs-without-visited-set",
                "content": "**Here is a template to solve these kind of question**\\nIn every question ,we just have to change the conditon for counting the res...\\nrest of the procedure is gonna same for all questions.\\n\\n# CODE\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n         \\n        r=len(grid)\\n        c=len(grid[0])\\n        \\n        # base case\\n        if grid[0][0] or grid[r-1][c-1]:\\n            return -1\\n        \\n#       it\\'s better to define the directioln first instead to define in the bfs main function\\n        direction=[(1,0),(0,1),(-1,0),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)]\\n        \\n#       initialize the queue with starting index and starting shell \\n        q=deque([(0,0,1)])\\n        \\n        while q:\\n            \\n            x,y,no_cell=q.popleft()\\n            \\n#           condition to return the result   \\n            if x==r-1 and y==c-1:\\n                return no_cell\\n\\n            for d in direction:\\n                nx=x+d[0]\\n                ny=y+d[1]\\n                \\n#               check for boundry condition and block places in the grid\\n                if 0<=nx<r and 0<=ny<c and grid[nx][ny]==0:\\n                   \\n#                   changing the grid value so that we don\\'t traverse again through it \\n#                   instead of using the seen/visited set we just change the grid value to mark it as visited \\n                    \\n                    grid[nx][ny]=1\\n                    q.append((nx,ny,no_cell+1))\\n        return -1\\n```\\nr==rows\\nc=columns\\n**Time complexity**:   r.c\\n**Space complexity**: Number of zero in the grid (which eventually added in queue)\\n\\n\\n![image](https://assets.leetcode.com/users/images/da439bd0-8c05-4b2e-a517-987869868a9d_1648911706.9934976.png)\\n\\n\\n**If you like the above content . Please Upvote.... car \\uD83E\\uDD17\\uD83E\\uDD17**\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n         \\n        r=len(grid)\\n        c=len(grid[0])\\n        \\n        # base case\\n        if grid[0][0] or grid[r-1][c-1]:\\n            return -1\\n        \\n#       it\\'s better to define the directioln first instead to define in the bfs main function\\n        direction=[(1,0),(0,1),(-1,0),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)]\\n        \\n#       initialize the queue with starting index and starting shell \\n        q=deque([(0,0,1)])\\n        \\n        while q:\\n            \\n            x,y,no_cell=q.popleft()\\n            \\n#           condition to return the result   \\n            if x==r-1 and y==c-1:\\n                return no_cell\\n\\n            for d in direction:\\n                nx=x+d[0]\\n                ny=y+d[1]\\n                \\n#               check for boundry condition and block places in the grid\\n                if 0<=nx<r and 0<=ny<c and grid[nx][ny]==0:\\n                   \\n#                   changing the grid value so that we don\\'t traverse again through it \\n#                   instead of using the seen/visited set we just change the grid value to mark it as visited \\n                    \\n                    grid[nx][ny]=1\\n                    q.append((nx,ny,no_cell+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833879,
                "title": "simple-c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dir{{0 , -1} , {0 , 1} , {1 , 0} , {-1 , 0} , {-1 , -1} , {-1 , 1} , {1 , -1} , {1 , 1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // int m = grid[0].size();\\n        if(n == 1 and grid[0][0] == 0)return 1;\\n        if(n == 1 and grid[0][0] == 1)return -1;\\n        if(grid[0][0] == 1 or grid[n-1][n-1] == 1)return -1;\\n        \\n        queue<pair<int , int>>q;\\n        q.push({0 , 0});\\n        vector<vector<bool>>vis(n , vector<bool>(n , 0));\\n        vis[0][0] = true;\\n        int ct = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto temp = q.front();\\n                q.pop();\\n                for(int i = 0 ; i < dir.size() ; i++){\\n                    int first = temp.first + dir[i][0];\\n                    int second = temp.second + dir[i][1];\\n                    if(first >= 0 and second >= 0 and first < n and second < n and !vis[first][second] and grid[first][second] == 0){\\n                        if(first == n-1 and  second == n-1){\\n                            return ct + 1;\\n                        }else{\\n                            vis[first][second] = true;\\n                            q.push({first , second});\\n                        }\\n                    }\\n                }\\n            }\\n            ct++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dir{{0 , -1} , {0 , 1} , {1 , 0} , {-1 , 0} , {-1 , -1} , {-1 , 1} , {1 , -1} , {1 , 1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // int m = grid[0].size();\\n        if(n == 1 and grid[0][0] == 0)return 1;\\n        if(n == 1 and grid[0][0] == 1)return -1;\\n        if(grid[0][0] == 1 or grid[n-1][n-1] == 1)return -1;\\n        \\n        queue<pair<int , int>>q;\\n        q.push({0 , 0});\\n        vector<vector<bool>>vis(n , vector<bool>(n , 0));\\n        vis[0][0] = true;\\n        int ct = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto temp = q.front();\\n                q.pop();\\n                for(int i = 0 ; i < dir.size() ; i++){\\n                    int first = temp.first + dir[i][0];\\n                    int second = temp.second + dir[i][1];\\n                    if(first >= 0 and second >= 0 and first < n and second < n and !vis[first][second] and grid[first][second] == 0){\\n                        if(first == n-1 and  second == n-1){\\n                            return ct + 1;\\n                        }else{\\n                            vis[first][second] = true;\\n                            q.push({first , second});\\n                        }\\n                    }\\n                }\\n            }\\n            ct++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823962,
                "title": "typescript-bfs-100-88ms",
                "content": "```\\nconst movements = [\\n    { x: 0, y: 1 },\\n    { x: 0, y: -1 },\\n    { y: 0, x: -1 },\\n    { y: 0, x: 1 },\\n    { x: 1, y: 1 },\\n    { x: 1, y: -1 },\\n    { y: 1, x: -1 },\\n    { y: -1, x: -1 },\\n]\\n\\nfunction safeToMove(x: number, y: number, grid: number[][]) {\\n    return x >= 0 && x < grid.length && y >= 0 && y < grid.length && grid[y][x] === 0;\\n}\\n\\nfunction shortestPathBinaryMatrix(grid: number[][]): number {\\n    const n = grid.length - 1;\\n\\n    if (grid[n][n] === 1 || grid[0][0] === 1) return -1;\\n\\n    let shortest = -1;\\n\\n    const queue: { x: number, y: number, count: number }[] = [{ x: 0, y: 0, count: 1 }];\\n    grid[0][0] = 1;\\n\\n    while (queue.length > 0) {\\n        const { x, y, count } = queue.shift()!;\\n        if (x === n && y === n) {\\n            return count;\\n        } else {\\n            for (const movement of movements) {\\n                const nextX = x + movement.x;\\n                const nextY = y + movement.y;\\n\\t\\t\\t\\t\\n                if (safeToMove(nextX, nextY, grid)) {\\n                    queue.push({ x: nextX, y: nextY, count: count + 1 })\\n                    grid[nextY][nextX] = 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    return shortest;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst movements = [\\n    { x: 0, y: 1 },\\n    { x: 0, y: -1 },\\n    { y: 0, x: -1 },\\n    { y: 0, x: 1 },\\n    { x: 1, y: 1 },\\n    { x: 1, y: -1 },\\n    { y: 1, x: -1 },\\n    { y: -1, x: -1 },\\n]\\n\\nfunction safeToMove(x: number, y: number, grid: number[][]) {\\n    return x >= 0 && x < grid.length && y >= 0 && y < grid.length && grid[y][x] === 0;\\n}\\n\\nfunction shortestPathBinaryMatrix(grid: number[][]): number {\\n    const n = grid.length - 1;\\n\\n    if (grid[n][n] === 1 || grid[0][0] === 1) return -1;\\n\\n    let shortest = -1;\\n\\n    const queue: { x: number, y: number, count: number }[] = [{ x: 0, y: 0, count: 1 }];\\n    grid[0][0] = 1;\\n\\n    while (queue.length > 0) {\\n        const { x, y, count } = queue.shift()!;\\n        if (x === n && y === n) {\\n            return count;\\n        } else {\\n            for (const movement of movements) {\\n                const nextX = x + movement.x;\\n                const nextY = y + movement.y;\\n\\t\\t\\t\\t\\n                if (safeToMove(nextX, nextY, grid)) {\\n                    queue.push({ x: nextX, y: nextY, count: count + 1 })\\n                    grid[nextY][nextX] = 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    return shortest;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1643336,
                "title": "c-bfs-mark-the-nodes-as-soon-as-you-push-them-into-queue-to-avoid-tle",
                "content": "\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid[0][0] == 1) return -1;\\n        queue<pair<int, int>> Q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        Q.push({0, 0});\\n        grid[0][0] = 1;\\n        int depth = 0;\\n        auto isValid = [&](int a, int b) {\\n            return (a >= 0 && b >= 0 && a < n && b < m);  \\n        };\\n        while(Q.size() > 0) {\\n            int N = (int)Q.size();\\n            ++depth;\\n            while(N--) {\\n                auto node = Q.front();\\n                Q.pop();\\n                if (node.first == n - 1 && node.second == m - 1) return depth;\\n                for (int i = -1; i < 2; ++i) {\\n                    for (int j = -1; j < 2; ++j) {\\n                        if (i == 0 && j == 0) continue;\\n                        int X = i + node.first;\\n                        int Y = j + node.second;\\n                        if (isValid(X, Y) && grid[X][Y] == 0) {\\n                            grid[X][Y] = 1;\\n                            Q.push({X, Y});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid[0][0] == 1) return -1;\\n        queue<pair<int, int>> Q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        Q.push({0, 0});\\n        grid[0][0] = 1;\\n        int depth = 0;\\n        auto isValid = [&](int a, int b) {\\n            return (a >= 0 && b >= 0 && a < n && b < m);  \\n        };\\n        while(Q.size() > 0) {\\n            int N = (int)Q.size();\\n            ++depth;\\n            while(N--) {\\n                auto node = Q.front();\\n                Q.pop();\\n                if (node.first == n - 1 && node.second == m - 1) return depth;\\n                for (int i = -1; i < 2; ++i) {\\n                    for (int j = -1; j < 2; ++j) {\\n                        if (i == 0 && j == 0) continue;\\n                        int X = i + node.first;\\n                        int Y = j + node.second;\\n                        if (isValid(X, Y) && grid[X][Y] == 0) {\\n                            grid[X][Y] = 1;\\n                            Q.push({X, Y});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602336,
                "title": "simple-bfs-python-solution-with-comments",
                "content": "#Time O(N) where N is the number of cells, Space O(N)\\n\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        def valid(r,c):\\n            return 0<=r<len(grid) and 0<=c<len(grid[0]) and grid[r][c]==0 \\n            \\n        \\n        if grid[0][0]==1 or grid[-1][-1]==1: return -1 #no need to loop it means wither start or end are not valis\\n        \\n        q=deque([(0,0,1)]) #(row,col,moves)\\n        directions=[(1,0),(-1,0),(0,1),(0,-1),(-1,-1),(-1,1),(1,1),(1,-1)]\\n        grid[0][0]=1 #mark first sell visited\\n        while q:\\n            r,c,moves=q.popleft()\\n            if r==len(grid)-1 and c==len(grid[0])-1:\\n                return moves\\n            \\n            for row,col in directions:\\n                newR=r+row\\n                newC=c+col\\n                if valid(newR,newC):\\n                    grid[newR][newC]=1 #mark visited by flipping to one\\n                    q.append((newR,newC,moves+1))\\n        return -1\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        def valid(r,c):\\n            return 0<=r<len(grid) and 0<=c<len(grid[0]) and grid[r][c]==0 \\n            \\n        \\n        if grid[0][0]==1 or grid[-1][-1]==1: return -1 #no need to loop it means wither start or end are not valis\\n        \\n        q=deque([(0,0,1)]) #(row,col,moves)\\n        directions=[(1,0),(-1,0),(0,1),(0,-1),(-1,-1),(-1,1),(1,1),(1,-1)]\\n        grid[0][0]=1 #mark first sell visited\\n        while q:\\n            r,c,moves=q.popleft()\\n            if r==len(grid)-1 and c==len(grid[0])-1:\\n                return moves\\n            \\n            for row,col in directions:\\n                newR=r+row\\n                newC=c+col\\n                if valid(newR,newC):\\n                    grid[newR][newC]=1 #mark visited by flipping to one\\n                    q.append((newR,newC,moves+1))\\n        return -1\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063637,
                "title": "bfs-solution-in-java",
                "content": "```\\nclass Matrix{\\n    int r;\\n    int c;\\n    Matrix(int r,int c){\\n        this.r=r;\\n        this.c=c;\\n    }\\n}\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid.length==0 || grid[0].length==0)\\n            return 0;\\n        \\n        int visited[][]=new int[grid.length][grid[0].length];\\n        for (int[] row : visited) \\n            Arrays.fill(row, -1); \\n        Queue<Matrix> q=new LinkedList<Matrix>();\\n        if(grid[0][0]==0){\\n            q.add(new Matrix(0,0));\\n            visited[0][0]=1;\\n        }\\n        \\n        while(!q.isEmpty()){\\n            Matrix m=q.remove();\\n            int level=visited[m.r][m.c];\\n            int R[]={-1,-1,-1,0,0,1,1,1};\\n            int C[]={-1,0,1,-1,1,-1,0,1};\\n            for(int i=0;i<8;i++){\\n                int currR=m.r+R[i];\\n                int currC=m.c+C[i];\\n                if(currR>=grid.length || currR<0 || currC<0 ||currC>=grid[0].length)\\n                    continue;\\n                if(visited[currR][currC]==-1 && grid[currR][currC]==0)\\n                {\\n                    visited[currR][currC]=level+1;\\n                    q.add(new Matrix(currR,currC));\\n                }\\n            }\\n        }\\n        return visited[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Matrix{\\n    int r;\\n    int c;\\n    Matrix(int r,int c){\\n        this.r=r;\\n        this.c=c;\\n    }\\n}\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid.length==0 || grid[0].length==0)\\n            return 0;\\n        \\n        int visited[][]=new int[grid.length][grid[0].length];\\n        for (int[] row : visited) \\n            Arrays.fill(row, -1); \\n        Queue<Matrix> q=new LinkedList<Matrix>();\\n        if(grid[0][0]==0){\\n            q.add(new Matrix(0,0));\\n            visited[0][0]=1;\\n        }\\n        \\n        while(!q.isEmpty()){\\n            Matrix m=q.remove();\\n            int level=visited[m.r][m.c];\\n            int R[]={-1,-1,-1,0,0,1,1,1};\\n            int C[]={-1,0,1,-1,1,-1,0,1};\\n            for(int i=0;i<8;i++){\\n                int currR=m.r+R[i];\\n                int currC=m.c+C[i];\\n                if(currR>=grid.length || currR<0 || currC<0 ||currC>=grid[0].length)\\n                    continue;\\n                if(visited[currR][currC]==-1 && grid[currR][currC]==0)\\n                {\\n                    visited[currR][currC]=level+1;\\n                    q.add(new Matrix(currR,currC));\\n                }\\n            }\\n        }\\n        return visited[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063636,
                "title": "try-with-c-a-star",
                "content": "for A star explanations: https://www.redblobgames.com/pathfinding/a-star/introduction.html\\n\\nA star is based on Dijkstra, but extends Dijkstra\\'s priority key to included heuristic cost(next, target) in addition.\\n\\nin Astar we can NOT use hashset to simply skip visited nodes liked BFS did,  because A star uses the heuristic as only kind of assumption, therefore Astar cannot guarantee that costs to visited nodes wouldn\\'t be reduced by newly found paths.\\n\\nfinally for the heuristic(next ,target) , I used max(abs(n-1-x), abs(n-1-y) ), i.e. the larger absolution difference either on x coordiator or on y coordiator\\uFF0Cbut not the manhattan distance since moving on diagonal directions are allowed.\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(!n || grid[0][0]==1 || grid[n-1][n-1]==1) return -1;\\n\\t\\t\\n        return Astar(grid);\\n    }\\n    \\n    int Astar(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq; \\n\\t\\tpq.push({0,0});\\n        int n = grid.size();\\n        int steps=0;\\n        vector<int> distance( n*n, INT_MAX);\\n        distance[0] = 1;\\n        \\n        while( !pq.empty()) {\\n            auto cur = pq.top(); pq.pop();  \\n            steps = distance[cur.second];\\n            int x = cur.second/n;\\n            int y = cur.second%n;  \\n            if ( x==n-1 && y==n-1) return steps;\\n                \\n            for( pair<int, int> p: vector<pair<int,int>>({ {-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1} })) {\\n                int dx = p.first + x;\\n                int dy = p.second +y;\\n                if( dx<0|| dx>=n || dy <0 || dy>=n || grid[dx][dy]==1 ||  distance[dx*n+dy] <= distance[ x*n+ y] +1   ) continue;\\n\\n                distance[dx*n+dy] = distance[ x*n+ y] +1 ;\\n                pq.push( { distance[dx*n+dy] +max(abs(n-1-x), abs(n-1-y))  , dx*n+dy} ); \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(!n || grid[0][0]==1 || grid[n-1][n-1]==1) return -1;\\n\\t\\t\\n        return Astar(grid);\\n    }\\n    \\n    int Astar(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq; \\n\\t\\tpq.push({0,0});\\n        int n = grid.size();\\n        int steps=0;\\n        vector<int> distance( n*n, INT_MAX);\\n        distance[0] = 1;\\n        \\n        while( !pq.empty()) {\\n            auto cur = pq.top(); pq.pop();  \\n            steps = distance[cur.second];\\n            int x = cur.second/n;\\n            int y = cur.second%n;  \\n            if ( x==n-1 && y==n-1) return steps;\\n                \\n            for( pair<int, int> p: vector<pair<int,int>>({ {-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1} })) {\\n                int dx = p.first + x;\\n                int dy = p.second +y;\\n                if( dx<0|| dx>=n || dy <0 || dy>=n || grid[dx][dy]==1 ||  distance[dx*n+dy] <= distance[ x*n+ y] +1   ) continue;\\n\\n                distance[dx*n+dy] = distance[ x*n+ y] +1 ;\\n                pq.push( { distance[dx*n+dy] +max(abs(n-1-x), abs(n-1-y))  , dx*n+dy} ); \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063571,
                "title": "js-python-java-c-bfs-solution-w-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nWhen we\\'re asked about finding the \"shortest path\", the first thing that should come to mind is a **breadth-first solution** (BFS) approach. In a standard graph BFS solution, we set up a **queue** (**q**) and fill it with our starting position (**grid[0][0]**). Then we keep pulling entries from **q**, figuring out the next moves from that position, and input those next moves back into **q**.\\n\\nWhen we\\'re ready to start, we can change **grid[0][0]** to **1**, then as we reach new cells, we can store the distance to that cell in the cell at the same time we add it to the queue. The distance will simply be one more than the distance to the cell we\\'re moving from. This will also eliminate duplicate queue entries by changing visited cells to a non-zero number.\\n\\nThrough the nature of a BFS approach to graph traversal (with non-weighted edges), the first time we reach the end location (**grid[n][n]**) will represent the best possible distance.\\n\\nSince **0 <= i, j <= 100**, both **i** and **j** will fit into **7 bits** each, so we can utilize **bit manipulation** to store both in one integer. With a **bitwise left shift** (**<<**) we can move the value of **j** to the left by **7 bits** before adding it to **i** to allow for both to fit in **14 bits** of an integer.\\n```js\\nBitwise shift example:\\n\\n   i  =  93 (base 10)  =  1011101 (base 2)\\n   j  =  75 (base 10)  =  1001011 (base 2)\\n\\n   j << 7  =  1001011<<<<<<<     // Bitwise left shift moves the value left\\n           =  10010110000000     // And fills in the space with 0s\\n\\n   i:                           1011101 \\n        j << 7:       +  10010110000000\\n                        ----------------\\n   i + (j << 7):      =  10010111011101 (base 2)\\n                      =            9693 (base 10)\\n```\\nTo read **i** from the first **7 bits** of our stored integer again, you can use **bitwise AND** (**&**) and a **bitmask** of **1111111**. The easiest way to get a bitmask of **1111111** is to shift a single bit to the left by **7** (**1 << 7 = 10000000**) and then subtract **1**, rolling it back to all **1**s.\\n```js\\nBitmask example:\\n\\n   1 << 7:               10000000\\n                      -         1\\n                        ----------\\n   (1 << 7) - 1:      =   1111111\\n```\\nThe bitwise AND will only keep any bits that have a **1** in both numbers, thus stripping away anything except the first **7 bits** of data.\\n```js\\nBitwise AND example:\\n\\n      10010111011101\\n   &         1111111\\n     ----------------\\n   =         1011101\\n```\\nTo read the **j** value from our integer, we can just shift it to the right by **7 bits**, which will throw away the first **7 bits** of data corresponding to the **i** value.\\n\\nIf **q** becomes empty without finding a path to the end, then **return -1**.\\n\\n---\\n\\n***Implementation:***\\n\\nIf either the starting point or the ending point are a **1**, then we quickly **return -1**.\\n\\nTo check which moves can be made, we can just iterate over a three-value range for each **i** and **j**, and to make sure that they remain in bounds, we can apply a **max** and **min** to the range.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **88ms / 42.3MB** (beats 100% / 100%).\\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {\\n    let n = grid.length - 1, q = [0]\\n    if (grid[0][0] || grid[n][n]) return -1\\n    grid[0][0] = 1\\n    while (q.length) {\\n        let curr = q.shift(), i = curr & (1 << 7) - 1, j = curr >> 7\\n        if (i === n && j === n) return grid[n][n]\\n        for (let a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n            for (let b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                if (grid[a][b] === 0)\\n                    grid[a][b] = grid[i][j] + 1, q.push(a + (b << 7))\\n    }\\n    return -1\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **656ms / 14.5MB** (beats 70% / 90%).\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n        q, grid[0][0] = [0], 1\\n        while len(q):\\n            curr = q.pop(0)\\n            i, j = curr & ((1 << 7) - 1), curr >> 7\\n            if i == n and j == n: return grid[n][n]\\n            for a in range(max(i-1,0),min(i+2,n+1)):\\n                for b in range(max(j-1,0),min(j+2,n+1)):\\n                    if grid[a][b] == 0:\\n                        grid[a][b] = grid[i][j] + 1\\n                        q.append(a + (b << 7))\\n        return -1\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **8ms / 40.0MB** (beats 100% / 90%).\\n```java\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        Queue<Integer> q = new ArrayDeque<Integer>();\\n        q.add(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.remove(), i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n                for (int b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.add(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **36 / 18.0MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nBitwise shift example:\\n\\n   i  =  93 (base 10)  =  1011101 (base 2)\\n   j  =  75 (base 10)  =  1001011 (base 2)\\n\\n   j << 7  =  1001011<<<<<<<     // Bitwise left shift moves the value left\\n           =  10010110000000     // And fills in the space with 0s\\n\\n   i:                           1011101 \\n        j << 7:       +  10010110000000\\n                        ----------------\\n   i + (j << 7):      =  10010111011101 (base 2)\\n                      =            9693 (base 10)\\n```\n```js\\nBitmask example:\\n\\n   1 << 7:               10000000\\n                      -         1\\n                        ----------\\n   (1 << 7) - 1:      =   1111111\\n```\n```js\\nBitwise AND example:\\n\\n      10010111011101\\n   &         1111111\\n     ----------------\\n   =         1011101\\n```\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {\\n    let n = grid.length - 1, q = [0]\\n    if (grid[0][0] || grid[n][n]) return -1\\n    grid[0][0] = 1\\n    while (q.length) {\\n        let curr = q.shift(), i = curr & (1 << 7) - 1, j = curr >> 7\\n        if (i === n && j === n) return grid[n][n]\\n        for (let a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n            for (let b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                if (grid[a][b] === 0)\\n                    grid[a][b] = grid[i][j] + 1, q.push(a + (b << 7))\\n    }\\n    return -1\\n};\\n```\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n        q, grid[0][0] = [0], 1\\n        while len(q):\\n            curr = q.pop(0)\\n            i, j = curr & ((1 << 7) - 1), curr >> 7\\n            if i == n and j == n: return grid[n][n]\\n            for a in range(max(i-1,0),min(i+2,n+1)):\\n                for b in range(max(j-1,0),min(j+2,n+1)):\\n                    if grid[a][b] == 0:\\n                        grid[a][b] = grid[i][j] + 1\\n                        q.append(a + (b << 7))\\n        return -1\\n```\n```java\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        Queue<Integer> q = new ArrayDeque<Integer>();\\n        q.add(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.remove(), i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n                for (int b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.add(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523647,
                "title": "c-breadth-first-search",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct Pos {\\n        int row;\\n        int col;\\n        int dist;\\n    };\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        queue<Pos> q;\\n        q.push(Pos{0, 0, 1});\\n        \\n        while (!q.empty()) {\\n            Pos front = q.front(); q.pop();\\n            \\n            if (front.row >= n || front.row < 0 ||\\n                front.col >= n || front.col < 0 ||\\n                grid[front.row][front.col] == 1) {\\n                continue;\\n            } else if (front.row == n-1 && front.col == n-1) {\\n                return front.dist;\\n            }\\n            \\n            q.push(Pos{front.row+1, front.col, front.dist+1});\\n            q.push(Pos{front.row+1, front.col+1, front.dist+1});\\n            q.push(Pos{front.row+1, front.col-1, front.dist+1});\\n            q.push(Pos{front.row, front.col+1, front.dist+1});\\n            q.push(Pos{front.row, front.col-1, front.dist+1});\\n            q.push(Pos{front.row-1, front.col, front.dist+1});\\n            q.push(Pos{front.row-1, front.col+1, front.dist+1});\\n            q.push(Pos{front.row-1, front.col-1, front.dist+1});\\n            \\n            grid[front.row][front.col] = 1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Pos {\\n        int row;\\n        int col;\\n        int dist;\\n    };\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        queue<Pos> q;\\n        q.push(Pos{0, 0, 1});\\n        \\n        while (!q.empty()) {\\n            Pos front = q.front(); q.pop();\\n            \\n            if (front.row >= n || front.row < 0 ||\\n                front.col >= n || front.col < 0 ||\\n                grid[front.row][front.col] == 1) {\\n                continue;\\n            } else if (front.row == n-1 && front.col == n-1) {\\n                return front.dist;\\n            }\\n            \\n            q.push(Pos{front.row+1, front.col, front.dist+1});\\n            q.push(Pos{front.row+1, front.col+1, front.dist+1});\\n            q.push(Pos{front.row+1, front.col-1, front.dist+1});\\n            q.push(Pos{front.row, front.col+1, front.dist+1});\\n            q.push(Pos{front.row, front.col-1, front.dist+1});\\n            q.push(Pos{front.row-1, front.col, front.dist+1});\\n            q.push(Pos{front.row-1, front.col+1, front.dist+1});\\n            q.push(Pos{front.row-1, front.col-1, front.dist+1});\\n            \\n            grid[front.row][front.col] = 1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405423,
                "title": "python-concise-bfs-memory-usage-better-than-100",
                "content": "Standard BFS using a queue. Use the original grid to store the seen elements.\\n```\\nclass Solution(object):\\n    def shortestPathBinaryMatrix(self, grid):\\n        if grid[0][0] or grid[-1][-1]:\\n            return -1\\n        queue = collections.deque([(0,0,1)])\\n        while queue:\\n            i, j, count = queue.popleft()\\n            if i == len(grid)-1 and j == len(grid[0])-1:\\n                return count\\n            for x, y in ((0,1), (0,-1), (1,0), (-1,0), (1,-1), (-1,1), (1,1), (-1,-1)):\\n                row, col = i + y, j + x\\n                if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and not grid[row][col]:\\n                    queue.append((row, col, count+1))\\n                    grid[row][col] = 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def shortestPathBinaryMatrix(self, grid):\\n        if grid[0][0] or grid[-1][-1]:\\n            return -1\\n        queue = collections.deque([(0,0,1)])\\n        while queue:\\n            i, j, count = queue.popleft()\\n            if i == len(grid)-1 and j == len(grid[0])-1:\\n                return count\\n            for x, y in ((0,1), (0,-1), (1,0), (-1,0), (1,-1), (-1,1), (1,1), (-1,-1)):\\n                row, col = i + y, j + x\\n                if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and not grid[row][col]:\\n                    queue.append((row, col, count+1))\\n                    grid[row][col] = 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338786,
                "title": "help-submission-fails-but-passes-same-test-case-when-passed-from-console",
                "content": "Hi Guys,\\n\\nI\\'m very stumped by this. Currently when I submit my code, it says I pass all but 3 test cases. The test case it currently says I fail on is this\\n\\n[[0,0,0,0,1,1,1,1,0],[0,1,1,0,0,0,0,1,0],[0,0,1,0,0,0,0,0,0],[1,1,0,0,1,0,0,1,1],[0,0,1,1,1,0,1,0,1],[0,1,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0],[0,1,0,1,1,0,0,0,0],[0,0,0,0,0,1,0,1,0]]\\n\\nIt claims that my submission outputs 12 when the expected answer is 11. However, when I copy that exact test case into my console and just run that specific test case, I get the right answer of 11. Anyone have any idea why this is happening?\\n\\n```\\nclass Solution {\\npublic:\\n    void pushNeighbors(queue<pair<int,int>> & bfs, int r, int c) {\\n        bfs.push(make_pair(r+1, c+1));\\n        bfs.push(make_pair(r, c+1));\\n        bfs.push(make_pair(r-1, c+1));\\n        bfs.push(make_pair(r+1, c));\\n        bfs.push(make_pair(r-1, c));\\n        bfs.push(make_pair(r+1, c-1));\\n        bfs.push(make_pair(r, c-1));\\n        bfs.push(make_pair(r-1, c-1));\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int len, ret = 1, k = grid.size(), visited[k][k] = {0}, r, c;\\n        if (grid[0][0] == 1 || grid[k-1][k-1] == 1) {\\n            return -1;\\n        }\\n        queue<pair<int,int>> bfs;\\n        bfs.push({0,0});\\n        while (!bfs.empty()) {\\n            len = bfs.size(); \\n            for (int i = 0; i < len; i++) {\\n                r = bfs.front().first;\\n                c = bfs.front().second;\\n                bfs.pop();\\n                if (r < 0 || r >= k || c < 0 || c >= k || visited[r][c] == 1) \\n                    continue;\\n                if (r == k-1 && c == k-1)\\n                    return ret;\\n                visited[r][c] = 1;\\n                if(grid[r][c] == 0)\\n                    pushNeighbors(bfs, r, c);\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void pushNeighbors(queue<pair<int,int>> & bfs, int r, int c) {\\n        bfs.push(make_pair(r+1, c+1));\\n        bfs.push(make_pair(r, c+1));\\n        bfs.push(make_pair(r-1, c+1));\\n        bfs.push(make_pair(r+1, c));\\n        bfs.push(make_pair(r-1, c));\\n        bfs.push(make_pair(r+1, c-1));\\n        bfs.push(make_pair(r, c-1));\\n        bfs.push(make_pair(r-1, c-1));\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int len, ret = 1, k = grid.size(), visited[k][k] = {0}, r, c;\\n        if (grid[0][0] == 1 || grid[k-1][k-1] == 1) {\\n            return -1;\\n        }\\n        queue<pair<int,int>> bfs;\\n        bfs.push({0,0});\\n        while (!bfs.empty()) {\\n            len = bfs.size(); \\n            for (int i = 0; i < len; i++) {\\n                r = bfs.front().first;\\n                c = bfs.front().second;\\n                bfs.pop();\\n                if (r < 0 || r >= k || c < 0 || c >= k || visited[r][c] == 1) \\n                    continue;\\n                if (r == k-1 && c == k-1)\\n                    return ret;\\n                visited[r][c] = 1;\\n                if(grid[r][c] == 0)\\n                    pushNeighbors(bfs, r, c);\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586061,
                "title": "dfs-to-bfs-my-step-by-step-thoughts-and-why-dfs-with-memoization-dynamic-programming-fails",
                "content": "# Intuition\\n\\n## First thought: DFS (Simple backtracking and keeping track of visited nodes)\\n- For someone  who hadn\\'t solved shortest path problems like this before, this will seem like a simple DFS/BFS backtracking problem with caching i.e DP.\\n- I choose to solve it using DFS, first coming up with a backtracking solution first, **which gave me TLE.**\\n- TC: O(8^n)\\n- SC: O(n^2) since the longest recursive stack length will be of the length which is of the magnitude equivalent to the entire grid size.\\n\\n```\\nclass Solution:\\n    dirns = []\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        self.dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        shortestPath = self.recurse(grid, 0,0)\\n\\n        return -1 if shortestPath == float(\\'inf\\') else shortestPath\\n\\n\\n    def recurse(self, A, i, j):\\n        n = len(A) #n x n array\\n        #base cases\\n        if i >= n or j >= n or i < 0 or j < 0 or A[i][j] == 1 or A[i][j] == -1: #out of bounds or no path exists or already visited in current route\\n            return float(\\'inf\\')\\n        \\n        if i == n-1 and j == n-1: #we are on the destination\\n            return 1 if A[i][j] == 0 else float(\\'inf\\')\\n\\n\\n        #recursive case - compute min distance from all 8 dirns\\n        A[i][j] = -1 #marking as already visited in the \\'currently active path\\'\\n        minDist = float(\\'inf\\')\\n        for dirn in self.dirns:\\n            nr = i + dirn[0]\\n            nc = j + dirn[1]\\n            minDist = min(minDist, self.recurse(A, nr, nc))\\n\\n        A[i][j] = 0 #it will always be zero since we have iterated through it\\n        return 1 + minDist\\n\\n```\\n\\n<br>\\n\\n## Second thought: Optimize DFS i.e use DP\\n\\n- I thought simply memoizing the solution would solve my problem, however **the memoized solution failed test cases**.\\n- Here\\'s the memoized solution (Dynamic Programming)\\n\\n```\\nclass Solution:\\n    dirns = []\\n    dp = []\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        #init dirns array and dp array\\n        n = len(grid)\\n        self.dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        self.dp = [[None for i in range(n)] for j in range(n)]\\n\\n        #compute shortest path\\n        shortestPath = self.recurse(grid, 0,0)\\n        return -1 if shortestPath == float(\\'inf\\') else shortestPath\\n\\n\\n    def recurse(self, A, i, j):\\n        n = len(A) #n x n array\\n        #base cases\\n        if i >= n or j >= n or i < 0 or j < 0 or A[i][j] == 1 or A[i][j] == -1: #out of bounds or no path exists or already visited in current route\\n            return float(\\'inf\\')\\n        \\n        if i == n-1 and j == n-1: #we are on the destination\\n            return 1 if A[i][j] == 0 else float(\\'inf\\')\\n\\n\\n        #recursive case - compute min distance from all 8 dirns\\n        if self.dp[i][j] == None:\\n            A[i][j] = -1 #marking as already visited in the \\'currently active path\\'\\n            minDist = float(\\'inf\\')\\n            for dirn in self.dirns:\\n                nr = i + dirn[0]\\n                nc = j + dirn[1]\\n                minDist = min(minDist, self.recurse(A, nr, nc))\\n\\n            A[i][j] = 0 #it will always be zero since we have iterated through it\\n            self.dp[i][j] = 1 + minDist\\n        \\n        return self.dp[i][j]\\n```\\n\\n## Third Thought: Why does DFS with memoization fail?\\n\\n- I printed out the DP memoization table which made me realize that **DFS with memoization will give you A path, but not THE shortest path for sure each time**\\n- Print out your memoization path for failed test cases to understand this completely.\\n- For eg. the test case below failed (shortest path 10 but result was 11) -> Attached below it is the DP table\\n\\n```\\nTest case:\\n[[0,0,1,0,0,0,0],\\n[0,1,0,0,0,0,1],\\n[0,0,1,0,1,0,0],\\n[0,0,0,1,1,1,0],\\n[1,0,0,1,1,0,0],\\n[1,1,1,1,1,0,1],\\n[0,0,1,0,0,0,0]]\\n\\nDP table:\\n[[11, inf, inf, 7, 7, inf, inf],\\n [10, inf, 8, 7, 6, 6, inf],\\n [10, 9, inf, inf, inf, 5, 5], \\n[10, 10, inf, inf, inf, inf, 4],\\n [inf, inf, inf, inf, inf, 3, 3], \\n[inf, inf, inf, inf, inf, 2, inf], \\n[None, None, inf, inf, inf, 2, None]]\\n\\n```\\n\\n\\n\\n\\n\\n# Correct Approach\\n## BFS (mark visited nodes + nodes currently in queue):\\n- Since BFS naturally branches out depth-first, we will definitively get the shortest path.\\n- Edge cases exist so code is kindof unclean.\\n- Mark [n-1][n-1]th node as \\'1\\' since it\\'s distance would be 1.\\n- Start with a queue of all valid nodes around [n-1][n-1] - for each node check all 8 sides and either \\n    - append unvisited nodes\\n    - ignore invalid nodes or nodes which are currently in the queue\\n    - compare minDistance with valid visit nodes distance\\n- Note: You must mark nodes currently in the queue to prevent them from re-insertion\\n\\n```\\nclass Solution:\\n    from collections import deque\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        #init constants\\n        A = grid\\n        dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        n = len(A)\\n\\n        #edge case\\n        if (A[0][0] == 1) or (A[n-1][n-1] == 1):\\n            return -1\\n\\n        #setting base distance for n-1,n-1\\n        A[n-1][n-1] = 1\\n\\n        #init queue\\n        queue = deque()\\n        if self.isBound(A, n - 1, n - 2) and A[n - 1][n - 2] == 0:\\n            queue.append([n-1, n-2])\\n        if self.isBound(A, n - 2, n - 1) and A[n - 2][n - 1] == 0:\\n            queue.append([n - 2, n - 1])\\n        if self.isBound(A, n - 2, n - 2) and A[n - 2][n - 2] == 0:\\n            queue.append([n - 2, n - 2])\\n\\n        while len(queue):\\n            #get current node and it\\'s min dist + append neigbours unvisited\\n            curNode = queue.popleft()\\n            r = curNode[0]\\n            c = curNode[1]\\n            minDist = float(\\'inf\\')\\n\\n            #iterate over all 8 neighbors\\n            for dirn in dirns:\\n                nr = r + dirn[0]\\n                nc = c + dirn[1]\\n                \\n                #edge case\\n                if nr == n-1 and nc == n-1:\\n                    minDist = A[nr][nc]\\n                \\n                #normal case\\n                elif self.isBound(A, nr, nc): #if within bounds\\n                    if A[nr][nc] == 0: #unvisited node\\n                        A[nr][nc] = -1\\n                        queue.append([nr, nc])\\n                    elif A[nr][nc] != 1 and A[nr][nc] != -1: #visited node, excluding those currently in queue \\n                        minDist = min(minDist, A[nr][nc])\\n            A[r][c] = minDist + 1\\n\\n        \\n        return A[0][0] if A[0][0] != 0 else -1\\n        \\n\\n\\n    def isBound(self, A, i, j):\\n        n = len(A)\\n        return i >= 0 and i < n and j >= 0 and j < n\\n\\n        \\n```\\n\\n\\n\\n# Complexity\\n- TC: O(n^2) - every node visited at most once\\n\\n\\n- SC: O(n^2) - max size of queue is of this magnitude\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    dirns = []\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        self.dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        shortestPath = self.recurse(grid, 0,0)\\n\\n        return -1 if shortestPath == float(\\'inf\\') else shortestPath\\n\\n\\n    def recurse(self, A, i, j):\\n        n = len(A) #n x n array\\n        #base cases\\n        if i >= n or j >= n or i < 0 or j < 0 or A[i][j] == 1 or A[i][j] == -1: #out of bounds or no path exists or already visited in current route\\n            return float(\\'inf\\')\\n        \\n        if i == n-1 and j == n-1: #we are on the destination\\n            return 1 if A[i][j] == 0 else float(\\'inf\\')\\n\\n\\n        #recursive case - compute min distance from all 8 dirns\\n        A[i][j] = -1 #marking as already visited in the \\'currently active path\\'\\n        minDist = float(\\'inf\\')\\n        for dirn in self.dirns:\\n            nr = i + dirn[0]\\n            nc = j + dirn[1]\\n            minDist = min(minDist, self.recurse(A, nr, nc))\\n\\n        A[i][j] = 0 #it will always be zero since we have iterated through it\\n        return 1 + minDist\\n\\n```\n```\\nclass Solution:\\n    dirns = []\\n    dp = []\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        #init dirns array and dp array\\n        n = len(grid)\\n        self.dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        self.dp = [[None for i in range(n)] for j in range(n)]\\n\\n        #compute shortest path\\n        shortestPath = self.recurse(grid, 0,0)\\n        return -1 if shortestPath == float(\\'inf\\') else shortestPath\\n\\n\\n    def recurse(self, A, i, j):\\n        n = len(A) #n x n array\\n        #base cases\\n        if i >= n or j >= n or i < 0 or j < 0 or A[i][j] == 1 or A[i][j] == -1: #out of bounds or no path exists or already visited in current route\\n            return float(\\'inf\\')\\n        \\n        if i == n-1 and j == n-1: #we are on the destination\\n            return 1 if A[i][j] == 0 else float(\\'inf\\')\\n\\n\\n        #recursive case - compute min distance from all 8 dirns\\n        if self.dp[i][j] == None:\\n            A[i][j] = -1 #marking as already visited in the \\'currently active path\\'\\n            minDist = float(\\'inf\\')\\n            for dirn in self.dirns:\\n                nr = i + dirn[0]\\n                nc = j + dirn[1]\\n                minDist = min(minDist, self.recurse(A, nr, nc))\\n\\n            A[i][j] = 0 #it will always be zero since we have iterated through it\\n            self.dp[i][j] = 1 + minDist\\n        \\n        return self.dp[i][j]\\n```\n```\\nTest case:\\n[[0,0,1,0,0,0,0],\\n[0,1,0,0,0,0,1],\\n[0,0,1,0,1,0,0],\\n[0,0,0,1,1,1,0],\\n[1,0,0,1,1,0,0],\\n[1,1,1,1,1,0,1],\\n[0,0,1,0,0,0,0]]\\n\\nDP table:\\n[[11, inf, inf, 7, 7, inf, inf],\\n [10, inf, 8, 7, 6, 6, inf],\\n [10, 9, inf, inf, inf, 5, 5], \\n[10, 10, inf, inf, inf, inf, 4],\\n [inf, inf, inf, inf, inf, 3, 3], \\n[inf, inf, inf, inf, inf, 2, inf], \\n[None, None, inf, inf, inf, 2, None]]\\n\\n```\n```\\nclass Solution:\\n    from collections import deque\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        #init constants\\n        A = grid\\n        dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        n = len(A)\\n\\n        #edge case\\n        if (A[0][0] == 1) or (A[n-1][n-1] == 1):\\n            return -1\\n\\n        #setting base distance for n-1,n-1\\n        A[n-1][n-1] = 1\\n\\n        #init queue\\n        queue = deque()\\n        if self.isBound(A, n - 1, n - 2) and A[n - 1][n - 2] == 0:\\n            queue.append([n-1, n-2])\\n        if self.isBound(A, n - 2, n - 1) and A[n - 2][n - 1] == 0:\\n            queue.append([n - 2, n - 1])\\n        if self.isBound(A, n - 2, n - 2) and A[n - 2][n - 2] == 0:\\n            queue.append([n - 2, n - 2])\\n\\n        while len(queue):\\n            #get current node and it\\'s min dist + append neigbours unvisited\\n            curNode = queue.popleft()\\n            r = curNode[0]\\n            c = curNode[1]\\n            minDist = float(\\'inf\\')\\n\\n            #iterate over all 8 neighbors\\n            for dirn in dirns:\\n                nr = r + dirn[0]\\n                nc = c + dirn[1]\\n                \\n                #edge case\\n                if nr == n-1 and nc == n-1:\\n                    minDist = A[nr][nc]\\n                \\n                #normal case\\n                elif self.isBound(A, nr, nc): #if within bounds\\n                    if A[nr][nc] == 0: #unvisited node\\n                        A[nr][nc] = -1\\n                        queue.append([nr, nc])\\n                    elif A[nr][nc] != 1 and A[nr][nc] != -1: #visited node, excluding those currently in queue \\n                        minDist = min(minDist, A[nr][nc])\\n            A[r][c] = minDist + 1\\n\\n        \\n        return A[0][0] if A[0][0] != 0 else -1\\n        \\n\\n\\n    def isBound(self, A, i, j):\\n        n = len(A)\\n        return i >= 0 and i < n and j >= 0 and j < n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585355,
                "title": "c-easy-solution-using-bfs-approach-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The intuition behind the code is to use a BFS algorithm to explore the binary matrix. The BFS algorithm starts at the top-left corner of the matrix and explores all of its neighbors. If a neighbor is the destination node, then the algorithm returns the distance from the source node to the destination node. Otherwise, the algorithm adds the neighbor to the queue and repeats the process. The algorithm terminates when the queue is empty.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a queue and add the top-left corner of the matrix to the queue.\\n- While the queue is not empty:\\n1) Remove the first element from the queue and let it be the current node.\\n2) If the current node is the destination node, then return the distance from the source node to the destination node.\\n3) For each neighbor of the current node:\\n--> If the neighbor is not visited, then add the neighbor to the queue and mark it as visited.\\n- Return -1 if the destination node is not reachable.\\n# Complexity\\n- Time complexity: $$O(N*M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs{{1,1},{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{-1,1},{1,-1}};\\n    \\n    bool isValid(int& x, int& y, int n, int m){\\n        if(x>=0 && x<n && y>=0 && y<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(n==0 || m==0 || grid[0][0] != 0){\\n            return -1;\\n        }\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        grid[0][0] = 1;\\n\\n        int step = 1;\\n        while(!q.empty()){\\n            int N = q.size();\\n            \\n            while(N--){\\n                auto curr = q.front();\\n                q.pop();\\n\\n                int x = curr.first;\\n                int y = curr.second;\\n\\n                if(x == n-1 && y == m-1){\\n                    return step;\\n                }\\n\\n                for(auto dir : dirs){\\n                    int dx = x + dir[0];\\n                    int dy = y + dir[1];\\n\\n                    if(isValid(dx,dy,n,m) && grid[dx][dy] == 0){\\n                        q.push({dx,dy});\\n                        grid[dx][dy] = 1;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/5f6bb6db-09f4-4851-8cae-8532bafd97e1_1685610542.5999708.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs{{1,1},{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{-1,1},{1,-1}};\\n    \\n    bool isValid(int& x, int& y, int n, int m){\\n        if(x>=0 && x<n && y>=0 && y<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(n==0 || m==0 || grid[0][0] != 0){\\n            return -1;\\n        }\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        grid[0][0] = 1;\\n\\n        int step = 1;\\n        while(!q.empty()){\\n            int N = q.size();\\n            \\n            while(N--){\\n                auto curr = q.front();\\n                q.pop();\\n\\n                int x = curr.first;\\n                int y = curr.second;\\n\\n                if(x == n-1 && y == m-1){\\n                    return step;\\n                }\\n\\n                for(auto dir : dirs){\\n                    int dx = x + dir[0];\\n                    int dy = y + dir[1];\\n\\n                    if(isValid(dx,dy,n,m) && grid[dx][dy] == 0){\\n                        q.push({dx,dy});\\n                        grid[dx][dy] = 1;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585294,
                "title": "c-solution-bfs",
                "content": "**Algorithm**\\n1. simple bfs \\n2. 8 -way traversal using 2- loops (from -1 to 1)\\n3. manipulating the grid itself after the traversal (so that it can\\'t be traversed again)\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] or grid[grid.size()-1][grid[0].size()-1]==1) return -1;\\n        if(grid.size()==1) return 1;\\n        \\n        int dist=1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto [i , j] = q.front();\\n                q.pop();\\n                if(i==grid.size()-1 and j==grid[0].size()-1){\\n                    return dist;\\n                }\\n                for(int k=-1;k<=1;k++){\\n                    for(int l=-1;l<=1;l++){\\n                        int x = i+k;\\n                        int y=  j+l;\\n                        if(x<0 or x>=grid.size() or y<0 or y>= grid[0].size() or grid[x][y]==1)continue;\\n                        q.push({x,y});\\n                        grid[x][y] = 1;\\n                    }\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] or grid[grid.size()-1][grid[0].size()-1]==1) return -1;\\n        if(grid.size()==1) return 1;\\n        \\n        int dist=1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto [i , j] = q.front();\\n                q.pop();\\n                if(i==grid.size()-1 and j==grid[0].size()-1){\\n                    return dist;\\n                }\\n                for(int k=-1;k<=1;k++){\\n                    for(int l=-1;l<=1;l++){\\n                        int x = i+k;\\n                        int y=  j+l;\\n                        if(x<0 or x>=grid.size() or y<0 or y>= grid[0].size() or grid[x][y]==1)continue;\\n                        q.push({x,y});\\n                        grid[x][y] = 1;\\n                    }\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584707,
                "title": "bfs-c-straight-to-the-point-very-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        queue<pair<int,pair<int,int>>>qu;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        if(grid[0][0] == 1) return -1;\\n        qu.push({0,{0,1}});\\n        int mins = INT_MAX;\\n        visited[0][0] = 1;\\n        while(!qu.empty()){\\n            int r = qu.front().first,c = qu.front().second.first,takentime = qu.front().second.second;\\n            qu.pop();\\n            if(r == m-1 && c==n-1){\\n                mins = min(mins,takentime);\\n                continue;\\n            }\\n            for(int i=-1;i<=1;i++){\\n                for(int z=-1;z<=1;z++){\\n                    int row = r+z,col = c+i;\\n                    if(row == r && col == c) continue;\\n                    else if(row >=0 && row < m && col >= 0 && col<n && grid[row][col] == 0 && !visited[row][col] ){\\n                         visited[row][col] =1;\\n                        qu.push({row,{col,takentime+1}});\\n                    }\\n                }\\n            }\\n        }\\n        return mins == INT_MAX?-1:mins;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        queue<pair<int,pair<int,int>>>qu;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        if(grid[0][0] == 1) return -1;\\n        qu.push({0,{0,1}});\\n        int mins = INT_MAX;\\n        visited[0][0] = 1;\\n        while(!qu.empty()){\\n            int r = qu.front().first,c = qu.front().second.first,takentime = qu.front().second.second;\\n            qu.pop();\\n            if(r == m-1 && c==n-1){\\n                mins = min(mins,takentime);\\n                continue;\\n            }\\n            for(int i=-1;i<=1;i++){\\n                for(int z=-1;z<=1;z++){\\n                    int row = r+z,col = c+i;\\n                    if(row == r && col == c) continue;\\n                    else if(row >=0 && row < m && col >= 0 && col<n && grid[row][col] == 0 && !visited[row][col] ){\\n                         visited[row][col] =1;\\n                        qu.push({row,{col,takentime+1}});\\n                    }\\n                }\\n            }\\n        }\\n        return mins == INT_MAX?-1:mins;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584590,
                "title": "java-bfs-complete-explanation-with-images",
                "content": "# Intuition\\nIt is simple breadth first search (BFS) traversal of the matrix.\\n\\nBFS is chosen over depth-first search (DFS) because `DFS may not guarantee finding the shortest path in certain scenarios.`\\n\\nTo illustrate this, let\\'s consider an example. Suppose we have the following binary matrix:\\n\\n<img src = \"https://assets.leetcode.com/users/images/0df0223a-d89f-4b5c-8557-602cd32235ce_1685593391.510974.png\" height=\"500px\" width=\"500px\"></img>\\n\\nDFS may take the following path to reach the destination first.\\n\\n<img src = \"https://assets.leetcode.com/users/images/47f4b121-62b9-481b-8201-f2a8958892e3_1685593347.8459778.png\" height=\"500px\" width=\"500px\"></img>\\n\\nNow, all the nodes in the above path will be marked as visited.\\n\\n<img src = \"https://assets.leetcode.com/users/images/9099e570-1a54-48f3-b8eb-fa3795f71349_1685594258.6301134.png\" height=\"500px\" width=\"500px\"></img>\\n\\n\\nThis results in the other paths passing through these nodes to be ignored. Hence the actual shortest path is ignored.\\n\\n<img src = \"https://assets.leetcode.com/users/images/61c1084a-68ec-4310-9080-9505701a2dcf_1685594331.9876206.png\" height=\"500px\" width=\"500px\"></img>\\n\\nOn the other hand, BFS systematically visits all neighboring cells at the current distance level before moving to the next distance level. This way, it guarantees finding the shortest path if one exists.\\n\\n# Approach\\nIt starts at the source cell `(0,0)` and performs a `BFS traversal`, exploring all reachable neighboring cells which are `0`. It marks the current cell as visited and adds all the unvisited neighbouring `0` cells in the queue.\\n\\nThe process continues until either the bottom-right cell is reached or the queue is empty. If the destination is reached, the distance of that cell is returned as the `length of the shortest path`. Otherwise, if the destination is not reachable, `-1` is returned.\\n\\n# Complexity\\n- Time complexity: $$O(N \\\\times M)$$ \\n\\n- Space complexity: $$O(N \\\\times M)$$ for the queue used for BFS.\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n\\n        if (grid[0][0]==1){\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0,1});\\n        grid[0][0]=1;\\n        int ct = 0;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.remove();\\n            int i = cur[0];\\n            int j = cur[1];\\n            int ans = cur[2];\\n            if(j==grid[0].length-1 && i==grid.length-1)return ans;\\n            for(int x = -1; x <= 1;x ++) {\\n                for(int y = -1; y <= 1; y ++){\\n                    if(i+x<0 || j+y<0){\\n                        continue;\\n                    }\\n                    if(i+x==grid[0].length || j+y==grid[0].length){\\n                        continue;\\n                    }\\n                    if(grid[i+x][j+y]==0){\\n                        q.add(new int[]{i+x,j+y,ans+1});\\n                        grid[i+x][j+y]=1;\\n                        ct++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n\\n        if (grid[0][0]==1){\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0,1});\\n        grid[0][0]=1;\\n        int ct = 0;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.remove();\\n            int i = cur[0];\\n            int j = cur[1];\\n            int ans = cur[2];\\n            if(j==grid[0].length-1 && i==grid.length-1)return ans;\\n            for(int x = -1; x <= 1;x ++) {\\n                for(int y = -1; y <= 1; y ++){\\n                    if(i+x<0 || j+y<0){\\n                        continue;\\n                    }\\n                    if(i+x==grid[0].length || j+y==grid[0].length){\\n                        continue;\\n                    }\\n                    if(grid[i+x][j+y]==0){\\n                        q.add(new int[]{i+x,j+y,ans+1});\\n                        grid[i+x][j+y]=1;\\n                        ct++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584180,
                "title": "o-n-2-c-bfs-approach-detailed-explanation-with-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe BFS algorithm is used to explore the grid and find the shortest path from the starting cell to the target cell. It visits cells in a breadth-first manner, i.e., it explores all the neighbors of a cell before moving on to the next level of cells.\\n\\nThe dist matrix is used to store the minimum distance to reach each cell from the starting cell. It is initialized with -1 to indicate that no path has been found yet.\\n\\nBy enqueueing the starting cell (0, 0) with a distance of 1, the BFS algorithm starts exploring the grid from the top-left cell.\\nThe BFS algorithm iteratively visits the cells, updates their distances in the dist matrix, and enqueues their valid neighbors until it reaches the target cell (n-1, n-1) or there are no more reachable cells.\\n\\nIf the distance to the target cell remains -1 after the BFS traversal, it means that there is no valid path from the starting cell to the target cell, so -1 is returned.\\n\\nOtherwise, the distance stored in dist[n-1][n-1] represents the shortest path length from the starting cell to the target cell, which is returned as the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnitialize a dist matrix of the same size as the input grid. Each cell in the dist matrix will store the minimum distance required to reach that cell from the starting cell (0, 0). Initially, all distances are set to -1 to indicate that no path has been found yet.\\n\\nCreate a queue q1 to perform BFS. Enqueue the starting cell (0, 0) into q1 and set its distance as 1 in the dist matrix.\\n\\nWhile the queue is not empty, perform the following steps:\\n\\nDequeue a cell (i, j) from q1.\\nExplore all eight possible neighbors of the current cell in the grid.\\nIf a neighbor cell is valid (within grid boundaries and empty) and its distance is still -1, update its distance in the dist matrix as dist[i][j] + 1 and enqueue the neighbor cell into q1. This step ensures that each cell is visited only once and the distance to reach it is minimized.\\n\\nAfter the BFS traversal, if the distance to the bottom-right cell (n-1, n-1) is still -1, it means no path was found, so return -1. Otherwise, return the distance stored in dist[n-1][n-1], which represents the shortest path length from (0, 0) to (n-1, n-1).\\n\\n# Complexity\\n- Time Complexity:\\nThe code uses a Breadth-First Search (BFS) algorithm to explore the grid. In the worst case, every cell in the grid needs to be visited. Since each cell is visited only once, the time complexity is O(n^2), where n is the size of the grid.\\n\\nSpace Complexity:\\nThe space complexity is determined by the additional data structures used in the code.\\n\\nThe dist matrix has a size of n x n, requiring O(n^2) space.\\nThe q1 queue can store at most n^2 elements in the worst case, as all cells of the grid are enqueued. Therefore, it also requires O(n^2) space.\\nHence, the overall space complexity is O(n^2).\\n\\nIn summary, the time complexity is O(n^2) and the space complexity is O(n^2).\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    \\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        if(i>=0 && j>=0 && i<n && j<n && grid[i][j] == 0) return true;\\n        else return false;\\n    }\\n    \\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        n = grid[0].size();\\n        vector<vector<int>> dist(n, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q1;\\n        \\n        if(grid[0][0] == 0){\\n            q1.push({0, 0});\\n            dist[0][0] = 1;\\n        }\\n        else return -1;\\n        \\n        vector<int> x = {-1, +1, 0, 0, -1, +1, -1, +1};\\n        vector<int> y = {0, 0, -1, +1, -1, +1, +1, -1};\\n        \\n        while(!q1.empty()){\\n            pair<int, int> curr = q1.front();\\n            q1.pop();\\n            \\n            for(int k=0; k<8; k++){\\n                int newX = curr.first + x[k];\\n                int newY = curr.second + y[k];\\n                \\n                if(isValid(newX, newY, grid) && dist[newX][newY]==-1){\\n                    dist[newX][newY] = dist[curr.first][curr.second]+1;\\n                    q1.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        if(dist[n-1][n-1] == -1)\\n            return -1;\\n        \\n        return dist[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    \\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        if(i>=0 && j>=0 && i<n && j<n && grid[i][j] == 0) return true;\\n        else return false;\\n    }\\n    \\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        n = grid[0].size();\\n        vector<vector<int>> dist(n, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q1;\\n        \\n        if(grid[0][0] == 0){\\n            q1.push({0, 0});\\n            dist[0][0] = 1;\\n        }\\n        else return -1;\\n        \\n        vector<int> x = {-1, +1, 0, 0, -1, +1, -1, +1};\\n        vector<int> y = {0, 0, -1, +1, -1, +1, +1, -1};\\n        \\n        while(!q1.empty()){\\n            pair<int, int> curr = q1.front();\\n            q1.pop();\\n            \\n            for(int k=0; k<8; k++){\\n                int newX = curr.first + x[k];\\n                int newY = curr.second + y[k];\\n                \\n                if(isValid(newX, newY, grid) && dist[newX][newY]==-1){\\n                    dist[newX][newY] = dist[curr.first][curr.second]+1;\\n                    q1.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        if(dist[n-1][n-1] == -1)\\n            return -1;\\n        \\n        return dist[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584112,
                "title": "swift-bfs",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        guard grid[0][0] == 0 else { return -1 }\\n        let deltas = [[-1, -1], [-1, 1], [1,-1], [1,1], [-1,0], [1,0], [0,1], [0,-1]]\\n        var bfs = [[0,0]], pathSize = 1, grid = grid\\n        while !bfs.isEmpty {\\n            guard !bfs.contains([grid.count-1, grid.count-1]) else { return pathSize }\\n            bfs = bfs.flatMap { node in\\n                deltas.compactMap { delta in\\n                    let (x, y) = (node[0] + delta[0], node[1] + delta[1])\\n                    guard grid.indices ~= x && grid.indices ~= y && grid[y][x] == 0 else { return nil }\\n                    grid[y][x] = 1\\n                    return [x,y]\\n                }\\n            }\\n            pathSize += 1\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        guard grid[0][0] == 0 else { return -1 }\\n        let deltas = [[-1, -1], [-1, 1], [1,-1], [1,1], [-1,0], [1,0], [0,1], [0,-1]]\\n        var bfs = [[0,0]], pathSize = 1, grid = grid\\n        while !bfs.isEmpty {\\n            guard !bfs.contains([grid.count-1, grid.count-1]) else { return pathSize }\\n            bfs = bfs.flatMap { node in\\n                deltas.compactMap { delta in\\n                    let (x, y) = (node[0] + delta[0], node[1] + delta[1])\\n                    guard grid.indices ~= x && grid.indices ~= y && grid[y][x] == 0 else { return nil }\\n                    grid[y][x] = 1\\n                    return [x,y]\\n                }\\n            }\\n            pathSize += 1\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584054,
                "title": "easy-python-solution-using-bfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        vis=[[0]*n for _ in range(m)]\\n        if grid[0][0]==1:\\n            return -1\\n        queue=[(0,0,1)]\\n        vis[0][0]=1\\n        while queue:\\n            x,y,d=queue.pop(0)\\n            if x==m-1 and y==n-1:\\n                return d\\n            # print(x,y,d)\\n            for i in range(-1,2):\\n                for j in range(-1,2):\\n                    if 0<=x+i<m and 0<=y+j<n:\\n                        if vis[x+i][y+j]==0 and grid[x+i][y+j]==0:\\n                            queue.append((x+i,y+j,d+1))\\n                            vis[x+i][y+j]=1\\n        return -1\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        vis=[[0]*n for _ in range(m)]\\n        if grid[0][0]==1:\\n            return -1\\n        queue=[(0,0,1)]\\n        vis[0][0]=1\\n        while queue:\\n            x,y,d=queue.pop(0)\\n            if x==m-1 and y==n-1:\\n                return d\\n            # print(x,y,d)\\n            for i in range(-1,2):\\n                for j in range(-1,2):\\n                    if 0<=x+i<m and 0<=y+j<n:\\n                        if vis[x+i][y+j]==0 and grid[x+i][y+j]==0:\\n                            queue.append((x+i,y+j,d+1))\\n                            vis[x+i][y+j]=1\\n        return -1\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488767,
                "title": "c-dfs-bfs-solutions-t-c-o-n-2-s-c-o-n-2",
                "content": "```\\nclass Solution\\n{\\n\\n    /*\\n        Brute Force - Using DFS\\n        Time Complexity = O(7^(n^2))\\n        Space Complexity = O(n^2)\\n    */\\n\\nprivate:\\n    int n;\\n    int res = INT_MAX;\\n\\n    vector<pair<int, int>> dirc = {{+1, 0}, {-1, 0}, {0, +1}, {0, -1}, {-1, -1}, {-1, +1}, {+1, -1}, {+1, +1}};\\n\\n    bool isSafe(int i, int j, vector<vector<int>> &grid)\\n    {\\n        return i >= 0 and i < n and j >= 0 and j < n and grid[i][j] == 0;\\n    }\\n\\n    void helper(int i, int j, int cellsVisited, vector<vector<int>> &grid)\\n    {\\n        if (i == n - 1 and j == n - 1)\\n        {\\n            res = min(res, cellsVisited);\\n            return;\\n        }\\n\\n        grid[i][j] = 2;\\n\\n        for (auto dir : dirc)\\n        {\\n            int newX = i + dir.first;\\n            int newY = j + dir.second;\\n\\n            if (isSafe(newX, newY, grid))\\n            {\\n                helper(newX, newY, cellsVisited + 1, grid);\\n            }\\n        }\\n\\n        grid[i][j] = 0;\\n    }\\n\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid)\\n    {\\n        n = grid.size();\\n\\n        if (grid[0][0] || grid[n - 1][n - 1])\\n            return -1;\\n\\n        // i, j, cellsVisited, grid\\n        helper(0, 0, 1, grid);\\n\\n        if (res == INT_MAX)\\n            return -1;\\n\\n        return res;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\n    \\n    /*\\n        Optimal Solution - Using BFS\\n        Time Complexity = O(n^2)\\n        Space Complexity = O(n^2)\\n    */\\n    \\nprivate:\\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        return i>=0 and i<grid.size() and j>=0 and j<grid.size() and grid[i][j]==0;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0]) return -1;\\n        \\n        int res;\\n        \\n        queue<pair<int, int>> q1;\\n        q1.push({0, 0});\\n        grid[0][0] = 2;\\n        \\n        int n = grid.size();\\n        \\n        vector<pair<int, int>> dirc = {{+1, 0}, {-1, 0}, {0, +1}, {0, -1},\\n                                       {-1, -1}, {+1, -1}, {-1, +1}, {+1, +1}};\\n        \\n        while(!q1.empty()){\\n            int size = q1.size();\\n            res++;\\n            \\n            while(size--){\\n                int i = q1.front().first;\\n                int j = q1.front().second;\\n                q1.pop();\\n\\n                if(i==n-1 and j==n-1) return res;\\n\\n                for(auto dir : dirc){\\n                    int newX = i+dir.first;\\n                    int newY = j+dir.second;\\n                    \\n                    if(isValid(newX, newY, grid)){\\n                        grid[newX][newY] = 2;\\n                        q1.push({newX, newY});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /*\\n        Brute Force - Using DFS\\n        Time Complexity = O(7^(n^2))\\n        Space Complexity = O(n^2)\\n    */\\n\\nprivate:\\n    int n;\\n    int res = INT_MAX;\\n\\n    vector<pair<int, int>> dirc = {{+1, 0}, {-1, 0}, {0, +1}, {0, -1}, {-1, -1}, {-1, +1}, {+1, -1}, {+1, +1}};\\n\\n    bool isSafe(int i, int j, vector<vector<int>> &grid)\\n    {\\n        return i >= 0 and i < n and j >= 0 and j < n and grid[i][j] == 0;\\n    }\\n\\n    void helper(int i, int j, int cellsVisited, vector<vector<int>> &grid)\\n    {\\n        if (i == n - 1 and j == n - 1)\\n        {\\n            res = min(res, cellsVisited);\\n            return;\\n        }\\n\\n        grid[i][j] = 2;\\n\\n        for (auto dir : dirc)\\n        {\\n            int newX = i + dir.first;\\n            int newY = j + dir.second;\\n\\n            if (isSafe(newX, newY, grid))\\n            {\\n                helper(newX, newY, cellsVisited + 1, grid);\\n            }\\n        }\\n\\n        grid[i][j] = 0;\\n    }\\n\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid)\\n    {\\n        n = grid.size();\\n\\n        if (grid[0][0] || grid[n - 1][n - 1])\\n            return -1;\\n\\n        // i, j, cellsVisited, grid\\n        helper(0, 0, 1, grid);\\n\\n        if (res == INT_MAX)\\n            return -1;\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    /*\\n        Optimal Solution - Using BFS\\n        Time Complexity = O(n^2)\\n        Space Complexity = O(n^2)\\n    */\\n    \\nprivate:\\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        return i>=0 and i<grid.size() and j>=0 and j<grid.size() and grid[i][j]==0;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0]) return -1;\\n        \\n        int res;\\n        \\n        queue<pair<int, int>> q1;\\n        q1.push({0, 0});\\n        grid[0][0] = 2;\\n        \\n        int n = grid.size();\\n        \\n        vector<pair<int, int>> dirc = {{+1, 0}, {-1, 0}, {0, +1}, {0, -1},\\n                                       {-1, -1}, {+1, -1}, {-1, +1}, {+1, +1}};\\n        \\n        while(!q1.empty()){\\n            int size = q1.size();\\n            res++;\\n            \\n            while(size--){\\n                int i = q1.front().first;\\n                int j = q1.front().second;\\n                q1.pop();\\n\\n                if(i==n-1 and j==n-1) return res;\\n\\n                for(auto dir : dirc){\\n                    int newX = i+dir.first;\\n                    int newY = j+dir.second;\\n                    \\n                    if(isValid(newX, newY, grid)){\\n                        grid[newX][newY] = 2;\\n                        q1.push({newX, newY});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218492,
                "title": "beat-97-99-c-easy-optimized-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n       int m= grid.size();\\n       int n= grid[0].size();\\n       vector<vector<int>>visited(m,vector<int>(n,0));\\n     \\n       queue<pair<pair<int,int>,int>>q;  ///queue< row, col, distance>\\n       if(grid[0][0]==1){\\n           return -1;\\n       }\\n       q.push({{0,0},1});\\n        visited[0][0]=1;\\n        int delrow[]= {-1, +1, 0, 0, -1, +1, -1, +1};\\n        int delcol[]= {0, 0, -1, +1, -1, +1, +1, -1};\\n        while(!q.empty()){\\n            auto it= q.front();\\n            q.pop();\\n            int row= it.first.first;\\n            int col= it.first.second;\\n            int distance= it.second;\\n            if(row==m-1 && col==n-1){\\n                return distance;\\n            }\\n            for(int i=0;i<8;i++){\\n                int nrow=row+delrow[i];\\n                int ncol=col+delcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && grid[nrow][ncol]==0 && !visited[nrow][ncol]){\\n                \\n                    grid[nrow][ncol]=1;\\n                        visited[nrow][ncol]=1;\\n                        q.push({{nrow,ncol},distance+1});\\n                }\\n            }\\n        }\\n\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n       int m= grid.size();\\n       int n= grid[0].size();\\n       vector<vector<int>>visited(m,vector<int>(n,0));\\n     \\n       queue<pair<pair<int,int>,int>>q;  ///queue< row, col, distance>\\n       if(grid[0][0]==1){\\n           return -1;\\n       }\\n       q.push({{0,0},1});\\n        visited[0][0]=1;\\n        int delrow[]= {-1, +1, 0, 0, -1, +1, -1, +1};\\n        int delcol[]= {0, 0, -1, +1, -1, +1, +1, -1};\\n        while(!q.empty()){\\n            auto it= q.front();\\n            q.pop();\\n            int row= it.first.first;\\n            int col= it.first.second;\\n            int distance= it.second;\\n            if(row==m-1 && col==n-1){\\n                return distance;\\n            }\\n            for(int i=0;i<8;i++){\\n                int nrow=row+delrow[i];\\n                int ncol=col+delcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && grid[nrow][ncol]==0 && !visited[nrow][ncol]){\\n                \\n                    grid[nrow][ncol]=1;\\n                        visited[nrow][ncol]=1;\\n                        q.push({{nrow,ncol},distance+1});\\n                }\\n            }\\n        }\\n\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140944,
                "title": "bfs-traversal-clean-code-with-comments-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //solving this question using BFS traversal\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(n==m && n==1){  //for the edge cases such as [[0]] && [[1]]\\n            if(grid[0][0]) return -1;\\n            return 1;\\n        }\\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0) return -1;\\n\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;  //to store grid location and dist simultaneously\\n        q.push({{0,0},1}); //src and initializing dist as 1\\n        vis[0][0]=1;\\n        int ans = INT_MAX;\\n\\n        int dRow[]= {-1,0,1,0,-1,-1,1,1};  //since it is 8 directional connected so all the cases etc. (-1,0),(0,-1)\\n        int dCol[] ={0,-1,0,1,-1,1,1,-1};\\n\\n        while(!q.empty()){\\n            int row = q.front().first.first;  \\n            int col = q.front().first.second;  //generating all the possible grid rows and colums\\n            int dist = q.front().second;\\n            q.pop();\\n            for(int i = 0;i<8;i++){\\n                int nxtRow = row + dRow[i];\\n                int nxtCol = col + dCol[i];\\n                if(nxtRow>=0 && nxtRow<n && nxtCol>=0 && nxtCol<m && !vis[nxtRow][nxtCol] && grid[nxtRow][nxtCol]==0)\\n                { //checking the boundaries and whether node is visited or not and if grid is already 0\\n                    vis[nxtRow][nxtCol]=1;\\n                    if(nxtRow==n-1 && nxtCol==m-1) return min(ans,dist+1); //the destination node\\n                    q.push({{nxtRow,nxtCol},dist+1}); //if the node is not the destination (n-1,m-1) then push it to to queue with increasing the distance\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //solving this question using BFS traversal\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(n==m && n==1){  //for the edge cases such as [[0]] && [[1]]\\n            if(grid[0][0]) return -1;\\n            return 1;\\n        }\\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0) return -1;\\n\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;  //to store grid location and dist simultaneously\\n        q.push({{0,0},1}); //src and initializing dist as 1\\n        vis[0][0]=1;\\n        int ans = INT_MAX;\\n\\n        int dRow[]= {-1,0,1,0,-1,-1,1,1};  //since it is 8 directional connected so all the cases etc. (-1,0),(0,-1)\\n        int dCol[] ={0,-1,0,1,-1,1,1,-1};\\n\\n        while(!q.empty()){\\n            int row = q.front().first.first;  \\n            int col = q.front().first.second;  //generating all the possible grid rows and colums\\n            int dist = q.front().second;\\n            q.pop();\\n            for(int i = 0;i<8;i++){\\n                int nxtRow = row + dRow[i];\\n                int nxtCol = col + dCol[i];\\n                if(nxtRow>=0 && nxtRow<n && nxtCol>=0 && nxtCol<m && !vis[nxtRow][nxtCol] && grid[nxtRow][nxtCol]==0)\\n                { //checking the boundaries and whether node is visited or not and if grid is already 0\\n                    vis[nxtRow][nxtCol]=1;\\n                    if(nxtRow==n-1 && nxtCol==m-1) return min(ans,dist+1); //the destination node\\n                    q.push({{nxtRow,nxtCol},dist+1}); //if the node is not the destination (n-1,m-1) then push it to to queue with increasing the distance\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087339,
                "title": "well-commented-bfs-queue",
                "content": "# Intuition\\nMentioned throughout code in form of $$comments$$\\n\\n# Approach\\nBreadth-First-Search by pushing coordinates in queue and then checking neighbours for desired conditions.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans =1;\\n        if (grid[0][0]==1 || grid[n-1][n-1]==1) { return -1; }\\n        queue<pair<int, int>> q;\\n            q.push({0,0});          //pushing the coordinates of \\'0\\' so that we can check in their 8 directions \\n            grid[0][0]=1;           //we will mark this visited by marking it \\'1\\'\\n        while (!q.empty()){\\n            int size = q.size();\\n            //considering it as a level itself and further looking in all directions           \\n            for (int k=0; k<size; k++){\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                grid[row][col]=1;\\n                // cout << row << \" \" << col << endl;\\n                q.pop();\\n                //returning when we have reached the destination\\n                if (row==n-1 && col==n-1){ \\n                    return ans;\\n                }\\n                //a loop to check in all the eight directions of the ones in queue \\n                //and marking them \\'1\\' to avoid repitition\\n                for (int i=row-1; i<row+2; i++){\\n                    for (int j=col-1; j<col+2; j++){\\n                        if (i>=0 && i<n && j>=0 && j<n && grid[i][j]==0){\\n                            q.push({i, j});\\n                            grid[i][j]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans ++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans =1;\\n        if (grid[0][0]==1 || grid[n-1][n-1]==1) { return -1; }\\n        queue<pair<int, int>> q;\\n            q.push({0,0});          //pushing the coordinates of \\'0\\' so that we can check in their 8 directions \\n            grid[0][0]=1;           //we will mark this visited by marking it \\'1\\'\\n        while (!q.empty()){\\n            int size = q.size();\\n            //considering it as a level itself and further looking in all directions           \\n            for (int k=0; k<size; k++){\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                grid[row][col]=1;\\n                // cout << row << \" \" << col << endl;\\n                q.pop();\\n                //returning when we have reached the destination\\n                if (row==n-1 && col==n-1){ \\n                    return ans;\\n                }\\n                //a loop to check in all the eight directions of the ones in queue \\n                //and marking them \\'1\\' to avoid repitition\\n                for (int i=row-1; i<row+2; i++){\\n                    for (int j=col-1; j<col+2; j++){\\n                        if (i>=0 && i<n && j>=0 && j<n && grid[i][j]==0){\\n                            q.push({i, j});\\n                            grid[i][j]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans ++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3031721,
                "title": "no-dijkstra-s-bfs-easy-explanation",
                "content": "# Intuition\\nIf we examine it closely, this question is just an extension of \"shortest path in an undirected graph with unit weights\".\\n\\n# Approach\\nHere we do not need to use a priority queue like in Dijkstra\\'s because all distances are unit weights. We will do simple BFS traversal in all 8 directions.\\n\\nI have use a queue of pairs of pair, which will store\\n{{row,col}, distance}. everytime we find a smaller distance we will update it and push it into the queue.\\n\\nIn the end if the distance is still infinity it means that the node is unreachable, else we can assume it is reachable and return the shortest distance.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0] || grid[n-1][n-1])\\n        return -1;\\n\\n        vector<vector<int>>dist(n,vector<int>(n,INT_MAX));\\n        dist[0][0]=0;\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{0,0},1});\\n\\n        int delrow[]={-1,0,1,0,-1,-1,1,1};\\n        int delcol[]={0,1,0,-1,-1,+1,-1,+1};\\n        while(!q.empty())\\n        {\\n            int row=q.front().first.first;\\n            int col=q.front().first.second;\\n            int dis=q.front().second;\\n            q.pop();\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=row+delrow[i];\\n                int ncol=col+delcol[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0&& ncol<n && \\n                !grid[nrow][ncol])\\n                {\\n                    if(dis+1<dist[nrow][ncol])\\n                    {\\n                        dist[nrow][ncol]=dis+1;\\n                        q.push({{nrow,ncol},dist[nrow][ncol]});\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(dist[n-1][n-1]==INT_MAX)\\n        return -1;\\n\\n        return dist[n-1][n-1];\\n\\n\\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0] || grid[n-1][n-1])\\n        return -1;\\n\\n        vector<vector<int>>dist(n,vector<int>(n,INT_MAX));\\n        dist[0][0]=0;\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{0,0},1});\\n\\n        int delrow[]={-1,0,1,0,-1,-1,1,1};\\n        int delcol[]={0,1,0,-1,-1,+1,-1,+1};\\n        while(!q.empty())\\n        {\\n            int row=q.front().first.first;\\n            int col=q.front().first.second;\\n            int dis=q.front().second;\\n            q.pop();\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=row+delrow[i];\\n                int ncol=col+delcol[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0&& ncol<n && \\n                !grid[nrow][ncol])\\n                {\\n                    if(dis+1<dist[nrow][ncol])\\n                    {\\n                        dist[nrow][ncol]=dis+1;\\n                        q.push({{nrow,ncol},dist[nrow][ncol]});\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(dist[n-1][n-1]==INT_MAX)\\n        return -1;\\n\\n        return dist[n-1][n-1];\\n\\n\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669984,
                "title": "simple-bfs-striver-approach",
                "content": "```\\nclass Solution {\\n    bool isValid(int row, int col, int n, int m) {\\n        return row >= 0 && row < n && col >= 0 && col < m;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n\\t\\n        if(grid[0][0] == 1) return -1;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t\\n        vector<vector<int> > distance(n, vector<int> (m, 1e9));\\n        distance[0][0] = 0;\\n        \\n        queue<pair<int, pair<int, int> > > q;\\n        q.push({1,{0, 0}});\\n        \\n        int delrow[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int delcol[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n        while(!q.empty()) {\\n            auto it = q.front();\\n            int dis = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            \\n            q.pop();\\n            \\n            if(row == n - 1 && col == m - 1) return dis;\\n            \\n            for(int k = 0; k < 8; k++) {\\n                int nrow = row + delrow[k];\\n                int ncol = col + delcol[k];\\n                \\n                if(isValid(nrow, ncol, n, m) && grid[nrow][ncol] == 0 && (dis + 1 < distance[nrow][ncol])) {\\n                    distance[nrow][ncol] = dis + 1;\\n                    q.push({dis + 1, {nrow, ncol}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool isValid(int row, int col, int n, int m) {\\n        return row >= 0 && row < n && col >= 0 && col < m;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n\\t\\n        if(grid[0][0] == 1) return -1;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t\\n        vector<vector<int> > distance(n, vector<int> (m, 1e9));\\n        distance[0][0] = 0;\\n        \\n        queue<pair<int, pair<int, int> > > q;\\n        q.push({1,{0, 0}});\\n        \\n        int delrow[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int delcol[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n        while(!q.empty()) {\\n            auto it = q.front();\\n            int dis = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            \\n            q.pop();\\n            \\n            if(row == n - 1 && col == m - 1) return dis;\\n            \\n            for(int k = 0; k < 8; k++) {\\n                int nrow = row + delrow[k];\\n                int ncol = col + delcol[k];\\n                \\n                if(isValid(nrow, ncol, n, m) && grid[nrow][ncol] == 0 && (dis + 1 < distance[nrow][ncol])) {\\n                    distance[nrow][ncol] = dis + 1;\\n                    q.push({dis + 1, {nrow, ncol}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045997,
                "title": "c-bfs-solution-easy-to-understand",
                "content": "```\\n//BFS solution\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        vector<vector<bool>> visited (n, vector<bool>(n, 0));\\n        queue<pair<int, int>> que;\\n        if(!grid[0][0])\\n        {\\n            que.push({0, 0});\\n            visited[0][0] = 1;\\n        }\\n        \\n        //BFS\\n        while(!que.empty())\\n        {\\n            int size = que.size();\\n            ans++;\\n            \\n            //iterate untill we cover all the nodes\\n            while(size--)\\n            {\\n                int i = que.front().first, j = que.front().second;\\n                que.pop();\\n                if(i==n-1 && j==n-1) return ans;\\n                \\n                //find 0 in all 8 directions\\n                for(int r=i-1; r<=i+1; r++)\\n                    {\\n                        for(int c=j-1; c<=j+1; c++)\\n                        {\\n                            if(isValid(r, c, n, grid, visited))\\n                            {\\n                                que.push({r, c});\\n                                visited[r][c] = 1;\\n                            }\\n                        }\\n                    }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    bool isValid(int r, int c, int n, vector<vector<int>>& grid, vector<vector<bool>> &visited){\\n        if(r<0 || c<0 || r>=n || c>=n || visited[r][c]==1 || grid[r][c]!=0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n//BFS solution\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        vector<vector<bool>> visited (n, vector<bool>(n, 0));\\n        queue<pair<int, int>> que;\\n        if(!grid[0][0])\\n        {\\n            que.push({0, 0});\\n            visited[0][0] = 1;\\n        }\\n        \\n        //BFS\\n        while(!que.empty())\\n        {\\n            int size = que.size();\\n            ans++;\\n            \\n            //iterate untill we cover all the nodes\\n            while(size--)\\n            {\\n                int i = que.front().first, j = que.front().second;\\n                que.pop();\\n                if(i==n-1 && j==n-1) return ans;\\n                \\n                //find 0 in all 8 directions\\n                for(int r=i-1; r<=i+1; r++)\\n                    {\\n                        for(int c=j-1; c<=j+1; c++)\\n                        {\\n                            if(isValid(r, c, n, grid, visited))\\n                            {\\n                                que.push({r, c});\\n                                visited[r][c] = 1;\\n                            }\\n                        }\\n                    }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    bool isValid(int r, int c, int n, vector<vector<int>>& grid, vector<vector<bool>> &visited){\\n        if(r<0 || c<0 || r>=n || c>=n || visited[r][c]==1 || grid[r][c]!=0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045236,
                "title": "c-bfs-explanation",
                "content": "Use BFS to solve this problem. \\nDefine the ```sturct _rc``` for ```queue<_rc>``` and for the 8 directions ```dir```.\\nRun the BFS and return current length of BFS when running algorithm arrive ```grid[n-1][n-1]```\\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    struct _rc{ int row; int col; };\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<_rc> currQ, nextQ;\\n        if(grid[0][0]++>0) return -1;\\n        currQ.push(_rc{0,0});\\n        int n = grid.size(), len = 1;        \\n        vector<_rc> dir = {        \\n            _rc{-1,-1},_rc{-1,+0},_rc{-1,+1},\\n            _rc{+0,-1},           _rc{+0,+1},\\n            _rc{+1,-1},_rc{+1,+0},_rc{+1,+1}\\n        };\\n        while(!currQ.empty()) {\\n            _rc rc = currQ.front();\\n            if(rc.row==n-1 && rc.col==n-1) return len;\\n            currQ.pop();\\n            for(auto& d : dir) {\\n                int row = rc.row+d.row, col = rc.col+d.col;\\n                if( row<0 || col<0 || row>=n || col>=n) continue;\\n                if(grid[row][col]++==0) nextQ.push(_rc{row,col});\\n            }\\n            if(currQ.empty()) { \\n                swap(currQ, nextQ);\\n                len++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```sturct _rc```\n```queue<_rc>```\n```dir```\n```grid[n-1][n-1]```\n```C++\\nclass Solution {\\npublic:\\n    struct _rc{ int row; int col; };\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<_rc> currQ, nextQ;\\n        if(grid[0][0]++>0) return -1;\\n        currQ.push(_rc{0,0});\\n        int n = grid.size(), len = 1;        \\n        vector<_rc> dir = {        \\n            _rc{-1,-1},_rc{-1,+0},_rc{-1,+1},\\n            _rc{+0,-1},           _rc{+0,+1},\\n            _rc{+1,-1},_rc{+1,+0},_rc{+1,+1}\\n        };\\n        while(!currQ.empty()) {\\n            _rc rc = currQ.front();\\n            if(rc.row==n-1 && rc.col==n-1) return len;\\n            currQ.pop();\\n            for(auto& d : dir) {\\n                int row = rc.row+d.row, col = rc.col+d.col;\\n                if( row<0 || col<0 || row>=n || col>=n) continue;\\n                if(grid[row][col]++==0) nextQ.push(_rc{row,col});\\n            }\\n            if(currQ.empty()) { \\n                swap(currQ, nextQ);\\n                len++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045196,
                "title": "python3-easy-to-understand-bfs-with-explanation",
                "content": "\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        dirs = [(0,1),(1,0),(1,1),(-1,-1),(-1,0),(0,-1),(-1,1),(1,-1)] # the 8 directions we are allowed for us to move\\n        \\n        if grid[0][0] != 0:\\n            return -1\\n        \\n        que = deque()\\n        que.append((0,0,1))\\n        step = float(\"inf\")\\n        grid[0][0] = 1 # mark (0,0) as visited so as to avoid visiting it again\\n        \\n        # now start iterative bfs\\n        while que:\\n            i,j,st = que.popleft()\\n            \\n            if (i,j) == (n-1,n-1): # we\\'ve reached the last index so... the step we toop must be minimum\\n                step = min(step, st)\\n                continue\\n            \\n            for i_add,j_add in dirs:\\n                new_i = i + i_add\\n                new_j = j + j_add\\n                # first check if the neightbours of (i,j) ar all valid\\n                # their validity is checked if (new_i,new_j) is a within the limits of \\n                # the grid and grid[new_i][new_j] must be 0, since we can only move trough the 0s\\n                \\n                if(0<= new_i< n and \\n                   0 <= new_j < n and \\n                   grid[new_i][new_j] == 0):\\n                    # add every valid neighbours to the que and mark them as visited to \\n                    # avoid visiting them again\\n                    que.append((new_i,new_j,st+1))\\n                    grid[new_i][new_j] = 1\\n        \\n        # if the step is changed from float(\"inf\") then we have reached the\\n        # last index somewere along our bfs\\n        return step if step != float(\"inf\") else -1",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        dirs = [(0,1),(1,0),(1,1),(-1,-1),(-1,0),(0,-1),(-1,1),(1,-1)] # the 8 directions we are allowed for us to move\\n        \\n        if grid[0][0] != 0:\\n            return -1\\n        \\n        que = deque()\\n        que.append((0,0,1))\\n        step = float(\"inf\")\\n        grid[0][0] = 1 # mark (0,0) as visited so as to avoid visiting it again\\n        \\n        # now start iterative bfs\\n        while que:\\n            i,j,st = que.popleft()\\n            \\n            if (i,j) == (n-1,n-1): # we\\'ve reached the last index so... the step we toop must be minimum\\n                step = min(step, st)\\n                continue\\n            \\n            for i_add,j_add in dirs:\\n                new_i = i + i_add\\n                new_j = j + j_add\\n                # first check if the neightbours of (i,j) ar all valid\\n                # their validity is checked if (new_i,new_j) is a within the limits of \\n                # the grid and grid[new_i][new_j] must be 0, since we can only move trough the 0s\\n                \\n                if(0<= new_i< n and \\n                   0 <= new_j < n and \\n                   grid[new_i][new_j] == 0):\\n                    # add every valid neighbours to the que and mark them as visited to \\n                    # avoid visiting them again\\n                    que.append((new_i,new_j,st+1))\\n                    grid[new_i][new_j] = 1\\n        \\n        # if the step is changed from float(\"inf\") then we have reached the\\n        # last index somewere along our bfs\\n        return step if step != float(\"inf\") else -1",
                "codeTag": "Python3"
            },
            {
                "id": 2044063,
                "title": "simple-bfs-readable-code",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int row;\\n        int col;\\n        int level;\\n        Pair(int row,int col,int level){\\n            this.row = row;\\n            this.col = col;\\n            this.level = level;\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid.length];\\n        int[][] dirs = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};\\n        \\n        Queue<Pair> Q = new ArrayDeque<>();\\n        if(grid[0][0] == 0) Q.add(new Pair(0,0,1));\\n        \\n        int shortestPath = Integer.MAX_VALUE;\\n        while(!Q.isEmpty()){\\n            Pair remove = Q.remove();\\n            int row = remove.row;\\n            int col = remove.col;\\n            int level = remove.level;\\n            if(row == grid.length-1 && col == grid.length-1){\\n                shortestPath = Math.min(shortestPath, level);\\n                continue;\\n            }\\n            for(int[] dir: dirs){\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(newRow>=0 \\n                   && newCol >= 0 \\n                   && newRow < grid.length \\n                   && newCol < grid.length \\n                   && !visited[ newRow][ newCol]\\n                   && grid[ newRow][ newCol] == 0)\\n                {\\n                    Q.add(new Pair(newRow, newCol, level+1));\\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        return (shortestPath == Integer.MAX_VALUE) ? -1: shortestPath;\\n    }\\n}\\n```\\nHappy LeetCoding",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int row;\\n        int col;\\n        int level;\\n        Pair(int row,int col,int level){\\n            this.row = row;\\n            this.col = col;\\n            this.level = level;\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid.length];\\n        int[][] dirs = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};\\n        \\n        Queue<Pair> Q = new ArrayDeque<>();\\n        if(grid[0][0] == 0) Q.add(new Pair(0,0,1));\\n        \\n        int shortestPath = Integer.MAX_VALUE;\\n        while(!Q.isEmpty()){\\n            Pair remove = Q.remove();\\n            int row = remove.row;\\n            int col = remove.col;\\n            int level = remove.level;\\n            if(row == grid.length-1 && col == grid.length-1){\\n                shortestPath = Math.min(shortestPath, level);\\n                continue;\\n            }\\n            for(int[] dir: dirs){\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(newRow>=0 \\n                   && newCol >= 0 \\n                   && newRow < grid.length \\n                   && newCol < grid.length \\n                   && !visited[ newRow][ newCol]\\n                   && grid[ newRow][ newCol] == 0)\\n                {\\n                    Q.add(new Pair(newRow, newCol, level+1));\\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        return (shortestPath == Integer.MAX_VALUE) ? -1: shortestPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043829,
                "title": "clean-and-fast-java-solution",
                "content": "At each `0` we need to check all `8` directions. If any of the `8` places is a `1` or already has been visited we do not need to visit it. \\n\\n**Trick for reducing space**: Mark visited nodes as `1` because if a point is already reached by some other path which takes less number of steps then why visit it again?\\n\\nI have created a `dir`(direction) array and a `isPointValid` functions as helpers\\n\\n```\\nclass Solution {\\n    private int[] dir = {-1,0,-1,-1,1,0,1,1,-1};\\n    private int n;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        this.n = grid.length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        if(grid[0][0] == 0) queue.offer(new int[]{0,0});\\n        grid[0][0] = 1;\\n        int steps = 1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                int[] cur_point = queue.poll();\\n                int x = cur_point[0];\\n                int y = cur_point[1];\\n                if(x == n-1 && y == n-1) return steps;\\n                for(int d=0;d<dir.length-1;d++){\\n                    int next_x = dir[d] + x;\\n                    int next_y = dir[d+1] + y;\\n                    if(isPointValid(next_x,next_y) && grid[next_x][next_y]==0){\\n                        queue.offer(new int[]{next_x,next_y});\\n                        grid[next_x][next_y] = 1;\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n    private boolean isPointValid(int i, int j){\\n        return i<n && j<n && i>=0 && j>=0;\\n    }\\n}\\n```\\nPlease Upvote if you like the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] dir = {-1,0,-1,-1,1,0,1,1,-1};\\n    private int n;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        this.n = grid.length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        if(grid[0][0] == 0) queue.offer(new int[]{0,0});\\n        grid[0][0] = 1;\\n        int steps = 1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                int[] cur_point = queue.poll();\\n                int x = cur_point[0];\\n                int y = cur_point[1];\\n                if(x == n-1 && y == n-1) return steps;\\n                for(int d=0;d<dir.length-1;d++){\\n                    int next_x = dir[d] + x;\\n                    int next_y = dir[d+1] + y;\\n                    if(isPointValid(next_x,next_y) && grid[next_x][next_y]==0){\\n                        queue.offer(new int[]{next_x,next_y});\\n                        grid[next_x][next_y] = 1;\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n    private boolean isPointValid(int i, int j){\\n        return i<n && j<n && i>=0 && j>=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043745,
                "title": "c-easy-understanding-clean-bfs",
                "content": "> BFS Algorithm:\\n\\n```\\n/*\\n   8 moves, if you are at i,j\\n   \\n\\ti-1,j-1    i-1,j    i-1,j+1\\n\\ti,j-1      i,j      i,j+1\\n\\ti+1,j+1    i+1,j    i+1,j+1\\n*/\\n```\\n\\n```\\nclass Solution {\\npublic:\\n // check that i and j will be inside the grid and is not visited already and have not value 1\\n    bool check(int i,int j,map<pair<int,int>,bool>& visited,vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i >= 0 && j >= 0 && i < n && j < m && grid[i][j] != 1 && (visited.find({i,j}) == visited.end())){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<vector<int>> Q;\\n        Q.push({0,0,0}); // i,j,dist\\n        map<pair<int,int>,bool> visited;\\n        visited[{0,0}] = true;\\n        while(!Q.empty()){\\n            auto curr = Q.front();Q.pop();\\n            int i = curr[0],j = curr[1],dist = curr[2];\\n            if(i == n-1 && j == m-1){\\n                return dist+1;\\n            }\\n            // left\\n            if(check(i,j-1,visited,grid)){\\n                visited[{i,j-1}] = true;\\n                Q.push({i,j-1,dist+1});\\n            }\\n            // right\\n            if(check(i,j+1,visited,grid)){\\n                visited[{i,j+1}] = true;\\n                Q.push({i,j+1,dist+1});\\n            }\\n            // up \\n            if(check(i-1,j,visited,grid)){\\n                visited[{i-1,j}] = true;\\n                Q.push({i-1,j,dist+1});\\n            }\\n            // down \\n            if(check(i+1,j,visited,grid)){\\n                visited[{i+1,j}] = true;\\n                Q.push({i+1,j,dist+1});\\n            }\\n            // leftUp\\n            if(check(i-1,j-1,visited,grid)){\\n                visited[{i-1,j-1}] = true;\\n                Q.push({i-1,j-1,dist+1});\\n            }\\n            // rightUp \\n            if(check(i-1,j+1,visited,grid)){\\n                visited[{i-1,j+1}] = true;\\n                Q.push({i-1,j+1,dist+1});\\n            }\\n            // leftDown \\n            if(check(i+1,j-1,visited,grid)){\\n                visited[{i+1,j-1}] = true;\\n                Q.push({i+1,j-1,dist+1});\\n            }\\n            // rightDown \\n            if(check(i+1,j+1,visited,grid)){\\n                visited[{i+1,j+1}] = true;\\n                Q.push({i+1,j+1,dist+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n   8 moves, if you are at i,j\\n   \\n\\ti-1,j-1    i-1,j    i-1,j+1\\n\\ti,j-1      i,j      i,j+1\\n\\ti+1,j+1    i+1,j    i+1,j+1\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n // check that i and j will be inside the grid and is not visited already and have not value 1\\n    bool check(int i,int j,map<pair<int,int>,bool>& visited,vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i >= 0 && j >= 0 && i < n && j < m && grid[i][j] != 1 && (visited.find({i,j}) == visited.end())){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<vector<int>> Q;\\n        Q.push({0,0,0}); // i,j,dist\\n        map<pair<int,int>,bool> visited;\\n        visited[{0,0}] = true;\\n        while(!Q.empty()){\\n            auto curr = Q.front();Q.pop();\\n            int i = curr[0],j = curr[1],dist = curr[2];\\n            if(i == n-1 && j == m-1){\\n                return dist+1;\\n            }\\n            // left\\n            if(check(i,j-1,visited,grid)){\\n                visited[{i,j-1}] = true;\\n                Q.push({i,j-1,dist+1});\\n            }\\n            // right\\n            if(check(i,j+1,visited,grid)){\\n                visited[{i,j+1}] = true;\\n                Q.push({i,j+1,dist+1});\\n            }\\n            // up \\n            if(check(i-1,j,visited,grid)){\\n                visited[{i-1,j}] = true;\\n                Q.push({i-1,j,dist+1});\\n            }\\n            // down \\n            if(check(i+1,j,visited,grid)){\\n                visited[{i+1,j}] = true;\\n                Q.push({i+1,j,dist+1});\\n            }\\n            // leftUp\\n            if(check(i-1,j-1,visited,grid)){\\n                visited[{i-1,j-1}] = true;\\n                Q.push({i-1,j-1,dist+1});\\n            }\\n            // rightUp \\n            if(check(i-1,j+1,visited,grid)){\\n                visited[{i-1,j+1}] = true;\\n                Q.push({i-1,j+1,dist+1});\\n            }\\n            // leftDown \\n            if(check(i+1,j-1,visited,grid)){\\n                visited[{i+1,j-1}] = true;\\n                Q.push({i+1,j-1,dist+1});\\n            }\\n            // rightDown \\n            if(check(i+1,j+1,visited,grid)){\\n                visited[{i+1,j+1}] = true;\\n                Q.push({i+1,j+1,dist+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043449,
                "title": "easy-and-neat-python-solution",
                "content": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n   \\n        visited = [[0 for _ in range(len(grid))] for _ in range(len(grid))]\\n        queue = deque()\\n        queue.append([0, 0, 1])\\n        \\n        while len(queue) > 0:\\n            x, y, currLength = queue.popleft()\\n            \\n            if x < 0 or x >= len(grid):\\n                continue\\n            if y < 0 or y >= len(grid):\\n                continue\\n            if visited[x][y] == 1:\\n                continue\\n            if grid[x][y] == 1:\\n                continue\\n            if x == len(grid) - 1 and y == len(grid) - 1:\\n                if grid[x][y] == 0:\\n                    return currLength\\n                continue\\n                \\n            visited[x][y] = 1\\n                \\n            for i in range(x-1, x+2):\\n                for j in range(y-1, y+2):\\n                    queue.append([i, j, currLength+1])\\n                    \\n        return -1\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n   \\n        visited = [[0 for _ in range(len(grid))] for _ in range(len(grid))]\\n        queue = deque()\\n        queue.append([0, 0, 1])\\n        \\n        while len(queue) > 0:\\n            x, y, currLength = queue.popleft()\\n            \\n            if x < 0 or x >= len(grid):\\n                continue\\n            if y < 0 or y >= len(grid):\\n                continue\\n            if visited[x][y] == 1:\\n                continue\\n            if grid[x][y] == 1:\\n                continue\\n            if x == len(grid) - 1 and y == len(grid) - 1:\\n                if grid[x][y] == 0:\\n                    return currLength\\n                continue\\n                \\n            visited[x][y] = 1\\n                \\n            for i in range(x-1, x+2):\\n                for j in range(y-1, y+2):\\n                    queue.append([i, j, currLength+1])\\n                    \\n        return -1\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997421,
                "title": "shouldn-t-be-the-bfs-space-complexity-o-m-n-instead-of-o-m-n",
                "content": "I found many answers state the space complexity of the BFS solution is O(MN), where M is rows and N is cols.\\nBut since we expand to neighbors while removing visited nodes, shouldn\\'t the max space complexity O(M+N)?\\nLet me know if I state anything wrong.\\n\\n```\\nclass Solution {\\npublic:\\n    // O(M * N), O(M + N)\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return -1;\\n        }\\n        int m = grid.size(), n = grid[0].size();        \\n        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        queue<pair<int, int>> qs;\\n        qs.push({0, 0});\\n        grid[0][0] = 1;\\n        int step = 1;\\n        while (!qs.empty()) {\\n            int sz = qs.size();\\n            while (sz--) {\\n                pair<int, int> f = qs.front();\\n                qs.pop();\\n                \\n                if (f.first == m - 1 && f.second == n - 1) {\\n                    return step;\\n                }\\n\\n                for (int i = -1; i <= 1; ++i) {\\n                    for (int j = -1; j <= 1; ++j) {\\n                        int newRow = f.first + i, newCol = f.second + j;\\n                        if ((i == 0 && j == 0) || newRow < 0 ||  newRow >= m\\n                            || newCol < 0 ||  newCol >= n || grid[newRow][newCol] == 1) {\\n                            continue;\\n                        }\\n                        qs.push({newRow, newCol});\\n                        grid[newRow][newCol] = 1;                        \\n                    }\\n                }\\n            }\\n            ++step;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(M * N), O(M + N)\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return -1;\\n        }\\n        int m = grid.size(), n = grid[0].size();        \\n        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        queue<pair<int, int>> qs;\\n        qs.push({0, 0});\\n        grid[0][0] = 1;\\n        int step = 1;\\n        while (!qs.empty()) {\\n            int sz = qs.size();\\n            while (sz--) {\\n                pair<int, int> f = qs.front();\\n                qs.pop();\\n                \\n                if (f.first == m - 1 && f.second == n - 1) {\\n                    return step;\\n                }\\n\\n                for (int i = -1; i <= 1; ++i) {\\n                    for (int j = -1; j <= 1; ++j) {\\n                        int newRow = f.first + i, newCol = f.second + j;\\n                        if ((i == 0 && j == 0) || newRow < 0 ||  newRow >= m\\n                            || newCol < 0 ||  newCol >= n || grid[newRow][newCol] == 1) {\\n                            continue;\\n                        }\\n                        qs.push({newRow, newCol});\\n                        grid[newRow][newCol] = 1;                        \\n                    }\\n                }\\n            }\\n            ++step;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850880,
                "title": "c-well-commented-easy-to-understand-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    // checking weather the index vot violating upper boungs\\n    bool isValid(int x, int y, int xl,  int yl) {\\n        if(x >= 0 && x < xl && y>=0 && y < yl) return true; return false; \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // dist 2D vector which will hold distance of source to every other element in the grid\\n        vector<vector<int>> dist(n, vector<int>(n, INT_MAX));\\n        dist[0][0] = 0;\\n        \\n        // handling cases when we can\\'t reach destination if the start or end is not visited\\n        if(grid[n-1][n-1] == 1 || grid[0][0] == 1) return -1;\\n        queue<pair<int, int>> q1;\\n        // pushing src index as from we need to find dist of every other index with src index\\n        q1.push({ 0, 0});\\n        \\n        // as here we can go in any the eight directed which is up, down, left, right, top left, top right, bottom left, bottom right\\n        \\n        vector<int> dx = {1, 0, 0, -1, 1 ,-1 ,1 ,-1};\\n        vector<int> dy = {0, 1, -1, 0, 1, -1, -1 , 1};\\n        \\n        while(!q1.empty()) {\\n            pair<int, int> p1 = q1.front();\\n            q1.pop();\\n            int x = p1.first;\\n            int y = p1.second;\\n            // checking the nerigbours\\n            for(int i=0;i<8;i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n                // checking if neighbour has valid index\\n                if(isValid(nx, ny, n, n)) {\\n                    // checking if any update in path in possible\\n                    if((dist[nx][ny] > dist[x][y] + 1) && grid[nx][ny] == 0) {\\n                        // updating the path length and pushing the index into queue to check if any further update possible                       \\n                        dist[nx][ny] = dist[x][y] + 1;\\n                        q1.push({ nx, ny });\\n                    }  \\n                } \\n                \\n            }\\n            \\n        }\\n        \\n        // if dist[n-1][n-1] is not changed then we return -1 or else we return the number of elements in the shortest path found\\n        return dist[n-1][n-1] == INT_MAX ? -1 : dist[n-1][n-1] + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // checking weather the index vot violating upper boungs\\n    bool isValid(int x, int y, int xl,  int yl) {\\n        if(x >= 0 && x < xl && y>=0 && y < yl) return true; return false; \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // dist 2D vector which will hold distance of source to every other element in the grid\\n        vector<vector<int>> dist(n, vector<int>(n, INT_MAX));\\n        dist[0][0] = 0;\\n        \\n        // handling cases when we can\\'t reach destination if the start or end is not visited\\n        if(grid[n-1][n-1] == 1 || grid[0][0] == 1) return -1;\\n        queue<pair<int, int>> q1;\\n        // pushing src index as from we need to find dist of every other index with src index\\n        q1.push({ 0, 0});\\n        \\n        // as here we can go in any the eight directed which is up, down, left, right, top left, top right, bottom left, bottom right\\n        \\n        vector<int> dx = {1, 0, 0, -1, 1 ,-1 ,1 ,-1};\\n        vector<int> dy = {0, 1, -1, 0, 1, -1, -1 , 1};\\n        \\n        while(!q1.empty()) {\\n            pair<int, int> p1 = q1.front();\\n            q1.pop();\\n            int x = p1.first;\\n            int y = p1.second;\\n            // checking the nerigbours\\n            for(int i=0;i<8;i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n                // checking if neighbour has valid index\\n                if(isValid(nx, ny, n, n)) {\\n                    // checking if any update in path in possible\\n                    if((dist[nx][ny] > dist[x][y] + 1) && grid[nx][ny] == 0) {\\n                        // updating the path length and pushing the index into queue to check if any further update possible                       \\n                        dist[nx][ny] = dist[x][y] + 1;\\n                        q1.push({ nx, ny });\\n                    }  \\n                } \\n                \\n            }\\n            \\n        }\\n        \\n        // if dist[n-1][n-1] is not changed then we return -1 or else we return the number of elements in the shortest path found\\n        return dist[n-1][n-1] == INT_MAX ? -1 : dist[n-1][n-1] + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816185,
                "title": "why-should-we-use-bfs-in-these-kind-of-problems",
                "content": "\\tAlways use BFS in these kind of problem because bfs always gives the shortest path in undirected, unweighted graph\\n\\t\\n\\t\\n\\tstruct Pair{\\n        int r;\\n        int c;\\n        int dist;\\n    };\\n    vector<vector<int>> dir = {\\n                                {-1,0}, {-1,1},{0,1},{1,1},\\n                                {1,0},{1,-1},{0,-1},{-1,-1}\\n                             };\\n    \\n    bool isSafe(int r,int c,int n,int m){\\n        if(r < 0 or c < 0 or r >= n or c >= m){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        queue<Pair> qu;\\n        if(grid[0][0]==1){\\n            return -1;\\n        }\\n        qu.push({0,0,1});\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        while(!qu.empty()){\\n            \\n            Pair p = qu.front();\\n            qu.pop();\\n            \\n            if(p.r == n-1 and p.c == m-1){\\n                \\n                return p.dist;\\n            }\\n            if(visited[p.r][p.c])continue;\\n            \\n            visited[p.r][p.c] = true;\\n            \\n            for(int i = 0 ;i<dir.size();i++){\\n                int x = p.r + dir[i][0];\\n                int y = p.c + dir[i][1];\\n                \\n                if(isSafe(x,y,n,m) and !visited[x][y] and grid[x][y]==0){\\n                    qu.push({x,y,p.dist + 1});\\n                }\\n            }\\n        \\n        }\\n        return -1;\\n        \\n    }",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "\\tAlways use BFS in these kind of problem because bfs always gives the shortest path in undirected, unweighted graph\\n\\t\\n\\t\\n\\tstruct Pair{\\n        int r;\\n        int c;\\n        int dist;\\n    };\\n    vector<vector<int>> dir = {\\n                                {-1,0}, {-1,1},{0,1},{1,1},\\n                                {1,0},{1,-1},{0,-1},{-1,-1}\\n                             };\\n    \\n    bool isSafe(int r,int c,int n,int m){\\n        if(r < 0 or c < 0 or r >= n or c >= m){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        queue<Pair> qu;\\n        if(grid[0][0]==1){\\n            return -1;\\n        }\\n        qu.push({0,0,1});\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        while(!qu.empty()){\\n            \\n            Pair p = qu.front();\\n            qu.pop();\\n            \\n            if(p.r == n-1 and p.c == m-1){\\n                \\n                return p.dist;\\n            }\\n            if(visited[p.r][p.c])continue;\\n            \\n            visited[p.r][p.c] = true;\\n            \\n            for(int i = 0 ;i<dir.size();i++){\\n                int x = p.r + dir[i][0];\\n                int y = p.c + dir[i][1];\\n                \\n                if(isSafe(x,y,n,m) and !visited[x][y] and grid[x][y]==0){\\n                    qu.push({x,y,p.dist + 1});\\n                }\\n            }\\n        \\n        }\\n        return -1;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1809171,
                "title": "simple-c-bfs-solution-commented-code",
                "content": "We are just applying BFS to every cell that has 0.\\n**Note:  the first time we visit a cell that would be the minimum distance of that cell from the starting position**\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(); //Taking the grid size\\n        \\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0)\\n            return -1; //checking if the starting and end positions are 0 .If not then returning -1\\n        \\n        if(n==1)\\n            return 1; //if size of grid is 1 then the answer will be 1 as the starting cell will be the ending cell also.\\n        \\n      \\n        \\n        queue<pair<int,int>> q; //For BFS traversal. passing the starting node\\n        q.push({0,0});\\n        grid[0][0]=1; //initialzing the starting distance as 1 cause the distance from\\n                        // the starting cell will be 1 cell only\\n        \\n        int dirx[8] = {0,1,0,-1,1,-1,1,-1};\\n        int diry[8] = {1,0,-1,0,1,1,-1,-1}; //for checking 8 directions\\n        \\n        while(!q.empty()){\\n            \\n            auto curr = q.front();  //The current position\\n            q.pop();//pop the current position\\n            int row = curr.first;\\n            int col = curr.second;\\n            \\n            for(int i=0;i<8;i++){\\n                int x = dirx[i];\\n                int y= diry[i];\\n                \\n                if(row+x<0||col+y<0||row+x>=n||col+y>=n||grid[row+x][col+y]>=1){\\n                    continue; //if the position goes out of bounds or if its already visited we move to the next position\\n                    //if the grid value is 1 then we cannot move to that cell because\\n                    //we can only move to 0 and if the grid value is greater than 1 then it means \\n                    //it is already visited so we dont need to visit again.\\n                }\\n                \\n                    grid[row+x][col+y] = 1 + grid[row][col]; //if we reach the last cell we return the distance\\n                    if(row+x==n-1&&col+y==n-1)\\n                        return grid[n-1][n-1];\\n                    q.push({row+x,col+y}); //if its not the last cell then we push it into the queue\\n                }\\n                \\n            }\\n            \\n        \\n        \\n        return -1; //if we reach here it means there is no clear path between starting and ending cell\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(); //Taking the grid size\\n        \\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0)\\n            return -1; //checking if the starting and end positions are 0 .If not then returning -1\\n        \\n        if(n==1)\\n            return 1; //if size of grid is 1 then the answer will be 1 as the starting cell will be the ending cell also.\\n        \\n      \\n        \\n        queue<pair<int,int>> q; //For BFS traversal. passing the starting node\\n        q.push({0,0});\\n        grid[0][0]=1; //initialzing the starting distance as 1 cause the distance from\\n                        // the starting cell will be 1 cell only\\n        \\n        int dirx[8] = {0,1,0,-1,1,-1,1,-1};\\n        int diry[8] = {1,0,-1,0,1,1,-1,-1}; //for checking 8 directions\\n        \\n        while(!q.empty()){\\n            \\n            auto curr = q.front();  //The current position\\n            q.pop();//pop the current position\\n            int row = curr.first;\\n            int col = curr.second;\\n            \\n            for(int i=0;i<8;i++){\\n                int x = dirx[i];\\n                int y= diry[i];\\n                \\n                if(row+x<0||col+y<0||row+x>=n||col+y>=n||grid[row+x][col+y]>=1){\\n                    continue; //if the position goes out of bounds or if its already visited we move to the next position\\n                    //if the grid value is 1 then we cannot move to that cell because\\n                    //we can only move to 0 and if the grid value is greater than 1 then it means \\n                    //it is already visited so we dont need to visit again.\\n                }\\n                \\n                    grid[row+x][col+y] = 1 + grid[row][col]; //if we reach the last cell we return the distance\\n                    if(row+x==n-1&&col+y==n-1)\\n                        return grid[n-1][n-1];\\n                    q.push({row+x,col+y}); //if its not the last cell then we push it into the queue\\n                }\\n                \\n            }\\n            \\n        \\n        \\n        return -1; //if we reach here it means there is no clear path between starting and ending cell\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698121,
                "title": "rust-a",
                "content": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nconst N: &[(isize, isize); 8] = &[\\n    (-1, -1),\\n    (-1, 0),\\n    (-1, 1),\\n    (0, -1),\\n    (0, 1),\\n    (1, -1),\\n    (1, 0),\\n    (1, 1),\\n];\\n\\npub fn shortest_path_binary_matrix(mut grid: Vec<Vec<i32>>) -> i32 {\\n    if grid[0][0] != 0 {\\n        return -1;\\n    }\\n\\n    let mut pq = BinaryHeap::new();\\n    pq.push((Reverse((heuristic(&grid, 0, 0) + 1, 1i32)), (0, 0)));\\n\\n    while let Some((Reverse((_, s)), (r, c))) = pq.pop() {\\n        if grid[r][c] != 0 {\\n            continue;\\n        }\\n        grid[r][c] = 255;\\n\\n        if r == grid.len() - 1 && c == grid[0].len() - 1 {\\n            return s;\\n        }\\n\\n        for (dr, dc) in N.iter().copied() {\\n            let rr = (r as isize) + dr;\\n            if rr < 0 || rr as usize >= grid.len() {\\n                continue;\\n            }\\n\\n            let cc = (c as isize) + dc;\\n            if cc < 0 || cc as usize >= grid[0].len() {\\n                continue;\\n            }\\n\\n            let rr = rr as usize;\\n            let cc = cc as usize;\\n            if grid[rr][cc] != 0 {\\n                continue;\\n            }\\n\\n            let m = heuristic(&grid, rr, cc);\\n            let s = s + 1;\\n            pq.push((Reverse((m + s, s)), (rr, cc)));\\n        }\\n    }\\n\\n    -1\\n}\\n\\nfn heuristic(grid: &Vec<Vec<i32>>, r: usize, c: usize) -> i32 {\\n    const D1: isize = 1;\\n    const D2: isize = 1;\\n\\n    let dx = (grid.len() - r - 1) as isize;\\n    let dy = (grid[0].len() - c - 1) as isize;\\n\\n    (D1 * (dx + dy) + (D2 - 2 * D1) * dx.min(dy)) as i32\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nconst N: &[(isize, isize); 8] = &[\\n    (-1, -1),\\n    (-1, 0),\\n    (-1, 1),\\n    (0, -1),\\n    (0, 1),\\n    (1, -1),\\n    (1, 0),\\n    (1, 1),\\n];\\n\\npub fn shortest_path_binary_matrix(mut grid: Vec<Vec<i32>>) -> i32 {\\n    if grid[0][0] != 0 {\\n        return -1;\\n    }\\n\\n    let mut pq = BinaryHeap::new();\\n    pq.push((Reverse((heuristic(&grid, 0, 0) + 1, 1i32)), (0, 0)));\\n\\n    while let Some((Reverse((_, s)), (r, c))) = pq.pop() {\\n        if grid[r][c] != 0 {\\n            continue;\\n        }\\n        grid[r][c] = 255;\\n\\n        if r == grid.len() - 1 && c == grid[0].len() - 1 {\\n            return s;\\n        }\\n\\n        for (dr, dc) in N.iter().copied() {\\n            let rr = (r as isize) + dr;\\n            if rr < 0 || rr as usize >= grid.len() {\\n                continue;\\n            }\\n\\n            let cc = (c as isize) + dc;\\n            if cc < 0 || cc as usize >= grid[0].len() {\\n                continue;\\n            }\\n\\n            let rr = rr as usize;\\n            let cc = cc as usize;\\n            if grid[rr][cc] != 0 {\\n                continue;\\n            }\\n\\n            let m = heuristic(&grid, rr, cc);\\n            let s = s + 1;\\n            pq.push((Reverse((m + s, s)), (rr, cc)));\\n        }\\n    }\\n\\n    -1\\n}\\n\\nfn heuristic(grid: &Vec<Vec<i32>>, r: usize, c: usize) -> i32 {\\n    const D1: isize = 1;\\n    const D2: isize = 1;\\n\\n    let dx = (grid.len() - r - 1) as isize;\\n    let dy = (grid[0].len() - c - 1) as isize;\\n\\n    (D1 * (dx + dy) + (D2 - 2 * D1) * dx.min(dy)) as i32\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663606,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        guard grid[0][0] == 0 else { return -1 }\\n        let row = grid.count, col = grid[0].count\\n        guard grid[row - 1][col - 1] == 0 else { return -1 }\\n        var grid = grid, queue = [(x: 0, y: 0)]\\n        grid[0][0] = 1\\n        \\n        while !queue.isEmpty {\\n            let cur = queue.removeFirst()\\n            if cur.x == row - 1, cur.y == col - 1 { return grid[cur.x][cur.y] }\\n            for (dx,dy) in [(0,1),(0,-1),(1,0),(-1,0),(-1,-1),(-1,1),(1,-1),(1,1)] {\\n                let new = (x: (cur.x + dx), y: (cur.y + dy))\\n                guard new.x >= 0, new.y >= 0, new.x < row, new.y < col, grid[new.x][new.y] == 0 else { continue }\\n                queue.append((new.x, new.y))\\n                grid[new.x][new.y] = grid[cur.x][cur.y] + 1\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shortestPathBinaryMatrix([[0,1],[1,0]])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.shortestPathBinaryMatrix([[0,0,0],[1,1,0],[1,1,0]])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.shortestPathBinaryMatrix([[1,0,0],[1,1,0],[1,1,0]])\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        guard grid[0][0] == 0 else { return -1 }\\n        let row = grid.count, col = grid[0].count\\n        guard grid[row - 1][col - 1] == 0 else { return -1 }\\n        var grid = grid, queue = [(x: 0, y: 0)]\\n        grid[0][0] = 1\\n        \\n        while !queue.isEmpty {\\n            let cur = queue.removeFirst()\\n            if cur.x == row - 1, cur.y == col - 1 { return grid[cur.x][cur.y] }\\n            for (dx,dy) in [(0,1),(0,-1),(1,0),(-1,0),(-1,-1),(-1,1),(1,-1),(1,1)] {\\n                let new = (x: (cur.x + dx), y: (cur.y + dy))\\n                guard new.x >= 0, new.y >= 0, new.x < row, new.y < col, grid[new.x][new.y] == 0 else { continue }\\n                queue.append((new.x, new.y))\\n                grid[new.x][new.y] = grid[cur.x][cur.y] + 1\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shortestPathBinaryMatrix([[0,1],[1,0]])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.shortestPathBinaryMatrix([[0,0,0],[1,1,0],[1,1,0]])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.shortestPathBinaryMatrix([[1,0,0],[1,1,0],[1,1,0]])\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656639,
                "title": "java-easy-to-understand-bfs-dfs",
                "content": "```\\nclass Solution\\n{// dfs passed only 49/88 cases and gave tle on other test cases\\n /*   int n;       \\n    int m;\\n    boolean visit[][];\\n    int count=Integer.MAX_VALUE;\\n    public void dfs(int grid[][],int row,int col,int moves)\\n    {\\n        \\n        if(row<0||row>=n||col<0||col>=n||visit[row][col]||grid[row][col]==1)\\n            return;\\n        if(row==n-1&&col==m-1)\\n        {\\n            count=Math.min(count,moves);\\n            return;\\n        }\\n          visit[row][col]=true;\\n        dfs(grid,row+1,col,moves+1);\\n        dfs(grid,row-1,col,moves+1);\\n        dfs(grid,row+1,col+1,moves+1);\\n        dfs(grid,row+1,col-1,moves+1);\\n        dfs(grid,row,col+1,moves+1);\\n        dfs(grid,row,col-1,moves+1);\\n        dfs(grid,row-1,col+1,moves+1);\\n        dfs(grid,row-1,col-1,moves+1);\\n          visit[row][col]=false;\\n            \\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) \\n    {\\n        n=grid.length;\\n        m=grid[0].length;\\n        visit=new boolean[n][m];\\n        if(grid[0][0]==1||grid[n-1][m-1]==1)\\n            return -1;\\n        dfs(grid,0,0,1);\\n        return count==Integer.MAX_VALUE?-1:count;\\n    }*/\\n    //going with bfs approach now\\n    //BURN BABY BURN!!!!!!\\n    class pair\\n    {\\n        int x;\\n        int y;\\n        int moves;\\n        pair(int x,int y,int moves)\\n        {\\n            this.x=x;\\n            this.y=y;\\n            this.moves=moves;\\n        }\\n    }\\n     public int shortestPathBinaryMatrix(int[][] grid)\\n     {\\n         int dir[][]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,-1},{-1,1}};\\n         int n=grid.length;\\n         int m=grid.length;\\n         LinkedList<pair>q=new LinkedList<>();\\n        // int count=Integer.MAX_VALUE;\\n         if(grid[0][0]==1||grid[n-1][m-1]==1)\\n             return -1;\\n         pair np=new pair(0,0,1);\\n         q.add(np);\\n         boolean visit[][]=new boolean[n][m];\\n         visit[0][0]=true;\\n         while(q.size()!=0)\\n         {\\n             pair p=q.poll();\\n             if(p.x==n-1 && p.y==m-1)\\n             {\\n                 return p.moves;\\n             }\\n             for(int dirs[]:dir)\\n             {\\n                 int nx=dirs[0]+p.x;\\n                 int ny=dirs[1]+p.y;\\n                 if(nx<0||nx>=n||ny<0||ny>=m||visit[nx][ny]||grid[nx][ny]==1)\\n                     continue;\\n                 else\\n                 {\\n                     pair c=new pair(nx,ny,p.moves+1);\\n                     q.add(c);\\n                     visit[nx][ny]=true;\\n                 }\\n             }\\n         }\\n         return -1;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{// dfs passed only 49/88 cases and gave tle on other test cases\\n /*   int n;       \\n    int m;\\n    boolean visit[][];\\n    int count=Integer.MAX_VALUE;\\n    public void dfs(int grid[][],int row,int col,int moves)\\n    {\\n        \\n        if(row<0||row>=n||col<0||col>=n||visit[row][col]||grid[row][col]==1)\\n            return;\\n        if(row==n-1&&col==m-1)\\n        {\\n            count=Math.min(count,moves);\\n            return;\\n        }\\n          visit[row][col]=true;\\n        dfs(grid,row+1,col,moves+1);\\n        dfs(grid,row-1,col,moves+1);\\n        dfs(grid,row+1,col+1,moves+1);\\n        dfs(grid,row+1,col-1,moves+1);\\n        dfs(grid,row,col+1,moves+1);\\n        dfs(grid,row,col-1,moves+1);\\n        dfs(grid,row-1,col+1,moves+1);\\n        dfs(grid,row-1,col-1,moves+1);\\n          visit[row][col]=false;\\n            \\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) \\n    {\\n        n=grid.length;\\n        m=grid[0].length;\\n        visit=new boolean[n][m];\\n        if(grid[0][0]==1||grid[n-1][m-1]==1)\\n            return -1;\\n        dfs(grid,0,0,1);\\n        return count==Integer.MAX_VALUE?-1:count;\\n    }*/\\n    //going with bfs approach now\\n    //BURN BABY BURN!!!!!!\\n    class pair\\n    {\\n        int x;\\n        int y;\\n        int moves;\\n        pair(int x,int y,int moves)\\n        {\\n            this.x=x;\\n            this.y=y;\\n            this.moves=moves;\\n        }\\n    }\\n     public int shortestPathBinaryMatrix(int[][] grid)\\n     {\\n         int dir[][]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,-1},{-1,1}};\\n         int n=grid.length;\\n         int m=grid.length;\\n         LinkedList<pair>q=new LinkedList<>();\\n        // int count=Integer.MAX_VALUE;\\n         if(grid[0][0]==1||grid[n-1][m-1]==1)\\n             return -1;\\n         pair np=new pair(0,0,1);\\n         q.add(np);\\n         boolean visit[][]=new boolean[n][m];\\n         visit[0][0]=true;\\n         while(q.size()!=0)\\n         {\\n             pair p=q.poll();\\n             if(p.x==n-1 && p.y==m-1)\\n             {\\n                 return p.moves;\\n             }\\n             for(int dirs[]:dir)\\n             {\\n                 int nx=dirs[0]+p.x;\\n                 int ny=dirs[1]+p.y;\\n                 if(nx<0||nx>=n||ny<0||ny>=m||visit[nx][ny]||grid[nx][ny]==1)\\n                     continue;\\n                 else\\n                 {\\n                     pair c=new pair(nx,ny,p.moves+1);\\n                     q.add(c);\\n                     visit[nx][ny]=true;\\n                 }\\n             }\\n         }\\n         return -1;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590798,
                "title": "javascript-a-search",
                "content": "```\\nclass Node {\\n    constructor(row, col, value) {\\n        this.row = row\\n        this.col = col\\n        this.value = value\\n        this.g = Infinity\\n        this.h = Infinity\\n        this.f = Infinity\\n        this.parent = null\\n    }\\n}\\nconst initNodes = (grid) => {\\n    const nodes = []\\n    for (let r = 0; r < grid.length; r++) {\\n        nodes.push([])\\n        for (let c = 0; c < grid[0].length; c++) {\\n            nodes[r].push(new Node(r, c, grid[r][c]))\\n        }\\n    }\\n    return nodes\\n}\\nconst calcDistance = (currNode, endNode) => {\\n    return Math.max(endNode.row - currNode.row, endNode.col - currNode.col)\\n}\\nconst getNeighborNodes = (currNode, nodes) => {\\n    const numRows = nodes.length\\n    const numCols = nodes[0].length\\n    const neighbors = []\\n    for (let r = -1; r <= 1; r++) {\\n        for (let c = -1; c <= 1; c++) {\\n            if (r === 0 && c === 0) continue\\n            const row = currNode.row + r\\n            const col = currNode.col + c\\n            \\n            if (row < 0 || row >= numRows || col < 0 || col >= numCols) continue\\n            neighbors.push(nodes[row][col])\\n        }\\n    }\\n    return neighbors\\n}\\nconst getPathLength = (endNode) => {\\n    if (endNode.parent === null) return -1\\n    let pathLength = 0\\n    let currNode = endNode\\n    while (currNode) {\\n        pathLength++\\n        currNode = currNode.parent\\n    }\\n    return pathLength\\n}\\n\\nconst shortestPathBinaryMatrix = (grid) => {\\n    const nodes = initNodes(grid)\\n    const n = grid.length\\n    const startNode = nodes[0][0]\\n    const endNode = nodes[n - 1][n - 1]\\n    \\n    if (startNode === endNode) return 1\\n    if (startNode.value === 1 || endNode.value === 1) return -1\\n    \\n    startNode.g = 0\\n    startNode.h = calcDistance(startNode, endNode)\\n    startNode.f = 0\\n    \\n    const nodesToVisit = [startNode]\\n    const visited = new Set()\\n    while (nodesToVisit.length) {\\n        let currNode = nodesToVisit[0]\\n        let currNodeIdx = 0\\n        for (let i = 0; i < nodesToVisit.length; i++) {\\n            const node = nodesToVisit[i]\\n            if (node.f <= currNode.f) {\\n                currNode = node\\n                currNodeIdx = i\\n            }\\n        }\\n        nodesToVisit.splice(currNodeIdx, 1)\\n        visited.add(currNode)\\n        \\n        if (currNode === endNode) break\\n        \\n        const neighbors = getNeighborNodes(currNode, nodes)\\n        for (const neighbor of neighbors) {\\n            if (neighbor.value === 1 || visited.has(neighbor)) continue\\n            \\n            const distanceToNeighbor = currNode.g + 1\\n            if (distanceToNeighbor >= neighbor.g) continue\\n            \\n            neighbor.g = distanceToNeighbor\\n            neighbor.h = calcDistance(neighbor, endNode)\\n            neighbor.f = neighbor.g + neighbor.h\\n            neighbor.parent = currNode\\n            \\n            if (!nodesToVisit.includes(neighbor)) {\\n                nodesToVisit.push(neighbor)\\n            }\\n        }\\n    }\\n    return getPathLength(endNode)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Node {\\n    constructor(row, col, value) {\\n        this.row = row\\n        this.col = col\\n        this.value = value\\n        this.g = Infinity\\n        this.h = Infinity\\n        this.f = Infinity\\n        this.parent = null\\n    }\\n}\\nconst initNodes = (grid) => {\\n    const nodes = []\\n    for (let r = 0; r < grid.length; r++) {\\n        nodes.push([])\\n        for (let c = 0; c < grid[0].length; c++) {\\n            nodes[r].push(new Node(r, c, grid[r][c]))\\n        }\\n    }\\n    return nodes\\n}\\nconst calcDistance = (currNode, endNode) => {\\n    return Math.max(endNode.row - currNode.row, endNode.col - currNode.col)\\n}\\nconst getNeighborNodes = (currNode, nodes) => {\\n    const numRows = nodes.length\\n    const numCols = nodes[0].length\\n    const neighbors = []\\n    for (let r = -1; r <= 1; r++) {\\n        for (let c = -1; c <= 1; c++) {\\n            if (r === 0 && c === 0) continue\\n            const row = currNode.row + r\\n            const col = currNode.col + c\\n            \\n            if (row < 0 || row >= numRows || col < 0 || col >= numCols) continue\\n            neighbors.push(nodes[row][col])\\n        }\\n    }\\n    return neighbors\\n}\\nconst getPathLength = (endNode) => {\\n    if (endNode.parent === null) return -1\\n    let pathLength = 0\\n    let currNode = endNode\\n    while (currNode) {\\n        pathLength++\\n        currNode = currNode.parent\\n    }\\n    return pathLength\\n}\\n\\nconst shortestPathBinaryMatrix = (grid) => {\\n    const nodes = initNodes(grid)\\n    const n = grid.length\\n    const startNode = nodes[0][0]\\n    const endNode = nodes[n - 1][n - 1]\\n    \\n    if (startNode === endNode) return 1\\n    if (startNode.value === 1 || endNode.value === 1) return -1\\n    \\n    startNode.g = 0\\n    startNode.h = calcDistance(startNode, endNode)\\n    startNode.f = 0\\n    \\n    const nodesToVisit = [startNode]\\n    const visited = new Set()\\n    while (nodesToVisit.length) {\\n        let currNode = nodesToVisit[0]\\n        let currNodeIdx = 0\\n        for (let i = 0; i < nodesToVisit.length; i++) {\\n            const node = nodesToVisit[i]\\n            if (node.f <= currNode.f) {\\n                currNode = node\\n                currNodeIdx = i\\n            }\\n        }\\n        nodesToVisit.splice(currNodeIdx, 1)\\n        visited.add(currNode)\\n        \\n        if (currNode === endNode) break\\n        \\n        const neighbors = getNeighborNodes(currNode, nodes)\\n        for (const neighbor of neighbors) {\\n            if (neighbor.value === 1 || visited.has(neighbor)) continue\\n            \\n            const distanceToNeighbor = currNode.g + 1\\n            if (distanceToNeighbor >= neighbor.g) continue\\n            \\n            neighbor.g = distanceToNeighbor\\n            neighbor.h = calcDistance(neighbor, endNode)\\n            neighbor.f = neighbor.g + neighbor.h\\n            neighbor.parent = currNode\\n            \\n            if (!nodesToVisit.includes(neighbor)) {\\n                nodesToVisit.push(neighbor)\\n            }\\n        }\\n    }\\n    return getPathLength(endNode)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239182,
                "title": "java-bfs-and-dfs-solution",
                "content": "class Solution {\\n    \\n\\tpublic int shortestPathBinaryMatrix(int[][] grid) {\\n        int[][] dirs = {\\n            {-1, +0}, \\n            {+0, +1}, \\n            {+0, -1},  \\n            {+1, +1},  \\n            {+1, -1},  \\n            {-1, +1},  \\n            {+1, +0},  \\n            {-1, -1},  \\n        };\\n        \\n        // BFS Accepted\\n        int y = bfs(grid, dirs);\\n        return y == Integer.MAX_VALUE?-1:y;\\n        \\n        // DFS Solution will give TLE\\n        // int x = dfs(0, 0, grid, dirs);\\n        // return x == Integer.MAX_VALUE?-1:x;\\n    }\\n    \\n    public int bfs(int[][] g, int[][] dirs){\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        int r = g.length, c = g[0].length;\\n        boolean[][] vis  = new boolean[r][c];\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0, 1});\\n        \\n        if(g[0][0] == 1) return -1;\\n        \\n        vis[0][0] = true;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-->0){\\n                int[] rem = q.remove();\\n                if(rem[0] == r-1 && rem[1] == c-1) min = Math.min(min, rem[2]);\\n                \\n                if(rem[2]<min) {\\n                    for(int[] d:dirs){\\n                        int x = rem[0]+d[0];\\n                        int y = rem[1]+d[1];\\n                        if(x<0 || y<0 || x>=g.length || y>=g[0].length || g[x][y] == 1 || vis[x][y]) continue;\\n                        q.add(new int[]{x, y, rem[2]+1});\\n                        vis[x][y] = true;\\n                    }    \\n                }\\n                \\n            }\\n        }\\n        \\n        return min;\\n        \\n    }\\n    \\n    public int dfs(int r, int c, int[][] g, int[][] dirs){\\n        \\n        if(r<0 || c<0 || r>=g.length || c>=g[0].length || g[r][c] == 1) return Integer.MAX_VALUE;\\n        if(r == g.length-1 && c == g[0].length-1) return 1;\\n        \\n        \\n        g[r][c] = 1;\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int[] d:dirs){\\n            min = Math.min(min, dfs(r+d[0], c+d[1], g, dirs));\\n        }\\n        \\n        g[r][c] = 0;\\n        \\n        if(min != Integer.MAX_VALUE) return min + 1;\\n        else return Integer.MAX_VALUE;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int shortestPathBinaryMatrix(int[][] grid) {\\n        int[][] dirs = {\\n            {-1, +0}",
                "codeTag": "Java"
            },
            {
                "id": 1158840,
                "title": "java-bfs-solution-easy-to-understand",
                "content": "mark visited cell as \\'1\\'\\n```\\nclass Solution {\\n    private int[][] dirs = new int[][]{{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {-1,-1}, {1,-1}, {-1, 1}};\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        // BFS\\n        if (grid[0][0] != 0 || grid[grid.length - 1][grid[0].length - 1] != 0) return -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0});\\n        int res = 1;\\n        grid[0][0] = 1;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cur = q.poll();\\n                if (cur[0] == grid.length - 1 && cur[1] == grid[0].length - 1) return res;\\n                for (int[] dir : dirs) {\\n                    int x = dir[0] + cur[0];\\n                    int y = dir[1] + cur[1];\\n                    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 1) continue;\\n                    q.offer(new int[]{x, y});\\n                    grid[x][y] = 1;\\n                }\\n            }\\n            res ++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] dirs = new int[][]{{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {-1,-1}, {1,-1}, {-1, 1}};\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        // BFS\\n        if (grid[0][0] != 0 || grid[grid.length - 1][grid[0].length - 1] != 0) return -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0});\\n        int res = 1;\\n        grid[0][0] = 1;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cur = q.poll();\\n                if (cur[0] == grid.length - 1 && cur[1] == grid[0].length - 1) return res;\\n                for (int[] dir : dirs) {\\n                    int x = dir[0] + cur[0];\\n                    int y = dir[1] + cur[1];\\n                    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 1) continue;\\n                    q.offer(new int[]{x, y});\\n                    grid[x][y] = 1;\\n                }\\n            }\\n            res ++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109622,
                "title": "c-short-bfs-beginner-friendly-code-faster-than-95-76",
                "content": "Dont get panic By seeing those if conditions! Just 8 directions!!!\\nTo avoid coming back to same place we will change the 0 to 1.\\nBFS\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int ans=1,m=grid.size(),n=grid[0].size();\\n        if(grid[0][0]||grid[m-1][n-1]) return -1;\\n        if(m==1&&n==1&&grid[0][0]==0) return 1;\\n        queue<pair<int,int>> q;grid[0][0]=1;q.push({0,0});\\n        while(q.size())\\n        {\\n            int sz=q.size();\\n            ans++;\\n            while(sz--)\\n            {\\n                auto p=q.front();q.pop();\\n                int r=p.first,c=p.second;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//to reach the last block 1st three are the only ways, So they are enough to get return ans;\\n\\t\\t\\t\\t\\n                if(r+1<m)           if(r+1==m-1&&c==n-1)return ans;else if(!grid[r+1][c]) grid[r+1][c]=1,q.push({r+1,c});\\n                if(c+1<n)           if(r==m-1&&c+1==n-1)return ans;else if(!grid[r][c+1]) grid[r][c+1]=1,q.push({r,c+1});\\n                if(r+1<m&&c+1<n)    if(r+1==m-1&&c+1==n-1)return ans;else if(!grid[r+1][c+1]) grid[r+1][c+1]=1,q.push({r+1,c+1});\\n                if(c-1>=0)          if(!grid[r][c-1]) grid[r][c-1]=1,q.push({r,c-1});\\n                if(r-1>=0)          if(!grid[r-1][c]) grid[r-1][c]=1,q.push({r-1,c});\\n                if(r+1<m&&c-1>=0)   if(!grid[r+1][c-1]) grid[r+1][c-1]=1,q.push({r+1,c-1});\\n                if(r-1>=0&&c+1<n)   if(!grid[r-1][c+1]) grid[r-1][c+1]=1,q.push({r-1,c+1});\\n                if(r-1>=0&&c-1>=0)  if(!grid[r-1][c-1]) grid[r-1][c-1]=1,q.push({r-1,c-1});\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int ans=1,m=grid.size(),n=grid[0].size();\\n        if(grid[0][0]||grid[m-1][n-1]) return -1;\\n        if(m==1&&n==1&&grid[0][0]==0) return 1;\\n        queue<pair<int,int>> q;grid[0][0]=1;q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1064125,
                "title": "c-solution-bfs-with-comments",
                "content": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] == 1) return -1; \\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        \\n        var q = new Queue<(int x, int y)>();\\n        int result = 0;\\n        \\n        q.Enqueue((0,0)); // starting point\\n        \\n        while (q.Count > 0)\\n        {\\n            int count = q.Count;\\n            result++; // count a step each time that the eight sides are processed\\n            for (int i = 0; i < count; i++)\\n            {\\n                var p = q.Dequeue();\\n                // check if out of range, blocked or visited\\n                if (p.x < 0 || p.x >= r || p.y < 0 || p.y >= c ||\\n                    grid[p.x][p.y] != 0) \\n                    continue;\\n                \\n\\t\\t\\t\\t// check if found the end\\n                if (p.x == r-1 && p.y == c-1) return result;\\n                \\n               \\n                grid[p.x][p.y] = -1; // visited\\n                \\n                q.Enqueue((p.x+1, p.y)); // right\\n                q.Enqueue((p.x+1, p.y+1)); // right/down\\n                q.Enqueue((p.x, p.y+1)); // down\\n                q.Enqueue((p.x-1, p.y+1)); // left/down\\n                q.Enqueue((p.x-1, p.y)); // left\\n                q.Enqueue((p.x-1, p.y-1)); // left/up\\n                q.Enqueue((p.x, p.y-1)); // up\\n                q.Enqueue((p.x+1, p.y-1)); // right/up                \\n            }\\n        }        \\n        return -1;         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] == 1) return -1; \\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        \\n        var q = new Queue<(int x, int y)>();\\n        int result = 0;\\n        \\n        q.Enqueue((0,0)); // starting point\\n        \\n        while (q.Count > 0)\\n        {\\n            int count = q.Count;\\n            result++; // count a step each time that the eight sides are processed\\n            for (int i = 0; i < count; i++)\\n            {\\n                var p = q.Dequeue();\\n                // check if out of range, blocked or visited\\n                if (p.x < 0 || p.x >= r || p.y < 0 || p.y >= c ||\\n                    grid[p.x][p.y] != 0) \\n                    continue;\\n                \\n\\t\\t\\t\\t// check if found the end\\n                if (p.x == r-1 && p.y == c-1) return result;\\n                \\n               \\n                grid[p.x][p.y] = -1; // visited\\n                \\n                q.Enqueue((p.x+1, p.y)); // right\\n                q.Enqueue((p.x+1, p.y+1)); // right/down\\n                q.Enqueue((p.x, p.y+1)); // down\\n                q.Enqueue((p.x-1, p.y+1)); // left/down\\n                q.Enqueue((p.x-1, p.y)); // left\\n                q.Enqueue((p.x-1, p.y-1)); // left/up\\n                q.Enqueue((p.x, p.y-1)); // up\\n                q.Enqueue((p.x+1, p.y-1)); // right/up                \\n            }\\n        }        \\n        return -1;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063531,
                "title": "shortest-path-bfs-tle-help-required",
                "content": "I don\\'t why I am getting TLE. Please help me to find the mistake.\\nProblem [link](https://leetcode.com/problems/shortest-path-in-binary-matrix/)\\n**Solved** \\nThanks to @colinyoyo26\\n```c++\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dx[8] = {-1, -1, -1, 1, 1, 1, 0 , 0};\\n    int dy[8] = {-1, 1, 0, -1, 0, 1,  1, -1};\\n    \\n    bool isValid(int x, int y, vector<vector<int>>& grid)\\n    {\\n        if( x<0 || x>=m)\\n            return false;\\n        if( y<0 || y>=n)\\n            return false;\\n        return grid[x][y]==0;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        if(grid[0][0])\\n            return -1;\\n        \\n        if(grid[m-1][n-1])\\n            return -1;\\n        \\n        if(m==1 && n==1)\\n            return 1;\\n        \\n        queue<pair<int, int> > q;\\n        q.push({0,0});\\n        \\n        int cnt = 0;\\n        \\n        while(!q.empty())\\n        {\\n            cnt++;\\n            int N = q.size();\\n            for(int j=1;j<=N;j++)\\n            {\\n                pair<int, int> curr = q.front(); q.pop();\\n                int x = curr.first, y = curr.second;\\n\\n                grid[x][y] = 1;     /// mistake, it can be updated inside second for loop\\n\\t\\t\\t\\t                          /// to avoid more number of iterations\\n                for(int i=0;i<8;i++)\\n                    if( isValid(x+dx[i], y+dy[i], grid ))\\n                    {\\n                        if(x+dx[i]==m-1 && y+dy[i]==n-1)\\n                            return cnt+1;\\n                         q.push( { x+dx[i], y+dy[i] } );  \\n                    }  \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dx[8] = {-1, -1, -1, 1, 1, 1, 0 , 0};\\n    int dy[8] = {-1, 1, 0, -1, 0, 1,  1, -1};\\n    \\n    bool isValid(int x, int y, vector<vector<int>>& grid)\\n    {\\n        if( x<0 || x>=m)\\n            return false;\\n        if( y<0 || y>=n)\\n            return false;\\n        return grid[x][y]==0;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        if(grid[0][0])\\n            return -1;\\n        \\n        if(grid[m-1][n-1])\\n            return -1;\\n        \\n        if(m==1 && n==1)\\n            return 1;\\n        \\n        queue<pair<int, int> > q;\\n        q.push({0,0});\\n        \\n        int cnt = 0;\\n        \\n        while(!q.empty())\\n        {\\n            cnt++;\\n            int N = q.size();\\n            for(int j=1;j<=N;j++)\\n            {\\n                pair<int, int> curr = q.front(); q.pop();\\n                int x = curr.first, y = curr.second;\\n\\n                grid[x][y] = 1;     /// mistake, it can be updated inside second for loop\\n\\t\\t\\t\\t                          /// to avoid more number of iterations\\n                for(int i=0;i<8;i++)\\n                    if( isValid(x+dx[i], y+dy[i], grid ))\\n                    {\\n                        if(x+dx[i]==m-1 && y+dy[i]==n-1)\\n                            return cnt+1;\\n                         q.push( { x+dx[i], y+dy[i] } );  \\n                    }  \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033988,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.Length == 0)\\n            return 0;\\n        else if (grid[0][0] == 1 || grid[grid.Length - 1][grid[0].Length - 1] == 1)\\n            return -1;\\n        \\n        int res = 0;\\n        Queue<int[]> q = new Queue<int[]>();\\n        int[] dx = new int[] { 0, 0, 1, -1, 1, 1, -1, -1 },\\n              dy = new int[] { 1, -1, 0, 0, 1, -1, 1, -1 };\\n        \\n        q.Enqueue(new int[] { 0, 0 });\\n        grid[0][0] = -1;\\n        \\n        while (q.Count > 0)\\n        {\\n            int count = q.Count;\\n            \\n            res++;\\n            \\n            while (count > 0)\\n            {\\n                int[] cur = q.Dequeue();\\n            \\n                if (cur[0] == grid.Length - 1 && cur[1] == grid[0].Length - 1)\\n                    return res;\\n\\n                for (int i = 0; i < 7; i++)\\n                {\\n                    int newX = cur[0] + dx[i],\\n                        newY = cur[1] + dy[i];\\n\\n                    if (newX > -1 && newX < grid.Length && newY > -1 && newY < grid[0].Length && grid[newX][newY] == 0)\\n                    {\\n                        q.Enqueue(new int[] { newX, newY });\\n                        grid[newX][newY] = -1;\\n                    }\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.Length == 0)\\n            return 0;\\n        else if (grid[0][0] == 1 || grid[grid.Length - 1][grid[0].Length - 1] == 1)\\n            return -1;\\n        \\n        int res = 0;\\n        Queue<int[]> q = new Queue<int[]>();\\n        int[] dx = new int[] { 0, 0, 1, -1, 1, 1, -1, -1 }",
                "codeTag": "Java"
            },
            {
                "id": 1025014,
                "title": "python3-bfs-o-n",
                "content": "**Algo**\\nSearch the grid breadth-first. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        if grid[0][0] == 0: \\n            ans = 0 \\n            grid[0][0] = 1\\n            queue = deque([(0, 0)])\\n            while queue: \\n                ans += 1\\n                for _ in range(len(queue)): \\n                    i, j = queue.popleft()\\n                    if i == j == n-1: return ans\\n                    for ii in range(i-1, i+2): \\n                        for jj in range(j-1, j+2): \\n                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] == 0: \\n                                grid[ii][jj] = 1\\n                                queue.append((ii, jj))\\n        return -1 \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        if grid[0][0] == 0: \\n            ans = 0 \\n            grid[0][0] = 1\\n            queue = deque([(0, 0)])\\n            while queue: \\n                ans += 1\\n                for _ in range(len(queue)): \\n                    i, j = queue.popleft()\\n                    if i == j == n-1: return ans\\n                    for ii in range(i-1, i+2): \\n                        for jj in range(j-1, j+2): \\n                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] == 0: \\n                                grid[ii][jj] = 1\\n                                queue.append((ii, jj))\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 933852,
                "title": "c-bfs-solution-with-explanation-runtime-96-ms-beats-96",
                "content": "BFS Solution -\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(); // row size\\n        int n = grid[0].size();// column size\\n        \\n        /*If the first value or last value is not zero, path doesn\\'t exist*/\\n        if(grid[0][0] != 0 || grid[m-1][n-1] != 0)\\n            return -1;        \\n        \\n        //Create a queue to store the indexes of the elements with value zero\\n        queue<pair<int, int>> q;\\n        \\n        //Push the starting index\\n        q.push({0,0});\\n        \\n        /* This looks at the 8 surrounding elements \\n        ie. left, right, up, down, and 4 diagonals*/\\n        int rows[] = {0,0,1,-1,1,1,-1,-1};\\n        int cols[] = {1,-1,0,0,1,-1,-1,1};\\n        //Intialize this to 0 to count the number of steps\\n        int l = 0;\\n        \\n        while(!q.empty()){\\n            l++; //increment the steps taken\\n            int k = q.size();\\n            \\n            //cx, cy = current indexes | tx, ty = traversed indexes\\n            int cx, cy, tx, ty; \\n            \\n            while(k--){\\n                cx = q.front().first; //get the x value\\n                cy = q.front().second; //get the y value\\n                q.pop(); //pop the element\\n                \\n                /*\\n                Check if the current value is the end point\\n                If it is the end point, we need not check other paths to end point.\\n                */\\n                if(cx == m-1 && cy == n-1)\\n                    return l; \\n                \\n                //Check the surrounding elements\\n                for(int i=0; i<8; i++){\\n                    tx = cx + rows[i];\\n                    ty = cy + cols[i];\\n                    \\n                    //If the element is inside the limits and  is 0, push int queue\\n                    if(tx>=0 && tx<m && ty>=0 && ty<n && grid[tx][ty] == 0){\\n                        grid[cx][cy] = 1; //Change the current value to 1\\n                        grid[tx][ty] = 1; //Change the surrounding element to 1\\n                        q.push({tx,ty}); //push the indexes into the queue\\n                    }\\n                }\\n            }\\n        }\\n        /*\\n        Check if the end point value is 1, if it is 1, that means we found a path\\n        */\\n       return  grid[m-1][n-1] == 1 ?  l :  -1; \\n    }\\n};\\n```\\n\\nSimilar Problems - \\nhttps://leetcode.com/problems/01-matrix/\\nhttps://leetcode.com/problems/as-far-from-land-as-possible/\\nhttps://leetcode.com/problems/rotting-oranges/\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(); // row size\\n        int n = grid[0].size();// column size\\n        \\n        /*If the first value or last value is not zero, path doesn\\'t exist*/\\n        if(grid[0][0] != 0 || grid[m-1][n-1] != 0)\\n            return -1;        \\n        \\n        //Create a queue to store the indexes of the elements with value zero\\n        queue<pair<int, int>> q;\\n        \\n        //Push the starting index\\n        q.push({0,0});\\n        \\n        /* This looks at the 8 surrounding elements \\n        ie. left, right, up, down, and 4 diagonals*/\\n        int rows[] = {0,0,1,-1,1,1,-1,-1};\\n        int cols[] = {1,-1,0,0,1,-1,-1,1};\\n        //Intialize this to 0 to count the number of steps\\n        int l = 0;\\n        \\n        while(!q.empty()){\\n            l++; //increment the steps taken\\n            int k = q.size();\\n            \\n            //cx, cy = current indexes | tx, ty = traversed indexes\\n            int cx, cy, tx, ty; \\n            \\n            while(k--){\\n                cx = q.front().first; //get the x value\\n                cy = q.front().second; //get the y value\\n                q.pop(); //pop the element\\n                \\n                /*\\n                Check if the current value is the end point\\n                If it is the end point, we need not check other paths to end point.\\n                */\\n                if(cx == m-1 && cy == n-1)\\n                    return l; \\n                \\n                //Check the surrounding elements\\n                for(int i=0; i<8; i++){\\n                    tx = cx + rows[i];\\n                    ty = cy + cols[i];\\n                    \\n                    //If the element is inside the limits and  is 0, push int queue\\n                    if(tx>=0 && tx<m && ty>=0 && ty<n && grid[tx][ty] == 0){\\n                        grid[cx][cy] = 1; //Change the current value to 1\\n                        grid[tx][ty] = 1; //Change the surrounding element to 1\\n                        q.push({tx,ty}); //push the indexes into the queue\\n                    }\\n                }\\n            }\\n        }\\n        /*\\n        Check if the end point value is 1, if it is 1, that means we found a path\\n        */\\n       return  grid[m-1][n-1] == 1 ?  l :  -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926988,
                "title": "swift-bfs-solution",
                "content": "```swift\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        let R = grid.count, C = grid[0].count\\n        if grid[0][0] == 1 || grid[R-1][C-1] == 1 { return -1 }\\n\\n        var grid = grid\\n        var points: Set<[Int]> = [[0, 0]]\\n        var res = 0\\n        while !points.isEmpty {\\n            res += 1\\n            points.forEach { grid[$0[0]][$0[1]] = 2 }\\n\\n            var nexts = Set<[Int]>()\\n            for point in points {\\n                let x = point[0], y = point[1]\\n                if x == R - 1 && y == C - 1 { return res }\\n                for dx in -1...1 { for dy in -1...1 {\\n                    let nx = x + dx, ny = y + dy\\n                    if nx >= 0 && nx < R && ny >= 0 && ny < C\\n                       && grid[nx][ny] == 0 {\\n                        nexts.insert([nx, ny])\\n                    }\\n                }}\\n            }\\n            points = nexts\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        let R = grid.count, C = grid[0].count\\n        if grid[0][0] == 1 || grid[R-1][C-1] == 1 { return -1 }\\n\\n        var grid = grid\\n        var points: Set<[Int]> = [[0, 0]]\\n        var res = 0\\n        while !points.isEmpty {\\n            res += 1\\n            points.forEach { grid[$0[0]][$0[1]] = 2 }\\n\\n            var nexts = Set<[Int]>()\\n            for point in points {\\n                let x = point[0], y = point[1]\\n                if x == R - 1 && y == C - 1 { return res }\\n                for dx in -1...1 { for dy in -1...1 {\\n                    let nx = x + dx, ny = y + dy\\n                    if nx >= 0 && nx < R && ny >= 0 && ny < C\\n                       && grid[nx][ny] == 0 {\\n                        nexts.insert([nx, ny])\\n                    }\\n                }}\\n            }\\n            points = nexts\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731983,
                "title": "javascript-classic-bfs-with-tracking-visited-nodes-with-comments",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar shortestPathBinaryMatrix = function(grid) {\\n    \\n    /*\\n       Classic BFS with level traversal.\\n       Time:  O(m*n)\\n       Space: O(m*n)\\n    */\\n    \\n    \\n    // Edge cases\\n    //   empty grid\\n    if(grid.length == 0){\\n        return -1;\\n    }\\n    //   blocked starting point\\n    if(grid[0][0] == 1){\\n        return -1;\\n    }\\n    \\n    // \\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    // moving directions\\n    const DIR = [\\n        // \\n        [0,1],\\n        [0,-1],\\n        [1,0],\\n        [-1,0],\\n        // diagonals\\n        [1,1],\\n        [-1,1],\\n        [1,-1],\\n        [-1,-1],\\n    ];\\n    \\n    // define target\\n    const target = {row: m-1, col: n-1};\\n        \\n    // preventing double visits\\n    // could be replaced with changing original grid\\n    // by changing visited 0 cells to 1\\n    const _seen = new Set();\\n    const seen$ = (r, c) => _seen.has(r*n+c);\\n    const visit$ = (r, c) => {\\n        _seen.add(r*n+c);\\n        return {row: r, col: c};\\n    }\\n    \\n    const q = [visit$(0,0)];\\n    \\n    let path  = 0\\n    \\n    while(q.length>0){\\n        path++;    \\n        // level traversal: in our case level it is steps in the grid\\n        for(let i=q.length;i>0;i--){\\n            let {row, col} = q.shift();\\n            \\n            // if target found - return current step\\n            // since it is BFS the very first occurences will be\\n            // at the shortest path\\n            if(row == target.row && col == target.col){\\n                return path;\\n            }\\n            \\n            for(let d of DIR){\\n                \\n                let nr = row + d[0];\\n                let nc = col + d[1];\\n                \\n                // bounds check\\n                if(nr < 0 || nc < 0 || nr >=m || nc >= n){\\n                    continue;\\n                }\\n                \\n                // ignore visited\\n                if(seen$(nr, nc)){\\n                    continue;\\n                }\\n                \\n                // visit only empty cells\\n                if(grid[nr][nc] == 0){\\n                    q.push(visit$(nr, nc));\\n                }\\n            }\\n        }\\n    }\\n    \\n    // all possible ways have been checked and no target achieved\\n    return -1;\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar shortestPathBinaryMatrix = function(grid) {\\n    \\n    /*\\n       Classic BFS with level traversal.\\n       Time:  O(m*n)\\n       Space: O(m*n)\\n    */\\n    \\n    \\n    // Edge cases\\n    //   empty grid\\n    if(grid.length == 0){\\n        return -1;\\n    }\\n    //   blocked starting point\\n    if(grid[0][0] == 1){\\n        return -1;\\n    }\\n    \\n    // \\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    // moving directions\\n    const DIR = [\\n        // \\n        [0,1],\\n        [0,-1],\\n        [1,0],\\n        [-1,0],\\n        // diagonals\\n        [1,1],\\n        [-1,1],\\n        [1,-1],\\n        [-1,-1],\\n    ];\\n    \\n    // define target\\n    const target = {row: m-1, col: n-1};\\n        \\n    // preventing double visits\\n    // could be replaced with changing original grid\\n    // by changing visited 0 cells to 1\\n    const _seen = new Set();\\n    const seen$ = (r, c) => _seen.has(r*n+c);\\n    const visit$ = (r, c) => {\\n        _seen.add(r*n+c);\\n        return {row: r, col: c};\\n    }\\n    \\n    const q = [visit$(0,0)];\\n    \\n    let path  = 0\\n    \\n    while(q.length>0){\\n        path++;    \\n        // level traversal: in our case level it is steps in the grid\\n        for(let i=q.length;i>0;i--){\\n            let {row, col} = q.shift();\\n            \\n            // if target found - return current step\\n            // since it is BFS the very first occurences will be\\n            // at the shortest path\\n            if(row == target.row && col == target.col){\\n                return path;\\n            }\\n            \\n            for(let d of DIR){\\n                \\n                let nr = row + d[0];\\n                let nc = col + d[1];\\n                \\n                // bounds check\\n                if(nr < 0 || nc < 0 || nr >=m || nc >= n){\\n                    continue;\\n                }\\n                \\n                // ignore visited\\n                if(seen$(nr, nc)){\\n                    continue;\\n                }\\n                \\n                // visit only empty cells\\n                if(grid[nr][nc] == 0){\\n                    q.push(visit$(nr, nc));\\n                }\\n            }\\n        }\\n    }\\n    \\n    // all possible ways have been checked and no target achieved\\n    return -1;\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691808,
                "title": "c-a-search-priority-queue",
                "content": "The A* search algorithm sounded as if it would be a good fit here. I think it could outperform Dijkstra/BFS in many cases.\\n\\nHere\\'s my C++ implementation:\\n```\\n#include <queue>\\n#include <vector>\\n#include <array>\\n#include <iterator>\\n#include <utility>\\n#include <climits>\\n\\nnamespace {\\n\\nconst std::array<std::pair<int, int>, 8> neighbours = {{\\n    { 1,  1},\\n    { 0,  1},\\n    { 1,  0},\\n    {-1,  1},\\n    { 1, -1},\\n    { 0, -1},\\n    {-1,  0},\\n    {-1, -1},\\n}};\\n\\nstruct square {\\n    int g_score{INT_MAX};\\n    int f_score{INT_MAX};\\n    bool in_open_set{false};\\n};\\n    \\nusing square_iterator = std::vector<square>::iterator;\\nauto lowest_f_score_cmp = [](const square_iterator lhs, const square_iterator rhs) {\\n    return lhs->f_score > rhs->f_score;\\n};\\n\\nusing p_queue = std::priority_queue<square_iterator,\\n                                    std::vector<square_iterator>,\\n                                    decltype(lowest_f_score_cmp)>;\\n\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(const std::vector<std::vector<int>>& grid) {\\n        int n_rows = grid.size();\\n        if (n_rows == 0)\\n            return -1;\\n        int n_cols = grid[0].size();\\n        if (n_cols == 0 || grid[0][0] != 0 || grid[n_rows-1][n_cols-1] != 0)\\n            return -1;\\n        \\n        auto h = [n_rows, n_cols](int r, int c) {\\n            auto r_dist = (n_rows - 1) - r;\\n            auto c_dist = (n_cols - 1) - c;\\n            return std::max(r_dist, c_dist);\\n        };\\n        \\n        std::vector<square> squares(n_rows * n_cols);\\n        auto get_square = [&squares, n_cols](int r, int c) {\\n            return squares.begin() + (r * n_cols + c);\\n        };\\n        auto get_rc = [&squares, n_cols](square_iterator it) {\\n            auto idx = std::distance(squares.begin(), it);\\n            return std::make_pair<int, int>(idx / n_cols, idx % n_cols);\\n        };\\n        \\n        auto start = get_square(0, 0);\\n        start->g_score = 1;\\n        start->f_score = h(0, 0);\\n        \\n        auto dest = get_square(n_rows - 1, n_cols - 1);\\n         \\n        p_queue open_set(lowest_f_score_cmp);\\n        start->in_open_set = true;\\n        open_set.push(start);\\n        \\n        while (!open_set.empty()) {\\n            auto current = open_set.top();\\n            if (current == dest)\\n                return dest->g_score;\\n\\n            open_set.pop();\\n            if (!current->in_open_set)\\n                continue;\\n            current->in_open_set = false;\\n            \\n            auto [curr_r, curr_c] = get_rc(current);\\n            for (const auto & n : neighbours) {\\n                auto r = curr_r + n.first;\\n                auto c = curr_c + n.second;\\n                if (r >= 0  && r < n_rows && c >= 0 && c < n_cols && grid[r][c] == 0) {\\n                    auto neighbour = get_square(r, c);\\n                    auto tentative_g_score = current->g_score + 1;\\n                    if (tentative_g_score < neighbour->g_score) {\\n                        neighbour->g_score = tentative_g_score;\\n                        neighbour->f_score = neighbour->g_score + h(r, c);\\n                        neighbour->in_open_set = true;\\n                        open_set.push(neighbour);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <queue>\\n#include <vector>\\n#include <array>\\n#include <iterator>\\n#include <utility>\\n#include <climits>\\n\\nnamespace {\\n\\nconst std::array<std::pair<int, int>, 8> neighbours = {{\\n    { 1,  1},\\n    { 0,  1},\\n    { 1,  0},\\n    {-1,  1},\\n    { 1, -1},\\n    { 0, -1},\\n    {-1,  0},\\n    {-1, -1},\\n}};\\n\\nstruct square {\\n    int g_score{INT_MAX};\\n    int f_score{INT_MAX};\\n    bool in_open_set{false};\\n};\\n    \\nusing square_iterator = std::vector<square>::iterator;\\nauto lowest_f_score_cmp = [](const square_iterator lhs, const square_iterator rhs) {\\n    return lhs->f_score > rhs->f_score;\\n};\\n\\nusing p_queue = std::priority_queue<square_iterator,\\n                                    std::vector<square_iterator>,\\n                                    decltype(lowest_f_score_cmp)>;\\n\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(const std::vector<std::vector<int>>& grid) {\\n        int n_rows = grid.size();\\n        if (n_rows == 0)\\n            return -1;\\n        int n_cols = grid[0].size();\\n        if (n_cols == 0 || grid[0][0] != 0 || grid[n_rows-1][n_cols-1] != 0)\\n            return -1;\\n        \\n        auto h = [n_rows, n_cols](int r, int c) {\\n            auto r_dist = (n_rows - 1) - r;\\n            auto c_dist = (n_cols - 1) - c;\\n            return std::max(r_dist, c_dist);\\n        };\\n        \\n        std::vector<square> squares(n_rows * n_cols);\\n        auto get_square = [&squares, n_cols](int r, int c) {\\n            return squares.begin() + (r * n_cols + c);\\n        };\\n        auto get_rc = [&squares, n_cols](square_iterator it) {\\n            auto idx = std::distance(squares.begin(), it);\\n            return std::make_pair<int, int>(idx / n_cols, idx % n_cols);\\n        };\\n        \\n        auto start = get_square(0, 0);\\n        start->g_score = 1;\\n        start->f_score = h(0, 0);\\n        \\n        auto dest = get_square(n_rows - 1, n_cols - 1);\\n         \\n        p_queue open_set(lowest_f_score_cmp);\\n        start->in_open_set = true;\\n        open_set.push(start);\\n        \\n        while (!open_set.empty()) {\\n            auto current = open_set.top();\\n            if (current == dest)\\n                return dest->g_score;\\n\\n            open_set.pop();\\n            if (!current->in_open_set)\\n                continue;\\n            current->in_open_set = false;\\n            \\n            auto [curr_r, curr_c] = get_rc(current);\\n            for (const auto & n : neighbours) {\\n                auto r = curr_r + n.first;\\n                auto c = curr_c + n.second;\\n                if (r >= 0  && r < n_rows && c >= 0 && c < n_cols && grid[r][c] == 0) {\\n                    auto neighbour = get_square(r, c);\\n                    auto tentative_g_score = current->g_score + 1;\\n                    if (tentative_g_score < neighbour->g_score) {\\n                        neighbour->g_score = tentative_g_score;\\n                        neighbour->f_score = neighbour->g_score + h(r, c);\\n                        neighbour->in_open_set = true;\\n                        open_set.push(neighbour);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 359287,
                "title": "java-bfs-20-ms-faster-than-73-32-48-7-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0 || grid[0][0] == 1) {\\n            return -1;\\n        }\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[n][n];\\n        q.offer(new int[]{0, 0});\\n        visited[0][0] = true;\\n        int steps = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            ++steps;\\n            for (int i = 0; i < size; ++i) {\\n                int[] p = q.poll();\\n                if (p[0] == n - 1 && p[1] == n - 1) {\\n                    return steps;\\n                }\\n                for (int a = -1; a <= 1; ++a) {\\n                    for (int b = -1; b <= 1; ++b) {\\n                        if (a == 0 && b == 0) {\\n                            continue;\\n                        }\\n                        int x = a + p[0];\\n                        int y = b + p[1];\\n                        if (0 <= x && x < n && 0 <= y && y < n && grid[x][y] == 0 && !visited[x][y]) {\\n                            q.offer(new int[]{x, y});\\n                            visited[x][y] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0 || grid[0][0] == 1) {\\n            return -1;\\n        }\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[n][n];\\n        q.offer(new int[]{0, 0});\\n        visited[0][0] = true;\\n        int steps = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            ++steps;\\n            for (int i = 0; i < size; ++i) {\\n                int[] p = q.poll();\\n                if (p[0] == n - 1 && p[1] == n - 1) {\\n                    return steps;\\n                }\\n                for (int a = -1; a <= 1; ++a) {\\n                    for (int b = -1; b <= 1; ++b) {\\n                        if (a == 0 && b == 0) {\\n                            continue;\\n                        }\\n                        int x = a + p[0];\\n                        int y = b + p[1];\\n                        if (0 <= x && x < n && 0 <= y && y < n && grid[x][y] == 0 && !visited[x][y]) {\\n                            q.offer(new int[]{x, y});\\n                            visited[x][y] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589114,
                "title": "c-easy-to-understand-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1)\\n            return -1;\\n        \\n        int s = grid.size();\\n        if(grid[s-1][s-1] != 0)\\n            return -1;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push({{0, 0}, 1});\\n        grid[0][0] = -1;\\n\\n        int drow[] = {-1, 0, +1, 0, 1, -1, -1, 1};\\n        int dcol[] = {0, 1, 0, -1, 1, 1, -1, -1}; \\n\\n        while(!q.empty()){\\n            auto val = q.front();\\n            int i = val.first.first;\\n            int j = val.first.second;\\n            int path = val.second;\\n            q.pop();\\n\\n            if(i == s-1 && j == s-1)\\n                return path;\\n\\n            for(int idx=0;idx<8;idx++){\\n                int row = i + drow[idx];\\n                int col = j + dcol[idx];\\n\\n                if(row >= 0 && row < s && col >= 0 && col < s && grid[row][col] == 0){\\n                    grid[row][col] = -1;\\n                    q.push({{row, col}, path+1});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1)\\n            return -1;\\n        \\n        int s = grid.size();\\n        if(grid[s-1][s-1] != 0)\\n            return -1;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push({{0, 0}, 1});\\n        grid[0][0] = -1;\\n\\n        int drow[] = {-1, 0, +1, 0, 1, -1, -1, 1};\\n        int dcol[] = {0, 1, 0, -1, 1, 1, -1, -1}; \\n\\n        while(!q.empty()){\\n            auto val = q.front();\\n            int i = val.first.first;\\n            int j = val.first.second;\\n            int path = val.second;\\n            q.pop();\\n\\n            if(i == s-1 && j == s-1)\\n                return path;\\n\\n            for(int idx=0;idx<8;idx++){\\n                int row = i + drow[idx];\\n                int col = j + dcol[idx];\\n\\n                if(row >= 0 && row < s && col >= 0 && col < s && grid[row][col] == 0){\\n                    grid[row][col] = -1;\\n                    q.push({{row, col}, path+1});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587122,
                "title": "simple-c-2-approach-bfs-dijkstra-easy-solution",
                "content": "Approach 1 -> using BFS\\nApproach 2 -> using Dijkstra Algo\\n\\n# Code\\n**BFS **\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>directions {{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n = g.size();\\n        if(g[0][0] || g[n-1][n-1]) return -1;\\n\\n        auto isSafe = [&](int x,int y){\\n            return x>=0 && x<n && y>=0 && y<n;\\n        }; // this is known as Lambda in Cpp\\n\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        g[0][0]=1;\\n        int dis = 0;\\n        while(!q.empty()){\\n            dis++;\\n            int k = q.size();\\n            while(k--){\\n                auto curr = q.front();\\n                q.pop();\\n                int x = curr.first , y = curr.second;\\n\\n                if(x==n-1 && y==n-1)return dis;\\n\\n                for(auto &dir : directions){\\n                    int nx = x + dir[0];\\n                    int ny = y + dir[1];\\n\\n                    if( isSafe(nx,ny) && g[nx][ny]==0 ){\\n                        q.push({nx,ny});\\n                        g[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\n\\n***Dijkstra ***\\n```\\nclass Solution {\\npublic:\\n\\n    typedef pair<int,pair<int,int>>P;\\n    vector<vector<int>>directions {{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n = g.size();\\n        if(g[0][0] || g[n-1][n-1]) return -1;\\n\\n        auto isSafe = [&](int x,int y){\\n            return x>=0 && x<n && y>=0 && y<n;\\n        }; // this is known as Lambda in Cpp\\n\\n        vector<vector<int>>result(n,vector<int>(n,INT_MAX));\\n\\n        priority_queue<P,vector<P>,greater<P>>pq;\\n        pq.push({0,{0,0}});\\n        result[0][0] = 0;\\n\\n        while(!pq.empty()){\\n            int d = pq.top().first;\\n            auto node = pq.top().second;\\n            int x = node.first , y = node.second;\\n            pq.pop();\\n\\n            for(auto &dir: directions){\\n                int nx = x+dir[0];\\n                int ny = y+dir[1];\\n\\n                if(isSafe(nx,ny)&& g[nx][ny]==0 && d+1<result[nx][ny]){\\n                    pq.push({d+1,{nx,ny}});\\n                    result[nx][ny] = d+1;\\n                } \\n            }\\n        }\\n        if(result[n-1][n-1] == INT_MAX) return -1;\\n        return result[n-1][n-1]+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>directions {{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n = g.size();\\n        if(g[0][0] || g[n-1][n-1]) return -1;\\n\\n        auto isSafe = [&](int x,int y){\\n            return x>=0 && x<n && y>=0 && y<n;\\n        }; // this is known as Lambda in Cpp\\n\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        g[0][0]=1;\\n        int dis = 0;\\n        while(!q.empty()){\\n            dis++;\\n            int k = q.size();\\n            while(k--){\\n                auto curr = q.front();\\n                q.pop();\\n                int x = curr.first , y = curr.second;\\n\\n                if(x==n-1 && y==n-1)return dis;\\n\\n                for(auto &dir : directions){\\n                    int nx = x + dir[0];\\n                    int ny = y + dir[1];\\n\\n                    if( isSafe(nx,ny) && g[nx][ny]==0 ){\\n                        q.push({nx,ny});\\n                        g[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\n    typedef pair<int,pair<int,int>>P;\\n    vector<vector<int>>directions {{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n = g.size();\\n        if(g[0][0] || g[n-1][n-1]) return -1;\\n\\n        auto isSafe = [&](int x,int y){\\n            return x>=0 && x<n && y>=0 && y<n;\\n        }; // this is known as Lambda in Cpp\\n\\n        vector<vector<int>>result(n,vector<int>(n,INT_MAX));\\n\\n        priority_queue<P,vector<P>,greater<P>>pq;\\n        pq.push({0,{0,0}});\\n        result[0][0] = 0;\\n\\n        while(!pq.empty()){\\n            int d = pq.top().first;\\n            auto node = pq.top().second;\\n            int x = node.first , y = node.second;\\n            pq.pop();\\n\\n            for(auto &dir: directions){\\n                int nx = x+dir[0];\\n                int ny = y+dir[1];\\n\\n                if(isSafe(nx,ny)&& g[nx][ny]==0 && d+1<result[nx][ny]){\\n                    pq.push({d+1,{nx,ny}});\\n                    result[nx][ny] = d+1;\\n                } \\n            }\\n        }\\n        if(result[n-1][n-1] == INT_MAX) return -1;\\n        return result[n-1][n-1]+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586869,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\n        lengthOfGrid = len(grid)\\n        queue = deque([(0,0,1)])\\n        visited = set((0,0))\\n        direct = [[0,1], [1,0],[0,-1], [-1,0],\\n                    [1,1],[-1,-1],[1,-1],[-1,1]]\\n        while queue:\\n            row, column, lengthOfPosition = queue.popleft()\\n            if min(row, column) < 0 or max(row, column) >= lengthOfGrid or grid[row][column]:\\n                continue\\n            if row == lengthOfGrid -1 and column == lengthOfGrid - 1:\\n                return lengthOfPosition\\n            for directRow, directColumn in direct:\\n                if (row + directRow, column + directColumn) not in visited:\\n                    queue.append((row + directRow, column+ directColumn, lengthOfPosition + 1))\\n                    visited.add((row + directRow, column + directColumn))\\n        \\n        return -1\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\n        lengthOfGrid = len(grid)\\n        queue = deque([(0,0,1)])\\n        visited = set((0,0))\\n        direct = [[0,1], [1,0],[0,-1], [-1,0],\\n                    [1,1],[-1,-1],[1,-1],[-1,1]]\\n        while queue:\\n            row, column, lengthOfPosition = queue.popleft()\\n            if min(row, column) < 0 or max(row, column) >= lengthOfGrid or grid[row][column]:\\n                continue\\n            if row == lengthOfGrid -1 and column == lengthOfGrid - 1:\\n                return lengthOfPosition\\n            for directRow, directColumn in direct:\\n                if (row + directRow, column + directColumn) not in visited:\\n                    queue.append((row + directRow, column+ directColumn, lengthOfPosition + 1))\\n                    visited.add((row + directRow, column + directColumn))\\n        \\n        return -1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586421,
                "title": "simple-bfs-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n=g.size();\\n        if(g[0][0] || g[n-1][n-1])\\n        {\\n            return -1;\\n        }\\n        g[0][0]=1;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int t=0;\\n        while(q.size()){\\n            int k=q.size();\\n            t++;\\n            while(k--){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                if(x==n-1 && y==n-1)return t;\\n                int dx[8]={1,-1,0,0,1,1,-1,-1};\\n                int dy[8]={0,0,1,-1,1,-1,1,-1};\\n                for(int i=0;i<8;i++){\\n                    int nx=x+dx[i];\\n                    int ny=y+dy[i];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<n && g[nx][ny]==0){\\n                        g[nx][ny]=1;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n=g.size();\\n        if(g[0][0] || g[n-1][n-1])\\n        {\\n            return -1;\\n        }\\n        g[0][0]=1;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int t=0;\\n        while(q.size()){\\n            int k=q.size();\\n            t++;\\n            while(k--){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                if(x==n-1 && y==n-1)return t;\\n                int dx[8]={1,-1,0,0,1,1,-1,-1};\\n                int dy[8]={0,0,1,-1,1,-1,1,-1};\\n                for(int i=0;i<8;i++){\\n                    int nx=x+dx[i];\\n                    int ny=y+dy[i];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<n && g[nx][ny]==0){\\n                        g[nx][ny]=1;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586246,
                "title": "c-bfs",
                "content": "\\n\\n# Complexity\\n- Time complexity : O(M*N)\\n\\n- Space complexity: O(M*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<pair<int,int>,int>>q;\\n        if(grid[0][0]==1)return-1;\\n        if(grid[0][0]==0&&m==1&&n==1)return 1;\\n\\n        q.push({{0,0},1});\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        while(!q.empty()){\\n        int x=q.front().first.first;\\n        int  y=q.front().first.second;\\n        int a=q.front().second;\\n        q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                int nr=x+i;\\n                int nc=y+j;\\n                if(nr>=0&&nc>=0&&nr<n&&nc<m&&vis[nr][nc]==0&&grid[nr][nc]==0){\\n                    if(nr==n-1&&nc==m-1)return a+1;\\n                    vis[nr][nc]=1;\\n                    q.push({{nr,nc},a+1});\\n\\n                }\\n            }\\n        }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<pair<int,int>,int>>q;\\n        if(grid[0][0]==1)return-1;\\n        if(grid[0][0]==0&&m==1&&n==1)return 1;\\n\\n        q.push({{0,0},1});\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        while(!q.empty()){\\n        int x=q.front().first.first;\\n        int  y=q.front().first.second;\\n        int a=q.front().second;\\n        q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                int nr=x+i;\\n                int nc=y+j;\\n                if(nr>=0&&nc>=0&&nr<n&&nc<m&&vis[nr][nc]==0&&grid[nr][nc]==0){\\n                    if(nr==n-1&&nc==m-1)return a+1;\\n                    vis[nr][nc]=1;\\n                    q.push({{nr,nc},a+1});\\n\\n                }\\n            }\\n        }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586160,
                "title": "crystal-clear-solution-using-java",
                "content": "# The algorithm is pretty simple :\\n- If the starting indices i.e. (0,0) cell value is 1 then you can immediately return -1 as the answer. Because we can\\'t even reach the first cell.\\n- Now run BFS algorithm by maintaing a queue which must store three value they are  (i,j) which the dimensions of a cell and a variable named value. You use a Pair class to achieve the above mentioned thing.\\n- Now create a pair with 0,0 and value as 1 and add the pair to the queue to run the BFS algo.\\n- The core part of the algorithm starts here. We need to run a loop such that the loop runs until there is no item left in the queue.\\n- Pop an item from the queue and check if it is the last cell , if it is then return the pair\\'s value.\\n- After we\\'ve popped the pair from the queue ,we now traverse all the eight directions of the cell with our conditions to satisfy, they are the direction must be in the bound of the grid and its value must be \\'0\\'.\\n- As you get the new dimensions add them into the queue by creating a pair with their dimensions and value with be the parent\\'s value + 1. \\n- Change the value to 1 because it tells us that you have already visited the array. We use this techinque to prevent the usage of 2d matrix (extra space).\\n- Run the loop until we find our answer or the queue size becomes zero. If that is the case then we need to return -1.\\n\\n---\\n\\n\\n# Code\\n```\\nclass Pair\\n{\\n    int i = 0;\\n    int j = 0;\\n    int value = 0;\\n    Pair(int i,int j,int value)\\n    {\\n        this.i = i;\\n        this.j = j;\\n        this.value = value;\\n    }\\n}\\nclass Solution {\\n    int[] xDir = {0,0,-1,1,-1,1,-1,1};\\n    int[] yDir = {-1,1,0,0,-1,1,1,-1};\\n    public boolean isSafe(int[][] grid,int i ,int j)\\n    {\\n        return(i>=0 && i<grid.length && j>=0 && j<grid[0].length && grid[i][j] != 1);\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n       if(grid[0][0] == 1)  return -1;\\n       int n = grid.length;\\n       Queue<Pair> queue = new LinkedList<>();\\n       queue.offer(new Pair(0,0,1));\\n       while(queue.size() > 0)\\n       {\\n           Pair curr = queue.remove();\\n           int row = curr.i;\\n           int col = curr.j;\\n           int path = curr.value;\\n           if(row == n-1 && col == n-1)\\n           {\\n               return path;\\n           }\\n           for(int k = 0;k<8;k++)\\n           {\\n               int newRow = row+xDir[k];\\n               int newCol = col+yDir[k];\\n               if(isSafe(grid,newRow,newCol))\\n               {\\n                   queue.offer(new Pair(newRow,newCol,path+1));\\n                   grid[newRow][newCol] = 1;\\n               }\\n           }\\n       }\\n       return -1;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n\\n#### *If you\\'ve liked my explanation don\\'t forget to upvote and encourage.* \\n\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Pair\\n{\\n    int i = 0;\\n    int j = 0;\\n    int value = 0;\\n    Pair(int i,int j,int value)\\n    {\\n        this.i = i;\\n        this.j = j;\\n        this.value = value;\\n    }\\n}\\nclass Solution {\\n    int[] xDir = {0,0,-1,1,-1,1,-1,1};\\n    int[] yDir = {-1,1,0,0,-1,1,1,-1};\\n    public boolean isSafe(int[][] grid,int i ,int j)\\n    {\\n        return(i>=0 && i<grid.length && j>=0 && j<grid[0].length && grid[i][j] != 1);\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n       if(grid[0][0] == 1)  return -1;\\n       int n = grid.length;\\n       Queue<Pair> queue = new LinkedList<>();\\n       queue.offer(new Pair(0,0,1));\\n       while(queue.size() > 0)\\n       {\\n           Pair curr = queue.remove();\\n           int row = curr.i;\\n           int col = curr.j;\\n           int path = curr.value;\\n           if(row == n-1 && col == n-1)\\n           {\\n               return path;\\n           }\\n           for(int k = 0;k<8;k++)\\n           {\\n               int newRow = row+xDir[k];\\n               int newCol = col+yDir[k];\\n               if(isSafe(grid,newRow,newCol))\\n               {\\n                   queue.offer(new Pair(newRow,newCol,path+1));\\n                   grid[newRow][newCol] = 1;\\n               }\\n           }\\n       }\\n       return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584725,
                "title": "beautiful-code-easy-to-understand-as-you-read-bfs-java-helper-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNoticed adjacent vertices followed a non-linear & graph topology. \\n\\n**DFS or BFS?**\\nThe order of traversal needed to be in a regular fashion, either depth-first or breadth-first. \\n\\n**Greedy approach**\\n\\nRuled out depth-first traversal on the basis that Greedy approach can be used here. Starting from the levels from the root (0, 0), the shortest path will encounter each vertex first and any path that leads to that same vertex would be a non-optimal path!\\n\\nThis follows from unidirectional graph topology :)\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo amortized BFS on all the possible adjacent vertices. \\n\\nCaveat: Maintain a visited array of seen vertices so far.\\n\\nWhy?\\nAs soon as a vertex is seen, it is already seen following the shortest path. So, just mark it visited as soon as its seen.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    class Vertex {\\n        int row;\\n        int col;\\n        int lenSoFar;\\n\\n        Vertex(int row, int col, int lenSoFar) {\\n            this.row = row;\\n            this.col = col;\\n            this.lenSoFar = lenSoFar;\\n        }\\n    }\\n\\n    public boolean isValid(int row, int col, int N, int [][]grid, boolean [][]isSeen) {\\n        if ( row >= 0 && row < N \\n        && col >= 0 && col < N\\n         && grid[row][col] == 0\\n          && isSeen[row][col] == false) {\\n              isSeen[row][col] = true;\\n              return true;\\n          }\\n        return false;\\n    }\\n\\n    public void printGrid(int [][]grid, int N) {\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                System.out.print(grid[i][j]);\\n            }\\n            System.out.println(\\',\\');\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        int N = grid[0].length;\\n\\n        // printGrid(grid, N);\\n\\n        int len = -1;\\n\\n        boolean[][] isSeen = new boolean[N][N];\\n        Queue<Vertex> adjacentCells = new LinkedList<>();\\n\\n        if (isValid(0, 0, N, grid, isSeen))\\n        {\\n            Vertex root = new Vertex(0, 0, 1);\\n            adjacentCells.add(root);\\n        }\\n\\n        while (adjacentCells.isEmpty() == false) {\\n\\n            Vertex currCell = adjacentCells.remove();\\n            int row = currCell.row, col = currCell.col;\\n\\n            // isSeen[row][col] = true;\\n\\n            // System.out.println(row + \" \" + col);\\n\\n            if (row == N - 1 && col == N - 1)\\n            {\\n                len = currCell.lenSoFar;\\n                break;\\n            }\\n\\n            // Vertex downright, downleft, upright, upleft, up, left, right, down;\\n            if (isValid(row + 1, col + 1, N, grid, isSeen))\\n            {\\n                Vertex downright = new Vertex(row + 1, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(downright);\\n            }\\n\\n            if (isValid(row + 1, col - 1, N, grid, isSeen))\\n            {\\n                Vertex downleft = new Vertex(row + 1, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(downleft);\\n            }\\n\\n            if (isValid(row - 1, col + 1, N, grid, isSeen))\\n            {\\n                Vertex upright = new Vertex(row - 1, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(upright);\\n            }\\n\\n            if (isValid(row - 1, col - 1, N, grid, isSeen))\\n            {\\n                Vertex upleft = new Vertex(row - 1, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(upleft);\\n            }\\n\\n            if (isValid(row - 1, col, N, grid, isSeen))\\n            {\\n                Vertex up = new Vertex(row - 1, col, currCell.lenSoFar + 1);\\n                adjacentCells.add(up);\\n            }\\n\\n            if (isValid(row, col - 1, N, grid, isSeen))\\n            {\\n                Vertex left = new Vertex(row, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(left);\\n            }\\n\\n            if (isValid(row + 1, col, N, grid, isSeen))\\n            {\\n                Vertex down = new Vertex(row + 1, col, currCell.lenSoFar + 1);\\n                adjacentCells.add(down);\\n            }\\n\\n            if (isValid(row, col + 1, N, grid, isSeen))\\n            {\\n                Vertex right = new Vertex(row, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(right);\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Vertex {\\n        int row;\\n        int col;\\n        int lenSoFar;\\n\\n        Vertex(int row, int col, int lenSoFar) {\\n            this.row = row;\\n            this.col = col;\\n            this.lenSoFar = lenSoFar;\\n        }\\n    }\\n\\n    public boolean isValid(int row, int col, int N, int [][]grid, boolean [][]isSeen) {\\n        if ( row >= 0 && row < N \\n        && col >= 0 && col < N\\n         && grid[row][col] == 0\\n          && isSeen[row][col] == false) {\\n              isSeen[row][col] = true;\\n              return true;\\n          }\\n        return false;\\n    }\\n\\n    public void printGrid(int [][]grid, int N) {\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                System.out.print(grid[i][j]);\\n            }\\n            System.out.println(\\',\\');\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        int N = grid[0].length;\\n\\n        // printGrid(grid, N);\\n\\n        int len = -1;\\n\\n        boolean[][] isSeen = new boolean[N][N];\\n        Queue<Vertex> adjacentCells = new LinkedList<>();\\n\\n        if (isValid(0, 0, N, grid, isSeen))\\n        {\\n            Vertex root = new Vertex(0, 0, 1);\\n            adjacentCells.add(root);\\n        }\\n\\n        while (adjacentCells.isEmpty() == false) {\\n\\n            Vertex currCell = adjacentCells.remove();\\n            int row = currCell.row, col = currCell.col;\\n\\n            // isSeen[row][col] = true;\\n\\n            // System.out.println(row + \" \" + col);\\n\\n            if (row == N - 1 && col == N - 1)\\n            {\\n                len = currCell.lenSoFar;\\n                break;\\n            }\\n\\n            // Vertex downright, downleft, upright, upleft, up, left, right, down;\\n            if (isValid(row + 1, col + 1, N, grid, isSeen))\\n            {\\n                Vertex downright = new Vertex(row + 1, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(downright);\\n            }\\n\\n            if (isValid(row + 1, col - 1, N, grid, isSeen))\\n            {\\n                Vertex downleft = new Vertex(row + 1, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(downleft);\\n            }\\n\\n            if (isValid(row - 1, col + 1, N, grid, isSeen))\\n            {\\n                Vertex upright = new Vertex(row - 1, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(upright);\\n            }\\n\\n            if (isValid(row - 1, col - 1, N, grid, isSeen))\\n            {\\n                Vertex upleft = new Vertex(row - 1, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(upleft);\\n            }\\n\\n            if (isValid(row - 1, col, N, grid, isSeen))\\n            {\\n                Vertex up = new Vertex(row - 1, col, currCell.lenSoFar + 1);\\n                adjacentCells.add(up);\\n            }\\n\\n            if (isValid(row, col - 1, N, grid, isSeen))\\n            {\\n                Vertex left = new Vertex(row, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(left);\\n            }\\n\\n            if (isValid(row + 1, col, N, grid, isSeen))\\n            {\\n                Vertex down = new Vertex(row + 1, col, currCell.lenSoFar + 1);\\n                adjacentCells.add(down);\\n            }\\n\\n            if (isValid(row, col + 1, N, grid, isSeen))\\n            {\\n                Vertex right = new Vertex(row, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(right);\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584719,
                "title": "very-easy-fast-c-soln-bfs-beginner-friendly",
                "content": "### **Please upvote if it helps.**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        int n = grid.size();\\n        if(grid[0][0] != 0 || grid[n-1][n-1] != 0)\\n            return -1;\\n        if(n-1 == 0)\\n            return 1;\\n        grid[0][0] = 1;  \\n        q.push({0,0});\\n        int count = 0;\\n        int flag = 0;\\n        vector<int> r = {0,1,-1,0,1,-1,1,-1};\\n        vector<int> c = {1,0,0,-1,1,1,-1,-1};\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            queue<pair<int,int>> temp;\\n            count++;\\n            while(size--)\\n            {\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                q.pop();\\n                for(int i = 0; i<8; i++)\\n                {\\n                    int x = row + r[i], y = col + c[i];\\n                    if(x == n-1 && y == n-1)\\n                    {\\n                        flag = 1;\\n                        count++;\\n                        break;\\n                    }\\n                    if(x >= 0 && y >= 0 && x < n && y < n)\\n                    {\\n                        if(grid[x][y] == 0)\\n                        {\\n                            temp.push({x,y});\\n                            grid[x][y] = 1;\\n                        }\\n                    }\\n                }\\n                if(flag == 1)\\n                    break;\\n            }\\n            q = temp;\\n            if(flag == 1)\\n                break;\\n        }\\n        if(flag == 0)\\n            return -1;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        int n = grid.size();\\n        if(grid[0][0] != 0 || grid[n-1][n-1] != 0)\\n            return -1;\\n        if(n-1 == 0)\\n            return 1;\\n        grid[0][0] = 1;  \\n        q.push({0,0});\\n        int count = 0;\\n        int flag = 0;\\n        vector<int> r = {0,1,-1,0,1,-1,1,-1};\\n        vector<int> c = {1,0,0,-1,1,1,-1,-1};\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            queue<pair<int,int>> temp;\\n            count++;\\n            while(size--)\\n            {\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                q.pop();\\n                for(int i = 0; i<8; i++)\\n                {\\n                    int x = row + r[i], y = col + c[i];\\n                    if(x == n-1 && y == n-1)\\n                    {\\n                        flag = 1;\\n                        count++;\\n                        break;\\n                    }\\n                    if(x >= 0 && y >= 0 && x < n && y < n)\\n                    {\\n                        if(grid[x][y] == 0)\\n                        {\\n                            temp.push({x,y});\\n                            grid[x][y] = 1;\\n                        }\\n                    }\\n                }\\n                if(flag == 1)\\n                    break;\\n            }\\n            q = temp;\\n            if(flag == 1)\\n                break;\\n        }\\n        if(flag == 0)\\n            return -1;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584653,
                "title": "python-short-and-clean-bfs-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n * n is the dimensions of the grid.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: list[list[int]]) -> int:\\n        n = len(grid)\\n        start, end = (0, 0), (n - 1, n - 1)\\n\\n        # Helper functions\\n        in_bound = lambda cell: 0 <= cell[0] < n and 0 <= cell[1] < n\\n        grid_get = lambda cell: grid[cell[0]][cell[1]] if in_bound(cell) else 1\\n        all_nbrs = lambda cell: product(range(cell[0] - 1, cell[0] + 2), range(cell[1] - 1, cell[1] + 2))\\n        is_clear = lambda cell, skips: grid_get(cell) == 0 and cell not in skips\\n\\n        if start == end: return -1 if grid_get(start) else 1\\n        queue = deque([] if grid_get(start) else [(start, 1)])\\n        seen = {start}\\n        valid_nbr = partial(is_clear, skips=seen)\\n\\n        while queue:\\n            cell, length = queue.popleft()\\n            valid_nbrs = set(filter(valid_nbr, all_nbrs(cell)))\\n\\n            if end in valid_nbrs: return length + 1\\n            queue.extend(zip(valid_nbrs, repeat(length + 1)))\\n            seen.update(valid_nbrs)\\n        \\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: list[list[int]]) -> int:\\n        n = len(grid)\\n        start, end = (0, 0), (n - 1, n - 1)\\n\\n        # Helper functions\\n        in_bound = lambda cell: 0 <= cell[0] < n and 0 <= cell[1] < n\\n        grid_get = lambda cell: grid[cell[0]][cell[1]] if in_bound(cell) else 1\\n        all_nbrs = lambda cell: product(range(cell[0] - 1, cell[0] + 2), range(cell[1] - 1, cell[1] + 2))\\n        is_clear = lambda cell, skips: grid_get(cell) == 0 and cell not in skips\\n\\n        if start == end: return -1 if grid_get(start) else 1\\n        queue = deque([] if grid_get(start) else [(start, 1)])\\n        seen = {start}\\n        valid_nbr = partial(is_clear, skips=seen)\\n\\n        while queue:\\n            cell, length = queue.popleft()\\n            valid_nbrs = set(filter(valid_nbr, all_nbrs(cell)))\\n\\n            if end in valid_nbrs: return length + 1\\n            queue.extend(zip(valid_nbrs, repeat(length + 1)))\\n            seen.update(valid_nbrs)\\n        \\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584615,
                "title": "easy-java-bfs-solution-beats-98-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1 || grid[grid.length-1][grid[0].length-1] == 1) return -1;\\n\\n        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{-1,-1},{-1,1},{1,-1}};\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        grid[0][0] = 1;\\n        int level = 1;\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int[] curr = q.poll();\\n                if(curr[0] == grid.length-1 && curr[1] == grid[0].length-1) return level;\\n                for(int[] dir : dirs){\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 0){\\n                        q.add(new int[]{x,y});\\n                        grid[x][y] = 1;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1 || grid[grid.length-1][grid[0].length-1] == 1) return -1;\\n\\n        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{-1,-1},{-1,1},{1,-1}};\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        grid[0][0] = 1;\\n        int level = 1;\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int[] curr = q.poll();\\n                if(curr[0] == grid.length-1 && curr[1] == grid[0].length-1) return level;\\n                for(int[] dir : dirs){\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 0){\\n                        q.add(new int[]{x,y});\\n                        grid[x][y] = 1;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584396,
                "title": "simple-solution-c-100-runtime-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*We\\'ll use simple BFS approach to visit neighbouirng 8 cells in each iteration till we reach the right-bottom cell.*\\n\\n![Screenshot 2023-06-01 092404.png](https://assets.leetcode.com/users/images/a684c3ea-c9d5-48b0-8f53-b3afc60f7b78_1685591665.4052565.png)\\n\\n***While visiting each cell with value \\'0\\', we\\'ll update it\\'s value with the distance so far from the left-top cell. This can help us in avoiding using separate array/hashset to track visited cells.***\\n\\n*We\\'ll use Queues of tuples to push cordinates of each cell to be visited next.*\\n<br>\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2) - as we enqueue at most all N^2 elements in the array in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2) - as we push N^2 elements in worst case\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.Length;\\n        //check if top-left and bottom-right cells are 0.\\n        if (grid[0][0] != 0 || grid[n - 1][n - 1 ] != 0)\\n            return -1;\\n\\n        //check if there\\'s only one cell, if yes - check if it is 0\\n        if (n == 1 && grid[0][0] == 0)\\n            return 1;\\n\\n        //Get moves to be made to traverse in 8 directions\\n        List<(int r, int c)> directions = GetDirections();\\n\\n        //Queue to hold cordinates of cell to be visited next\\n        Queue<(int x, int y)> q = new Queue<(int, int)>();\\n        q.Enqueue((0, 0));\\n        grid[0][0] = 1;\\n\\n        while (q.Count > 0)\\n        {\\n            (int cr, int cc) = q.Dequeue();\\n        \\n            //fixed 8 loops - O(1) runtime for this loop\\n            for (int i = 0; i < directions.Count; i++)\\n            {\\n                //neighbouring row-col cell to check\\n                int row = cr + directions[i].r;\\n                int col = cc + directions[i].c;\\n                if (row >= 0 && row < n\\n                    && col >= 0 && col < n && grid[row][col] == 0)\\n                {\\n                    grid[row][col] = grid[cr][cc] + 1;\\n                    //if we have reached bottom-right cell\\n                    if (row == n - 1 && col == n - 1)\\n                        return (grid[row][col]);\\n\\n                    q.Enqueue((row, col));\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private List<(int, int)> GetDirections()\\n    {\\n        List<(int r, int c)> directions = new List<(int, int)>();\\n        directions.Add((-1, -1));\\n        directions.Add((-1, 0));\\n        directions.Add((-1, 1));\\n        directions.Add((0, -1));\\n        directions.Add((0, 1));\\n        directions.Add((1, -1));\\n        directions.Add((1, 0));\\n        directions.Add((1, 1));\\n\\n        return directions;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach, as it would encourage us more :)\\n![Upvote please - Monkey.jpg](https://assets.leetcode.com/users/images/1dca1454-b7b2-4c9b-a65d-ac809957991a_1685591973.541374.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.Length;\\n        //check if top-left and bottom-right cells are 0.\\n        if (grid[0][0] != 0 || grid[n - 1][n - 1 ] != 0)\\n            return -1;\\n\\n        //check if there\\'s only one cell, if yes - check if it is 0\\n        if (n == 1 && grid[0][0] == 0)\\n            return 1;\\n\\n        //Get moves to be made to traverse in 8 directions\\n        List<(int r, int c)> directions = GetDirections();\\n\\n        //Queue to hold cordinates of cell to be visited next\\n        Queue<(int x, int y)> q = new Queue<(int, int)>();\\n        q.Enqueue((0, 0));\\n        grid[0][0] = 1;\\n\\n        while (q.Count > 0)\\n        {\\n            (int cr, int cc) = q.Dequeue();\\n        \\n            //fixed 8 loops - O(1) runtime for this loop\\n            for (int i = 0; i < directions.Count; i++)\\n            {\\n                //neighbouring row-col cell to check\\n                int row = cr + directions[i].r;\\n                int col = cc + directions[i].c;\\n                if (row >= 0 && row < n\\n                    && col >= 0 && col < n && grid[row][col] == 0)\\n                {\\n                    grid[row][col] = grid[cr][cc] + 1;\\n                    //if we have reached bottom-right cell\\n                    if (row == n - 1 && col == n - 1)\\n                        return (grid[row][col]);\\n\\n                    q.Enqueue((row, col));\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private List<(int, int)> GetDirections()\\n    {\\n        List<(int r, int c)> directions = new List<(int, int)>();\\n        directions.Add((-1, -1));\\n        directions.Add((-1, 0));\\n        directions.Add((-1, 1));\\n        directions.Add((0, -1));\\n        directions.Add((0, 1));\\n        directions.Add((1, -1));\\n        directions.Add((1, 0));\\n        directions.Add((1, 1));\\n\\n        return directions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584370,
                "title": "simple-python3-solution-using-bfs-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsearch for the shortest path from the start point to the end point through BFS traversal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a queue to store the grids to be processed, and initially adds the starting point to the queue. Then, take a grid out of the queue for processing, explore its adjacent grids, and add unvisited adjacent grids to the queue. This process continues until an end point is found or the queue is empty.\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        # Check if the start/end cell is blocked.\\n        if grid[0][0] != 0 or grid[n-1][n-1] != 0:\\n            return -1\\n\\n        # Create a queue for BFS and enqueue the start cell\\n        queue = deque([(0, 0, 1)])  #(row, col, path_length)\\n\\n        # Offset in 8 directions\\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\\n        \\n        # Execute BFS\\n        while queue:\\n\\n            row, col, path_len = queue.popleft()\\n            \\n            # Check if the goal has been reached.\\n            if row == n-1 and col == n-1:\\n                return path_len\\n\\n            # Explore adjacent grids.\\n            for i, j in directions:\\n                neighbour_row = i + row\\n                neighbour_col = j + col\\n\\n                # Check if the adjacent grid is within the grid range and has not been visited\\n                if 0 <= neighbour_row < n and 0 <= neighbour_col < n and grid[neighbour_row][neighbour_col] == 0:\\n                    # Mark adjacent cells as visited (set to 1)\\n                    grid[neighbour_row][neighbour_col] = 1\\n                    queue.append((neighbour_row, neighbour_col, path_len + 1))\\n\\n        # No clear path found\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        # Check if the start/end cell is blocked.\\n        if grid[0][0] != 0 or grid[n-1][n-1] != 0:\\n            return -1\\n\\n        # Create a queue for BFS and enqueue the start cell\\n        queue = deque([(0, 0, 1)])  #(row, col, path_length)\\n\\n        # Offset in 8 directions\\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\\n        \\n        # Execute BFS\\n        while queue:\\n\\n            row, col, path_len = queue.popleft()\\n            \\n            # Check if the goal has been reached.\\n            if row == n-1 and col == n-1:\\n                return path_len\\n\\n            # Explore adjacent grids.\\n            for i, j in directions:\\n                neighbour_row = i + row\\n                neighbour_col = j + col\\n\\n                # Check if the adjacent grid is within the grid range and has not been visited\\n                if 0 <= neighbour_row < n and 0 <= neighbour_col < n and grid[neighbour_row][neighbour_col] == 0:\\n                    # Mark adjacent cells as visited (set to 1)\\n                    grid[neighbour_row][neighbour_col] = 1\\n                    queue.append((neighbour_row, neighbour_col, path_len + 1))\\n\\n        # No clear path found\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584254,
                "title": "java-solution-for-shortest-path-in-binary-matrix-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The goal is to find the shortest clear path from the top-left cell to the bottom-right cell in the binary matrix.\\n- A clear path consists of cells with a value of 0, and adjacent cells are considered 8-directionally connected.\\n- The BFS algorithm is used to explore cells in a breadth-first manner, starting from the top-left cell and moving towards the bottom-right cell.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The algorithm starts by checking if the top-left and bottom-right cells are obstacles (1). If either of them is an obstacle, there is no clear path, and -1 is returned.\\n1. A directions array is defined to represent the 8 possible directions to explore neighboring cells.\\n1. A queue is initialized, and the top-left cell is added to the queue as the starting point.\\n1. The grid is updated to mark the starting cell as visited.\\n1. A pathLength variable is initialized to track the length of the path.\\n1. The algorithm enters a while loop until the queue becomes empty:\\n- The size of the current level is obtained from the queue.\\n- For each cell in the current level:\\n- If the cell is the bottom-right cell, the pathLength is returned as the shortest clear path.\\n- For each direction in the directions array:\\n- The neighboring cell coordinates are calculated based on the current cell and the direction.\\n- If the neighboring cell is within the grid boundaries, has a value of 0, and hasn\\'t been visited:\\n- The neighboring cell is added to the queue.\\n- The neighboring cell is marked as visited in the grid.\\n7. The pathLength is incremented to move to the next level.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the BFS algorithm is O(V + E), where V is the number of vertices (cells) and E is the number of edges (adjacent connections). In this case, V represents the number of cells in the grid, which is n^2, and E is proportional to V, as each cell has at most 8 neighbors in the 8-directional connectivity. Therefore, the time complexity is O(n^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the queue and the grid. The queue can store at most n^2 cells in the worst case, resulting in O(n^2) space. The grid uses O(n^2) space as well to represent the visited status of each cell. Hence, the overall space complexity is O(n^2).\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n         int n = grid.length;\\n        if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) {\\n            return -1; // There is no clear path from the start to the end\\n        }\\n\\n        int[][] directions = {\\n            {-1, -1}, {-1, 0}, {-1, 1},\\n            {0, -1},           {0, 1},\\n            {1, -1},  {1, 0},  {1, 1}\\n        };\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0}); // Start from the top-left cell\\n        grid[0][0] = 1; // Mark the starting cell as visited\\n\\n        int pathLength = 1;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] cell = queue.poll();\\n                int row = cell[0];\\n                int col = cell[1];\\n\\n                if (row == n - 1 && col == n - 1) {\\n                    return pathLength; // Reached the bottom-right cell, return the path length\\n                }\\n\\n                for (int[] direction : directions) {\\n                    int newRow = row + direction[0];\\n                    int newCol = col + direction[1];\\n\\n                    if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                        queue.offer(new int[]{newRow, newCol});\\n                        grid[newRow][newCol] = 1; // Mark the cell as visited\\n                    }\\n                }\\n            }\\n\\n            pathLength++;\\n        }\\n\\n        return -1; // There is no clear path from the start to the end\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n         int n = grid.length;\\n        if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) {\\n            return -1; // There is no clear path from the start to the end\\n        }\\n\\n        int[][] directions = {\\n            {-1, -1}, {-1, 0}, {-1, 1},\\n            {0, -1},           {0, 1},\\n            {1, -1},  {1, 0},  {1, 1}\\n        };\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0}); // Start from the top-left cell\\n        grid[0][0] = 1; // Mark the starting cell as visited\\n\\n        int pathLength = 1;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] cell = queue.poll();\\n                int row = cell[0];\\n                int col = cell[1];\\n\\n                if (row == n - 1 && col == n - 1) {\\n                    return pathLength; // Reached the bottom-right cell, return the path length\\n                }\\n\\n                for (int[] direction : directions) {\\n                    int newRow = row + direction[0];\\n                    int newCol = col + direction[1];\\n\\n                    if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                        queue.offer(new int[]{newRow, newCol});\\n                        grid[newRow][newCol] = 1; // Mark the cell as visited\\n                    }\\n                }\\n            }\\n\\n            pathLength++;\\n        }\\n\\n        return -1; // There is no clear path from the start to the end\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442502,
                "title": "shortest-path-with-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass pair{\\n    int first,second,third;\\n    pair(int first,int second,int third)\\n    {\\n        this.first=first;\\n        this.second=second;\\n        this.third=third;\\n    }\\n}\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n=grid.length;\\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0){\\n            return -1;\\n        }\\n        if(n-1==0)return 1;\\n        Queue<pair> q =new LinkedList<>();\\n        int dis[][]=new int[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dis[i][j]=Integer.MAX_VALUE;\\n            }\\n        }\\n        dis[0][0]=0;\\n        q.add(new pair(0,0,0));\\n        int dr[] = {0, -1, -1, -1, 0, 1, 1, 1};\\n        int[] dc = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        while(!q.isEmpty()){\\n            pair p=q.peek();\\n            q.poll();\\n            int k=p.first;\\n            int y=p.second;\\n            int z=p.third;\\n            for(int i=0;i<8;i++)\\n            {\\n                int nr=y+dr[i];\\n                int nc=z+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<n && grid[nr][nc]==0 && k+1<dis[nr][nc]){\\n                    dis[nr][nc]=k+1;\\n                    if(nr==n-1 && nc==n-1){\\n                        return k+2;\\n                    }\\n                    q.add(new pair(k+1,nr,nc));\\n                }\\n            }\\n        }\\n        return -1;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass pair{\\n    int first,second,third;\\n    pair(int first,int second,int third)\\n    {\\n        this.first=first;\\n        this.second=second;\\n        this.third=third;\\n    }\\n}\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n=grid.length;\\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0){\\n            return -1;\\n        }\\n        if(n-1==0)return 1;\\n        Queue<pair> q =new LinkedList<>();\\n        int dis[][]=new int[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dis[i][j]=Integer.MAX_VALUE;\\n            }\\n        }\\n        dis[0][0]=0;\\n        q.add(new pair(0,0,0));\\n        int dr[] = {0, -1, -1, -1, 0, 1, 1, 1};\\n        int[] dc = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        while(!q.isEmpty()){\\n            pair p=q.peek();\\n            q.poll();\\n            int k=p.first;\\n            int y=p.second;\\n            int z=p.third;\\n            for(int i=0;i<8;i++)\\n            {\\n                int nr=y+dr[i];\\n                int nc=z+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<n && grid[nr][nc]==0 && k+1<dis[nr][nc]){\\n                    dis[nr][nc]=k+1;\\n                    if(nr==n-1 && nc==n-1){\\n                        return k+2;\\n                    }\\n                    q.add(new pair(k+1,nr,nc));\\n                }\\n            }\\n        }\\n        return -1;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417571,
                "title": "bfs-dijkstra-logic-python-explained",
                "content": "# Intuition\\ncreate a distance matrix of size grid and run a bfs over it\\nfor every new visit of node if we find the curr vist + 1 < prev distance stored then update the distance (as a shorter path is available)\\n`why curr vist + 1 ? Becuase cost of visiting each new cell is 1`\\nreturn the value stored in the last cell as the smallest cost required to reach the path.\\n\\n**NOTE -> unlike other graph questions u can visit here diagonals too so make the directions array accordingly**\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        # BASE CASE ->\\n        if grid[0][0] != 0 or grid[-1][-1] != 0: \\n            return -1\\n\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        directions = [(-1, 0), (0, 1), (1, 0), (0, -1), (1, -1), (-1, -1), (-1, 1), (1, 1)]\\n        q = deque()\\n        distance = [[float(\\'inf\\')] * (COLS) for _ in range(ROWS)]\\n\\n        distance[0][0] = 1 # starting cost is 1\\n        q.append((0, 0, distance[0][0])) #currRow, currCol, currDistance      \\n        \\n        while q:\\n            currRow, currCol, currDistance = q.popleft()\\n            for dr, dc in directions:\\n                r = currRow + dr\\n                c = currCol + dc\\n                if r in range(ROWS) and c in range(COLS) and grid[r][c] == 0:\\n                    if distance[r][c] > currDistance + 1: \\n                        distance[r][c] = currDistance + 1 #update distance if smaller found\\n                        q.append((r, c, distance[r][c]))\\n        if distance[-1][-1] == float(\\'inf\\'): #path not possible\\n            return -1\\n        return distance[-1][-1]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        # BASE CASE ->\\n        if grid[0][0] != 0 or grid[-1][-1] != 0: \\n            return -1\\n\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        directions = [(-1, 0), (0, 1), (1, 0), (0, -1), (1, -1), (-1, -1), (-1, 1), (1, 1)]\\n        q = deque()\\n        distance = [[float(\\'inf\\')] * (COLS) for _ in range(ROWS)]\\n\\n        distance[0][0] = 1 # starting cost is 1\\n        q.append((0, 0, distance[0][0])) #currRow, currCol, currDistance      \\n        \\n        while q:\\n            currRow, currCol, currDistance = q.popleft()\\n            for dr, dc in directions:\\n                r = currRow + dr\\n                c = currCol + dc\\n                if r in range(ROWS) and c in range(COLS) and grid[r][c] == 0:\\n                    if distance[r][c] > currDistance + 1: \\n                        distance[r][c] = currDistance + 1 #update distance if smaller found\\n                        q.append((r, c, distance[r][c]))\\n        if distance[-1][-1] == float(\\'inf\\'): #path not possible\\n            return -1\\n        return distance[-1][-1]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351602,
                "title": "bfs-dijkstra-approaches",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# BFS\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size(); int m= grid[0].size();\\n        int lvl=0;\\n        int dx[]= {0,0,1,1,1,-1,-1,-1};\\n        int dy[]= {1,-1,0,1,-1,0,1,-1};\\n        queue<pair<int,int>> q; \\n        q.push({0,0});\\n        if (grid[0][0]==1)return -1;\\n        \\n        while (!q.empty()){\\n            int sz= q.size();\\n            lvl++;\\n            for (int i=0; i<sz; i++){\\n                int x= q.front().first;\\n                int y= q.front().second;\\n                \\n                if (x==n-1 && y==m-1)return lvl;\\n                q.pop();\\n                for (int it=0; it<8; it++){\\n                    int nr= x+dx[it];\\n                    int nc= y+dy[it];\\n                    if (nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]==0){\\n                        grid[nr][nc]=1;\\n                        q.push({nr,nc});\\n                        //if (nr==n-1 && nc==m-1)return lvl+1;\\n                    }\\n                }\\n            }\\n            //lvl++;\\n        }\\n        return -1;\\n    }\\n}; \\n```\\n\\n\\n# DIJKSTRA\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int dx[]= {0,0,1,1,1,-1,-1,-1};\\n        int dy[]= {1,-1,0,1,-1,0,1,-1};\\n        if (grid[0][0]==1)return -1;\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({0,{0,0}});\\n        while (!pq.empty()){\\n            auto top= pq.top();\\n            pq.pop();\\n            int dis= top.first;\\n            int x= top.second.first;\\n            int y= top.second.second;\\n            if (x==n-1 && y==n-1)return dis+1;\\n            for (int it=0; it<8; it++){\\n                int xx= x+dx[it];\\n                int yy= y+dy[it];\\n                if (xx>=0 && xx<n && yy>=0 && yy<n && grid[xx][yy]==0){\\n                    pq.push({dis+1,{xx,yy}});\\n                    grid[xx][yy]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size(); int m= grid[0].size();\\n        int lvl=0;\\n        int dx[]= {0,0,1,1,1,-1,-1,-1};\\n        int dy[]= {1,-1,0,1,-1,0,1,-1};\\n        queue<pair<int,int>> q; \\n        q.push({0,0});\\n        if (grid[0][0]==1)return -1;\\n        \\n        while (!q.empty()){\\n            int sz= q.size();\\n            lvl++;\\n            for (int i=0; i<sz; i++){\\n                int x= q.front().first;\\n                int y= q.front().second;\\n                \\n                if (x==n-1 && y==m-1)return lvl;\\n                q.pop();\\n                for (int it=0; it<8; it++){\\n                    int nr= x+dx[it];\\n                    int nc= y+dy[it];\\n                    if (nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]==0){\\n                        grid[nr][nc]=1;\\n                        q.push({nr,nc});\\n                        //if (nr==n-1 && nc==m-1)return lvl+1;\\n                    }\\n                }\\n            }\\n            //lvl++;\\n        }\\n        return -1;\\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int dx[]= {0,0,1,1,1,-1,-1,-1};\\n        int dy[]= {1,-1,0,1,-1,0,1,-1};\\n        if (grid[0][0]==1)return -1;\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({0,{0,0}});\\n        while (!pq.empty()){\\n            auto top= pq.top();\\n            pq.pop();\\n            int dis= top.first;\\n            int x= top.second.first;\\n            int y= top.second.second;\\n            if (x==n-1 && y==n-1)return dis+1;\\n            for (int it=0; it<8; it++){\\n                int xx= x+dx[it];\\n                int yy= y+dy[it];\\n                if (xx>=0 && xx<n && yy>=0 && yy<n && grid[xx][yy]==0){\\n                    pq.push({dis+1,{xx,yy}});\\n                    grid[xx][yy]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204526,
                "title": "c-bfs-implementation-64ms-88-beaten",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe description of the question boils down to finding the shortest path of an unweighted and undirected graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThis solution is an implementation of **Breadth First Search** (BFS) where the **visited** and **distance** are 2D arrays. The start index `grid[0][0]` should be checked if it\\'s `1`, in which a solution is **not possible**. \\n\\n##### Breakdown of BFS\\n---\\n1. Push start into the queue, set `visited[start] = true` and `dist[start] = 1`\\n2. Explore all possible edges that the current edge leads to, in this case, it\\'s the 8 possible cells that are adjacent to the current edge\\n3. Add the candidate edges to the queue. Set `distance[new] = distance[current] + 1` and `visited[new] = true`\\n4. Repeat 2-3 until queue is empty\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    pair<int, int> d[8]{{0,1}, {0,-1}, {-1,-1}, {-1,0}, {-1, 1}, {1,-1}, {1,0}, {1,1}}; // Possible Changes in Location\\n\\n    int v[101][101], dist[101][101]; // Visited (v) and Distance (dist)\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> q; // BFS queue\\n        int size = grid.size();\\n\\n        if (grid[0][0]) return -1;\\n\\n        v[0][0] = true; dist[0][0] = 1; q.emplace(0, 0);\\n\\n        while (!q.empty()) {\\n            auto [r, c] = q.front(); q.pop();\\n\\n            for (auto& [dr, dc] : d) {\\n                int nr = r + dr, nc = c + dc;\\n\\n                if (nr >= 0 && nc >= 0 && nr < size && nc < size && !v[nr][nc] && !grid[nr][nc]) {\\n                    v[nr][nc] = 1;\\n                    q.emplace(nr, nc);\\n                    dist[nr][nc] = dist[r][c] + 1;\\n                }\\n            }\\n        }\\n\\n        return (v[size-1][size-1] ? dist[size-1][size-1] : -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    pair<int, int> d[8]{{0,1}, {0,-1}, {-1,-1}, {-1,0}, {-1, 1}, {1,-1}, {1,0}, {1,1}}; // Possible Changes in Location\\n\\n    int v[101][101], dist[101][101]; // Visited (v) and Distance (dist)\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> q; // BFS queue\\n        int size = grid.size();\\n\\n        if (grid[0][0]) return -1;\\n\\n        v[0][0] = true; dist[0][0] = 1; q.emplace(0, 0);\\n\\n        while (!q.empty()) {\\n            auto [r, c] = q.front(); q.pop();\\n\\n            for (auto& [dr, dc] : d) {\\n                int nr = r + dr, nc = c + dc;\\n\\n                if (nr >= 0 && nc >= 0 && nr < size && nc < size && !v[nr][nc] && !grid[nr][nc]) {\\n                    v[nr][nc] = 1;\\n                    q.emplace(nr, nc);\\n                    dist[nr][nc] = dist[r][c] + 1;\\n                }\\n            }\\n        }\\n\\n        return (v[size-1][size-1] ? dist[size-1][size-1] : -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195760,
                "title": "c-using-bfs-t-c-o-n-2-s-c-o-n-2",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity = O(N^2)\\n        Space Complexity = O(N^2)\\n    */\\n    \\n    int m, n;\\n    \\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        if(i>=0 && j>=0 && i<m && j<n && grid[i][j] == 0) return true;\\n        else return false;\\n    }\\n    \\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dist(m, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q1;\\n        \\n        if(grid[0][0] == 0){\\n            q1.push({0, 0});\\n            dist[0][0] = 1;\\n        }else\\n            return -1;\\n        \\n        // Directions\\n        vector<int> x = {-1, +1, 0, 0, -1, +1, -1, +1};\\n        vector<int> y = {0, 0, -1, +1, -1, +1, +1, -1};\\n        \\n        while(!q1.empty()){\\n            pair<int, int> curr = q1.front();\\n            q1.pop();\\n            \\n            for(int k=0; k<8; k++){\\n                int newX = curr.first + x[k];\\n                int newY = curr.second + y[k];\\n                \\n                if(isValid(newX, newY, grid) && dist[newX][newY]==-1){\\n                    dist[newX][newY] = dist[curr.first][curr.second]+1;\\n                    q1.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        if(dist[m-1][n-1] == -1)\\n            return -1;\\n        \\n        return dist[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity = O(N^2)\\n        Space Complexity = O(N^2)\\n    */\\n    \\n    int m, n;\\n    \\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        if(i>=0 && j>=0 && i<m && j<n && grid[i][j] == 0) return true;\\n        else return false;\\n    }\\n    \\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dist(m, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q1;\\n        \\n        if(grid[0][0] == 0){\\n            q1.push({0, 0});\\n            dist[0][0] = 1;\\n        }else\\n            return -1;\\n        \\n        // Directions\\n        vector<int> x = {-1, +1, 0, 0, -1, +1, -1, +1};\\n        vector<int> y = {0, 0, -1, +1, -1, +1, +1, -1};\\n        \\n        while(!q1.empty()){\\n            pair<int, int> curr = q1.front();\\n            q1.pop();\\n            \\n            for(int k=0; k<8; k++){\\n                int newX = curr.first + x[k];\\n                int newY = curr.second + y[k];\\n                \\n                if(isValid(newX, newY, grid) && dist[newX][newY]==-1){\\n                    dist[newX][newY] = dist[curr.first][curr.second]+1;\\n                    q1.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        if(dist[m-1][n-1] == -1)\\n            return -1;\\n        \\n        return dist[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126325,
                "title": "bfs-hindi-m-explain-c-easy",
                "content": "# Intuition\\nhar ek node par jana h jo ki 0 h ,aur 0 ke connected path m h\\nhum ise bfs se solve krnege\\n\\n# Approach\\nbfs ka use krke hum solve kr rahe h\\nsteps wise approach solution ke sath commented h\\n# Complexity\\n- Time complexity:\\nO(d) d is the no of zeroes\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // sabhi directions main badhne ke liye\\n    int mr[8][2]={\\n        {1,0},{-1,0},{0,1},{0,-1},{-1,-1},{1,1},{-1,1},{1,-1}\\n    };\\n\\n    // row aur col ka size store krne ke liye\\n    int row,col;\\n\\n    //actual bfs apply krne ke liye\\n    int solve(vector<vector<int>>&grid){\\n\\n        //A grid ka starting ya ending dono hi agar 1 h to hum kabhi path ni bana skte isliye -1 return krdo\\n        if(grid[0][0] || grid[row-1][col-1] ) return -1;\\n\\n        // ab agar grid m sirf ek hi element h to matlab starting or ending ek hi jagah h\\n        // aur ye element 0 hi hoga qki agar 1 hota to phle hi -1 return kr diya hota\\n        // qki ye ek hi element path m h isliye 1 return hoga ( yaha row = col =1  hai)\\n        if(row==col && row == 1) return row;\\n\\n        // check krne ke liye ki hum curr node ko visit kr chuke h ya nahi \\n        vector<vector<bool>> ch(row,vector<bool>(col,false));\\n\\n        // yaha humne queue to pair of pair is liye bana h qki \\n        // main pair group h location of cell or distance staring se \\n        // inner pair humari location bata rha h\\n        // { { x coordinate , y coordinate} , distance starting se }\\n        queue<pair<pair<int,int>,int>> q;\\n\\n        // answer mann liya bahut bada h\\n        int ans=INT_MAX;\\n\\n        // queue m starting position ko push krke uski location ko visited mark kr diya\\n        q.push({{0,0},1});\\n        ch[0][0]=1;\\n\\n        // ab bfs apply krte h\\n        while(!q.empty()){\\n\\n            // queue ke front m node h usse coordinates nikal lete h aur distance bhi \\n            // r humara current x coordinate h\\n            // c humara cuurent y coordinate h\\n            // d humara current node ka starting se dist h\\n            // akhir m humne queue se node pop kr diya\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int d = q.front().second;\\n            q.pop();\\n\\n            // ab curr location se har direction m connected nodes ki location nikalenge \\n            for(int i=0;i<8;i++){\\n\\n                //next location ke x or y coordinates \\n                int x = r + mr[i][0];\\n                int y = c + mr[i][1];\\n\\n                //ab hum check krenge ki humara node grid ke andar hi h na\\n                // aur agar andar h to wo nahi visited hua ho aur nahi usme 1 ho \\n                // matlab ki uska visited false ho aur grid mein x,y location pe 0 ho\\n                if(x<row && y<col && x>=0 && y>=0 && !ch[x][y] && !grid[x][y]){\\n                    \\n                    //agar sari condition sahi h to node ko visited mark krdo\\n                    ch[x][y]=true;\\n\\n                    // check kro agar humare next node destination yane row-1,col-1 node to nahi\\n                    // agar hn to ans, ya dis+1 m se chote distance ko return krdo\\n                    // yaha d+1 isliye kiya h qki d jo h wo current node ka distace h\\n                    // to next node ka distance d+1\\n                    if(x==row-1 && y==col-1 ) return min(ans,d+1);\\n\\n                    //aur agar ye destination ni h to queue m location or increse ki hui distance ka pair banake push krdo\\n                    q.push({{x,y},d+1});\\n                }\\n            }\\n        }\\n\\n        // hume path nahi milega tb hum yaha tk ayenge\\n        // isliye -1 return krdo\\n        return -1;\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n      row = grid.size();\\n      col = grid[0].size();\\n         \\n        return solve(grid);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // sabhi directions main badhne ke liye\\n    int mr[8][2]={\\n        {1,0},{-1,0},{0,1},{0,-1},{-1,-1},{1,1},{-1,1},{1,-1}\\n    };\\n\\n    // row aur col ka size store krne ke liye\\n    int row,col;\\n\\n    //actual bfs apply krne ke liye\\n    int solve(vector<vector<int>>&grid){\\n\\n        //A grid ka starting ya ending dono hi agar 1 h to hum kabhi path ni bana skte isliye -1 return krdo\\n        if(grid[0][0] || grid[row-1][col-1] ) return -1;\\n\\n        // ab agar grid m sirf ek hi element h to matlab starting or ending ek hi jagah h\\n        // aur ye element 0 hi hoga qki agar 1 hota to phle hi -1 return kr diya hota\\n        // qki ye ek hi element path m h isliye 1 return hoga ( yaha row = col =1  hai)\\n        if(row==col && row == 1) return row;\\n\\n        // check krne ke liye ki hum curr node ko visit kr chuke h ya nahi \\n        vector<vector<bool>> ch(row,vector<bool>(col,false));\\n\\n        // yaha humne queue to pair of pair is liye bana h qki \\n        // main pair group h location of cell or distance staring se \\n        // inner pair humari location bata rha h\\n        // { { x coordinate , y coordinate} , distance starting se }\\n        queue<pair<pair<int,int>,int>> q;\\n\\n        // answer mann liya bahut bada h\\n        int ans=INT_MAX;\\n\\n        // queue m starting position ko push krke uski location ko visited mark kr diya\\n        q.push({{0,0},1});\\n        ch[0][0]=1;\\n\\n        // ab bfs apply krte h\\n        while(!q.empty()){\\n\\n            // queue ke front m node h usse coordinates nikal lete h aur distance bhi \\n            // r humara current x coordinate h\\n            // c humara cuurent y coordinate h\\n            // d humara current node ka starting se dist h\\n            // akhir m humne queue se node pop kr diya\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int d = q.front().second;\\n            q.pop();\\n\\n            // ab curr location se har direction m connected nodes ki location nikalenge \\n            for(int i=0;i<8;i++){\\n\\n                //next location ke x or y coordinates \\n                int x = r + mr[i][0];\\n                int y = c + mr[i][1];\\n\\n                //ab hum check krenge ki humara node grid ke andar hi h na\\n                // aur agar andar h to wo nahi visited hua ho aur nahi usme 1 ho \\n                // matlab ki uska visited false ho aur grid mein x,y location pe 0 ho\\n                if(x<row && y<col && x>=0 && y>=0 && !ch[x][y] && !grid[x][y]){\\n                    \\n                    //agar sari condition sahi h to node ko visited mark krdo\\n                    ch[x][y]=true;\\n\\n                    // check kro agar humare next node destination yane row-1,col-1 node to nahi\\n                    // agar hn to ans, ya dis+1 m se chote distance ko return krdo\\n                    // yaha d+1 isliye kiya h qki d jo h wo current node ka distace h\\n                    // to next node ka distance d+1\\n                    if(x==row-1 && y==col-1 ) return min(ans,d+1);\\n\\n                    //aur agar ye destination ni h to queue m location or increse ki hui distance ka pair banake push krdo\\n                    q.push({{x,y},d+1});\\n                }\\n            }\\n        }\\n\\n        // hume path nahi milega tb hum yaha tk ayenge\\n        // isliye -1 return krdo\\n        return -1;\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n      row = grid.size();\\n      col = grid[0].size();\\n         \\n        return solve(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092363,
                "title": "easy-to-understand-c-solution-with-explanation-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Intution is very simple where we have to traverse all the cells and check for all the 0 cell to make the clear path ( as termed in the question). \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Get the boundary condition check first so that we can avoid the unnecessary calls.\\n2. since we have to traverse in all the 8 direction, create the array of points using simple geometry.\\n3. run the standard BFS algorithm.\\n\\n# Complexity\\n- Time complexity: O(N)*O(M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:)(N)*O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // getting the size of rows and cols\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        // creating the visited array to keep track of traversal\\n        vector<vector<int>> vis(rows,vector<int>(cols,0));\\n        // creating a queue to hold the row,col and distance \\n        queue<pair<pair<int,int>,int>> q;\\n        // checking the initial condition\\n        if(grid[0][0]!=0 || grid[rows-1][cols-1]!=0) return -1;\\n        // staring the BFS with setting the q with initial postion and distance\\n        q.push({{0,0},0});\\n        // marking the visited array position\\n        vis[0][0] =1;\\n        // untill q is not empty\\n        while(!q.empty()){\\n            //getting the row postion from the queue\\n            int sr = q.front().first.first;\\n            //getting the col postion from the queue\\n            int sc = q.front().first.second;\\n            // //getting the distance from the queue\\n            int distance = q.front().second;\\n            q.pop();\\n            //checking if final postion reached, if yes return distance+1\\n            if(sr==rows-1 and sc== cols-1) return distance+1;\\n            // created the delrow and delcol array with all the 8 direction values\\n            int delrow[] = {1,0,-1,-1,-1,0,1,1};\\n            int delcol[] = {-1,-1,-1,0,1,1,1,0};\\n            // checking all 8 direction from current postion\\n            for(int i=0;i<8;i++){\\n                int drow = sr + delrow[i];\\n                int dcol = sc + delcol[i];\\n                // Again checking the valid values before pushing the values on the queue\\n                if(drow>= 0 && drow<rows && dcol>=0 && dcol<cols && \\n                grid[drow][dcol]==0 && vis[drow][dcol]==0){\\n                    //pushing it into the queue and marking visited.\\n                    q.push({{drow,dcol},distance+1});\\n                    vis[drow][dcol]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n# IF THIS IS HELPFUL, PLEASE UPVOTE!!!\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // getting the size of rows and cols\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        // creating the visited array to keep track of traversal\\n        vector<vector<int>> vis(rows,vector<int>(cols,0));\\n        // creating a queue to hold the row,col and distance \\n        queue<pair<pair<int,int>,int>> q;\\n        // checking the initial condition\\n        if(grid[0][0]!=0 || grid[rows-1][cols-1]!=0) return -1;\\n        // staring the BFS with setting the q with initial postion and distance\\n        q.push({{0,0},0});\\n        // marking the visited array position\\n        vis[0][0] =1;\\n        // untill q is not empty\\n        while(!q.empty()){\\n            //getting the row postion from the queue\\n            int sr = q.front().first.first;\\n            //getting the col postion from the queue\\n            int sc = q.front().first.second;\\n            // //getting the distance from the queue\\n            int distance = q.front().second;\\n            q.pop();\\n            //checking if final postion reached, if yes return distance+1\\n            if(sr==rows-1 and sc== cols-1) return distance+1;\\n            // created the delrow and delcol array with all the 8 direction values\\n            int delrow[] = {1,0,-1,-1,-1,0,1,1};\\n            int delcol[] = {-1,-1,-1,0,1,1,1,0};\\n            // checking all 8 direction from current postion\\n            for(int i=0;i<8;i++){\\n                int drow = sr + delrow[i];\\n                int dcol = sc + delcol[i];\\n                // Again checking the valid values before pushing the values on the queue\\n                if(drow>= 0 && drow<rows && dcol>=0 && dcol<cols && \\n                grid[drow][dcol]==0 && vis[drow][dcol]==0){\\n                    //pushing it into the queue and marking visited.\\n                    q.push({{drow,dcol},distance+1});\\n                    vis[drow][dcol]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n# IF THIS IS HELPFUL, PLEASE UPVOTE!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958483,
                "title": "c-solution-dijkstra-s-algorithm",
                "content": "# Please Upvote If You Find It Helpful.\\n# Approach: Using Dijkstral\\'s Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0]==1)\\n            return -1;\\n        int n = grid.size();\\n        vector<vector<int>> dis(n, vector<int>(n, 1e9));\\n        dis[0][0] = 1;\\n        queue<pair<int, pair<int, int>>> q;\\n        // {dis, {r, c}}\\n        q.push({1, {0, 0}});\\n        int drow[] = {-1, 1, 0 ,0, -1, 1, 1, -1}, dcol[] = {0, 0, -1, 1, -1, -1, 1, 1};\\n        while(!q.empty()){\\n            auto it = q.front();\\n            auto ver = it.second;\\n            int dist = it.first, r = ver.first, c = ver.second;\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int nrow = r + drow[i], ncol = c + dcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<n && grid[nrow][ncol]==0){\\n                    if(dis[nrow][ncol] > dist + 1){\\n                        dis[nrow][ncol] = dist+1;\\n                        q.push({dis[nrow][ncol], {nrow, ncol}});\\n                    }\\n                }\\n            }\\n        }\\n        if(dis[n-1][n-1]!=1e9)\\n            return dis[n-1][n-1];\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0]==1)\\n            return -1;\\n        int n = grid.size();\\n        vector<vector<int>> dis(n, vector<int>(n, 1e9));\\n        dis[0][0] = 1;\\n        queue<pair<int, pair<int, int>>> q;\\n        // {dis, {r, c}}\\n        q.push({1, {0, 0}});\\n        int drow[] = {-1, 1, 0 ,0, -1, 1, 1, -1}, dcol[] = {0, 0, -1, 1, -1, -1, 1, 1};\\n        while(!q.empty()){\\n            auto it = q.front();\\n            auto ver = it.second;\\n            int dist = it.first, r = ver.first, c = ver.second;\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int nrow = r + drow[i], ncol = c + dcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<n && grid[nrow][ncol]==0){\\n                    if(dis[nrow][ncol] > dist + 1){\\n                        dis[nrow][ncol] = dist+1;\\n                        q.push({dis[nrow][ncol], {nrow, ncol}});\\n                    }\\n                }\\n            }\\n        }\\n        if(dis[n-1][n-1]!=1e9)\\n            return dis[n-1][n-1];\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939321,
                "title": "faster-than-98-bfs-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nVisit in all possible 8 directions and update their distacnes from (0,0) by following BFS approach. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0]==1||grid[n-1][n-1]==1)\\n        {\\n            return -1;\\n        }\\n        queue<pair<int,int>>q;\\n        int dis[n][n];\\n        bool vis[n][n];\\n        memset(vis,false,sizeof(vis));\\n        memset(dis,0,sizeof(dis));\\n        dis[0][0]=1;\\n        q.push({0,0});\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            int i=p.first,j=p.second;\\n            q.pop();\\n            //vis[i][j]=true;\\n            //for(auto child:adj[{i,j}])\\n            {\\n                //if(!vis[i][j])\\n                {\\n                    if(i+1<n&&!vis[i+1][j]&&grid[i+1][j]==0)\\n                    {\\n                        vis[i+1][j]=true;\\n                        dis[i+1][j]=dis[i][j]+1;\\n                        q.push({i+1,j});\\n                    }\\n                    if(i-1>=0&&!vis[i-1][j]&&grid[i-1][j]==0)\\n                    {\\n                        vis[i-1][j]=true;\\n                        dis[i-1][j]=dis[i][j]+1;\\n                        q.push({i-1,j});\\n                    }\\n                    if(j+1<n&&!vis[i][j+1]&&grid[i][j+1]==0)\\n                    {\\n                        vis[i][j+1]=true;\\n                        dis[i][j+1]=dis[i][j]+1;\\n                        q.push({i,j+1});\\n                    }\\n                    if(j-1>=0&&!vis[i][j-1]&&grid[i][j-1]==0)\\n                    {\\n                        vis[i][j-1]=true;\\n                        dis[i][j-1]=dis[i][j]+1;\\n                        q.push({i,j-1});\\n                    }\\n                    if(i+1<n&&j+1<n&&!vis[i+1][j+1]&&grid[i+1][j+1]==0)\\n                    {\\n                        vis[i+1][j+1]=true;\\n                        dis[i+1][j+1]=dis[i][j]+1;\\n                        q.push({i+1,j+1});\\n                    }\\n                    if(i-1>=0&&j+1<n&&!vis[i-1][j+1]&&grid[i-1][j+1]==0)\\n                    {\\n                        vis[i-1][j+1]=true;\\n                        dis[i-1][j+1]=dis[i][j]+1;\\n                        q.push({i-1,j+1});\\n                    }\\n                    if(i-1>=0&&j-1>=0&&!vis[i-1][j-1]&&grid[i-1][j-1]==0)\\n                    {\\n                        vis[i-1][j-1]=true;\\n                        dis[i-1][j-1]=dis[i][j]+1;\\n                        q.push({i-1,j-1});\\n                    }\\n                    if(i+1<n&&j-1>=0&&!vis[i+1][j-1]&&grid[i+1][j-1]==0)\\n                    {\\n                        vis[i+1][j-1]=true;\\n                        dis[i+1][j-1]=dis[i][j]+1;\\n                        q.push({i+1,j-1});\\n                    }\\n                }\\n            }\\n        }\\n        if(dis[n-1][n-1]) return dis[n-1][n-1];\\n        else return -1;\\n    }\\n};\\n```\\nPls upvote if find useful:)",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0]==1||grid[n-1][n-1]==1)\\n        {\\n            return -1;\\n        }\\n        queue<pair<int,int>>q;\\n        int dis[n][n];\\n        bool vis[n][n];\\n        memset(vis,false,sizeof(vis));\\n        memset(dis,0,sizeof(dis));\\n        dis[0][0]=1;\\n        q.push({0,0});\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            int i=p.first,j=p.second;\\n            q.pop();\\n            //vis[i][j]=true;\\n            //for(auto child:adj[{i,j}])\\n            {\\n                //if(!vis[i][j])\\n                {\\n                    if(i+1<n&&!vis[i+1][j]&&grid[i+1][j]==0)\\n                    {\\n                        vis[i+1][j]=true;\\n                        dis[i+1][j]=dis[i][j]+1;\\n                        q.push({i+1,j});\\n                    }\\n                    if(i-1>=0&&!vis[i-1][j]&&grid[i-1][j]==0)\\n                    {\\n                        vis[i-1][j]=true;\\n                        dis[i-1][j]=dis[i][j]+1;\\n                        q.push({i-1,j});\\n                    }\\n                    if(j+1<n&&!vis[i][j+1]&&grid[i][j+1]==0)\\n                    {\\n                        vis[i][j+1]=true;\\n                        dis[i][j+1]=dis[i][j]+1;\\n                        q.push({i,j+1});\\n                    }\\n                    if(j-1>=0&&!vis[i][j-1]&&grid[i][j-1]==0)\\n                    {\\n                        vis[i][j-1]=true;\\n                        dis[i][j-1]=dis[i][j]+1;\\n                        q.push({i,j-1});\\n                    }\\n                    if(i+1<n&&j+1<n&&!vis[i+1][j+1]&&grid[i+1][j+1]==0)\\n                    {\\n                        vis[i+1][j+1]=true;\\n                        dis[i+1][j+1]=dis[i][j]+1;\\n                        q.push({i+1,j+1});\\n                    }\\n                    if(i-1>=0&&j+1<n&&!vis[i-1][j+1]&&grid[i-1][j+1]==0)\\n                    {\\n                        vis[i-1][j+1]=true;\\n                        dis[i-1][j+1]=dis[i][j]+1;\\n                        q.push({i-1,j+1});\\n                    }\\n                    if(i-1>=0&&j-1>=0&&!vis[i-1][j-1]&&grid[i-1][j-1]==0)\\n                    {\\n                        vis[i-1][j-1]=true;\\n                        dis[i-1][j-1]=dis[i][j]+1;\\n                        q.push({i-1,j-1});\\n                    }\\n                    if(i+1<n&&j-1>=0&&!vis[i+1][j-1]&&grid[i+1][j-1]==0)\\n                    {\\n                        vis[i+1][j-1]=true;\\n                        dis[i+1][j-1]=dis[i][j]+1;\\n                        q.push({i+1,j-1});\\n                    }\\n                }\\n            }\\n        }\\n        if(dis[n-1][n-1]) return dis[n-1][n-1];\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927775,
                "title": "simple-and-detailed-djkistra-s-shortest-path-based-approach-beats-90",
                "content": "# Intuition\\n**Simple Djkistra Shortest Path Algorithm**\\n\\n# Approach\\n1.We need a distance vector with the same dimension as the grid matrix.\\n2.Queue to store [Distance][Row][Col]\\n3.Initial configuration: \\n    Matrix[0][0]=1 \\n    Queue having [1][0][0] as the first entry\\n4.Run the Djikstra,s algorithm in 8 directions \\n5.return the shortest path to the node[n-1][n-1]\\n\\n\\n# Complexity\\n- Time complexity:\\nSame complexity as Djiktra\\'s:\\nO((E+V)log(V)) where E->no of edges and V->no of vertices\\n\\n- Space complexity:\\nO(n^2)+O(n) for the distance matrix and the queue respectively\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        if(grid[0][0]==1)return -1;\\n        //defining starting and ending nodes\\n        int srow=0;\\n        int scol=0;\\n        int trow=grid.size()-1;\\n        int tcol=grid[0].size()-1;\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //defining the initial configuration\\n        vector<vector<int>>dist(m,vector<int>(n,1e9));//distance matrix\\n        dist[srow][scol]=1;\\n        queue<pair<int,pair<int,int>>>q;//queue: dist,row,col\\n        q.push({1,{0,0}});\\n        \\n        //defining the movements\\n        int drow[]={-1,-1,0,1,1,1,0,-1};\\n        int dcol[]={0,1,1,1,0,-1,-1,-1};\\n\\n        //djkistra implementation\\n        while(!q.empty())\\n        {\\n            int d=q.front().first;\\n            int row=q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=row+drow[i];\\n                int ncol=col+dcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && grid[nrow][ncol]==0 && dist[nrow][ncol]>d+1)\\n                {\\n                    dist[nrow][ncol]=d+1;\\n                    q.push({d+1,{nrow,ncol}});\\n                }\\n            }\\n            \\n        }\\n        if(dist[trow][tcol]==1e9)//path not possible\\n            return -1;\\n        return dist[trow][tcol];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        if(grid[0][0]==1)return -1;\\n        //defining starting and ending nodes\\n        int srow=0;\\n        int scol=0;\\n        int trow=grid.size()-1;\\n        int tcol=grid[0].size()-1;\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //defining the initial configuration\\n        vector<vector<int>>dist(m,vector<int>(n,1e9));//distance matrix\\n        dist[srow][scol]=1;\\n        queue<pair<int,pair<int,int>>>q;//queue: dist,row,col\\n        q.push({1,{0,0}});\\n        \\n        //defining the movements\\n        int drow[]={-1,-1,0,1,1,1,0,-1};\\n        int dcol[]={0,1,1,1,0,-1,-1,-1};\\n\\n        //djkistra implementation\\n        while(!q.empty())\\n        {\\n            int d=q.front().first;\\n            int row=q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=row+drow[i];\\n                int ncol=col+dcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && grid[nrow][ncol]==0 && dist[nrow][ncol]>d+1)\\n                {\\n                    dist[nrow][ncol]=d+1;\\n                    q.push({d+1,{nrow,ncol}});\\n                }\\n            }\\n            \\n        }\\n        if(dist[trow][tcol]==1e9)//path not possible\\n            return -1;\\n        return dist[trow][tcol];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920574,
                "title": "a-simple-dijkstra-algorithm-striver-intuition-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA dijkstra Algorithm for finding shortest path.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDone a simple BFS with the help of Dijkstra algorithm. Storing every minimum dist of that index from source in the index;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(ElogV*8)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N) for taking matrix size of NXN;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //int n=grid.size();\\n\\n        const int n = grid.size();\\n    if (grid[0][0] == 0 && n == 1)\\n      return 1;\\n    if (grid[0][0] == 1 || grid.back().back() == 1)\\n      return -1;\\n        \\n        vector<vector<int>> dist(n,vector<int>(n,1e9));\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({1,{0,0}});\\n        dist[0][0]=0;\\n\\n        int dRow[8]={-1,-1,0,1,1,1,0,-1};\\n        int dCol[8]={0,1,1,1,0,-1,-1,-1};\\n\\n        while(!q.empty())\\n        {\\n            int dis=q.front().first;\\n            int r=q.front().second.first;\\n            int c=q.front().second.second;\\n\\n            q.pop();\\n\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=r+dRow[i];\\n                int ncol=c+dCol[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<n && grid[nrow][ncol]==0\\n                && dis+1<dist[nrow][ncol])\\n                {\\n                    dist[nrow][ncol]=dis+1;\\n                   if(nrow==n-1 && ncol==n-1) return dist[nrow][ncol];\\n                    q.push({1+dis,{nrow,ncol}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //int n=grid.size();\\n\\n        const int n = grid.size();\\n    if (grid[0][0] == 0 && n == 1)\\n      return 1;\\n    if (grid[0][0] == 1 || grid.back().back() == 1)\\n      return -1;\\n        \\n        vector<vector<int>> dist(n,vector<int>(n,1e9));\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({1,{0,0}});\\n        dist[0][0]=0;\\n\\n        int dRow[8]={-1,-1,0,1,1,1,0,-1};\\n        int dCol[8]={0,1,1,1,0,-1,-1,-1};\\n\\n        while(!q.empty())\\n        {\\n            int dis=q.front().first;\\n            int r=q.front().second.first;\\n            int c=q.front().second.second;\\n\\n            q.pop();\\n\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=r+dRow[i];\\n                int ncol=c+dCol[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<n && grid[nrow][ncol]==0\\n                && dis+1<dist[nrow][ncol])\\n                {\\n                    dist[nrow][ncol]=dis+1;\\n                   if(nrow==n-1 && ncol==n-1) return dist[nrow][ncol];\\n                    q.push({1+dis,{nrow,ncol}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877508,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS 2D\\n\\n\\n# Code\\n```\\n#define maxn 105\\n#define pii pair<int, int>\\nint fx[] = {-1, 1, 0, 0, 1, -1, -1, 1};\\nint fy[] = {0, 0, -1, 1, 1, 1, -1, -1};\\n\\nclass Solution {\\npublic:\\n    int n, m, vis[maxn][maxn], dis[maxn][maxn];\\n    vector<vector<int>> grids;\\n\\n    bool valid(int x, int y)\\n    {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and !grids[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void bfs(int sx, int sy) {\\n        vis[sx][sy] = 1;\\n        dis[sx][sy] = 1;\\n        queue<pii> q;\\n        q.push({sx, sy});\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop();\\n            for(int k=0; k<8; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    dis[tx][ty] = dis[x][y] + 1;\\n                    q.push({tx, ty});\\n                }\\n            }\\n        }\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        grids = grid;\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        n = grid.size(), m = grid[0].size();\\n\\n        if(valid(0, 0)) bfs(0, 0);\\n\\n        int ans = dis[n-1][m-1];\\n        if(ans) return ans;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define maxn 105\\n#define pii pair<int, int>\\nint fx[] = {-1, 1, 0, 0, 1, -1, -1, 1};\\nint fy[] = {0, 0, -1, 1, 1, 1, -1, -1};\\n\\nclass Solution {\\npublic:\\n    int n, m, vis[maxn][maxn], dis[maxn][maxn];\\n    vector<vector<int>> grids;\\n\\n    bool valid(int x, int y)\\n    {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and !grids[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void bfs(int sx, int sy) {\\n        vis[sx][sy] = 1;\\n        dis[sx][sy] = 1;\\n        queue<pii> q;\\n        q.push({sx, sy});\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop();\\n            for(int k=0; k<8; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    dis[tx][ty] = dis[x][y] + 1;\\n                    q.push({tx, ty});\\n                }\\n            }\\n        }\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        grids = grid;\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        n = grid.size(), m = grid[0].size();\\n\\n        if(valid(0, 0)) bfs(0, 0);\\n\\n        int ans = dis[n-1][m-1];\\n        if(ans) return ans;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742566,
                "title": "c-from-bfs-to-djikstras-solution",
                "content": "Simple Bfs Solution\\n```\\nclass Solution {\\npublic:\\n    int dx[8]={0,1,-1,0,1,-1,-1,1};\\n    int dy[8]={1,0,0,-1,1,-1,1,-1};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        if(grid[0][0]==1 or grid[n-1][n-1]==1)\\n            return -1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({1,{0,0}});\\n        while(!q.empty())\\n        {\\n            int cnt=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            if(x==n-1 and y==n-1)\\n            {\\n                return cnt;\\n            }\\n           \\n            for(int k=0;k<8;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=n or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==1)\\n                    continue;\\n                vis[newx][newy]=1;\\n                q.push({cnt+1,{newx,newy}});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\nDjikstras Shortest Path Solution\\n```\\ntypedef pair<int,pair<int,int>> pi;\\nclass Solution {\\npublic:\\n    int dx[8]={0,1,-1,0,1,-1,-1,1};\\n    int dy[8]={1,0,0,-1,1,-1,1,-1};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n        vector<vector<int>> dist(n,vector<int>(n,1e9));\\n        if(grid[0][0]==1 or grid[n-1][n-1]==1)\\n            return -1;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        pq.push({1,{0,0}});\\n        dist[0][0]=1;\\n        while(!pq.empty())\\n        {\\n            int cnt=pq.top().first;\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            pq.pop();\\n            for(int k=0;k<=7;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=n or newy>=n or grid[newx][newy]==1)\\n                    continue;\\n                if(dist[newx][newy]>1+cnt)\\n                {\\n                    dist[newx][newy]=1+cnt;\\n                    pq.push({dist[newx][newy],{newx,newy}});\\n                }\\n            }\\n        }\\n        if(dist[n-1][n-1]==1e9)\\n            return -1;\\n        return dist[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[8]={0,1,-1,0,1,-1,-1,1};\\n    int dy[8]={1,0,0,-1,1,-1,1,-1};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        if(grid[0][0]==1 or grid[n-1][n-1]==1)\\n            return -1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({1,{0,0}});\\n        while(!q.empty())\\n        {\\n            int cnt=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            if(x==n-1 and y==n-1)\\n            {\\n                return cnt;\\n            }\\n           \\n            for(int k=0;k<8;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=n or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==1)\\n                    continue;\\n                vis[newx][newy]=1;\\n                q.push({cnt+1,{newx,newy}});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\ntypedef pair<int,pair<int,int>> pi;\\nclass Solution {\\npublic:\\n    int dx[8]={0,1,-1,0,1,-1,-1,1};\\n    int dy[8]={1,0,0,-1,1,-1,1,-1};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n        vector<vector<int>> dist(n,vector<int>(n,1e9));\\n        if(grid[0][0]==1 or grid[n-1][n-1]==1)\\n            return -1;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        pq.push({1,{0,0}});\\n        dist[0][0]=1;\\n        while(!pq.empty())\\n        {\\n            int cnt=pq.top().first;\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            pq.pop();\\n            for(int k=0;k<=7;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=n or newy>=n or grid[newx][newy]==1)\\n                    continue;\\n                if(dist[newx][newy]>1+cnt)\\n                {\\n                    dist[newx][newy]=1+cnt;\\n                    pq.push({dist[newx][newy],{newx,newy}});\\n                }\\n            }\\n        }\\n        if(dist[n-1][n-1]==1e9)\\n            return -1;\\n        return dist[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700526,
                "title": "easy-to-understand-bfs-with-explanation",
                "content": "# Intuition\\nThe goal is to convert the 1st martix to the 2nd. So in this we will use BFS and add +1 to the next visited neighbor. So whatever the end sum is in cell (m-1, n-1) will be our answer.\\n\\n![matrix.png](https://assets.leetcode.com/users/images/bf073896-ded8-488c-911a-6c63231c4953_1665714677.1979873.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Code\\n```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        Queue<int[]> que = new Queue<int[]>();\\n\\n        // 8 directional\\n        List<int[]> directions = new List<int[]>(){new int[]{-1,0}, new int[]{1,0}, new int[]{0,1}, new int[]{0,-1}, new int[]{1,-1}, new int[]{-1,-1}, new int[]{-1,1}, new int[]{1,1}};\\n\\n        int m = grid.Count();\\n        int n = grid[0].Count();\\n\\n        // There is either no start or no end then return false\\n        if(grid[0][0] != 0 || grid[m-1][n-1] != 0) return -1;\\n\\n        que.Enqueue(new int[]{0,0});\\n        grid[0][0] = 1; // This is our starting point\\n\\n        while(que.Count != 0){\\n            int[] curr = que.Dequeue();\\n            int currI = curr[0];\\n            int currJ = curr[1];\\n\\n            // We have reached the destination so return this.\\n            if(currI == m-1 && currJ == n-1) return grid[currI][currJ]; \\n\\n            foreach(int[] dir in directions){\\n                int newI = currI+dir[0];\\n                int newJ = currJ+dir[1];\\n\\n                if(newI>=0 && newI<m && newJ>=0 && newJ<n && grid[newI][newJ] == 0){\\n                    que.Enqueue(new int[]{newI, newJ});\\n                    grid[newI][newJ] = grid[currI][currJ]+1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        Queue<int[]> que = new Queue<int[]>();\\n\\n        // 8 directional\\n        List<int[]> directions = new List<int[]>(){new int[]{-1,0}, new int[]{1,0}, new int[]{0,1}, new int[]{0,-1}, new int[]{1,-1}, new int[]{-1,-1}, new int[]{-1,1}, new int[]{1,1}};\\n\\n        int m = grid.Count();\\n        int n = grid[0].Count();\\n\\n        // There is either no start or no end then return false\\n        if(grid[0][0] != 0 || grid[m-1][n-1] != 0) return -1;\\n\\n        que.Enqueue(new int[]{0,0});\\n        grid[0][0] = 1; // This is our starting point\\n\\n        while(que.Count != 0){\\n            int[] curr = que.Dequeue();\\n            int currI = curr[0];\\n            int currJ = curr[1];\\n\\n            // We have reached the destination so return this.\\n            if(currI == m-1 && currJ == n-1) return grid[currI][currJ]; \\n\\n            foreach(int[] dir in directions){\\n                int newI = currI+dir[0];\\n                int newJ = currJ+dir[1];\\n\\n                if(newI>=0 && newI<m && newJ>=0 && newJ<n && grid[newI][newJ] == 0){\\n                    que.Enqueue(new int[]{newI, newJ});\\n                    grid[newI][newJ] = grid[currI][currJ]+1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661020,
                "title": "c-djikstra-algorithm-bfs",
                "content": "**!!! Please Upvote !!!**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have to find the shortest distnace from a source node (i.e. index $(0,0)$) to a destination node (i.e. index $(n-1, n-1)$).\\n    So, here we can use simple Dijkstra Algorithm, taking 8 direction from current index as child node and taking unit weight $(i.e.\\\\ Taking\\\\ Distance\\\\ to\\\\ travel\\\\ another\\\\ node\\\\ is\\\\ 1)$.\\n\\n- **Base Cases :-**\\n  1. node should be inside boundry of matrix.\\n  $(i.e,$ $i>=0$ $and$ $j>=0$ $and$ $i<n$ $and$ $j<n$ $)$\\n  2. We can only traverse when $grid[i][j] == 0$. \\n  3. if source $(0,0)$) or destination $(n-1, n-1)$ is 1 than as per point no. 2, we can not even move forward, so we will `return -1` at starting only.\\n  4. After completing Djikstra algorithm if $distTo[n-1][n-1]\\\\ ==\\\\ INT\\\\_MAX$, than it will conclude that reaching destination node $(n-1, n-1)$ is not possible,  so we will `return -1`.\\n  5. if point no. 4 is not true, than we will `return (distTo[n-1][n-1] + 1)`. $$(Here\\\\ \\\\ we\\\\ \\\\ add\\\\ \\\\ 1\\\\ \\\\ to\\\\ \\\\ final\\\\ \\\\ result,\\\\ \\\\ to\\\\ \\\\ count\\\\ \\\\ source\\\\ \\\\ node\\\\ \\\\ (0, 0)\\\\ \\\\ in\\\\ \\\\ the\\\\ \\\\ path)$$\\n\\n# Code\\n```\\nstruct myPair{\\n    int dist;\\n    int i;\\n    int j;\\n};\\n\\nstruct myComp {\\n    constexpr bool operator()(myPair const& a, myPair const& b)const noexcept\\n    {\\n        return a.dist > b.dist;\\n    }\\n};\\nclass Solution {\\n    bool check(int i, int j, int n, vector<vector<int>>& grid)\\n    {\\n        if(i>=0 and j>=0 and i<n and j<n and grid[i][j]==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n\\n        if(grid[0][0]!=0 or grid[n-1][n-1]!=0)\\n            return -1;\\n\\n        vector<vector<int>> distTo(n, vector<int>(n, INT_MAX));\\n\\n        priority_queue<myPair, vector<myPair>, myComp> pq;\\n\\n        vector<int> dirx{1, -1, 1, 1, 0, -1, 0, -1};\\n        vector<int> diry{1, 1, -1, 0, 1, 0, -1, -1};\\n\\n        distTo[0][0] = 0;\\n        pq.push({0, 0, 0});\\n\\n        while(!pq.empty())\\n        {\\n            myPair u = pq.top();\\n            pq.pop();\\n\\n            for(int k=0; k<8; k++)\\n            {\\n                if(check((u.i + dirx[k]), (u.j + diry[k]), n, grid))\\n                {\\n                    myPair v = {distTo[(u.i + dirx[k])][(u.j + diry[k])], (u.i + dirx[k]), (u.j + diry[k])};\\n\\n                    if(v.dist > (distTo[u.i][u.j] + 1))\\n                    {\\n                        v.dist = (distTo[u.i][u.j] + 1);\\n                        distTo[(u.i + dirx[k])][(u.j + diry[k])] = v.dist;\\n                        pq.push(v);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (distTo[n-1][n-1]==INT_MAX)?-1:(distTo[n-1][n-1]+1);\\n    }\\n};\\n```\\n\\n\\n**!!! Please Upvote !!!**",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct myPair{\\n    int dist;\\n    int i;\\n    int j;\\n};\\n\\nstruct myComp {\\n    constexpr bool operator()(myPair const& a, myPair const& b)const noexcept\\n    {\\n        return a.dist > b.dist;\\n    }\\n};\\nclass Solution {\\n    bool check(int i, int j, int n, vector<vector<int>>& grid)\\n    {\\n        if(i>=0 and j>=0 and i<n and j<n and grid[i][j]==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n\\n        if(grid[0][0]!=0 or grid[n-1][n-1]!=0)\\n            return -1;\\n\\n        vector<vector<int>> distTo(n, vector<int>(n, INT_MAX));\\n\\n        priority_queue<myPair, vector<myPair>, myComp> pq;\\n\\n        vector<int> dirx{1, -1, 1, 1, 0, -1, 0, -1};\\n        vector<int> diry{1, 1, -1, 0, 1, 0, -1, -1};\\n\\n        distTo[0][0] = 0;\\n        pq.push({0, 0, 0});\\n\\n        while(!pq.empty())\\n        {\\n            myPair u = pq.top();\\n            pq.pop();\\n\\n            for(int k=0; k<8; k++)\\n            {\\n                if(check((u.i + dirx[k]), (u.j + diry[k]), n, grid))\\n                {\\n                    myPair v = {distTo[(u.i + dirx[k])][(u.j + diry[k])], (u.i + dirx[k]), (u.j + diry[k])};\\n\\n                    if(v.dist > (distTo[u.i][u.j] + 1))\\n                    {\\n                        v.dist = (distTo[u.i][u.j] + 1);\\n                        distTo[(u.i + dirx[k])][(u.j + diry[k])] = v.dist;\\n                        pq.push(v);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (distTo[n-1][n-1]==INT_MAX)?-1:(distTo[n-1][n-1]+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543974,
                "title": "simple-java-solution-bfs",
                "content": "```\\n// BFS Time Complexity --> O(v) ~ O(n * m)\\n// Please Upvote if you find it helpful !!\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, shortestPath = 1;\\n        int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}};\\n        \\n        LinkedList<Integer> que = new LinkedList<>();\\n        \\n        // if the start (row, col) or the end (row, col) contains non zero values then it is impossible to reach (n - 1, m - 1) or start from (0, 0)\\n        if(grid[0][0] != 0 || grid[n - 1][m - 1] != 0){  \\n            return -1;\\n        }\\n        \\n        // instead of making a visited[] just doing changes in the original matrix i.e placing a value not present in matrix to mark it visited.\\n        grid[0][0] = 2; \\n        \\n        // instead of adding pair of (row, col) in the queue we are just treating the (row, col) as 1D\\n        que.addLast(0);\\n        \\n        // First While loop in BFS manages the Levels\\n        while(que.size() != 0){                \\n            int size = que.size();\\n            // Second While loop in BFS Processes the current Level and prepare the upcoming level Simultaneously\\n            while(size-- > 0){    \\n                int remove_vtx_idx = que.removeFirst();\\n                int row = remove_vtx_idx / m;                    // converting the 1D mapping back into the 2D\\n                int col = remove_vtx_idx % m;                    // converting the 1D mapping back into the 2D\\n                \\n                if(row == n - 1 && col == m - 1){\\n                    return shortestPath;                    // if the removed vertex is our dest then return from here.\\n                }\\n                \\n                for(int d = 0; d < dir.length; d++){\\n                    int r = row + dir[d][0];\\n                    int c = col + dir[d][1];\\n                    \\n                    if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == 0){\\n                        grid[r][c] = 2;       // marking visited\\n                        que.addLast(r * m + c); // Adding the 1D mapping of indexes\\n                    }\\n                }\\n            }\\n            shortestPath += 1;                     // incrementing the level i.e shortestPath in this case\\n        }\\n        \\n// if the above BFS is Completed and it comes at this point then it means there is no clear path, Therefore return -1\\n        return -1; \\n    }   \\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, shortestPath = 1;\\n        int[][] dir = {{0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 2452243,
                "title": "bfs-with-self-explainatory-variable-names-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if 1 in (grid[0][0], grid[-1][-1]):\\n            return -1\\n\\n        ROWS, COLS = len(grid), len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\\n        \\n        q = deque([(0, 0, 1)])\\n        visited = set()\\n        visited.add((0, 0))\\n        \\n        while q:\\n            x, y, distance = q.popleft()\\n            if (x, y) == (COLS - 1, ROWS - 1):\\n                return distance\\n            \\n            for dx, dy in directions:\\n                newX, newY = x + dx, y + dy\\n                \\n                if 0 <= newX < COLS and 0 <= newY < ROWS and (newX, newY) not in visited and grid[newX][newY] == 0:\\n                    q.append((newX, newY, distance + 1))\\n                    visited.add((newX, newY))\\n                    \\n        return -1\\n    # Time: O(n) where n is the number of cells in the grid\\n    # Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if 1 in (grid[0][0], grid[-1][-1]):\\n            return -1\\n\\n        ROWS, COLS = len(grid), len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\\n        \\n        q = deque([(0, 0, 1)])\\n        visited = set()\\n        visited.add((0, 0))\\n        \\n        while q:\\n            x, y, distance = q.popleft()\\n            if (x, y) == (COLS - 1, ROWS - 1):\\n                return distance\\n            \\n            for dx, dy in directions:\\n                newX, newY = x + dx, y + dy\\n                \\n                if 0 <= newX < COLS and 0 <= newY < ROWS and (newX, newY) not in visited and grid[newX][newY] == 0:\\n                    q.append((newX, newY, distance + 1))\\n                    visited.add((newX, newY))\\n                    \\n        return -1\\n    # Time: O(n) where n is the number of cells in the grid\\n    # Space: O(n)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575612,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1878646,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1570870,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566117,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912468,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566221,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566563,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912518,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1796187,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912561,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1575612,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1878646,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1570870,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566117,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912468,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566221,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566563,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912518,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1796187,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912561,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912488,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1912756,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1913466,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1912722,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1912533,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1912532,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1842244,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 2049155,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 2048374,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1967456,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1928310,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1924380,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1921952,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1914453,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1914281,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913744,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913470,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913454,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913300,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913287,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913273,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913244,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913214,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913210,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913189,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913087,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913078,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913016,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1912985,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1912966,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1912938,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912878,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912851,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912810,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912800,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912724,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912707,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912692,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912667,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912665,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912614,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912613,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912609,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912595,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912593,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912511,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912484,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1883520,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1803865,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1799493,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove Max Number of Edges to Keep Graph Fully Traversable",
        "question_content": "<p>Alice and Bob have an undirected graph of <code>n</code> nodes and three types of edges:</p>\n\n<ul>\n\t<li>Type 1: Can be traversed by Alice only.</li>\n\t<li>Type 2: Can be traversed by Bob only.</li>\n\t<li>Type 3: Can be traversed by both Alice and Bob.</li>\n</ul>\n\n<p>Given an array <code>edges</code> where <code>edges[i] = [type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>]</code> represents a bidirectional edge of type <code>type<sub>i</sub></code> between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.</p>\n\n<p>Return <em>the maximum number of edges you can remove, or return</em> <code>-1</code> <em>if Alice and Bob cannot fully traverse the graph.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/19/ex1.png\" style=\"width: 179px; height: 191px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/19/ex2.png\" style=\"width: 178px; height: 190px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>Notice that removing any edge will not make the graph fully traversable by Alice and Bob.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/19/ex3.png\" style=\"width: 178px; height: 190px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\n<strong>Output:</strong> -1\n<b>Explanation: </b>In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it&#39;s impossible to make the graph fully traversable.</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, 3 * n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>1 &lt;= type<sub>i</sub> &lt;= 3</code></li>\n\t<li><code>1 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt;= n</code></li>\n\t<li>All tuples <code>(type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>)</code> are distinct.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 831506,
                "title": "c-java-textbook-union-find-data-structure-code-with-explanation-and-comments",
                "content": "The idea here is to think that initially the graph is empty and now we want to add the edges into the graph such that graph is connected.\\n\\nUnion-Find is an easiest way to solve such problem where we start with all nodes in separate components and merge the nodes as we add edges into the graph.\\n\\nAs some edges are available to only Bob while some are available only to Alice, we will have two different union find objects to take care of their own traversability.\\n\\nKey thing to remember is that we should prioritize type 3 edges over type 1 and 2 because they help both of them at the same time.\\n**C++**\\n```\\n/* You can simply plug in this class any many different codes. This class is a generic implementation of union-find. */\\nclass UnionFind {\\n    vector<int> component;\\n    int distinctComponents;\\npublic:\\n    /*\\n     *   Initially all \\'n\\' nodes are in different components.\\n     *   e.g. component[2] = 2 i.e. node 2 belong to component 2.\\n     */\\n    UnionFind(int n) {\\n\\t    distinctComponents = n;\\n        for (int i=0; i<=n; i++) {\\n            component.push_back(i);\\n        }\\n    }\\n    \\n    /*\\n     *   Returns true when two nodes \\'a\\' and \\'b\\' are initially in different\\n     *   components. Otherwise returns false.\\n     */\\n    bool unite(int a, int b) {       \\n        if (findComponent(a) == findComponent(b)) {\\n            return false;\\n        }\\n        component[findComponent(a)] = b;\\n        distinctComponents--;\\n        return true;\\n    }\\n    \\n    /*\\n     *   Returns what component does the node \\'a\\' belong to.\\n     */\\n    int findComponent(int a) {\\n        if (component[a] != a) {\\n            component[a] = findComponent(component[a]);\\n        }\\n        return component[a];\\n    }\\n    \\n    /*\\n     *   Are all nodes united into a single component?\\n     */\\n    bool united() {\\n        return distinctComponents == 1;\\n    }\\n};\\n\\n\\n\\n// ----------------- Actual Solution --------------\\nclass Solution {\\n    \\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        // Sort edges by their type such that all type 3 edges will be at the beginning.\\n        sort(edges.begin(), edges.end(), [] (vector<int> &a, vector<int> &b) { return a[0] > b[0]; });\\n        \\n        int edgesAdded = 0; // Stores the number of edges added to the initial empty graph.\\n        \\n        UnionFind bob(n), alice(n); // Track whether bob and alice can traverse the entire graph,\\n                                    // are there still more than one distinct components, etc.\\n        \\n        for (auto &edge: edges) { // For each edge -\\n            int type = edge[0], one = edge[1], two = edge[2];\\n            switch(type) {\\n                case 3:\\n                    edgesAdded += (bob.unite(one, two) | alice.unite(one, two));\\n                    break;\\n                case 2:\\n                    edgesAdded += bob.unite(one, two);\\n                    break;\\n                case 1:\\n                    edgesAdded += alice.unite(one, two);\\n                    break;\\n            }\\n        }\\n        \\n        return (bob.united() && alice.united()) ? (edges.size()-edgesAdded) : -1; // Yay, solved.\\n    }\\n};\\n```\\n\\n**Java** (Credits to @binlei)\\n```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        Arrays.sort(edges, (a, b) -> b[0] - a[0]);\\n        \\n        int edgeAdd = 0;\\n        \\n        UnionFind alice = new UnionFind(n);\\n        UnionFind bob = new UnionFind(n);\\n        \\n        for (int[] edge : edges) {\\n            int type = edge[0];\\n            int a = edge[1];\\n            int b = edge[2];\\n            \\n            switch (type) {\\n                case 3:\\n                    if (alice.unite(a, b) | bob.unite(a, b)) {\\n                        edgeAdd++;\\n                    }\\n                    break;\\n                case 2:\\n                    if (bob.unite(a, b)) {\\n                        edgeAdd++;\\n                    }\\n                    break;\\n                case 1:\\n                    if (alice.unite(a, b)) {\\n                        edgeAdd++;\\n                    } \\n                    break;\\n            }\\n        }\\n        \\n        return (alice.united() && bob.united()) ? edges.length - edgeAdd : -1;\\n    }\\n    \\n    private class UnionFind {\\n        int[] component;\\n        int distinctComponents;\\n        \\n        public UnionFind(int n) {\\n            component = new int[n+1];\\n            for (int i = 0; i <= n; i++) {\\n                component[i] = i;\\n            }\\n            distinctComponents = n;\\n        }\\n        // unite. For example, if previously we have component {0, 4, 4, 4, 4, 6, 7, 7}, then invoke this method with a=1, b=5, then after invoke, {0, 4, 4, 4, 5, 7, 7, 7}\\n        private boolean unite(int a, int b) {\\n            if (findComponent(a) != findComponent(b)) {\\n                component[findComponent(a)] = b;\\n                distinctComponents--;\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        // find and change component\\n        // for example, if previously we have component:{0, 2, 3, 4, 4, 6, 7, 7}, then after invoke this method with a=1, the component become {0, 4, 4, 4, 4, 6, 7, 7}\\n        private int findComponent(int a) {\\n            if (component[a] != a) {\\n                component[a] = findComponent(component[a]);\\n            }\\n            return component[a];\\n        }\\n        \\n        private boolean united() {\\n            return distinctComponents == 1;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* You can simply plug in this class any many different codes. This class is a generic implementation of union-find. */\\nclass UnionFind {\\n    vector<int> component;\\n    int distinctComponents;\\npublic:\\n    /*\\n     *   Initially all \\'n\\' nodes are in different components.\\n     *   e.g. component[2] = 2 i.e. node 2 belong to component 2.\\n     */\\n    UnionFind(int n) {\\n\\t    distinctComponents = n;\\n        for (int i=0; i<=n; i++) {\\n            component.push_back(i);\\n        }\\n    }\\n    \\n    /*\\n     *   Returns true when two nodes \\'a\\' and \\'b\\' are initially in different\\n     *   components. Otherwise returns false.\\n     */\\n    bool unite(int a, int b) {       \\n        if (findComponent(a) == findComponent(b)) {\\n            return false;\\n        }\\n        component[findComponent(a)] = b;\\n        distinctComponents--;\\n        return true;\\n    }\\n    \\n    /*\\n     *   Returns what component does the node \\'a\\' belong to.\\n     */\\n    int findComponent(int a) {\\n        if (component[a] != a) {\\n            component[a] = findComponent(component[a]);\\n        }\\n        return component[a];\\n    }\\n    \\n    /*\\n     *   Are all nodes united into a single component?\\n     */\\n    bool united() {\\n        return distinctComponents == 1;\\n    }\\n};\\n\\n\\n\\n// ----------------- Actual Solution --------------\\nclass Solution {\\n    \\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        // Sort edges by their type such that all type 3 edges will be at the beginning.\\n        sort(edges.begin(), edges.end(), [] (vector<int> &a, vector<int> &b) { return a[0] > b[0]; });\\n        \\n        int edgesAdded = 0; // Stores the number of edges added to the initial empty graph.\\n        \\n        UnionFind bob(n), alice(n); // Track whether bob and alice can traverse the entire graph,\\n                                    // are there still more than one distinct components, etc.\\n        \\n        for (auto &edge: edges) { // For each edge -\\n            int type = edge[0], one = edge[1], two = edge[2];\\n            switch(type) {\\n                case 3:\\n                    edgesAdded += (bob.unite(one, two) | alice.unite(one, two));\\n                    break;\\n                case 2:\\n                    edgesAdded += bob.unite(one, two);\\n                    break;\\n                case 1:\\n                    edgesAdded += alice.unite(one, two);\\n                    break;\\n            }\\n        }\\n        \\n        return (bob.united() && alice.united()) ? (edges.size()-edgesAdded) : -1; // Yay, solved.\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        Arrays.sort(edges, (a, b) -> b[0] - a[0]);\\n        \\n        int edgeAdd = 0;\\n        \\n        UnionFind alice = new UnionFind(n);\\n        UnionFind bob = new UnionFind(n);\\n        \\n        for (int[] edge : edges) {\\n            int type = edge[0];\\n            int a = edge[1];\\n            int b = edge[2];\\n            \\n            switch (type) {\\n                case 3:\\n                    if (alice.unite(a, b) | bob.unite(a, b)) {\\n                        edgeAdd++;\\n                    }\\n                    break;\\n                case 2:\\n                    if (bob.unite(a, b)) {\\n                        edgeAdd++;\\n                    }\\n                    break;\\n                case 1:\\n                    if (alice.unite(a, b)) {\\n                        edgeAdd++;\\n                    } \\n                    break;\\n            }\\n        }\\n        \\n        return (alice.united() && bob.united()) ? edges.length - edgeAdd : -1;\\n    }\\n    \\n    private class UnionFind {\\n        int[] component;\\n        int distinctComponents;\\n        \\n        public UnionFind(int n) {\\n            component = new int[n+1];\\n            for (int i = 0; i <= n; i++) {\\n                component[i] = i;\\n            }\\n            distinctComponents = n;\\n        }\\n        // unite. For example, if previously we have component {0, 4, 4, 4, 4, 6, 7, 7}, then invoke this method with a=1, b=5, then after invoke, {0, 4, 4, 4, 5, 7, 7, 7}\\n        private boolean unite(int a, int b) {\\n            if (findComponent(a) != findComponent(b)) {\\n                component[findComponent(a)] = b;\\n                distinctComponents--;\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        // find and change component\\n        // for example, if previously we have component:{0, 2, 3, 4, 4, 6, 7, 7}, then after invoke this method with a=1, the component become {0, 4, 4, 4, 4, 6, 7, 7}\\n        private int findComponent(int a) {\\n            if (component[a] != a) {\\n                component[a] = findComponent(component[a]);\\n            }\\n            return component[a];\\n        }\\n        \\n        private boolean united() {\\n            return distinctComponents == 1;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831573,
                "title": "python-union-find",
                "content": "# **Intuition**\\nAdd Type3 first, then check Type 1 and Type 2.\\n<br>\\n\\n# **Explanation**\\nGo through all edges of type 3 (Alice and Bob)\\nIf not necessary to add, increment `res`.\\nOtherwith increment `e1` and `e2`.\\n\\nGo through all edges of type 1 (Alice)\\nIf not necessary to add, increment `res`.\\nOtherwith increment `e1`.\\n\\nGo through all edges of type 2 (Bob)\\nIf not necessary to add, increment `res`.\\nOtherwith increment `e2`.\\n\\nIf Alice\\'s\\'graph is connected, `e1 == n - 1` should valid.\\nIf Bob\\'s graph is connected, `e2 == n - 1` should valid.\\nIn this case we return `res`,\\notherwise return `-1`.\\n<br>\\n\\n# Complexity\\nTime O(E), if union find with compression and rank\\nSpace O(E)\\n<br>\\n\\n**Python:**\\n```py\\n    def maxNumEdgesToRemove(self, n, edges):\\n        # Union find\\n        def find(i):\\n            if i != root[i]:\\n                root[i] = find(root[i])\\n            return root[i]\\n\\n        def uni(x, y):\\n            x, y = find(x), find(y)\\n            if x == y: return 0\\n            root[x] = y\\n            return 1\\n\\n        res = e1 = e2 = 0\\n\\n        # Alice and Bob\\n        root = range(n + 1)\\n        for t, i, j in edges:\\n            if t == 3:\\n                if uni(i, j):\\n                    e1 += 1\\n                    e2 += 1\\n                else:\\n                    res += 1\\n        root0 = root[:]\\n\\n        # only Alice\\n        for t, i, j in edges:\\n            if t == 1:\\n                if uni(i, j):\\n                    e1 += 1\\n                else:\\n                    res += 1\\n\\n        # only Bob\\n        root = root0\\n        for t, i, j in edges:\\n            if t == 2:\\n                if uni(i, j):\\n                    e2 += 1\\n                else:\\n                    res += 1\\n\\n        return res if e1 == e2 == n - 1 else -1\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def maxNumEdgesToRemove(self, n, edges):\\n        # Union find\\n        def find(i):\\n            if i != root[i]:\\n                root[i] = find(root[i])\\n            return root[i]\\n\\n        def uni(x, y):\\n            x, y = find(x), find(y)\\n            if x == y: return 0\\n            root[x] = y\\n            return 1\\n\\n        res = e1 = e2 = 0\\n\\n        # Alice and Bob\\n        root = range(n + 1)\\n        for t, i, j in edges:\\n            if t == 3:\\n                if uni(i, j):\\n                    e1 += 1\\n                    e2 += 1\\n                else:\\n                    res += 1\\n        root0 = root[:]\\n\\n        # only Alice\\n        for t, i, j in edges:\\n            if t == 1:\\n                if uni(i, j):\\n                    e1 += 1\\n                else:\\n                    res += 1\\n\\n        # only Bob\\n        root = root0\\n        for t, i, j in edges:\\n            if t == 2:\\n                if uni(i, j):\\n                    e2 += 1\\n                else:\\n                    res += 1\\n\\n        return res if e1 == e2 == n - 1 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3468066,
                "title": "image-explanation-easiest-complete-intuition-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Remove Max Number of Edges to Keep Graph Fully Traversable` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/a5f3580b-5ef1-44c7-b9d6-c194c4588dc2_1682819037.469955.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/021bc978-11d2-4a11-9de1-dee362d67309_1682818399.3212633.png)\\n![image.png](https://assets.leetcode.com/users/images/a1e85df9-7d16-4fb4-a04d-baa9dfa4087e_1682818408.9161522.png)\\n![image.png](https://assets.leetcode.com/users/images/970b6e4f-4ab1-4762-b1aa-9df606097b65_1682818422.780898.png)\\n![image.png](https://assets.leetcode.com/users/images/1e4e315a-8954-4ae4-94f5-65f63becd770_1682818440.0835755.png)\\n![image.png](https://assets.leetcode.com/users/images/0529a674-bd29-41ff-9417-337636abf9fa_1682818452.1050658.png)\\n![image.png](https://assets.leetcode.com/users/images/9a51dcc0-d1f4-44bc-a2d8-d5fca25e04e1_1682818471.9856927.png)\\n![image.png](https://assets.leetcode.com/users/images/bd099e1c-b023-4a07-9955-5b683ddb5ed3_1682818479.443172.png)\\n![image.png](https://assets.leetcode.com/users/images/1aac4488-e4c7-466e-8570-ffeaba83fefe_1682818492.1441891.png)\\n![image.png](https://assets.leetcode.com/users/images/387e113b-a8d1-41a3-aeea-f845acf3ec12_1682818499.3856347.png)\\n![image.png](https://assets.leetcode.com/users/images/23b8e642-ba76-44b2-b854-7c89fcca7113_1682818510.7526262.png)\\n![image.png](https://assets.leetcode.com/users/images/e9843723-ce97-4b6c-8cbe-dfeafb99756c_1682818525.044252.png)\\n![image.png](https://assets.leetcode.com/users/images/fca0cfa7-da66-460f-a55c-ab17cbff4cfc_1682818533.878107.png)\\n![image.png](https://assets.leetcode.com/users/images/5cb07d8d-606c-480f-b8b0-bb7c0ddb7950_1682818543.163168.png)\\n![image.png](https://assets.leetcode.com/users/images/c7cb773a-3525-4e4e-a7d6-cfe8f0945b4c_1682818550.6547136.png)\\n\\n\\n# Code\\n```C++ []\\nclass DSU {\\npublic:\\n    vector<int> parent, rank;\\n    DSU(int n){\\n        parent.resize(n, 0);\\n        rank.resize(n, 0);\\n        \\n        for(int i=0;i<n;i++) parent[i] = i;\\n    }\\n    \\n    int Find(int x){\\n        return parent[x] = parent[x] == x ? x : Find(parent[x]);\\n    }\\n    \\n    bool Union(int x, int y){\\n        int xset = Find(x), yset = Find(y);\\n        if(xset != yset){\\n            rank[xset] < rank[yset] ? parent[xset] = yset : parent[yset] = xset;\\n            rank[xset] += rank[xset] == rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), [&](auto const &a, auto const &b){\\n            return a[0] > b[0];\\n        });\\n\\n        DSU dsu_alice(n+1);\\n        DSU dsu_bob(n+1);\\n\\n        int removed_edge = 0, alice_edges=0, bob_edges=0;\\n        for(auto edge : edges){\\n            if(edge[0] == 3){\\n                if(dsu_alice.Union(edge[1], edge[2])){ // Both Alice & Bob\\n                    dsu_bob.Union(edge[1], edge[2]);\\n                    alice_edges++;\\n                    bob_edges++;\\n                }else{\\n                    removed_edge++;\\n                }\\n            }else if(edge[0] == 2){ //Only Bob\\n                if(dsu_bob.Union(edge[1], edge[2])){\\n                    bob_edges++;\\n                }else{\\n                    removed_edge++;\\n                }\\n            }else{ // Only Alice\\n                if(dsu_alice.Union(edge[1], edge[2])){\\n                    alice_edges++;\\n                }else{\\n                    removed_edge++;\\n                }\\n            }\\n        }\\n\\n        return (bob_edges == n - 1 && alice_edges == n - 1) ? removed_edge : -1;\\n    }\\n};\\n```\\n```Java []\\nclass DSU {\\n    int[] parent;\\n    int[] rank;\\n    \\n    public DSU(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    public int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int xset = find(x), yset = find(y);\\n        if (xset != yset) {\\n            if (rank[xset] < rank[yset]) {\\n                parent[xset] = yset;\\n            } else if (rank[xset] > rank[yset]) {\\n                parent[yset] = xset;\\n            } else {\\n                parent[xset] = yset;\\n                rank[yset]++;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        Arrays.sort(edges, (a, b) -> Integer.compare(b[0], a[0]));\\n        \\n        DSU dsu_alice = new DSU(n+1);\\n        DSU dsu_bob = new DSU(n+1);\\n        \\n        int removed_edge = 0, alice_edges = 0, bob_edges = 0;\\n        for (int[] edge : edges) {\\n            if (edge[0] == 3) {\\n                if (dsu_alice.union(edge[1], edge[2])) {\\n                    dsu_bob.union(edge[1], edge[2]);\\n                    alice_edges++;\\n                    bob_edges++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            } else if (edge[0] == 2) {\\n                if (dsu_bob.union(edge[1], edge[2])) {\\n                    bob_edges++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            } else {\\n                if (dsu_alice.union(edge[1], edge[2])) {\\n                    alice_edges++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            }\\n        }\\n        \\n        return (bob_edges == n - 1 && alice_edges == n - 1) ? removed_edge : -1;\\n    }\\n}\\n```\\n```Python []\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.rank = [0] * n\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        xset, yset = self.find(x), self.find(y)\\n        if xset != yset:\\n            if self.rank[xset] < self.rank[yset]:\\n                self.parent[xset] = yset\\n            elif self.rank[xset] > self.rank[yset]:\\n                self.parent[yset] = xset\\n            else:\\n                self.parent[xset] = yset\\n                self.rank[yset] += 1\\n            return True\\n        return False\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        edges.sort(reverse=True)\\n        dsu_alice = DSU(n+1)\\n        dsu_bob = DSU(n+1)\\n        removed_edge = 0\\n        alice_edges, bob_edges = 0, 0\\n        for edge in edges:\\n            if edge[0] == 3:\\n                if dsu_alice.union(edge[1], edge[2]):\\n                    dsu_bob.union(edge[1], edge[2])\\n                    alice_edges += 1\\n                    bob_edges += 1\\n                else:\\n                    removed_edge += 1\\n            elif edge[0] == 2:\\n                if dsu_bob.union(edge[1], edge[2]):\\n                    bob_edges += 1\\n                else:\\n                    removed_edge += 1\\n            else:\\n                if dsu_alice.union(edge[1], edge[2]):\\n                    alice_edges += 1\\n                else:\\n                    removed_edge += 1\\n        return removed_edge if bob_edges == n - 1 == alice_edges else -1\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```C++ []\\nclass DSU {\\npublic:\\n    vector<int> parent, rank;\\n    DSU(int n){\\n        parent.resize(n, 0);\\n        rank.resize(n, 0);\\n        \\n        for(int i=0;i<n;i++) parent[i] = i;\\n    }\\n    \\n    int Find(int x){\\n        return parent[x] = parent[x] == x ? x : Find(parent[x]);\\n    }\\n    \\n    bool Union(int x, int y){\\n        int xset = Find(x), yset = Find(y);\\n        if(xset != yset){\\n            rank[xset] < rank[yset] ? parent[xset] = yset : parent[yset] = xset;\\n            rank[xset] += rank[xset] == rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), [&](auto const &a, auto const &b){\\n            return a[0] > b[0];\\n        });\\n\\n        DSU dsu_alice(n+1);\\n        DSU dsu_bob(n+1);\\n\\n        int removed_edge = 0, alice_edges=0, bob_edges=0;\\n        for(auto edge : edges){\\n            if(edge[0] == 3){\\n                if(dsu_alice.Union(edge[1], edge[2])){ // Both Alice & Bob\\n                    dsu_bob.Union(edge[1], edge[2]);\\n                    alice_edges++;\\n                    bob_edges++;\\n                }else{\\n                    removed_edge++;\\n                }\\n            }else if(edge[0] == 2){ //Only Bob\\n                if(dsu_bob.Union(edge[1], edge[2])){\\n                    bob_edges++;\\n                }else{\\n                    removed_edge++;\\n                }\\n            }else{ // Only Alice\\n                if(dsu_alice.Union(edge[1], edge[2])){\\n                    alice_edges++;\\n                }else{\\n                    removed_edge++;\\n                }\\n            }\\n        }\\n\\n        return (bob_edges == n - 1 && alice_edges == n - 1) ? removed_edge : -1;\\n    }\\n};\\n```\n```Java []\\nclass DSU {\\n    int[] parent;\\n    int[] rank;\\n    \\n    public DSU(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    public int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int xset = find(x), yset = find(y);\\n        if (xset != yset) {\\n            if (rank[xset] < rank[yset]) {\\n                parent[xset] = yset;\\n            } else if (rank[xset] > rank[yset]) {\\n                parent[yset] = xset;\\n            } else {\\n                parent[xset] = yset;\\n                rank[yset]++;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        Arrays.sort(edges, (a, b) -> Integer.compare(b[0], a[0]));\\n        \\n        DSU dsu_alice = new DSU(n+1);\\n        DSU dsu_bob = new DSU(n+1);\\n        \\n        int removed_edge = 0, alice_edges = 0, bob_edges = 0;\\n        for (int[] edge : edges) {\\n            if (edge[0] == 3) {\\n                if (dsu_alice.union(edge[1], edge[2])) {\\n                    dsu_bob.union(edge[1], edge[2]);\\n                    alice_edges++;\\n                    bob_edges++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            } else if (edge[0] == 2) {\\n                if (dsu_bob.union(edge[1], edge[2])) {\\n                    bob_edges++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            } else {\\n                if (dsu_alice.union(edge[1], edge[2])) {\\n                    alice_edges++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            }\\n        }\\n        \\n        return (bob_edges == n - 1 && alice_edges == n - 1) ? removed_edge : -1;\\n    }\\n}\\n```\n```Python []\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.rank = [0] * n\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        xset, yset = self.find(x), self.find(y)\\n        if xset != yset:\\n            if self.rank[xset] < self.rank[yset]:\\n                self.parent[xset] = yset\\n            elif self.rank[xset] > self.rank[yset]:\\n                self.parent[yset] = xset\\n            else:\\n                self.parent[xset] = yset\\n                self.rank[yset] += 1\\n            return True\\n        return False\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        edges.sort(reverse=True)\\n        dsu_alice = DSU(n+1)\\n        dsu_bob = DSU(n+1)\\n        removed_edge = 0\\n        alice_edges, bob_edges = 0, 0\\n        for edge in edges:\\n            if edge[0] == 3:\\n                if dsu_alice.union(edge[1], edge[2]):\\n                    dsu_bob.union(edge[1], edge[2])\\n                    alice_edges += 1\\n                    bob_edges += 1\\n                else:\\n                    removed_edge += 1\\n            elif edge[0] == 2:\\n                if dsu_bob.union(edge[1], edge[2]):\\n                    bob_edges += 1\\n                else:\\n                    removed_edge += 1\\n            else:\\n                if dsu_alice.union(edge[1], edge[2]):\\n                    alice_edges += 1\\n                else:\\n                    removed_edge += 1\\n        return removed_edge if bob_edges == n - 1 == alice_edges else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831536,
                "title": "c-union-find-both-one",
                "content": "#### Intuition\\nWe would use union-find to solve this problem for one person. For two (or more) people, we first populate our \"shared\" disjoined set, using type 3 edges.\\n\\nThen, we process Alice and Bob independently, using the \"shared\" disjoined set as a starting point.\\n\\nEvery time we find a non-redundant edge, we increment `used`. We also check that the graph is fully connected for each person.\\n\\nIn the end, we can remove `total - used` edges.\\n\\n**C++**\\n```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nint maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n    vector<int> ds_both(n + 1, -1);\\n    int used = 0;\\n    for (int type = 3; type > 0; --type) {\\n        auto ds_one = ds_both;\\n        auto &ds = type == 3 ? ds_both : ds_one;\\n        for (auto &e : edges)\\n            if (e[0] == type) {\\n                int i = find(ds, e[1]), j = find(ds, e[2]);\\n                if (i != j) {\\n                    ++used;\\n                    if (ds[j] < ds[i])\\n                        swap(i, j);\\n                    ds[i] += ds[j];\\n                    ds[j] = i;\\n                }\\n            }\\n        if (type != 3 && ds[find(ds, 1)] != -n)\\n            return -1;\\n    }\\n    return edges.size() - used;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(m), where m is the number of edges. We go through all edges 3 times. The complexity of the `find` operation is O(\\uD835\\uDEFC(n)) as we use both rank and path compression. \\uD835\\uDEFC(n) can be considered a constant for all practical purposes.\\n- Memory: O(n) for a disjoined set.",
                "solutionTags": [],
                "code": "```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nint maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n    vector<int> ds_both(n + 1, -1);\\n    int used = 0;\\n    for (int type = 3; type > 0; --type) {\\n        auto ds_one = ds_both;\\n        auto &ds = type == 3 ? ds_both : ds_one;\\n        for (auto &e : edges)\\n            if (e[0] == type) {\\n                int i = find(ds, e[1]), j = find(ds, e[2]);\\n                if (i != j) {\\n                    ++used;\\n                    if (ds[j] < ds[i])\\n                        swap(i, j);\\n                    ds[i] += ds[j];\\n                    ds[j] = i;\\n                }\\n            }\\n        if (type != 3 && ds[find(ds, 1)] != -n)\\n            return -1;\\n    }\\n    return edges.size() - used;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831475,
                "title": "java-union-find-solution",
                "content": "When iterating over each edge, we check if the roots of the two nodes are the same: \\n\\n* If not, then this is a critical path which cannot be removed. And we connect these two nodes.\\n\\n* If yes, then this is a redundant path which can be removed. The result needs to increment by 1.\\n\\nHere order matters. Therefore we need to sort the edge by type. Type 3 comes first, then type 1 or 2. For type 3 edge, if and only if it is redundant for both players, then we can say that this path can be removed, otherwise not.\\n\\nAnother thing we need to check is whether the original graph is traversable for both players. So whenever we connect two new nodes, we decrease the total number of components in the graph by 1. The graph is only traversable when the total number of components is 1.\\n\\n```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        Arrays.sort(edges, (a, b) -> (b[0] - a[0]));\\n        int[] roots1 = new int[n + 1];\\n        int[] roots2 = new int[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            roots1[i] = i;\\n            roots2[i] = i;\\n        }\\n        int n1 = n, n2 = n; // Number of components for two players.\\n        int res = 0;\\n        for(int[] e : edges) {\\n            if(e[0] == 1) {\\n                int root_a = find(e[1], roots1);\\n                int root_b = find(e[2], roots1);\\n                if(root_a == root_b) { // If roots are the same, then this is a redundant edge and can be removed.\\n                    res++;\\n                } else {\\n                    roots1[root_a] = root_b; // If roots are different, we connect two different components.\\n                    n1--;\\n                }\\n            } else if(e[0] == 2) {\\n                int root_a = find(e[1], roots2);\\n                int root_b = find(e[2], roots2);\\n                if(root_a == root_b) {\\n                    res++;\\n                } else {\\n                    roots2[root_a] = root_b;\\n                    n2--;\\n                }\\n            } else {\\n                int root_a1 = find(e[1], roots1);\\n                int root_b1 = find(e[2], roots1);\\n                int root_a2 = find(e[1], roots2);\\n                int root_b2 = find(e[2], roots2);\\n                if(root_a1 != root_b1) {\\n                    roots1[root_a1] = root_b1;\\n                    n1--;\\n                }\\n                if(root_a2 != root_b2) {\\n                    roots2[root_a2] = root_b2;\\n                    n2--;\\n                }\\n                if(root_a1 == root_b1 && root_a2 == root_b2) {\\n                    res++;\\n                }\\n            }\\n        }\\n        if(n1 != 1 || n2 != 1) return -1; // If total number of components is not one for either players, return -1.\\n        return res;\\n    }\\n    \\n    private int find(int i, int[] roots) {\\n        int j = i;\\n        while(roots[i] != i) {\\n            i = roots[i];\\n        }\\n        roots[j] = i;\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        Arrays.sort(edges, (a, b) -> (b[0] - a[0]));\\n        int[] roots1 = new int[n + 1];\\n        int[] roots2 = new int[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            roots1[i] = i;\\n            roots2[i] = i;\\n        }\\n        int n1 = n, n2 = n; // Number of components for two players.\\n        int res = 0;\\n        for(int[] e : edges) {\\n            if(e[0] == 1) {\\n                int root_a = find(e[1], roots1);\\n                int root_b = find(e[2], roots1);\\n                if(root_a == root_b) { // If roots are the same, then this is a redundant edge and can be removed.\\n                    res++;\\n                } else {\\n                    roots1[root_a] = root_b; // If roots are different, we connect two different components.\\n                    n1--;\\n                }\\n            } else if(e[0] == 2) {\\n                int root_a = find(e[1], roots2);\\n                int root_b = find(e[2], roots2);\\n                if(root_a == root_b) {\\n                    res++;\\n                } else {\\n                    roots2[root_a] = root_b;\\n                    n2--;\\n                }\\n            } else {\\n                int root_a1 = find(e[1], roots1);\\n                int root_b1 = find(e[2], roots1);\\n                int root_a2 = find(e[1], roots2);\\n                int root_b2 = find(e[2], roots2);\\n                if(root_a1 != root_b1) {\\n                    roots1[root_a1] = root_b1;\\n                    n1--;\\n                }\\n                if(root_a2 != root_b2) {\\n                    roots2[root_a2] = root_b2;\\n                    n2--;\\n                }\\n                if(root_a1 == root_b1 && root_a2 == root_b2) {\\n                    res++;\\n                }\\n            }\\n        }\\n        if(n1 != 1 || n2 != 1) return -1; // If total number of components is not one for either players, return -1.\\n        return res;\\n    }\\n    \\n    private int find(int i, int[] roots) {\\n        int j = i;\\n        while(roots[i] != i) {\\n            i = roots[i];\\n        }\\n        roots[j] = i;\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468567,
                "title": "day-395-dsu-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n![image.png](https://assets.leetcode.com/users/images/a2267944-10b8-41f2-b624-81a67ccea163_1680148646.205976.png)\\n# Intuition \\n##### \\u2022\\tWe have a graph with N nodes and bidirectional edges of three types: Type 1 (Alice only), Type 2 (Bob only), and Type 3 (both Alice and Bob).\\n##### \\u2022\\tWe need to find the maximum number of edges that can be removed while still allowing both Alice and Bob to reach any node starting from any node via the remaining edges.\\n##### \\u2022\\tWe can assume that there are two graphs, one for Alice and one for Bob, where the first graph has edges only of Type 1 and 3, and the second graph has edges only of Type 2 and 3.\\n##### \\u2022\\tAn edge is useful only if it connects two nodes that are not already connected via some other edge or path.\\n##### \\u2022\\tWe can use the Disjoint Set Union (DSU) data structure to detect if two nodes are connected via some path or not in O(\\u03B1(N)), where \\u03B1(N) is the extremely fast inverse Ackermann function.\\n##### \\u2022\\tWe can use DSU to perform the union of two nodes for an edge, and if the nodes were not connected earlier (i.e., they have a different representative), then we know this edge is needed.\\n##### \\u2022\\tFor every edge, if the two nodes were not connected earlier, we know this edge is required. To get the answer, we can subtract the number of required edges from the total number of edges.\\n##### \\u2022\\tSince Type 3 edges are the most useful (as one Type 3 edge adds two edges, one for Alice and one for Bob), we will first iterate over the edges of Type 3 and add the edge to both graphs.\\n##### \\u2022\\tIn the end, we need to check if the graph for both Alice and Bob is connected or not. If yes, we can say the edges that we didn\\'t connect can be removed. To check if the individual graphs are connected, we will check if the number of components in the graph is 1 or not.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tDefine constants for edge types indices: TYPE U, V, ALICE, BOB, BOTH.\\n##### \\u2022\\tDefine the maxNumEdgesToRemove function that takes in the number of nodes (n) and an array of edges (edges).\\n##### \\u2022\\tMove all edges of type BOTH to the start of the array.\\n##### \\u2022\\tCreate two UnionFind data structures, one for Alice and one for Bob.\\n##### \\u2022\\tInitialize a variable added to 0.\\n##### \\u2022\\tIterate over the edges and add them to the appropriate UnionFind data structure.\\n##### \\u2022\\tIf the edge is of type BOTH, add it to both UnionFind data structures.\\n##### \\u2022\\tIf the edge is of type ALICE, add it to the Alice UnionFind data structure.\\n##### \\u2022\\tIf the edge is of type BOB, add it to the Bob UnionFind data structure.\\n##### \\u2022\\tIf the two UnionFind data structures are united, return the number of edges that were not added (edges.length - added).\\n##### \\u2022\\tIf both UnionFind data structures are not united, it is impossible to remove enough edges to make them united, so return -1.\\n##### \\u2022\\tDefine the UnionFind class that takes in the number of elements (n).\\n##### \\u2022\\tInitialize the parent array with n+1 elements and the groups variable to n.\\n##### \\u2022\\tDefine the union function that takes in two elements (u and v) and returns 1 if they were not already in the same group, 0 otherwise.\\n##### \\u2022\\tFind the parent of an element and perform path compression.\\n##### \\u2022\\tDefine the isUnited function that checks if all elements are in the same group and returns true if they are, false otherwise.\\n\\n\\n\\n# Code\\n```java []\\nclass Solution {\\n    // constants for the edge types indices\\n    static final int \\n        TYPE = 0, U = 1, V = 2,\\n        ALICE = 1, BOB = 2, BOTH = 3;\\n\\n    public int maxNumEdgesToRemove(final int n, final int[][] edges) {\\n        // Move all edges of type BOTH to the start of the array\\n        for (int i = 0, j = edges.length - 1; i < j; ) {\\n            if (edges[i][TYPE] == BOTH) {\\n                ++i;\\n                continue;\\n            }\\n            final var temp = edges[i];\\n            edges[i] = edges[j];\\n            edges[j] = temp;\\n            --j;\\n        }\\n\\n        // Create two UnionFind data structures, one for Alice and one for Bob\\n        final UnionFind \\n            aliceUf = new UnionFind(n), \\n            bobUf = new UnionFind(n);\\n        private int added = 0;\\n\\n        // Iterate over the edges and add them to the appropriate UnionFind data structure\\n        for (final var edge : edges) {\\n            final int type = edge[TYPE];\\n            final int u = edge[U];\\n            final int v = edge[V];\\n\\n            // Add the edge to both UnionFind data structures if it is of type BOTH\\n            added += switch (type) {\\n                case BOTH -> \\n                    aliceUf.union(u, v) | bobUf.union(u, v);\\n                case ALICE -> aliceUf.union(u, v);\\n                default -> bobUf.union(u, v);\\n            };\\n\\n            // If both UnionFind data structures are united, return the number of edges that were not added\\n            if (aliceUf.isUnited() && bobUf.isUnited())\\n                return edges.length - added;\\n        }\\n\\n        // If both UnionFind data structures are not united, it is impossible to remove enough edges to make them united\\n        return -1;\\n    }\\n}\\n\\nclass UnionFind {\\n    static final int ZERO = 0;\\n    final int[] parent;\\n    int groups;\\n\\n    // Initialize the UnionFind data structure with n groups\\n    UnionFind(final int n) {\\n        parent = new int[n + 1];\\n        groups = n;\\n    }\\n\\n    // Union two elements and return 1 if they were not already in the same group, 0 otherwise\\n    int union(final int u, final int v) {\\n        final int uParent = find(u);\\n        final int vParent = find(v);\\n        if (uParent == vParent)\\n            return 0;\\n        parent[uParent] = vParent;\\n        --groups;\\n        return 1;\\n    }\\n\\n    // Find the parent of an element and perform path compression\\n    int find(final int v) {\\n        if (parent[v] != ZERO)\\n            return parent[v] = find(parent[v]);\\n        return v;\\n    }\\n\\n    // Check if all elements are in the same group\\n    boolean isUnited() {\\n        return groups == 1;\\n    }\\n}\\n```\\n\\n```c++ []\\nclass Solution {\\nprivate:\\n    // constants for the edge types indices\\n    static constexpr int \\n        TYPE = 0, U = 1, V =2,\\n        ALICE = 1, BOB = 2, BOTH = 3;\\n\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        // Move all edges of type BOTH to the end of the array\\n        for (int i = 0, j = edges.size() - 1; i < j; ) {\\n            if (edges[i][TYPE] == BOTH) {\\n                ++i;\\n                continue;\\n            }\\n            swap(edges[i], edges[j]);\\n            --j;\\n        }\\n\\n        // Create two UnionFind data structures, one for Alice and one for Bob\\n        UnionFind alice_uf(n), bob_uf(n);\\n        int added = 0;\\n\\n        // Iterate over the edges and add them to the appropriate UnionFind data structure\\n        for (const auto& edge : edges) {\\n            const int type = edge[TYPE];\\n            const int u = edge[U];\\n            const int v = edge[V];\\n\\n            // Add the edge to both UnionFind data structures if it is of type BOTH\\n            added += (type == BOTH) ? \\n                alice_uf.union_(u, v) | bob_uf.union_(u, v) :\\n                (type == ALICE) ? alice_uf.union_(u, v) : bob_uf.union_(u, v);\\n\\n            // If both UnionFind data structures are united, return the number of edges that were not added\\n            if (alice_uf.is_united() && bob_uf.is_united())\\n                return edges.size() - added;\\n        }\\n\\n        // If both UnionFind data structures are united, return the number of edges that were not added\\n        if (alice_uf.is_united() && bob_uf.is_united())\\n            return edges.size() - added;\\n\\n        // If both UnionFind data structures are not united, it is impossible to remove enough edges to make them united\\n        return -1;\\n    }\\n};\\n\\nclass UnionFind {\\nprivate:\\n    vector<int> parent;\\n    int groups;\\n\\npublic:\\n    // Initialize the UnionFind data structure with n groups\\n    UnionFind(int n) : parent(n + 1), groups(n) {\\n        iota(parent.begin(), parent.end(), 0);\\n    }\\n\\n    // Union two elements and return 1 if they were not already in the same group, 0 otherwise\\n    int union_(int u, int v) {\\n        const int uParent = find_(u);\\n        const int vParent = find_(v);\\n        if (uParent == vParent)\\n            return 0;\\n        parent[uParent] = vParent;\\n        --groups;\\n        return 1;\\n    }\\n\\n    // Find the parent of an element and perform path compression\\n    int find_(int v) {\\n        if (parent[v] != v)\\n            parent[v] = find_(parent[v]);\\n        return parent[v];\\n    }\\n\\n    // Check if all elements are in the same group\\n    bool is_united() {\\n        return groups == 1;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n   # constants for the edge types indices\\n    TYPE, U, V, ALICE, BOB, BOTH = range(6)\\n\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        # Move all edges of type BOTH to the end of the array\\n        i, j = 0, len(edges) - 1\\n        while i < j:\\n            if edges[i][self.TYPE] == self.BOTH:\\n                i += 1\\n                continue\\n            edges[i], edges[j] = edges[j], edges[i]\\n            j -= 1\\n\\n        # Create two UnionFind data structures, one for Alice and one for Bob\\n        alice_uf, bob_uf = UnionFind(n), UnionFind(n)\\n        added = 0\\n\\n        # Iterate over the edges and add them to the appropriate UnionFind data structure\\n        for edge in edges:\\n            type_, u, v = edge[self.TYPE], edge[self.U], edge[self.V]\\n\\n            # Add the edge to both UnionFind data structures if it is of type BOTH\\n            if type_ == self.BOTH:\\n                added += alice_uf.union(u, v) | bob_uf.union(u, v)\\n            elif type_ == self.ALICE:\\n                added += alice_uf.union(u, v)\\n            else:\\n                added += bob_uf.union(u, v)\\n\\n            # If both UnionFind data structures are united, return the number of edges that were not added\\n            if alice_uf.is_united() and bob_uf.is_united():\\n                return len(edges) - added\\n\\n        # If both UnionFind data structures are not united, it is impossible to remove enough edges to make them united\\n        if not alice_uf.is_united() or not bob_uf.is_united():\\n            return -1\\n\\n        # If both UnionFind data structures are united, return the number of edges that were not added\\n        return len(edges) - added\\n\\n\\nclass UnionFind:\\n    def __init__(self, n: int):\\n        self.parent = list(range(n + 1))\\n        self.groups = n\\n\\n    def union(self, u: int, v: int) -> int:\\n        u_parent = self.find(u)\\n        v_parent = self.find(v)\\n        if u_parent == v_parent:\\n            return 0\\n        self.parent[u_parent] = v_parent\\n        self.groups -= 1\\n        return 1\\n\\n    def find(self, v: int) -> int:\\n        if self.parent[v] != v:\\n            self.parent[v] = self.find(self.parent[v])\\n        return self.parent[v]\\n\\n    def is_united(self) -> bool:\\n        return self.groups == 1\\n```\\n\\n\\n# Complexity\\nTime Complexity:\\n1 Moving all edges of type BOTH to the end of the array takes O(n) time.\\n\\nCreating two UnionFind data structures takes O(n) time.\\nIterating over the edges takes O(m) time, where m is the number of edges.\\nAdding an edge to a UnionFind data structure takes O(\\u03B1(n)) time, where \\u03B1(n) is the extremely fast inverse Ackermann function.\\nChecking if both UnionFind data structures are united takes O(1) time.\\nOverall, the time complexity of the code is O(m \\u03B1(n)), where m is the number of edges and n is the number of nodes.\\nSpace Complexity:\\n\\nCreating two UnionFind data structures takes O(n) space.\\nCreating the parent array for the UnionFind data structures takes O(n) space.\\nCreating the added variable takes O(1) space.\\nOverall, the space complexity of the code is O(n).\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nhttps://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solutions/3468567/day-395-dsu-100-0ms-python-java-c-explained-approach/\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```java []\\nclass Solution {\\n    // constants for the edge types indices\\n    static final int \\n        TYPE = 0, U = 1, V = 2,\\n        ALICE = 1, BOB = 2, BOTH = 3;\\n\\n    public int maxNumEdgesToRemove(final int n, final int[][] edges) {\\n        // Move all edges of type BOTH to the start of the array\\n        for (int i = 0, j = edges.length - 1; i < j; ) {\\n            if (edges[i][TYPE] == BOTH) {\\n                ++i;\\n                continue;\\n            }\\n            final var temp = edges[i];\\n            edges[i] = edges[j];\\n            edges[j] = temp;\\n            --j;\\n        }\\n\\n        // Create two UnionFind data structures, one for Alice and one for Bob\\n        final UnionFind \\n            aliceUf = new UnionFind(n), \\n            bobUf = new UnionFind(n);\\n        private int added = 0;\\n\\n        // Iterate over the edges and add them to the appropriate UnionFind data structure\\n        for (final var edge : edges) {\\n            final int type = edge[TYPE];\\n            final int u = edge[U];\\n            final int v = edge[V];\\n\\n            // Add the edge to both UnionFind data structures if it is of type BOTH\\n            added += switch (type) {\\n                case BOTH -> \\n                    aliceUf.union(u, v) | bobUf.union(u, v);\\n                case ALICE -> aliceUf.union(u, v);\\n                default -> bobUf.union(u, v);\\n            };\\n\\n            // If both UnionFind data structures are united, return the number of edges that were not added\\n            if (aliceUf.isUnited() && bobUf.isUnited())\\n                return edges.length - added;\\n        }\\n\\n        // If both UnionFind data structures are not united, it is impossible to remove enough edges to make them united\\n        return -1;\\n    }\\n}\\n\\nclass UnionFind {\\n    static final int ZERO = 0;\\n    final int[] parent;\\n    int groups;\\n\\n    // Initialize the UnionFind data structure with n groups\\n    UnionFind(final int n) {\\n        parent = new int[n + 1];\\n        groups = n;\\n    }\\n\\n    // Union two elements and return 1 if they were not already in the same group, 0 otherwise\\n    int union(final int u, final int v) {\\n        final int uParent = find(u);\\n        final int vParent = find(v);\\n        if (uParent == vParent)\\n            return 0;\\n        parent[uParent] = vParent;\\n        --groups;\\n        return 1;\\n    }\\n\\n    // Find the parent of an element and perform path compression\\n    int find(final int v) {\\n        if (parent[v] != ZERO)\\n            return parent[v] = find(parent[v]);\\n        return v;\\n    }\\n\\n    // Check if all elements are in the same group\\n    boolean isUnited() {\\n        return groups == 1;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\nprivate:\\n    // constants for the edge types indices\\n    static constexpr int \\n        TYPE = 0, U = 1, V =2,\\n        ALICE = 1, BOB = 2, BOTH = 3;\\n\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        // Move all edges of type BOTH to the end of the array\\n        for (int i = 0, j = edges.size() - 1; i < j; ) {\\n            if (edges[i][TYPE] == BOTH) {\\n                ++i;\\n                continue;\\n            }\\n            swap(edges[i], edges[j]);\\n            --j;\\n        }\\n\\n        // Create two UnionFind data structures, one for Alice and one for Bob\\n        UnionFind alice_uf(n), bob_uf(n);\\n        int added = 0;\\n\\n        // Iterate over the edges and add them to the appropriate UnionFind data structure\\n        for (const auto& edge : edges) {\\n            const int type = edge[TYPE];\\n            const int u = edge[U];\\n            const int v = edge[V];\\n\\n            // Add the edge to both UnionFind data structures if it is of type BOTH\\n            added += (type == BOTH) ? \\n                alice_uf.union_(u, v) | bob_uf.union_(u, v) :\\n                (type == ALICE) ? alice_uf.union_(u, v) : bob_uf.union_(u, v);\\n\\n            // If both UnionFind data structures are united, return the number of edges that were not added\\n            if (alice_uf.is_united() && bob_uf.is_united())\\n                return edges.size() - added;\\n        }\\n\\n        // If both UnionFind data structures are united, return the number of edges that were not added\\n        if (alice_uf.is_united() && bob_uf.is_united())\\n            return edges.size() - added;\\n\\n        // If both UnionFind data structures are not united, it is impossible to remove enough edges to make them united\\n        return -1;\\n    }\\n};\\n\\nclass UnionFind {\\nprivate:\\n    vector<int> parent;\\n    int groups;\\n\\npublic:\\n    // Initialize the UnionFind data structure with n groups\\n    UnionFind(int n) : parent(n + 1), groups(n) {\\n        iota(parent.begin(), parent.end(), 0);\\n    }\\n\\n    // Union two elements and return 1 if they were not already in the same group, 0 otherwise\\n    int union_(int u, int v) {\\n        const int uParent = find_(u);\\n        const int vParent = find_(v);\\n        if (uParent == vParent)\\n            return 0;\\n        parent[uParent] = vParent;\\n        --groups;\\n        return 1;\\n    }\\n\\n    // Find the parent of an element and perform path compression\\n    int find_(int v) {\\n        if (parent[v] != v)\\n            parent[v] = find_(parent[v]);\\n        return parent[v];\\n    }\\n\\n    // Check if all elements are in the same group\\n    bool is_united() {\\n        return groups == 1;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n   # constants for the edge types indices\\n    TYPE, U, V, ALICE, BOB, BOTH = range(6)\\n\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        # Move all edges of type BOTH to the end of the array\\n        i, j = 0, len(edges) - 1\\n        while i < j:\\n            if edges[i][self.TYPE] == self.BOTH:\\n                i += 1\\n                continue\\n            edges[i], edges[j] = edges[j], edges[i]\\n            j -= 1\\n\\n        # Create two UnionFind data structures, one for Alice and one for Bob\\n        alice_uf, bob_uf = UnionFind(n), UnionFind(n)\\n        added = 0\\n\\n        # Iterate over the edges and add them to the appropriate UnionFind data structure\\n        for edge in edges:\\n            type_, u, v = edge[self.TYPE], edge[self.U], edge[self.V]\\n\\n            # Add the edge to both UnionFind data structures if it is of type BOTH\\n            if type_ == self.BOTH:\\n                added += alice_uf.union(u, v) | bob_uf.union(u, v)\\n            elif type_ == self.ALICE:\\n                added += alice_uf.union(u, v)\\n            else:\\n                added += bob_uf.union(u, v)\\n\\n            # If both UnionFind data structures are united, return the number of edges that were not added\\n            if alice_uf.is_united() and bob_uf.is_united():\\n                return len(edges) - added\\n\\n        # If both UnionFind data structures are not united, it is impossible to remove enough edges to make them united\\n        if not alice_uf.is_united() or not bob_uf.is_united():\\n            return -1\\n\\n        # If both UnionFind data structures are united, return the number of edges that were not added\\n        return len(edges) - added\\n\\n\\nclass UnionFind:\\n    def __init__(self, n: int):\\n        self.parent = list(range(n + 1))\\n        self.groups = n\\n\\n    def union(self, u: int, v: int) -> int:\\n        u_parent = self.find(u)\\n        v_parent = self.find(v)\\n        if u_parent == v_parent:\\n            return 0\\n        self.parent[u_parent] = v_parent\\n        self.groups -= 1\\n        return 1\\n\\n    def find(self, v: int) -> int:\\n        if self.parent[v] != v:\\n            self.parent[v] = self.find(self.parent[v])\\n        return self.parent[v]\\n\\n    def is_united(self) -> bool:\\n        return self.groups == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831478,
                "title": "python-union-find-3-times-o-n",
                "content": "**Idea**\\n\\nWe simply run Union-Find three times:\\n\\n- first on `Type1` \\n- then on `Type2` and `Type3` simultaneously\\n\\nIncrement `ans` whenever we find redundant edges. Remember to check if the graph is fully connected at the end.\\n\\n<br />\\n\\n**Complexity**\\n\\nTime complexity: `O(N)`\\nSpace complexity: `O(N)`\\n\\n<br />\\n\\n**Python**\\n```Python\\nclass UnionFindSet:\\n    def __init__(self, n):\\n        self.parents = list(range(n))\\n        self.ranks = [1] * n\\n        self.size = 1\\n        \\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv:\\n            return False\\n        if self.ranks[pu] > self.ranks[pv]:\\n            self.parents[pv] = pu\\n        elif self.ranks[pv] > self.ranks[pu]:\\n            self.parents[pu] = pv\\n        else:\\n            self.parents[pu] = pv\\n            self.ranks[pv] += 1\\n        self.size += 1\\n        return True\\n    \\n    \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        uf1, uf2, ans = UnionFindSet(n), UnionFindSet(n), 0\\n\\t\\t\\n        for t, u, v in edges:\\n            if t != 3:\\n                continue\\n            if not uf1.union(u - 1, v - 1) or not uf2.union(u - 1, v - 1):\\n                ans += 1\\n        \\n        for t, u, v in edges:\\n            if t == 1 and not uf1.union(u - 1, v - 1):\\n                ans += 1\\n            elif t == 2 and not uf2.union(u - 1, v - 1):\\n                ans += 1\\n   \\n        return ans if uf1.size == n and uf2.size == n else -1\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass UnionFindSet:\\n    def __init__(self, n):\\n        self.parents = list(range(n))\\n        self.ranks = [1] * n\\n        self.size = 1\\n        \\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv:\\n            return False\\n        if self.ranks[pu] > self.ranks[pv]:\\n            self.parents[pv] = pu\\n        elif self.ranks[pv] > self.ranks[pu]:\\n            self.parents[pu] = pv\\n        else:\\n            self.parents[pu] = pv\\n            self.ranks[pv] += 1\\n        self.size += 1\\n        return True\\n    \\n    \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        uf1, uf2, ans = UnionFindSet(n), UnionFindSet(n), 0\\n\\t\\t\\n        for t, u, v in edges:\\n            if t != 3:\\n                continue\\n            if not uf1.union(u - 1, v - 1) or not uf2.union(u - 1, v - 1):\\n                ans += 1\\n        \\n        for t, u, v in edges:\\n            if t == 1 and not uf1.union(u - 1, v - 1):\\n                ans += 1\\n            elif t == 2 and not uf2.union(u - 1, v - 1):\\n                ans += 1\\n   \\n        return ans if uf1.size == n and uf2.size == n else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484589,
                "title": "java-easy-approach-with-explanation-union-find",
                "content": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) \\n    {\\n        Arrays.sort(edges, (a, b)->{\\n            return b[0]-a[0];\\n        });//giving the priority to third type of edge or the edge which Bob and Alice both can access\\n        \\n        //1-based indexing of nodes \\n        int []parentAlice= new int[n+1];//Graph 1 for Alice connectedness\\n        int []parentBob= new int[n+1];//Graph 2 for Bob connectedness\\n        \\n        for(int i= 0; i< n+1; i++){//every node is pointing to itself, at first no connection is considered all sets are independent(no dependency) \\n            parentAlice[i]= i;\\n            parentBob[i]= i;\\n        }\\n        \\n        //number of merged unique node for Alice and Bob that are required to maintain the connectedness of Alice and Bob graph nodes//intialised with one because merging happens in pair \\n        int mergeAlice= 1;\\n        int mergeBob= 1;\\n        \\n        //number of cyclic or the non dependent node, that are not required for the connectedness of Alice and Bob nodes  \\n        int removeEdge= 0;\\n        \\n        for(int []edge: edges)\\n        {\\n            int cat= edge[0];//category of edge 1)edge Alice can only access 2)edge Bob can only access 3)edge both Alice and Bob can access\\n            int u= edge[1];\\n            int v= edge[2];\\n            \\n            if(cat == 3){//edge both Alice and Bob an access\\n                \\n                //creating dependency of nodes in graph 1 and 2 \\n                boolean tempAlice= union(u, v, parentAlice);\\n                boolean tempBob= union(u, v, parentBob);\\n                \\n                if(tempAlice == true)\\n                    mergeAlice+= 1;\\n                \\n                if(tempBob == true)\\n                    mergeBob+= 1;\\n                \\n                if(tempAlice == false && tempBob == false)//retundant or the cyclic non-dependent edge//both Alice and Bob don\\'t rquire it connection is already there between these pair of nodes\\n                    removeEdge+= 1;\\n            }\\n            else if(cat == 2){//edge Bob can only access \\n                \\n                //creating dependency of nodes in graph 2\\n                boolean tempBob= union(u, v, parentBob);\\n                \\n                if(tempBob == true)\\n                    mergeBob+= 1;\\n                else//no merging of set is done, that means that this edge is not required because it will form cycle or the dependency \\n                    removeEdge+= 1;\\n            }\\n            else{//edge Alice can only access \\n                \\n                //creating dependency of nodes in graph 1\\n                boolean tempAlice= union(u, v, parentAlice);\\n                \\n                if(tempAlice == true)\\n                    mergeAlice+= 1; \\n                else//no merging of set is done, that means that this edge is not required because it will form cycle or the dependency \\n                    removeEdge+= 1;\\n            }\\n        }\\n        if(mergeAlice != n || mergeBob != n)//all node are not connected, connectedness is not maintained \\n            return -1;\\n        return removeEdge;//number of edge removed by maintaining the connectedness \\n    }\\n    \\n    public int find(int x, int[] parent)\\n    {\\n        if(parent[x] == x)//when we found the absolute root or the leader of the set \\n            return x;\\n        \\n        int temp= find(parent[x], parent);\\n        \\n        parent[x]= temp;//Path Compression//child pointing to the absolute root or the leader of the set, while backtracking\\n        \\n        return temp;//returning the absolute root \\n    }\\n    \\n    public boolean union(int x, int y, int[] parent)\\n    {\\n        int lx= find(x, parent);//leader of set x or the absolute root\\n        int ly= find(y, parent);//leader of set y or the absolute root\\n        \\n        if(lx != ly){//belong to different set merging \\n            \\n            //Rank Compression is not done, but you can do it \\n            parent[lx]= ly;\\n            \\n            return true;//union done, dependency created\\n        }\\n        else\\n            return false;//no union done cycle is due to this edge \\n    }//Please do Upvote, it helps a lot \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) \\n    {\\n        Arrays.sort(edges, (a, b)->{\\n            return b[0]-a[0];\\n        });//giving the priority to third type of edge or the edge which Bob and Alice both can access\\n        \\n        //1-based indexing of nodes \\n        int []parentAlice= new int[n+1];//Graph 1 for Alice connectedness\\n        int []parentBob= new int[n+1];//Graph 2 for Bob connectedness\\n        \\n        for(int i= 0; i< n+1; i++){//every node is pointing to itself, at first no connection is considered all sets are independent(no dependency) \\n            parentAlice[i]= i;\\n            parentBob[i]= i;\\n        }\\n        \\n        //number of merged unique node for Alice and Bob that are required to maintain the connectedness of Alice and Bob graph nodes//intialised with one because merging happens in pair \\n        int mergeAlice= 1;\\n        int mergeBob= 1;\\n        \\n        //number of cyclic or the non dependent node, that are not required for the connectedness of Alice and Bob nodes  \\n        int removeEdge= 0;\\n        \\n        for(int []edge: edges)\\n        {\\n            int cat= edge[0];//category of edge 1)edge Alice can only access 2)edge Bob can only access 3)edge both Alice and Bob can access\\n            int u= edge[1];\\n            int v= edge[2];\\n            \\n            if(cat == 3){//edge both Alice and Bob an access\\n                \\n                //creating dependency of nodes in graph 1 and 2 \\n                boolean tempAlice= union(u, v, parentAlice);\\n                boolean tempBob= union(u, v, parentBob);\\n                \\n                if(tempAlice == true)\\n                    mergeAlice+= 1;\\n                \\n                if(tempBob == true)\\n                    mergeBob+= 1;\\n                \\n                if(tempAlice == false && tempBob == false)//retundant or the cyclic non-dependent edge//both Alice and Bob don\\'t rquire it connection is already there between these pair of nodes\\n                    removeEdge+= 1;\\n            }\\n            else if(cat == 2){//edge Bob can only access \\n                \\n                //creating dependency of nodes in graph 2\\n                boolean tempBob= union(u, v, parentBob);\\n                \\n                if(tempBob == true)\\n                    mergeBob+= 1;\\n                else//no merging of set is done, that means that this edge is not required because it will form cycle or the dependency \\n                    removeEdge+= 1;\\n            }\\n            else{//edge Alice can only access \\n                \\n                //creating dependency of nodes in graph 1\\n                boolean tempAlice= union(u, v, parentAlice);\\n                \\n                if(tempAlice == true)\\n                    mergeAlice+= 1; \\n                else//no merging of set is done, that means that this edge is not required because it will form cycle or the dependency \\n                    removeEdge+= 1;\\n            }\\n        }\\n        if(mergeAlice != n || mergeBob != n)//all node are not connected, connectedness is not maintained \\n            return -1;\\n        return removeEdge;//number of edge removed by maintaining the connectedness \\n    }\\n    \\n    public int find(int x, int[] parent)\\n    {\\n        if(parent[x] == x)//when we found the absolute root or the leader of the set \\n            return x;\\n        \\n        int temp= find(parent[x], parent);\\n        \\n        parent[x]= temp;//Path Compression//child pointing to the absolute root or the leader of the set, while backtracking\\n        \\n        return temp;//returning the absolute root \\n    }\\n    \\n    public boolean union(int x, int y, int[] parent)\\n    {\\n        int lx= find(x, parent);//leader of set x or the absolute root\\n        int ly= find(y, parent);//leader of set y or the absolute root\\n        \\n        if(lx != ly){//belong to different set merging \\n            \\n            //Rank Compression is not done, but you can do it \\n            parent[lx]= ly;\\n            \\n            return true;//union done, dependency created\\n        }\\n        else\\n            return false;//no union done cycle is due to this edge \\n    }//Please do Upvote, it helps a lot \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831509,
                "title": "python3-union-find",
                "content": "Edited on 9/7/2020. \\n\\nAs practicing more on LC, we realize the importance of union-find data structure. Even though there isn\\'t a builtin implementatin in Python, it is not difficult to do one from scratch. I have one [here](https://github.com/gaosanyong/algorithms/blob/master/unionfind.py) for reference. \\n\\nIn addition, I see lots of people taking part of union-find and mixing it along with the implementation of this problem. Personally, I prefer to start from a standard complete data structure. It is easier for developers to implment and easier for readers to understand. \\n\\n```\\nclass UnionFind:\\n    \"\"\"A minimalist standalone union-find implementation.\"\"\"\\n    def __init__(self, n):\\n        self.count = n               # number of disjoint sets \\n        self.parent = list(range(n)) # parent of given nodes\\n        self.rank = [1]*n            # rank (aka size) of sub-tree \\n        \\n    def find(self, p):\\n        \"\"\"Find with path compression.\"\"\"\\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p]) # path compression \\n        return self.parent[p]\\n    \\n    def union(self, p, q):\\n        \"\"\"Union with ranking.\"\"\"\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False\\n        self.count -= 1 # one more connection => one less disjoint \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt # add small sub-tree to large sub-tree for balancing\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt] # ranking \\n        return True\\n    \\n        \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        ufa = UnionFind(n) # for Alice\\n        ufb = UnionFind(n) # for Bob\\n        \\n        ans = 0\\n        edges.sort(reverse=True) \\n        for t, u, v in edges: \\n            u, v = u-1, v-1\\n            if t == 3: ans += not (ufa.union(u, v) and ufb.union(u, v)) # Alice & Bob\\n            elif t == 2: ans += not ufb.union(u, v)                     # Bob only\\n            else: ans += not ufa.union(u, v)                            # Alice only\\n        return ans if ufa.count == 1 and ufb.count == 1 else -1 # check if uf is connected \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    \"\"\"A minimalist standalone union-find implementation.\"\"\"\\n    def __init__(self, n):\\n        self.count = n               # number of disjoint sets \\n        self.parent = list(range(n)) # parent of given nodes\\n        self.rank = [1]*n            # rank (aka size) of sub-tree \\n        \\n    def find(self, p):\\n        \"\"\"Find with path compression.\"\"\"\\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p]) # path compression \\n        return self.parent[p]\\n    \\n    def union(self, p, q):\\n        \"\"\"Union with ranking.\"\"\"\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False\\n        self.count -= 1 # one more connection => one less disjoint \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt # add small sub-tree to large sub-tree for balancing\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt] # ranking \\n        return True\\n    \\n        \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        ufa = UnionFind(n) # for Alice\\n        ufb = UnionFind(n) # for Bob\\n        \\n        ans = 0\\n        edges.sort(reverse=True) \\n        for t, u, v in edges: \\n            u, v = u-1, v-1\\n            if t == 3: ans += not (ufa.union(u, v) and ufb.union(u, v)) # Alice & Bob\\n            elif t == 2: ans += not ufb.union(u, v)                     # Bob only\\n            else: ans += not ufa.union(u, v)                            # Alice only\\n        return ans if ufa.count == 1 and ufb.count == 1 else -1 # check if uf is connected \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505983,
                "title": "c-using-disjoint-set",
                "content": "**Please Upvote  if you like the Solution!**\\n\\n    class Solution {\\n    public:\\n    bool static comp(vector<int> &a ,vector<int> &b)//Compare according to type-3\\n    {\\n        return a[0]>b[0];\\n    }\\n    int findparent(int node,vector<int> &parent)//find parent function (fro disjoint set)\\n    {\\n        if(node==parent[node])\\n            return node;\\n        return parent[node]=findparent(parent[node],parent);\\n    }\\n    bool unionn(int u,int v,vector<int> &parent,vector<int> &rank)//Union function\\n    {\\n        u=findparent(u,parent);\\n        v=findparent(v,parent);\\n        \\n        if(u!=v)// when u and v are not equal return true else return false\\n        {\\n            if(rank[u]<rank[v])\\n                parent[u]=v;\\n            else if(rank[u]>rank[v])\\n                parent[v]=u;\\n            else\\n            {\\n                parent[v]=u;\\n                rank[u]++;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) \\n    {\\n        sort(edges.begin(),edges.end(),comp);//sort according to type 3, because type 3 solves problem of both alice and bob\\n        \\n        vector<int> parent_Alice(n+1);\\n        vector<int> parent_Bob(n+1);\\n        vector<int> rank_Alice(n+1);\\n        vector<int> rank_Bob(n+1);\\n        \\n        //Initialize the parent and rank Array\\n        for(int i=0;i<parent_Alice.size();i++)\\n        {\\n            parent_Alice[i]=i;//intially every node is their own parent and rank of all is 1\\n            parent_Bob[i]=i;\\n            rank_Alice[i]=1;\\n            rank_Bob[i]=1;\\n        }\\n        int merge_Alice=1;//to count how many nodes we already processed for alice\\n        int merge_Bob=1;//to count how many nodes we already processed for bob\\n        \\n        int remove_edges=0;//for counting how many edges we remove\\n        \\n        for(auto it:edges)\\n        {\\n            if(it[0]==3)//for type-3 edges,which is followed by both bob and Alice\\n            {\\n                bool temp_Alice=unionn(it[1],it[2],parent_Alice,rank_Alice);//unionn when it[0] is of type-3 for Alice\\n                bool temp_Bob=unionn(it[1],it[2],parent_Bob,rank_Bob);//unionnn when it[0] is of type-3 for Bob\\n                 if(temp_Alice==true)//if it[0] and it[1] are not merged increase merge count\\n                    merge_Alice++;\\n                \\n                if(temp_Bob==true)\\n                    merge_Bob++;\\n                \\n                if(temp_Alice==false && temp_Bob==false)//when they are already merged,then increase count of removed edges\\n                    remove_edges++;\\n            }\\n            else if(it[0]==1)//for type 1, path followed by Alice\\n            {\\n                 bool temp_Alice=unionn(it[1],it[2],parent_Alice,rank_Alice);//unionn for Alice\\n                \\n                 if(temp_Alice==true)//if unionn function is true, increase merge_ALice count\\n                    merge_Alice++;\\n                 else\\n                     remove_edges++;//increase remove edges count, if unionn is false\\n            }\\n            else\\n            {\\n                bool temp_Bob=unionn(it[1],it[2],parent_Bob,rank_Bob);//for type2,which is followed by bob\\n                 \\n                if(temp_Bob==true)\\n                    merge_Bob++;\\n                 else\\n                     remove_edges++;\\n            }\\n        }\\n        if(merge_Alice!=n || merge_Bob!=n)//when merge count is not equal to number of nodes return -1\\n        {\\n            return -1;\\n        }\\n        return remove_edges;\\n      }\\n      };",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\n    public:\\n    bool static comp(vector<int> &a ,vector<int> &b)//Compare according to type-3\\n    {\\n        return a[0]>b[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 831504,
                "title": "c-union-find-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Union Find\\n\\nCreate two UnionFinds `a` and `b` for Alice and Bob respectively.\\n\\nWe should take type 3 edges first, then type 1 and 2.\\n\\nIf two nodes are already connected, we increment the answer `ans`. Otherwise we connect them.\\n\\nIn the end, if `a.getSize() == 1 && b.size() == 1` meaning that the graph is all connected for both Alice and Bob, we return `ans`; otherwise return `-1`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N)\\nclass UnionFind{\\n    vector<int> id;\\n    int size;\\npublic:\\n    UnionFind(int N ): id(N), size(N) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    int connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n    void connect(int a, int b) {\\n        int p = find(a), q = find(b);\\n        if (p == q) return;\\n        id[p] = q;\\n        --size;\\n    }\\n    int getSize() { return size; }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& E) {\\n        UnionFind a(n), b(n);\\n        int ans = 0;\\n        for (auto &e : E) {\\n            if (e[0] != 3) continue;\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (a.connected(u, v)) {\\n                ++ans;\\n                continue;\\n            }\\n            a.connect(u, v);\\n            b.connect(u, v);\\n        }\\n        for (auto &e : E) {\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (e[0] == 1) {\\n                if (a.connected(u, v)) ++ans;\\n                else a.connect(u, v);\\n            } else if (e[0] == 2) {\\n                if (b.connected(u, v)) ++ans;\\n                else b.connect(u, v);\\n            }\\n        }\\n        return a.getSize() != 1 || b.getSize() != 1 ? -1 : ans;\\n    }\\n};\\n```\\n\\n---\\n\\nThe following code can beat 100% (~1000ms run time) but the idea is exactly the same.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N)\\n// The following block might trivially improve the exec time.\\nstatic const auto __optimize__ = []() {\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(NULL);\\n    return 0;\\n}();\\nclass UnionFind{\\n    vector<int> id;\\n    int size;\\npublic:\\n    UnionFind(int N ): id(N), size(N) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    int connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n    void connect(int a, int b) {\\n        int p = find(a), q = find(b);\\n        if (p == q) return;\\n        id[p] = q;\\n        --size;\\n    }\\n    int getSize() { return size; }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& E) {\\n        UnionFind a(n), b(n);\\n        int ans = 0;\\n        for (auto &e : E) {\\n            if (e[0] != 3) continue;\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (a.connected(u, v)) {\\n                ++ans;\\n                continue;\\n            }\\n            a.connect(u, v);\\n            b.connect(u, v);\\n        }\\n        for (auto &e : E) {\\n            if (e[0] != 1) continue;\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (a.connected(u, v)) ++ans;\\n            else a.connect(u, v);\\n        }\\n        if (a.getSize() != 1) return -1;\\n        for (auto &e : E) {\\n            if (e[0] != 2) continue;\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (b.connected(u, v)) ++ans;\\n            else b.connect(u, v);\\n        }\\n        return b.getSize() != 1 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N)\\nclass UnionFind{\\n    vector<int> id;\\n    int size;\\npublic:\\n    UnionFind(int N ): id(N), size(N) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    int connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n    void connect(int a, int b) {\\n        int p = find(a), q = find(b);\\n        if (p == q) return;\\n        id[p] = q;\\n        --size;\\n    }\\n    int getSize() { return size; }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& E) {\\n        UnionFind a(n), b(n);\\n        int ans = 0;\\n        for (auto &e : E) {\\n            if (e[0] != 3) continue;\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (a.connected(u, v)) {\\n                ++ans;\\n                continue;\\n            }\\n            a.connect(u, v);\\n            b.connect(u, v);\\n        }\\n        for (auto &e : E) {\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (e[0] == 1) {\\n                if (a.connected(u, v)) ++ans;\\n                else a.connect(u, v);\\n            } else if (e[0] == 2) {\\n                if (b.connected(u, v)) ++ans;\\n                else b.connect(u, v);\\n            }\\n        }\\n        return a.getSize() != 1 || b.getSize() != 1 ? -1 : ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N)\\n// The following block might trivially improve the exec time.\\nstatic const auto __optimize__ = []() {\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(NULL);\\n    return 0;\\n}();\\nclass UnionFind{\\n    vector<int> id;\\n    int size;\\npublic:\\n    UnionFind(int N ): id(N), size(N) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    int connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n    void connect(int a, int b) {\\n        int p = find(a), q = find(b);\\n        if (p == q) return;\\n        id[p] = q;\\n        --size;\\n    }\\n    int getSize() { return size; }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& E) {\\n        UnionFind a(n), b(n);\\n        int ans = 0;\\n        for (auto &e : E) {\\n            if (e[0] != 3) continue;\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (a.connected(u, v)) {\\n                ++ans;\\n                continue;\\n            }\\n            a.connect(u, v);\\n            b.connect(u, v);\\n        }\\n        for (auto &e : E) {\\n            if (e[0] != 1) continue;\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (a.connected(u, v)) ++ans;\\n            else a.connect(u, v);\\n        }\\n        if (a.getSize() != 1) return -1;\\n        for (auto &e : E) {\\n            if (e[0] != 2) continue;\\n            int u = e[1] - 1, v = e[2] - 1;\\n            if (b.connected(u, v)) ++ans;\\n            else b.connect(u, v);\\n        }\\n        return b.getSize() != 1 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831786,
                "title": "minimum-weight-spanning-tree-prim-s-algorithm",
                "content": "The problem is essentially finding the minimum weight spanning tree for the graph for both Alice and Bob if we assign weights: say Type 3, 1, Type 1 and 2,  2.\\n\\nOne such algorithm is Prim\\'s algorithm. (I learnt it during the contest since I didn\\'t know any algo for weighted spanning trees.) The basic idea is simply (copied from wikipedia):\\n1. Initialize a tree with a single vertex, chosen arbitrarily from the graph.\\n2. Grow the tree by one edge: of the edges that connect the tree to vertices not yet in the tree, find the minimum-weight edge, and transfer it to the tree.\\n3. Repeat step 2 (until all vertices are in the tree).\\n\\nMore details found here. [https://en.wikipedia.org/wiki/Prim%27s_algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)\\n\\nHere are my codes:\\n```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n\\t\\t# process graph\\n        graphs = [collections.defaultdict(list) for _ in range(3)]\\n        for c, i, j in edges:\\n            graphs[c-1][i].append((-c, j))\\n            graphs[c-1][j].append((-c, i))\\n\\t\\t# build tree for Alice\\n        e = graphs[2][1] + graphs[0][1]\\n        heapq.heapify(e)\\n        treeset = set([1])\\n        type3 = 0\\n        while e:\\n            c, y = heapq.heappop(e)\\n            if y not in treeset:\\n                treeset.add(y)\\n                if c == -3:\\n                    type3 += 1\\n                for item in graphs[2][y]:\\n                    heapq.heappush(e, item)\\n                for item in graphs[0][y]:\\n                    heapq.heappush(e, item)\\n        if len(treeset) != n:\\n            return -1\\n\\t\\t# build tree for Bob\\n        e = graphs[2][1] + graphs[1][1]\\n        heapq.heapify(e)\\n        treeset = set([1])\\n        while e:\\n            c, y = heapq.heappop(e)\\n            if y not in treeset:\\n                treeset.add(y)\\n                for item in graphs[2][y]:\\n                    heapq.heappush(e, item)\\n                for item in graphs[1][y]:\\n                    heapq.heappush(e, item)\\n        if len(treeset) != n:\\n            return -1\\n        return len(edges) + type3 - 2 * (n - 1)\\n```\\n\\nMy solution is by no means optimal. I think Prim\\'s Algorithm in this case can be implemented using BFS (since we know what are the low weight edges):\\n1. We don\\'t care about the weights for Bob because if there exists a spanning tree for him, then there must be one with Type 3 edges precisely those in the one built for Alice (and it is also one with minimum weight for Bob).  So we just need to check if there is a spanning tree for Bob and this can be done using BFS, DFS etc with time complexity ```O(E)```.\\n2. The part for finding the MWSP for Alice can also be achieved in ```O(E)```. Starting from one node say ```1```, we build the spanning tree for the connected component containing ```1```  in the subgraph consisting of Type 3 edges using BFS and then do the same thing for Type 1 edges using BFS. \\n\\nIn short, BFS for the Type 3 edges, then BFS for the Type 1 edges. This get rids of the use of heap in my code, and improves performance. \\n\\n\\nThere are many great solutions using Kruskal\\'s algorithm with union-find implementation. Just want to point this out. \\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n\\t\\t# process graph\\n        graphs = [collections.defaultdict(list) for _ in range(3)]\\n        for c, i, j in edges:\\n            graphs[c-1][i].append((-c, j))\\n            graphs[c-1][j].append((-c, i))\\n\\t\\t# build tree for Alice\\n        e = graphs[2][1] + graphs[0][1]\\n        heapq.heapify(e)\\n        treeset = set([1])\\n        type3 = 0\\n        while e:\\n            c, y = heapq.heappop(e)\\n            if y not in treeset:\\n                treeset.add(y)\\n                if c == -3:\\n                    type3 += 1\\n                for item in graphs[2][y]:\\n                    heapq.heappush(e, item)\\n                for item in graphs[0][y]:\\n                    heapq.heappush(e, item)\\n        if len(treeset) != n:\\n            return -1\\n\\t\\t# build tree for Bob\\n        e = graphs[2][1] + graphs[1][1]\\n        heapq.heapify(e)\\n        treeset = set([1])\\n        while e:\\n            c, y = heapq.heappop(e)\\n            if y not in treeset:\\n                treeset.add(y)\\n                for item in graphs[2][y]:\\n                    heapq.heappush(e, item)\\n                for item in graphs[1][y]:\\n                    heapq.heappush(e, item)\\n        if len(treeset) != n:\\n            return -1\\n        return len(edges) + type3 - 2 * (n - 1)\\n```\n```O(E)```\n```O(E)```\n```1```\n```1```",
                "codeTag": "Java"
            },
            {
                "id": 3468127,
                "title": "c-union-find-implementation",
                "content": "# Code\\n```\\nclass UnionFind {\\n    vector<int> representative;\\n    vector<int> componentSize;\\n    int components;\\n    \\npublic:\\n    UnionFind(int n) {\\n        components = n;\\n        for (int i = 0; i <= n; i++) {\\n            representative.push_back(i);\\n            componentSize.push_back(1);\\n        }\\n    }\\n    \\n    int findRepresentative(int x) {\\n        if (representative[x] == x) {\\n            return x;\\n        }\\n        return representative[x] = findRepresentative(representative[x]);\\n    }\\n    \\n    int performUnion(int x, int y) {       \\n        x = findRepresentative(x); y = findRepresentative(y);\\n        \\n        if (x == y) {\\n            return 0;\\n        }\\n        \\n        if (componentSize[x] > componentSize[y]) {\\n            componentSize[x] += componentSize[y];\\n            representative[y] = x;\\n        } else {\\n            componentSize[y] += componentSize[x];\\n            representative[x] = y;\\n        }\\n        \\n        components--;\\n        return 1;\\n    }\\n\\n    bool isConnected() {\\n        return components == 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind Alice(n), Bob(n);\\n\\n        int edgesRequired = 0;\\n        for (vector<int>& edge : edges) {\\n            if (edge[0] == 3) {\\n                edgesRequired += (Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2]));\\n            }\\n        }\\n\\n        for (vector<int>& edge : edges) {\\n            if (edge[0] == 1) {\\n                edgesRequired += Alice.performUnion(edge[1], edge[2]);\\n            } else if (edge[0] == 2) {\\n                edgesRequired += Bob.performUnion(edge[1], edge[2]);\\n            }\\n        }\\n\\n        if (Alice.isConnected() && Bob.isConnected()) {\\n            return edges.size() - edgesRequired;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind {\\n    vector<int> representative;\\n    vector<int> componentSize;\\n    int components;\\n    \\npublic:\\n    UnionFind(int n) {\\n        components = n;\\n        for (int i = 0; i <= n; i++) {\\n            representative.push_back(i);\\n            componentSize.push_back(1);\\n        }\\n    }\\n    \\n    int findRepresentative(int x) {\\n        if (representative[x] == x) {\\n            return x;\\n        }\\n        return representative[x] = findRepresentative(representative[x]);\\n    }\\n    \\n    int performUnion(int x, int y) {       \\n        x = findRepresentative(x); y = findRepresentative(y);\\n        \\n        if (x == y) {\\n            return 0;\\n        }\\n        \\n        if (componentSize[x] > componentSize[y]) {\\n            componentSize[x] += componentSize[y];\\n            representative[y] = x;\\n        } else {\\n            componentSize[y] += componentSize[x];\\n            representative[x] = y;\\n        }\\n        \\n        components--;\\n        return 1;\\n    }\\n\\n    bool isConnected() {\\n        return components == 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind Alice(n), Bob(n);\\n\\n        int edgesRequired = 0;\\n        for (vector<int>& edge : edges) {\\n            if (edge[0] == 3) {\\n                edgesRequired += (Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2]));\\n            }\\n        }\\n\\n        for (vector<int>& edge : edges) {\\n            if (edge[0] == 1) {\\n                edgesRequired += Alice.performUnion(edge[1], edge[2]);\\n            } else if (edge[0] == 2) {\\n                edgesRequired += Bob.performUnion(edge[1], edge[2]);\\n            }\\n        }\\n\\n        if (Alice.isConnected() && Bob.isConnected()) {\\n            return edges.size() - edgesRequired;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833089,
                "title": "java-detailed-explanation-no-union-find-another-easy-understand-thought",
                "content": "**Key Notes:**\\n- build a graph with **type 3 only**: then remove edges which form a cycle (they are not needed anyway in the future **under ALL circumstances**) and update in final \"res\"\\n- count edges for Alice with **type 1 and type 3**. res += (totalEdges - (n - 1)), **BUT** if totalEdges < n - 1 or coverd nodes != n return -1.\\n- count edges for Bob with **type 2 and type 3**. res += (totalEdges - (n - 1)), **BUT** if totalEdges < n - 1 or coverd nodes != n return -1.\\n\\n```java\\npublic int maxNumEdgesToRemove(int n, int[][] edges) {\\n        \\n\\tint res = 0;\\n\\n\\t// build type 3 only graph, and remove unnecessary edges which can form cycles\\n\\tSet<String> removedEdges = new HashSet<>();\\n\\tres += helper(edges, n, removedEdges);\\n\\n\\t// count type 1 + 3 only edges for Alice: make sure: cover all nodes + edgesNum >= n - 1\\n\\tSet<Integer> nodes = new HashSet<>();\\n\\tint edgeCount = countEdges(2, removedEdges, nodes, edges);\\n\\tif (edgeCount < n - 1 || nodes.size() < n) return -1;\\n\\tres += (edgeCount - (n - 1));\\n\\n\\t// count type 2 + 3 only edges for Bob: make sure: cover all nodes + edgesNum >= n - 1\\n\\tnodes = new HashSet<>();\\n\\tedgeCount = countEdges(1, removedEdges, nodes, edges);\\n\\tif (edgeCount < n - 1 || nodes.size() < n) return -1;\\n\\tres += (edgeCount - (n - 1));\\n\\n\\treturn res;\\n}\\n\\n// helper to build type 3 only graph, store in removedEdges set, return num of edges removed\\nprivate int helper(int[][] edges, int n, Set<String> removedEdges) {\\n\\n\\tint numEdgesRemoved = 0;\\n\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\n\\tfor (int[] edge : edges) {\\n\\t\\tif (edge[0] != 3) continue;\\n\\t\\tint a = edge[1], b = edge[2];\\n\\t\\tmap.computeIfAbsent(a, f -> new ArrayList<>()).add(b);\\n\\t\\tmap.computeIfAbsent(b, f -> new ArrayList<>()).add(a);\\n\\t}\\n\\n\\n\\tint[] visited = new int[n + 1];  // 0: not visited, > 0: depth\\n\\n\\tfor (int i = 1; i <= n; ++i) {\\n\\t\\tif (visited[i] != 0) continue;\\n\\t\\tnumEdgesRemoved += dfs(map, visited, i, 1, removedEdges);\\n\\t}\\n\\n\\treturn numEdgesRemoved;\\n}\\n\\n// dfs for removing circle edges recursively\\nprivate int dfs(Map<Integer, List<Integer>> map, int[] visited, int node, int depth, Set<String> removedEdges) {\\n\\n\\tint count = 0;\\n\\tvisited[node] = depth;\\n\\n\\tfor (int next : map.getOrDefault(node, new ArrayList<>())) {\\n\\n\\t\\tif (visited[next] == 0) {  // keep going\\n\\t\\t\\tcount += dfs(map, visited, next, depth + 1, removedEdges);\\n\\t\\t} else if (visited[next] == depth - 1) {  // we ain\\'t go back\\n\\t\\t\\tcontinue;\\n\\t\\t} else if (!removedEdges.contains(node + \"-\" + next)) {  // find cycle edge and not been removed\\n\\t\\t\\tremovedEdges.add(node + \"-\" + next); removedEdges.add(next + \"-\" + node);\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n\\n// count edges without exclusiveType\\nprivate int countEdges(int exclusiveType, Set<String> removedEdges, Set<Integer> nodes, int[][] edges) {\\n\\tint edgeCount = 0;\\n\\tfor (int[] edge : edges) {\\n\\t\\tif (edge[0] == exclusiveType) continue;\\n\\t\\tint a = edge[1], b = edge[2];\\n\\t\\tnodes.add(a); nodes.add(b);\\n\\t\\tif (edge[0] == 3 && removedEdges.contains(a + \"-\" + b)) continue;\\n\\t\\tedgeCount++;\\n\\t}\\n\\treturn edgeCount;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int maxNumEdgesToRemove(int n, int[][] edges) {\\n        \\n\\tint res = 0;\\n\\n\\t// build type 3 only graph, and remove unnecessary edges which can form cycles\\n\\tSet<String> removedEdges = new HashSet<>();\\n\\tres += helper(edges, n, removedEdges);\\n\\n\\t// count type 1 + 3 only edges for Alice: make sure: cover all nodes + edgesNum >= n - 1\\n\\tSet<Integer> nodes = new HashSet<>();\\n\\tint edgeCount = countEdges(2, removedEdges, nodes, edges);\\n\\tif (edgeCount < n - 1 || nodes.size() < n) return -1;\\n\\tres += (edgeCount - (n - 1));\\n\\n\\t// count type 2 + 3 only edges for Bob: make sure: cover all nodes + edgesNum >= n - 1\\n\\tnodes = new HashSet<>();\\n\\tedgeCount = countEdges(1, removedEdges, nodes, edges);\\n\\tif (edgeCount < n - 1 || nodes.size() < n) return -1;\\n\\tres += (edgeCount - (n - 1));\\n\\n\\treturn res;\\n}\\n\\n// helper to build type 3 only graph, store in removedEdges set, return num of edges removed\\nprivate int helper(int[][] edges, int n, Set<String> removedEdges) {\\n\\n\\tint numEdgesRemoved = 0;\\n\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\n\\tfor (int[] edge : edges) {\\n\\t\\tif (edge[0] != 3) continue;\\n\\t\\tint a = edge[1], b = edge[2];\\n\\t\\tmap.computeIfAbsent(a, f -> new ArrayList<>()).add(b);\\n\\t\\tmap.computeIfAbsent(b, f -> new ArrayList<>()).add(a);\\n\\t}\\n\\n\\n\\tint[] visited = new int[n + 1];  // 0: not visited, > 0: depth\\n\\n\\tfor (int i = 1; i <= n; ++i) {\\n\\t\\tif (visited[i] != 0) continue;\\n\\t\\tnumEdgesRemoved += dfs(map, visited, i, 1, removedEdges);\\n\\t}\\n\\n\\treturn numEdgesRemoved;\\n}\\n\\n// dfs for removing circle edges recursively\\nprivate int dfs(Map<Integer, List<Integer>> map, int[] visited, int node, int depth, Set<String> removedEdges) {\\n\\n\\tint count = 0;\\n\\tvisited[node] = depth;\\n\\n\\tfor (int next : map.getOrDefault(node, new ArrayList<>())) {\\n\\n\\t\\tif (visited[next] == 0) {  // keep going\\n\\t\\t\\tcount += dfs(map, visited, next, depth + 1, removedEdges);\\n\\t\\t} else if (visited[next] == depth - 1) {  // we ain\\'t go back\\n\\t\\t\\tcontinue;\\n\\t\\t} else if (!removedEdges.contains(node + \"-\" + next)) {  // find cycle edge and not been removed\\n\\t\\t\\tremovedEdges.add(node + \"-\" + next); removedEdges.add(next + \"-\" + node);\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n\\n// count edges without exclusiveType\\nprivate int countEdges(int exclusiveType, Set<String> removedEdges, Set<Integer> nodes, int[][] edges) {\\n\\tint edgeCount = 0;\\n\\tfor (int[] edge : edges) {\\n\\t\\tif (edge[0] == exclusiveType) continue;\\n\\t\\tint a = edge[1], b = edge[2];\\n\\t\\tnodes.add(a); nodes.add(b);\\n\\t\\tif (edge[0] == 3 && removedEdges.contains(a + \"-\" + b)) continue;\\n\\t\\tedgeCount++;\\n\\t}\\n\\treturn edgeCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468048,
                "title": "easy-solution-of-java-c-with-comments-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxNumEdgesToRemove(int n, int[][] edges) {\\n    if (edges.length < n - 1) return -1; // if edges are less than n - 1, then it\\'s not a valid tree, not all nodes are accessible\\n\\n    int[] parentAlice = new int[n + 1];\\n    for (int i = 0; i < parentAlice.length; i++) {\\n      parentAlice[i] = i;\\n    }\\n\\n    // First process the type 3 nodes, this will help us to reduce number of edges required\\n    int numType3Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 3) {\\n        if (union(parentAlice, edge[1], edge[2])) {\\n          numType3Edges++;\\n        }\\n      }\\n    }\\n\\n    int[] parentBob = parentAlice.clone(); // as type 3 are for both alice and bob, clone it for bob as well\\n\\n    // Process Alice\\n    int numType1Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 1) {\\n        if (union(parentAlice, edge[1], edge[2])) {\\n          numType1Edges++;\\n        }\\n      }\\n    }\\n    if (numType1Edges + numType3Edges + 1 != n) return -1; // if edges are less than n - 1, then type 1 is not a valid tree, not all nodes are accessible\\n\\n    // Process Bob\\n    int numType2Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 2) {\\n        if (union(parentBob, edge[1], edge[2])) {\\n          numType2Edges++;\\n        }\\n      }\\n    }\\n    if (numType2Edges + numType3Edges + 1 != n) return -1; // if edges are less than n - 1, then type 1 is not a valid tree, not all nodes are accessible\\n    // return total edges - (number of type 3 + type 2 + type 1 edges required)\\n    return edges.length - numType1Edges - numType2Edges - numType3Edges;\\n  }\\n\\n  int find(int[] parent, int node) {\\n    if (parent[node] != node) {\\n      parent[node] = find(parent, parent[node]);\\n    }\\n    return parent[node];\\n  }\\n\\n  boolean union(int[] parent, int left, int right) {\\n    int leftParent = find(parent, left);\\n    int rightParent = find(parent, right);\\n    if (leftParent == rightParent) return false;\\n    parent[rightParent] = leftParent;\\n    return true;\\n  }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int> &parent, vector<int> &rank)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x] = find(parent[x], parent, rank);\\n    }\\n    \\n    bool merge(int x, int y, vector<int> &parent, vector<int> &rank)\\n    {\\n        x = find(x, parent, rank); y = find(y, parent, rank);\\n        if(x!=y)\\n        {\\n            parent[x] = y;\\n            if(rank[x]<rank[y]) swap(x,y);\\n            rank[x] += rank[y];\\n            return true;\\n        }\\n        return false;\\n    }\\n    static bool comp(vector<int> &a, vector<int> &b){\\n        return a[0]>b[0];\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), comp);\\n        vector<int> parentA(n+1,-1), rankA(n+1,1), parentB(n+1,-1), rankB(n+1,1);\\n        for(int i=1; i<n+1; i++)\\n        {\\n            parentA[i] = i;\\n            parentB[i] = i;\\n        }\\n        \\n        int mergedA = 1, mergedB = 1;\\n        int removed = 0;\\n        \\n        for(auto edge:edges)\\n        {\\n            int type = edge[0], u = edge[1], v = edge[2];\\n            if(type == 3){\\n                bool tempa = merge(u,v,parentA,rankA);\\n                bool tempb = merge(u,v, parentB, rankB);\\n                if(tempa) mergedA++;\\n                if(tempb) mergedB++;\\n                if(!tempa and !tempb) removed++;\\n            }\\n            else if(type==1){\\n                bool tempa = merge(u,v,parentA,rankA);                \\n                if(tempa) mergedA++;\\n                else removed++;\\n            }\\n            else{\\n                bool tempb = merge(u,v, parentB, rankB);                \\n                if(tempb) mergedB++;\\n                else removed++;\\n            }\\n        }\\n        \\n        if(mergedA != n || mergedB != n) return -1;\\n        return removed;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxNumEdgesToRemove(int n, int[][] edges) {\\n    if (edges.length < n - 1) return -1; // if edges are less than n - 1, then it\\'s not a valid tree, not all nodes are accessible\\n\\n    int[] parentAlice = new int[n + 1];\\n    for (int i = 0; i < parentAlice.length; i++) {\\n      parentAlice[i] = i;\\n    }\\n\\n    // First process the type 3 nodes, this will help us to reduce number of edges required\\n    int numType3Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 3) {\\n        if (union(parentAlice, edge[1], edge[2])) {\\n          numType3Edges++;\\n        }\\n      }\\n    }\\n\\n    int[] parentBob = parentAlice.clone(); // as type 3 are for both alice and bob, clone it for bob as well\\n\\n    // Process Alice\\n    int numType1Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 1) {\\n        if (union(parentAlice, edge[1], edge[2])) {\\n          numType1Edges++;\\n        }\\n      }\\n    }\\n    if (numType1Edges + numType3Edges + 1 != n) return -1; // if edges are less than n - 1, then type 1 is not a valid tree, not all nodes are accessible\\n\\n    // Process Bob\\n    int numType2Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 2) {\\n        if (union(parentBob, edge[1], edge[2])) {\\n          numType2Edges++;\\n        }\\n      }\\n    }\\n    if (numType2Edges + numType3Edges + 1 != n) return -1; // if edges are less than n - 1, then type 1 is not a valid tree, not all nodes are accessible\\n    // return total edges - (number of type 3 + type 2 + type 1 edges required)\\n    return edges.length - numType1Edges - numType2Edges - numType3Edges;\\n  }\\n\\n  int find(int[] parent, int node) {\\n    if (parent[node] != node) {\\n      parent[node] = find(parent, parent[node]);\\n    }\\n    return parent[node];\\n  }\\n\\n  boolean union(int[] parent, int left, int right) {\\n    int leftParent = find(parent, left);\\n    int rightParent = find(parent, right);\\n    if (leftParent == rightParent) return false;\\n    parent[rightParent] = leftParent;\\n    return true;\\n  }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int> &parent, vector<int> &rank)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x] = find(parent[x], parent, rank);\\n    }\\n    \\n    bool merge(int x, int y, vector<int> &parent, vector<int> &rank)\\n    {\\n        x = find(x, parent, rank); y = find(y, parent, rank);\\n        if(x!=y)\\n        {\\n            parent[x] = y;\\n            if(rank[x]<rank[y]) swap(x,y);\\n            rank[x] += rank[y];\\n            return true;\\n        }\\n        return false;\\n    }\\n    static bool comp(vector<int> &a, vector<int> &b){\\n        return a[0]>b[0];\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), comp);\\n        vector<int> parentA(n+1,-1), rankA(n+1,1), parentB(n+1,-1), rankB(n+1,1);\\n        for(int i=1; i<n+1; i++)\\n        {\\n            parentA[i] = i;\\n            parentB[i] = i;\\n        }\\n        \\n        int mergedA = 1, mergedB = 1;\\n        int removed = 0;\\n        \\n        for(auto edge:edges)\\n        {\\n            int type = edge[0], u = edge[1], v = edge[2];\\n            if(type == 3){\\n                bool tempa = merge(u,v,parentA,rankA);\\n                bool tempb = merge(u,v, parentB, rankB);\\n                if(tempa) mergedA++;\\n                if(tempb) mergedB++;\\n                if(!tempa and !tempb) removed++;\\n            }\\n            else if(type==1){\\n                bool tempa = merge(u,v,parentA,rankA);                \\n                if(tempa) mergedA++;\\n                else removed++;\\n            }\\n            else{\\n                bool tempb = merge(u,v, parentB, rankB);                \\n                if(tempb) mergedB++;\\n                else removed++;\\n            }\\n        }\\n        \\n        if(mergedA != n || mergedB != n) return -1;\\n        return removed;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086603,
                "title": "somewhat-kruskal-s-algo-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // The idea is to connect type 3 vertices first, without forming any cycle. Then again do the same for type 1, and type 2. \\n\\t\\n    vector<int> par;\\n    \\n    int find(int x){\\n        if(par[x]==x)\\n            return x;\\n        return par[x]=find(par[x]);\\n    }\\n    \\n    void merge(int x, int y){\\n        int a=find(x);\\n        int b=find(y);\\n        par[a]=b;\\n    }\\n    \\n    int isValid(int type, vector<vector<int>>& edges){\\n        int c=0;\\n        int m=edges.size();\\n        for(int i=0;i<m;i++){\\n            if(edges[i][0]==type && find(edges[i][1])!=find(edges[i][2])){\\n                c++;\\n                merge(edges[i][1], edges[i][2]);\\n            }\\n        }\\n        return c;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int m=edges.size();\\n        for(int i=0;i<=n;i++){\\n            par.push_back(i);\\n        }\\n        int t3=isValid(3, edges);\\n        vector<int> p=par;\\n        int t1=isValid(1, edges);\\n        par=p;\\n        int t2=isValid(2, edges);\\n        if(t1+t3!=n-1 || t2+t3!=n-1)\\n            return -1;\\n        return m-t1-t2-t3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // The idea is to connect type 3 vertices first, without forming any cycle. Then again do the same for type 1, and type 2. \\n\\t\\n    vector<int> par;\\n    \\n    int find(int x){\\n        if(par[x]==x)\\n            return x;\\n        return par[x]=find(par[x]);\\n    }\\n    \\n    void merge(int x, int y){\\n        int a=find(x);\\n        int b=find(y);\\n        par[a]=b;\\n    }\\n    \\n    int isValid(int type, vector<vector<int>>& edges){\\n        int c=0;\\n        int m=edges.size();\\n        for(int i=0;i<m;i++){\\n            if(edges[i][0]==type && find(edges[i][1])!=find(edges[i][2])){\\n                c++;\\n                merge(edges[i][1], edges[i][2]);\\n            }\\n        }\\n        return c;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int m=edges.size();\\n        for(int i=0;i<=n;i++){\\n            par.push_back(i);\\n        }\\n        int t3=isValid(3, edges);\\n        vector<int> p=par;\\n        int t1=isValid(1, edges);\\n        par=p;\\n        int t2=isValid(2, edges);\\n        if(t1+t3!=n-1 || t2+t3!=n-1)\\n            return -1;\\n        return m-t1-t2-t3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470433,
                "title": "python3-union-find-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n\\n    def __init__(self, n: int):\\n        self.root = [i for i in range(n)]\\n        self.rank = [1 for _ in range(n)]\\n        self.group = n\\n\\n    def find(self, x: int) -> int:\\n        if self.root[x] != x: self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x == root_y: return\\n        if self.rank[root_x] > self.rank[root_y]: self.root[root_y] = root_x\\n        elif self.rank[root_x] < self.rank[root_y]: self.root[root_x] = root_y\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n        self.group -= 1\\n\\n    def are_connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        uf_a, uf_b = UnionFind(n), UnionFind(n)\\n        res = 0\\n        edges.sort(reverse=True)\\n        for t, u, v in edges:\\n            if t == 3:\\n                if uf_a.are_connected(u - 1, v - 1) or uf_b.are_connected(u - 1,  v - 1): res += 1\\n                else:\\n                    uf_a.union(u - 1, v - 1)\\n                    uf_b.union(u - 1, v - 1)\\n            if t == 2:\\n                if uf_b.are_connected(u - 1, v - 1): res += 1\\n                else: uf_b.union(u - 1, v - 1)\\n            if t == 1:\\n                if uf_a.are_connected(u - 1, v - 1): res += 1\\n                else: uf_a.union(u - 1, v - 1)\\n            \\n        return res if uf_a.group == uf_b.group == 1 else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind:\\n\\n    def __init__(self, n: int):\\n        self.root = [i for i in range(n)]\\n        self.rank = [1 for _ in range(n)]\\n        self.group = n\\n\\n    def find(self, x: int) -> int:\\n        if self.root[x] != x: self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x == root_y: return\\n        if self.rank[root_x] > self.rank[root_y]: self.root[root_y] = root_x\\n        elif self.rank[root_x] < self.rank[root_y]: self.root[root_x] = root_y\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n        self.group -= 1\\n\\n    def are_connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        uf_a, uf_b = UnionFind(n), UnionFind(n)\\n        res = 0\\n        edges.sort(reverse=True)\\n        for t, u, v in edges:\\n            if t == 3:\\n                if uf_a.are_connected(u - 1, v - 1) or uf_b.are_connected(u - 1,  v - 1): res += 1\\n                else:\\n                    uf_a.union(u - 1, v - 1)\\n                    uf_b.union(u - 1, v - 1)\\n            if t == 2:\\n                if uf_b.are_connected(u - 1, v - 1): res += 1\\n                else: uf_b.union(u - 1, v - 1)\\n            if t == 1:\\n                if uf_a.are_connected(u - 1, v - 1): res += 1\\n                else: uf_a.union(u - 1, v - 1)\\n            \\n        return res if uf_a.group == uf_b.group == 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468042,
                "title": "clean-code-easy-to-understand-union-find",
                "content": "### A BIT OF REDUNDANT CODE \\uD83D\\uDE05, JUST FOR SIMPLICITY\\n### ALSO INCLUDED A \\'NOT REDUNDANT\\' CODE LATER \\uD83D\\uDC47\\uD83D\\uDC47\\n```\\nclass Solution {\\npublic:\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        if (parent[node] == node) return node;\\n        else return findParent(parent, parent[node]);\\n    }\\n    bool merge(vector<int>&parent, vector<int>&rank, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n        if (parent1 == parent2) return false;\\n        else\\n        {\\n            //NON-OPTIMAL WAY => { parent[parent1] = parent2 or parent[parent2] = parent2; return; :)} \\n            //OPTIMAL WAY=> merge based on rank to reduce complexity in \\'FINDING PARENT\\' next time\\n            if (rank[parent1] == rank[parent2])  //both at same level\\n            {\\n                parent[parent1] = parent2; \\n                rank[parent2]++; \\n            }\\n            else if (rank[parent1] < rank[parent2]) //parent2 is at higher level\\n                parent[parent1] = parent2; \\n            else  //parent1 is at higher level\\n                parent[parent2] = parent1;\\n            return true;\\n        }\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) \\n    {\\n        int notUsed = 0, componentCount = n;\\n        vector<int>parent(n + 1);\\n        vector<int>rank(n + 1, 0);\\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n        //===========================================================================\\n        //COMMON FOR BOTH\\n        for (vector<int>&edge : edges)\\n        {\\n            if (edge[0] != 3) continue;\\n            \\n            bool merged = merge(parent, rank, edge[1], edge[2]);\\n            if (!merged) notUsed++;\\n            else componentCount--;\\n        }\\n        //===========================================================================\\n        //ONLY FOR ALICE\\n        vector<int>aliceParent = parent, aliceRank = rank;\\n        int aliceComponentCount = componentCount;\\n        for (vector<int>&edge : edges)\\n        {\\n            if (edge[0] != 1) continue;\\n            bool merged = merge(aliceParent, aliceRank, edge[1], edge[2]);\\n            if (!merged) notUsed++;\\n            else aliceComponentCount--;\\n        }\\n        if (aliceComponentCount != 1) return -1;  //still not connected, so return -1\\n        //==============================================================================\\n        //ONLY FOR BOB\\n        //could have used tha main \\'parent\\', \\'rank\\', \\'componentCount\\'...\\n        //made duplicate copies here also only to explain \\n        vector<int>bobParent = parent, bobRank = rank; \\n        int bobComponentCount = componentCount;\\n        for (vector<int>&edge : edges)\\n        {\\n            if (edge[0] != 2) continue;\\n            bool merged = merge(bobParent, bobRank, edge[1], edge[2]);\\n            if (!merged) notUsed++;\\n            else bobComponentCount--;\\n        }\\n        if (bobComponentCount != 1) return -1;  //still not connected, so return -1\\n        //================================================================================\\n        return notUsed;//not used edges will be removed\\n        \\n    }\\n};\\n```\\n//=======================================================================================================================\\n## REDUCED DUPLICACY\\n```\\nclass Solution {\\npublic:\\n    int notUsed = 0;\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        if (parent[node] == node) return node;\\n        else return findParent(parent, parent[node]);\\n    }\\n    bool merge(vector<int>&parent, vector<int>&rank, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n        if (parent1 == parent2) return false;\\n        else\\n        {\\n            if (rank[parent1] == rank[parent2])  //both at same level\\n            {\\n                parent[parent1] = parent2; \\n                rank[parent2]++; \\n            }\\n            else if (rank[parent1] < rank[parent2]) //parent2 is at higher level\\n                parent[parent1] = parent2; \\n            else  //parent1 is at higher level\\n                parent[parent2] = parent1;\\n            return true;\\n        }\\n    }\\n    void solve(vector<vector<int>>&edges, vector<int>&parent, vector<int>&rank, int& componentCount, int currType)\\n    {\\n        for (vector<int>&edge : edges)\\n        {\\n            if (edge[0] != currType) continue;\\n            \\n            bool merged = merge(parent, rank, edge[1], edge[2]);\\n            if (!merged) notUsed++; //declared global\\n            else componentCount--;\\n        }\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) \\n    {\\n        //==============================================================================\\n        //COMMON FOR BOTH\\n        int componentCount = n;\\n        vector<int>parent(n + 1);\\n        vector<int>rank(n + 1, 0);\\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n        solve(edges, parent, rank, componentCount, 3);\\n        //===============================================================================\\n        //ONLY FOR ALICE\\n        vector<int>aliceParent = parent, aliceRank = rank;\\n        int aliceComponentCount = componentCount;\\n        solve(edges, aliceParent, aliceRank, aliceComponentCount, 1);\\n        if (aliceComponentCount != 1) return -1;  \\n        //==============================================================================\\n        //ONLY FOR BOB\\n        vector<int>bobParent = parent, bobRank = rank; \\n        int bobComponentCount = componentCount;\\n        solve(edges, bobParent, bobRank, bobComponentCount, 2);\\n        if (bobComponentCount != 1) return -1;  \\n        //================================================================================\\n        return notUsed;//not used edges will be removed\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        if (parent[node] == node) return node;\\n        else return findParent(parent, parent[node]);\\n    }\\n    bool merge(vector<int>&parent, vector<int>&rank, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n        if (parent1 == parent2) return false;\\n        else\\n        {\\n            //NON-OPTIMAL WAY => { parent[parent1] = parent2 or parent[parent2] = parent2; return; :)} \\n            //OPTIMAL WAY=> merge based on rank to reduce complexity in \\'FINDING PARENT\\' next time\\n            if (rank[parent1] == rank[parent2])  //both at same level\\n            {\\n                parent[parent1] = parent2; \\n                rank[parent2]++; \\n            }\\n            else if (rank[parent1] < rank[parent2]) //parent2 is at higher level\\n                parent[parent1] = parent2; \\n            else  //parent1 is at higher level\\n                parent[parent2] = parent1;\\n            return true;\\n        }\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) \\n    {\\n        int notUsed = 0, componentCount = n;\\n        vector<int>parent(n + 1);\\n        vector<int>rank(n + 1, 0);\\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n        //===========================================================================\\n        //COMMON FOR BOTH\\n        for (vector<int>&edge : edges)\\n        {\\n            if (edge[0] != 3) continue;\\n            \\n            bool merged = merge(parent, rank, edge[1], edge[2]);\\n            if (!merged) notUsed++;\\n            else componentCount--;\\n        }\\n        //===========================================================================\\n        //ONLY FOR ALICE\\n        vector<int>aliceParent = parent, aliceRank = rank;\\n        int aliceComponentCount = componentCount;\\n        for (vector<int>&edge : edges)\\n        {\\n            if (edge[0] != 1) continue;\\n            bool merged = merge(aliceParent, aliceRank, edge[1], edge[2]);\\n            if (!merged) notUsed++;\\n            else aliceComponentCount--;\\n        }\\n        if (aliceComponentCount != 1) return -1;  //still not connected, so return -1\\n        //==============================================================================\\n        //ONLY FOR BOB\\n        //could have used tha main \\'parent\\', \\'rank\\', \\'componentCount\\'...\\n        //made duplicate copies here also only to explain \\n        vector<int>bobParent = parent, bobRank = rank; \\n        int bobComponentCount = componentCount;\\n        for (vector<int>&edge : edges)\\n        {\\n            if (edge[0] != 2) continue;\\n            bool merged = merge(bobParent, bobRank, edge[1], edge[2]);\\n            if (!merged) notUsed++;\\n            else bobComponentCount--;\\n        }\\n        if (bobComponentCount != 1) return -1;  //still not connected, so return -1\\n        //================================================================================\\n        return notUsed;//not used edges will be removed\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int notUsed = 0;\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        if (parent[node] == node) return node;\\n        else return findParent(parent, parent[node]);\\n    }\\n    bool merge(vector<int>&parent, vector<int>&rank, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n        if (parent1 == parent2) return false;\\n        else\\n        {\\n            if (rank[parent1] == rank[parent2])  //both at same level\\n            {\\n                parent[parent1] = parent2; \\n                rank[parent2]++; \\n            }\\n            else if (rank[parent1] < rank[parent2]) //parent2 is at higher level\\n                parent[parent1] = parent2; \\n            else  //parent1 is at higher level\\n                parent[parent2] = parent1;\\n            return true;\\n        }\\n    }\\n    void solve(vector<vector<int>>&edges, vector<int>&parent, vector<int>&rank, int& componentCount, int currType)\\n    {\\n        for (vector<int>&edge : edges)\\n        {\\n            if (edge[0] != currType) continue;\\n            \\n            bool merged = merge(parent, rank, edge[1], edge[2]);\\n            if (!merged) notUsed++; //declared global\\n            else componentCount--;\\n        }\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) \\n    {\\n        //==============================================================================\\n        //COMMON FOR BOTH\\n        int componentCount = n;\\n        vector<int>parent(n + 1);\\n        vector<int>rank(n + 1, 0);\\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n        solve(edges, parent, rank, componentCount, 3);\\n        //===============================================================================\\n        //ONLY FOR ALICE\\n        vector<int>aliceParent = parent, aliceRank = rank;\\n        int aliceComponentCount = componentCount;\\n        solve(edges, aliceParent, aliceRank, aliceComponentCount, 1);\\n        if (aliceComponentCount != 1) return -1;  \\n        //==============================================================================\\n        //ONLY FOR BOB\\n        vector<int>bobParent = parent, bobRank = rank; \\n        int bobComponentCount = componentCount;\\n        solve(edges, bobParent, bobRank, bobComponentCount, 2);\\n        if (bobComponentCount != 1) return -1;  \\n        //================================================================================\\n        return notUsed;//not used edges will be removed\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831949,
                "title": "java-simple-union-find",
                "content": "Just use union-find to check if that is critical connect;\\n1, if by find the root partent for the 2 nodes that one edge connected, it is not critical nonnect, could be removed, res++;\\nelse union it, islands--;\\n2, union and count for type 3 first.\\n\\n\\n```\\nclass Solution {\\n    int res = 0, na, nb, psa[], psb[], es[][];  // na, islands of alice, nb, islands of bob, etc...\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        na = nb = n; psa = new int[n + 1]; psb = new int[n + 1]; es = edges;\\n        for (int i = 1; i <= n; i++) {\\n            psa[i] = i;   // init, single islands for each node;\\n            psb[i] = i;\\n        }\\n        count(3);  // union and count for type 3 first.\\n        count(2);\\n        count(1);\\n        if (na != 1 || nb != 1) return -1; // either Alice or bob could not traverse\\n        return res;\\n    }\\n    \\n    private void count(int type) {\\n        for (int[] e : es) \\n            if (e[0] == type) {\\n                if (type == 3 && !union(1, e) && !union(2, e)) res++;\\n                else if (!union(type, e)) res++;\\n            }\\n    }\\n    \\n    private boolean union(int type, int[] e) {\\n        int ps[] = type == 1 ? psa : psb, up = find(e[1], ps), vp = find(e[2], ps);\\n        if (up == vp) return false;  // don\\'t need to union, non-critical edges, possible remove;\\n        ps[up] = vp;\\n        if (type == 1) na--;\\n        else nb--;\\n        return true;\\n    }\\n    \\n    private int find(int node, int[] ps) {\\n        int p = ps[node];\\n        if (node != p)  ps[node] = find(ps[node], ps);\\n        return ps[node];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0, na, nb, psa[], psb[], es[][];  // na, islands of alice, nb, islands of bob, etc...\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        na = nb = n; psa = new int[n + 1]; psb = new int[n + 1]; es = edges;\\n        for (int i = 1; i <= n; i++) {\\n            psa[i] = i;   // init, single islands for each node;\\n            psb[i] = i;\\n        }\\n        count(3);  // union and count for type 3 first.\\n        count(2);\\n        count(1);\\n        if (na != 1 || nb != 1) return -1; // either Alice or bob could not traverse\\n        return res;\\n    }\\n    \\n    private void count(int type) {\\n        for (int[] e : es) \\n            if (e[0] == type) {\\n                if (type == 3 && !union(1, e) && !union(2, e)) res++;\\n                else if (!union(type, e)) res++;\\n            }\\n    }\\n    \\n    private boolean union(int type, int[] e) {\\n        int ps[] = type == 1 ? psa : psb, up = find(e[1], ps), vp = find(e[2], ps);\\n        if (up == vp) return false;  // don\\'t need to union, non-critical edges, possible remove;\\n        ps[up] = vp;\\n        if (type == 1) na--;\\n        else nb--;\\n        return true;\\n    }\\n    \\n    private int find(int node, int[] ps) {\\n        int p = ps[node];\\n        if (node != p)  ps[node] = find(ps[node], ps);\\n        return ps[node];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470044,
                "title": "union-find-solution-optimal",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Firstly, make two disjointSet one for alice and one for bob.\\n2. We will keep 3 counter, for - alice, bob and both\\n3. Now, first check for all the type 3 edges which is common for both alice and bob.\\n4. If parents of nodes for Both alice and bob are already same so we will consider to remove it (both++).\\n5. Else we will make there parents same.\\n6. Now, similar step we will follow again for type 1 and type 2 edges.\\n7. As we know, type 1 is for alice and type 2 is for bob\\n8. so, if type 1 edge is there and the parent of nodes are already same so we can consider it to remove (alice++).else we will make there parent to be same.\\n9. if type 2 edge is there and the parent of nodes are already same so we can consider it to remove (bob++).else we will make there parent to be same.\\n10. Finally, before returning your you should check whether all nodes are connected or not (by checking if there parent is same or not) for both alice and bob.\\n11. if all the nodes are connected for both of them. then, return ans as alice+bob+both. else return -1\\n\\n\\n# Complexity\\n- Time complexity: O(m \\u03B1(n)), where m=no. of edges & n=no. of nodes\\n \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass disjointSet{\\n    vector<int>parent,size;\\n    public:\\n        disjointSet(int n){\\n            parent.resize(n+1);\\n            size.resize(n+1,1);\\n            for(int i=0; i<=n; i++){\\n                parent[i]=i;\\n            }\\n        }\\n        int findParent(int node){\\n            if(node==parent[node]){\\n                return node;\\n            }\\n            return parent[node]=findParent(parent[node]);\\n        }\\n        void unionBySize(int u,int v){\\n            int parentOfU=findParent(u);\\n            int parentOfV=findParent(v);\\n            if(parentOfU==parentOfV) return;\\n            if(size[parentOfU] < size[parentOfV]){\\n                parent[parentOfU]=parentOfV;\\n                size[parentOfV]+=size[parentOfU];\\n            }\\n            else{\\n                parent[parentOfV]=parentOfU;\\n                size[parentOfU]+=size[parentOfV];\\n            }\\n        }\\n        bool check(int first,int second){\\n            if(findParent(first)==findParent(second)) \\n                return true;\\n            return false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        disjointSet ds1(n);\\n        disjointSet ds2(n);\\n        int alice=0,bob=0,both=0;\\n        for(auto it:edges){\\n            int type=it[0];\\n            int node1=it[1];\\n            int node2=it[2];\\n            if(type==1 || type==2)continue;\\n            if(ds1.check(node1,node2) && ds2.check(node1,node2)){\\n                both++;\\n            }\\n            else{\\n                ds1.unionBySize(node1,node2);\\n                ds2.unionBySize(node1,node2);\\n            }\\n        }\\n        for(auto it:edges){\\n            int type=it[0];\\n            int node1=it[1];\\n            int node2=it[2];\\n            if(type==1){\\n                if(ds1.check(node1,node2))alice++;\\n                else ds1.unionBySize(node1,node2);\\n            }\\n            else if(type==2){\\n                if(ds2.check(node1,node2))bob++;\\n                else ds2.unionBySize(node1,node2);\\n            }\\n        }\\n        unordered_set<int>st1;\\n        unordered_set<int>st2;\\n        for(int i=1; i<=n; i++){\\n            st1.insert(ds1.findParent(i));\\n            if(st1.size()>1)break;\\n        }\\n        for(int i=1; i<=n; i++){\\n            st2.insert(ds2.findParent(i));\\n            if(st2.size()>1)break;\\n        }\\n\\n        if(st1.size()==1 && st2.size()==1)\\n        return alice+bob+both;\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass disjointSet{\\n    vector<int>parent,size;\\n    public:\\n        disjointSet(int n){\\n            parent.resize(n+1);\\n            size.resize(n+1,1);\\n            for(int i=0; i<=n; i++){\\n                parent[i]=i;\\n            }\\n        }\\n        int findParent(int node){\\n            if(node==parent[node]){\\n                return node;\\n            }\\n            return parent[node]=findParent(parent[node]);\\n        }\\n        void unionBySize(int u,int v){\\n            int parentOfU=findParent(u);\\n            int parentOfV=findParent(v);\\n            if(parentOfU==parentOfV) return;\\n            if(size[parentOfU] < size[parentOfV]){\\n                parent[parentOfU]=parentOfV;\\n                size[parentOfV]+=size[parentOfU];\\n            }\\n            else{\\n                parent[parentOfV]=parentOfU;\\n                size[parentOfU]+=size[parentOfV];\\n            }\\n        }\\n        bool check(int first,int second){\\n            if(findParent(first)==findParent(second)) \\n                return true;\\n            return false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        disjointSet ds1(n);\\n        disjointSet ds2(n);\\n        int alice=0,bob=0,both=0;\\n        for(auto it:edges){\\n            int type=it[0];\\n            int node1=it[1];\\n            int node2=it[2];\\n            if(type==1 || type==2)continue;\\n            if(ds1.check(node1,node2) && ds2.check(node1,node2)){\\n                both++;\\n            }\\n            else{\\n                ds1.unionBySize(node1,node2);\\n                ds2.unionBySize(node1,node2);\\n            }\\n        }\\n        for(auto it:edges){\\n            int type=it[0];\\n            int node1=it[1];\\n            int node2=it[2];\\n            if(type==1){\\n                if(ds1.check(node1,node2))alice++;\\n                else ds1.unionBySize(node1,node2);\\n            }\\n            else if(type==2){\\n                if(ds2.check(node1,node2))bob++;\\n                else ds2.unionBySize(node1,node2);\\n            }\\n        }\\n        unordered_set<int>st1;\\n        unordered_set<int>st2;\\n        for(int i=1; i<=n; i++){\\n            st1.insert(ds1.findParent(i));\\n            if(st1.size()>1)break;\\n        }\\n        for(int i=1; i<=n; i++){\\n            st2.insert(ds2.findParent(i));\\n            if(st2.size()>1)break;\\n        }\\n\\n        if(st1.size()==1 && st2.size()==1)\\n        return alice+bob+both;\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468239,
                "title": "javascript-with-explanation-clean-solution-union-find",
                "content": "# Code\\n```\\nvar maxNumEdgesToRemove = function(n, edges) {\\n    const alice = new UnionFind(n), bob = new UnionFind(n);\\n\\n    // Count number of times parent changed\\n    let count = 0;\\n\\n    // Check all type 3 edges\\n    for(let [type, u, v] of edges){\\n        if (type === 3 && alice.union(u, v) && bob.union(u, v)) count++;\\n    }\\n\\n    // Check all type 1 & 2 edges\\n    for(let [type, u, v] of edges){\\n        if (type === 1 && alice.union(u, v)) count++\\n        if (type === 2 && bob.union(u, v)) count++;\\n    }\\n\\n    // If groups = 1 then all nodes are connected\\n    if(alice.groups === 1 && bob.groups === 1) return edges.length - count;\\n    else return -1;\\n};\\n\\n\\n\\n//////////////// Union Find Data Structure \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass UnionFind{\\n    constructor(n){\\n        this.parent = new Array(n).fill().map((_,i) => i);\\n        this.groups = n;\\n    }\\n\\n    find(i){\\n        if(this.parent[i] !== i) this.parent[i] = this.find(this.parent[i])\\n        return this.parent[i];\\n    }\\n\\n    // Return true if parent is changed\\n    union(i, j){\\n        const x = this.find(i), y = this.find(j);\\n        if(x === y) return false;\\n        else{\\n            this.parent[y] = x;\\n            this.groups--;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nvar maxNumEdgesToRemove = function(n, edges) {\\n    const alice = new UnionFind(n), bob = new UnionFind(n);\\n\\n    // Count number of times parent changed\\n    let count = 0;\\n\\n    // Check all type 3 edges\\n    for(let [type, u, v] of edges){\\n        if (type === 3 && alice.union(u, v) && bob.union(u, v)) count++;\\n    }\\n\\n    // Check all type 1 & 2 edges\\n    for(let [type, u, v] of edges){\\n        if (type === 1 && alice.union(u, v)) count++\\n        if (type === 2 && bob.union(u, v)) count++;\\n    }\\n\\n    // If groups = 1 then all nodes are connected\\n    if(alice.groups === 1 && bob.groups === 1) return edges.length - count;\\n    else return -1;\\n};\\n\\n\\n\\n//////////////// Union Find Data Structure \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass UnionFind{\\n    constructor(n){\\n        this.parent = new Array(n).fill().map((_,i) => i);\\n        this.groups = n;\\n    }\\n\\n    find(i){\\n        if(this.parent[i] !== i) this.parent[i] = this.find(this.parent[i])\\n        return this.parent[i];\\n    }\\n\\n    // Return true if parent is changed\\n    union(i, j){\\n        const x = this.find(i), y = this.find(j);\\n        if(x === y) return false;\\n        else{\\n            this.parent[y] = x;\\n            this.groups--;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467976,
                "title": "daily-leetcoding-challenge-april-day-30",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** Disjoint Set Union (DSU)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2499577,
                "title": "c-dsu-application-beats-around-97-runtime",
                "content": "We give priority to third type of paths first. Essentially, we are connecting the nodes of different paths as seperate components and then adding/selecting edges to connect them. \\n```\\nclass Solution {\\npublic:\\n    vector<int> par, rank ; \\n    \\n    int find(int v){\\n        if(par[v] == v)\\n            return v ; \\n        return par[v] = find(par[v]) ; \\n    }\\n    \\n    void unionfn(int a, int b) {\\n        a = find(a) ; \\n        b = find(b) ; \\n        if(a!=b) {\\n            if(rank[a] < rank[b])\\n                swap(a, b) ; \\n            par[b] = a ; \\n            if(rank[b] == rank[a])\\n                rank[a]++ ; \\n        }\\n    }\\n    \\n    int calc(int type, vector<vector<int>>& e) {\\n        int ct = 0 ; \\n        for(int i = 0 ; i < e.size() ; i++) {\\n            if(e[i][0] == type and find(e[i][1]) != find(e[i][2])) {\\n                ct++ ; \\n                unionfn(e[i][1], e[i][2]) ; \\n            }\\n        }\\n        return ct ; \\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& e) {\\n        rank.assign(n+1, 0) ;  \\n        for(int i =0 ; i <= n ; i++)\\n            par.push_back(i) ; \\n        int common = calc(3, e) ; \\n        vector<int> temp = par ; \\n        int alice = calc(1, e) ; \\n        par = temp ; \\n        int bob = calc(2, e) ; \\n        if((common + alice != n-1) or (common + bob != n-1))\\n            return -1 ; \\n        return (e.size()-common-alice-bob) ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> par, rank ; \\n    \\n    int find(int v){\\n        if(par[v] == v)\\n            return v ; \\n        return par[v] = find(par[v]) ; \\n    }\\n    \\n    void unionfn(int a, int b) {\\n        a = find(a) ; \\n        b = find(b) ; \\n        if(a!=b) {\\n            if(rank[a] < rank[b])\\n                swap(a, b) ; \\n            par[b] = a ; \\n            if(rank[b] == rank[a])\\n                rank[a]++ ; \\n        }\\n    }\\n    \\n    int calc(int type, vector<vector<int>>& e) {\\n        int ct = 0 ; \\n        for(int i = 0 ; i < e.size() ; i++) {\\n            if(e[i][0] == type and find(e[i][1]) != find(e[i][2])) {\\n                ct++ ; \\n                unionfn(e[i][1], e[i][2]) ; \\n            }\\n        }\\n        return ct ; \\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& e) {\\n        rank.assign(n+1, 0) ;  \\n        for(int i =0 ; i <= n ; i++)\\n            par.push_back(i) ; \\n        int common = calc(3, e) ; \\n        vector<int> temp = par ; \\n        int alice = calc(1, e) ; \\n        par = temp ; \\n        int bob = calc(2, e) ; \\n        if((common + alice != n-1) or (common + bob != n-1))\\n            return -1 ; \\n        return (e.size()-common-alice-bob) ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831616,
                "title": "python-simple-union-find",
                "content": "Things we know:\\n1. We know how to solve a problem if edges only contains **type3** edges. The solusion will be: get a spanning tree, then all the other edges can be removed as the spanning tree already connected all nodes.\\n2. We know **type3** edge is important becasues: **type3** edge can connect both for **Alice** and **Bob** in best case. But **type1** and **type2** edge can only connect **Alice** or **Bob** in best case.\\n\\nThen our idea will be:\\n1. Use spanning tree algoritm to choose from **type3** edges first (**Union Find**): If two nodes are not from the same **union**, connect them\\n2.  Then use **type1** edges for **Alice**\\n3.  Use **type2** edges for Bob\\n4.  Finnaly if they are still not connected, return **-1**\\n\\n```\\nclass UnionFind(object):\\n    def __init__(self, size):\\n        self.res = [i for i in range(size)]\\n        self.group = size\\n        self.size = [1] * size\\n\\n    def find(self, child):\\n        if self.res[child] != child:\\n            idx = self.find(self.res[child])\\n            self.res[child] = idx\\n        return self.res[child]\\n\\n    def union(self, a, b):\\n        pa = self.find(a)\\n        pb = self.find(b)\\n        if pa == pb:\\n            return\\n        if self.size[pa] > self.size[pb]:\\n            pa, pb = pb, pa\\n        self.group -= 1\\n        self.res[pa] = pb\\n        self.size[pb] += self.size[pa]\\n        \\nclass Solution(object):\\n    def maxNumEdgesToRemove(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# used edges count\\n        res = 0\\n        ua = UnionFind(n + 1)\\n        ub = UnionFind(n + 1)\\n        es = [[] for _ in range(4)]\\n        \\n\\t\\t# group edges\\n        for edge in edges:\\n            es[edge[0]].append(edge)\\n            \\n\\t\\t# use type 3 first\\n        for edge in es[3]:\\n            x = ua.find(edge[1])\\n            y = ua.find(edge[2])\\n\\t\\t\\t\\n\\t\\t\\t# if not from same union, add the edge and connect them\\n            if x != y:\\n                res += 1\\n                ua.union(x, y)\\n                ub.union(x, y)\\n\\n        for edge in es[2]:\\n            x = ua.find(edge[1])\\n            y = ua.find(edge[2])\\n            if x != y:\\n                res += 1\\n                ua.union(x, y)\\n                \\n        for edge in es[1]:\\n            x = ub.find(edge[1])\\n            y = ub.find(edge[2])\\n            if x != y:\\n                res += 1\\n                ub.union(x, y)\\n\\t\\t# if still not connected, return -1\\n        x = ua.find(1)\\n        if any(x != ua.find(i) for i in range(1, n + 1)):\\n            return -1\\n            \\n\\t\\tx = ub.find(1)\\n        if any(x != ub.find(i) for i in range(1, n + 1)):\\n            return -1\\n\\n        return len(edges) - res\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind(object):\\n    def __init__(self, size):\\n        self.res = [i for i in range(size)]\\n        self.group = size\\n        self.size = [1] * size\\n\\n    def find(self, child):\\n        if self.res[child] != child:\\n            idx = self.find(self.res[child])\\n            self.res[child] = idx\\n        return self.res[child]\\n\\n    def union(self, a, b):\\n        pa = self.find(a)\\n        pb = self.find(b)\\n        if pa == pb:\\n            return\\n        if self.size[pa] > self.size[pb]:\\n            pa, pb = pb, pa\\n        self.group -= 1\\n        self.res[pa] = pb\\n        self.size[pb] += self.size[pa]\\n        \\nclass Solution(object):\\n    def maxNumEdgesToRemove(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# used edges count\\n        res = 0\\n        ua = UnionFind(n + 1)\\n        ub = UnionFind(n + 1)\\n        es = [[] for _ in range(4)]\\n        \\n\\t\\t# group edges\\n        for edge in edges:\\n            es[edge[0]].append(edge)\\n            \\n\\t\\t# use type 3 first\\n        for edge in es[3]:\\n            x = ua.find(edge[1])\\n            y = ua.find(edge[2])\\n\\t\\t\\t\\n\\t\\t\\t# if not from same union, add the edge and connect them\\n            if x != y:\\n                res += 1\\n                ua.union(x, y)\\n                ub.union(x, y)\\n\\n        for edge in es[2]:\\n            x = ua.find(edge[1])\\n            y = ua.find(edge[2])\\n            if x != y:\\n                res += 1\\n                ua.union(x, y)\\n                \\n        for edge in es[1]:\\n            x = ub.find(edge[1])\\n            y = ub.find(edge[2])\\n            if x != y:\\n                res += 1\\n                ub.union(x, y)\\n\\t\\t# if still not connected, return -1\\n        x = ua.find(1)\\n        if any(x != ua.find(i) for i in range(1, n + 1)):\\n            return -1\\n            \\n\\t\\tx = ub.find(1)\\n        if any(x != ub.find(i) for i in range(1, n + 1)):\\n            return -1\\n\\n        return len(edges) - res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044949,
                "title": "c-union-find-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int> &par,int u)\\n    {\\n        if(u==par[u])\\n            return u;\\n        return par[u]=find(par,par[u]);\\n    }\\n    void unions(vector<int> &par,int u,int v)\\n    {\\n        int pu=find(par,u);\\n        int pv=find(par,v);\\n        par[pu]=pv;\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges)\\n    {\\n        vector<int> a(n+1),b(n+1);\\n        int ans=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            a[i]=i;\\n            b[i]=i;\\n        }\\n        for(auto &e:edges)\\n        {\\n            if(e[0]!=3)\\n                continue;\\n            if(find(a,e[1])==find(a,e[2]))\\n            {\\n                ans++;\\n                continue;\\n            }\\n            unions(a,e[1],e[2]);\\n            unions(b,e[1],e[2]);\\n        }\\n        for(auto &e:edges)\\n        {\\n            int u=e[1],v=e[2];\\n            if(e[0]==1)\\n            {\\n                if(find(a,u)==find(a,v))\\n                {\\n                    ans++;\\n                }\\n                else\\n                {\\n                    unions(a,u,v);\\n                }\\n            }\\n            else if(e[0]==2)\\n            {\\n                if(find(b,u)==find(b,v))\\n                {\\n                    ans++;\\n                }\\n                else\\n                {\\n                    unions(b,u,v);\\n                }\\n            }\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(find(a,i)!=find(a,n)||find(b,i)!=find(b,n))\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    int find(vector<int> &par,int u)\\n    {\\n        if(u==par[u])\\n            return u;\\n        return par[u]=find(par,par[u]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 831861,
                "title": "c-union-find-o-n-concise-code",
                "content": "```\\npublic class Solution\\n{\\n    public int MaxNumEdgesToRemove(int n, int[][] edges)\\n    {\\n        int res = 0;\\n        UnionFind alice = new UnionFind(n);\\n        UnionFind bob = new UnionFind(n);\\n        foreach (var edge in edges)\\n        {\\n            if(edge[0] == 3 && (!alice.Union(edge[1], edge[2]) || !bob.Union(edge[1], edge[2])))\\n                res++;\\n        }\\n\\n        foreach (var edge in edges)\\n        {\\n            if (edge[0] == 1 && !alice.Union(edge[1], edge[2]))\\n                res++;\\n            if (edge[0] == 2 && !bob.Union(edge[1], edge[2]))\\n                res++;\\n        }\\n\\n        return alice.Componets == 1 && bob.Componets == 1 ? res : -1;\\n    }\\n}\\n\\npublic class UnionFind\\n{\\n    private int[] parent;\\n    public int Componets { get; private set; }\\n    public UnionFind(int n)\\n    {\\n        Componets = n;\\n        parent = new int[n + 1];\\n        for (int i = 0; i <= n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int Find(int x)\\n    {\\n        if (parent[x] != x)\\n            parent[x] = Find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public bool Union(int x, int y)\\n    {\\n        int px = Find(x);\\n        int py = Find(y);\\n        if (px != py)\\n        {\\n            parent[px] = py;\\n            Componets--;\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MaxNumEdgesToRemove(int n, int[][] edges)\\n    {\\n        int res = 0;\\n        UnionFind alice = new UnionFind(n);\\n        UnionFind bob = new UnionFind(n);\\n        foreach (var edge in edges)\\n        {\\n            if(edge[0] == 3 && (!alice.Union(edge[1], edge[2]) || !bob.Union(edge[1], edge[2])))\\n                res++;\\n        }\\n\\n        foreach (var edge in edges)\\n        {\\n            if (edge[0] == 1 && !alice.Union(edge[1], edge[2]))\\n                res++;\\n            if (edge[0] == 2 && !bob.Union(edge[1], edge[2]))\\n                res++;\\n        }\\n\\n        return alice.Componets == 1 && bob.Componets == 1 ? res : -1;\\n    }\\n}\\n\\npublic class UnionFind\\n{\\n    private int[] parent;\\n    public int Componets { get; private set; }\\n    public UnionFind(int n)\\n    {\\n        Componets = n;\\n        parent = new int[n + 1];\\n        for (int i = 0; i <= n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int Find(int x)\\n    {\\n        if (parent[x] != x)\\n            parent[x] = Find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public bool Union(int x, int y)\\n    {\\n        int px = Find(x);\\n        int py = Find(y);\\n        if (px != py)\\n        {\\n            parent[px] = py;\\n            Componets--;\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831495,
                "title": "python-union-find-two-pass",
                "content": "```\\nclass Solution(object):\\n    def maxNumEdgesToRemove(self, n, edges):\\n\\n        ufa = UnionFind(n) # Graph for Alice\\n        ufb = UnionFind(n) # Graph for Bob\\n        cnt = 0 # number of removable edges\\n        \\n        for x, y, z in edges:\\n            if x == 3:\\n                flag1 = ufa.union(y, z)\\n                flag2 = ufb.union(y, z)\\n                if not flag1 or not flag2: cnt +=1\\n\\n        for x, y, z in edges:\\n            if x == 1:\\n                flag = ufa.union(y, z)\\n                if not flag: cnt += 1\\n            if x == 2:\\n                flag = ufb.union(y, z)\\n                if not flag: cnt += 1\\n\\n        return cnt if ufa.groups == 1 and ufb.groups == 1 else -1\\n            \\n        \\nclass UnionFind():\\n    def __init__(self, n):\\n        self.parents = {i:i for i in range(1, n+1)}\\n        self.groups = n\\n\\n    def find(self, x):\\n        if self.parents[x] == x:\\n            return x\\n        else:\\n            self.parents[x] = self.find(self.parents[x])\\n            return self.parents[x]\\n\\n    def union(self, x, y):\\n        x = self.find(x)\\n        y = self.find(y)\\n\\n        if x == y:\\n            return False\\n\\n        self.parents[y] = x\\n        self.groups -= 1\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxNumEdgesToRemove(self, n, edges):\\n\\n        ufa = UnionFind(n) # Graph for Alice\\n        ufb = UnionFind(n) # Graph for Bob\\n        cnt = 0 # number of removable edges\\n        \\n        for x, y, z in edges:\\n            if x == 3:\\n                flag1 = ufa.union(y, z)\\n                flag2 = ufb.union(y, z)\\n                if not flag1 or not flag2: cnt +=1\\n\\n        for x, y, z in edges:\\n            if x == 1:\\n                flag = ufa.union(y, z)\\n                if not flag: cnt += 1\\n            if x == 2:\\n                flag = ufb.union(y, z)\\n                if not flag: cnt += 1\\n\\n        return cnt if ufa.groups == 1 and ufb.groups == 1 else -1\\n            \\n        \\nclass UnionFind():\\n    def __init__(self, n):\\n        self.parents = {i:i for i in range(1, n+1)}\\n        self.groups = n\\n\\n    def find(self, x):\\n        if self.parents[x] == x:\\n            return x\\n        else:\\n            self.parents[x] = self.find(self.parents[x])\\n            return self.parents[x]\\n\\n    def union(self, x, y):\\n        x = self.find(x)\\n        y = self.find(y)\\n\\n        if x == y:\\n            return False\\n\\n        self.parents[y] = x\\n        self.groups -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470959,
                "title": "python-short-and-clean-dsu-disjoint-set-union-functional-programming",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/editorial/).\\n\\n# Complexity\\n- Time complexity: $$O(e)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`n is number of nodes`,\\n`e is number of edges`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: list[list[int]]) -> int:\\n        es = reduce(lambda a, x: a[x[0]].append((x[1], x[2])) or a, edges, ([], [], [], []))\\n\\n        def union_count(dsu: DSU, es: Iterable[tuple[T, T]]) -> int:\\n            return sum(dsu.union(u, v) or 1 for u, v in es if not dsu.is_connected(u, v))\\n\\n        xs = range(1, n + 1)\\n        a_dsu, b_dsu = DSU(xs), DSU(xs)\\n        used = sum((\\n            union_count(a_dsu, es[3]) and\\n            union_count(b_dsu, es[3]),\\n            union_count(a_dsu, es[1]),\\n            union_count(b_dsu, es[2]),\\n        ))\\n\\n        return len(edges) - used if a_dsu.ds_count() == b_dsu.ds_count() == 1 else -1\\n\\n\\nT = Hashable\\n\\n\\nclass DSU:\\n    def __init__(self, xs: Iterable[T] = ()) -> None:\\n        self.parents: Mapping[T, T] = {x: x for x in xs}\\n        self.sizes: Mapping[T, int] = {x: 1 for x in xs}\\n        self.count: int = len(self.parents)\\n\\n    def find(self, u: T) -> T:\\n        self.parents[u] = u if self.parents[u] == u else self.find(self.parents[u])\\n        return self.parents[u]\\n\\n    def union(self, u: T, v: T) -> None:\\n        ur, vr = self.find(u), self.find(v)\\n        if ur == vr:\\n            return\\n        low, high = (ur, vr) if self.sizes[ur] < self.sizes[vr] else (vr, ur)\\n        self.parents[low] = high\\n        self.sizes[high] += self.sizes[low]\\n        self.count -= 1\\n\\n    def is_connected(self, u: T, v: T) -> bool:\\n        return self.find(u) == self.find(v)\\n\\n    def ds_count(self) -> int:\\n        return self.count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: list[list[int]]) -> int:\\n        es = reduce(lambda a, x: a[x[0]].append((x[1], x[2])) or a, edges, ([], [], [], []))\\n\\n        def union_count(dsu: DSU, es: Iterable[tuple[T, T]]) -> int:\\n            return sum(dsu.union(u, v) or 1 for u, v in es if not dsu.is_connected(u, v))\\n\\n        xs = range(1, n + 1)\\n        a_dsu, b_dsu = DSU(xs), DSU(xs)\\n        used = sum((\\n            union_count(a_dsu, es[3]) and\\n            union_count(b_dsu, es[3]),\\n            union_count(a_dsu, es[1]),\\n            union_count(b_dsu, es[2]),\\n        ))\\n\\n        return len(edges) - used if a_dsu.ds_count() == b_dsu.ds_count() == 1 else -1\\n\\n\\nT = Hashable\\n\\n\\nclass DSU:\\n    def __init__(self, xs: Iterable[T] = ()) -> None:\\n        self.parents: Mapping[T, T] = {x: x for x in xs}\\n        self.sizes: Mapping[T, int] = {x: 1 for x in xs}\\n        self.count: int = len(self.parents)\\n\\n    def find(self, u: T) -> T:\\n        self.parents[u] = u if self.parents[u] == u else self.find(self.parents[u])\\n        return self.parents[u]\\n\\n    def union(self, u: T, v: T) -> None:\\n        ur, vr = self.find(u), self.find(v)\\n        if ur == vr:\\n            return\\n        low, high = (ur, vr) if self.sizes[ur] < self.sizes[vr] else (vr, ur)\\n        self.parents[low] = high\\n        self.sizes[high] += self.sizes[low]\\n        self.count -= 1\\n\\n    def is_connected(self, u: T, v: T) -> bool:\\n        return self.find(u) == self.find(v)\\n\\n    def ds_count(self) -> int:\\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470548,
                "title": "c-union-find-using-striver-s-template",
                "content": "**Approach**\\n1. We have to find the maximum number of edges that can be removed from the graph while ensureing that both Alice and Bob able to construct a spanning tree. As spanning tree connects all the nodes in a graph, all nodes will be traversable in that case. we also know that there must be n-1 edges in the spanning tree.\\n2. We can use the union-find data structure to keep track of which nodes are connected to each other in the spanning tree, so we have defined two dsu\\'s for alice and bob. Initially, each node is its own parent. Also we defined alice_edge, bob_edge to track no of edges in their spanning tree and removed_edge for counting no of removable edges.\\n3. At first we start by considering the edges that can be used by both Alice and Bob i.e. type 3 edges. Because If we can merge the two nodes of type 3 edge it contributes in construction of both alice and bobs spanning tree. so increase the count of edges of boths dsu\\'s [alice_edge, bol_edge]. If not possible to merge them, it means they are already connected so the current edge is redundent and we can remove it.\\n4. Next, we consider the edges that can only be used by Alice and Bob respectively. If a type 1 or type 2 edge can be used to connect two nodes in Alice\\'s or Bob\\'s respective connected components, then we know that only that user can use that edge to construct their spanning tree so increase their respcetive edge count. Otherwise, remove the edge same as type 3.\\n5. Finally, check if both Alice and Bob were able to construct a spanning tree (i.e. they both have n-1 no of edges). If that possible then we can return the no of removed edge [removed_edge]. else return -1.\\n\\n**Disjoint Set  class**\\n```\\nclass DisjointSet {\\n    vector<int> parent; \\n    vector<int> rank;\\n    public:\\n    DisjointSet(int n) {\\n        parent.resize(n+1,0);\\n        rank.resize(n+1,0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    int findUParent(int node) {\\n        if(node == parent[node])\\n            return node;\\n        return parent[node] = findUParent(parent[node]);\\n    }\\n    \\n    void unionByRank(int u, int v) {\\n        int uparentU = findUParent(u);\\n        int uparentV = findUParent(v);\\n        \\n        if(rank[uparentU] > rank[uparentV]) {\\n            parent[uparentV] = uparentU;\\n\\n        } else if(rank[uparentU] < rank[uparentV]){\\n            parent[uparentU] = uparentV;\\n\\n        } else {\\n            parent[uparentU] = uparentV;\\n            rank[uparentV]++;\\n        }       \\n    }\\n};\\n```\\n\\n**Solution Class**\\n```\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        DisjointSet alice(n), bob(n);\\n        \\n        int removed_edge = 0, alice_edge = 0, bob_edge = 0;\\n        \\n        for(auto edge : edges) {\\n            if(edge[0] == 3) {\\n                if(alice.findUParent(edge[1]) != alice.findUParent(edge[2])) {\\n                    alice.unionByRank(edge[1], edge[2]);\\n                    bob.unionByRank(edge[1], edge[2]);\\n                    alice_edge++;\\n                    bob_edge++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            }\\n        }\\n            \\n         for(auto edge : edges) {\\n            if(edge[0] == 2) {\\n                if(bob.findUParent(edge[1]) != bob.findUParent(edge[2])) {\\n                    bob.unionByRank(edge[1], edge[2]);\\n                    bob_edge++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            } else if(edge[0] == 1) {\\n                if(alice.findUParent(edge[1]) != alice.findUParent(edge[2])) {\\n                    alice.unionByRank(edge[1], edge[2]);\\n                    alice_edge++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            }\\n        }  \\n        \\n        return (alice_edge == n-1 && bob_edge == n-1) ? removed_edge : -1;\\n    }\\n};\\n```\\n\\n**TC : O(N)** [as we are using two loops and union find takes O(4\\u03B1) which is approximately O(1)]\\n**SC: O(N)** [as we taking two dsu objects means toatal 4 arrays i.e. O(N)]\\n\\n**Please upvote if you like the solution !!\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> parent; \\n    vector<int> rank;\\n    public:\\n    DisjointSet(int n) {\\n        parent.resize(n+1,0);\\n        rank.resize(n+1,0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    int findUParent(int node) {\\n        if(node == parent[node])\\n            return node;\\n        return parent[node] = findUParent(parent[node]);\\n    }\\n    \\n    void unionByRank(int u, int v) {\\n        int uparentU = findUParent(u);\\n        int uparentV = findUParent(v);\\n        \\n        if(rank[uparentU] > rank[uparentV]) {\\n            parent[uparentV] = uparentU;\\n\\n        } else if(rank[uparentU] < rank[uparentV]){\\n            parent[uparentU] = uparentV;\\n\\n        } else {\\n            parent[uparentU] = uparentV;\\n            rank[uparentV]++;\\n        }       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        DisjointSet alice(n), bob(n);\\n        \\n        int removed_edge = 0, alice_edge = 0, bob_edge = 0;\\n        \\n        for(auto edge : edges) {\\n            if(edge[0] == 3) {\\n                if(alice.findUParent(edge[1]) != alice.findUParent(edge[2])) {\\n                    alice.unionByRank(edge[1], edge[2]);\\n                    bob.unionByRank(edge[1], edge[2]);\\n                    alice_edge++;\\n                    bob_edge++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            }\\n        }\\n            \\n         for(auto edge : edges) {\\n            if(edge[0] == 2) {\\n                if(bob.findUParent(edge[1]) != bob.findUParent(edge[2])) {\\n                    bob.unionByRank(edge[1], edge[2]);\\n                    bob_edge++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            } else if(edge[0] == 1) {\\n                if(alice.findUParent(edge[1]) != alice.findUParent(edge[2])) {\\n                    alice.unionByRank(edge[1], edge[2]);\\n                    alice_edge++;\\n                } else {\\n                    removed_edge++;\\n                }\\n            }\\n        }  \\n        \\n        return (alice_edge == n-1 && bob_edge == n-1) ? removed_edge : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312484,
                "title": "union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool sortcol(vector<int> &a,vector<int> &b)\\n    {\\n      return a[0]>b[0];  \\n    }\\n    int extremeparent(vector<int> &parent,int x)\\n    {\\n      if(parent[x]==x)\\n      return x;\\n      parent[x]=extremeparent(parent,parent[x]);\\n      return parent[x];  \\n    }\\n    void changeparent(vector<int> &parent,int x,int y)\\n    {\\n      if(x>y)\\n      parent[x]=y;\\n      else\\n      parent[y]=x;\\n      return ;  \\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n       vector<int> parental(n+1,0);\\n       vector<int> parentbo(n+1,0);\\n       for(int i=0;i<n+1;i++) \\n       {\\n         parental[i]=i;\\n         parentbo[i]=i;\\n       }\\n       sort(edges.begin(),edges.end(),sortcol);  \\n       vector<vector<int>> v=edges;\\n       int count=0; \\n      // cout<<count<<\" \"; \\n       for(int i=0;i<v.size();i++)\\n       {\\n         if(v[i][0]==3)\\n         {\\n          int flag=0;   \\n          int x=extremeparent(parental,v[i][1]);\\n          int y=extremeparent(parental,v[i][2]);\\n          if(x!=y)\\n          changeparent(parental,x,y);\\n          else\\n          flag=1;    \\n          x=extremeparent(parentbo,v[i][1]);\\n          y=extremeparent(parentbo,v[i][2]);\\n          if(x!=y)\\n          changeparent(parentbo,x,y);\\n          else\\n          flag++;\\n          if(flag==2)\\n          count++;    \\n         }\\n         else if(v[i][0]==1)\\n         {\\n          int x=extremeparent(parental,v[i][1]);\\n          int y=extremeparent(parental,v[i][2]);\\n          if(x!=y)\\n          changeparent(parental,x,y);\\n          else\\n          count++;    \\n         }\\n         else\\n         {\\n          int x=extremeparent(parentbo,v[i][1]);\\n          int y=extremeparent(parentbo,v[i][2]);\\n          if(x!=y)\\n          changeparent(parentbo,x,y);  \\n          else\\n          count++;    \\n         }\\n         // cout<<count<<\" \";  \\n       }\\n       int last=-1; \\n       for(int i=1;i<n+1;i++)\\n       {\\n         int x=extremeparent(parental,i);\\n         if(x==last||last==-1)\\n         {\\n         }\\n         else\\n         return -1;\\n         last=x;  \\n       }\\n       for(int j=1;j<n+1;j++)\\n       {\\n         int x=extremeparent(parentbo,j);\\n         if(x==last||last==-1)\\n         {\\n         }\\n         else\\n         return -1;\\n         last=x;   \\n       }\\n       return count;\\n    }\\n};\\n\\n// \\n// \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sortcol(vector<int> &a,vector<int> &b)\\n    {\\n      return a[0]>b[0];  \\n    }\\n    int extremeparent(vector<int> &parent,int x)\\n    {\\n      if(parent[x]==x)\\n      return x;\\n      parent[x]=extremeparent(parent,parent[x]);\\n      return parent[x];  \\n    }\\n    void changeparent(vector<int> &parent,int x,int y)\\n    {\\n      if(x>y)\\n      parent[x]=y;\\n      else\\n      parent[y]=x;\\n      return ;  \\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n       vector<int> parental(n+1,0);\\n       vector<int> parentbo(n+1,0);\\n       for(int i=0;i<n+1;i++) \\n       {\\n         parental[i]=i;\\n         parentbo[i]=i;\\n       }\\n       sort(edges.begin(),edges.end(),sortcol);  \\n       vector<vector<int>> v=edges;\\n       int count=0; \\n      // cout<<count<<\" \"; \\n       for(int i=0;i<v.size();i++)\\n       {\\n         if(v[i][0]==3)\\n         {\\n          int flag=0;   \\n          int x=extremeparent(parental,v[i][1]);\\n          int y=extremeparent(parental,v[i][2]);\\n          if(x!=y)\\n          changeparent(parental,x,y);\\n          else\\n          flag=1;    \\n          x=extremeparent(parentbo,v[i][1]);\\n          y=extremeparent(parentbo,v[i][2]);\\n          if(x!=y)\\n          changeparent(parentbo,x,y);\\n          else\\n          flag++;\\n          if(flag==2)\\n          count++;    \\n         }\\n         else if(v[i][0]==1)\\n         {\\n          int x=extremeparent(parental,v[i][1]);\\n          int y=extremeparent(parental,v[i][2]);\\n          if(x!=y)\\n          changeparent(parental,x,y);\\n          else\\n          count++;    \\n         }\\n         else\\n         {\\n          int x=extremeparent(parentbo,v[i][1]);\\n          int y=extremeparent(parentbo,v[i][2]);\\n          if(x!=y)\\n          changeparent(parentbo,x,y);  \\n          else\\n          count++;    \\n         }\\n         // cout<<count<<\" \";  \\n       }\\n       int last=-1; \\n       for(int i=1;i<n+1;i++)\\n       {\\n         int x=extremeparent(parental,i);\\n         if(x==last||last==-1)\\n         {\\n         }\\n         else\\n         return -1;\\n         last=x;  \\n       }\\n       for(int j=1;j<n+1;j++)\\n       {\\n         int x=extremeparent(parentbo,j);\\n         if(x==last||last==-1)\\n         {\\n         }\\n         else\\n         return -1;\\n         last=x;   \\n       }\\n       return count;\\n    }\\n};\\n\\n// \\n// \\n```",
                "codeTag": "C++"
            },
            {
                "id": 2038969,
                "title": "easy-c-solution-using-union-find-method",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    class dsu{\\n        public:\\n        vector<int> parent, sz;\\n        dsu(int n){\\n            parent.resize(n);\\n            sz.resize(n);\\n            for(int i = 0; i<n; i++){\\n                parent[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n\\n        int find_set(int x){\\n            if(parent[x] == x) return x;\\n            return parent[x] = find_set(parent[x]);\\n        }\\n\\n        bool make_union(int x, int y){\\n            int a = find_set(x);\\n            int b = find_set(y);\\n            if(a == b) return false;\\n            if(sz[a] < sz[b]) swap(a, b);\\n            parent[b] = a;\\n            sz[a] += sz[b];\\n            return true;\\n        }\\n\\n        int count(int x){\\n            return sz[x];\\n        }\\n    };\\n    int maxNumEdgesToRemove(int n, vector<vector<int>> &edges)\\n    {\\n         vector<pair<int,int>> alice, bob, both;\\n         for(int i = 0; i<edges.size(); i++){\\n             int t = edges[i][0];\\n             int x = edges[i][1]-1;\\n             int y = edges[i][2]-1;\\n             if(t == 3){\\n                 both.push_back({x, y});\\n             }\\n             else if(t == 2){\\n                 bob.push_back({x, y});\\n             }\\n             else{\\n                 alice.push_back({x, y});\\n             }\\n         }\\n\\n         dsu a(n), b(n);\\n         int ans = 0;\\n         for(auto it : both){\\n             ans += a.make_union(it.first, it.second);\\n             b.make_union(it.first, it.second);\\n         }\\n         for (auto it : alice){\\n             ans += a.make_union(it.first, it.second); \\n         }\\n         for (auto it : bob){\\n             ans += b.make_union(it.first, it.second);     \\n         }\\n         if(a.count(a.find_set(0)) < n || b.count(b.find_set(0)) < n) return -1;\\n         return edges.size() - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    class dsu{\\n        public:\\n        vector<int> parent, sz;\\n        dsu(int n){\\n            parent.resize(n);\\n            sz.resize(n);\\n            for(int i = 0; i<n; i++){\\n                parent[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n\\n        int find_set(int x){\\n            if(parent[x] == x) return x;\\n            return parent[x] = find_set(parent[x]);\\n        }\\n\\n        bool make_union(int x, int y){\\n            int a = find_set(x);\\n            int b = find_set(y);\\n            if(a == b) return false;\\n            if(sz[a] < sz[b]) swap(a, b);\\n            parent[b] = a;\\n            sz[a] += sz[b];\\n            return true;\\n        }\\n\\n        int count(int x){\\n            return sz[x];\\n        }\\n    };\\n    int maxNumEdgesToRemove(int n, vector<vector<int>> &edges)\\n    {\\n         vector<pair<int,int>> alice, bob, both;\\n         for(int i = 0; i<edges.size(); i++){\\n             int t = edges[i][0];\\n             int x = edges[i][1]-1;\\n             int y = edges[i][2]-1;\\n             if(t == 3){\\n                 both.push_back({x, y});\\n             }\\n             else if(t == 2){\\n                 bob.push_back({x, y});\\n             }\\n             else{\\n                 alice.push_back({x, y});\\n             }\\n         }\\n\\n         dsu a(n), b(n);\\n         int ans = 0;\\n         for(auto it : both){\\n             ans += a.make_union(it.first, it.second);\\n             b.make_union(it.first, it.second);\\n         }\\n         for (auto it : alice){\\n             ans += a.make_union(it.first, it.second); \\n         }\\n         for (auto it : bob){\\n             ans += b.make_union(it.first, it.second);     \\n         }\\n         if(a.count(a.find_set(0)) < n || b.count(b.find_set(0)) < n) return -1;\\n         return edges.size() - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881536,
                "title": "python-union-find-by-rank-w-path-compression-beats-99",
                "content": "First process the edges that both people can use. This has priority over Type 1 and Type 2 edges since the edge works for both Alice and Bob. After that, it\\'s textbook Union-Find for both Alice and Bob.\\n\\n```\\nclass UnionFind:\\n    \"\"\"\\n    Standard Union-Find data structure implementation\\n    with path compression and rank\\n    \"\"\"\\n    def __init__(self, n):\\n        self.n = n\\n        self.uf = [i for i in range(n + 1)]\\n        self.rank = [0] * (n + 1)\\n        self.comp = n\\n    \\n    def root(self, u):\\n        if self.uf[u] != u:\\n            self.uf[u] = self.root(self.uf[u])\\n        return self.uf[u]\\n\\n    def union(self, u, v):\\n        u, v = self.root(u), self.root(v)\\n        if u == v: return False\\n        if self.rank[u] > self.rank[v]:\\n            self.uf[v] = u\\n        elif self.rank[u] < self.rank[v]:\\n            self.uf[u] = v\\n        else:\\n            self.uf[v] = u\\n            self.rank[u] += 1\\n        \\n        self.comp -= 1\\n        return True\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        # initialize both data structures to keep track of connected components\\n        ufAlice = UnionFind(n)\\n        ufBob = UnionFind(n)\\n\\n        numEdges = 0\\n\\n        # Add all type 3 edges that don\\'t create a cycle (i.e. have the same parent in the \\n        # data structure)\\n        for t, u, v in edges:\\n            if t == 3:\\n                numEdges += int(ufAlice.union(u, v))\\n                ufBob.union(u, v)\\n        \\n        # Unite all Alice / Bob edges that don\\'t create a cycle\\n        for t, u, v in edges:\\n            if t == 1:\\n                numEdges += int(ufAlice.union(u, v))\\n            elif t == 2:\\n                numEdges += int(ufBob.union(u, v))\\n        \\n        # if there are multiple components in either alice / bob\\'s graphs, then it is \\n        # disconnected and we return -1\\n        if ufAlice.comp != 1 or ufBob.comp != 1:\\n            return -1\\n        \\n        # otherwise, we can remove all edges that aren\\'t chosen\\n        return len(edges) - numEdges\\n\\n```\\n\\n**Analysis**\\nTime: $O(E * \\\\alpha(N))$ where E is the number of edges. We traverse the edges array twice, and the time complexity of Union-Find is the *Inverse Ackermann Function* ($\\\\alpha(N)$), which is near-constant but can be treated as $\\\\log(n)$.\\n\\nSpace: $O(N)$ To Store the Union-Find data structures",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass UnionFind:\\n    \"\"\"\\n    Standard Union-Find data structure implementation\\n    with path compression and rank\\n    \"\"\"\\n    def __init__(self, n):\\n        self.n = n\\n        self.uf = [i for i in range(n + 1)]\\n        self.rank = [0] * (n + 1)\\n        self.comp = n\\n    \\n    def root(self, u):\\n        if self.uf[u] != u:\\n            self.uf[u] = self.root(self.uf[u])\\n        return self.uf[u]\\n\\n    def union(self, u, v):\\n        u, v = self.root(u), self.root(v)\\n        if u == v: return False\\n        if self.rank[u] > self.rank[v]:\\n            self.uf[v] = u\\n        elif self.rank[u] < self.rank[v]:\\n            self.uf[u] = v\\n        else:\\n            self.uf[v] = u\\n            self.rank[u] += 1\\n        \\n        self.comp -= 1\\n        return True\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        # initialize both data structures to keep track of connected components\\n        ufAlice = UnionFind(n)\\n        ufBob = UnionFind(n)\\n\\n        numEdges = 0\\n\\n        # Add all type 3 edges that don\\'t create a cycle (i.e. have the same parent in the \\n        # data structure)\\n        for t, u, v in edges:\\n            if t == 3:\\n                numEdges += int(ufAlice.union(u, v))\\n                ufBob.union(u, v)\\n        \\n        # Unite all Alice / Bob edges that don\\'t create a cycle\\n        for t, u, v in edges:\\n            if t == 1:\\n                numEdges += int(ufAlice.union(u, v))\\n            elif t == 2:\\n                numEdges += int(ufBob.union(u, v))\\n        \\n        # if there are multiple components in either alice / bob\\'s graphs, then it is \\n        # disconnected and we return -1\\n        if ufAlice.comp != 1 or ufBob.comp != 1:\\n            return -1\\n        \\n        # otherwise, we can remove all edges that aren\\'t chosen\\n        return len(edges) - numEdges\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237183,
                "title": "dsu-c-explained-by-comments",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n\\n    int alice[100001];\\n    int bob[100001];\\n  \\nint finda(int a){\\n\\tif(alice[a]==-1)\\n\\treturn a;\\n\\treturn alice[a]=finda(alice[a]);\\n}\\n    int findb(int a){\\n\\tif(bob[a]==-1)\\n\\treturn a;\\n\\treturn bob[a]=findb(bob[a]);\\n}\\nvoid mergea (int a,int b){\\n\\talice[a]=b;\\n}\\n    void mergeb (int a,int b){\\n\\tbob[a]=b;\\n}\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<100001;i++){\\n\\talice[i]=-1;\\n            bob[i]=-1;\\n}   \\n     int t3=0;//essential edges for both \\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==3){\\n                if(finda(edges[i][1])!=finda(edges[i][2])){\\n                   mergea(finda(edges[i][1]),finda(edges[i][2]));\\n                   mergeb(findb(edges[i][1]),findb(edges[i][2]));\\n                    t3++;\\n                }\\n            }\\n        }\\n        int t1=0; // essential edges for alice\\n         for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==1){\\n                if(finda(edges[i][1])!=finda(edges[i][2])){\\n                    mergea(finda(edges[i][1]),finda(edges[i][2]));\\n                    \\n                    t1++;\\n                    cout<<\"I\"<<i<<\" \";\\n                }\\n            }\\n        }\\n        int t2=0; //essential edges for bob\\n         for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==2){\\n                if(findb(edges[i][1])!=findb(edges[i][2])){\\n                    mergeb(findb(edges[i][1]),findb(edges[i][2]));\\n                    \\n                    t2++;\\n                }\\n            }\\n        }\\n   if(t1+t3<n-1||t3+t2<n-1)// if(t1+t3<n-1) then alice can not traverse the graph because tree requires n-1 edges to be spanned completely if(t2+t3<n-1)then bob can not traverse.\\n       return -1;\\n        \\n        cout<<t1<<\" \"<<t2<<\" \"<<t3<<endl;\\n      return edges.size()-t1-t2-t3;  //(t1+t2+t3) are essential edges\\n    }\\n};\\n\\n\\n// below description in hindi vvvvvvvvvvvvvvvvvvvvvv//\\n\\n// yrrr agar yeh code smjhna he toh bsss sbse phle type third nodes count krrro jo essential he unse alice ka parent  array aur bob ka parent  array dono modify honge but in case of type 1 node we only modify alice array in second for loop then we run last loop for bob \\n// so t1 +t2+t3 are all the essential edgess we can get \\n//so answer is total -(essential);------------------:)\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n\\n    int alice[100001];\\n    int bob[100001];\\n  \\nint finda(int a){\\n\\tif(alice[a]==-1)\\n\\treturn a;\\n\\treturn alice[a]=finda(alice[a]);\\n}\\n    int findb(int a){\\n\\tif(bob[a]==-1)\\n\\treturn a;\\n\\treturn bob[a]=findb(bob[a]);\\n}\\nvoid mergea (int a,int b){\\n\\talice[a]=b;\\n}\\n    void mergeb (int a,int b){\\n\\tbob[a]=b;\\n}\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<100001;i++){\\n\\talice[i]=-1;\\n            bob[i]=-1;\\n}   \\n     int t3=0;//essential edges for both \\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==3){\\n                if(finda(edges[i][1])!=finda(edges[i][2])){\\n                   mergea(finda(edges[i][1]),finda(edges[i][2]));\\n                   mergeb(findb(edges[i][1]),findb(edges[i][2]));\\n                    t3++;\\n                }\\n            }\\n        }\\n        int t1=0; // essential edges for alice\\n         for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==1){\\n                if(finda(edges[i][1])!=finda(edges[i][2])){\\n                    mergea(finda(edges[i][1]),finda(edges[i][2]));\\n                    \\n                    t1++;\\n                    cout<<\"I\"<<i<<\" \";\\n                }\\n            }\\n        }\\n        int t2=0; //essential edges for bob\\n         for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==2){\\n                if(findb(edges[i][1])!=findb(edges[i][2])){\\n                    mergeb(findb(edges[i][1]),findb(edges[i][2]));\\n                    \\n                    t2++;\\n                }\\n            }\\n        }\\n   if(t1+t3<n-1||t3+t2<n-1)// if(t1+t3<n-1) then alice can not traverse the graph because tree requires n-1 edges to be spanned completely if(t2+t3<n-1)then bob can not traverse.\\n       return -1;\\n        \\n        cout<<t1<<\" \"<<t2<<\" \"<<t3<<endl;\\n      return edges.size()-t1-t2-t3;  //(t1+t2+t3) are essential edges\\n    }\\n};\\n\\n\\n// below description in hindi vvvvvvvvvvvvvvvvvvvvvv//\\n\\n// yrrr agar yeh code smjhna he toh bsss sbse phle type third nodes count krrro jo essential he unse alice ka parent  array aur bob ka parent  array dono modify honge but in case of type 1 node we only modify alice array in second for loop then we run last loop for bob \\n// so t1 +t2+t3 are all the essential edgess we can get \\n//so answer is total -(essential);------------------:)\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 933579,
                "title": "ruby-union-find-kruskal-s-algorithm-with-comments",
                "content": "## Rephrase task\\n\\nAssume we do not have any edges initially: only some set of vertices (numbers from 1 to n). And some set of edges that we can use to make graph traversable by both Alice and Bob. Number of edges in the set minus minimum number of edges to add (to make graph traversable by both Alice and Bob) equals to the initial value we need to calculate.\\n\\n## Observation\\n\\nEdges that are traversable by both Alice and Bob should be preoritasable over others edges. But only if any new age does not add a cycle in the graph. At the end we should have `n - 1` edges traversable by Alice and `n - 1` edges traversable by Bob. Some of them may be shared (if can by traversed by both Alice and Bob). So we need from `n - 1`  upto ` 2(n - 1)` edges to make graph traversable by both.\\n\\n## Algorithm\\n\\nSplit edges by three groups (like in task description). Use `merge` method from Union Find algorithm to to check whether we can add next edge not adding cycles (vertices `u` and `v` should be in different groups). First use up to `n - 1` edges traversed by both Alice and Bob, then use up to `n - 1` edges traversed by Alice, and then use up to `n - 1` edges traversed by Bob. Return number not used edges if we have enough edges for Alice and Bob or `-1` if we ran out of edges.\\n\\n## Implementation\\n\\nRuby version\\n\\n```ruby\\n# find with path compression\\ndef find(par, x)\\n  par[x] == x ? x : (par[x] = find(par, par[x]))\\nend\\n\\ndef merge(par, x, y)\\n  x = find(par, x)\\n  y = find(par, y)\\n  return false if x == y\\n  par[x] = y\\n  return true\\nend\\n\\nALICE = 1\\nBOB = 2\\nBOTH = 3\\n\\ndef max_num_edges_to_remove(n, edges)\\n  res = edges.size # all minus min needed num of edges to make graph traversable\\n                   # (remaining count after adding all nessasary edges)\\n  return res if n == 1\\n  return -1 if edges.size < n - 1 # not enough edges to make graph traversable\\n\\n  edges_for = edges.group_by(&:first)\\n  return -1 if edges_for.keys.one? && edges_for.keys[0] != BOTH # not enough edges for Alice or Bob\\n  \\n  # Initially, each vertice is in its own single-vertice group where the vertice is the parent of that group.\\n  par_alice = *0..n\\n  need_alice = n - 1\\n  \\n  edges_for[BOTH]&.each do |_, u, v|\\n    if merge(par_alice, u, v)\\n      res -= 1\\n      need_alice -= 1\\n      return res if need_alice == 0\\n    end\\n  end\\n  \\n  par_bob = par_alice.dup\\n  need_bob = need_alice\\n  \\n  edges_for[ALICE]&.each do |_, u, v|\\n    if merge(par_alice, u, v)\\n      res -= 1\\n      need_alice -= 1\\n      break if need_alice == 0\\n    end\\n  end\\n  return -1 if need_alice > 0\\n  \\n  edges_for[BOB]&.each do |_, u, v|\\n    if merge(par_bob, u, v)\\n      res -= 1\\n      need_bob -= 1\\n      return res if need_bob == 0\\n    end\\n  end\\n  \\n  return -1\\nend\\n# Runtime: 216 ms\\n```\\n\\n## Videos for Union Find (by William Fiset):\\n- [Union Find Introduction](https://www.youtube.com/watch?v=ibjEGG7ylHk)\\n- [Union Find Kruskal\\'s Algorithm](https://www.youtube.com/watch?v=JZBQLXgSGfs)\\n- [Union Find - Union and Find Operations](https://www.youtube.com/watch?v=0jNmHPfA_yE)\\n- [Union Find Path Compression](https://www.youtube.com/watch?v=VHRhJWacxis)\\n- [Union Find Code](https://www.youtube.com/watch?v=KbFlZYCpONw)\\n\\n[LeetCode Union Find Problems](https://leetcode.com/tag/union-find/)\\n",
                "solutionTags": [
                    "Ruby",
                    "Union Find"
                ],
                "code": "```ruby\\n# find with path compression\\ndef find(par, x)\\n  par[x] == x ? x : (par[x] = find(par, par[x]))\\nend\\n\\ndef merge(par, x, y)\\n  x = find(par, x)\\n  y = find(par, y)\\n  return false if x == y\\n  par[x] = y\\n  return true\\nend\\n\\nALICE = 1\\nBOB = 2\\nBOTH = 3\\n\\ndef max_num_edges_to_remove(n, edges)\\n  res = edges.size # all minus min needed num of edges to make graph traversable\\n                   # (remaining count after adding all nessasary edges)\\n  return res if n == 1\\n  return -1 if edges.size < n - 1 # not enough edges to make graph traversable\\n\\n  edges_for = edges.group_by(&:first)\\n  return -1 if edges_for.keys.one? && edges_for.keys[0] != BOTH # not enough edges for Alice or Bob\\n  \\n  # Initially, each vertice is in its own single-vertice group where the vertice is the parent of that group.\\n  par_alice = *0..n\\n  need_alice = n - 1\\n  \\n  edges_for[BOTH]&.each do |_, u, v|\\n    if merge(par_alice, u, v)\\n      res -= 1\\n      need_alice -= 1\\n      return res if need_alice == 0\\n    end\\n  end\\n  \\n  par_bob = par_alice.dup\\n  need_bob = need_alice\\n  \\n  edges_for[ALICE]&.each do |_, u, v|\\n    if merge(par_alice, u, v)\\n      res -= 1\\n      need_alice -= 1\\n      break if need_alice == 0\\n    end\\n  end\\n  return -1 if need_alice > 0\\n  \\n  edges_for[BOB]&.each do |_, u, v|\\n    if merge(par_bob, u, v)\\n      res -= 1\\n      need_bob -= 1\\n      return res if need_bob == 0\\n    end\\n  end\\n  \\n  return -1\\nend\\n# Runtime: 216 ms\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 833374,
                "title": "javascript-union-find-easy-and-concise",
                "content": "**Intuition**:\\n\\tUnion find appeals to problems related to paths that traverse the whole tree. Here we create two union finds, one for each player. The important thing here is to always prefer type 3 edges over 2 or 1 because the latter are reduntant once the type 3 is chosen. So the whole idea is filling up my unionfinds with the components while keeping track of the edges I\\'m using. In the end, the number of groups in each unionfind has to be 1 for each, meaning that both players can traverse the whole tree. If not, then the tree is not traversable and -1 has to be returned.  The result is the total available edges minus the ones I actually used.\\n\\t\\n```\\nclass UnionFind {\\n\\n    // Construction takes O(n)\\n    constructor(size){\\n        //the total count of different elements(not groups) in this union find\\n        this.count=size\\n        //tracks the sizes of each of the components(groups/sets)\\n        //groupsize[a] returns how many elements the component with root a has \\n        this.groupSize=[...Array(size)] \\n        //number of components(groups) in the union find\\n        this.numComponents=size\\n        //points to the parent of i, if parent[i]=i, i is a root node\\n        this.parent=[...Array(size)]  //which is also the index of the group\\n\\n        //put every element into its own group\\n        // rooted at itself\\n        for (let i = 0; i < size; i++) {\\n            this.groupSize[i]=i     \\n            this.parent[i]=i            \\n        }\\n    }\\n\\n\\n\\n    //returns to which component (group) my element belongs to \\n    // \\u03B1(n) --Amortized constant time \\n    // Update: Also compresses the paths so that each child points to its \\n    // parent\\n    find(element){\\n        let root=element\\n        //find the parent of the group the elemnt belongs to\\n        // When root===parent[root] is always the parent of that group (root)\\n        while(root!=this.parent[root])\\n            root=this.parent[root]\\n\\n        // Compression, point the element to its parent if its not already pointed\\n        // Tldr: Not only do I point my element to its actual root, i point any\\n        // inbetween elements to that root aswell\\n        while(element!=root){\\n            let next=this.parent[element]\\n            this.parent[element]=root\\n            element=next\\n        }\\n        \\n        return root\\n    }   \\n\\n    //Unifies the sets containing A and B\\n    // \\u03B1(n) --Amortized constant time \\n    union(A,B){\\n        let root1=this.find(A) //parent of A\\n            ,root2=this.find(B) //parent of B\\n\\n        // I want to put the set with fewer elements \\n        // to the one with more elemenets\\n        if(this.groupSize[root1]<this.groupSize[root2]){\\n            this.groupSize[root2]+=this.groupSize[root1]\\n            this.parent[root1]=this.parent[root2]\\n        }\\n        else {\\n            this.groupSize[root1]+=this.groupSize[root2]\\n            this.parent[root2]=this.parent[root1]\\n        }\\n\\n        this.numComponents-- //cos 1 less group, since i merged 2\\n    }\\n\\n    //same parent=>samegroup\\n    sameGroup=(A,B)=>this.find(A)==this.find(B)\\n\\n    //essentially the groupSize of its parent\\'s group\\n    sizeOfGroup=(A)=>this.groupSize[this.find(A)]\\n\\n}\\n\\n//Main Function\\n var maxNumEdgesToRemove = function(n, edges) {\\n    edges.sort((a,b)=>b[0]-a[0]) //sort to always prefer type 3 first\\n    let edgesUsed=0,Bob=new UnionFind(n),Alice=new UnionFind(n)\\n    \\n    for (const [type,f,to] of edges) {\\n        if((type==3||type==2)&&!Bob.sameGroup(f,to)){\\n            Bob.union(f,to)\\n            edgesUsed++\\n        }\\n        if((type==3||type==1)&&!Alice.sameGroup(f,to)){\\n            Alice.union(f,to)\\n            if(type==1)// I already incremented above for type 3s\\n\\t\\t\\t\\tedgesUsed++\\n        }\\n    }\\n\\t\\n\\t//can they both traverse the whole tree?\\n    if(Bob.numComponents!=1||Alice.numComponents!==1)\\n        return -1\\n    return edges.length-edgesUsed\\n };\\n\\n\\t\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\n\\n    // Construction takes O(n)\\n    constructor(size){\\n        //the total count of different elements(not groups) in this union find\\n        this.count=size\\n        //tracks the sizes of each of the components(groups/sets)\\n        //groupsize[a] returns how many elements the component with root a has \\n        this.groupSize=[...Array(size)] \\n        //number of components(groups) in the union find\\n        this.numComponents=size\\n        //points to the parent of i, if parent[i]=i, i is a root node\\n        this.parent=[...Array(size)]  //which is also the index of the group\\n\\n        //put every element into its own group\\n        // rooted at itself\\n        for (let i = 0; i < size; i++) {\\n            this.groupSize[i]=i     \\n            this.parent[i]=i            \\n        }\\n    }\\n\\n\\n\\n    //returns to which component (group) my element belongs to \\n    // \\u03B1(n) --Amortized constant time \\n    // Update: Also compresses the paths so that each child points to its \\n    // parent\\n    find(element){\\n        let root=element\\n        //find the parent of the group the elemnt belongs to\\n        // When root===parent[root] is always the parent of that group (root)\\n        while(root!=this.parent[root])\\n            root=this.parent[root]\\n\\n        // Compression, point the element to its parent if its not already pointed\\n        // Tldr: Not only do I point my element to its actual root, i point any\\n        // inbetween elements to that root aswell\\n        while(element!=root){\\n            let next=this.parent[element]\\n            this.parent[element]=root\\n            element=next\\n        }\\n        \\n        return root\\n    }   \\n\\n    //Unifies the sets containing A and B\\n    // \\u03B1(n) --Amortized constant time \\n    union(A,B){\\n        let root1=this.find(A) //parent of A\\n            ,root2=this.find(B) //parent of B\\n\\n        // I want to put the set with fewer elements \\n        // to the one with more elemenets\\n        if(this.groupSize[root1]<this.groupSize[root2]){\\n            this.groupSize[root2]+=this.groupSize[root1]\\n            this.parent[root1]=this.parent[root2]\\n        }\\n        else {\\n            this.groupSize[root1]+=this.groupSize[root2]\\n            this.parent[root2]=this.parent[root1]\\n        }\\n\\n        this.numComponents-- //cos 1 less group, since i merged 2\\n    }\\n\\n    //same parent=>samegroup\\n    sameGroup=(A,B)=>this.find(A)==this.find(B)\\n\\n    //essentially the groupSize of its parent\\'s group\\n    sizeOfGroup=(A)=>this.groupSize[this.find(A)]\\n\\n}\\n\\n//Main Function\\n var maxNumEdgesToRemove = function(n, edges) {\\n    edges.sort((a,b)=>b[0]-a[0]) //sort to always prefer type 3 first\\n    let edgesUsed=0,Bob=new UnionFind(n),Alice=new UnionFind(n)\\n    \\n    for (const [type,f,to] of edges) {\\n        if((type==3||type==2)&&!Bob.sameGroup(f,to)){\\n            Bob.union(f,to)\\n            edgesUsed++\\n        }\\n        if((type==3||type==1)&&!Alice.sameGroup(f,to)){\\n            Alice.union(f,to)\\n            if(type==1)// I already incremented above for type 3s\\n\\t\\t\\t\\tedgesUsed++\\n        }\\n    }\\n\\t\\n\\t//can they both traverse the whole tree?\\n    if(Bob.numComponents!=1||Alice.numComponents!==1)\\n        return -1\\n    return edges.length-edgesUsed\\n };\\n\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831656,
                "title": "c-kruskal-algorithm-easy-to-follow-code",
                "content": "1. Try to include Type 3 edges maximally (1.set)\\n2. Count number of type1 edges that we can add to 1.set with out introducing any cycle.\\n3. Count number of type2 edges that we can add to 1.set with out introducing any cycle.\\n\\nthe answer will be (totoal_#_edges - size_of_set.1 - #_2 - #_3)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<long long, pair<int, int>>> p;\\n    vector<int> id;\\n    int N;\\n\\n    void initialize() {\\n        id.resize(N);\\n        p.resize(N);\\n        for(int i = 0;i < N;++i)\\n            id[i] = i;\\n    }\\n\\n    int root(int x) {\\n        while(id[x] != x) {\\n            id[x] = id[id[x]];\\n            x = id[x];\\n        }\\n\\n        return x;\\n    }\\n\\n    void union1(int x, int y) {\\n        int p = root(x);\\n        int q = root(y);\\n        id[p] = id[q];\\n    }\\n\\n    int check_type(int type, int n, vector<vector<int>>& edges) {\\n        int x, y;\\n        int min_c = 0;\\n        for(int i = 0;i < edges.size();i++) {\\n            int x=edges[i][1];\\n            int y=edges[i][2];\\n            if (edges[i][0] == type && root(x) != root(y)) {\\n                min_c++;\\n                union1(x, y);\\n            }\\n        }\\n        \\n        return min_c;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        N=n+1;\\n        initialize();\\n        int t3 = check_type(3, n, edges);\\n        auto p_temp = p;\\n        auto id_temp = id;\\n        int t1 = check_type(1, n, edges);\\n        p=p_temp;\\n        id=id_temp;\\n        int t2 = check_type(2, n, edges);\\n\\n        if (t3+t1 != n - 1 || t3+t2 != n - 1) {\\n            return -1;\\n        }\\n        \\n        return edges.size()-t3-t1-t2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<long long, pair<int, int>>> p;\\n    vector<int> id;\\n    int N;\\n\\n    void initialize() {\\n        id.resize(N);\\n        p.resize(N);\\n        for(int i = 0;i < N;++i)\\n            id[i] = i;\\n    }\\n\\n    int root(int x) {\\n        while(id[x] != x) {\\n            id[x] = id[id[x]];\\n            x = id[x];\\n        }\\n\\n        return x;\\n    }\\n\\n    void union1(int x, int y) {\\n        int p = root(x);\\n        int q = root(y);\\n        id[p] = id[q];\\n    }\\n\\n    int check_type(int type, int n, vector<vector<int>>& edges) {\\n        int x, y;\\n        int min_c = 0;\\n        for(int i = 0;i < edges.size();i++) {\\n            int x=edges[i][1];\\n            int y=edges[i][2];\\n            if (edges[i][0] == type && root(x) != root(y)) {\\n                min_c++;\\n                union1(x, y);\\n            }\\n        }\\n        \\n        return min_c;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        N=n+1;\\n        initialize();\\n        int t3 = check_type(3, n, edges);\\n        auto p_temp = p;\\n        auto id_temp = id;\\n        int t1 = check_type(1, n, edges);\\n        p=p_temp;\\n        id=id_temp;\\n        int t2 = check_type(2, n, edges);\\n\\n        if (t3+t1 != n - 1 || t3+t2 != n - 1) {\\n            return -1;\\n        }\\n        \\n        return edges.size()-t3-t1-t2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831469,
                "title": "java-union-find-compress-path-rank-once-check-type-3-edges-then-check-others",
                "content": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int[] componentsAlice=new int[n+1];\\n        int[] componentsBob=new int[n+1];\\n        // to make union find tree balance, avoid the worst case where the tree is a single linked list \\n        int[] sizeAlice=new int[n+1];\\n        int[] sizeBob=new int[n+1];\\n        int numsAlice=n,numsBob=n;\\n        int cycleAlice=0,cycleBob=0,commonCycle=0;\\n        // initialize union find related variables \\n        for(int i=1;i<=n;i++)\\n        {    \\n            componentsAlice[i]=i;\\n            componentsBob[i]=i;\\n            sizeAlice[i]=1;\\n            sizeBob[i]=1;\\n        }\\n        // this step is very important!!!. we need to firstly check edges that can be traversed by Alice and Bob. \\n        // we use common edges to connect all nodes, then we use type 1/2 to connect nodes for Alice/Bob. So all edges that cause cycles in union find can be removed. \\n        Arrays.sort(edges,(a,b)->(b[0]-a[0]));\\n        for(int[] edge:edges){\\n            if(edge[0]==3){\\n                boolean resAlice=union(edge[1],edge[2],componentsAlice,sizeAlice);\\n                boolean resBob=union(edge[1],edge[2],componentsBob,sizeBob);\\n                if(resAlice&&resBob) commonCycle++;\\n                else {\\n                    if(resAlice) cycleAlice++;\\n                    else numsAlice--;\\n                    if(resBob) cycleBob++;\\n                    else numsBob--;\\n                } \\n            } else if(edge[0]==2){\\n                if(union(edge[1],edge[2],componentsBob,sizeBob))\\n                    cycleBob++;\\n                else numsBob--;\\n            } else {\\n                if(union(edge[1],edge[2],componentsAlice,sizeAlice))\\n                    cycleAlice++;\\n                else numsAlice--;\\n            }\\n        }\\n        if(numsAlice>1||numsBob>1) return -1;\\n        return cycleAlice+cycleBob+commonCycle;\\n    }\\n    \\n    int findParent(int n,int[] components){\\n        while(components[n]!=n){\\n            // compress path\\n            n=components[components[n]];\\n        }\\n        return n;\\n    }\\n    \\n    boolean union(int a,int b,int[] components,int[] size){\\n        int parentA=findParent(a,components);\\n        int parentB=findParent(b,components);\\n        // node a is already connected with node b. so this edge is redundant. \\n        if(parentA==parentB) return true;\\n        // use size to determine which node can be parent \\n        if(size[parentA]>size[parentB]){\\n            components[parentB]=parentA;\\n            size[parentA]+=size[parentB];\\n        } else{\\n            components[parentA]=parentB;\\n            size[parentB]+=size[parentA];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int[] componentsAlice=new int[n+1];\\n        int[] componentsBob=new int[n+1];\\n        // to make union find tree balance, avoid the worst case where the tree is a single linked list \\n        int[] sizeAlice=new int[n+1];\\n        int[] sizeBob=new int[n+1];\\n        int numsAlice=n,numsBob=n;\\n        int cycleAlice=0,cycleBob=0,commonCycle=0;\\n        // initialize union find related variables \\n        for(int i=1;i<=n;i++)\\n        {    \\n            componentsAlice[i]=i;\\n            componentsBob[i]=i;\\n            sizeAlice[i]=1;\\n            sizeBob[i]=1;\\n        }\\n        // this step is very important!!!. we need to firstly check edges that can be traversed by Alice and Bob. \\n        // we use common edges to connect all nodes, then we use type 1/2 to connect nodes for Alice/Bob. So all edges that cause cycles in union find can be removed. \\n        Arrays.sort(edges,(a,b)->(b[0]-a[0]));\\n        for(int[] edge:edges){\\n            if(edge[0]==3){\\n                boolean resAlice=union(edge[1],edge[2],componentsAlice,sizeAlice);\\n                boolean resBob=union(edge[1],edge[2],componentsBob,sizeBob);\\n                if(resAlice&&resBob) commonCycle++;\\n                else {\\n                    if(resAlice) cycleAlice++;\\n                    else numsAlice--;\\n                    if(resBob) cycleBob++;\\n                    else numsBob--;\\n                } \\n            } else if(edge[0]==2){\\n                if(union(edge[1],edge[2],componentsBob,sizeBob))\\n                    cycleBob++;\\n                else numsBob--;\\n            } else {\\n                if(union(edge[1],edge[2],componentsAlice,sizeAlice))\\n                    cycleAlice++;\\n                else numsAlice--;\\n            }\\n        }\\n        if(numsAlice>1||numsBob>1) return -1;\\n        return cycleAlice+cycleBob+commonCycle;\\n    }\\n    \\n    int findParent(int n,int[] components){\\n        while(components[n]!=n){\\n            // compress path\\n            n=components[components[n]];\\n        }\\n        return n;\\n    }\\n    \\n    boolean union(int a,int b,int[] components,int[] size){\\n        int parentA=findParent(a,components);\\n        int parentB=findParent(b,components);\\n        // node a is already connected with node b. so this edge is redundant. \\n        if(parentA==parentB) return true;\\n        // use size to determine which node can be parent \\n        if(size[parentA]>size[parentB]){\\n            components[parentB]=parentA;\\n            size[parentA]+=size[parentB];\\n        } else{\\n            components[parentA]=parentB;\\n            size[parentB]+=size[parentA];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582125,
                "title": "simplest-python-uf-solution",
                "content": "\\n# Code\\n```\\nclass DSU():\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    \\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    \\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = self.par[self.par[vv]]\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.par[uu]:\\n            self.par[uu] = self.par[self.par[uu]]\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        uf1, uf2, ans = DSU(n), DSU(n), 0\\n\\n        for t, u, v in edges:\\n            if t == 3 and (not uf1.union(u-1, v-1) or not uf2.union(u-1, v-1)):\\n                ans += 1\\n        for t, u, v in edges:\\n            if t == 1 and not uf1.union(u-1, v-1):\\n                ans += 1\\n            elif t == 2 and not uf2.union(u-1, v-1):\\n                ans += 1\\n        return ans if uf1.size == n and uf2.size == n else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DSU():\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    \\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    \\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = self.par[self.par[vv]]\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.par[uu]:\\n            self.par[uu] = self.par[self.par[uu]]\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        uf1, uf2, ans = DSU(n), DSU(n), 0\\n\\n        for t, u, v in edges:\\n            if t == 3 and (not uf1.union(u-1, v-1) or not uf2.union(u-1, v-1)):\\n                ans += 1\\n        for t, u, v in edges:\\n            if t == 1 and not uf1.union(u-1, v-1):\\n                ans += 1\\n            elif t == 2 and not uf2.union(u-1, v-1):\\n                ans += 1\\n        return ans if uf1.size == n and uf2.size == n else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470626,
                "title": "php-javascript-beats-100-using-union-find-or-disjoint-set-data-structure",
                "content": "This approach uses UnionFind to determine the number of edges to remove in order to disconnect a graph with edges of type 1, 2, and 3. \\n\\nThe union-find data structure helps to keep track of connected components in the graph. \\n\\nThe algorithm first iterates over all the edges of type 3 and uses the union-find data structure to union all the nodes connected by these edges. \\nIt then iterates over the edges of type 1 and 2 for each one, it checks if the two nodes connected by this edge have been already connected (using union-find) or not. \\nIf they are not connected, then the edge is added (using union-find) and the number of edges to keep is incremented. \\n\\nFinally, the algorithm checks if the graph is connected *isConnected* and if it is, it return the number of edges that need to be removed *(edges.length - resNumberOfEdgesToKeep)*, else it returns -1.\\n\\n# Complexity\\n- Time complexity: $$O(m * log(n))$$ where *m* is the number of edges and *n* is the number of nodes. \\n- Space complexity: $$O(N)$$, where N is the number of vertices.\\n\\n# JavaScript\\n``` JavaScript\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar maxNumEdgesToRemove = function (n, edges) {\\n    let ufA = new UnionFind(n);\\n    let ufB = new UnionFind(n);\\n    let resNumberOfEdgesToKeep = 0;\\n    // Type 3\\n    for (let edge of edges) {\\n        if (edge[0] === 3) {\\n            resNumberOfEdgesToKeep += ufA.union(edge[1], edge[2]);\\n            ufB.union(edge[1], edge[2]);\\n        }\\n    }\\n    // Type 1 and 2\\n    for (let edge of edges) {\\n        if (edge[0] === 1) {\\n            resNumberOfEdgesToKeep += ufA.union(edge[1], edge[2]);\\n        } else if (edge[0] === 2) {\\n            resNumberOfEdgesToKeep += ufB.union(edge[1], edge[2]);\\n        }\\n    }\\n    return ufA.isConnected() && ufB.isConnected() ? edges.length - resNumberOfEdgesToKeep : -1;\\n};\\n\\nclass UnionFind {\\n    constructor(n) {\\n        this.parent = {};\\n        this.rank = {};\\n        this.count = n;\\n        for (let i = 0; i <= n; i++) {\\n            this.parent[i] = i;\\n            this.rank[i] = 1;\\n        }\\n    }\\n\\n    find(node) {\\n        while (node !== this.parent[node]) {\\n            this.parent[node] = this.parent[this.parent[node]];\\n            node = this.parent[node];\\n        }\\n        return node;\\n    }\\n\\n    union(u, v) {\\n        let rootU = this.find(u);\\n        let rootV = this.find(v);\\n        if (rootU === rootV) return 0;\\n        if (this.rank[rootU] > this.rank[rootV]) {\\n            this.parent[rootV] = rootU;\\n            this.rank[rootU] += this.rank[rootV];\\n        } else {\\n            this.parent[rootU] = rootV;\\n            this.rank[rootV] += this.rank[rootU];\\n        }\\n        this.count--;\\n        return 1;\\n    }\\n\\n    isConnected() {\\n        return this.count === 1;\\n    }\\n}\\n```\\n\\n# PHP\\n``` PHP\\nclass Solution\\n{\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $edges\\n     * @return Integer\\n     */\\n    function maxNumEdgesToRemove(int $n, array $edges): int {\\n        $ufA = new UnionFind($n);\\n        $ufB = new UnionFind($n);\\n        $resNumberOfEdgesToKeep = 0;\\n        // Type 3\\n        foreach ($edges as $edge) {\\n            if ($edge[0] == 3) {\\n                $resNumberOfEdgesToKeep += $ufA->union($edge[1], $edge[2]);\\n                $ufB->union($edge[1], $edge[2]);\\n            }\\n        }\\n        // Type 1 and 2\\n        foreach ($edges as $edge) {\\n            if ($edge[0] == 1) {\\n                $resNumberOfEdgesToKeep += $ufA->union($edge[1], $edge[2]);\\n            } else if ($edge[0] == 2) {\\n                $resNumberOfEdgesToKeep += $ufB->union($edge[1], $edge[2]);\\n            }\\n        }\\n        return $ufA->isConnected() && $ufB->isConnected() ? count($edges) - $resNumberOfEdgesToKeep : -1;\\n    }\\n}\\n\\nclass UnionFind\\n{\\n    private $parent = [];\\n    private $rank = [];\\n    private $count = 0;\\n\\n    function __construct(int $n) {\\n        $this->count = $n;\\n        for ($i = 0; $i <= $n; $i++) {\\n            $this->parent[$i] = $i;\\n            $this->rank[$i] = 1;\\n        }\\n    }\\n\\n    function find(int $node): int {\\n        while ($node != $this->parent[$node]) {\\n            $this->parent[$node] = $this->parent[$this->parent[$node]];\\n            $node = $this->parent[$node];\\n        }\\n        return $node;\\n    }\\n\\n    function union(int $u, int $v): int {\\n        $rootU = $this->find($u);\\n        $rootV = $this->find($v);\\n        if ($rootU == $rootV) return 0;\\n        if ($this->rank[$rootU] > $this->rank[$rootV]) {\\n            $this->parent[$rootV] = $rootU;\\n            $this->rank[$rootU] += $this->rank[$rootV];\\n        } else {\\n            $this->parent[$rootU] = $rootV;\\n            $this->rank[$rootV] += $this->rank[$rootU];\\n        }\\n        $this->count--;\\n        return 1;\\n    }\\n\\n    function isConnected(): bool {\\n        return $this->count == 1;\\n    }\\n}\\n```\\n\\n\\n##### Thanks for reading! If you have any questions or suggestions, please leave a comment below. I would love to hear your thoughts! \\uD83D\\uDE0A\\n### **Please upvote if you found this post helpful! \\uD83D\\uDC4D**",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "Union Find",
                    "Graph"
                ],
                "code": "``` JavaScript\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar maxNumEdgesToRemove = function (n, edges) {\\n    let ufA = new UnionFind(n);\\n    let ufB = new UnionFind(n);\\n    let resNumberOfEdgesToKeep = 0;\\n    // Type 3\\n    for (let edge of edges) {\\n        if (edge[0] === 3) {\\n            resNumberOfEdgesToKeep += ufA.union(edge[1], edge[2]);\\n            ufB.union(edge[1], edge[2]);\\n        }\\n    }\\n    // Type 1 and 2\\n    for (let edge of edges) {\\n        if (edge[0] === 1) {\\n            resNumberOfEdgesToKeep += ufA.union(edge[1], edge[2]);\\n        } else if (edge[0] === 2) {\\n            resNumberOfEdgesToKeep += ufB.union(edge[1], edge[2]);\\n        }\\n    }\\n    return ufA.isConnected() && ufB.isConnected() ? edges.length - resNumberOfEdgesToKeep : -1;\\n};\\n\\nclass UnionFind {\\n    constructor(n) {\\n        this.parent = {};\\n        this.rank = {};\\n        this.count = n;\\n        for (let i = 0; i <= n; i++) {\\n            this.parent[i] = i;\\n            this.rank[i] = 1;\\n        }\\n    }\\n\\n    find(node) {\\n        while (node !== this.parent[node]) {\\n            this.parent[node] = this.parent[this.parent[node]];\\n            node = this.parent[node];\\n        }\\n        return node;\\n    }\\n\\n    union(u, v) {\\n        let rootU = this.find(u);\\n        let rootV = this.find(v);\\n        if (rootU === rootV) return 0;\\n        if (this.rank[rootU] > this.rank[rootV]) {\\n            this.parent[rootV] = rootU;\\n            this.rank[rootU] += this.rank[rootV];\\n        } else {\\n            this.parent[rootU] = rootV;\\n            this.rank[rootV] += this.rank[rootU];\\n        }\\n        this.count--;\\n        return 1;\\n    }\\n\\n    isConnected() {\\n        return this.count === 1;\\n    }\\n}\\n```\n``` PHP\\nclass Solution\\n{\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $edges\\n     * @return Integer\\n     */\\n    function maxNumEdgesToRemove(int $n, array $edges): int {\\n        $ufA = new UnionFind($n);\\n        $ufB = new UnionFind($n);\\n        $resNumberOfEdgesToKeep = 0;\\n        // Type 3\\n        foreach ($edges as $edge) {\\n            if ($edge[0] == 3) {\\n                $resNumberOfEdgesToKeep += $ufA->union($edge[1], $edge[2]);\\n                $ufB->union($edge[1], $edge[2]);\\n            }\\n        }\\n        // Type 1 and 2\\n        foreach ($edges as $edge) {\\n            if ($edge[0] == 1) {\\n                $resNumberOfEdgesToKeep += $ufA->union($edge[1], $edge[2]);\\n            } else if ($edge[0] == 2) {\\n                $resNumberOfEdgesToKeep += $ufB->union($edge[1], $edge[2]);\\n            }\\n        }\\n        return $ufA->isConnected() && $ufB->isConnected() ? count($edges) - $resNumberOfEdgesToKeep : -1;\\n    }\\n}\\n\\nclass UnionFind\\n{\\n    private $parent = [];\\n    private $rank = [];\\n    private $count = 0;\\n\\n    function __construct(int $n) {\\n        $this->count = $n;\\n        for ($i = 0; $i <= $n; $i++) {\\n            $this->parent[$i] = $i;\\n            $this->rank[$i] = 1;\\n        }\\n    }\\n\\n    function find(int $node): int {\\n        while ($node != $this->parent[$node]) {\\n            $this->parent[$node] = $this->parent[$this->parent[$node]];\\n            $node = $this->parent[$node];\\n        }\\n        return $node;\\n    }\\n\\n    function union(int $u, int $v): int {\\n        $rootU = $this->find($u);\\n        $rootV = $this->find($v);\\n        if ($rootU == $rootV) return 0;\\n        if ($this->rank[$rootU] > $this->rank[$rootV]) {\\n            $this->parent[$rootV] = $rootU;\\n            $this->rank[$rootU] += $this->rank[$rootV];\\n        } else {\\n            $this->parent[$rootU] = $rootV;\\n            $this->rank[$rootV] += $this->rank[$rootU];\\n        }\\n        $this->count--;\\n        return 1;\\n    }\\n\\n    function isConnected(): bool {\\n        return $this->count == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469787,
                "title": "python-3-dsu-union-by-rank-path-compression",
                "content": "# Intuition\\nAs long as you know DSU, this question is quite straghtforward.\\n\\nProcess edges in 2 parts:\\n- Join all type 3 edges and then type 1 edges. This denotes all Alice edges. And edges with the same parent can be removed.\\n- Same process will be done by using type 2 edges instead of type 1.\\n\\nCheck if all nodes belong to the same parent finally to see if any nodes cannot be reached.\\n\\n# Approach\\nDSU\\n\\n# Complexity\\n- Time complexity:\\nO(n * alpha(n)) -> DSU operation on input edges list\\n\\n- Space complexity:\\nO(n) -> DSU structure\\'s sc\\n\\n# Code\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n    \\n    def find(self, node):\\n        if self.par[node] != node:\\n            self.par[node] = self.find(self.par[node])\\n        return self.par[node]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if self.rank[px] > self.rank[py]: # py to px\\n            self.par[py] = px\\n            self.rank[px] += self.rank[py]\\n        else: # px to py\\n            self.par[px] = py\\n            self.rank[py] += self.rank[px]\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        import collections\\n        type2edge = collections.defaultdict(list)\\n        for ty, u, v in edges:\\n            type2edge[ty].append([u, v])\\n        \\n        ans = 0\\n\\n        # alice\\n        dsua = DSU(n+1)\\n        for u, v in type2edge[3]: # join common\\n            if dsua.find(u) == dsua.find(v):\\n                ans += 1\\n            else:\\n                dsua.union(u, v)\\n        for u, v in type2edge[1]:\\n            if dsua.find(u) == dsua.find(v):\\n                ans += 1\\n            else:\\n                dsua.union(u, v)\\n        \\n        for i in range(n):\\n            dsua.find(i)\\n        if len(set(dsua.par[1:])) > 1: # diff groups\\n            return -1\\n        \\n        # bob\\n        dsub = DSU(n+1)\\n        for u, v in type2edge[3]:\\n            if dsub.find(u) != dsub.find(v):\\n                dsub.union(u, v)\\n        for u, v in type2edge[2]:\\n            if dsub.find(u) == dsub.find(v):\\n                ans += 1\\n            else:\\n                dsub.union(u, v)\\n        \\n        for i in range(n):\\n            dsub.find(i)\\n        if len(set(dsub.par[1:])) > 1:\\n            return -1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n    \\n    def find(self, node):\\n        if self.par[node] != node:\\n            self.par[node] = self.find(self.par[node])\\n        return self.par[node]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if self.rank[px] > self.rank[py]: # py to px\\n            self.par[py] = px\\n            self.rank[px] += self.rank[py]\\n        else: # px to py\\n            self.par[px] = py\\n            self.rank[py] += self.rank[px]\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        import collections\\n        type2edge = collections.defaultdict(list)\\n        for ty, u, v in edges:\\n            type2edge[ty].append([u, v])\\n        \\n        ans = 0\\n\\n        # alice\\n        dsua = DSU(n+1)\\n        for u, v in type2edge[3]: # join common\\n            if dsua.find(u) == dsua.find(v):\\n                ans += 1\\n            else:\\n                dsua.union(u, v)\\n        for u, v in type2edge[1]:\\n            if dsua.find(u) == dsua.find(v):\\n                ans += 1\\n            else:\\n                dsua.union(u, v)\\n        \\n        for i in range(n):\\n            dsua.find(i)\\n        if len(set(dsua.par[1:])) > 1: # diff groups\\n            return -1\\n        \\n        # bob\\n        dsub = DSU(n+1)\\n        for u, v in type2edge[3]:\\n            if dsub.find(u) != dsub.find(v):\\n                dsub.union(u, v)\\n        for u, v in type2edge[2]:\\n            if dsub.find(u) == dsub.find(v):\\n                ans += 1\\n            else:\\n                dsub.union(u, v)\\n        \\n        for i in range(n):\\n            dsub.find(i)\\n        if len(set(dsub.par[1:])) > 1:\\n            return -1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469568,
                "title": "union-find-c",
                "content": "```\\nclass Solution {\\n    int find_prnt(int node, vector<int> &prnt) {\\n        if(node == prnt[node]) return node;\\n        return prnt[node] = find_prnt(prnt[node], prnt);\\n    }\\n    void unionn(int u, int v, vector<int> &prnt, vector<int> &rank) {\\n        int ulp_u = find_prnt(u, prnt), ulp_v = find_prnt(v, prnt);\\n\\n        if(rank[ulp_u] > rank[ulp_v]) prnt[ulp_v] = ulp_u; \\n        else if(rank[ulp_u] < rank[ulp_v]) prnt[ulp_u] = ulp_v;\\n        else {\\n            prnt[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n    int solve(vector<pair<int, int>> &edges, vector<int> &prnt, vector<int> &rank) {\\n        int ans = 0;\\n        for(auto e : edges) {\\n            if(find_prnt(e.first, prnt) != find_prnt(e.second, prnt)) {\\n                unionn(e.first, e.second, prnt, rank);\\n            }\\n            else ans++;\\n        }\\n        int p = find_prnt(1, prnt);\\n        for(int i=1; i<prnt.size(); i++) {\\n            if(find_prnt(i, prnt) != p) return -1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> prnt1(n + 1), rank1(n + 1);\\n        vector<int> prnt2(n + 1), rank2(n + 1);\\n        for(int i=1; i<=n; i++) prnt1[i] = i, prnt2[i] = i;\\n\\n        vector<pair<int, int>> alice, bob;\\n        int cntAlice = 0, cntBob = 0, ans = 0;\\n\\n        for(auto e : edges) {\\n            if(e[0] == 3) {\\n                if(find_prnt(e[1], prnt1) != find_prnt(e[2], prnt1)) {\\n                    unionn(e[1], e[2], prnt1, rank1);\\n                }\\n                else ans++;\\n\\n                if(find_prnt(e[1], prnt2) != find_prnt(e[2], prnt2)) {\\n                    unionn(e[1], e[2], prnt2, rank2);\\n                }\\n            }\\n            else if(e[0] == 2) bob.push_back({e[1], e[2]});\\n            else alice.push_back({e[1], e[2]});\\n        }\\n\\n        int a = solve(alice, prnt1, rank1), b = solve(bob, prnt2, rank2);\\n        if(a == -1 || b == -1) return -1;\\n        return a + b + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int find_prnt(int node, vector<int> &prnt) {\\n        if(node == prnt[node]) return node;\\n        return prnt[node] = find_prnt(prnt[node], prnt);\\n    }\\n    void unionn(int u, int v, vector<int> &prnt, vector<int> &rank) {\\n        int ulp_u = find_prnt(u, prnt), ulp_v = find_prnt(v, prnt);\\n\\n        if(rank[ulp_u] > rank[ulp_v]) prnt[ulp_v] = ulp_u; \\n        else if(rank[ulp_u] < rank[ulp_v]) prnt[ulp_u] = ulp_v;\\n        else {\\n            prnt[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n    int solve(vector<pair<int, int>> &edges, vector<int> &prnt, vector<int> &rank) {\\n        int ans = 0;\\n        for(auto e : edges) {\\n            if(find_prnt(e.first, prnt) != find_prnt(e.second, prnt)) {\\n                unionn(e.first, e.second, prnt, rank);\\n            }\\n            else ans++;\\n        }\\n        int p = find_prnt(1, prnt);\\n        for(int i=1; i<prnt.size(); i++) {\\n            if(find_prnt(i, prnt) != p) return -1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> prnt1(n + 1), rank1(n + 1);\\n        vector<int> prnt2(n + 1), rank2(n + 1);\\n        for(int i=1; i<=n; i++) prnt1[i] = i, prnt2[i] = i;\\n\\n        vector<pair<int, int>> alice, bob;\\n        int cntAlice = 0, cntBob = 0, ans = 0;\\n\\n        for(auto e : edges) {\\n            if(e[0] == 3) {\\n                if(find_prnt(e[1], prnt1) != find_prnt(e[2], prnt1)) {\\n                    unionn(e[1], e[2], prnt1, rank1);\\n                }\\n                else ans++;\\n\\n                if(find_prnt(e[1], prnt2) != find_prnt(e[2], prnt2)) {\\n                    unionn(e[1], e[2], prnt2, rank2);\\n                }\\n            }\\n            else if(e[0] == 2) bob.push_back({e[1], e[2]});\\n            else alice.push_back({e[1], e[2]});\\n        }\\n\\n        int a = solve(alice, prnt1, rank1), b = solve(bob, prnt2, rank2);\\n        if(a == -1 || b == -1) return -1;\\n        return a + b + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468453,
                "title": "best-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- The time complexity of this approach is O(E), where E is the number of edges, as we are using path compression and union by rank so the find and union function become O(1) on average.\\n\\n- Space complexity:\\nThe space complexity is also O(N), where N is the number of nodes\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i,vector<int> &par){\\n        if(par[i] == -1){\\n            return i;\\n        }\\n        return par[i] = find(par[i],par);\\n        //path compression.\\n    }\\n    bool union_set(int x,int y,vector<int> &par,vector<int> &rnk){\\n        int s1 = find(x,par);\\n        int s2 = find(y,par);\\n        \\n        if(s1 != s2){\\n            //union by rank.\\n            if(rnk[s1] > rnk[s2]){\\n                par[s2] = s1;\\n                rnk[s1] += rnk[s2];\\n            }\\n            else{\\n                par[s1] = s2;\\n                rnk[s2] += rnk[s1];\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n        sort(edges.begin(),edges.end(),[](vector<int> &a,vector<int> &b){\\n            return a[0] > b[0]; \\n        });\\n        // To process the edges of type 3 first we sort the edges vector.\\n        \\n        int rem = 0;\\n        \\n        vector<int> parAlice(n,-1);\\n        vector<int> parBob(n,-1);\\n        vector<int> rnkAlice(n,1);\\n        vector<int> rnkBob(n,1);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0] == 3){\\n                bool fg1 = union_set(edges[i][1]-1,edges[i][2]-1,parAlice,rnkAlice);\\n                bool fg2 = union_set(edges[i][1]-1,edges[i][2]-1,parBob,rnkBob);\\n                if(fg1==false && fg2==false){\\n                    //alice and bob are both connected to node x and node y so remove this edge.\\n                    rem += 1;\\n                }\\n            }\\n            else if(edges[i][0] == 2){\\n                bool fg2 = union_set(edges[i][1]-1,edges[i][2]-1,parBob,rnkBob);\\n                if(fg2 == false){\\n                    //bob is connected to node x and node y so remove this edge.\\n                    rem += 1;\\n                }\\n            }\\n            else{\\n                bool fg1 = union_set(edges[i][1]-1,edges[i][2]-1,parAlice,rnkAlice);\\n                if(fg1 == false){\\n                    //alice is connected to node x and node y so remove this edge.\\n                    rem += 1;\\n                }\\n            }\\n        }\\n        \\n        int co1=0,co2=0;\\n        for(int i=0;i<n;i++){\\n            if(parAlice[i]==-1){co1++;}\\n            if(parBob[i]==-1){co2++;}\\n            //if the nodes can be connected then there will be only one parent in the parent array.\\n        }\\n        if(co1==1 && co2==1){return rem;}\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i,vector<int> &par){\\n        if(par[i] == -1){\\n            return i;\\n        }\\n        return par[i] = find(par[i],par);\\n        //path compression.\\n    }\\n    bool union_set(int x,int y,vector<int> &par,vector<int> &rnk){\\n        int s1 = find(x,par);\\n        int s2 = find(y,par);\\n        \\n        if(s1 != s2){\\n            //union by rank.\\n            if(rnk[s1] > rnk[s2]){\\n                par[s2] = s1;\\n                rnk[s1] += rnk[s2];\\n            }\\n            else{\\n                par[s1] = s2;\\n                rnk[s2] += rnk[s1];\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n        sort(edges.begin(),edges.end(),[](vector<int> &a,vector<int> &b){\\n            return a[0] > b[0]; \\n        });\\n        // To process the edges of type 3 first we sort the edges vector.\\n        \\n        int rem = 0;\\n        \\n        vector<int> parAlice(n,-1);\\n        vector<int> parBob(n,-1);\\n        vector<int> rnkAlice(n,1);\\n        vector<int> rnkBob(n,1);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0] == 3){\\n                bool fg1 = union_set(edges[i][1]-1,edges[i][2]-1,parAlice,rnkAlice);\\n                bool fg2 = union_set(edges[i][1]-1,edges[i][2]-1,parBob,rnkBob);\\n                if(fg1==false && fg2==false){\\n                    //alice and bob are both connected to node x and node y so remove this edge.\\n                    rem += 1;\\n                }\\n            }\\n            else if(edges[i][0] == 2){\\n                bool fg2 = union_set(edges[i][1]-1,edges[i][2]-1,parBob,rnkBob);\\n                if(fg2 == false){\\n                    //bob is connected to node x and node y so remove this edge.\\n                    rem += 1;\\n                }\\n            }\\n            else{\\n                bool fg1 = union_set(edges[i][1]-1,edges[i][2]-1,parAlice,rnkAlice);\\n                if(fg1 == false){\\n                    //alice is connected to node x and node y so remove this edge.\\n                    rem += 1;\\n                }\\n            }\\n        }\\n        \\n        int co1=0,co2=0;\\n        for(int i=0;i<n;i++){\\n            if(parAlice[i]==-1){co1++;}\\n            if(parBob[i]==-1){co2++;}\\n            //if the nodes can be connected then there will be only one parent in the parent array.\\n        }\\n        if(co1==1 && co2==1){return rem;}\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468072,
                "title": "swift-union-find-smallest-fastest-solution",
                "content": "**Union Find (accepted answer)**\\n```\\nclass Solution {\\n    func maxNumEdgesToRemove(_ n: Int, _ edges: [[Int]]) -> Int {\\n        var groups = [Array(0...n), Array(0...n)] // [0] = alice, [1] = bob\\n        var connectedCounts = [0,0], edgesNeeded = 0\\n\\n        func find(_ x: Int, _ group: inout [Int]) -> Int {\\n            if x != group[x] { group[x] = find(group[x], &group) }\\n            return group[x]\\n        }\\n\\n        func tryUnion(_ i:Int, _ j:Int, _ g:Int) -> Bool {\\n            let (x,y) = (find(i, &groups[g]), find(j, &groups[g]))\\n            groups[g][x] = y\\n            connectedCounts[g] += x != y ? 1 : 0\\n            return x != y\\n        }\\n\\n        let ALICE = 1, BOB = 2, ALICE_OR_BOB = 3\\n\\n        for e in edges where e[0] == ALICE_OR_BOB && tryUnion(e[1], e[2], 0) && tryUnion(e[1], e[2], 1) {\\n            edgesNeeded += 1  // Connect edges that both can use\\n        }\\n\\n        for e in edges where (e[0] == ALICE && tryUnion(e[1], e[2], 0)) || (e[0] == BOB && tryUnion(e[1], e[2], 1)) {\\n            edgesNeeded += 1  // Connect edges that are not already joined for both\\n        }\\n        \\n        return connectedCounts.allSatisfy { $0 == n-1 } ? edges.count - edgesNeeded : -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxNumEdgesToRemove(_ n: Int, _ edges: [[Int]]) -> Int {\\n        var groups = [Array(0...n), Array(0...n)] // [0] = alice, [1] = bob\\n        var connectedCounts = [0,0], edgesNeeded = 0\\n\\n        func find(_ x: Int, _ group: inout [Int]) -> Int {\\n            if x != group[x] { group[x] = find(group[x], &group) }\\n            return group[x]\\n        }\\n\\n        func tryUnion(_ i:Int, _ j:Int, _ g:Int) -> Bool {\\n            let (x,y) = (find(i, &groups[g]), find(j, &groups[g]))\\n            groups[g][x] = y\\n            connectedCounts[g] += x != y ? 1 : 0\\n            return x != y\\n        }\\n\\n        let ALICE = 1, BOB = 2, ALICE_OR_BOB = 3\\n\\n        for e in edges where e[0] == ALICE_OR_BOB && tryUnion(e[1], e[2], 0) && tryUnion(e[1], e[2], 1) {\\n            edgesNeeded += 1  // Connect edges that both can use\\n        }\\n\\n        for e in edges where (e[0] == ALICE && tryUnion(e[1], e[2], 0)) || (e[0] == BOB && tryUnion(e[1], e[2], 1)) {\\n            edgesNeeded += 1  // Connect edges that are not already joined for both\\n        }\\n        \\n        return connectedCounts.allSatisfy { $0 == n-1 } ? edges.count - edgesNeeded : -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467996,
                "title": "python3-solution",
                "content": "\\n\\n```\\nclass Solution:\\n\\n    def dfs(self,vis,li,com,i):\\n        if(vis[i]):\\n            return 0\\n        vis[i]=com\\n        ans=1\\n        for j in li[i]:\\n            ans+=self.dfs(vis,li,com,j)\\n        return ans\\n\\n    def maxNumEdgesToRemove(self, n: int, e: List[List[int]]) -> int:\\n        ans=0\\n        li=[[] for i in range(n)]\\n        for l in e:\\n            if(l[0]==3):\\n                li[l[1]-1].append(l[2]-1)\\n                li[l[2]-1].append(l[1]-1)\\n        vis=[0 for i in range(n)]\\n        com=0\\n        for i in range(n):\\n            if(vis[i]):\\n                continue\\n            else:\\n                com+=1\\n                temp=self.dfs(vis,li,com,i)\\n                ans+=(temp-1)\\n        lia=[[] for i in range(com)]\\n        lib=[[] for i in range(com)]\\n        for l in e:\\n            if(l[0]==1):\\n                a=vis[l[1]-1]-1\\n                b=vis[l[2]-1]-1\\n                if(a==b):\\n                    continue\\n                lia[a].append(b)\\n                lia[b].append(a)\\n            elif(l[0]==2):\\n                a=vis[l[1]-1]-1\\n                b=vis[l[2]-1]-1\\n                if(a==b):\\n                    continue\\n                lib[a].append(b)\\n                lib[b].append(a)\\n        visa=[0 for i in range(com)]\\n        coma=0\\n        comb=0\\n        for i in range(com):\\n            if(visa[i]):\\n                continue\\n            else:\\n                coma+=1\\n                if(coma>1):\\n                    return -1\\n                self.dfs(visa,lia,coma,i)\\n        \\n        visb=[0 for i in range(com)]\\n        for i in range(com):\\n            if(visb[i]):\\n                continue\\n            else:\\n                comb+=1\\n                if(comb>1):\\n                    return -1\\n                self.dfs(visb,lib,comb,i)\\n        if(coma>1 or comb>1):\\n            return -1\\n        ans+=(com-1)*2\\n        return len(e)-ans\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def dfs(self,vis,li,com,i):\\n        if(vis[i]):\\n            return 0\\n        vis[i]=com\\n        ans=1\\n        for j in li[i]:\\n            ans+=self.dfs(vis,li,com,j)\\n        return ans\\n\\n    def maxNumEdgesToRemove(self, n: int, e: List[List[int]]) -> int:\\n        ans=0\\n        li=[[] for i in range(n)]\\n        for l in e:\\n            if(l[0]==3):\\n                li[l[1]-1].append(l[2]-1)\\n                li[l[2]-1].append(l[1]-1)\\n        vis=[0 for i in range(n)]\\n        com=0\\n        for i in range(n):\\n            if(vis[i]):\\n                continue\\n            else:\\n                com+=1\\n                temp=self.dfs(vis,li,com,i)\\n                ans+=(temp-1)\\n        lia=[[] for i in range(com)]\\n        lib=[[] for i in range(com)]\\n        for l in e:\\n            if(l[0]==1):\\n                a=vis[l[1]-1]-1\\n                b=vis[l[2]-1]-1\\n                if(a==b):\\n                    continue\\n                lia[a].append(b)\\n                lia[b].append(a)\\n            elif(l[0]==2):\\n                a=vis[l[1]-1]-1\\n                b=vis[l[2]-1]-1\\n                if(a==b):\\n                    continue\\n                lib[a].append(b)\\n                lib[b].append(a)\\n        visa=[0 for i in range(com)]\\n        coma=0\\n        comb=0\\n        for i in range(com):\\n            if(visa[i]):\\n                continue\\n            else:\\n                coma+=1\\n                if(coma>1):\\n                    return -1\\n                self.dfs(visa,lia,coma,i)\\n        \\n        visb=[0 for i in range(com)]\\n        for i in range(com):\\n            if(visb[i]):\\n                continue\\n            else:\\n                comb+=1\\n                if(comb>1):\\n                    return -1\\n                self.dfs(visb,lib,comb,i)\\n        if(coma>1 or comb>1):\\n            return -1\\n        ans+=(com-1)*2\\n        return len(e)-ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588804,
                "title": "golang-go-easy-to-follow-union-find-solution",
                "content": "```\\n\\n\\nfunc maxNumEdgesToRemove(n int, edges [][]int) int {\\n\\n\\tvar result int\\n\\n\\tufAlice := NewUnionFind(n)\\n\\tufBob := NewUnionFind(n)\\n\\n\\tfor _, edge := range edges {\\n\\t\\t// When edge is 3, both Alice and Bob can use it\\n\\t\\t// So we need to union both ufAlice and ufBob\\n\\t\\t// If the union fails, it means that the two nodes are already connected\\n\\t\\tif edge[0] == 3 {\\n\\t\\t\\tif !ufAlice.Union(edge[1]-1, edge[2]-1) {\\n\\t\\t\\t\\t// Counting only once sice Alice and Bob are using the same edges\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t\\tufBob.Union(edge[1]-1, edge[2]-1)\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, edge := range edges {\\n\\n\\t\\t// When edge is 1, only Alice can use it\\n\\t\\tif edge[0] == 1 {\\n\\t\\t\\tif !ufAlice.Union(edge[1]-1, edge[2]-1) {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// When edge is 2, only Bob can use it\\n\\t\\tif edge[0] == 2 {\\n\\t\\t\\tif !ufBob.Union(edge[1]-1, edge[2]-1) {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(\"Count:\", ufAlice.count, ufBob.count)\\n\\n\\tif ufAlice.count != 1 || ufBob.count != 1 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn result\\n\\n}\\n\\n// Union Find Data Structure Implementation\\ntype UnionFind struct {\\n\\tparent []int\\n\\tcount  int\\n}\\n\\nfunc NewUnionFind(num int) *UnionFind {\\n\\tarr := make([]int, num)\\n\\tfor i := 0; i < num; i++ {\\n\\t\\tarr[i] = i\\n\\t}\\n\\treturn &UnionFind{\\n\\t\\tarr,\\n\\t\\tnum,\\n\\t}\\n}\\n\\nfunc (u *UnionFind) Union(a, b int) bool {\\n\\n\\tparentA := u.Find(a)\\n\\tparentB := u.Find(b)\\n\\tif parentA != parentB {\\n\\t\\tu.parent[parentA] = parentB\\n\\t\\tu.count--\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n\\n}\\n\\nfunc (u *UnionFind) Find(a int) int {\\n\\n\\tif u.parent[a] == a {\\n\\t\\treturn a\\n\\t}\\n\\tu.parent[a] = u.Find(u.parent[a])\\n\\treturn u.parent[a]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```\\n\\n\\nfunc maxNumEdgesToRemove(n int, edges [][]int) int {\\n\\n\\tvar result int\\n\\n\\tufAlice := NewUnionFind(n)\\n\\tufBob := NewUnionFind(n)\\n\\n\\tfor _, edge := range edges {\\n\\t\\t// When edge is 3, both Alice and Bob can use it\\n\\t\\t// So we need to union both ufAlice and ufBob\\n\\t\\t// If the union fails, it means that the two nodes are already connected\\n\\t\\tif edge[0] == 3 {\\n\\t\\t\\tif !ufAlice.Union(edge[1]-1, edge[2]-1) {\\n\\t\\t\\t\\t// Counting only once sice Alice and Bob are using the same edges\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t\\tufBob.Union(edge[1]-1, edge[2]-1)\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, edge := range edges {\\n\\n\\t\\t// When edge is 1, only Alice can use it\\n\\t\\tif edge[0] == 1 {\\n\\t\\t\\tif !ufAlice.Union(edge[1]-1, edge[2]-1) {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// When edge is 2, only Bob can use it\\n\\t\\tif edge[0] == 2 {\\n\\t\\t\\tif !ufBob.Union(edge[1]-1, edge[2]-1) {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(\"Count:\", ufAlice.count, ufBob.count)\\n\\n\\tif ufAlice.count != 1 || ufBob.count != 1 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn result\\n\\n}\\n\\n// Union Find Data Structure Implementation\\ntype UnionFind struct {\\n\\tparent []int\\n\\tcount  int\\n}\\n\\nfunc NewUnionFind(num int) *UnionFind {\\n\\tarr := make([]int, num)\\n\\tfor i := 0; i < num; i++ {\\n\\t\\tarr[i] = i\\n\\t}\\n\\treturn &UnionFind{\\n\\t\\tarr,\\n\\t\\tnum,\\n\\t}\\n}\\n\\nfunc (u *UnionFind) Union(a, b int) bool {\\n\\n\\tparentA := u.Find(a)\\n\\tparentB := u.Find(b)\\n\\tif parentA != parentB {\\n\\t\\tu.parent[parentA] = parentB\\n\\t\\tu.count--\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n\\n}\\n\\nfunc (u *UnionFind) Find(a int) int {\\n\\n\\tif u.parent[a] == a {\\n\\t\\treturn a\\n\\t}\\n\\tu.parent[a] = u.Find(u.parent[a])\\n\\treturn u.parent[a]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459804,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    vector<int> alice, bob;\\n    static bool comp(vector<int> &a, vector<int> &b)\\n    {\\n        return a[0] > b[0];\\n    }\\n    int find_alice(int v)\\n    {\\n        if(v == alice[v])\\n            return v;\\n        return alice[v] = find_alice(alice[v]);\\n    }\\n    int find_bob(int v)\\n    {\\n        if(v == bob[v])\\n            return v;\\n        return bob[v] = find_bob(bob[v]);\\n    }\\n    void union_alice(int a, int b)\\n    {\\n        a = find_alice(a);\\n        b = find_alice(b);\\n        if(a == b)\\n            return;\\n        alice[b] = a;\\n        return;\\n    }\\n    void union_bob(int a, int b)\\n    {\\n        a = find_bob(a);\\n        b = find_bob(b);\\n        if(a == b)\\n            return;\\n        bob[b] = a;\\n        return;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), comp);\\n        for(int i = 0; i <= n; i++)\\n        {\\n            alice.push_back(i);\\n            bob.push_back(i);\\n        }\\n        int ans = 0;\\n        for(vector<int> &v : edges)\\n        {\\n            if(v[0] == 3)\\n            {\\n                int xa = find_alice(v[1]);\\n                int ya = find_alice(v[2]);\\n                int xb = find_bob(v[1]);\\n                int yb = find_bob(v[2]);\\n                if(xa == ya && xb == yb)\\n                {\\n                    ans++;\\n                }\\n                else\\n                {\\n                    if(xa != ya)\\n                        union_alice(xa, ya);\\n                    if(xb != yb)\\n                        union_bob(xb, yb);\\n                }\\n            }\\n            else if(v[0] == 2)\\n            {\\n                int xb = find_bob(v[1]);\\n                int yb = find_bob(v[2]);\\n                if(xb == yb)\\n                    ans++;\\n                else\\n                {\\n                    union_bob(xb, yb);\\n                }\\n            }\\n            else\\n            {\\n                int xa = find_alice(v[1]);\\n                int ya = find_alice(v[2]);\\n                if(xa == ya)\\n                    ans++;\\n                else\\n                    union_alice(xa, ya);\\n            }\\n        }\\n        int vala, valb;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(i == 1)\\n            {\\n                vala = find_alice(i);\\n                valb = find_bob(i);\\n            }\\n            else\\n            {\\n                if(vala != find_alice(i))\\n                {\\n                    return -1;\\n                }\\n                if(valb != find_bob(i))\\n                {\\n                    return -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> alice, bob;\\n    static bool comp(vector<int> &a, vector<int> &b)\\n    {\\n        return a[0] > b[0];\\n    }\\n    int find_alice(int v)\\n    {\\n        if(v == alice[v])\\n            return v;\\n        return alice[v] = find_alice(alice[v]);\\n    }\\n    int find_bob(int v)\\n    {\\n        if(v == bob[v])\\n            return v;\\n        return bob[v] = find_bob(bob[v]);\\n    }\\n    void union_alice(int a, int b)\\n    {\\n        a = find_alice(a);\\n        b = find_alice(b);\\n        if(a == b)\\n            return;\\n        alice[b] = a;\\n        return;\\n    }\\n    void union_bob(int a, int b)\\n    {\\n        a = find_bob(a);\\n        b = find_bob(b);\\n        if(a == b)\\n            return;\\n        bob[b] = a;\\n        return;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), comp);\\n        for(int i = 0; i <= n; i++)\\n        {\\n            alice.push_back(i);\\n            bob.push_back(i);\\n        }\\n        int ans = 0;\\n        for(vector<int> &v : edges)\\n        {\\n            if(v[0] == 3)\\n            {\\n                int xa = find_alice(v[1]);\\n                int ya = find_alice(v[2]);\\n                int xb = find_bob(v[1]);\\n                int yb = find_bob(v[2]);\\n                if(xa == ya && xb == yb)\\n                {\\n                    ans++;\\n                }\\n                else\\n                {\\n                    if(xa != ya)\\n                        union_alice(xa, ya);\\n                    if(xb != yb)\\n                        union_bob(xb, yb);\\n                }\\n            }\\n            else if(v[0] == 2)\\n            {\\n                int xb = find_bob(v[1]);\\n                int yb = find_bob(v[2]);\\n                if(xb == yb)\\n                    ans++;\\n                else\\n                {\\n                    union_bob(xb, yb);\\n                }\\n            }\\n            else\\n            {\\n                int xa = find_alice(v[1]);\\n                int ya = find_alice(v[2]);\\n                if(xa == ya)\\n                    ans++;\\n                else\\n                    union_alice(xa, ya);\\n            }\\n        }\\n        int vala, valb;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(i == 1)\\n            {\\n                vala = find_alice(i);\\n                valb = find_bob(i);\\n            }\\n            else\\n            {\\n                if(vala != find_alice(i))\\n                {\\n                    return -1;\\n                }\\n                if(valb != find_bob(i))\\n                {\\n                    return -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434801,
                "title": "python-union-find-solution",
                "content": "As mentioned in many other solutions, the main idea is that we want to construct the graph from given edges rather than removing edges. \\nYou need to argue and make yourself belive that it is always optimal to take blue colored edges and connect a red/green edge only if they aren\\'t already connected ( part of same connected set), this is where the concept of DSU( Disjoing Set Union) comes in .\\nBelow is the code.\\n\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n + 1)]\\n        self.size = [1 for _ in range(n + 1)]\\n        self.count = n\\n    \\n    def find(self, x):\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def merge(self, a, b):\\n        pa = self.find(a)\\n        pb = self.find(b)\\n        if pa == pb:\\n            return False\\n        if self.size[pa]> self.size[pb]:\\n            self.size[pa] += self.size[pb]\\n            self.parent[pb] = pa\\n        else:\\n            self.size[pb] += self.size[pa]\\n            self.parent[pa] = pb\\n\\n        return True\\n    \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        ufa = UnionFind(n)\\n        ufb = UnionFind(n)\\n        cnta = 0\\n        common = 0\\n        \\n        for edge in edges:\\n            if edge[0] == 3:\\n                if ufa.find(edge[1]) != ufa.find(edge[2]):\\n                    ufa.merge(edge[1], edge[2])\\n                    common += 1\\n                    cnta += 1\\n        \\n        for edge in edges:\\n            if edge[0] == 1:\\n                if ufa.find(edge[1])!=ufa.find(edge[2]):\\n                    ufa.merge(edge[1], edge[2])\\n                    cnta += 1\\n        \\n        \\n        if cnta != n-1:\\n            return -1\\n        \\n        cntb = 0\\n        for edge in edges:\\n            if edge[0] == 3:\\n                if ufb.find(edge[1])!=ufb.find(edge[2]):\\n                    ufb.merge(edge[1], edge[2])\\n        \\n        for edge in edges:\\n            if edge[0] == 2:\\n                if ufb.find(edge[1])!=ufb.find(edge[2]):\\n                    ufb.merge(edge[1], edge[2])\\n                    cntb += 1\\n        \\n        \\n        if cntb  + common != n-1:\\n            return -1\\n        \\n        \\n        total = len(edges)\\n        print(total)\\n        return total - (cnta + cntb) \\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n + 1)]\\n        self.size = [1 for _ in range(n + 1)]\\n        self.count = n\\n    \\n    def find(self, x):\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def merge(self, a, b):\\n        pa = self.find(a)\\n        pb = self.find(b)\\n        if pa == pb:\\n            return False\\n        if self.size[pa]> self.size[pb]:\\n            self.size[pa] += self.size[pb]\\n            self.parent[pb] = pa\\n        else:\\n            self.size[pb] += self.size[pa]\\n            self.parent[pa] = pb\\n\\n        return True\\n    \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        ufa = UnionFind(n)\\n        ufb = UnionFind(n)\\n        cnta = 0\\n        common = 0\\n        \\n        for edge in edges:\\n            if edge[0] == 3:\\n                if ufa.find(edge[1]) != ufa.find(edge[2]):\\n                    ufa.merge(edge[1], edge[2])\\n                    common += 1\\n                    cnta += 1\\n        \\n        for edge in edges:\\n            if edge[0] == 1:\\n                if ufa.find(edge[1])!=ufa.find(edge[2]):\\n                    ufa.merge(edge[1], edge[2])\\n                    cnta += 1\\n        \\n        \\n        if cnta != n-1:\\n            return -1\\n        \\n        cntb = 0\\n        for edge in edges:\\n            if edge[0] == 3:\\n                if ufb.find(edge[1])!=ufb.find(edge[2]):\\n                    ufb.merge(edge[1], edge[2])\\n        \\n        for edge in edges:\\n            if edge[0] == 2:\\n                if ufb.find(edge[1])!=ufb.find(edge[2]):\\n                    ufb.merge(edge[1], edge[2])\\n                    cntb += 1\\n        \\n        \\n        if cntb  + common != n-1:\\n            return -1\\n        \\n        \\n        total = len(edges)\\n        print(total)\\n        return total - (cnta + cntb) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271716,
                "title": "java-union-find",
                "content": "Sort the edges in non increasing order as we want to keep the edge with type 3 in the graph and try to remove the edges with type 1 and 2. This is due to we want to remove maximum number of edges.\\n\\nThen a simple Union Find separately for Alice and Bob for checking the connectivity of the graph.\\n```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) \\n    {\\n        Arrays.sort(edges , (a,b) -> b[0] - a[0]);\\n        \\n        int[] aparent = new int[n+1];\\n        int[] bparent = new int[n+1];\\n        \\n        int[] arank = new int[n+1];\\n        int[] brank = new int[n+1];\\n        \\n        for(int i=0;i<n+1;i++){\\n            aparent[i] = i;\\n            bparent[i] = i;\\n            arank[i] = 1;\\n            brank[i] = 1;\\n        }\\n        \\n        int amerged = 1;\\n        int bmerged = 1;\\n        int remove = 0;\\n        \\n        for(int[] edge : edges){\\n            if(edge[0] == 3){\\n                boolean aunion = union(edge[1] , edge[2] , aparent , arank);\\n                boolean bunion = union(edge[1] , edge[2] , bparent , brank);\\n                \\n                if(aunion == true)\\n                    amerged++;\\n                if(bunion == true)\\n                    bmerged++;\\n                if(aunion == false && bunion == false)\\n                    remove++;\\n            }\\n            else if(edge[0] == 1){\\n                boolean aunion = union(edge[1] , edge[2] , aparent , arank);\\n                if(aunion == true)\\n                    amerged++;\\n                else\\n                    remove++;\\n            }\\n            else{\\n                boolean bunion = union(edge[1] , edge[2] , bparent , brank);\\n                if(bunion == true)\\n                    bmerged++;\\n                else\\n                    remove++;\\n            }\\n            \\n        }\\n        if(amerged != n || bmerged != n)\\n                return -1;\\n            return remove;\\n    }\\n    \\n    public int find(int x , int[] parent){\\n        if(parent[x] == x)\\n            return x;\\n        int temp = find(parent[x] , parent);\\n        parent[x] = temp;\\n        return temp;\\n    }\\n    \\n    public boolean union(int x , int y , int[] parent , int[] rank){\\n        int lx = find(x , parent);\\n        int ly = find(y , parent);\\n        \\n        if(lx != ly){\\n            if(rank[lx] > rank[ly])\\n                parent[ly] = lx;\\n            else if(rank[ly] > rank[lx])\\n                parent[lx] = ly;\\n            else{\\n                parent[ly] = lx;\\n                rank[lx]++;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) \\n    {\\n        Arrays.sort(edges , (a,b) -> b[0] - a[0]);\\n        \\n        int[] aparent = new int[n+1];\\n        int[] bparent = new int[n+1];\\n        \\n        int[] arank = new int[n+1];\\n        int[] brank = new int[n+1];\\n        \\n        for(int i=0;i<n+1;i++){\\n            aparent[i] = i;\\n            bparent[i] = i;\\n            arank[i] = 1;\\n            brank[i] = 1;\\n        }\\n        \\n        int amerged = 1;\\n        int bmerged = 1;\\n        int remove = 0;\\n        \\n        for(int[] edge : edges){\\n            if(edge[0] == 3){\\n                boolean aunion = union(edge[1] , edge[2] , aparent , arank);\\n                boolean bunion = union(edge[1] , edge[2] , bparent , brank);\\n                \\n                if(aunion == true)\\n                    amerged++;\\n                if(bunion == true)\\n                    bmerged++;\\n                if(aunion == false && bunion == false)\\n                    remove++;\\n            }\\n            else if(edge[0] == 1){\\n                boolean aunion = union(edge[1] , edge[2] , aparent , arank);\\n                if(aunion == true)\\n                    amerged++;\\n                else\\n                    remove++;\\n            }\\n            else{\\n                boolean bunion = union(edge[1] , edge[2] , bparent , brank);\\n                if(bunion == true)\\n                    bmerged++;\\n                else\\n                    remove++;\\n            }\\n            \\n        }\\n        if(amerged != n || bmerged != n)\\n                return -1;\\n            return remove;\\n    }\\n    \\n    public int find(int x , int[] parent){\\n        if(parent[x] == x)\\n            return x;\\n        int temp = find(parent[x] , parent);\\n        parent[x] = temp;\\n        return temp;\\n    }\\n    \\n    public boolean union(int x , int y , int[] parent , int[] rank){\\n        int lx = find(x , parent);\\n        int ly = find(y , parent);\\n        \\n        if(lx != ly){\\n            if(rank[lx] > rank[ly])\\n                parent[ly] = lx;\\n            else if(rank[ly] > rank[lx])\\n                parent[lx] = ly;\\n            else{\\n                parent[ly] = lx;\\n                rank[lx]++;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082195,
                "title": "java-mega-easy-solution-to-understand",
                "content": "The algorithm: \\n0. Initialize `count` as number of total edges `n`\\n1. Since the type 3 is applicable for both Alice and Bob, consider only those edges. It is optimal.\\n2. Create a copy for `parent` and `rank`\\n3. Continue merging only Bob edges. If they are already connected, do not consider them, decrement count.\\n4. Use the copy to instantiate the DisjointSet\\'s `parent` and `rank`.\\n5. Continue merging only Alice edges. If they are already connected, do not consider them, decrement count. \\n6. Return `n-cnt`  which is the `total number of edges` - `necessary number of edges`\\n\\nP.S. Hope it helped, your likes would be appreciated)\\n\\n```\\nclass Solution {\\n    class DisjointSet {\\n        int[] parent;\\n        int[] rank;\\n        int n;\\n        \\n        public DisjointSet(int n) {\\n            this.n = n;\\n            parent = new int[n+1];\\n            rank = new int[n+1];\\n            for (int i = 1; i <= n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int find(int node) {\\n            while (node != parent[node])\\n                node = parent[node];\\n            \\n            return node;\\n        }\\n        \\n        public boolean merge(int a, int b) {\\n            int parentA = find(a);\\n            int parentB = find(b);\\n            \\n            if (parentA == parentB) return false;\\n            \\n            if (rank[parentA] >= rank[parentB]) {\\n                parent[parentB] = parentA;\\n                rank[parentA]++;\\n            } else {\\n                parent[parentA] = parentB;\\n                rank[parentB]++;\\n            }\\n            \\n            return true;\\n        }\\n        \\n        public int countSeparateComponents() {\\n            int cnt = 0;\\n            \\n            for (int i = 1; i <= n; i++) \\n                if (parent[i] == i) \\n                    cnt++;\\n            \\n            return cnt;\\n        }\\n    }\\n    \\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        DisjointSet ds = new DisjointSet(n);\\n        int cnt = n;\\n        \\n        for (int[] e : edges) {\\n            if (e[0] == 3) {\\n                boolean status = ds.merge(e[1], e[2]);\\n                if (!status) cnt--;\\n            }\\n        }\\n        \\n        int[] parentCopy = new int[n+1];\\n        int[] rankCopy = new int[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            parentCopy[i] = ds.parent[i];\\n            rankCopy[i] = ds.rank[i];\\n        }\\n        \\n        // Let\\'s run for Bob only\\n        for (int[] e : edges) {\\n            if (e[0] == 2) {\\n                boolean status = ds.merge(e[1], e[2]);\\n                if (!status) cnt--;\\n            }\\n        }\\n        \\n        if (ds.countSeparateComponents() > 1) {\\n            return -1;\\n        } \\n        \\n        ds.parent = parentCopy;\\n        ds.rank = rankCopy;\\n        \\n        // Let\\'s run for Alice only\\n        for (int[] e : edges) {\\n            if (e[0] == 1) {\\n                boolean status = ds.merge(e[1], e[2]);\\n                if (!status) cnt--;\\n            }\\n        }\\n        \\n        if (ds.countSeparateComponents() > 1) {\\n            return -1;\\n        } \\n        \\n        return n-cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class DisjointSet {\\n        int[] parent;\\n        int[] rank;\\n        int n;\\n        \\n        public DisjointSet(int n) {\\n            this.n = n;\\n            parent = new int[n+1];\\n            rank = new int[n+1];\\n            for (int i = 1; i <= n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int find(int node) {\\n            while (node != parent[node])\\n                node = parent[node];\\n            \\n            return node;\\n        }\\n        \\n        public boolean merge(int a, int b) {\\n            int parentA = find(a);\\n            int parentB = find(b);\\n            \\n            if (parentA == parentB) return false;\\n            \\n            if (rank[parentA] >= rank[parentB]) {\\n                parent[parentB] = parentA;\\n                rank[parentA]++;\\n            } else {\\n                parent[parentA] = parentB;\\n                rank[parentB]++;\\n            }\\n            \\n            return true;\\n        }\\n        \\n        public int countSeparateComponents() {\\n            int cnt = 0;\\n            \\n            for (int i = 1; i <= n; i++) \\n                if (parent[i] == i) \\n                    cnt++;\\n            \\n            return cnt;\\n        }\\n    }\\n    \\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        DisjointSet ds = new DisjointSet(n);\\n        int cnt = n;\\n        \\n        for (int[] e : edges) {\\n            if (e[0] == 3) {\\n                boolean status = ds.merge(e[1], e[2]);\\n                if (!status) cnt--;\\n            }\\n        }\\n        \\n        int[] parentCopy = new int[n+1];\\n        int[] rankCopy = new int[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            parentCopy[i] = ds.parent[i];\\n            rankCopy[i] = ds.rank[i];\\n        }\\n        \\n        // Let\\'s run for Bob only\\n        for (int[] e : edges) {\\n            if (e[0] == 2) {\\n                boolean status = ds.merge(e[1], e[2]);\\n                if (!status) cnt--;\\n            }\\n        }\\n        \\n        if (ds.countSeparateComponents() > 1) {\\n            return -1;\\n        } \\n        \\n        ds.parent = parentCopy;\\n        ds.rank = rankCopy;\\n        \\n        // Let\\'s run for Alice only\\n        for (int[] e : edges) {\\n            if (e[0] == 1) {\\n                boolean status = ds.merge(e[1], e[2]);\\n                if (!status) cnt--;\\n            }\\n        }\\n        \\n        if (ds.countSeparateComponents() > 1) {\\n            return -1;\\n        } \\n        \\n        return n-cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800975,
                "title": "modified-dsu-c-path-compression-easy-solution",
                "content": "Here, in1,in2 stores the true/false value for type1 and type2 respectively.\\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\t\\tint flag1=0,flag2=0;\\n\\t\\t\\t\\tint find(int a,vector<int>& par)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(par[a]==a) return a;\\n\\t\\t\\t\\t\\treturn par[a]=find(par[a],par);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid unionf(int a,int b,vector<int>& par,vector<int>& rank,int x,int in1,int in2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint u=find(a,par);\\n\\t\\t\\t\\t\\tint v=find(b,par);\\n\\t\\t\\t\\t\\tif(u==v&&x==3)\\n\\t\\t\\t\\t\\t{ if(in1==1)\\n\\t\\t\\t\\t\\t\\tflag1++;\\n\\t\\t\\t\\t\\t if(in2==1) flag2++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(u==v&&x!=3)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(rank[u]<rank[v])\\n\\t\\t\\t\\t\\t\\tpar[u]=v;\\n\\t\\t\\t\\t\\telse if(rank[u]>rank[v])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tpar[v]=u;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tpar[v]=u;\\n\\t\\t\\t\\t\\t\\trank[u]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n\\t\\t\\t\\t\\tvector<int> par1(n+1);\\n\\t\\t\\t\\t\\tvector<int> rank1(n+1);\\n\\t\\t\\t\\t\\t  vector<int> par2(n+1);\\n\\t\\t\\t\\t\\tvector<int> rank2(n+1);\\n\\n\\t\\t\\t\\t\\tfor(int i=1;i<=n;i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tpar1[i]=i;\\n\\t\\t\\t\\t\\t\\tpar2[i]=i;\\n\\t\\t\\t\\t\\t\\trank1[i]=0;\\n\\t\\t\\t\\t\\t\\trank2[i]=0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(int i=0;i<edges.size();i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(edges[i][0]==3)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tunionf(edges[i][1],edges[i][2],par1,rank1,3,1,0);\\n\\t\\t\\t\\t\\t\\t\\tunionf(edges[i][1],edges[i][2],par2,rank2,3,0,1);\\n\\t\\t\\t\\t\\t\\t\\tif(flag1==1&&flag2==1) {\\n\\t\\t\\t\\t\\t\\t\\t\\tflag1=flag2=0;\\n\\t\\t\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(int i=0;i<edges.size();i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(edges[i][0]==1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tunionf(edges[i][1],edges[i][2],par1,rank1,1,1,0);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(edges[i][0]==2)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tunionf(edges[i][1],edges[i][2],par2,rank2,2,0,1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint c1=0,c2=0;\\n\\t\\t\\t\\t\\tfor(int i=1;i<=n;i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(par1[i]==i) c1++;\\n\\t\\t\\t\\t\\t\\tif(par2[i]==i) c2++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(c1>1||c2>1) return -1;\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\t\\tint flag1=0,flag2=0;\\n\\t\\t\\t\\tint find(int a,vector<int>& par)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(par[a]==a) return a;\\n\\t\\t\\t\\t\\treturn par[a]=find(par[a],par);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1755602,
                "title": "java-two-union-find-for-alice-and-bob",
                "content": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        UF a = new UF(n + 1);\\n        UF b = new UF(n + 1);\\n        int extra = 0;\\n        for (int[] e: edges) {\\n            if (e[0] != 3) continue;\\n            boolean ext = false;\\n            if (!a.add(e)) ext = true;\\n            if (!b.add(e)) ext = true;\\n            if (ext) extra++;\\n        }\\n        for (int[] e: edges) {\\n            if (e[0] == 1 && !a.add(e)) extra++;\\n            if (e[0] == 2 && !b.add(e)) extra++;\\n        }\\n        return a.isConnected() && b.isConnected() ? extra : -1;\\n    }\\n}\\n\\nclass UF {\\n    int[] nodes;\\n    int edjCnt = 0;\\n    UF(int n) {\\n        nodes = new int[n];\\n        for(int i = 0; i < n; i++)\\n            nodes[i] = i;\\n    }\\n    \\n    boolean isConnected() {\\n        return (nodes.length - 1 - 1) == edjCnt;\\n    }\\n    \\n    boolean add(int[] edj) {\\n        int aHead = head(edj[1]);\\n        int bHead = head(edj[2]);\\n        if (aHead != bHead) {\\n            nodes[bHead] = aHead;\\n            edjCnt++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int head(int n) {\\n        if (n != nodes[n]) \\n            nodes[n] = head(nodes[n]);\\n        return nodes[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        UF a = new UF(n + 1);\\n        UF b = new UF(n + 1);\\n        int extra = 0;\\n        for (int[] e: edges) {\\n            if (e[0] != 3) continue;\\n            boolean ext = false;\\n            if (!a.add(e)) ext = true;\\n            if (!b.add(e)) ext = true;\\n            if (ext) extra++;\\n        }\\n        for (int[] e: edges) {\\n            if (e[0] == 1 && !a.add(e)) extra++;\\n            if (e[0] == 2 && !b.add(e)) extra++;\\n        }\\n        return a.isConnected() && b.isConnected() ? extra : -1;\\n    }\\n}\\n\\nclass UF {\\n    int[] nodes;\\n    int edjCnt = 0;\\n    UF(int n) {\\n        nodes = new int[n];\\n        for(int i = 0; i < n; i++)\\n            nodes[i] = i;\\n    }\\n    \\n    boolean isConnected() {\\n        return (nodes.length - 1 - 1) == edjCnt;\\n    }\\n    \\n    boolean add(int[] edj) {\\n        int aHead = head(edj[1]);\\n        int bHead = head(edj[2]);\\n        if (aHead != bHead) {\\n            nodes[bHead] = aHead;\\n            edjCnt++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int head(int n) {\\n        if (n != nodes[n]) \\n            nodes[n] = head(nodes[n]);\\n        return nodes[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046549,
                "title": "java-union-find-beginner-friendly-full-explanation-17ms",
                "content": "**Please upvote if u find useful**\\nCredits - A big thanks to @interviewrecipes and @akshay31verma\\n\\n\\n*  The idea here is to think that initially the graph is empty and now we want to add the edges into the graph such that graph is connected. \\n* As some edges are available to only Bob while some are available only to Alice, we will have two different union find objects to take care of their own traversability.\\n* Make all the components which you can reach from type 3 edges i.e traverserable for both Alice and Bob\\n* Now using First go with alice and find if we can connect all the disconnected groups using the Alice edges.\\n* And apply same for Bob.\\n* Also in Union Find DS i have made var comp. to calculate the no of independent Component in the graph of Alice and Bob\\n* we cal. comp. for both alice and bob\\n* ***if the graph is fully traversible then we must no. comp. = 2 (coz 0 is indept. node)***\\n\\nMy Simple Java Code:\\n```\\npublic int maxNumEdgesToRemove(int n, int[][] edges) {\\n\\t\\t int nboth=0,nalice=0,nbob=0;\\n\\t\\t List<int[]> both=new Vector<>();\\n\\t\\t List<int[]> bob=new Vector<>();\\n\\t\\t List<int[]> alice=new Vector<>();\\n\\t\\t \\n\\t\\t for(int[] t:edges) {\\n\\t\\t\\t if(t[0]==3) {nboth++;both.add(t);}\\n\\t\\t\\t else if(t[0]==2) {nbob++;bob.add(t);}\\n\\t\\t\\t else {nalice++;alice.add(t);}\\n\\t\\t }\\n\\t\\t \\n\\t\\t Dsu dsu_bob=new Dsu(n+1);\\n\\t\\t Dsu dsu_alice=new Dsu(n+1);\\n\\t\\tint ans=0;\\n\\t\\tint edge=0;\\n\\t\\tfor(int[] t:both) {\\n\\t\\t\\tif(dsu_alice.union(t[1], t[2])==false&&dsu_bob.union(t[1], t[2])==false)\\n\\t\\t\\t\\tedge++;\\n\\t\\t}\\n\\t\\tans+=nboth-edge;\\n\\t\\tedge=0;\\n\\t\\tfor(int[] t:alice) {\\n\\t\\t\\tif(dsu_alice.union(t[1], t[2])==false)\\n\\t\\t\\t\\tedge++;\\n\\t\\t}\\n\\t\\tans+=nalice-edge;\\n\\t\\tedge=0;\\n\\t\\tfor(int[] t:bob) {\\n\\t\\t\\tif(dsu_bob.union(t[1], t[2])==false)\\n\\t\\t\\t\\tedge++;\\n\\t\\t}\\n\\t\\tans+=nbob-edge;\\n\\t\\tif(dsu_alice.comp>2|| dsu_bob.comp>2) return -1;\\n\\t\\treturn ans;\\n\\t }\\n\\t static class Dsu{\\n\\t\\t int[] parent;\\n\\t\\t int[] rank;\\n\\t\\t int comp;\\n\\t\\t Dsu(int N){\\n\\t\\t\\t parent=new int[N];\\n\\t\\t\\t rank=new int[N];\\n\\t\\t\\t Arrays.fill(parent, -1);\\n\\t\\t\\t this.comp=N;\\n\\t\\t }\\n\\t\\t int find(int x) {\\n\\t\\t\\t if(parent[x]==-1)return x;\\n\\t\\t\\t return parent[x]=find(parent[x]);\\n\\t\\t }\\n\\t\\t boolean union(int u,int v) {\\n\\t\\t\\t int p1=find(u);\\n\\t\\t\\t int p2=find(v);\\n\\t\\t\\t if(p1==p2)return true;\\n\\t\\t\\t \\n\\t\\t\\t if(rank[p1] >rank[p2])\\n\\t\\t\\t\\t parent[p2]=p1;\\n\\t\\t\\t else if(rank[p2] >rank[p1])\\n\\t\\t\\t\\t parent[p1]=p2;\\n\\t\\t\\t else {\\n\\t\\t\\t\\t parent[p2]=p1;\\n\\t\\t\\t\\t rank[p1]++;\\n\\t\\t\\t }\\n\\t\\t\\t comp--;\\n\\t\\t\\t return false;\\n\\t\\t }\\n\\t }\\n\\n```\\n\\nTime: O(m), where m is the number of edges.\\nMemory: O(n) \\n**Please upvote if u find useful**",
                "solutionTags": [],
                "code": "```\\npublic int maxNumEdgesToRemove(int n, int[][] edges) {\\n\\t\\t int nboth=0,nalice=0,nbob=0;\\n\\t\\t List<int[]> both=new Vector<>();\\n\\t\\t List<int[]> bob=new Vector<>();\\n\\t\\t List<int[]> alice=new Vector<>();\\n\\t\\t \\n\\t\\t for(int[] t:edges) {\\n\\t\\t\\t if(t[0]==3) {nboth++;both.add(t);}\\n\\t\\t\\t else if(t[0]==2) {nbob++;bob.add(t);}\\n\\t\\t\\t else {nalice++;alice.add(t);}\\n\\t\\t }\\n\\t\\t \\n\\t\\t Dsu dsu_bob=new Dsu(n+1);\\n\\t\\t Dsu dsu_alice=new Dsu(n+1);\\n\\t\\tint ans=0;\\n\\t\\tint edge=0;\\n\\t\\tfor(int[] t:both) {\\n\\t\\t\\tif(dsu_alice.union(t[1], t[2])==false&&dsu_bob.union(t[1], t[2])==false)\\n\\t\\t\\t\\tedge++;\\n\\t\\t}\\n\\t\\tans+=nboth-edge;\\n\\t\\tedge=0;\\n\\t\\tfor(int[] t:alice) {\\n\\t\\t\\tif(dsu_alice.union(t[1], t[2])==false)\\n\\t\\t\\t\\tedge++;\\n\\t\\t}\\n\\t\\tans+=nalice-edge;\\n\\t\\tedge=0;\\n\\t\\tfor(int[] t:bob) {\\n\\t\\t\\tif(dsu_bob.union(t[1], t[2])==false)\\n\\t\\t\\t\\tedge++;\\n\\t\\t}\\n\\t\\tans+=nbob-edge;\\n\\t\\tif(dsu_alice.comp>2|| dsu_bob.comp>2) return -1;\\n\\t\\treturn ans;\\n\\t }\\n\\t static class Dsu{\\n\\t\\t int[] parent;\\n\\t\\t int[] rank;\\n\\t\\t int comp;\\n\\t\\t Dsu(int N){\\n\\t\\t\\t parent=new int[N];\\n\\t\\t\\t rank=new int[N];\\n\\t\\t\\t Arrays.fill(parent, -1);\\n\\t\\t\\t this.comp=N;\\n\\t\\t }\\n\\t\\t int find(int x) {\\n\\t\\t\\t if(parent[x]==-1)return x;\\n\\t\\t\\t return parent[x]=find(parent[x]);\\n\\t\\t }\\n\\t\\t boolean union(int u,int v) {\\n\\t\\t\\t int p1=find(u);\\n\\t\\t\\t int p2=find(v);\\n\\t\\t\\t if(p1==p2)return true;\\n\\t\\t\\t \\n\\t\\t\\t if(rank[p1] >rank[p2])\\n\\t\\t\\t\\t parent[p2]=p1;\\n\\t\\t\\t else if(rank[p2] >rank[p1])\\n\\t\\t\\t\\t parent[p1]=p2;\\n\\t\\t\\t else {\\n\\t\\t\\t\\t parent[p2]=p1;\\n\\t\\t\\t\\t rank[p1]++;\\n\\t\\t\\t }\\n\\t\\t\\t comp--;\\n\\t\\t\\t return false;\\n\\t\\t }\\n\\t }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984169,
                "title": "a-solution-without-union-find-just-do-at-most-3-times-of-dfs-bfs",
                "content": "Almost all the solutions posted in Discuss are Union-Find solution. So I am providing a different solution without union-find here: Just do at most 3 times of graph traversal.\\n1. First travel the graph by using only edge type 1 and type 3. If it can\\'t visit all the nodes, then it means Alice can\\'t visit all nodes. Return -1.\\n2. Then travel the graph by using only edge type 2 and type 3. If it can\\'t visit all the nodes, then it means Bob can\\'t visit all nodes. Return -1.\\n3. Finally travel the graph by using only edge type 3 and count the number of connected component, say x.  Then the result is **edges.length - (n -1 + x -1)**.\\n```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        ArrayList<Integer>[] als1=new ArrayList[n], als2=new ArrayList[n], als3=new ArrayList[n];\\n        for(int i=0;i<n;++i){\\n            als1[i]=new ArrayList();\\n            als2[i]=new ArrayList();\\n            als3[i]=new ArrayList();\\n        }\\n        for(int[] e : edges){\\n            if(e[0]==1){\\n                als1[e[1]-1].add(e[2]-1);\\n                als1[e[2]-1].add(e[1]-1);\\n            }else if(e[0]==2){\\n                als2[e[1]-1].add(e[2]-1);\\n                als2[e[2]-1].add(e[1]-1);\\n            }else{\\n                als3[e[1]-1].add(e[2]-1);\\n                als3[e[2]-1].add(e[1]-1);\\n            }\\n        }\\n        int[] kk=new int[1];\\n        check(als1,als3,new boolean[n],0,kk);\\n        if(kk[0]!=n)return -1;\\n        kk[0]=0;\\n        check(als2,als3,new boolean[n],0,kk);\\n        if(kk[0]!=n)return -1;\\n        boolean[] f=new boolean[n];\\n        int count=0;\\n        for(int i=0;i<n;++i){\\n            if(!f[i]){\\n                ++count;\\n                todo(als3,f,i);\\n            }\\n        }\\n        return edges.length - (n-1+(count-1));\\n    }\\n    \\n    private void todo(ArrayList<Integer>[] als, boolean[] f, int st){\\n        f[st]=true;\\n        for(int n : als[st]){\\n            if(!f[n])todo(als, f, n);\\n        }\\n    }\\n    \\n    private void check(ArrayList<Integer>[] als1, ArrayList<Integer>[] als2, boolean[] f, int st, int[] kk){\\n        f[st]=true;\\n        ++kk[0];\\n        for(int n : als1[st]){\\n            if(!f[n])check(als1, als2, f, n, kk);\\n        }\\n        for(int n : als2[st]){\\n            if(!f[n])check(als1, als2, f, n, kk);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        ArrayList<Integer>[] als1=new ArrayList[n], als2=new ArrayList[n], als3=new ArrayList[n];\\n        for(int i=0;i<n;++i){\\n            als1[i]=new ArrayList();\\n            als2[i]=new ArrayList();\\n            als3[i]=new ArrayList();\\n        }\\n        for(int[] e : edges){\\n            if(e[0]==1){\\n                als1[e[1]-1].add(e[2]-1);\\n                als1[e[2]-1].add(e[1]-1);\\n            }else if(e[0]==2){\\n                als2[e[1]-1].add(e[2]-1);\\n                als2[e[2]-1].add(e[1]-1);\\n            }else{\\n                als3[e[1]-1].add(e[2]-1);\\n                als3[e[2]-1].add(e[1]-1);\\n            }\\n        }\\n        int[] kk=new int[1];\\n        check(als1,als3,new boolean[n],0,kk);\\n        if(kk[0]!=n)return -1;\\n        kk[0]=0;\\n        check(als2,als3,new boolean[n],0,kk);\\n        if(kk[0]!=n)return -1;\\n        boolean[] f=new boolean[n];\\n        int count=0;\\n        for(int i=0;i<n;++i){\\n            if(!f[i]){\\n                ++count;\\n                todo(als3,f,i);\\n            }\\n        }\\n        return edges.length - (n-1+(count-1));\\n    }\\n    \\n    private void todo(ArrayList<Integer>[] als, boolean[] f, int st){\\n        f[st]=true;\\n        for(int n : als[st]){\\n            if(!f[n])todo(als, f, n);\\n        }\\n    }\\n    \\n    private void check(ArrayList<Integer>[] als1, ArrayList<Integer>[] als2, boolean[] f, int st, int[] kk){\\n        f[st]=true;\\n        ++kk[0];\\n        for(int n : als1[st]){\\n            if(!f[n])check(als1, als2, f, n, kk);\\n        }\\n        for(int n : als2[st]){\\n            if(!f[n])check(als1, als2, f, n, kk);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870919,
                "title": "concise-union-find-python",
                "content": "```\\ndef maxNumEdgesToRemove(self, n: int, e: List[List[int]]) -> int:\\n\\tdef union(UF, u, v):            \\n\\t\\tUF[find(UF, v)] = find(UF, u)\\n\\tdef find(UF, u):\\n\\t\\tif UF[u] != u: UF[u] = find(UF, UF[u])\\n\\t\\treturn UF[u]         \\n\\tdef check(UF, t):            \\n\\t\\tUF = UF.copy()\\n\\t\\tfor tp, u, v in e:\\n\\t\\t\\tif tp == t: \\n\\t\\t\\t\\tif find(UF, u) == find(UF, v): self.ans += 1\\n\\t\\t\\t\\telse: union(UF, u, v)\\n\\t\\treturn len(set(find(UF, u) for u in UF)) == 1, UF\\n\\n\\tself.ans, UF = 0, {u: u for u in range(1, n+1)}                \\n\\tUF = check(UF, 3)[1]\\n\\tif not check(UF, 1)[0] or not check(UF, 2)[0]: return -1        \\n\\treturn self.ans",
                "solutionTags": [],
                "code": "```\\ndef maxNumEdgesToRemove(self, n: int, e: List[List[int]]) -> int:\\n\\tdef union(UF, u, v):            \\n\\t\\tUF[find(UF, v)] = find(UF, u)\\n\\tdef find(UF, u):\\n\\t\\tif UF[u] != u: UF[u] = find(UF, UF[u])\\n\\t\\treturn UF[u]         \\n\\tdef check(UF, t):            \\n\\t\\tUF = UF.copy()\\n\\t\\tfor tp, u, v in e:\\n\\t\\t\\tif tp == t: \\n\\t\\t\\t\\tif find(UF, u) == find(UF, v): self.ans += 1\\n\\t\\t\\t\\telse: union(UF, u, v)\\n\\t\\treturn len(set(find(UF, u) for u in UF)) == 1, UF\\n\\n\\tself.ans, UF = 0, {u: u for u in range(1, n+1)}                \\n\\tUF = check(UF, 3)[1]\\n\\tif not check(UF, 1)[0] or not check(UF, 2)[0]: return -1        \\n\\treturn self.ans",
                "codeTag": "Python3"
            },
            {
                "id": 847777,
                "title": "c-union-find-code-and-steps-hinglish",
                "content": "I am writing the steps in both English and Hinglish because I personally feel Hinglish makes it easier to understand for native Hindi speakers.\\nSteps:-\\n* Make all the components which you can reach from type 3 edges i.e traverserable for both Alice and Bob.(Sabse pehle saare components nikallo 3rd type ki edge use karke ,jisko Alice and Bob dono use kar sake).\\n* Now using First go with alice and find if we can connect all the disconnected groups using the Alice edges.(uske baad yeh dekho ki kyaa alice apne edges use karke saare jagah jaa sakta hai ,toh isse humhe alice ke minimum required edges aajayenge).\\n* And apply same for Bob.(Bob ke liye bhi check karlo)\\n* Final answer will be \\n\\t*if(alice edges!=n-1 || bob edges!=-1){\\n\\t\\tthen all the edges cannot be traversed.(Matlab Alice Bob nhi kar sakte saare destinations.)\\n\\t\\treturn -1.\\n\\t}\\n\\totherwise (varna)\\n\\ttotaledges-(alice edges+bob edges-common edges(because we have added common edges with both alice and bob));(saare edges mein se alice ki requirement+bob ki requirement aur inmein se common edges jo 2 baar add hue hai unko total edges mein se subtract kardo.)\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n   \\n    \\n    int findp(int x, vector<int> &par){\\n        if(par[x]!=x){\\n            par[x]=findp(par[x],par);\\n        }\\n        return par[x];\\n    }\\n    void unio(int x,int y, vector<int> &par){\\n        int p1=findp(x,par);\\n        int p2=findp(y,par);\\n        if(p1!=p2){\\n            par[p2]=p1;\\n        }\\n    }\\n    \\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> gA;\\n        unordered_map<int,vector<int>> gB;\\n        unordered_map<int,vector<int>> gC;\\n        \\n        for(auto r:edges){\\n            if(r[0]==1){\\n                gA[r[1]].push_back(r[2]);\\n                gA[r[2]].push_back(r[1]);\\n            }else if(r[0]==2){\\n                gB[r[1]].push_back(r[2]);\\n                gB[r[2]].push_back(r[1]);\\n            }else{\\n                gC[r[1]].push_back(r[2]);\\n                gC[r[2]].push_back(r[1]);\\n            }\\n        }\\n        vector<int> par;\\n        par.resize(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            par[i]=i;\\n        }\\n        \\n        int ed=0;\\n        int cnt=0;\\n        \\n        \\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j:gC[i]){\\n                int p1=findp(i,par);\\n                int p2=findp(j,par);\\n                if(p1==p2){\\n                    continue;\\n                }else{\\n                    unio(i,j,par);\\n                    ed++;\\n                }\\n            }\\n        }\\n       \\n        vector<int> pa=par;\\n        vector<int> pb=par;\\n        int ed1=ed;\\n        int ed2=ed;\\n        for(int i=1;i<=n;i++){\\n            int p1=findp(i,pa);\\n           \\n            for(auto j:gA[i]){\\n                int p2=findp(j,pa);\\n                if(p1==p2){\\n                    continue;\\n                }else{\\n                    unio(i,j,pa);\\n                    ed1++;\\n                }\\n            }\\n            int p4=findp(i,pb);\\n             for(auto k:gB[i]){\\n                int p3=findp(k,pb);\\n                if(p4==p3){\\n                    continue;\\n                }else{\\n                    unio(i,k,pb);\\n                    ed2++;\\n                }\\n            }\\n        }\\n     \\n        \\n        if(ed1!=n-1 || ed2!=n-1 ){\\n            return -1;\\n        }\\n        return edges.size()-(ed1+ed2-ed);\\n       \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    \\n    int findp(int x, vector<int> &par){\\n        if(par[x]!=x){\\n            par[x]=findp(par[x],par);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 832261,
                "title": "java-easy-to-understand-union-find",
                "content": "```\\nclass Solution {\\n\\t// union-find structure\\n    class UnionFind {\\n        int count;\\n        int[] parent;\\n        int[] rank;\\n        public UnionFind(int n) {\\n            count = n;\\n            parent = new int[n+1];\\n            for(int i = 0; i < n+1; i++) {\\n                parent[i] = i;\\n            }\\n            rank = new int[n+1];\\n        }\\n        \\n        public int find(int a) {\\n            if(a != parent[a]) {\\n                parent[a] = find(parent[a]);\\n            }\\n            return parent[a];\\n        }\\n        // returns false if a and b are in same set, i.e., if both have already been reached\\n        public boolean union(int a, int b) {\\n            int parent_a = find(a);\\n            int parent_b = find(b);\\n            if(parent_a == parent_b)    return false;\\n            if(rank[parent_a] >= rank[parent_b]) {\\n                parent[parent_b] = parent_a;\\n                if(rank[parent_a] == rank[parent_b])\\n                    rank[parent_a]++;\\n            }\\n            else {\\n                parent[parent_a] = parent_b;\\n            }\\n            count--;\\n            return true;\\n        }\\n            \\n        \\n    }\\n\\t// real solution\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        UnionFind uf_alice = new UnionFind(n);\\n        UnionFind uf_bob = new UnionFind(n);\\n        for(int[] edge : edges) {\\n            if(edge[0] == 1) {\\n                uf_alice.union(edge[1], edge[2]);\\n            }\\n            else if(edge[0] == 2) {\\n                uf_bob.union(edge[1], edge[2]);\\n            }\\n            else {\\n                uf_alice.union(edge[1], edge[2]);\\n                uf_bob.union(edge[1], edge[2]);\\n            }\\n        }\\n\\t\\t// let\\'s just make sure, if with given edges they can reach all nodes or not\\n        if(uf_alice.count != 1 || uf_bob.count != 1)    return -1;\\n        \\n\\t\\t/* okay, so they are reachable , now remove the redundant ones in following way :\\n\\t\\t\\t1.  It\\'s best to insert the type-3 edges, while removing the redundant ones.\\n\\t\\t\\t2.  Once, above step is finished, we can remove the redundant type-1 and redundant type-2 edges. \\n\\t\\t*/\\n\\t\\t\\n        uf_alice = new UnionFind(n);\\n        uf_bob = new UnionFind(n);\\n        int ans = 0;\\n        for(int[] edge : edges) {\\n            if(edge[0] == 3) {\\n                if(!uf_alice.union(edge[1], edge[2]))\\n                    ans++;\\n                uf_bob.union(edge[1], edge[2]);\\n            }\\n        }\\n        for(int[] edge : edges) {\\n            if(edge[0] == 1) {\\n                if(!uf_alice.union(edge[1], edge[2]))\\n                    ans++;\\n            }\\n            else if(edge[0] == 2) {\\n                if(!uf_bob.union(edge[1], edge[2]))\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n\\t// union-find structure\\n    class UnionFind {\\n        int count;\\n        int[] parent;\\n        int[] rank;\\n        public UnionFind(int n) {\\n            count = n;\\n            parent = new int[n+1];\\n            for(int i = 0; i < n+1; i++) {\\n                parent[i] = i;\\n            }\\n            rank = new int[n+1];\\n        }\\n        \\n        public int find(int a) {\\n            if(a != parent[a]) {\\n                parent[a] = find(parent[a]);\\n            }\\n            return parent[a];\\n        }\\n        // returns false if a and b are in same set, i.e., if both have already been reached\\n        public boolean union(int a, int b) {\\n            int parent_a = find(a);\\n            int parent_b = find(b);\\n            if(parent_a == parent_b)    return false;\\n            if(rank[parent_a] >= rank[parent_b]) {\\n                parent[parent_b] = parent_a;\\n                if(rank[parent_a] == rank[parent_b])\\n                    rank[parent_a]++;\\n            }\\n            else {\\n                parent[parent_a] = parent_b;\\n            }\\n            count--;\\n            return true;\\n        }\\n            \\n        \\n    }\\n\\t// real solution\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        UnionFind uf_alice = new UnionFind(n);\\n        UnionFind uf_bob = new UnionFind(n);\\n        for(int[] edge : edges) {\\n            if(edge[0] == 1) {\\n                uf_alice.union(edge[1], edge[2]);\\n            }\\n            else if(edge[0] == 2) {\\n                uf_bob.union(edge[1], edge[2]);\\n            }\\n            else {\\n                uf_alice.union(edge[1], edge[2]);\\n                uf_bob.union(edge[1], edge[2]);\\n            }\\n        }\\n\\t\\t// let\\'s just make sure, if with given edges they can reach all nodes or not\\n        if(uf_alice.count != 1 || uf_bob.count != 1)    return -1;\\n        \\n\\t\\t/* okay, so they are reachable , now remove the redundant ones in following way :\\n\\t\\t\\t1.  It\\'s best to insert the type-3 edges, while removing the redundant ones.\\n\\t\\t\\t2.  Once, above step is finished, we can remove the redundant type-1 and redundant type-2 edges. \\n\\t\\t*/\\n\\t\\t\\n        uf_alice = new UnionFind(n);\\n        uf_bob = new UnionFind(n);\\n        int ans = 0;\\n        for(int[] edge : edges) {\\n            if(edge[0] == 3) {\\n                if(!uf_alice.union(edge[1], edge[2]))\\n                    ans++;\\n                uf_bob.union(edge[1], edge[2]);\\n            }\\n        }\\n        for(int[] edge : edges) {\\n            if(edge[0] == 1) {\\n                if(!uf_alice.union(edge[1], edge[2]))\\n                    ans++;\\n            }\\n            else if(edge[0] == 2) {\\n                if(!uf_bob.union(edge[1], edge[2]))\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832034,
                "title": "what-a-crap-test-cases-and-constraints-same-solution-passing-in-practice-and-tle-in-contest",
                "content": "Even it\\'s showing better than 75% solutions. \\nThis is my solution using BFS.\\nFirst I used blue edges to mark nodes visited then tried using green and red edges to connect rest nodes and in last connecting different components of blue.\\nI know there are so many scope of improvements even I have also submited a improved version but runtime is same for both still I was not able to pass the 82nd case in contest.\\n\\nLeetcode should do something for this kind of problems.\\nTest cases and constraints should be consistent for all the solutions having similar complexity.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    bool pos ;\\n    \\n    int seprateCount(vector<vector<int>> &gr,vector<vector<int>> goodBlue,vector<bool> vis)\\n    {\\n        int cnt=0;\\n        for(auto &x:goodBlue)\\n        {\\n            vector<int> ans;\\n            for(auto y:x)\\n            {\\n                \\n                for(auto z:gr[y])\\n                {\\n                    if(vis[z]==false)\\n                    {\\n                        cnt++;\\n                        queue<int> Q;\\n                        Q.push(z);\\n                        vis[z]=true;\\n                        while(Q.size())\\n                        {\\n                            int cur = Q.front();\\n                            Q.pop();\\n                            ans.push_back(cur);\\n                            for(auto xx: gr[cur])\\n                            {\\n                                if(vis[xx]==false)\\n                                {\\n                                    vis[xx]=true;\\n                                    cnt++;\\n                                    Q.push(xx);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto y:ans)\\n            {\\n                x.push_back(y);\\n            }\\n        }\\n        \\n        for(auto x:vis)\\n        {\\n            if(x==false)\\n            {\\n                pos=false;\\n                return 0;\\n            }\\n        }\\n        \\n        vector<int> mark(n);\\n        int m = goodBlue.size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(auto x:goodBlue[i])\\n            {\\n                mark[x] = i;\\n            }\\n        }\\n        \\n        vector<vector<int>> newGraph(m);\\n        for(int i=0;i<n;i++)\\n        {\\n            int his = mark[i];\\n            for(auto x:gr[i])\\n            {\\n                if(mark[x]!=his)\\n                {\\n                    newGraph[his].push_back(mark[x]);\\n                    newGraph[mark[x]].push_back(his);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> newVis(m,false);\\n        \\n        newVis[0]=true;\\n        queue<int> Q;\\n        Q.push(0);\\n        int cnt2 = 0;\\n        while(Q.size())\\n        {\\n            int cur = Q.front();\\n            Q.pop();\\n            for(auto xx: newGraph[cur])\\n            {\\n                if(newVis[xx]==false)\\n                {\\n                    newVis[xx]=true;\\n                    cnt2++;\\n                    Q.push(xx);\\n                }\\n            }\\n        }\\n        \\n        if(cnt2<m-1)\\n        {\\n                pos=false;\\n                return 0;\\n        }\\n        \\n        \\n        return cnt+cnt2;\\n    }\\n    \\n    int goodBlueCount(vector<vector<int>> &gr,vector<vector<int>> &goodBlue,vector<bool> &vis)\\n    {\\n        int cnt=0,i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(gr[i].size()&&vis[i]==false)\\n            {\\n                vector<int> emp;\\n                goodBlue.push_back(emp);\\n                vector<int> &ans = goodBlue.back();\\n                queue<int> Q;\\n                Q.push(i);\\n                vis[i]=true;\\n                while(Q.size())\\n                {\\n                    int cur = Q.front();\\n                    Q.pop();\\n                    ans.push_back(cur);\\n                    for(auto x: gr[cur])\\n                    {\\n                        if(vis[x]==false)\\n                        {\\n                            vis[x]=true;\\n                            cnt++;\\n                            Q.push(x);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n\\n    bool BFS(vector<vector<int>> &newGraph,vector<bool> newVis)\\n    {\\n        \\n        newVis[0]=true;\\n        queue<int> Q;\\n        Q.push(0);\\n        int cnt2 = 0;\\n        while(Q.size())\\n        {\\n            int cur = Q.front();\\n            Q.pop();\\n            for(auto xx: newGraph[cur])\\n            {\\n                if(newVis[xx]==false)\\n                {\\n                    newVis[xx]=true;\\n                    cnt2++;\\n                    Q.push(xx);\\n                }\\n            }\\n        }\\n        return cnt2==n-1;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        this-> n =n;\\n        int typeCnt[3] = {0,0,0};\\n        vector<vector<int>> blue(n);\\n        vector<vector<int>> red(n);\\n        vector<vector<int>> green(n);\\n        for(auto x:edges)\\n        {\\n            typeCnt[x[0]-1]++;\\n            \\n            //R\\n            if(x[0]==1)\\n            {\\n                red[x[2]-1].push_back(x[1]-1);\\n                red[x[1]-1].push_back(x[2]-1);\\n            }\\n            //G\\n            else if(x[0]==2)\\n            {\\n                green[x[2]-1].push_back(x[1]-1);\\n                green[x[1]-1].push_back(x[2]-1);\\n            }\\n            //B\\n            else\\n            {\\n                blue[x[2]-1].push_back(x[1]-1);\\n                blue[x[1]-1].push_back(x[2]-1);\\n            }\\n        }\\n        pos=true;\\n        vector<vector<int>> goodBlue;\\n        vector<bool> vis(n,false);\\n        int blueCnt = goodBlueCount(blue,goodBlue,vis);\\n        if(blueCnt)\\n        {\\n            int redCnt = seprateCount(red,goodBlue,vis);\\n            if(pos==false)\\n                return -1;\\n\\n            int greenCnt = seprateCount(green,goodBlue,vis);\\n            if(pos==false)\\n                return -1;\\n\\n            return typeCnt[0]+typeCnt[1]+typeCnt[2]-(blueCnt+redCnt+greenCnt);\\n        }\\n        else\\n        {\\n            if(BFS(red,vis)&&BFS(green,vis))\\n            {\\n                return 0;\\n            }\\n            return -1;\\n        }\\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/828953cc-a57e-4937-8cbf-2b51ef76f34c_1599376737.1800864.png)\\n![image](https://assets.leetcode.com/users/images/e1f175aa-c70b-4a66-84c2-a72a372bbf87_1599376737.6449122.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    bool pos ;\\n    \\n    int seprateCount(vector<vector<int>> &gr,vector<vector<int>> goodBlue,vector<bool> vis)\\n    {\\n        int cnt=0;\\n        for(auto &x:goodBlue)\\n        {\\n            vector<int> ans;\\n            for(auto y:x)\\n            {\\n                \\n                for(auto z:gr[y])\\n                {\\n                    if(vis[z]==false)\\n                    {\\n                        cnt++;\\n                        queue<int> Q;\\n                        Q.push(z);\\n                        vis[z]=true;\\n                        while(Q.size())\\n                        {\\n                            int cur = Q.front();\\n                            Q.pop();\\n                            ans.push_back(cur);\\n                            for(auto xx: gr[cur])\\n                            {\\n                                if(vis[xx]==false)\\n                                {\\n                                    vis[xx]=true;\\n                                    cnt++;\\n                                    Q.push(xx);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto y:ans)\\n            {\\n                x.push_back(y);\\n            }\\n        }\\n        \\n        for(auto x:vis)\\n        {\\n            if(x==false)\\n            {\\n                pos=false;\\n                return 0;\\n            }\\n        }\\n        \\n        vector<int> mark(n);\\n        int m = goodBlue.size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(auto x:goodBlue[i])\\n            {\\n                mark[x] = i;\\n            }\\n        }\\n        \\n        vector<vector<int>> newGraph(m);\\n        for(int i=0;i<n;i++)\\n        {\\n            int his = mark[i];\\n            for(auto x:gr[i])\\n            {\\n                if(mark[x]!=his)\\n                {\\n                    newGraph[his].push_back(mark[x]);\\n                    newGraph[mark[x]].push_back(his);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> newVis(m,false);\\n        \\n        newVis[0]=true;\\n        queue<int> Q;\\n        Q.push(0);\\n        int cnt2 = 0;\\n        while(Q.size())\\n        {\\n            int cur = Q.front();\\n            Q.pop();\\n            for(auto xx: newGraph[cur])\\n            {\\n                if(newVis[xx]==false)\\n                {\\n                    newVis[xx]=true;\\n                    cnt2++;\\n                    Q.push(xx);\\n                }\\n            }\\n        }\\n        \\n        if(cnt2<m-1)\\n        {\\n                pos=false;\\n                return 0;\\n        }\\n        \\n        \\n        return cnt+cnt2;\\n    }\\n    \\n    int goodBlueCount(vector<vector<int>> &gr,vector<vector<int>> &goodBlue,vector<bool> &vis)\\n    {\\n        int cnt=0,i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(gr[i].size()&&vis[i]==false)\\n            {\\n                vector<int> emp;\\n                goodBlue.push_back(emp);\\n                vector<int> &ans = goodBlue.back();\\n                queue<int> Q;\\n                Q.push(i);\\n                vis[i]=true;\\n                while(Q.size())\\n                {\\n                    int cur = Q.front();\\n                    Q.pop();\\n                    ans.push_back(cur);\\n                    for(auto x: gr[cur])\\n                    {\\n                        if(vis[x]==false)\\n                        {\\n                            vis[x]=true;\\n                            cnt++;\\n                            Q.push(x);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n\\n    bool BFS(vector<vector<int>> &newGraph,vector<bool> newVis)\\n    {\\n        \\n        newVis[0]=true;\\n        queue<int> Q;\\n        Q.push(0);\\n        int cnt2 = 0;\\n        while(Q.size())\\n        {\\n            int cur = Q.front();\\n            Q.pop();\\n            for(auto xx: newGraph[cur])\\n            {\\n                if(newVis[xx]==false)\\n                {\\n                    newVis[xx]=true;\\n                    cnt2++;\\n                    Q.push(xx);\\n                }\\n            }\\n        }\\n        return cnt2==n-1;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        this-> n =n;\\n        int typeCnt[3] = {0,0,0};\\n        vector<vector<int>> blue(n);\\n        vector<vector<int>> red(n);\\n        vector<vector<int>> green(n);\\n        for(auto x:edges)\\n        {\\n            typeCnt[x[0]-1]++;\\n            \\n            //R\\n            if(x[0]==1)\\n            {\\n                red[x[2]-1].push_back(x[1]-1);\\n                red[x[1]-1].push_back(x[2]-1);\\n            }\\n            //G\\n            else if(x[0]==2)\\n            {\\n                green[x[2]-1].push_back(x[1]-1);\\n                green[x[1]-1].push_back(x[2]-1);\\n            }\\n            //B\\n            else\\n            {\\n                blue[x[2]-1].push_back(x[1]-1);\\n                blue[x[1]-1].push_back(x[2]-1);\\n            }\\n        }\\n        pos=true;\\n        vector<vector<int>> goodBlue;\\n        vector<bool> vis(n,false);\\n        int blueCnt = goodBlueCount(blue,goodBlue,vis);\\n        if(blueCnt)\\n        {\\n            int redCnt = seprateCount(red,goodBlue,vis);\\n            if(pos==false)\\n                return -1;\\n\\n            int greenCnt = seprateCount(green,goodBlue,vis);\\n            if(pos==false)\\n                return -1;\\n\\n            return typeCnt[0]+typeCnt[1]+typeCnt[2]-(blueCnt+redCnt+greenCnt);\\n        }\\n        else\\n        {\\n            if(BFS(red,vis)&&BFS(green,vis))\\n            {\\n                return 0;\\n            }\\n            return -1;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831955,
                "title": "c",
                "content": "``` \\n\\n//the idea is bascially union find // first do union find for type 3 edges and keep  counter of extra edges \\n//after that n using the previous union find array do union find fortyep 1 and type 2 respecitvely  and inceremnt the count of random  edges \\n\\nclass Solution {\\npublic:  \\n    int find(vector<int>&p,int a)\\n    {\\n      if(p[a]==-1)\\n      {\\n          return a; \\n      }\\n       \\n      p[a]=find(p,p[a]); \\n       \\n      return p[a];   \\n    }\\n    int unionn(vector<int>&p,int a,int b)\\n    {\\n        int  x,y;  \\n        x=find(p,a);  \\n        y=find(p,b); \\n        \\n        if(x==y)\\n        {\\n            return 1; \\n        }\\n        \\n        p[x]=y;  \\n        return 0;  \\n        \\n    }  \\n     int find2(vector<int>&p,int a)\\n    {\\n      if(p[a]==-1)\\n      {\\n          return a; \\n      }\\n       \\n      p[a]=find(p,p[a]); \\n       \\n      return p[a];   \\n    }\\n    \\n        int unionn2(vector<int>&p,int a,int b)\\n    {\\n        int  x,y;  \\n        x=find2(p,a);  \\n        y=find2(p,b); \\n        \\n        if(x==y)\\n        {\\n            return 1; \\n        }\\n        \\n        p[x]=y;  \\n        return 0;  \\n        \\n    } \\n    \\n      int solve(int n, vector<vector<int>>& e,int x,vector<int>p)\\n    {\\n        \\n        map<int,bool>vis;  \\n        \\n        int i,j,k,l,ans=0; \\n        \\n     \\n        for(i=0;i<e.size();i++)\\n        {\\n            if(e[i][0]==x)\\n            {  \\n               vis[e[i][1]]=true; \\n               vis[e[i][2]]=true;   \\n               ans=ans+unionn2(p,e[i][1],e[i][2]);  \\n            }\\n            if(e[i][0]==3)\\n            {\\n                vis[e[i][1]]=true; \\n               vis[e[i][2]]=true;   \\n            }\\n        }\\n        \\n        \\n        for(i=1;i<=n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n\\n        \\n        return ans;  \\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& e) {\\n       \\n       vector<int>p(n+1,-1); \\n       int  i,j,k,l,ans;  \\n       ans=0;  \\n        \\n       for(i=0;i<e.size();i++)\\n       {\\n            if(e[i][0]==3)\\n            {\\n               ans+=unionn(p,e[i][1],e[i][2]);  \\n            }\\n           \\n       }\\n       \\n       int alice,bob;  \\n        \\n       alice=solve(n,e,1,p); \\n        \\n        if(alice==-1)\\n        {\\n            return -1; \\n        }\\n        \\n        bob=solve(n,e,2,p); \\n        \\n        if(bob==-1)\\n        {\\n            return -1;\\n        }\\n        \\n         return ans+alice+bob; \\n        \\n        \\n    } \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:  \\n    int find(vector<int>&p,int a)\\n    {\\n      if(p[a]==-1)\\n      {\\n          return a; \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 831737,
                "title": "java-combine-the-msts-o-n-e-log-e-easy-to-understand",
                "content": "Algorithm:\\n1. Calculate MSTs for both Alice and Bob.\\n2. Combine these MSTs via intersection.\\n3. Answer is total num edges - num combined MSTs edges.\\n\\nKey idea:\\n- When computing the MSTs, the shared edge has higher priority.\\n\\nUsed Kruskalls algorithm (union find) to calculate MSTs.\\n\\n![image](https://assets.leetcode.com/users/images/e6d44e0a-9f9e-478d-895b-840fc17d6489_1599376341.7511034.png)\\n\\n```\\nclass Solution {\\n  public int maxNumEdgesToRemove(int n, int[][] edges) {\\n    // solution: make MST for both bob and alice\\n    // combine MSTs by taking intersection\\n    // difference of total num edges - combined MST = num edges can be removed\\n\\n    // {cost, src, dst}\\n    List<List<Integer>> aliceEdge = new ArrayList<>();\\n    List<List<Integer>> bobEdge = new ArrayList<>();\\n    for (int[] edge : edges) {\\n      if (edge[0] == 3) {\\n        // favour combined edge in MST calculation by making its cost cheaper\\n        aliceEdge.add(Arrays.asList(1, edge[1], edge[2]));\\n        bobEdge.add(Arrays.asList(1, edge[1], edge[2]));\\n      } else if (edge[0] == 1) {\\n        aliceEdge.add(Arrays.asList(2, edge[1], edge[2]));\\n      } else if (edge[0] == 2) {\\n        // use different cost to alice so combined mst considers them differently (i.e. in the Set.addAll)\\n        // wont have the unshared edges in same MST calculation so doesn\\'t matter as long as > combined edge cost\\n        bobEdge.add(Arrays.asList(4, edge[1], edge[2]));\\n      }\\n    }\\n\\n    Set<List<Integer>> aliceMst = mst(n, aliceEdge);\\n    if (aliceMst.size() != n - 1) {\\n      return -1;\\n    }\\n    Set<List<Integer>> bobMst = mst(n, bobEdge);\\n    if (bobMst.size() != n - 1) {\\n      return -1;\\n    }\\n\\n    // intersection\\n    Set<List<Integer>> combinedMst = new HashSet<>();\\n    combinedMst.addAll(aliceMst);\\n    combinedMst.addAll(bobMst);\\n\\n    return edges.length - combinedMst.size();\\n  }\\n\\n  private int[] parent;\\n\\n  // kruskals algorithm\\n  private Set<List<Integer>> mst(int n, List<List<Integer>> edges) {\\n    // make n sets\\n    parent = IntStream.rangeClosed(0, n).toArray();\\n    // sort so try cheapest edges first\\n    edges.sort(Comparator.comparing(list -> list.get(0)));\\n\\n    Set<List<Integer>> mstEdges = new HashSet<>();\\n\\n    // process edges until mst found or ran out of edges\\n    for (int i = 0; i < edges.size() && mstEdges.size() < n - 1; i++) {\\n      List<Integer> edge = edges.get(i);\\n      int src = edge.get(1);\\n      int dst = edge.get(2);\\n\\n      int srcSet = find(src);\\n      int dstSet = find(dst);\\n\\n      if (srcSet != dstSet) {\\n        // nodes in different tree, merge trees\\n        union(srcSet, dstSet);\\n        mstEdges.add(edge);\\n      }\\n    }\\n    return mstEdges;\\n  }\\n\\n  private void union(int a, int b) {\\n    parent[find(a)] = find(b);\\n  }\\n\\n  private int find(int a) {\\n    if (a != parent[a]) {\\n      parent[a] = find(parent[a]);\\n    }\\n    return parent[a];\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int maxNumEdgesToRemove(int n, int[][] edges) {\\n    // solution: make MST for both bob and alice\\n    // combine MSTs by taking intersection\\n    // difference of total num edges - combined MST = num edges can be removed\\n\\n    // {cost, src, dst}\\n    List<List<Integer>> aliceEdge = new ArrayList<>();\\n    List<List<Integer>> bobEdge = new ArrayList<>();\\n    for (int[] edge : edges) {\\n      if (edge[0] == 3) {\\n        // favour combined edge in MST calculation by making its cost cheaper\\n        aliceEdge.add(Arrays.asList(1, edge[1], edge[2]));\\n        bobEdge.add(Arrays.asList(1, edge[1], edge[2]));\\n      } else if (edge[0] == 1) {\\n        aliceEdge.add(Arrays.asList(2, edge[1], edge[2]));\\n      } else if (edge[0] == 2) {\\n        // use different cost to alice so combined mst considers them differently (i.e. in the Set.addAll)\\n        // wont have the unshared edges in same MST calculation so doesn\\'t matter as long as > combined edge cost\\n        bobEdge.add(Arrays.asList(4, edge[1], edge[2]));\\n      }\\n    }\\n\\n    Set<List<Integer>> aliceMst = mst(n, aliceEdge);\\n    if (aliceMst.size() != n - 1) {\\n      return -1;\\n    }\\n    Set<List<Integer>> bobMst = mst(n, bobEdge);\\n    if (bobMst.size() != n - 1) {\\n      return -1;\\n    }\\n\\n    // intersection\\n    Set<List<Integer>> combinedMst = new HashSet<>();\\n    combinedMst.addAll(aliceMst);\\n    combinedMst.addAll(bobMst);\\n\\n    return edges.length - combinedMst.size();\\n  }\\n\\n  private int[] parent;\\n\\n  // kruskals algorithm\\n  private Set<List<Integer>> mst(int n, List<List<Integer>> edges) {\\n    // make n sets\\n    parent = IntStream.rangeClosed(0, n).toArray();\\n    // sort so try cheapest edges first\\n    edges.sort(Comparator.comparing(list -> list.get(0)));\\n\\n    Set<List<Integer>> mstEdges = new HashSet<>();\\n\\n    // process edges until mst found or ran out of edges\\n    for (int i = 0; i < edges.size() && mstEdges.size() < n - 1; i++) {\\n      List<Integer> edge = edges.get(i);\\n      int src = edge.get(1);\\n      int dst = edge.get(2);\\n\\n      int srcSet = find(src);\\n      int dstSet = find(dst);\\n\\n      if (srcSet != dstSet) {\\n        // nodes in different tree, merge trees\\n        union(srcSet, dstSet);\\n        mstEdges.add(edge);\\n      }\\n    }\\n    return mstEdges;\\n  }\\n\\n  private void union(int a, int b) {\\n    parent[find(a)] = find(b);\\n  }\\n\\n  private int find(int a) {\\n    if (a != parent[a]) {\\n      parent[a] = find(parent[a]);\\n    }\\n    return parent[a];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831513,
                "title": "java-union-find-o-n",
                "content": "Let\\nc1: number of connected components using type 1 edges only\\nc2: number of connected components using type 1  and type 2 edges \\nc3: number of connected components using type 1  and type 3 edges \\n=>\\ncase 1: The graph is not connected for Alice or Bob, return -1\\ncase 2: The graph is connected for Alice and Bob, return **number of edges - ((number of vertices - c3) + (c3 -1) + (c3 -1))**\\n```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        DSU dsu3 = new DSU(n);\\n        DSU dsu2 = new DSU(n);\\n        DSU dsu1 = new DSU(n);\\n        for(int[] e : edges){\\n            int type = e[0];\\n            if(type==3){\\n                dsu3.union(e[1]-1, e[2]-1);\\n                dsu2.union(e[1]-1, e[2]-1);\\n                dsu1.union(e[1]-1, e[2]-1);\\n            }\\n            else if(type==2){\\n                dsu2.union(e[1]-1, e[2]-1);\\n            }\\n            else{\\n                dsu1.union(e[1]-1, e[2]-1);\\n            }\\n        }\\n        int c1 = dsu1.components;\\n        int c2 = dsu2.components;\\n        if(c1!=1 || c2!=1){\\n            return -1;\\n        }\\n        int c3 = dsu3.components;\\n        int need = n-c3 + c3-1 + c3-1;\\n        return edges.length-need;\\n    }\\n    \\n    class DSU{\\n        int[] parent;\\n        int[] size;\\n        int components;\\n\\n        public DSU(int N){\\n            components = N;\\n            parent = new int[N];\\n            size = new int[N];\\n            for(int i=0; i<parent.length; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int x){\\n            if(parent[x]!=x){\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n\\n        public int union(int x, int y){\\n            int xParent = find(x);\\n            int yParent = find(y);\\n            if(xParent==yParent) return size[xParent];\\n            components--;\\n            if(size[xParent]<=size[yParent]){\\n                parent[xParent] = yParent;\\n                size[yParent]+=size[xParent];\\n                return size[yParent];\\n            }\\n            else{\\n                parent[yParent] = xParent;\\n                size[xParent] += size[yParent];\\n                return size[xParent];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        DSU dsu3 = new DSU(n);\\n        DSU dsu2 = new DSU(n);\\n        DSU dsu1 = new DSU(n);\\n        for(int[] e : edges){\\n            int type = e[0];\\n            if(type==3){\\n                dsu3.union(e[1]-1, e[2]-1);\\n                dsu2.union(e[1]-1, e[2]-1);\\n                dsu1.union(e[1]-1, e[2]-1);\\n            }\\n            else if(type==2){\\n                dsu2.union(e[1]-1, e[2]-1);\\n            }\\n            else{\\n                dsu1.union(e[1]-1, e[2]-1);\\n            }\\n        }\\n        int c1 = dsu1.components;\\n        int c2 = dsu2.components;\\n        if(c1!=1 || c2!=1){\\n            return -1;\\n        }\\n        int c3 = dsu3.components;\\n        int need = n-c3 + c3-1 + c3-1;\\n        return edges.length-need;\\n    }\\n    \\n    class DSU{\\n        int[] parent;\\n        int[] size;\\n        int components;\\n\\n        public DSU(int N){\\n            components = N;\\n            parent = new int[N];\\n            size = new int[N];\\n            for(int i=0; i<parent.length; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int x){\\n            if(parent[x]!=x){\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n\\n        public int union(int x, int y){\\n            int xParent = find(x);\\n            int yParent = find(y);\\n            if(xParent==yParent) return size[xParent];\\n            components--;\\n            if(size[xParent]<=size[yParent]){\\n                parent[xParent] = yParent;\\n                size[yParent]+=size[xParent];\\n                return size[yParent];\\n            }\\n            else{\\n                parent[yParent] = xParent;\\n                size[xParent] += size[yParent];\\n                return size[xParent];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941994,
                "title": "c-union-find-solution",
                "content": "## Overview\\nThe problem revolves around removing edges from a graph while adhering to specific connectivity conditions. The solution employs the Union-Find data structure to effectively manage the connected components of the graph while accommodating different types of edges. \\n\\n## Approach\\nThe approach can be summarized in the following steps:\\n\\n1. **Initialization**: Create separate Union-Find instances for Alice and Bob. Initialize each vertex as its own parent. Set up a counter `ans` to keep track of the number of edges to be removed.\\n\\n2. **Edge Sorting**: Sort the given edges in descending order based on their types. This ensures that type 3 edges are processed first, as they have implications for both Alice\\'s and Bob\\'s components.\\n\\n3. **Edge Iteration**: Process each edge in the sorted list:\\n   - **Type 3 edges**: If the parents of vertices in both Alice\\'s and Bob\\'s components are different, perform a union operation to connect them. If the vertices are already in the same component for either player, increment the `ans` counter.\\n   - **Type 2 edges**: If the parents of vertices in Alice\\'s component are different, unite them using a union operation. If the vertices are already connected, increment `ans`.\\n   - **Type 1 edges**: Similarly, unite vertices\\' parents in Bob\\'s component or increment `ans` if necessary.\\n\\n4. **Final Check**: After processing all edges, confirm that both Alice and Bob have a maximum connected component size equal to the total vertex count `n`. If not, the graph is disconnected, and the function returns -1.\\n\\n5. **Returning Result**: Finally, return the `ans` counter, indicating the maximum count of edges that can be removed while maintaining the desired component structure.\\n\\n## Complexity Analysis\\n- **Time Complexity**: The sorting of edges dominates the time complexity, resulting in O(E * log E), where E is the edge count. The Union-Find operations contribute O(E * \\u03B1(V)), where \\u03B1(V) is the inverse Ackermann function.\\n- **Space Complexity**: The space complexity is O(n) for the Union-Find structures and additional variables.\\n\\n\\n\\n# Code\\n```\\nclass UnionFind{\\npublic:\\n    vector<int> parent,sizes;\\n    UnionFind(int n)\\n    {\\n        parent.resize(n);\\n        sizes.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n            sizes[i]=1;\\n        }\\n    }\\n    int findParent(int v)\\n    {\\n        if(parent[v]==v) return v;\\n        return parent[v]=findParent(parent[v]);\\n    }\\n    void Union(int a,int b)\\n    {\\n        a=findParent(a);\\n        b=findParent(b);\\n        if(a!=b)\\n        {\\n            if(sizes[b]>sizes[a]) swap(b,a);\\n            parent[b]=a;\\n            sizes[a]+=sizes[b];\\n        }\\n    }\\n    int maxSize()\\n    {\\n        int cnt=0;\\n        for(auto i:sizes)\\n        {\\n            cnt=max(cnt,i);\\n        }\\n        return cnt;\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[0]>b[0];\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind alice(n),bob(n);\\n        sort(edges.begin(),edges.end(),comp);\\n        int ans=0;\\n        for(auto i:edges)\\n        {\\n            int type=i[0];\\n            int u=i[1]-1;\\n            int v=i[2]-1;\\n            if(type==3)\\n            {\\n                if(alice.findParent(u)!=alice.findParent(v))\\n                {\\n                    alice.Union(u,v);\\n                    bob.Union(u,v);\\n                }\\n                else\\n                {\\n                    ans++;\\n                }\\n            }\\n            else if(type==2)\\n            {\\n                if(alice.findParent(u)!=alice.findParent(v))\\n                {\\n                    alice.Union(u,v);\\n                }\\n                else ans++;\\n            }\\n            else\\n            {\\n                if(bob.findParent(u)!=bob.findParent(v))\\n                {\\n                    bob.Union(u,v);\\n                }\\n                else ans++;\\n            }\\n        }\\n        if(alice.maxSize()!=n||bob.maxSize()!=n) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind{\\npublic:\\n    vector<int> parent,sizes;\\n    UnionFind(int n)\\n    {\\n        parent.resize(n);\\n        sizes.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n            sizes[i]=1;\\n        }\\n    }\\n    int findParent(int v)\\n    {\\n        if(parent[v]==v) return v;\\n        return parent[v]=findParent(parent[v]);\\n    }\\n    void Union(int a,int b)\\n    {\\n        a=findParent(a);\\n        b=findParent(b);\\n        if(a!=b)\\n        {\\n            if(sizes[b]>sizes[a]) swap(b,a);\\n            parent[b]=a;\\n            sizes[a]+=sizes[b];\\n        }\\n    }\\n    int maxSize()\\n    {\\n        int cnt=0;\\n        for(auto i:sizes)\\n        {\\n            cnt=max(cnt,i);\\n        }\\n        return cnt;\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[0]>b[0];\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind alice(n),bob(n);\\n        sort(edges.begin(),edges.end(),comp);\\n        int ans=0;\\n        for(auto i:edges)\\n        {\\n            int type=i[0];\\n            int u=i[1]-1;\\n            int v=i[2]-1;\\n            if(type==3)\\n            {\\n                if(alice.findParent(u)!=alice.findParent(v))\\n                {\\n                    alice.Union(u,v);\\n                    bob.Union(u,v);\\n                }\\n                else\\n                {\\n                    ans++;\\n                }\\n            }\\n            else if(type==2)\\n            {\\n                if(alice.findParent(u)!=alice.findParent(v))\\n                {\\n                    alice.Union(u,v);\\n                }\\n                else ans++;\\n            }\\n            else\\n            {\\n                if(bob.findParent(u)!=bob.findParent(v))\\n                {\\n                    bob.Union(u,v);\\n                }\\n                else ans++;\\n            }\\n        }\\n        if(alice.maxSize()!=n||bob.maxSize()!=n) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667964,
                "title": "beating-98-69-python-easiest-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/8987b23f-57ef-4481-9c55-3d5a960eac19_1687410494.8892117.png)\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def dfs(self,vis,li,com,i):\\n        if(vis[i]):\\n            return 0\\n        vis[i]=com\\n        ans=1\\n        for j in li[i]:\\n            ans+=self.dfs(vis,li,com,j)\\n        return ans\\n\\n    def maxNumEdgesToRemove(self, n: int, e: List[List[int]]) -> int:\\n        ans=0\\n        li=[[] for i in range(n)]\\n        for l in e:\\n            if(l[0]==3):\\n                li[l[1]-1].append(l[2]-1)\\n                li[l[2]-1].append(l[1]-1)\\n        vis=[0 for i in range(n)]\\n        com=0\\n        for i in range(n):\\n            if(vis[i]):\\n                continue\\n            else:\\n                com+=1\\n                temp=self.dfs(vis,li,com,i)\\n                ans+=(temp-1)\\n        lia=[[] for i in range(com)]\\n        lib=[[] for i in range(com)]\\n        for l in e:\\n            if(l[0]==1):\\n                a=vis[l[1]-1]-1\\n                b=vis[l[2]-1]-1\\n                if(a==b):\\n                    continue\\n                lia[a].append(b)\\n                lia[b].append(a)\\n            elif(l[0]==2):\\n                a=vis[l[1]-1]-1\\n                b=vis[l[2]-1]-1\\n                if(a==b):\\n                    continue\\n                lib[a].append(b)\\n                lib[b].append(a)\\n        visa=[0 for i in range(com)]\\n        coma=0\\n        comb=0\\n        for i in range(com):\\n            if(visa[i]):\\n                continue\\n            else:\\n                coma+=1\\n                if(coma>1):\\n                    return -1\\n                self.dfs(visa,lia,coma,i)\\n        \\n        visb=[0 for i in range(com)]\\n        for i in range(com):\\n            if(visb[i]):\\n                continue\\n            else:\\n                comb+=1\\n                if(comb>1):\\n                    return -1\\n                self.dfs(visb,lib,comb,i)\\n        if(coma>1 or comb>1):\\n            return -1\\n        ans+=(com-1)*2\\n        return len(e)-ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def dfs(self,vis,li,com,i):\\n        if(vis[i]):\\n            return 0\\n        vis[i]=com\\n        ans=1\\n        for j in li[i]:\\n            ans+=self.dfs(vis,li,com,j)\\n        return ans\\n\\n    def maxNumEdgesToRemove(self, n: int, e: List[List[int]]) -> int:\\n        ans=0\\n        li=[[] for i in range(n)]\\n        for l in e:\\n            if(l[0]==3):\\n                li[l[1]-1].append(l[2]-1)\\n                li[l[2]-1].append(l[1]-1)\\n        vis=[0 for i in range(n)]\\n        com=0\\n        for i in range(n):\\n            if(vis[i]):\\n                continue\\n            else:\\n                com+=1\\n                temp=self.dfs(vis,li,com,i)\\n                ans+=(temp-1)\\n        lia=[[] for i in range(com)]\\n        lib=[[] for i in range(com)]\\n        for l in e:\\n            if(l[0]==1):\\n                a=vis[l[1]-1]-1\\n                b=vis[l[2]-1]-1\\n                if(a==b):\\n                    continue\\n                lia[a].append(b)\\n                lia[b].append(a)\\n            elif(l[0]==2):\\n                a=vis[l[1]-1]-1\\n                b=vis[l[2]-1]-1\\n                if(a==b):\\n                    continue\\n                lib[a].append(b)\\n                lib[b].append(a)\\n        visa=[0 for i in range(com)]\\n        coma=0\\n        comb=0\\n        for i in range(com):\\n            if(visa[i]):\\n                continue\\n            else:\\n                coma+=1\\n                if(coma>1):\\n                    return -1\\n                self.dfs(visa,lia,coma,i)\\n        \\n        visb=[0 for i in range(com)]\\n        for i in range(com):\\n            if(visb[i]):\\n                continue\\n            else:\\n                comb+=1\\n                if(comb>1):\\n                    return -1\\n                self.dfs(visb,lib,comb,i)\\n        if(coma>1 or comb>1):\\n            return -1\\n        ans+=(com-1)*2\\n        return len(e)-ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475289,
                "title": "java-union-find-solution-with-comments",
                "content": "# Intuition\\nQuick lesson on Disjoint-set (Union Find) and how we will use it:\\n\\nThe Union Find data structure is typically used to maintain a partition of a set of elements. The nodes in the graph correspond to the elements and we are partioning them based on which component of the graph they belong to. So we are going to go through the edges of the graph and partition the nodes. We will use the Union Find data structure to find the components of a graph. Furthermore we will use this data structure to determine if a graph is connected. A graph is connected if there is a path from any node to any other node in the graph. \\n\\nNodes that are a part of the same component are in the same set.\\n\\n# Approach\\nWe maintain several variables, `count`, `aliceCount` and `bobCount`, which is the number of edges both alice and bob, alice, bob, can take that we are going to keep in the graph, respectively. We need separate `UnionFind` data structures for alice, bob, and alice and bob, `ufAlice`, `ufBob`, `ufBoth`, respectively.\\n\\nWe go through edges and perform union on edges that both alice and bob can take, we take an edge if it connects components. If it connects components we add 1 to the `count` variable.\\n\\nWe go through edges again and consider edges only bob or only alice can take, perform union and only take an edge if it connects components.\\n\\nSuppose we are considering an edge only alice or bob can take, if this edge connects components that are not already connected by the edges both alice and bob can take, we need to take it. If it connects components we add 1 to the corresponding count variable, either `aliceCount` or `bobCount`.\\n\\nWe then check if the graph is connected (can be fully traversed by both Alice and Bob). We do this by calling the `isConnected` method on both `ufAlice` and `ufBob`. Since we know that if a graph is connected then there is only 1 set that all nodes in the graph belong to. The `isConnected` method builds the set of components and checks that the size is equal to 1, corresponding to the graph being connected. We then return the number of edges that were originally in the graph minus the ones we took, this gives us how many edges we could remove.\\n\\n# Complexity\\n- Time Complexity:\\n\\nThe find operation has a time complexity of $ O(\\\\alpha (n)) $, where $ \\\\alpha (n) $ is the inverse Ackermann function. In practice, $\\\\alpha (n) $ is very small and can be considered constant, so the time complexity of the find operation is effectively $O(1)$.\\n\\nThe union operation has a time complexity of $ O(\\\\alpha (n)) $ as well, since it involves performing two find operations and updating a parent pointer. Therefore, the time complexity of a sequence of $m$ union-find operations is $ O(m \\\\alpha (n)) $.\\n\\n- Space Complexity:\\n\\nThe space complexity of the union-find data structure is $O(n)$, where $n$ is the number of elements in the set. This is because each element is initially represented by its own set, and each set has a parent pointer and possibly a size or rank value.\\n\\n# Code\\n```\\nclass Solution {\\n    class UnionFind {\\n        int n;\\n        int[] parent;\\n\\n        public UnionFind(UnionFind other) {\\n            this.n = other.n;\\n            this.parent = new int[this.n+1];\\n            for (int i = 1; i <= this.n; i++) {\\n                this.parent[i] = other.parent[i];\\n            }\\n        }\\n\\n        public UnionFind(int n) {\\n            this.n = n;\\n            parent = new int[n+1];\\n            for (int i = 1; i <= n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        public int find(int node) {\\n            int root = parent[node];\\n            int currNode = node;\\n            while (root != currNode) {\\n                currNode = root;\\n                root = parent[currNode];\\n            }\\n\\n            currNode = node;\\n            while (root != currNode) {\\n                int tmp = parent[currNode];\\n                parent[currNode] = root;\\n                currNode = tmp;                \\n            }\\n            return root;\\n        }\\n\\n        public boolean union(int nodeA, int nodeB) {\\n            int rootA = find(nodeA);\\n            int rootB = find(nodeB);\\n            if (rootA == rootB) {\\n                return false;\\n            }\\n            parent[rootB] = rootA;\\n            return true;\\n        }\\n\\n        public boolean isConnected() {\\n            Set<Integer> components = new HashSet<>();\\n            for (int i = 1; i <= n; i++) {\\n                components.add(find(i));\\n            }\\n            return components.size() == 1;\\n        }\\n    }\\n\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int count = 0;\\n        UnionFind ufBoth = new UnionFind(n);\\n        for (int[] edge : edges) {\\n            int type = edge[0];\\n            int u = edge[1];\\n            int v = edge[2];\\n            if (type == 3) {\\n                if (ufBoth.union(u, v)) {\\n                    count += 1;\\n                }\\n            }\\n        }\\n\\n        UnionFind ufAlice = new UnionFind(ufBoth);\\n        UnionFind ufBob = new UnionFind(ufBoth);\\n        int aliceCount = 0;\\n        int bobCount = 0;\\n        for (int[] edge : edges) {\\n            int type = edge[0];\\n            int u = edge[1];\\n            int v = edge[2];\\n            if (type == 1) {\\n                if (ufAlice.union(u, v)) {\\n                    aliceCount += 1; \\n                }\\n            }\\n            if (type == 2) {\\n                if (ufBob.union(u, v)) {\\n                    bobCount += 1; \\n                }\\n            }\\n        }\\n        return ufAlice.isConnected() && ufBob.isConnected() ? edges.length - count - aliceCount - bobCount : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        int n;\\n        int[] parent;\\n\\n        public UnionFind(UnionFind other) {\\n            this.n = other.n;\\n            this.parent = new int[this.n+1];\\n            for (int i = 1; i <= this.n; i++) {\\n                this.parent[i] = other.parent[i];\\n            }\\n        }\\n\\n        public UnionFind(int n) {\\n            this.n = n;\\n            parent = new int[n+1];\\n            for (int i = 1; i <= n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        public int find(int node) {\\n            int root = parent[node];\\n            int currNode = node;\\n            while (root != currNode) {\\n                currNode = root;\\n                root = parent[currNode];\\n            }\\n\\n            currNode = node;\\n            while (root != currNode) {\\n                int tmp = parent[currNode];\\n                parent[currNode] = root;\\n                currNode = tmp;                \\n            }\\n            return root;\\n        }\\n\\n        public boolean union(int nodeA, int nodeB) {\\n            int rootA = find(nodeA);\\n            int rootB = find(nodeB);\\n            if (rootA == rootB) {\\n                return false;\\n            }\\n            parent[rootB] = rootA;\\n            return true;\\n        }\\n\\n        public boolean isConnected() {\\n            Set<Integer> components = new HashSet<>();\\n            for (int i = 1; i <= n; i++) {\\n                components.add(find(i));\\n            }\\n            return components.size() == 1;\\n        }\\n    }\\n\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int count = 0;\\n        UnionFind ufBoth = new UnionFind(n);\\n        for (int[] edge : edges) {\\n            int type = edge[0];\\n            int u = edge[1];\\n            int v = edge[2];\\n            if (type == 3) {\\n                if (ufBoth.union(u, v)) {\\n                    count += 1;\\n                }\\n            }\\n        }\\n\\n        UnionFind ufAlice = new UnionFind(ufBoth);\\n        UnionFind ufBob = new UnionFind(ufBoth);\\n        int aliceCount = 0;\\n        int bobCount = 0;\\n        for (int[] edge : edges) {\\n            int type = edge[0];\\n            int u = edge[1];\\n            int v = edge[2];\\n            if (type == 1) {\\n                if (ufAlice.union(u, v)) {\\n                    aliceCount += 1; \\n                }\\n            }\\n            if (type == 2) {\\n                if (ufBob.union(u, v)) {\\n                    bobCount += 1; \\n                }\\n            }\\n        }\\n        return ufAlice.isConnected() && ufBob.isConnected() ? edges.length - count - aliceCount - bobCount : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471501,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct DisjointUnionSets\\n    {\\n    int *rank,*parent;\\n    int x;\\n    DisjointUnionSets(int n)\\n    {\\n        rank=new int[n];\\n        parent=new int[n];\\n        x=n;\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    bool Union(int x,int y)\\n    {\\n        int xRoot=find(x),yRoot=find(y);\\n        if(xRoot == yRoot)\\n            return false;\\n        if(rank[xRoot] < rank[yRoot])\\n            parent[xRoot]=yRoot;\\n        else if (rank[xRoot] > rank[yRoot])\\n            parent[yRoot]=xRoot;\\n        else\\n        {\\n            parent[yRoot]=xRoot;\\n            rank[xRoot]++;\\n        }\\n        return true;\\n    }\\n};\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges)\\n     {\\n        int size=edges.size();\\n        vector<pair<int,int>> alice;\\n        vector<pair<int,int>> bob;\\n        vector<pair<int,int>> both;\\n        for(int i=0;i<size;i++)\\n        {\\n            int temp=edges[i][0];\\n            if(temp==1)\\n                alice.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n            else if(temp==2)\\n                bob.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n            else\\n                both.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n        }\\n        DisjointUnionSets a(n),b(n);\\n        int res=0,componentA=n,componentB=n;\\n        for(auto x:both){\\n            bool flag1=a.Union(x.first,x.second);\\n            bool flag2=b.Union(x.first,x.second);\\n            if(flag1)\\n                componentA--;\\n            if(flag2)\\n                componentB--;\\n            if(flag1 && flag2)\\n                res++;\\n        }\\n        for(auto x:alice){\\n            bool flag=a.Union(x.first,x.second);\\n            if(flag)\\n            {\\n                componentA--;\\n                res++;\\n            }\\n        }\\n        for(auto x:bob)\\n        {\\n            bool flag=b.Union(x.first,x.second);\\n            if(flag)\\n            {\\n                componentB--;\\n                res++;\\n            }\\n        }\\n        if(componentA!=1 ||componentB!=1)\\n            return -1;\\n        return size-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct DisjointUnionSets\\n    {\\n    int *rank,*parent;\\n    int x;\\n    DisjointUnionSets(int n)\\n    {\\n        rank=new int[n];\\n        parent=new int[n];\\n        x=n;\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    bool Union(int x,int y)\\n    {\\n        int xRoot=find(x),yRoot=find(y);\\n        if(xRoot == yRoot)\\n            return false;\\n        if(rank[xRoot] < rank[yRoot])\\n            parent[xRoot]=yRoot;\\n        else if (rank[xRoot] > rank[yRoot])\\n            parent[yRoot]=xRoot;\\n        else\\n        {\\n            parent[yRoot]=xRoot;\\n            rank[xRoot]++;\\n        }\\n        return true;\\n    }\\n};\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges)\\n     {\\n        int size=edges.size();\\n        vector<pair<int,int>> alice;\\n        vector<pair<int,int>> bob;\\n        vector<pair<int,int>> both;\\n        for(int i=0;i<size;i++)\\n        {\\n            int temp=edges[i][0];\\n            if(temp==1)\\n                alice.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n            else if(temp==2)\\n                bob.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n            else\\n                both.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n        }\\n        DisjointUnionSets a(n),b(n);\\n        int res=0,componentA=n,componentB=n;\\n        for(auto x:both){\\n            bool flag1=a.Union(x.first,x.second);\\n            bool flag2=b.Union(x.first,x.second);\\n            if(flag1)\\n                componentA--;\\n            if(flag2)\\n                componentB--;\\n            if(flag1 && flag2)\\n                res++;\\n        }\\n        for(auto x:alice){\\n            bool flag=a.Union(x.first,x.second);\\n            if(flag)\\n            {\\n                componentA--;\\n                res++;\\n            }\\n        }\\n        for(auto x:bob)\\n        {\\n            bool flag=b.Union(x.first,x.second);\\n            if(flag)\\n            {\\n                componentB--;\\n                res++;\\n            }\\n        }\\n        if(componentA!=1 ||componentB!=1)\\n            return -1;\\n        return size-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471379,
                "title": "c-double-disjoint-set-100-time-460ms-60-space-139-9mb",
                "content": "This problem revolves around finding the cheapest way to connect all nodes to both the Alice and Bob\\'s clusters.\\n\\nIt is clearly cheaper to use as many as possible of the edges of type `3`, since they will do the work of two bridges of the other kind, the ones we will try to use only to connect the nodes that were not to be connected by the type `3` pass we will have first.\\n\\nLet\\'s start declaring a data structure `DoubleUF` to handle both clusters; it will have at instance level, with all the information about Alice at index `0`, all the one about Bob at index `1`:\\n* `parent`, made of two arrays with the parents for both clusters;\\n* `count` will keep track of how many clusters each person has.\\n\\nThe `constructor` will set all the cells up to `n` (included) to initially point to their own indexes and both `count` variables to be `n` (initially each node is also its own cluster).\\n\\n`find` will take a `node` and a `flag` to see who we are inspecting and then proceed as usual for a UF by `return`ing:\\n* `node` if it is the head of a cluster (ie: `parent[flag][node] == node`);\\n* the result of calling recursively `find` with `parent[flag][node]` after having stored it there otherwise.\\n\\n`merge` will take two nodes `n1` and `n2` and a `type` matching the one of the edges and:\\n* compute `flag` as `1` for `type == 2`, `0` otherwise;\\n* reevaluate `n1` and `n2` as the values of their own parents;\\n* `return` `false` if no merge is executed (ie: `n1 == n2`, meaning both nodes are already in the same cluster);\\n* make sure that `n1 < n2` (nothing major, it just streamlines clustering a bit and can be a cheap replacement for ranking) and if not, `swap` them;\\n* with `f` getting values of `0` and `1`, we will check if it matches the user (`0` for `type == 1`, `1` for `type == 2` and both for `type == 3`) and:\\n    * set the parent of `n2` (ie: `parent[f][n2]`) to be `n1`;\\n    * decrease the matching `count` by `1`;\\n* since a merge was executed, we will `return` `true`.\\n\\nIn our main function, we will declare first:\\n* `res` with an initial value equal to the number of edges (assuming we will not cut any until proven otherwise)\\n* `uf`, an instance of `DoubleUF` with initial capacity of `n`.\\n\\nWe will then take all the edges with `type == 3` and try to put the nodes it connects in the same cluster, passing them and the type to `duf.merge` and, if this will `return` `true`:\\n* decrease `res` by `1` (since we know we will either need this node or have to replace it with another);\\n* check if both users have now only a sole cluster are filled (ie: `duf.count[0] == 1 && duf.count[1] == 1`) and if so, `return` `res`.\\n\\nPretty much similar logic with all the edges with `type == 1` or `type == 2`, with the sole difference that we will not bother to check the last condition above when we parse only edges of `type == 1` (since if we do that loop, it means we were still missing connections for Bob too) and at the end of each loop we will check if the matching `count` is not `1` - if so, either Alice or Bob can\\'t to everywhere, so we will `return` `-1`.\\n\\nFinally, just to make the compiler happy, we will `return` `res`\\n\\n# Complexity\\n- Time complexity: $$O(e)$$ (number of edges)\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nstruct DoubleUF {\\n    int parent[2][100000], count[2];\\n    DoubleUF(int n) {\\n        count[0] = count[1] = n;\\n        for (int i = 1; i <= n; i++) parent[0][i] = parent[1][i] = i;\\n    }\\n    int find(int node, bool flag = false) {\\n        return parent[flag][node] == node ? node : parent[flag][node] = find(parent[flag][node], flag);\\n    }\\n    bool merge(int n1, int n2, int type) {\\n        bool flag = (type - 1) & 1;\\n        n1 = find(n1, flag), n2 = find(n2, flag);\\n        // already part of the same cluster\\n        if (n1 == n2) return false;\\n        // making sure n1 < n2\\n        if (n1 > n2) swap(n1, n2);\\n        // merging accordingly\\n        for (int f = 0; f < 2; f++) {\\n            if (type == 3 || f == type - 1) {\\n                parent[f][n2] = n1;\\n                count[f]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>> &edges) {\\n        // support variables\\n        int res = edges.size();\\n        DoubleUF duf(n);\\n        // parsing type 3 edges first\\n        for (auto &edge: edges) {\\n            if (edge[0] == 3 && duf.merge(edge[1], edge[2], 3)) {\\n                res--;\\n                if (duf.count[0] == 1 && duf.count[1] == 1) return res;\\n            }\\n        }\\n        // parsing type 1 edges\\n        for (auto &edge: edges) {\\n            if (edge[0] == 1 && duf.merge(edge[1], edge[2], 1)) {\\n                res--;\\n            }\\n        }\\n        if (duf.count[0] != 1) return -1;\\n        // parsing type 2 edges\\n        for (auto &edge: edges) {\\n            if (edge[0] == 2 && duf.merge(edge[1], edge[2], 2)) {\\n                res--;\\n                if (duf.count[1] == 1) return res;\\n            }\\n        }\\n        if (duf.count[1] != 1) return -1;\\n        return res;\\n    }\\n};\\n```\\n\\nAdding a `rank` to the UF and pregrouping the edges gave me basically yhe same performance in terms of space, but burning more space:\\n\\n```cpp\\nstruct DoubleUF {\\n    int parent[2][100000], rank[2][100000], count[2];\\n    DoubleUF(int n) {\\n        count[0] = count[1] = n;\\n        for (int i = 1; i <= n; i++) parent[0][i] = parent[1][i] = i,\\n            rank[0][i] = rank[1][i] = 1;\\n    }\\n    int find(int node, bool flag = false) {\\n        return parent[flag][node] == node ? node : parent[flag][node] = find(parent[flag][node], flag);\\n    }\\n    bool merge(int n1, int n2, int type) {\\n        bool flag = (type - 1) & 1;\\n        n1 = find(n1, flag), n2 = find(n2, flag);\\n        // already part of the same cluster\\n        if (n1 == n2) return false;\\n        // merging accordingly\\n        for (int f = 0; f < 2; f++) {\\n            if (type == 3 || f == type - 1) {\\n                // making sure rank[f][n1] > rank[f][n2]\\n                if (rank[f][n1] < rank[f][n2]) swap(n1, n2);\\n                parent[f][n2] = n1;\\n                rank[f][n1] += rank[f][n2];\\n                count[f]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>> &edges) {\\n        // support variables\\n        int res = edges.size();\\n        DoubleUF duf(n);\\n        vector<int> edgesByType[3];\\n        // populating edgesByType\\n        for (int i = 0; i < 3; i++) edgesByType[i].reserve(res);\\n        for (int i = 0; i < res; i++) edgesByType[edges[i][0] - 1].push_back(i);\\n        // parsing type 3 edges first\\n        auto &currEdges = edgesByType[2];\\n        for (int i: currEdges) {\\n            auto &edge = edges[i];\\n            if (duf.merge(edge[1], edge[2], 3)) {\\n                res--;\\n                if (duf.count[0] == 1 && duf.count[1] == 1) return res;\\n            }\\n        }\\n        // parsing type 1 edges\\n        currEdges = edgesByType[0];\\n        for (int i: currEdges) {\\n            auto &edge = edges[i];\\n            if (duf.merge(edge[1], edge[2], 1)) {\\n                res--;\\n            }\\n        }\\n        if (duf.count[0] != 1) return -1;\\n        // parsing type 2 edges\\n        currEdges = edgesByType[1];\\n        for (int i: currEdges) {\\n            auto &edge = edges[i];\\n            if (duf.merge(edge[1], edge[2], 2)) {\\n                res--;\\n                if (duf.count[1] == 1) return res;\\n            }\\n        }\\n        if (duf.count[1] != 1) return -1;\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image.png](https://assets.leetcode.com/users/images/5e8462e9-46fa-4d80-a6ee-4f139ffd6cb8_1682898304.8080537.png)\\n",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```cpp\\nstruct DoubleUF {\\n    int parent[2][100000], count[2];\\n    DoubleUF(int n) {\\n        count[0] = count[1] = n;\\n        for (int i = 1; i <= n; i++) parent[0][i] = parent[1][i] = i;\\n    }\\n    int find(int node, bool flag = false) {\\n        return parent[flag][node] == node ? node : parent[flag][node] = find(parent[flag][node], flag);\\n    }\\n    bool merge(int n1, int n2, int type) {\\n        bool flag = (type - 1) & 1;\\n        n1 = find(n1, flag), n2 = find(n2, flag);\\n        // already part of the same cluster\\n        if (n1 == n2) return false;\\n        // making sure n1 < n2\\n        if (n1 > n2) swap(n1, n2);\\n        // merging accordingly\\n        for (int f = 0; f < 2; f++) {\\n            if (type == 3 || f == type - 1) {\\n                parent[f][n2] = n1;\\n                count[f]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>> &edges) {\\n        // support variables\\n        int res = edges.size();\\n        DoubleUF duf(n);\\n        // parsing type 3 edges first\\n        for (auto &edge: edges) {\\n            if (edge[0] == 3 && duf.merge(edge[1], edge[2], 3)) {\\n                res--;\\n                if (duf.count[0] == 1 && duf.count[1] == 1) return res;\\n            }\\n        }\\n        // parsing type 1 edges\\n        for (auto &edge: edges) {\\n            if (edge[0] == 1 && duf.merge(edge[1], edge[2], 1)) {\\n                res--;\\n            }\\n        }\\n        if (duf.count[0] != 1) return -1;\\n        // parsing type 2 edges\\n        for (auto &edge: edges) {\\n            if (edge[0] == 2 && duf.merge(edge[1], edge[2], 2)) {\\n                res--;\\n                if (duf.count[1] == 1) return res;\\n            }\\n        }\\n        if (duf.count[1] != 1) return -1;\\n        return res;\\n    }\\n};\\n```\n```cpp\\nstruct DoubleUF {\\n    int parent[2][100000], rank[2][100000], count[2];\\n    DoubleUF(int n) {\\n        count[0] = count[1] = n;\\n        for (int i = 1; i <= n; i++) parent[0][i] = parent[1][i] = i,\\n            rank[0][i] = rank[1][i] = 1;\\n    }\\n    int find(int node, bool flag = false) {\\n        return parent[flag][node] == node ? node : parent[flag][node] = find(parent[flag][node], flag);\\n    }\\n    bool merge(int n1, int n2, int type) {\\n        bool flag = (type - 1) & 1;\\n        n1 = find(n1, flag), n2 = find(n2, flag);\\n        // already part of the same cluster\\n        if (n1 == n2) return false;\\n        // merging accordingly\\n        for (int f = 0; f < 2; f++) {\\n            if (type == 3 || f == type - 1) {\\n                // making sure rank[f][n1] > rank[f][n2]\\n                if (rank[f][n1] < rank[f][n2]) swap(n1, n2);\\n                parent[f][n2] = n1;\\n                rank[f][n1] += rank[f][n2];\\n                count[f]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>> &edges) {\\n        // support variables\\n        int res = edges.size();\\n        DoubleUF duf(n);\\n        vector<int> edgesByType[3];\\n        // populating edgesByType\\n        for (int i = 0; i < 3; i++) edgesByType[i].reserve(res);\\n        for (int i = 0; i < res; i++) edgesByType[edges[i][0] - 1].push_back(i);\\n        // parsing type 3 edges first\\n        auto &currEdges = edgesByType[2];\\n        for (int i: currEdges) {\\n            auto &edge = edges[i];\\n            if (duf.merge(edge[1], edge[2], 3)) {\\n                res--;\\n                if (duf.count[0] == 1 && duf.count[1] == 1) return res;\\n            }\\n        }\\n        // parsing type 1 edges\\n        currEdges = edgesByType[0];\\n        for (int i: currEdges) {\\n            auto &edge = edges[i];\\n            if (duf.merge(edge[1], edge[2], 1)) {\\n                res--;\\n            }\\n        }\\n        if (duf.count[0] != 1) return -1;\\n        // parsing type 2 edges\\n        currEdges = edgesByType[1];\\n        for (int i: currEdges) {\\n            auto &edge = edges[i];\\n            if (duf.merge(edge[1], edge[2], 2)) {\\n                res--;\\n                if (duf.count[1] == 1) return res;\\n            }\\n        }\\n        if (duf.count[1] != 1) return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471234,
                "title": "ruby-classic-union-find",
                "content": "# Intuition\\nWe should prioritize the edges that both Alice and Bob can take when connecting nodes because that will maximize the number of edges we can remove. \\n\\n# Approach\\nInstead of removing edges, build up connected nodes using type 3 first. \\n\\nUnion find data structure for Bob\\'s graph and union find data structure for Alice\\'s graph. A graph that has all nodes connected minimally with have n-1 edges. \\n\\nIf the union operation is successful, then we used the edge to connect the nodes.\\n\\n# Complexity\\n- Time complexity:\\n\\n O(E\\u2217\\u03B1(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n# @param {Integer} n\\n# @param {Integer[][]} edges\\n# @return {Integer}\\ndef max_num_edges_to_remove(n, edges)\\n   bob_parents = (0..n).to_a\\n   bob_rank = Array.new(n+1, 1)\\n\\n   alice_parents = (0..n).to_a\\n   alice_rank = Array.new(n+1,1)\\n\\n    edges_required = 0\\n    bob_graph_edges = 0\\n    alice_graph_edges = 0 \\n\\n    for type, n1, n2 in edges\\n       if type == 3\\n          bob_unioned = union(n1, n2, bob_parents, bob_rank)\\n          alice_unioned = union(n1, n2, alice_parents, alice_rank)\\n        \\n          bob_graph_edges += 1 if bob_unioned\\n          alice_graph_edges += 1 if alice_unioned\\n          edges_required += 1 if bob_unioned || alice_unioned\\n        end\\n    end\\n\\n    for type, n1, n2 in edges\\n       if type == 2\\n          if union(n1, n2, bob_parents, bob_rank) \\n            edges_required += 1 \\n            bob_graph_edges += 1\\n          end\\n       elsif type == 1\\n         if  union(n1, n2, alice_parents, alice_rank) \\n           edges_required += 1 \\n           alice_graph_edges += 1\\n         end\\n       end\\n    end\\n\\n    return -1 if bob_graph_edges != n-1 || alice_graph_edges != n-1\\n    return edges.size - edges_required\\nend\\n\\ndef union(n1, n2, parent, rank)\\n   root1, root2 = find(n1, parent), find(n2, parent)\\n\\n   return false if root1 == root2\\n\\n   if rank[root1] > rank[root2]\\n     parent[root2] = root1\\n     rank[root1] += rank[root2]\\n   else\\n      parent[root1] = root2\\n      rank[root2] += rank[root1]\\n   end\\n\\n   return true\\nend\\n\\ndef find(n1, parent)\\n  node = n1\\n\\n  while( node != parent[node] )\\n    parent[node] = parent[parent[node]]\\n    node = parent[node]\\n   end\\n\\n  return node\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer[][]} edges\\n# @return {Integer}\\ndef max_num_edges_to_remove(n, edges)\\n   bob_parents = (0..n).to_a\\n   bob_rank = Array.new(n+1, 1)\\n\\n   alice_parents = (0..n).to_a\\n   alice_rank = Array.new(n+1,1)\\n\\n    edges_required = 0\\n    bob_graph_edges = 0\\n    alice_graph_edges = 0 \\n\\n    for type, n1, n2 in edges\\n       if type == 3\\n          bob_unioned = union(n1, n2, bob_parents, bob_rank)\\n          alice_unioned = union(n1, n2, alice_parents, alice_rank)\\n        \\n          bob_graph_edges += 1 if bob_unioned\\n          alice_graph_edges += 1 if alice_unioned\\n          edges_required += 1 if bob_unioned || alice_unioned\\n        end\\n    end\\n\\n    for type, n1, n2 in edges\\n       if type == 2\\n          if union(n1, n2, bob_parents, bob_rank) \\n            edges_required += 1 \\n            bob_graph_edges += 1\\n          end\\n       elsif type == 1\\n         if  union(n1, n2, alice_parents, alice_rank) \\n           edges_required += 1 \\n           alice_graph_edges += 1\\n         end\\n       end\\n    end\\n\\n    return -1 if bob_graph_edges != n-1 || alice_graph_edges != n-1\\n    return edges.size - edges_required\\nend\\n\\ndef union(n1, n2, parent, rank)\\n   root1, root2 = find(n1, parent), find(n2, parent)\\n\\n   return false if root1 == root2\\n\\n   if rank[root1] > rank[root2]\\n     parent[root2] = root1\\n     rank[root1] += rank[root2]\\n   else\\n      parent[root1] = root2\\n      rank[root2] += rank[root1]\\n   end\\n\\n   return true\\nend\\n\\ndef find(n1, parent)\\n  node = n1\\n\\n  while( node != parent[node] )\\n    parent[node] = parent[parent[node]]\\n    node = parent[node]\\n   end\\n\\n  return node\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3470938,
                "title": "lengthy-code-but-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> rootA(n + 1);\\n        vector<int> rootB(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            rootA[i] = i;\\n            rootB[i] = i;\\n        }\\n\\n        int res = 0;\\n        int aliceEdges = 0;\\n        int bobEdges = 0;\\n\\n        \\n        for (auto& edge : edges) {\\n            if (edge[0] == 3) {\\n                if (uni(edge[1], edge[2], rootA)) {\\n                    aliceEdges++;\\n                    if (uni(edge[1], edge[2], rootB)) {\\n                        bobEdges++;\\n                    }\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        vector<int> rootA_copy = rootA;\\n\\n        \\n        for (auto& edge : edges) {\\n            if (edge[0] == 1) {\\n                if (uni(edge[1], edge[2], rootA)) {\\n                    aliceEdges++;\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        \\n        rootA = rootA_copy;\\n        for (auto& edge : edges) {\\n            if (edge[0] == 2) {\\n                if (uni(edge[1], edge[2], rootB)) {\\n                    bobEdges++;\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        return (aliceEdges == bobEdges && aliceEdges == n - 1) ? res : -1;\\n    }\\n\\n    bool uni(int a, int b, vector<int>& root) {\\n        int rootA = find(a, root);\\n        int rootB = find(b, root);\\n        if (rootA == rootB) {\\n            return false;\\n        }\\n        root[rootA] = rootB;\\n        return true;\\n    }\\n\\n    int find(int a, vector<int>& root) {\\n        if (root[a] != a) {\\n            root[a] = find(root[a], root);\\n        }\\n        return root[a];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> rootA(n + 1);\\n        vector<int> rootB(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            rootA[i] = i;\\n            rootB[i] = i;\\n        }\\n\\n        int res = 0;\\n        int aliceEdges = 0;\\n        int bobEdges = 0;\\n\\n        \\n        for (auto& edge : edges) {\\n            if (edge[0] == 3) {\\n                if (uni(edge[1], edge[2], rootA)) {\\n                    aliceEdges++;\\n                    if (uni(edge[1], edge[2], rootB)) {\\n                        bobEdges++;\\n                    }\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        vector<int> rootA_copy = rootA;\\n\\n        \\n        for (auto& edge : edges) {\\n            if (edge[0] == 1) {\\n                if (uni(edge[1], edge[2], rootA)) {\\n                    aliceEdges++;\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        \\n        rootA = rootA_copy;\\n        for (auto& edge : edges) {\\n            if (edge[0] == 2) {\\n                if (uni(edge[1], edge[2], rootB)) {\\n                    bobEdges++;\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        return (aliceEdges == bobEdges && aliceEdges == n - 1) ? res : -1;\\n    }\\n\\n    bool uni(int a, int b, vector<int>& root) {\\n        int rootA = find(a, root);\\n        int rootB = find(b, root);\\n        if (rootA == rootB) {\\n            return false;\\n        }\\n        root[rootA] = rootB;\\n        return true;\\n    }\\n\\n    int find(int a, vector<int>& root) {\\n        if (root[a] != a) {\\n            root[a] = find(root[a], root);\\n        }\\n        return root[a];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470793,
                "title": "easy-to-understand-c-solution-using-dsu",
                "content": "# Code\\n```\\nclass DSU {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    int components;\\n\\n    DSU(int n) {\\n        parent.resize(n+1);\\n        for(int i = 1; i <=n; i++) {\\n            parent[i] = i;\\n        }\\n        rank.resize(n+1);\\n        components = n;\\n    }\\n\\n    int findParent(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return findParent(parent[node]);\\n    }\\n\\n    void unionByRank(int node1, int node2) {\\n        int p1 = findParent(node1);\\n        int p2 = findParent(node2);\\n\\n        if(p1 == p2) {\\n            return;\\n        }\\n        if(rank[p1] > rank[p2]) {\\n            parent[p2] = p1;\\n        } else if(rank[p2] > rank[p1]) {\\n            parent[p1] = p2;\\n        } else {\\n            parent[p1] = p2;\\n            rank[p2]++;\\n        }\\n        components--;\\n    }\\n\\n    bool isSingle() {\\n        return components == 1;\\n    }\\n\\n};\\n\\nclass Solution {\\npublic:\\n   \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        // Aaj bhi DSU ka question hai\\n        // 2 DSU Banao Alice and Bob k liye\\n        // aur edges ko traverse karo sorting order me type k 3,2,1\\n        // agr type 3 hai to u and v k parent check karo agr wo \\n        // alag hai to union karo aur edge++ karo ye kaam dono k liye karo\\n        // agr type 2 hai aur u and v ka parent same nahi to union karo aur\\n        // edge++ karo, same kaam type 1 k liye bhi\\n        // last me check karo ki agr components dono graph ka 1 hai to\\n        // return edges.size() - edge otherwise return -1;\\n        DSU Alice(n);\\n        DSU Bob(n);\\n\\n        auto lambda = [](vector<int> &a, vector<int> &b) {\\n            return a[0] > b[0]; \\n        };\\n        sort(edges.begin(), edges.end(), lambda);\\n\\n        int edge = 0;\\n        for(auto &ed: edges) {\\n            int type = ed[0];\\n            int u = ed[1];\\n            int v = ed[2];\\n\\n            if(type == 3) {\\n                bool edgeAdded = false;\\n                if(Alice.findParent(u) != Alice.findParent(v)) {\\n                    Alice.unionByRank(u,v);\\n                    edgeAdded = true;\\n                }\\n                if(Bob.findParent(u) != Bob.findParent(v)) {\\n                    Bob.unionByRank(u,v);\\n                    edgeAdded = true;\\n                } \\n                if(edgeAdded == true) {\\n                    edge++;\\n                }  \\n            } else if (type == 2) {\\n                if(Bob.findParent(u) != Bob.findParent(v)) {\\n                    Bob.unionByRank(u,v);\\n                    edge++;\\n                }\\n                \\n            } else {\\n                if(Alice.findParent(u) != Alice.findParent(v)) {\\n                    Alice.unionByRank(u,v);\\n                    edge++;\\n                }\\n            }\\n        }\\n        if(Alice.isSingle() == true and Bob.isSingle() == true) {\\n            return edges.size() - edge;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    int components;\\n\\n    DSU(int n) {\\n        parent.resize(n+1);\\n        for(int i = 1; i <=n; i++) {\\n            parent[i] = i;\\n        }\\n        rank.resize(n+1);\\n        components = n;\\n    }\\n\\n    int findParent(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return findParent(parent[node]);\\n    }\\n\\n    void unionByRank(int node1, int node2) {\\n        int p1 = findParent(node1);\\n        int p2 = findParent(node2);\\n\\n        if(p1 == p2) {\\n            return;\\n        }\\n        if(rank[p1] > rank[p2]) {\\n            parent[p2] = p1;\\n        } else if(rank[p2] > rank[p1]) {\\n            parent[p1] = p2;\\n        } else {\\n            parent[p1] = p2;\\n            rank[p2]++;\\n        }\\n        components--;\\n    }\\n\\n    bool isSingle() {\\n        return components == 1;\\n    }\\n\\n};\\n\\nclass Solution {\\npublic:\\n   \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        // Aaj bhi DSU ka question hai\\n        // 2 DSU Banao Alice and Bob k liye\\n        // aur edges ko traverse karo sorting order me type k 3,2,1\\n        // agr type 3 hai to u and v k parent check karo agr wo \\n        // alag hai to union karo aur edge++ karo ye kaam dono k liye karo\\n        // agr type 2 hai aur u and v ka parent same nahi to union karo aur\\n        // edge++ karo, same kaam type 1 k liye bhi\\n        // last me check karo ki agr components dono graph ka 1 hai to\\n        // return edges.size() - edge otherwise return -1;\\n        DSU Alice(n);\\n        DSU Bob(n);\\n\\n        auto lambda = [](vector<int> &a, vector<int> &b) {\\n            return a[0] > b[0]; \\n        };\\n        sort(edges.begin(), edges.end(), lambda);\\n\\n        int edge = 0;\\n        for(auto &ed: edges) {\\n            int type = ed[0];\\n            int u = ed[1];\\n            int v = ed[2];\\n\\n            if(type == 3) {\\n                bool edgeAdded = false;\\n                if(Alice.findParent(u) != Alice.findParent(v)) {\\n                    Alice.unionByRank(u,v);\\n                    edgeAdded = true;\\n                }\\n                if(Bob.findParent(u) != Bob.findParent(v)) {\\n                    Bob.unionByRank(u,v);\\n                    edgeAdded = true;\\n                } \\n                if(edgeAdded == true) {\\n                    edge++;\\n                }  \\n            } else if (type == 2) {\\n                if(Bob.findParent(u) != Bob.findParent(v)) {\\n                    Bob.unionByRank(u,v);\\n                    edge++;\\n                }\\n                \\n            } else {\\n                if(Alice.findParent(u) != Alice.findParent(v)) {\\n                    Alice.unionByRank(u,v);\\n                    edge++;\\n                }\\n            }\\n        }\\n        if(Alice.isSingle() == true and Bob.isSingle() == true) {\\n            return edges.size() - edge;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470286,
                "title": "kruskal-mst",
                "content": "# Intuition\\nMinimum spanning tree with Kruskal algorithm (disjoint set), with some hairs.\\n\\n# Approach\\nFirst attemp to use all type-3 edges (both) (phase 1), then use type-1 (alice-only) and type-2 (bob-only) separatedly (phase 2). Until the tree is built. Register the total edge used.\\n\\nProof of correctness:\\n\\n0. ignore the proof of correctness of the MST algorithm\\n1. The correctness of \"use type-3\" first:\\n    Consider an type-3 edge connects two sets in the phase 1, If we don\\'t use it but some other edges at the second phase to connect the two sets, it would costs two edges (one for either alice or bob).\\n2. Is there a possible (sub-) spanning tree, whose edges are of mixed type, that has less edge numbers that the pure-type-3 spanning tree?\\n    -impossible, since the number of edges in the combination of edges from two mixed-spanning tree must be larger or equal to the pure-type-3 tree, with the same reachability.\\n\\nThus the correctness of the algorithm is proved through the induction.\\n\\n# Complexity\\n- Time complexity:\\n$O(|E| * n)$, \\nthe $|E|$ is for iterating over all edges, while the $n$ is the worst-case time-complexity of the disjoint set.\\n\\nNote that there is a ```sorted(edges, ...)``` in my current implementation. This is only for the ease of coding, which means theoretically the sorting (with the time complexity of $O(|E| log(|E|))$) is not needed and the only thing that is needed during the preprocessing is identifying all type-3 edges, which contributes only a O(|E|) time complexity.\\n\\n- Space complexity:\\n$O(n)$ for the disjoint set.\\n\\n# Code\\n```\\nclass DS:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.n_set = n\\n        self.parent = list(range(n))\\n    \\n    def find_root(self, v: int) -> int:\\n        if self.parent[v] == v:\\n            return v\\n        self.parent[v] = self.find_root(self.parent[v])\\n        return self.parent[v]\\n\\n    def join(self, u: int, v: int) -> bool:\\n        if self.n_set == 1:\\n            return False\\n        u_root = self.find_root(u)\\n        v_root = self.find_root(v)\\n        if u_root == v_root:\\n            return False\\n        self.parent[u_root] = v_root\\n        self.n_set -= 1\\n        return True\\n        \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        ds_a = DS(n)\\n        ds_b = DS(n)\\n        reordered_edges = sorted(edges, key=lambda x: x[0], reverse=True)\\n        edges_used = 0\\n        print(reordered_edges)\\n        # note: node ids start from 1\\n        for n_type, u, v in reordered_edges:\\n            if n_type == 3 and ds_a.n_set != 1:\\n                if ds_a.join(u - 1, v - 1) and ds_b.join(u - 1, v - 1):\\n                    edges_used += 1\\n            elif n_type == 1 and ds_a.n_set != 1:\\n                if ds_a.join(u - 1, v - 1):\\n                    edges_used += 1\\n            elif n_type == 2 and ds_b.n_set != 1:\\n                if ds_b.join(u - 1, v - 1):\\n                    edges_used += 1\\n\\n        if ds_b.n_set != 1 or ds_a.n_set != 1:\\n            return -1\\n        \\n        return len(edges) - edges_used\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```sorted(edges, ...)```\n```\\nclass DS:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.n_set = n\\n        self.parent = list(range(n))\\n    \\n    def find_root(self, v: int) -> int:\\n        if self.parent[v] == v:\\n            return v\\n        self.parent[v] = self.find_root(self.parent[v])\\n        return self.parent[v]\\n\\n    def join(self, u: int, v: int) -> bool:\\n        if self.n_set == 1:\\n            return False\\n        u_root = self.find_root(u)\\n        v_root = self.find_root(v)\\n        if u_root == v_root:\\n            return False\\n        self.parent[u_root] = v_root\\n        self.n_set -= 1\\n        return True\\n        \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        ds_a = DS(n)\\n        ds_b = DS(n)\\n        reordered_edges = sorted(edges, key=lambda x: x[0], reverse=True)\\n        edges_used = 0\\n        print(reordered_edges)\\n        # note: node ids start from 1\\n        for n_type, u, v in reordered_edges:\\n            if n_type == 3 and ds_a.n_set != 1:\\n                if ds_a.join(u - 1, v - 1) and ds_b.join(u - 1, v - 1):\\n                    edges_used += 1\\n            elif n_type == 1 and ds_a.n_set != 1:\\n                if ds_a.join(u - 1, v - 1):\\n                    edges_used += 1\\n            elif n_type == 2 and ds_b.n_set != 1:\\n                if ds_b.join(u - 1, v - 1):\\n                    edges_used += 1\\n\\n        if ds_b.n_set != 1 or ds_a.n_set != 1:\\n            return -1\\n        \\n        return len(edges) - edges_used\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470195,
                "title": "first-type-3-union",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findParent(vector<int>& parent, int u) {\\n        if(parent[u] < 0)\\n            return u;\\n        return parent[u] = findParent(parent, parent[u]);\\n    }\\n    bool UnionByWeight(vector<int>& parent, int u, int v) {\\n        int pu = findParent(parent, u), pv = findParent(parent, v);\\n        if(pu == pv)\\n            return false;\\n        if(parent[pu] < parent[pv]) {\\n            parent[pu] += parent[pv];\\n            parent[pv] = pu;\\n        }\\n        else {\\n            parent[pv] += parent[pu];\\n            parent[pu] = pv;\\n        }\\n        return true;\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> parent(n + 1, -1);\\n        int remove = 0;\\n        for(vector<int>& edge: edges)\\n            if(edge[0] == 3 && !UnionByWeight(parent, edge[1], edge[2]))\\n                    remove++;\\n        vector<int> a(parent), b(parent);\\n        for(vector<int>& edge: edges) {\\n            if(edge[0] == 1 && !UnionByWeight(a, edge[1], edge[2]))\\n                    remove++;\\n            else if(edge[0] == 2 && !UnionByWeight(b, edge[1], edge[2]))\\n                    remove++;\\n        }\\n        int groupa = 0, groupb = 0;\\n        for(int i = 1; i <= n; i++) {\\n            if(a[i] < 0)\\n                groupa++;\\n            if(b[i] < 0)\\n                groupb++;\\n        }\\n        if(groupa > 1 || groupb > 1)\\n            return -1;\\n        return remove;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findParent(vector<int>& parent, int u) {\\n        if(parent[u] < 0)\\n            return u;\\n        return parent[u] = findParent(parent, parent[u]);\\n    }\\n    bool UnionByWeight(vector<int>& parent, int u, int v) {\\n        int pu = findParent(parent, u), pv = findParent(parent, v);\\n        if(pu == pv)\\n            return false;\\n        if(parent[pu] < parent[pv]) {\\n            parent[pu] += parent[pv];\\n            parent[pv] = pu;\\n        }\\n        else {\\n            parent[pv] += parent[pu];\\n            parent[pu] = pv;\\n        }\\n        return true;\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> parent(n + 1, -1);\\n        int remove = 0;\\n        for(vector<int>& edge: edges)\\n            if(edge[0] == 3 && !UnionByWeight(parent, edge[1], edge[2]))\\n                    remove++;\\n        vector<int> a(parent), b(parent);\\n        for(vector<int>& edge: edges) {\\n            if(edge[0] == 1 && !UnionByWeight(a, edge[1], edge[2]))\\n                    remove++;\\n            else if(edge[0] == 2 && !UnionByWeight(b, edge[1], edge[2]))\\n                    remove++;\\n        }\\n        int groupa = 0, groupb = 0;\\n        for(int i = 1; i <= n; i++) {\\n            if(a[i] < 0)\\n                groupa++;\\n            if(b[i] < 0)\\n                groupb++;\\n        }\\n        if(groupa > 1 || groupb > 1)\\n            return -1;\\n        return remove;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470143,
                "title": "c-solution-union-find-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxNumEdgesToRemove(int n, int[][] edges) {\\n        DSU dsu1 = new DSU(n);\\n        DSU dsu2 = new DSU(n);\\n        int count = 0;\\n        Array.Sort(edges, (a, b) => b[0] - a[0]);\\n\\n        foreach(var edge in edges){\\n            if(edge[0] == 3){\\n                if(dsu1.find(edge[1]) == dsu1.find(edge[2]) && dsu2.find(edge[1]) == dsu2.find(edge[2])){\\n                    count++;\\n                    continue;\\n                }\\n                \\n                dsu1.union(edge[1], edge[2]);\\n                dsu2.union(edge[1], edge[2]);\\n            }\\n            else if(edge[0] == 1){\\n                if(dsu1.find(edge[1]) == dsu1.find(edge[2])){\\n                    count++;\\n                }\\n\\n                dsu1.union(edge[1], edge[2]);\\n            }\\n            else{\\n                if(dsu2.find(edge[1]) == dsu2.find(edge[2])){\\n                    count++;\\n                }\\n\\n                dsu2.union(edge[1], edge[2]);\\n            }\\n        }\\n\\n        for(int i=1; i<=n; i++){\\n            dsu1.find(i);\\n            dsu2.find(i);\\n        }\\n\\n        for(int i=2; i<=n; i++){\\n            if(dsu1.parent[i] != dsu1.parent[1] || dsu2.parent[i] != dsu2.parent[1]){\\n                return -1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    class DSU {\\n        public int[] parent;\\n\\n        public DSU(int n) {\\n            parent = new int[n+1];\\n\\n            for (int i = 0; i <= n; i++) parent[i] = i;\\n        }\\n\\n        public int find(int x) {\\n            if (parent[x] != x) parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public void union(int x, int y) {\\n            parent[find(x)] = parent[find(y)];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxNumEdgesToRemove(int n, int[][] edges) {\\n        DSU dsu1 = new DSU(n);\\n        DSU dsu2 = new DSU(n);\\n        int count = 0;\\n        Array.Sort(edges, (a, b) => b[0] - a[0]);\\n\\n        foreach(var edge in edges){\\n            if(edge[0] == 3){\\n                if(dsu1.find(edge[1]) == dsu1.find(edge[2]) && dsu2.find(edge[1]) == dsu2.find(edge[2])){\\n                    count++;\\n                    continue;\\n                }\\n                \\n                dsu1.union(edge[1], edge[2]);\\n                dsu2.union(edge[1], edge[2]);\\n            }\\n            else if(edge[0] == 1){\\n                if(dsu1.find(edge[1]) == dsu1.find(edge[2])){\\n                    count++;\\n                }\\n\\n                dsu1.union(edge[1], edge[2]);\\n            }\\n            else{\\n                if(dsu2.find(edge[1]) == dsu2.find(edge[2])){\\n                    count++;\\n                }\\n\\n                dsu2.union(edge[1], edge[2]);\\n            }\\n        }\\n\\n        for(int i=1; i<=n; i++){\\n            dsu1.find(i);\\n            dsu2.find(i);\\n        }\\n\\n        for(int i=2; i<=n; i++){\\n            if(dsu1.parent[i] != dsu1.parent[1] || dsu2.parent[i] != dsu2.parent[1]){\\n                return -1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    class DSU {\\n        public int[] parent;\\n\\n        public DSU(int n) {\\n            parent = new int[n+1];\\n\\n            for (int i = 0; i <= n; i++) parent[i] = i;\\n        }\\n\\n        public int find(int x) {\\n            if (parent[x] != x) parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public void union(int x, int y) {\\n            parent[find(x)] = parent[find(y)];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470091,
                "title": "swift-unionfind",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    \\n    enum UnType: Int {\\n        case alice = 1\\n        case bob = 2\\n        case both = 3\\n    }\\n\\n    func maxNumEdgesToRemove(_ n: Int, _ edges: [[Int]]) -> Int {\\n        \\n        var edges = edges.map { (type: UnType(rawValue: $0[0])!, from: $0[1], to: $0[2]) }.sorted { $0.type.rawValue > $1.type.rawValue }\\n        var unionA = Union(n)\\n        var unionB = Union(n)\\n        \\n        var extra = 0\\n        for edge in edges {\\n            \\n            switch edge.type {\\n            case .both:\\n                let aConnected = unionA.wasConnected(edge.from, edge.to)\\n                let bConnected = unionB.wasConnected(edge.from, edge.to)\\n                if aConnected && bConnected { extra += 1 }\\n            case .alice:\\n                if unionA.wasConnected(edge.from, edge.to) { extra += 1 }\\n            case .bob:\\n                if unionB.wasConnected(edge.from, edge.to) { extra += 1 }\\n            }\\n        }\\n        \\n        return unionB.connected() && unionA.connected() ? extra : -1\\n    }\\n}\\n\\nclass Union {\\n    \\n    private var union: [Int]\\n    private var ranks: [Int]\\n    \\n    init(_ n: Int) {\\n        union = Array(repeating: 0, count: n + 1).enumerated().map { $0.offset }\\n        ranks = Array(repeating: 1, count: n + 1)\\n    }\\n    \\n    // return true if i and j was connected previously\\n    func wasConnected(_ i: Int, _ j: Int) -> Bool {\\n        if areConnected(i, j) { return true }\\n        union(i, j)\\n        return false\\n    }\\n    \\n    func root(of node: Int) -> Int {\\n        var node = node\\n        while node != union[node] {\\n            node = union[node]\\n        }\\n        return node\\n    }\\n    \\n    func areConnected(_ i: Int, _ j: Int) -> Bool {\\n        root(of: i) == root(of: j)\\n    }\\n    \\n    func union(_ i: Int, _ j: Int) {\\n        if i == j { return }\\n        let iRoot = root(of: i)\\n        let jRoot = root(of: j)\\n        if iRoot == jRoot { return }\\n        \\n        if ranks[iRoot] < ranks[jRoot] {\\n            union[iRoot] = jRoot\\n            ranks[jRoot] += ranks[iRoot]\\n        } else {\\n            union[jRoot] = iRoot\\n            ranks[iRoot] += ranks[jRoot]\\n        }\\n    }\\n    \\n    func connected() -> Bool {\\n        Set(union.suffix(from: 1).map { root(of: $0) }).count == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    enum UnType: Int {\\n        case alice = 1\\n        case bob = 2\\n        case both = 3\\n    }\\n\\n    func maxNumEdgesToRemove(_ n: Int, _ edges: [[Int]]) -> Int {\\n        \\n        var edges = edges.map { (type: UnType(rawValue: $0[0])!, from: $0[1], to: $0[2]) }.sorted { $0.type.rawValue > $1.type.rawValue }\\n        var unionA = Union(n)\\n        var unionB = Union(n)\\n        \\n        var extra = 0\\n        for edge in edges {\\n            \\n            switch edge.type {\\n            case .both:\\n                let aConnected = unionA.wasConnected(edge.from, edge.to)\\n                let bConnected = unionB.wasConnected(edge.from, edge.to)\\n                if aConnected && bConnected { extra += 1 }\\n            case .alice:\\n                if unionA.wasConnected(edge.from, edge.to) { extra += 1 }\\n            case .bob:\\n                if unionB.wasConnected(edge.from, edge.to) { extra += 1 }\\n            }\\n        }\\n        \\n        return unionB.connected() && unionA.connected() ? extra : -1\\n    }\\n}\\n\\nclass Union {\\n    \\n    private var union: [Int]\\n    private var ranks: [Int]\\n    \\n    init(_ n: Int) {\\n        union = Array(repeating: 0, count: n + 1).enumerated().map { $0.offset }\\n        ranks = Array(repeating: 1, count: n + 1)\\n    }\\n    \\n    // return true if i and j was connected previously\\n    func wasConnected(_ i: Int, _ j: Int) -> Bool {\\n        if areConnected(i, j) { return true }\\n        union(i, j)\\n        return false\\n    }\\n    \\n    func root(of node: Int) -> Int {\\n        var node = node\\n        while node != union[node] {\\n            node = union[node]\\n        }\\n        return node\\n    }\\n    \\n    func areConnected(_ i: Int, _ j: Int) -> Bool {\\n        root(of: i) == root(of: j)\\n    }\\n    \\n    func union(_ i: Int, _ j: Int) {\\n        if i == j { return }\\n        let iRoot = root(of: i)\\n        let jRoot = root(of: j)\\n        if iRoot == jRoot { return }\\n        \\n        if ranks[iRoot] < ranks[jRoot] {\\n            union[iRoot] = jRoot\\n            ranks[jRoot] += ranks[iRoot]\\n        } else {\\n            union[jRoot] = iRoot\\n            ranks[iRoot] += ranks[jRoot]\\n        }\\n    }\\n    \\n    func connected() -> Bool {\\n        Set(union.suffix(from: 1).map { root(of: $0) }).count == 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470060,
                "title": "union-find-solution-with-path-compression-and-union-with-rank-c",
                "content": "# Intuition\\nThe problem statement asks us to remove maximum number of edges such that alice and bob, both are able to traverse the graph completely.\\n\\nWe can break the problem as follows -\\n1. If an edge is type 3 then both alice and bob can travel over that edges.\\n2. If some edges is already marked of type 3 then there is no need for an edge specific to alice or bob. Hence, we can remove it.\\n3. Now, if there is a path from node 1 to node 2 then again we do not need to consider that edge. (We remove it.)\\n4. After considering all the edges, if the graph cannot the travered completely, return -1.\\n\\n# Approach\\nWe use ***UNION FIND*** to solve this problem.\\n1. We create two union find objects, i.e. 1 for Bob and 1 for Alice.\\n2. Now we create an edge between Node 1 and Node 2, if parent of Node 1 is not equal to parent of Node 2.\\n3. If edge is type 3 then check for both objects and iff both holds true then update both the objects.\\n4. If none of step 2 - 3 hold then delete that edge and increment the counter.\\n5. Now, we reduce the UNION FIND object again to find and update parents for all the remaining nodes.\\n6. Check for number of distinct parents inside each object. Iff the number of distinct parents is not 1 for any object then return -1.\\n7. Else return the counter.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class UF {\\n        vector<int> parent;\\n        vector<int> rank;\\n        int num;\\n        public:\\n            UF(int n) {\\n                parent = vector<int>(n, 0);\\n                rank = vector<int>(n, 0);\\n                for(int i = 0; i < n; i++) {\\n                    parent[i] = i;\\n                }\\n                num = n;\\n            }\\n            void Union(int a, int b) {\\n                int pa = find(a), pb = find(b);\\n                if(pa == pb) {\\n                    return;\\n                }\\n                if(rank[pa] > rank[pb]) {\\n                    parent[pb] = pa;\\n                } else if(rank[pa] < rank[pb]) {\\n                    parent[pa] = pb;\\n                } else {\\n                    parent[pb] = pa;\\n                    rank[pa]++;\\n                }\\n            }\\n            int find(int index) {\\n                if(parent[index] == index) {\\n                    return index;\\n                }\\n                return parent[index] = find(parent[index]);\\n            }\\n            int getParrentCount() {\\n                unordered_map<int, int> visited;\\n                for(int i = 0; i < num; i++) {\\n                    cout << parent[i] << \" \";\\n                    visited[parent[i]] = 1;\\n                }\\n                cout << endl;\\n                return visited.size();\\n            }\\n    };\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b) {\\n        return a[0] > b[0];\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), &comp);\\n        vector<UF> ufs;\\n        UF temp(n), temp2(n);\\n        ufs.push_back(temp);\\n        ufs.push_back(temp2);\\n        int m = edges.size(), res = 0;\\n        for(int i = 0; i < m; i++) {\\n            if(edges[i][0] == 3 && ufs[0].find(edges[i][1] - 1) != ufs[0].find(edges[i][2] - 1) && ufs[1].find(edges[i][1] - 1) != ufs[1].find(edges[i][2] - 1)) {\\n                ufs[0].Union(edges[i][1] - 1, edges[i][2] - 1);\\n                ufs[1].Union(edges[i][1] - 1, edges[i][2] - 1);\\n            } else if(edges[i][0] == 2 && ufs[1].find(edges[i][1] - 1) != ufs[1].find(edges[i][2] - 1)) {\\n                ufs[1].Union(edges[i][1] - 1, edges[i][2] - 1);\\n            } else if(edges[i][0] == 1 && ufs[0].find(edges[i][1] - 1) != ufs[0].find(edges[i][2] - 1)) {\\n                ufs[0].Union(edges[i][1] - 1, edges[i][2] - 1);\\n            } else {\\n                res++;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            ufs[0].find(i);\\n            ufs[1].find(i);\\n        }\\n        if(ufs[0].getParrentCount() != 1 || ufs[1].getParrentCount() != 1) {\\n            return -1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    class UF {\\n        vector<int> parent;\\n        vector<int> rank;\\n        int num;\\n        public:\\n            UF(int n) {\\n                parent = vector<int>(n, 0);\\n                rank = vector<int>(n, 0);\\n                for(int i = 0; i < n; i++) {\\n                    parent[i] = i;\\n                }\\n                num = n;\\n            }\\n            void Union(int a, int b) {\\n                int pa = find(a), pb = find(b);\\n                if(pa == pb) {\\n                    return;\\n                }\\n                if(rank[pa] > rank[pb]) {\\n                    parent[pb] = pa;\\n                } else if(rank[pa] < rank[pb]) {\\n                    parent[pa] = pb;\\n                } else {\\n                    parent[pb] = pa;\\n                    rank[pa]++;\\n                }\\n            }\\n            int find(int index) {\\n                if(parent[index] == index) {\\n                    return index;\\n                }\\n                return parent[index] = find(parent[index]);\\n            }\\n            int getParrentCount() {\\n                unordered_map<int, int> visited;\\n                for(int i = 0; i < num; i++) {\\n                    cout << parent[i] << \" \";\\n                    visited[parent[i]] = 1;\\n                }\\n                cout << endl;\\n                return visited.size();\\n            }\\n    };\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b) {\\n        return a[0] > b[0];\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), &comp);\\n        vector<UF> ufs;\\n        UF temp(n), temp2(n);\\n        ufs.push_back(temp);\\n        ufs.push_back(temp2);\\n        int m = edges.size(), res = 0;\\n        for(int i = 0; i < m; i++) {\\n            if(edges[i][0] == 3 && ufs[0].find(edges[i][1] - 1) != ufs[0].find(edges[i][2] - 1) && ufs[1].find(edges[i][1] - 1) != ufs[1].find(edges[i][2] - 1)) {\\n                ufs[0].Union(edges[i][1] - 1, edges[i][2] - 1);\\n                ufs[1].Union(edges[i][1] - 1, edges[i][2] - 1);\\n            } else if(edges[i][0] == 2 && ufs[1].find(edges[i][1] - 1) != ufs[1].find(edges[i][2] - 1)) {\\n                ufs[1].Union(edges[i][1] - 1, edges[i][2] - 1);\\n            } else if(edges[i][0] == 1 && ufs[0].find(edges[i][1] - 1) != ufs[0].find(edges[i][2] - 1)) {\\n                ufs[0].Union(edges[i][1] - 1, edges[i][2] - 1);\\n            } else {\\n                res++;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            ufs[0].find(i);\\n            ufs[1].find(i);\\n        }\\n        if(ufs[0].getParrentCount() != 1 || ufs[1].getParrentCount() != 1) {\\n            return -1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3469931,
                "title": "easy-dsu-approach-solution-without-class-explanation-c-disjoint-set-rank",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used is to first process all the edges of type 3, since they can be traversed by both Alice and Bob. For each edge of type 3, if the nodes connected by the edge are not already connected in both Alice\\'s and Bob\\'s connected components, the edge is added to both Alice\\'s and Bob\\'s connected components. If the nodes are already connected in either Alice\\'s or Bob\\'s connected components, the edge is considered redundant and is counted in the variable c.\\n\\nNext, the remaining edges of type 1 and type 2 are processed. For each edge of type 1, if the nodes connected by the edge are not already connected in Alice\\'s connected component, the edge is added to Alice\\'s connected component. If the nodes are already connected, the edge is considered redundant and is counted in the variable c. Similarly, for each edge of type 2, if the nodes connected by the edge are not already connected in Bob\\'s connected component, the edge is added to Bob\\'s connected component. If the nodes are already connected, the edge is considered redundant and is counted in the variable c.\\n\\nFinally, the code checks if all nodes in both Alice\\'s and Bob\\'s connected components are connected to the node n. If not, it means that the graph cannot be fully traversed by both Alice and Bob, and the function returns -1. Otherwise, the function returns the count of redundant edges (variable c).\\n\\n# Code\\n```\\nclass Solution {\\n    void makeset( vector<int>&parent, vector<int>&rank,int n){\\n\\t    for(int i=0;i<=n;i++){\\n\\t        parent[i]=i;\\n\\t        rank[i]=0;\\n\\t    }\\n\\t}\\n\\t\\n\\tint findparent( vector<int>&parent,int node){\\n\\t    if(parent[node]==node) return node;\\n\\t    return parent[node]=findparent(parent,parent[node]);\\n\\t}\\n\\t\\n\\tvoid unioinset( vector<int>&parent,int u,int v, vector<int>&rank){\\n\\t    u=findparent(parent,u);\\n\\t    v=findparent(parent,v);\\n\\t    if(rank[u]>rank[v]){\\n\\t        parent[v]=u;\\n\\t    }\\n\\t    else if(rank[u]<rank[v]){\\n\\t        parent[u]=v;\\n\\t    }\\n        else{\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n\\t}\\n\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int>parent1(n+1),rank1(n+1);\\n        vector<int>parent2(n+1),rank2(n+1);\\n        int c=0;\\n        makeset(parent1,rank1,n);\\n        makeset(parent2,rank2,n);\\n\\n         // Prioritize type3 edges first\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==3){\\n                if(findparent(parent1,edges[i][1])!=findparent(parent1,edges[i][2])){\\n                    unioinset(parent1,edges[i][1],edges[i][2],rank1);\\n                }\\n                if(findparent(parent2,edges[i][1])!=findparent(parent2,edges[i][2])){\\n                    unioinset(parent2,edges[i][1],edges[i][2],rank2);\\n                }\\n                else c++;\\n            }\\n        }\\n\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==1){\\n                if(findparent(parent1,edges[i][1])!=findparent(parent1,edges[i][2])){\\n                    unioinset(parent1,edges[i][1],edges[i][2],rank1);\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            else if(edges[i][0]==2){\\n                if(findparent(parent2,edges[i][1])!=findparent(parent2,edges[i][2])){\\n                    unioinset(parent2,edges[i][1],edges[i][2],rank2);\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<=n; i++){\\n            if(findparent(parent1, i) != findparent(parent1, n) || findparent(parent2, i) != findparent(parent2, n)){\\n                return -1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void makeset( vector<int>&parent, vector<int>&rank,int n){\\n\\t    for(int i=0;i<=n;i++){\\n\\t        parent[i]=i;\\n\\t        rank[i]=0;\\n\\t    }\\n\\t}\\n\\t\\n\\tint findparent( vector<int>&parent,int node){\\n\\t    if(parent[node]==node) return node;\\n\\t    return parent[node]=findparent(parent,parent[node]);\\n\\t}\\n\\t\\n\\tvoid unioinset( vector<int>&parent,int u,int v, vector<int>&rank){\\n\\t    u=findparent(parent,u);\\n\\t    v=findparent(parent,v);\\n\\t    if(rank[u]>rank[v]){\\n\\t        parent[v]=u;\\n\\t    }\\n\\t    else if(rank[u]<rank[v]){\\n\\t        parent[u]=v;\\n\\t    }\\n        else{\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n\\t}\\n\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int>parent1(n+1),rank1(n+1);\\n        vector<int>parent2(n+1),rank2(n+1);\\n        int c=0;\\n        makeset(parent1,rank1,n);\\n        makeset(parent2,rank2,n);\\n\\n         // Prioritize type3 edges first\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==3){\\n                if(findparent(parent1,edges[i][1])!=findparent(parent1,edges[i][2])){\\n                    unioinset(parent1,edges[i][1],edges[i][2],rank1);\\n                }\\n                if(findparent(parent2,edges[i][1])!=findparent(parent2,edges[i][2])){\\n                    unioinset(parent2,edges[i][1],edges[i][2],rank2);\\n                }\\n                else c++;\\n            }\\n        }\\n\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0]==1){\\n                if(findparent(parent1,edges[i][1])!=findparent(parent1,edges[i][2])){\\n                    unioinset(parent1,edges[i][1],edges[i][2],rank1);\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            else if(edges[i][0]==2){\\n                if(findparent(parent2,edges[i][1])!=findparent(parent2,edges[i][2])){\\n                    unioinset(parent2,edges[i][1],edges[i][2],rank2);\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<=n; i++){\\n            if(findparent(parent1, i) != findparent(parent1, n) || findparent(parent2, i) != findparent(parent2, n)){\\n                return -1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469685,
                "title": "java-solution-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        var alice = new UF(n);\\n        var bob = new UF(n);\\n\\n        var remainigEdges = edges.length;\\n        // avoid sorting by type desc, iterate for type 3\\n        for (var e : edges) {\\n            if (e[0] == 3 && (alice.union(e[1], e[2]) | bob.union(e[1], e[2])))\\n                --remainigEdges;\\n        }\\n        \\n        // for type 1 and 2 union in any order\\n        for (var e : edges) {\\n            if (e[0] == 2 && bob.union(e[1], e[2]))\\n                --remainigEdges;\\n            else if (e[0] == 1 && alice.union(e[1], e[2]))\\n                --remainigEdges;\\n        }\\n        \\n        if (!bob.isConnected() || !alice.isConnected())\\n            return -1;\\n\\n        return remainigEdges;\\n    }\\n}\\n\\nclass UF {\\n\\n    private final int[] id, rank;\\n    private int count;\\n\\n    UF(int N) {\\n        this.id = new int[N + 1];\\n        this.rank = new int[N + 1];\\n        this.count = N;\\n\\n        for (var i = 1; i <= N; ++i)\\n            id[i] = i;\\n    }\\n\\n    boolean union(int p, int q) {\\n        var pId = find(p);\\n        var qId = find(q);\\n\\n        if (pId == qId)\\n            return false;\\n\\n        if (rank[pId] < rank[qId])\\n            id[pId] = qId;\\n        else if (rank[pId] > rank[qId])\\n            id[qId] = pId;\\n        else {\\n            id[qId] = pId;\\n            rank[pId]++;\\n        }\\n\\n        --count;\\n\\n        return true;\\n    }\\n\\n    private int find(int p) {\\n        while (p != id[p])\\n            p = id[p];\\n\\n        return p;\\n    }\\n\\n    boolean isConnected() {\\n        return count == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        var alice = new UF(n);\\n        var bob = new UF(n);\\n\\n        var remainigEdges = edges.length;\\n        // avoid sorting by type desc, iterate for type 3\\n        for (var e : edges) {\\n            if (e[0] == 3 && (alice.union(e[1], e[2]) | bob.union(e[1], e[2])))\\n                --remainigEdges;\\n        }\\n        \\n        // for type 1 and 2 union in any order\\n        for (var e : edges) {\\n            if (e[0] == 2 && bob.union(e[1], e[2]))\\n                --remainigEdges;\\n            else if (e[0] == 1 && alice.union(e[1], e[2]))\\n                --remainigEdges;\\n        }\\n        \\n        if (!bob.isConnected() || !alice.isConnected())\\n            return -1;\\n\\n        return remainigEdges;\\n    }\\n}\\n\\nclass UF {\\n\\n    private final int[] id, rank;\\n    private int count;\\n\\n    UF(int N) {\\n        this.id = new int[N + 1];\\n        this.rank = new int[N + 1];\\n        this.count = N;\\n\\n        for (var i = 1; i <= N; ++i)\\n            id[i] = i;\\n    }\\n\\n    boolean union(int p, int q) {\\n        var pId = find(p);\\n        var qId = find(q);\\n\\n        if (pId == qId)\\n            return false;\\n\\n        if (rank[pId] < rank[qId])\\n            id[pId] = qId;\\n        else if (rank[pId] > rank[qId])\\n            id[qId] = pId;\\n        else {\\n            id[qId] = pId;\\n            rank[pId]++;\\n        }\\n\\n        --count;\\n\\n        return true;\\n    }\\n\\n    private int find(int p) {\\n        while (p != id[p])\\n            p = id[p];\\n\\n        return p;\\n    }\\n\\n    boolean isConnected() {\\n        return count == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469655,
                "title": "golang-unionfind",
                "content": "# Complexity\\n- Time complexity:\\nO(N+E)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc maxNumEdgesToRemove(n int, edges [][]int) int {\\n    // O(N)\\n    AliceUF := NewUnionFind(n)\\n    BobUF := NewUnionFind(n)\\n\\n    // O(E)\\n    edgesRequired := 0\\n    for _, edge := range edges {\\n        if edge[0] == 3 {\\n            // Check for both and increment edgesRequired if one of them required\\n            res1 := AliceUF.PerformUnion(edge)\\n            res2 := BobUF.PerformUnion(edge)\\n            if res1 || res2 {\\n                edgesRequired++\\n            }\\n        }\\n    }\\n\\n    // O(E)\\n    for _, edge := range edges {\\n        if edge[0] == 1 && AliceUF.PerformUnion(edge) {\\n            edgesRequired++\\n        } else if edge[0] == 2 && BobUF.PerformUnion(edge) {\\n            edgesRequired++\\n        }\\n    }\\n\\n    if AliceUF.isConnected() && BobUF.isConnected() {\\n        return len(edges) - edgesRequired\\n    }\\n\\n    return -1\\n}\\n\\ntype UnionFind struct {\\n    Parents []int\\n    Ranks []int\\n    Groups int\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    parents := make([]int, n+1)\\n    for i := 1; i <= n; i++ {\\n        parents[i] = i\\n    }\\n\\n    return &UnionFind{\\n        Parents : parents,\\n        Ranks : make([]int, n+1),\\n        Groups : n,\\n    }\\n}\\n\\nfunc (uf *UnionFind) PerformUnion(edge []int) bool {\\n    p1 := uf.findParent(edge[1])\\n    p2 := uf.findParent(edge[2])\\n\\n    if p1 == p2 {\\n        return false\\n    }   \\n\\n    if uf.Ranks[p1] > uf.Ranks[p2] {\\n        uf.Parents[p2] = p1\\n    } else if uf.Ranks[p2] > uf.Ranks[p1] {\\n        uf.Parents[p1] = p2\\n    } else {\\n        uf.Parents[p2] = p1\\n        uf.Ranks[p1]++\\n    }\\n\\n    uf.Groups--\\n    return true\\n}\\n\\nfunc (uf *UnionFind) findParent(idx int) int {\\n    if idx != uf.Parents[idx] {\\n        uf.Parents[idx] = uf.findParent(uf.Parents[idx])\\n    }\\n    return uf.Parents[idx]\\n}\\n\\nfunc (uf *UnionFind) isConnected() bool {\\n    return uf.Groups == 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxNumEdgesToRemove(n int, edges [][]int) int {\\n    // O(N)\\n    AliceUF := NewUnionFind(n)\\n    BobUF := NewUnionFind(n)\\n\\n    // O(E)\\n    edgesRequired := 0\\n    for _, edge := range edges {\\n        if edge[0] == 3 {\\n            // Check for both and increment edgesRequired if one of them required\\n            res1 := AliceUF.PerformUnion(edge)\\n            res2 := BobUF.PerformUnion(edge)\\n            if res1 || res2 {\\n                edgesRequired++\\n            }\\n        }\\n    }\\n\\n    // O(E)\\n    for _, edge := range edges {\\n        if edge[0] == 1 && AliceUF.PerformUnion(edge) {\\n            edgesRequired++\\n        } else if edge[0] == 2 && BobUF.PerformUnion(edge) {\\n            edgesRequired++\\n        }\\n    }\\n\\n    if AliceUF.isConnected() && BobUF.isConnected() {\\n        return len(edges) - edgesRequired\\n    }\\n\\n    return -1\\n}\\n\\ntype UnionFind struct {\\n    Parents []int\\n    Ranks []int\\n    Groups int\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    parents := make([]int, n+1)\\n    for i := 1; i <= n; i++ {\\n        parents[i] = i\\n    }\\n\\n    return &UnionFind{\\n        Parents : parents,\\n        Ranks : make([]int, n+1),\\n        Groups : n,\\n    }\\n}\\n\\nfunc (uf *UnionFind) PerformUnion(edge []int) bool {\\n    p1 := uf.findParent(edge[1])\\n    p2 := uf.findParent(edge[2])\\n\\n    if p1 == p2 {\\n        return false\\n    }   \\n\\n    if uf.Ranks[p1] > uf.Ranks[p2] {\\n        uf.Parents[p2] = p1\\n    } else if uf.Ranks[p2] > uf.Ranks[p1] {\\n        uf.Parents[p1] = p2\\n    } else {\\n        uf.Parents[p2] = p1\\n        uf.Ranks[p1]++\\n    }\\n\\n    uf.Groups--\\n    return true\\n}\\n\\nfunc (uf *UnionFind) findParent(idx int) int {\\n    if idx != uf.Parents[idx] {\\n        uf.Parents[idx] = uf.findParent(uf.Parents[idx])\\n    }\\n    return uf.Parents[idx]\\n}\\n\\nfunc (uf *UnionFind) isConnected() bool {\\n    return uf.Groups == 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469620,
                "title": "dsu",
                "content": "```\\nclass DSU\\n{\\n    public:\\n        vector<int> p;\\n        vector<int> r;\\n\\n         DSU(int n)\\n        {\\n            r.resize(n);\\n            p.resize(n);\\n\\n            for(int i=0;i<n;i++)\\n            {\\n                p[i] = i;\\n                r[i] = 0;\\n            }\\n        }\\n\\n        int find(int x)\\n        {\\n            if(p[x] == x)\\n                return x;\\n            return p[x] = find(p[x]);\\n        }\\n\\n        void makeUnion(int xx, int yy)\\n        {   int x = find(xx);\\n            int y = find(yy);\\n            if(x!=y)\\n            {\\n                if(r[x]>=r[y])\\n                {\\n                    p[y] = x;\\n                    r[x]+=r[y];\\n                }\\n                else\\n                {\\n                    p[x] = y;\\n                    r[y]+=r[x];            \\n                }\\n            }\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& e) {\\n        \\n        DSU a(n+1),b(n+1);\\n        \\n        int ae = 0,be = 0, re = 0;\\n        \\n        for(auto &i:e)\\n        {\\n            int t = i[0];\\n            int n1 = i[1];\\n            int n2 = i[2];\\n            \\n            if(t ==3)\\n            {\\n                if(a.find(n1)!=a.find(n2) || b.find(n1)!=b.find(n2))\\n                {\\n                    a.makeUnion(n1,n2);\\n                    b.makeUnion(n1,n2);\\n                    ae++;\\n                    be++;\\n                }\\n                else\\n                    re++;\\n            }\\n        }\\n        for(auto &i:e)\\n        {\\n            int t = i[0];\\n            int n1 = i[1];\\n            int n2 = i[2];\\n            if(t == 1)\\n            {\\n                if(a.find(n1)!=a.find(n2))\\n                {\\n                    a.makeUnion(n1,n2);\\n                    ae++;\\n                }\\n                else\\n                    re++;\\n\\n            }\\n            if(t == 2)\\n            {\\n                if(b.find(n1)!=b.find(n2))\\n                {\\n                    b.makeUnion(n1,n2);\\n                    be++;\\n                }\\n                else\\n                    re++;\\n\\n            }\\n        }\\n        \\n        return (ae == n-1 && be == n-1)?re:-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU\\n{\\n    public:\\n        vector<int> p;\\n        vector<int> r;\\n\\n         DSU(int n)\\n        {\\n            r.resize(n);\\n            p.resize(n);\\n\\n            for(int i=0;i<n;i++)\\n            {\\n                p[i] = i;\\n                r[i] = 0;\\n            }\\n        }\\n\\n        int find(int x)\\n        {\\n            if(p[x] == x)\\n                return x;\\n            return p[x] = find(p[x]);\\n        }\\n\\n        void makeUnion(int xx, int yy)\\n        {   int x = find(xx);\\n            int y = find(yy);\\n            if(x!=y)\\n            {\\n                if(r[x]>=r[y])\\n                {\\n                    p[y] = x;\\n                    r[x]+=r[y];\\n                }\\n                else\\n                {\\n                    p[x] = y;\\n                    r[y]+=r[x];            \\n                }\\n            }\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& e) {\\n        \\n        DSU a(n+1),b(n+1);\\n        \\n        int ae = 0,be = 0, re = 0;\\n        \\n        for(auto &i:e)\\n        {\\n            int t = i[0];\\n            int n1 = i[1];\\n            int n2 = i[2];\\n            \\n            if(t ==3)\\n            {\\n                if(a.find(n1)!=a.find(n2) || b.find(n1)!=b.find(n2))\\n                {\\n                    a.makeUnion(n1,n2);\\n                    b.makeUnion(n1,n2);\\n                    ae++;\\n                    be++;\\n                }\\n                else\\n                    re++;\\n            }\\n        }\\n        for(auto &i:e)\\n        {\\n            int t = i[0];\\n            int n1 = i[1];\\n            int n2 = i[2];\\n            if(t == 1)\\n            {\\n                if(a.find(n1)!=a.find(n2))\\n                {\\n                    a.makeUnion(n1,n2);\\n                    ae++;\\n                }\\n                else\\n                    re++;\\n\\n            }\\n            if(t == 2)\\n            {\\n                if(b.find(n1)!=b.find(n2))\\n                {\\n                    b.makeUnion(n1,n2);\\n                    be++;\\n                }\\n                else\\n                    re++;\\n\\n            }\\n        }\\n        \\n        return (ae == n-1 && be == n-1)?re:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469566,
                "title": "c-dsu-explained-with-detailed-approach",
                "content": "# Intuition\\n***Quite a simple logic to solve this particular problem***\\n1. Intially sort the edges in descending order of their typessuch that the type 3 edges get the highest priority\\n2. Then simple create 2 objects one for Alice and one for Bob\\n3. These DSU objects can be used to check whether both alice and bob can traverse the entire graph.\\n4. Now start iterating the edges :- \\n    4.1 if the edge is type 3 : add that edge for Alice and Bob;\\n    4.2 if the edge is type 2 : add the edge to the Bob object;\\n    4.3 if the edge is type 1 : add the edge to the Alice object;\\n5. At the end check whether both Alice and Bob can traverse the Entire Graph\\n\\n# Code\\n```\\nclass dsu{\\nprivate:\\n    vector<int>parent;\\n    int distinct_components;\\npublic:\\n    \\n    dsu(int n){\\n        distinct_components = n;\\n\\n        for(int i=0;i<=n;i++){\\n            parent.push_back(i);\\n        }\\n    }\\n    int find_parent(int u){\\n        if(parent[u] != u){\\n            parent[u] = find_parent(parent[u]);\\n        }\\n        return parent[u];\\n    }\\n    bool Union(int u, int v){\\n        if(find_parent(u) == find_parent(v)){\\n            return false;\\n        }\\n\\n        parent[find_parent(u)] = v;\\n        distinct_components--;\\n        return true;\\n    }\\n    bool united(){\\n        return distinct_components == 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n\\n        sort(edges.begin(),edges.end(), [](auto& it, auto &it2){\\n            return it[0] > it2[0];\\n        });\\n\\n        dsu *bob = new dsu(n);\\n        dsu *alice = new dsu(n);\\n        int edges_added = 0;\\n\\n        for(auto &it : edges){\\n            int type = it[0];\\n            int u = it[1];\\n            int v = it[2];\\n\\n            switch(type){\\n                case 3 : {\\n                    edges_added += (bob->Union(u,v) | alice->Union(u,v));\\n                    break;\\n                }\\n                case 2:{\\n                    edges_added += bob->Union(u,v);\\n                    break;\\n                }\\n                case 1 : {\\n                    edges_added += alice->Union(u,v);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (bob->united() && alice->united()) ? edges.size() - edges_added : -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass dsu{\\nprivate:\\n    vector<int>parent;\\n    int distinct_components;\\npublic:\\n    \\n    dsu(int n){\\n        distinct_components = n;\\n\\n        for(int i=0;i<=n;i++){\\n            parent.push_back(i);\\n        }\\n    }\\n    int find_parent(int u){\\n        if(parent[u] != u){\\n            parent[u] = find_parent(parent[u]);\\n        }\\n        return parent[u];\\n    }\\n    bool Union(int u, int v){\\n        if(find_parent(u) == find_parent(v)){\\n            return false;\\n        }\\n\\n        parent[find_parent(u)] = v;\\n        distinct_components--;\\n        return true;\\n    }\\n    bool united(){\\n        return distinct_components == 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n\\n        sort(edges.begin(),edges.end(), [](auto& it, auto &it2){\\n            return it[0] > it2[0];\\n        });\\n\\n        dsu *bob = new dsu(n);\\n        dsu *alice = new dsu(n);\\n        int edges_added = 0;\\n\\n        for(auto &it : edges){\\n            int type = it[0];\\n            int u = it[1];\\n            int v = it[2];\\n\\n            switch(type){\\n                case 3 : {\\n                    edges_added += (bob->Union(u,v) | alice->Union(u,v));\\n                    break;\\n                }\\n                case 2:{\\n                    edges_added += bob->Union(u,v);\\n                    break;\\n                }\\n                case 1 : {\\n                    edges_added += alice->Union(u,v);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (bob->united() && alice->united()) ? edges.size() - edges_added : -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469238,
                "title": "easy-approach-beats-95",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We start by creating two separate union-find data structures for Alice and Bob. Each data structure keeps track of the root of each node, which represents the set that the node belongs to.\\n- We first consider the edges that can be used by both Alice and Bob (i.e. type 3 edges). For each such edge, we perform a union operation on both union-find data structures. If the union is successful, we increment the edge count for both Alice and Bob. Otherwise, we increment the \"rejected\" edge count.\\n- We then make copies of both union-find data structures and consider the edges that can only be used by Alice and Bob respectively (i.e. type 1 and type 2 edges). For each such edge, we perform a union operation on the corresponding union-find data structure. If the union is successful, we increment the edge count for that user. Otherwise, we increment the \"rejected\" edge count.\\n- Finally, we check if both Alice and Bob were able to construct a spanning tree (i.e. they both used n-1 edges). If they did, we return the number of rejected edges. Otherwise, we return -1.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> rootA(n + 1);\\n        vector<int> rootB(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            rootA[i] = i;\\n            rootB[i] = i;\\n        }\\n\\n        int res = 0;\\n        int aliceEdges = 0;\\n        int bobEdges = 0;\\n\\n        \\n        for (auto& edge : edges) {\\n            if (edge[0] == 3) {\\n                if (uni(edge[1], edge[2], rootA)) {\\n                    aliceEdges++;\\n                    if (uni(edge[1], edge[2], rootB)) {\\n                        bobEdges++;\\n                    }\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        vector<int> rootA_copy = rootA;\\n\\n        \\n        for (auto& edge : edges) {\\n            if (edge[0] == 1) {\\n                if (uni(edge[1], edge[2], rootA)) {\\n                    aliceEdges++;\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        \\n        rootA = rootA_copy;\\n        for (auto& edge : edges) {\\n            if (edge[0] == 2) {\\n                if (uni(edge[1], edge[2], rootB)) {\\n                    bobEdges++;\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        return (aliceEdges == bobEdges && aliceEdges == n - 1) ? res : -1;\\n    }\\n\\n    bool uni(int a, int b, vector<int>& root) {\\n        int rootA = find(a, root);\\n        int rootB = find(b, root);\\n        if (rootA == rootB) {\\n            return false;\\n        }\\n        root[rootA] = rootB;\\n        return true;\\n    }\\n\\n    int find(int a, vector<int>& root) {\\n        if (root[a] != a) {\\n            root[a] = find(root[a], root);\\n        }\\n        return root[a];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> rootA(n + 1);\\n        vector<int> rootB(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            rootA[i] = i;\\n            rootB[i] = i;\\n        }\\n\\n        int res = 0;\\n        int aliceEdges = 0;\\n        int bobEdges = 0;\\n\\n        \\n        for (auto& edge : edges) {\\n            if (edge[0] == 3) {\\n                if (uni(edge[1], edge[2], rootA)) {\\n                    aliceEdges++;\\n                    if (uni(edge[1], edge[2], rootB)) {\\n                        bobEdges++;\\n                    }\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        vector<int> rootA_copy = rootA;\\n\\n        \\n        for (auto& edge : edges) {\\n            if (edge[0] == 1) {\\n                if (uni(edge[1], edge[2], rootA)) {\\n                    aliceEdges++;\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        \\n        rootA = rootA_copy;\\n        for (auto& edge : edges) {\\n            if (edge[0] == 2) {\\n                if (uni(edge[1], edge[2], rootB)) {\\n                    bobEdges++;\\n                } else {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        return (aliceEdges == bobEdges && aliceEdges == n - 1) ? res : -1;\\n    }\\n\\n    bool uni(int a, int b, vector<int>& root) {\\n        int rootA = find(a, root);\\n        int rootB = find(b, root);\\n        if (rootA == rootB) {\\n            return false;\\n        }\\n        root[rootA] = rootB;\\n        return true;\\n    }\\n\\n    int find(int a, vector<int>& root) {\\n        if (root[a] != a) {\\n            root[a] = find(root[a], root);\\n        }\\n        return root[a];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469227,
                "title": "c-disjoint-set-union-find",
                "content": "# Intuition && Approach\\nFirst use the common edges for both Alice and Bob, then the individual edges. Use DSU for easier implementation\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        DisjointSet Alice(n);\\n        DisjointSet Bob(n);\\n        int ans = 0;\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0] == 3){\\n                bool a = Alice.findUPar(edges[i][1]) == Alice.findUPar(edges[i][2]);\\n                bool b = Bob.findUPar(edges[i][1]) == Bob.findUPar(edges[i][2]);\\n                if(a && b)\\n                    ans++;\\n                else if(!a && b)\\n                    Alice.unionByRank(edges[i][1],edges[i][2]);\\n                else if(a && !b)\\n                    Bob.unionByRank(edges[i][1],edges[i][2]);\\n                else if(!a && !b){\\n                    Alice.unionByRank(edges[i][1],edges[i][2]);\\n                    Bob.unionByRank(edges[i][1],edges[i][2]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0] == 1){\\n                bool a = Alice.findUPar(edges[i][1]) == Alice.findUPar(edges[i][2]);\\n                if(a)\\n                    ans++;\\n                else\\n                    Alice.unionByRank(edges[i][1],edges[i][2]);\\n            }\\n            else if(edges[i][0] == 2){\\n                bool b = Bob.findUPar(edges[i][1]) == Bob.findUPar(edges[i][2]);\\n                if(b)\\n                    ans++;\\n                else\\n                    Bob.unionByRank(edges[i][1],edges[i][2]);\\n            }\\n        }\\n        int al = Alice.findUPar(1);\\n        int bo = Bob.findUPar(1);\\n        for(int i=1;i<=n;i++){\\n            if(al != Alice.findUPar(i))\\n                return -1;\\n            if(bo != Bob.findUPar(i))\\n                return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        DisjointSet Alice(n);\\n        DisjointSet Bob(n);\\n        int ans = 0;\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0] == 3){\\n                bool a = Alice.findUPar(edges[i][1]) == Alice.findUPar(edges[i][2]);\\n                bool b = Bob.findUPar(edges[i][1]) == Bob.findUPar(edges[i][2]);\\n                if(a && b)\\n                    ans++;\\n                else if(!a && b)\\n                    Alice.unionByRank(edges[i][1],edges[i][2]);\\n                else if(a && !b)\\n                    Bob.unionByRank(edges[i][1],edges[i][2]);\\n                else if(!a && !b){\\n                    Alice.unionByRank(edges[i][1],edges[i][2]);\\n                    Bob.unionByRank(edges[i][1],edges[i][2]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][0] == 1){\\n                bool a = Alice.findUPar(edges[i][1]) == Alice.findUPar(edges[i][2]);\\n                if(a)\\n                    ans++;\\n                else\\n                    Alice.unionByRank(edges[i][1],edges[i][2]);\\n            }\\n            else if(edges[i][0] == 2){\\n                bool b = Bob.findUPar(edges[i][1]) == Bob.findUPar(edges[i][2]);\\n                if(b)\\n                    ans++;\\n                else\\n                    Bob.unionByRank(edges[i][1],edges[i][2]);\\n            }\\n        }\\n        int al = Alice.findUPar(1);\\n        int bo = Bob.findUPar(1);\\n        for(int i=1;i<=n;i++){\\n            if(al != Alice.findUPar(i))\\n                return -1;\\n            if(bo != Bob.findUPar(i))\\n                return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469177,
                "title": "java-dsu-100-faster-solution-with-explanation",
                "content": "\\n# Code\\n```\\nclass DSU {\\n    int[] parent;\\n    int[] rank;\\n    public DSU(int n) { // To call it when needed and to make code look cleaner\\n        parent = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    public int find(int x) {\\n        if (parent[x] == x) {\\n            return x;\\n        }\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int xl = find(x); \\n        int yl = find(y);\\n        if(xl == yl)return false;   // belong to same group, so there\\'s a redundant connection\\n\\n        if (rank[xl] < rank[yl]) {\\n            parent[xl] = yl;\\n            return true;\\n        } \\n        if (rank[xl] > rank[yl]) {\\n            parent[yl] = xl;\\n            return true;\\n        }     \\n        parent[xl] = yl;\\n        rank[yl]++;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n\\n        Arrays.sort(edges, (a, b) -> b[0]-a[0]); // to give edges that can be travelled by both more priority\\n        DSU alice = new DSU(n+1);\\n        DSU bob = new DSU(n+1);\\n        int redundant = 0;\\n        int aliceEdges = 0;\\n        int bobEdges = 0;\\n\\n        for (int[] edge : edges) {\\n            if (edge[0]==1){\\n                if (alice.union(edge[1], edge[2])) {\\n                    aliceEdges++;\\n                } else {\\n                    redundant++;\\n                }\\n            }\\n            else if (edge[0] == 2) {\\n                if (bob.union(edge[1], edge[2])) {\\n                    bobEdges++;\\n                } \\n                else {\\n                    redundant++;\\n                }\\n            } \\n            else{\\n                if(alice.union(edge[1], edge[2])) {\\n                    bob.union(edge[1], edge[2]); // can be travelled by both \\n                    aliceEdges++;\\n                    bobEdges++;\\n                } \\n                else {\\n                    redundant++;  // no need to this connection\\n                }\\n            }\\n        }\\n        return (bobEdges == n - 1 && aliceEdges == n - 1) ? redundant : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass DSU {\\n    int[] parent;\\n    int[] rank;\\n    public DSU(int n) { // To call it when needed and to make code look cleaner\\n        parent = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    public int find(int x) {\\n        if (parent[x] == x) {\\n            return x;\\n        }\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int xl = find(x); \\n        int yl = find(y);\\n        if(xl == yl)return false;   // belong to same group, so there\\'s a redundant connection\\n\\n        if (rank[xl] < rank[yl]) {\\n            parent[xl] = yl;\\n            return true;\\n        } \\n        if (rank[xl] > rank[yl]) {\\n            parent[yl] = xl;\\n            return true;\\n        }     \\n        parent[xl] = yl;\\n        rank[yl]++;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n\\n        Arrays.sort(edges, (a, b) -> b[0]-a[0]); // to give edges that can be travelled by both more priority\\n        DSU alice = new DSU(n+1);\\n        DSU bob = new DSU(n+1);\\n        int redundant = 0;\\n        int aliceEdges = 0;\\n        int bobEdges = 0;\\n\\n        for (int[] edge : edges) {\\n            if (edge[0]==1){\\n                if (alice.union(edge[1], edge[2])) {\\n                    aliceEdges++;\\n                } else {\\n                    redundant++;\\n                }\\n            }\\n            else if (edge[0] == 2) {\\n                if (bob.union(edge[1], edge[2])) {\\n                    bobEdges++;\\n                } \\n                else {\\n                    redundant++;\\n                }\\n            } \\n            else{\\n                if(alice.union(edge[1], edge[2])) {\\n                    bob.union(edge[1], edge[2]); // can be travelled by both \\n                    aliceEdges++;\\n                    bobEdges++;\\n                } \\n                else {\\n                    redundant++;  // no need to this connection\\n                }\\n            }\\n        }\\n        return (bobEdges == n - 1 && aliceEdges == n - 1) ? redundant : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469150,
                "title": "easiest-code-using-disjoint-set-data-structure",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\tclass Disjoint\\n\\t{\\n\\tpublic:\\n\\t\\tvector<int> parent;\\n\\t\\tvector<int> size;\\n\\n\\t\\tDisjoint(int n)\\n\\t\\t{\\n\\t\\t\\tparent.resize(n+1);\\n\\t\\t\\tsize.resize(n+1, 1);\\n\\t\\t\\tfor(int i = 0; i <= n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint findParent(int u)\\n\\t\\t{\\n\\t\\t\\tif(u == parent[u])\\n\\t\\t\\t\\treturn u;\\n\\n\\t\\t\\treturn parent[u] = findParent(parent[u]);\\n\\t\\t}\\n\\n\\n\\t\\tbool unionBySize(int u, int v)\\n\\t\\t{\\n\\t\\t\\tint ultp_u = findParent(u);\\n\\t\\t\\tint ultp_v = findParent(v);\\n\\n\\t\\t\\tif(ultp_u == ultp_v)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\telse if (size[ultp_u] < size[ultp_v])\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[ultp_u] = ultp_v;\\n\\t\\t\\t\\tsize[ultp_v] += size[ultp_u];\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[ultp_v] = ultp_u;\\n\\t\\t\\t\\tsize[ultp_u] += size[ultp_v];\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t};\\n\\n\\t\\tbool static cmp(vector<int> &v1, vector<int> &v2)\\n\\t\\t{\\n\\t\\t\\treturn v1[0] > v2[0];\\n\\t\\t}\\n\\n\\n\\t\\tint maxNumEdgesToRemove(int n, vector<vector<int>>& e) \\n\\t\\t{\\n\\t\\t\\tDisjoint bob(n);\\n\\t\\t\\tDisjoint alice(n);\\n\\n\\n\\t\\t\\tsort(e.begin(), e.end(), cmp);\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint bs = 0;\\n\\t\\t\\tint as = 0;\\n\\t\\t\\tfor(int i = 0; i < e.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint u = e[i][1];\\n\\t\\t\\t\\tint v = e[i][2];\\n\\t\\t\\t\\tint t = e[i][0];\\n\\n\\t\\t\\t\\tif(t == 3)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbool b1 = bob.unionBySize(u, v);\\n\\t\\t\\t\\t\\tbool b2 = alice.unionBySize(u, v);\\n\\t\\t\\t\\t\\tif(b1 == false && b1 == false)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(b1 == true)\\n\\t\\t\\t\\t\\t\\tbs++;\\n\\t\\t\\t\\t\\tif(b2 == true)\\n\\t\\t\\t\\t\\t\\tas++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(t == 2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbool b1 = bob.unionBySize(u, v);\\n\\t\\t\\t\\t\\tif(b1 == false)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(b1 == true)\\n\\t\\t\\t\\t\\t\\tbs++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbool b1 = alice.unionBySize(u, v);\\n\\t\\t\\t\\t\\tif(b1 == false)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(b1 == true)\\n\\t\\t\\t\\t\\t\\tas++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(bs != n-1 || as != n-1)\\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\tclass Disjoint\\n\\t{\\n\\tpublic:\\n\\t\\tvector<int> parent;\\n\\t\\tvector<int> size;\\n\\n\\t\\tDisjoint(int n)\\n\\t\\t{\\n\\t\\t\\tparent.resize(n+1);\\n\\t\\t\\tsize.resize(n+1, 1);\\n\\t\\t\\tfor(int i = 0; i <= n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3469043,
                "title": "c-simple-union-find",
                "content": "This one is simpler and cleaner but because of sorting time complexity becomes $O(ElogE)$. You want to solve type 3 cases first, because they cover both Alice and Bob\\'s graph.\\n# Code [With Sorting (Slower)]\\n```\\n//Normal DSU class with Path compression and Union by Rank\\nclass DSU{\\n    public:\\n    vector<int> P;\\n    vector<int> Rank;\\n    int distinct; //Count of unconnected graphs \\n    DSU(int n){\\n        distinct = n; //Initially no node is connected\\n        Rank = vector<int>(n,0);\\n        for(int i=0;i<n;i++){\\n            P.push_back(i);\\n        }\\n    }\\n\\n    void Union(int a, int b){\\n        int x = Find(a);\\n        int y = Find(b);\\n        \\n        if(x!=y){\\n            distinct--;\\n            if(Rank[x] > Rank[y]) P[y]=x;\\n            else if(Rank[x] < Rank[y]) P[x]=y;\\n            else{\\n                Rank[x]++;\\n                P[y] = x;\\n            }\\n        }\\n    }\\n\\n    int Find(int x){\\n        if(P[x]==x) return x;\\n        return P[x] = Find(P[x]);\\n    }\\n\\n    bool SameGroup(int a, int b){\\n        return Find(a)==Find(b);\\n    }\\n\\n    bool valid(){\\n        return distinct==1;  //All node are connected and have one root as a result\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        //Sorting so that we get type 3, then 2 and 1\\n        sort(edges.begin(),edges.end(),greater<vector<int>>());\\n\\n        //Create graph for both Alice and Bob\\n        DSU A(n);\\n        DSU B(n);\\n        int ans = 0;\\n        for(auto&x:edges){\\n            int type = x[0];\\n            int p = x[1]-1;\\n            int q = x[2]-1;\\n            bool skip1 = false;\\n            bool skip2 = false;\\n\\n            //Alice\\'s Graph\\n            if(type==1 || type==3){\\n                //If already present skip\\n                if(A.SameGroup(p,q)) skip1 = true;\\n                //Else add to graph\\n                else A.Union(p,q);\\n            }\\n\\n            //Bob\\'s Graph\\n            if(type==2 || type==3){\\n                //If already present skip\\n                if(B.SameGroup(p,q)) skip2 = true;\\n                //Else add to graph\\n                else B.Union(p,q);\\n            }\\n            //If either of them did not skip, do not remove this edge\\n            //Else add 1 to skipped edges\\n            ans += (skip1||skip2);\\n        }\\n        //Check if all nodes are covered\\n        if(A.valid() && B.valid()) return ans;\\n        return -1;\\n    }\\n};\\n```\\n______________________________\\nDont sort, just traverse multiple times. First for type 3. Then for type 1 and 2 together. Complexity becomes $O(E)$\\n# Code [Without Sorting (Faster)]\\n```\\n//Same DSU class as previous one\\nclass DSU{\\n    public:\\n    vector<int> P;\\n    vector<int> Rank;\\n    int distinct;\\n    DSU(int n){\\n        distinct = n;\\n        Rank = vector<int>(n,0);\\n        for(int i=0;i<n;i++){\\n            P.push_back(i);\\n        }\\n    }\\n\\n    void Union(int a, int b){\\n        int x = Find(a);\\n        int y = Find(b);\\n        \\n        if(x!=y){\\n            distinct--;\\n            if(Rank[x] > Rank[y]) P[y]=x;\\n            else if(Rank[x] < Rank[y]) P[x]=y;\\n            else{\\n                Rank[x]++;\\n                P[y] = x;\\n            }\\n        }\\n    }\\n\\n    int Find(int x){\\n        if(P[x]==x) return x;\\n        return P[x] = Find(P[x]);\\n    }\\n\\n    bool SameGroup(int a, int b){\\n        return Find(a)==Find(b);\\n    }\\n\\n    bool valid(){\\n        return distinct==1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        DSU A(n);\\n        DSU B(n);\\n        int ans = 0;\\n\\n        //For Type 3\\n        for(auto&x:edges){\\n            int type = x[0];\\n            int p = x[1]-1;\\n            int q = x[2]-1;\\n            bool skip1 = false;\\n            bool skip2 = false;\\n            if(type==3){\\n                if(A.SameGroup(p,q)) skip1 = true;\\n                else A.Union(p,q);\\n                if(B.SameGroup(p,q)) skip2 = true;\\n                else B.Union(p,q);\\n            }\\n            ans += (skip1||skip2);\\n        }\\n\\n        //For Type 1 and Type 2\\n        for(auto&x:edges){\\n            int type = x[0];\\n            int p = x[1]-1;\\n            int q = x[2]-1;\\n            bool skip1 = false;\\n            bool skip2 = false;\\n            if(type==1){\\n                if(A.SameGroup(p,q)) skip1 = true;\\n                else A.Union(p,q);\\n            }\\n            if(type==2){\\n                if(B.SameGroup(p,q)) skip2 = true;\\n                else B.Union(p,q);\\n            }\\n            ans += (skip1||skip2);\\n        }\\n        if(A.valid() && B.valid()) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n//Normal DSU class with Path compression and Union by Rank\\nclass DSU{\\n    public:\\n    vector<int> P;\\n    vector<int> Rank;\\n    int distinct; //Count of unconnected graphs \\n    DSU(int n){\\n        distinct = n; //Initially no node is connected\\n        Rank = vector<int>(n,0);\\n        for(int i=0;i<n;i++){\\n            P.push_back(i);\\n        }\\n    }\\n\\n    void Union(int a, int b){\\n        int x = Find(a);\\n        int y = Find(b);\\n        \\n        if(x!=y){\\n            distinct--;\\n            if(Rank[x] > Rank[y]) P[y]=x;\\n            else if(Rank[x] < Rank[y]) P[x]=y;\\n            else{\\n                Rank[x]++;\\n                P[y] = x;\\n            }\\n        }\\n    }\\n\\n    int Find(int x){\\n        if(P[x]==x) return x;\\n        return P[x] = Find(P[x]);\\n    }\\n\\n    bool SameGroup(int a, int b){\\n        return Find(a)==Find(b);\\n    }\\n\\n    bool valid(){\\n        return distinct==1;  //All node are connected and have one root as a result\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        //Sorting so that we get type 3, then 2 and 1\\n        sort(edges.begin(),edges.end(),greater<vector<int>>());\\n\\n        //Create graph for both Alice and Bob\\n        DSU A(n);\\n        DSU B(n);\\n        int ans = 0;\\n        for(auto&x:edges){\\n            int type = x[0];\\n            int p = x[1]-1;\\n            int q = x[2]-1;\\n            bool skip1 = false;\\n            bool skip2 = false;\\n\\n            //Alice\\'s Graph\\n            if(type==1 || type==3){\\n                //If already present skip\\n                if(A.SameGroup(p,q)) skip1 = true;\\n                //Else add to graph\\n                else A.Union(p,q);\\n            }\\n\\n            //Bob\\'s Graph\\n            if(type==2 || type==3){\\n                //If already present skip\\n                if(B.SameGroup(p,q)) skip2 = true;\\n                //Else add to graph\\n                else B.Union(p,q);\\n            }\\n            //If either of them did not skip, do not remove this edge\\n            //Else add 1 to skipped edges\\n            ans += (skip1||skip2);\\n        }\\n        //Check if all nodes are covered\\n        if(A.valid() && B.valid()) return ans;\\n        return -1;\\n    }\\n};\\n```\n```\\n//Same DSU class as previous one\\nclass DSU{\\n    public:\\n    vector<int> P;\\n    vector<int> Rank;\\n    int distinct;\\n    DSU(int n){\\n        distinct = n;\\n        Rank = vector<int>(n,0);\\n        for(int i=0;i<n;i++){\\n            P.push_back(i);\\n        }\\n    }\\n\\n    void Union(int a, int b){\\n        int x = Find(a);\\n        int y = Find(b);\\n        \\n        if(x!=y){\\n            distinct--;\\n            if(Rank[x] > Rank[y]) P[y]=x;\\n            else if(Rank[x] < Rank[y]) P[x]=y;\\n            else{\\n                Rank[x]++;\\n                P[y] = x;\\n            }\\n        }\\n    }\\n\\n    int Find(int x){\\n        if(P[x]==x) return x;\\n        return P[x] = Find(P[x]);\\n    }\\n\\n    bool SameGroup(int a, int b){\\n        return Find(a)==Find(b);\\n    }\\n\\n    bool valid(){\\n        return distinct==1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        DSU A(n);\\n        DSU B(n);\\n        int ans = 0;\\n\\n        //For Type 3\\n        for(auto&x:edges){\\n            int type = x[0];\\n            int p = x[1]-1;\\n            int q = x[2]-1;\\n            bool skip1 = false;\\n            bool skip2 = false;\\n            if(type==3){\\n                if(A.SameGroup(p,q)) skip1 = true;\\n                else A.Union(p,q);\\n                if(B.SameGroup(p,q)) skip2 = true;\\n                else B.Union(p,q);\\n            }\\n            ans += (skip1||skip2);\\n        }\\n\\n        //For Type 1 and Type 2\\n        for(auto&x:edges){\\n            int type = x[0];\\n            int p = x[1]-1;\\n            int q = x[2]-1;\\n            bool skip1 = false;\\n            bool skip2 = false;\\n            if(type==1){\\n                if(A.SameGroup(p,q)) skip1 = true;\\n                else A.Union(p,q);\\n            }\\n            if(type==2){\\n                if(B.SameGroup(p,q)) skip2 = true;\\n                else B.Union(p,q);\\n            }\\n            ans += (skip1||skip2);\\n        }\\n        if(A.valid() && B.valid()) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468700,
                "title": "union-find-python-js-solution",
                "content": "Hello **Tenno Leetcoders**,\\nFor this problem, Alice and Bob have an undirected graph with n nodes, where each node represents a point in the graph. The graph has three types of edges:\\n\\n1) Type 1: These edges can only be traversed by Alice.\\n\\n2) Type 2: These edges can only be traversed by Bob.\\n\\n3) Type 3: These edges can be traversed by both Alice and Bob.\\n\\nWe are asked to find the `maximum number of edges` that can be removed from the graph such that after removing the edges, Alice and Bob can still traverse the graph fully, meaning starting from any node, Alice and Bob can still reach all other nodes.\\n\\nYou are given an array edges, where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`. \\n\\nif we have `edges[i] = [1, 2, 3]`, this represent that there is a `Type 1` edge between `nodes 2` and `3`, and Alice can traverse this edge.\\n\\nWe want to find `the maximum number of edges that can be removed` such that the graph can still be fully traversed by both Alice and Bob or return -1 if it is not possible to traverse the graph fully even after removing some edges\\n\\n### Explanation\\n\\nThe idea behind this problem is to keep track of which edges Alice and Bob can iterate separately and which edges both of them can iterate together. For this approach, we can use three different `Union Find`. For each of the three types of edges, we can create three different instances of Union Find\\n\\nWe will traverse through the edges and use these Union Find instances to keep track of the connected component for each type of edge separately.\\n\\nFor each `Type`, we will call `union() method`:\\n\\n- Type 1 will be called for Alice to merge componenet containing u and v\\n\\n- Type 2 will be called for Bob to merge corresponding components\\n\\n- Type 3 will be called for Alice and Bob to merge the componenets for both, since the edges can be traveled by both\\n\\nWith all the edges already processed, we need to check if Alice and Bob can traverse the entire graph by checking the number of connected components in both `Union Find` instance will be equal to one.\\n\\nIf both can travel the entire graph, we can start removing edges to see how many can be removed while still being able to traverse the graph\\n\\nThen we traverse through the edges counting type 3 edges that were merged by both Alice and Bob, and as well for type 1 and type 2 edges that was merged by either Alice or Bob\\n\\nWe can then check if both can traverse the graph by checking if they have more than one connected component\\n\\nIf either Alice or Bob has more than one connected component, then it means that there are some vertices that are not reachable by either Alice or Bob as the problem\\'s requirement should be able to remove edges such that all vertices are reachable by both of them. \\n\\nTherefore, if there is more than one connected component for either Alice or Bob, we return -1 to indicate that it is not possible to remove edges to satisfy the requirement.\\n\\nThe `maximum number of edges that can be removed` while still being able to fully traversed by both will be the sum of the counts of `type1, type2 and type3 edges` denoted as `alice_remove, bob_remove, both_remove` or `return -1` as they were not able to traverse the whole graph\\n\\n\\n### Code\\n\\n**Python**\\n\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n + 1)]\\n        self.size = [1] * (n + 1)\\n        self.components = n\\n\\n    def find(self, x):\\n        # If the parent of x is not x, recursively find the parent of x\\n        if self.parent[x] != x: self.parent[x] = self.find(self.parent[x])\\n        # Return the parent of x\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        # Find the parents of x and y\\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        # If the parents are the same, x and y are already in the same component\\n        if x_root == y_root: return False\\n        # Merge the smaller component into the larger component\\n        if self.size[x_root] < self.size[y_root]: x_root, y_root = y_root, x_root\\n        self.size[x_root] += self.size[y_root]\\n        self.parent[y_root] = x_root\\n        self.components -= 1\\n        return True\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        alice = UnionFind(n)\\n        bob = UnionFind(n)\\n        both = UnionFind(n)\\n        alice_remove = bob_remove = both_remove = 0\\n\\n        # Process type 3 edges\\n        for t, u, v in edges:\\n            if t == 3:\\n                if both.union(u, v):\\n                    alice.union(u, v)\\n                    bob.union(u, v)\\n                else:\\n                    both_remove += 1\\n        \\n        # Process type 1 edges\\n        for t, u, v in edges:\\n            if t == 1:\\n                if not alice.union(u, v):\\n                    alice_remove += 1\\n        \\n        # Process type 2 edges\\n        for t, u, v in edges:\\n            if t == 2:\\n                if not bob.union(u, v):\\n                    bob_remove += 1\\n        \\n        # Check if both Alice and Bob can traverse the graph\\n        if alice.components > 1 or bob.components > 1:\\n            return -1\\n        \\n        return alice_remove + bob_remove + both_remove\\n```\\n\\n\\n\\n**JavaScript**\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\n\\nclass UnionFind{\\n    \\n    constructor(n){\\n        this.parent = Array.from({length: n+1}, (_,i) => i)\\n        this.size = Array(n+1).fill(1);\\n        this.components = n\\n    }\\n    \\n    find(x) {\\n        return this.parent[x] !== x ? this.parent[x] = this.find(this.parent[x]) : this.parent[x];\\n    }\\n    \\n    union(x,y){\\n        const rootX = this.find(x)\\n        const rootY = this.find(y)\\n        \\n        if(rootX === rootY) return false\\n        const [smaller, bigger] = this.size[rootX] < this.size[rootY] ? [rootX, rootY] : [rootY, rootX];\\n  \\n        this.size[smaller] += this.size[bigger];\\n        this.parent[bigger] = smaller;\\n        this.components -= 1    \\n        return true\\n    }\\n    \\n}\\n\\n\\nvar maxNumEdgesToRemove = function(n, edges) {\\n    const alice = new UnionFind(n);\\n    const bob = new UnionFind(n);\\n    const both = new UnionFind(n);\\n    let aliceRemove = 0, bobRemove = 0, bothRemove = 0;\\n\\n    // Process type 3 edges\\n    for(const [type, u, v] of edges){\\n        if(type === 3){\\n            both.union(u,v) ? (alice.union(u,v), bob.union(u,v) ): bothRemove +=1 \\n        }\\n    }\\n\\n    // Process type 1 edges\\n    for(const[type, u,v] of edges){  \\n        if(type === 1)\\n            !alice.union(u, v) && aliceRemove++\\n        }\\n\\n    // Process type 2 edges\\n    for(const[type, u,v] of edges){  \\n        if(type === 2){\\n            !bob.union(u, v) && bobRemove++ \\n        }\\n    }\\n    \\n    // Check if both Alice and Bob can traverse the graph\\n    if(alice.components > 1 || bob.components > 1) return -1\\n    \\n    return aliceRemove + bobRemove + bothRemove\\n};\\n```\\n\\n#### Time Complexity: O(m*\\u03B1(n))\\n\\nUnion-Find algorithm with union-by-rank and path compression is `O(m\\u03B1(n))` where n is the number of elements and m is the number of operations.  `\\u03B1(n)` is the inverse Ackermann function, which grows very slowly and is effectively constant for practical values of n.\\n\\n#### Space Complexity: O(n)\\n\\nwhere n is the number of vertices in the graph, because we need to store the parent and size arrays for each Union-Find data structure.\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n + 1)]\\n        self.size = [1] * (n + 1)\\n        self.components = n\\n\\n    def find(self, x):\\n        # If the parent of x is not x, recursively find the parent of x\\n        if self.parent[x] != x: self.parent[x] = self.find(self.parent[x])\\n        # Return the parent of x\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        # Find the parents of x and y\\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        # If the parents are the same, x and y are already in the same component\\n        if x_root == y_root: return False\\n        # Merge the smaller component into the larger component\\n        if self.size[x_root] < self.size[y_root]: x_root, y_root = y_root, x_root\\n        self.size[x_root] += self.size[y_root]\\n        self.parent[y_root] = x_root\\n        self.components -= 1\\n        return True\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        alice = UnionFind(n)\\n        bob = UnionFind(n)\\n        both = UnionFind(n)\\n        alice_remove = bob_remove = both_remove = 0\\n\\n        # Process type 3 edges\\n        for t, u, v in edges:\\n            if t == 3:\\n                if both.union(u, v):\\n                    alice.union(u, v)\\n                    bob.union(u, v)\\n                else:\\n                    both_remove += 1\\n        \\n        # Process type 1 edges\\n        for t, u, v in edges:\\n            if t == 1:\\n                if not alice.union(u, v):\\n                    alice_remove += 1\\n        \\n        # Process type 2 edges\\n        for t, u, v in edges:\\n            if t == 2:\\n                if not bob.union(u, v):\\n                    bob_remove += 1\\n        \\n        # Check if both Alice and Bob can traverse the graph\\n        if alice.components > 1 or bob.components > 1:\\n            return -1\\n        \\n        return alice_remove + bob_remove + both_remove\\n```\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\n\\nclass UnionFind{\\n    \\n    constructor(n){\\n        this.parent = Array.from({length: n+1}, (_,i) => i)\\n        this.size = Array(n+1).fill(1);\\n        this.components = n\\n    }\\n    \\n    find(x) {\\n        return this.parent[x] !== x ? this.parent[x] = this.find(this.parent[x]) : this.parent[x];\\n    }\\n    \\n    union(x,y){\\n        const rootX = this.find(x)\\n        const rootY = this.find(y)\\n        \\n        if(rootX === rootY) return false\\n        const [smaller, bigger] = this.size[rootX] < this.size[rootY] ? [rootX, rootY] : [rootY, rootX];\\n  \\n        this.size[smaller] += this.size[bigger];\\n        this.parent[bigger] = smaller;\\n        this.components -= 1    \\n        return true\\n    }\\n    \\n}\\n\\n\\nvar maxNumEdgesToRemove = function(n, edges) {\\n    const alice = new UnionFind(n);\\n    const bob = new UnionFind(n);\\n    const both = new UnionFind(n);\\n    let aliceRemove = 0, bobRemove = 0, bothRemove = 0;\\n\\n    // Process type 3 edges\\n    for(const [type, u, v] of edges){\\n        if(type === 3){\\n            both.union(u,v) ? (alice.union(u,v), bob.union(u,v) ): bothRemove +=1 \\n        }\\n    }\\n\\n    // Process type 1 edges\\n    for(const[type, u,v] of edges){  \\n        if(type === 1)\\n            !alice.union(u, v) && aliceRemove++\\n        }\\n\\n    // Process type 2 edges\\n    for(const[type, u,v] of edges){  \\n        if(type === 2){\\n            !bob.union(u, v) && bobRemove++ \\n        }\\n    }\\n    \\n    // Check if both Alice and Bob can traverse the graph\\n    if(alice.components > 1 || bob.components > 1) return -1\\n    \\n    return aliceRemove + bobRemove + bothRemove\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468671,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int notUsed = 0;\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        if (parent[node] == node) return node;\\n        else return findParent(parent, parent[node]);\\n    }\\n    bool merge(vector<int>&parent, vector<int>&rank, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n\\n        if (parent1 == parent2) \\n            return false;\\n            \\n        else\\n        {\\n            if (rank[parent1] == rank[parent2]){\\n                parent[parent1] = parent2; \\n                rank[parent2]++; \\n            }\\n            else if (rank[parent1] < rank[parent2])\\n                parent[parent1] = parent2; \\n            else\\n                parent[parent2] = parent1;\\n            return true;\\n        }\\n    }\\n\\n    void solve(vector<vector<int>>&edges, vector<int>&parent, vector<int>&rank, int& componentCount, int currType){\\n        \\n        for (vector<int>&edge : edges){\\n\\n            if (edge[0] != currType) \\n                continue;      \\n              \\n            bool merged = merge(parent, rank, edge[1], edge[2]);\\n            if (!merged) notUsed++;\\n            else componentCount--;\\n        }\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) \\n    {\\n\\n        int componentCount = n;\\n\\n        vector<int>parent(n + 1);\\n        vector<int>rank(n + 1, 0);\\n\\n        for (int i = 1; i <= n; i++) \\n            parent[i] = i;\\n\\n        solve(edges, parent, rank, componentCount, 3);\\n        \\n        vector<int>aliceParent = parent, aliceRank = rank;\\n        int aliceComponentCount = componentCount;\\n        solve(edges, aliceParent, aliceRank, aliceComponentCount, 1);\\n        if (aliceComponentCount != 1) \\n            return -1;  \\n        vector<int>bobParent = parent, bobRank = rank; \\n        int bobComponentCount = componentCount;\\n        solve(edges, bobParent, bobRank, bobComponentCount, 2);\\n        if (bobComponentCount != 1) \\n            return -1; \\n        return notUsed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int notUsed = 0;\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        if (parent[node] == node) return node;\\n        else return findParent(parent, parent[node]);\\n    }\\n    bool merge(vector<int>&parent, vector<int>&rank, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n\\n        if (parent1 == parent2) \\n            return false;\\n            \\n        else\\n        {\\n            if (rank[parent1] == rank[parent2]){\\n                parent[parent1] = parent2; \\n                rank[parent2]++; \\n            }\\n            else if (rank[parent1] < rank[parent2])\\n                parent[parent1] = parent2; \\n            else\\n                parent[parent2] = parent1;\\n            return true;\\n        }\\n    }\\n\\n    void solve(vector<vector<int>>&edges, vector<int>&parent, vector<int>&rank, int& componentCount, int currType){\\n        \\n        for (vector<int>&edge : edges){\\n\\n            if (edge[0] != currType) \\n                continue;      \\n              \\n            bool merged = merge(parent, rank, edge[1], edge[2]);\\n            if (!merged) notUsed++;\\n            else componentCount--;\\n        }\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) \\n    {\\n\\n        int componentCount = n;\\n\\n        vector<int>parent(n + 1);\\n        vector<int>rank(n + 1, 0);\\n\\n        for (int i = 1; i <= n; i++) \\n            parent[i] = i;\\n\\n        solve(edges, parent, rank, componentCount, 3);\\n        \\n        vector<int>aliceParent = parent, aliceRank = rank;\\n        int aliceComponentCount = componentCount;\\n        solve(edges, aliceParent, aliceRank, aliceComponentCount, 1);\\n        if (aliceComponentCount != 1) \\n            return -1;  \\n        vector<int>bobParent = parent, bobRank = rank; \\n        int bobComponentCount = componentCount;\\n        solve(edges, bobParent, bobRank, bobComponentCount, 2);\\n        if (bobComponentCount != 1) \\n            return -1; \\n        return notUsed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468660,
                "title": "python-union-find-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nWe can use union-find to check if two node are connected or not.\\nWe can build the graph with type 3 edges first, which can save the number of other 2 types of edges used.\\nAnd then we can use type 1 and 2 edges to connect the node which Alice or Bob can not reach.\\nFinally, check Alice and Bob can reach all of the nodes, if not return -1, \\nif so, return number of edge we save. \\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\n\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = list(range(size))\\n\\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n\\n    def union(self, p, q):\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        self.parent[pq] = pp\\n\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        if len(edges) < n-1: return -1\\n        dsu1 = DSU(n+1)\\n        dsu2 = DSU(n+1)\\n        ans = 0\\n        for t, n1, n2 in edges:\\n            if t == 3:\\n                if dsu1.find(n1) != dsu1.find(n2):\\n                    dsu1.union(n1, n2)\\n                    dsu2.union(n1, n2)\\n                else: ans += 1\\n\\n        for t, n1, n2 in edges:\\n            if t == 1:\\n                if dsu1.find(n1) != dsu1.find(n2):\\n                    dsu1.union(n1, n2)\\n                else: ans += 1\\n            elif t == 2:\\n                if dsu2.find(n1) != dsu2.find(n2):\\n                    dsu2.union(n1, n2)\\n                else: ans += 1\\n\\n        g1 = dsu1.find(1)\\n        g2 = dsu2.find(1)\\n        for i in range(2, n+1):\\n            if dsu1.find(i) != g1 or dsu2.find(i) != g2: return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```python\\n\\'\\'\\'\\nWe can use union-find to check if two node are connected or not.\\nWe can build the graph with type 3 edges first, which can save the number of other 2 types of edges used.\\nAnd then we can use type 1 and 2 edges to connect the node which Alice or Bob can not reach.\\nFinally, check Alice and Bob can reach all of the nodes, if not return -1, \\nif so, return number of edge we save. \\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\n\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = list(range(size))\\n\\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n\\n    def union(self, p, q):\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        self.parent[pq] = pp\\n\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        if len(edges) < n-1: return -1\\n        dsu1 = DSU(n+1)\\n        dsu2 = DSU(n+1)\\n        ans = 0\\n        for t, n1, n2 in edges:\\n            if t == 3:\\n                if dsu1.find(n1) != dsu1.find(n2):\\n                    dsu1.union(n1, n2)\\n                    dsu2.union(n1, n2)\\n                else: ans += 1\\n\\n        for t, n1, n2 in edges:\\n            if t == 1:\\n                if dsu1.find(n1) != dsu1.find(n2):\\n                    dsu1.union(n1, n2)\\n                else: ans += 1\\n            elif t == 2:\\n                if dsu2.find(n1) != dsu2.find(n2):\\n                    dsu2.union(n1, n2)\\n                else: ans += 1\\n\\n        g1 = dsu1.find(1)\\n        g2 = dsu2.find(1)\\n        for i in range(2, n+1):\\n            if dsu1.find(i) != g1 or dsu2.find(i) != g2: return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468572,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct DisjointUnionSets\\n    {\\n    int *rank,*parent;\\n    int x;\\n    DisjointUnionSets(int n)\\n    {\\n        rank=new int[n];\\n        parent=new int[n];\\n        x=n;\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    bool Union(int x,int y)\\n    {\\n        int xRoot=find(x),yRoot=find(y);\\n        if(xRoot == yRoot)\\n            return false;\\n        if(rank[xRoot] < rank[yRoot])\\n            parent[xRoot]=yRoot;\\n        else if (rank[xRoot] > rank[yRoot])\\n            parent[yRoot]=xRoot;\\n        else\\n        {\\n            parent[yRoot]=xRoot;\\n            rank[xRoot]++;\\n        }\\n        return true;\\n    }\\n};\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges)\\n     {\\n        int size=edges.size();\\n        vector<pair<int,int>> alice;\\n        vector<pair<int,int>> bob;\\n        vector<pair<int,int>> both;\\n        for(int i=0;i<size;i++)\\n        {\\n            int temp=edges[i][0];\\n            if(temp==1)\\n                alice.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n            else if(temp==2)\\n                bob.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n            else\\n                both.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n        }\\n        DisjointUnionSets a(n),b(n);\\n        int res=0,componentA=n,componentB=n;\\n        for(auto x:both){\\n            bool flag1=a.Union(x.first,x.second);\\n            bool flag2=b.Union(x.first,x.second);\\n            if(flag1)\\n                componentA--;\\n            if(flag2)\\n                componentB--;\\n            if(flag1 && flag2)\\n                res++;\\n        }\\n        for(auto x:alice){\\n            bool flag=a.Union(x.first,x.second);\\n            if(flag)\\n            {\\n                componentA--;\\n                res++;\\n            }\\n        }\\n        for(auto x:bob)\\n        {\\n            bool flag=b.Union(x.first,x.second);\\n            if(flag)\\n            {\\n                componentB--;\\n                res++;\\n            }\\n        }\\n        if(componentA!=1 ||componentB!=1)\\n            return -1;\\n        return size-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct DisjointUnionSets\\n    {\\n    int *rank,*parent;\\n    int x;\\n    DisjointUnionSets(int n)\\n    {\\n        rank=new int[n];\\n        parent=new int[n];\\n        x=n;\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    bool Union(int x,int y)\\n    {\\n        int xRoot=find(x),yRoot=find(y);\\n        if(xRoot == yRoot)\\n            return false;\\n        if(rank[xRoot] < rank[yRoot])\\n            parent[xRoot]=yRoot;\\n        else if (rank[xRoot] > rank[yRoot])\\n            parent[yRoot]=xRoot;\\n        else\\n        {\\n            parent[yRoot]=xRoot;\\n            rank[xRoot]++;\\n        }\\n        return true;\\n    }\\n};\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges)\\n     {\\n        int size=edges.size();\\n        vector<pair<int,int>> alice;\\n        vector<pair<int,int>> bob;\\n        vector<pair<int,int>> both;\\n        for(int i=0;i<size;i++)\\n        {\\n            int temp=edges[i][0];\\n            if(temp==1)\\n                alice.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n            else if(temp==2)\\n                bob.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n            else\\n                both.push_back(make_pair(edges[i][1]-1,edges[i][2]-1));\\n        }\\n        DisjointUnionSets a(n),b(n);\\n        int res=0,componentA=n,componentB=n;\\n        for(auto x:both){\\n            bool flag1=a.Union(x.first,x.second);\\n            bool flag2=b.Union(x.first,x.second);\\n            if(flag1)\\n                componentA--;\\n            if(flag2)\\n                componentB--;\\n            if(flag1 && flag2)\\n                res++;\\n        }\\n        for(auto x:alice){\\n            bool flag=a.Union(x.first,x.second);\\n            if(flag)\\n            {\\n                componentA--;\\n                res++;\\n            }\\n        }\\n        for(auto x:bob)\\n        {\\n            bool flag=b.Union(x.first,x.second);\\n            if(flag)\\n            {\\n                componentB--;\\n                res++;\\n            }\\n        }\\n        if(componentA!=1 ||componentB!=1)\\n            return -1;\\n        return size-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468467,
                "title": "disjoint-set-union-in-c-easy-to-understand-solution",
                "content": "# Intuition\\nTo solve this problem, we need to find the maximum number of edges that can be removed so that the given graph can still be fully traversed by both Alice and Bob. So, instead of removing edges we will try to build a graph by adding only required edges one by one.\\n\\nThe idea is to use a `disjoint-set data structure` to keep track of the connectivity of the nodes in the graph. We can then iterate over the given edges and process them in a specific order to determine which edges can be removed. We will start by processing the type 3 edges, then type 2 edges, and finally type 1 edges. For each edge, we will check if it can be added to the disjoint sets of both Alice and Bob, or to just one of them. If an edge can be added to any of the sets we will increment `requiredEdges` counter. At end, we will check if both Alice\\'s and Bob\\'s DSUs are connected then we can return `totalEdges -requiredEdges` which is equal to the maximum number of edges that can be removed to keep Graph Fully Traversable.\\n\\n# Approach\\nWe will start by defining a Disjoint-Set Union (DSU) data structure to help us with the connectivity of the nodes in the graph. The DSU will have three methods, \\n\\n- **findPar** - For finding parent of node and Path compression\\n\\n- **mergeCost** - Will merge (union) two nodes if their parents are not same and return the cost (0 if parents are same otherwise 1). \\nBasically it is a combined function of \\'Union\\' and \\'areSame\\'.\\n\\n- **isConnected** - Will return true if current disjoint set is connected or false.\\n\\nWe will then sort the given edges using **sortByType** and **initialize two DSUs**, one for Alice and one for Bob. We will iterate over the sorted edges and process each edge based on its type. \\n\\n- If the edge is of type 3:\\nwe will try to merge the nodes in both Alice\\'s and Bob\\'s DSUs, and if successful, we will add the edge to the sets and increment the required edges counter.\\n\\n- If the edge is of type 2:\\nwe will try to merge the nodes in Bob\\'s DSU only, and if successful, we will add the edge to the set and increment the required edges counter. \\n\\n- If the edge is of type 1:\\nwe will try to merge the nodes in Alice\\'s DSU only, and if successful, we will add the edge to the set and increment the required edges counter.\\n\\nAfter processing all the edges, We will check if both Alice\\'s and Bob\\'s DSUs are connected, meaning that starting from any node, they can reach all other nodes.\\n\\n- If they are connected:\\nwe will return the **total number of edges minus the required edges**, which will give us the maximum number of edges that can be removed.\\n\\n- If they are not connected:\\nwe will **return -1**.\\n\\n# Complexity\\n- **Time complexity:** $$O(m * alpha(n))$$, *where m is the number of edges and n is the number of nodes in the graph. Alpha(n) is the inverse Ackermann function and can be considered a constant for all practical purposes.*\\n\\n- **Space complexity:** $$O(n)$$, *where n is the number of nodes in the graph. This is the space required to store the parent and size arrays for the DSUs.*\\n\\n# Code\\n```\\nclass DSU {\\nprivate:\\n    vector<int> par, size;\\npublic:\\n    DSU (int n){\\n        par.resize(n, -1);\\n        size.resize(n, 0);\\n    }\\n\\n    int findPar(int x) {\\n        if(par[x] == -1) return x;\\n        return par[x] = findPar(par[x]);\\n    }\\n\\n    int mergeCost(int a, int b) {\\n        int pa = findPar(a);\\n        int pb = findPar(b);\\n\\n        if(pa == pb) return 0;\\n        if(size[pa] <= size[pb]) {\\n            par[pa] = pb;\\n            size[pb] += size[pa];\\n        } else {\\n            par[pb] = pa;\\n            size[pa] += size[pb];\\n        }\\n        return 1;\\n    }\\n\\n    bool isConnected() {\\n        int roots = 0;\\n        for(int i=0; i<par.size(); i++) {\\n            if(par[i] == -1) {\\n                roots++;\\n            } \\n        }\\n        return (roots == 1);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool sortByType(const vector<int> &a, const vector<int> &b) {\\n        return a[0] > b[0];\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), sortByType);\\n        int totalEdges = edges.size();\\n        int requiredEdges = 0;\\n\\n        DSU alice(n);\\n        DSU bob(n);\\n\\n        for(auto &edge: edges) {\\n            int type = edge[0];\\n            int u = edge[1] - 1;\\n            int v = edge[2] - 1;\\n            \\n            if(type == 3) {\\n                requiredEdges += min(alice.mergeCost(u, v), bob.mergeCost(u, v));\\n            } else if(type == 2) {\\n                requiredEdges += bob.mergeCost(u, v);\\n            } else {\\n                requiredEdges += alice.mergeCost(u, v); \\n            }\\n        }\\n\\n        if(alice.isConnected() && bob.isConnected()) {\\n            return totalEdges - requiredEdges;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Reminder\\n- Please upvote this solution if you find it helpful.\\n- Have a Good day!",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DSU {\\nprivate:\\n    vector<int> par, size;\\npublic:\\n    DSU (int n){\\n        par.resize(n, -1);\\n        size.resize(n, 0);\\n    }\\n\\n    int findPar(int x) {\\n        if(par[x] == -1) return x;\\n        return par[x] = findPar(par[x]);\\n    }\\n\\n    int mergeCost(int a, int b) {\\n        int pa = findPar(a);\\n        int pb = findPar(b);\\n\\n        if(pa == pb) return 0;\\n        if(size[pa] <= size[pb]) {\\n            par[pa] = pb;\\n            size[pb] += size[pa];\\n        } else {\\n            par[pb] = pa;\\n            size[pa] += size[pb];\\n        }\\n        return 1;\\n    }\\n\\n    bool isConnected() {\\n        int roots = 0;\\n        for(int i=0; i<par.size(); i++) {\\n            if(par[i] == -1) {\\n                roots++;\\n            } \\n        }\\n        return (roots == 1);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool sortByType(const vector<int> &a, const vector<int> &b) {\\n        return a[0] > b[0];\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), sortByType);\\n        int totalEdges = edges.size();\\n        int requiredEdges = 0;\\n\\n        DSU alice(n);\\n        DSU bob(n);\\n\\n        for(auto &edge: edges) {\\n            int type = edge[0];\\n            int u = edge[1] - 1;\\n            int v = edge[2] - 1;\\n            \\n            if(type == 3) {\\n                requiredEdges += min(alice.mergeCost(u, v), bob.mergeCost(u, v));\\n            } else if(type == 2) {\\n                requiredEdges += bob.mergeCost(u, v);\\n            } else {\\n                requiredEdges += alice.mergeCost(u, v); \\n            }\\n        }\\n\\n        if(alice.isConnected() && bob.isConnected()) {\\n            return totalEdges - requiredEdges;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468212,
                "title": "java-runtime-14-ms-beats-69-80-memory-96-8-mb-beats-57-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class DSU{\\n        int[] parent;\\n        int[] rank;\\n        int islands;\\n\\n        DSU(int size){\\n            islands=size;\\n            parent = new int[size];\\n            rank = new int[size];\\n            for(int i=0; i<size; i++){\\n                parent[i]=i;\\n                rank[i]=0;\\n            }\\n        }\\n        public int find(int x){\\n            if(parent[x] != x) parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n        public void union(int x, int y){\\n            int sx = find(x), sy=find(y);\\n            if(sx == sy){\\n                return;\\n            }\\n            if(rank[sx]>rank[sy]){\\n                parent[sy]=sx;\\n            } else if(rank[sx]<rank[sy]){\\n                parent[sx]=sy;\\n            } else {\\n                parent[sy]=sx;\\n                rank[sx]++;\\n            }\\n            islands--;\\n        }\\n        public boolean isSameSet(int x, int y){\\n            int sx = find(x), sy=find(y);\\n            if(sx == sy){\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        DSU t1 = new DSU(n);\\n        DSU t2 = new DSU(n);\\n        int extra=0;\\n        for(int[] e : edges){\\n            int et = e[0], x=e[1]-1, y=e[2]-1;\\n            if(et==3){\\n                if(t1.isSameSet(x,y) && t2.isSameSet(x,y)){\\n                    extra++;\\n                    continue;\\n                }\\n                t1.union(x,y);\\n                t2.union(x,y);\\n            }\\n        }\\n        for(int[] e : edges){\\n            int et = e[0], x=e[1]-1, y=e[2]-1;\\n            if(et==1){\\n                if(t1.isSameSet(x,y)){\\n                    extra++;\\n                    continue;\\n                }\\n                t1.union(x,y);\\n            } else if(et==2){\\n                if(t2.isSameSet(x,y)){\\n                    extra++;\\n                    continue;\\n                }\\n                t2.union(x,y);\\n            }\\n        }\\n        if(t1.islands != 1 || t2.islands != 1){\\n            return -1;\\n        }\\n        return extra;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class DSU{\\n        int[] parent;\\n        int[] rank;\\n        int islands;\\n\\n        DSU(int size){\\n            islands=size;\\n            parent = new int[size];\\n            rank = new int[size];\\n            for(int i=0; i<size; i++){\\n                parent[i]=i;\\n                rank[i]=0;\\n            }\\n        }\\n        public int find(int x){\\n            if(parent[x] != x) parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n        public void union(int x, int y){\\n            int sx = find(x), sy=find(y);\\n            if(sx == sy){\\n                return;\\n            }\\n            if(rank[sx]>rank[sy]){\\n                parent[sy]=sx;\\n            } else if(rank[sx]<rank[sy]){\\n                parent[sx]=sy;\\n            } else {\\n                parent[sy]=sx;\\n                rank[sx]++;\\n            }\\n            islands--;\\n        }\\n        public boolean isSameSet(int x, int y){\\n            int sx = find(x), sy=find(y);\\n            if(sx == sy){\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        DSU t1 = new DSU(n);\\n        DSU t2 = new DSU(n);\\n        int extra=0;\\n        for(int[] e : edges){\\n            int et = e[0], x=e[1]-1, y=e[2]-1;\\n            if(et==3){\\n                if(t1.isSameSet(x,y) && t2.isSameSet(x,y)){\\n                    extra++;\\n                    continue;\\n                }\\n                t1.union(x,y);\\n                t2.union(x,y);\\n            }\\n        }\\n        for(int[] e : edges){\\n            int et = e[0], x=e[1]-1, y=e[2]-1;\\n            if(et==1){\\n                if(t1.isSameSet(x,y)){\\n                    extra++;\\n                    continue;\\n                }\\n                t1.union(x,y);\\n            } else if(et==2){\\n                if(t2.isSameSet(x,y)){\\n                    extra++;\\n                    continue;\\n                }\\n                t2.union(x,y);\\n            }\\n        }\\n        if(t1.islands != 1 || t2.islands != 1){\\n            return -1;\\n        }\\n        return extra;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468194,
                "title": "c-solutions",
                "content": "\\n\\n# Code\\n```\\nclass UnionFind {\\n    vector<int> representative;\\n    vector<int> componentSize;\\n    int components;\\n    \\npublic:\\n    UnionFind(int n) {\\n        components = n;\\n        for (int i = 0; i <= n; i++) {\\n            representative.push_back(i);\\n            componentSize.push_back(1);\\n        }\\n    }\\n    \\n    int findRepresentative(int x) {\\n        if (representative[x] == x) {\\n            return x;\\n        }\\n        return representative[x] = findRepresentative(representative[x]);\\n    }\\n    \\n    int performUnion(int x, int y) {       \\n        x = findRepresentative(x); y = findRepresentative(y);\\n        \\n        if (x == y) {\\n            return 0;\\n        }\\n        \\n        if (componentSize[x] > componentSize[y]) {\\n            componentSize[x] += componentSize[y];\\n            representative[y] = x;\\n        } else {\\n            componentSize[y] += componentSize[x];\\n            representative[x] = y;\\n        }\\n        \\n        components--;\\n        return 1;\\n    }\\n\\n    bool isConnected() {\\n        return components == 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind Alice(n), Bob(n);\\n\\n        int edgesRequired = 0;\\n        for (vector<int>& edge : edges) {\\n            if (edge[0] == 3) {\\n                edgesRequired += (Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2]));\\n            }\\n        }\\n\\n        for (vector<int>& edge : edges) {\\n            if (edge[0] == 1) {\\n                edgesRequired += Alice.performUnion(edge[1], edge[2]);\\n            } else if (edge[0] == 2) {\\n                edgesRequired += Bob.performUnion(edge[1], edge[2]);\\n            }\\n        }\\n\\n        if (Alice.isConnected() && Bob.isConnected()) {\\n            return edges.size() - edgesRequired;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind {\\n    vector<int> representative;\\n    vector<int> componentSize;\\n    int components;\\n    \\npublic:\\n    UnionFind(int n) {\\n        components = n;\\n        for (int i = 0; i <= n; i++) {\\n            representative.push_back(i);\\n            componentSize.push_back(1);\\n        }\\n    }\\n    \\n    int findRepresentative(int x) {\\n        if (representative[x] == x) {\\n            return x;\\n        }\\n        return representative[x] = findRepresentative(representative[x]);\\n    }\\n    \\n    int performUnion(int x, int y) {       \\n        x = findRepresentative(x); y = findRepresentative(y);\\n        \\n        if (x == y) {\\n            return 0;\\n        }\\n        \\n        if (componentSize[x] > componentSize[y]) {\\n            componentSize[x] += componentSize[y];\\n            representative[y] = x;\\n        } else {\\n            componentSize[y] += componentSize[x];\\n            representative[x] = y;\\n        }\\n        \\n        components--;\\n        return 1;\\n    }\\n\\n    bool isConnected() {\\n        return components == 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind Alice(n), Bob(n);\\n\\n        int edgesRequired = 0;\\n        for (vector<int>& edge : edges) {\\n            if (edge[0] == 3) {\\n                edgesRequired += (Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2]));\\n            }\\n        }\\n\\n        for (vector<int>& edge : edges) {\\n            if (edge[0] == 1) {\\n                edgesRequired += Alice.performUnion(edge[1], edge[2]);\\n            } else if (edge[0] == 2) {\\n                edgesRequired += Bob.performUnion(edge[1], edge[2]);\\n            }\\n        }\\n\\n        if (Alice.isConnected() && Bob.isConnected()) {\\n            return edges.size() - edgesRequired;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468017,
                "title": "rust-unionfind",
                "content": "```\\nimpl Solution {\\n    pub fn max_num_edges_to_remove(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let mut alice: Vec<_> = (0..=n as usize).collect();\\n        let mut bob: Vec<_> = (0..=n as usize).collect();\\n\\n        fn uf_find(i: usize, uf: &mut [usize]) -> usize {\\n            if uf[i] != i {\\n                uf[i] = uf_find(uf[i], uf);\\n            }\\n            uf[i]\\n        }\\n        fn uf_union(i: usize, j: usize, uf: &mut [usize]) -> bool {\\n            let i = uf_find(i, uf);\\n            let j = uf_find(j, uf);\\n            if i == j {\\n                false\\n            } else {\\n                uf[i] = j;\\n                true                \\n            }\\n        }\\n\\n        let mut ret = 0;\\n        let mut a_count = 1;\\n        let mut b_count = 1;\\n        for edge in &edges {\\n            if edge[0] == 3 {\\n                let a_change = uf_union(edge[1] as usize, edge[2] as usize, &mut alice);\\n                let b_change = uf_union(edge[1] as usize, edge[2] as usize, &mut bob);\\n                match (a_change, b_change) {\\n                    (true, true) => {\\n                        a_count += 1;\\n                        b_count += 1;\\n                    }\\n                    (true, false) => {\\n                        a_count += 1;\\n                    }\\n                    (false, true) => {\\n                        b_count += 1;\\n                    }\\n                    (false, false) => {\\n                        ret += 1;\\n                    }\\n                }\\n            }\\n        }\\n        for edge in edges {\\n            if edge[0] == 1 {\\n                if uf_union(edge[1] as usize, edge[2] as usize, &mut alice) {\\n                    a_count += 1;\\n                } else {\\n                    ret += 1;\\n                }\\n            } else if edge[0] == 2 {\\n                if uf_union(edge[1] as usize, edge[2] as usize, &mut bob) {\\n                    b_count += 1;\\n                } else {\\n                    ret += 1;\\n                }\\n            }\\n        }\\n\\n        if a_count < n || b_count < n {\\n            -1\\n        } else {\\n            ret\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_num_edges_to_remove(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let mut alice: Vec<_> = (0..=n as usize).collect();\\n        let mut bob: Vec<_> = (0..=n as usize).collect();\\n\\n        fn uf_find(i: usize, uf: &mut [usize]) -> usize {\\n            if uf[i] != i {\\n                uf[i] = uf_find(uf[i], uf);\\n            }\\n            uf[i]\\n        }\\n        fn uf_union(i: usize, j: usize, uf: &mut [usize]) -> bool {\\n            let i = uf_find(i, uf);\\n            let j = uf_find(j, uf);\\n            if i == j {\\n                false\\n            } else {\\n                uf[i] = j;\\n                true                \\n            }\\n        }\\n\\n        let mut ret = 0;\\n        let mut a_count = 1;\\n        let mut b_count = 1;\\n        for edge in &edges {\\n            if edge[0] == 3 {\\n                let a_change = uf_union(edge[1] as usize, edge[2] as usize, &mut alice);\\n                let b_change = uf_union(edge[1] as usize, edge[2] as usize, &mut bob);\\n                match (a_change, b_change) {\\n                    (true, true) => {\\n                        a_count += 1;\\n                        b_count += 1;\\n                    }\\n                    (true, false) => {\\n                        a_count += 1;\\n                    }\\n                    (false, true) => {\\n                        b_count += 1;\\n                    }\\n                    (false, false) => {\\n                        ret += 1;\\n                    }\\n                }\\n            }\\n        }\\n        for edge in edges {\\n            if edge[0] == 1 {\\n                if uf_union(edge[1] as usize, edge[2] as usize, &mut alice) {\\n                    a_count += 1;\\n                } else {\\n                    ret += 1;\\n                }\\n            } else if edge[0] == 2 {\\n                if uf_union(edge[1] as usize, edge[2] as usize, &mut bob) {\\n                    b_count += 1;\\n                } else {\\n                    ret += 1;\\n                }\\n            }\\n        }\\n\\n        if a_count < n || b_count < n {\\n            -1\\n        } else {\\n            ret\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2636650,
                "title": "c-easy-simple-comprehensible",
                "content": "Link to the submission stats:\\nhttps://leetcode.com/submissions/detail/811005306/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> repa,repb;\\n    vector<int> sza,szb;\\n    //for alice\\n    int roota(int x){\\n        if(x==repa[x]){return x;}\\n        return repa[x]=roota(repa[x]);\\n    }\\n    //for bob\\n    int rootb(int x){\\n        if(x==repb[x]){return x;}\\n        return repb[x]=rootb(repb[x]);\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& ar) {\\n        //initializing stuff\\n        //repa for alice and repb for bob\\n        //sza for alice and szb for bob\\n        \\n        repa.resize(n);\\n        sza.resize(n);\\n        repb.resize(n);\\n        szb.resize(n);\\n        //init \\n        int xx=ar.size(); // useless edges\\n        int x=0;//useful edges\\n        for(int i=0;i<n;i++){\\n            repa[i]=repb[i]=i;\\n            sza[i]=szb[i]=1;\\n        }\\n        for(auto it:ar){\\n            if(it[0]==3){\\n                int a=it[1],b=it[2];\\n                a--;b--;\\n                a=roota(a);\\n                b=roota(b);\\n                if(a==b){continue;}\\n                //useful edge spotted\\n                x++;\\n                xx--;\\n                if(sza[a]<sza[b]){\\n                    swap(a,b);\\n                }\\n                //updating values\\n                sza[a]+=sza[b];\\n                repa[b]=a;\\n            }\\n        }\\n        \\n        //copying values for bob as well as common edges graph has been generated and will\\n        //be same for all\\n        repb=repa;\\n        szb=sza;\\n        //useful edges till now for both Alcie and Bob\\n        int xa=x;\\n        int xb=x;\\n        for(auto it:ar){\\n            if(it[0]==3){continue;}\\n            if(it[0]==1){\\n                //Alice graph update only\\n                int a=it[1],b=it[2];\\n                a--;b--;\\n                a=roota(a);\\n                b=roota(b);\\n                if(a==b){continue;}\\n                //useful edge for alice\\n                xa++;\\n                xx--;\\n                if(sza[a]<sza[b]){swap(a,b);}\\n                repa[b]=a;\\n                sza[a]+=sza[b];\\n            }\\n            else{\\n                //Bob graph update only\\n                int a=it[1],b=it[2];\\n                a--;b--;\\n                a=rootb(a);\\n                b=rootb(b);\\n                if(a==b){continue;}\\n                //useful edge for bob\\n                xb++;xx--;\\n                if(szb[a]<szb[b]){swap(a,b);}\\n                repb[b]=a;\\n                szb[a]+=szb[b];\\n            }\\n        }\\n        if(xa == n-1 && xb == n-1){\\n            //both graphs good and well connected \\n            true;\\n        }\\n        else{\\n            xx=-1;\\n        }\\n        return xx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> repa,repb;\\n    vector<int> sza,szb;\\n    //for alice\\n    int roota(int x){\\n        if(x==repa[x]){return x;}\\n        return repa[x]=roota(repa[x]);\\n    }\\n    //for bob\\n    int rootb(int x){\\n        if(x==repb[x]){return x;}\\n        return repb[x]=rootb(repb[x]);\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& ar) {\\n        //initializing stuff\\n        //repa for alice and repb for bob\\n        //sza for alice and szb for bob\\n        \\n        repa.resize(n);\\n        sza.resize(n);\\n        repb.resize(n);\\n        szb.resize(n);\\n        //init \\n        int xx=ar.size(); // useless edges\\n        int x=0;//useful edges\\n        for(int i=0;i<n;i++){\\n            repa[i]=repb[i]=i;\\n            sza[i]=szb[i]=1;\\n        }\\n        for(auto it:ar){\\n            if(it[0]==3){\\n                int a=it[1],b=it[2];\\n                a--;b--;\\n                a=roota(a);\\n                b=roota(b);\\n                if(a==b){continue;}\\n                //useful edge spotted\\n                x++;\\n                xx--;\\n                if(sza[a]<sza[b]){\\n                    swap(a,b);\\n                }\\n                //updating values\\n                sza[a]+=sza[b];\\n                repa[b]=a;\\n            }\\n        }\\n        \\n        //copying values for bob as well as common edges graph has been generated and will\\n        //be same for all\\n        repb=repa;\\n        szb=sza;\\n        //useful edges till now for both Alcie and Bob\\n        int xa=x;\\n        int xb=x;\\n        for(auto it:ar){\\n            if(it[0]==3){continue;}\\n            if(it[0]==1){\\n                //Alice graph update only\\n                int a=it[1],b=it[2];\\n                a--;b--;\\n                a=roota(a);\\n                b=roota(b);\\n                if(a==b){continue;}\\n                //useful edge for alice\\n                xa++;\\n                xx--;\\n                if(sza[a]<sza[b]){swap(a,b);}\\n                repa[b]=a;\\n                sza[a]+=sza[b];\\n            }\\n            else{\\n                //Bob graph update only\\n                int a=it[1],b=it[2];\\n                a--;b--;\\n                a=rootb(a);\\n                b=rootb(b);\\n                if(a==b){continue;}\\n                //useful edge for bob\\n                xb++;xx--;\\n                if(szb[a]<szb[b]){swap(a,b);}\\n                repb[b]=a;\\n                szb[a]+=szb[b];\\n            }\\n        }\\n        if(xa == n-1 && xb == n-1){\\n            //both graphs good and well connected \\n            true;\\n        }\\n        else{\\n            xx=-1;\\n        }\\n        return xx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514625,
                "title": "easy-to-understand-dsu-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a , vector<int> &b){ // compare function \\n        return a[0] > b[0];\\n    }\\n    \\n    int find(int v, vector<int>&parent){  //DSU data structure\\n        if(parent[v] == v){\\n             \\n            return v;\\n        }\\n         \\n        return parent[v]= find(parent[v],parent);\\n    }\\n    bool Union(int a, int b, vector<int> &rank, vector<int>& parent){\\n       \\n        int x = find(a,parent);\\n      \\n        int y = find(b, parent);\\n        \\n        if(x==y){\\n            return false;\\n        }\\n        else{\\n            if(rank[x] == rank[y]){\\n                rank[x]++;\\n            \\n            }\\n            else if(rank[x] < rank[y]){\\n                swap(x,y);\\n            }\\n            parent[y] = x;\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), comp); // sort the edges array w.r.t array[0]\\n        vector<int> parentA(n+1) ; \\n        vector<int> parentB(n+1);\\n        vector<int> rankA(n+1);\\n        vector<int> rankB(n+1);\\n        for(int i =1;i<n+1;i++){\\n            parentA[i] = i;\\n            parentB[i]= i;\\n            rankA[i] = 1; \\n            rankB[i] = 1;\\n            \\n        }\\n        int mergeA= 1, mergeB= 1; // initially we have single node\\n        int removedEdges = 0;\\n        for(auto e : edges){\\n            if(e[0]==3){  //if edge is of type3\\n                bool x =  Union(e[1],e[2],rankA,parentA);\\n                bool y =  Union(e[1],e[2], rankB,parentB);\\n                if(x) {\\n                    mergeA++; //nodes are merged using Type-3 edges, increment total merged nodes for Alice\\n                }\\n                if(y){\\n                    mergeB++;  //nodes in disjoint set B are merged using Type-3 edges, increment total merged nodes for Bob\\n                }\\n                if(x== false  &&  y == false){\\n                    removedEdges++; // if two nodes are already connected, no need to use extra edges\\n                    \\n                    \\n                }\\n                \\n            }\\n            else if(e[0]==2){  // if edge is of type2\\n                 bool y = Union(e[1],e[2], rankB,parentB);\\n                 if(y) {\\n                    mergeB++;\\n                }\\n                else {\\n                    removedEdges++;\\n                }\\n            }\\n            else{  // if edge is of type1\\n                 bool x =  Union(e[1],e[2],rankA, parentA);\\n                  if(x) {\\n                    mergeA++;\\n                }\\n                else {\\n                    removedEdges++;\\n                }\\n                \\n            }\\n            \\n        }\\n        if(mergeA==n && mergeB == n){ // if  mergeA== n  Alice can traverse all nodes inside the graph\\n            return removedEdges;\\n        }\\n        else \\n            return -1;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    static bool comp(vector<int> &a , vector<int> &b){ // compare function \\n        return a[0] > b[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2372613,
                "title": "easiest-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n        int find_parent(int node,vector<int>& parent){\\n        if(node == parent[node])\\n            return node;\\n        \\n        return parent[node] = find_parent(parent[node],parent);\\n    }\\n    \\n    void union_find(int u,int v,vector<int>& parent,vector<int>& rank){\\n        u = find_parent(u,parent);\\n        v = find_parent(v,parent);\\n        \\n        if(rank[u]>rank[v]){\\n            parent[v] = u;\\n        }else if(rank[v]>rank[u]){\\n            parent[u] = v;\\n        }else{\\n            parent[v] = u;\\n            rank[u]+=1;\\n        }\\n    }\\n    static bool comparator(vector<int>& a,vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n        int countA = 0;\\n        int countB = 0;\\n        int ans = 0;\\n        sort(edges.begin(),edges.end(),comparator);\\n        vector<int> parentA(n+1);\\n        for(int i=1;i<=n;i++)\\n            parentA[i] = i;\\n        vector<int> rankA(n+1,0);\\n        \\n        vector<int> parentB(n+1);\\n        for(int i=1;i<=n;i++)\\n            parentB[i] = i;\\n        vector<int> rankB(n+1,0);\\n        \\n        for(auto edge : edges){\\n            int u = edge[1];\\n            int v = edge[2];\\n            int type = edge[0];\\n            if(type == 1){\\n                if(find_parent(u,parentA) != find_parent(v,parentA)){\\n                    union_find(u,v,parentA,rankA);\\n                    countA++;\\n                    ans++;\\n                }\\n            }else if(type == 2){\\n                if(find_parent(u,parentB) != find_parent(v,parentB)){\\n                    union_find(u,v,parentB,rankB);\\n                    countB++;\\n                    ans++;\\n                }\\n            }else{\\n                int temp = ans;\\n                if(find_parent(u,parentA) != find_parent(v,parentA)){\\n                    union_find(u,v,parentA,rankA);\\n                    countA++;\\n                    ans++;\\n                }\\n                \\n                if(find_parent(u,parentB) != find_parent(v,parentB)){\\n                    union_find(u,v,parentB,rankB);\\n                    countB++;\\n                    if(temp == ans)\\n                        ans++;\\n                }\\n            }\\n        }\\n        \\n        if(countA < n-1 || countB < n-1)\\n            return -1;\\n        \\n        return edges.size()-ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n        int find_parent(int node,vector<int>& parent){\\n        if(node == parent[node])\\n            return node;\\n        \\n        return parent[node] = find_parent(parent[node],parent);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2253542,
                "title": "c-simple-union-find-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/\\n    \\n    TC: O(Elogn + E)\\n    \\n    Idea is to use UnionFind to find the min no. of edges needed to make the graph connected.\\n    Now at first we build the graph with the common edges.\\n    Next for both Alice and Bob we, do UnionFind on top of the graph built with the common edges.\\n    This will result in the addition of edges not covered by the common edges that can enable Bob and Alice\\n    to traverse the entire graph.\\n*/\\nclass Solution {\\nprivate:\\n    class UnionFind {\\n    public:\\n        vector<int> root, size;\\n        // No. of edges processed\\n        int edges_processed = 0;\\n        // No. of nodes in the graph\\n        int n = 0;\\n        \\n        UnionFind(int n_) {\\n            n = n_;\\n            size.resize(n, 1), root.resize(n);\\n            for(int i = 0; i < n; i++)\\n                root[i] = i;\\n        }\\n        \\n        // Copy the state from input object\\n        void Copy(UnionFind* ob) {\\n            // Copy the root and size values\\n            for(int i = 0; i < n; i++)\\n                root[i] = ob->root[i];\\n            for(int i = 0; i < n; i++)\\n                size[i] = ob->size[i];\\n            // Copy the no. of edges processed\\n            edges_processed = ob->edges_processed;\\n        }\\n        \\n        int getRoot(int a) {\\n            while(a != root[a]) {\\n                root[a] = root[root[a]];\\n                a = root[a];\\n            }\\n            return a;\\n        }\\n        \\n        bool Union(int a, int b) {\\n            int root_a = getRoot(a);\\n            int root_b = getRoot(b);\\n            \\n            if(root_a != root_b) {\\n                if(size[root_a] > size[root_b]) {\\n                    size[root_a] += size[root_b];\\n                    root[root_b] = root_a;\\n                }\\n                else {\\n                    size[root_b] += size[root_a];\\n                    root[root_a] = root_b;\\n                }\\n                ++edges_processed;\\n                return true;\\n            }\\n            return false;\\n        }\\n    };\\n    \\npublic:\\n    UnionFind connectEdges(int edge_type, int n, int& edges_used,\\n                     vector<vector<int>>& edges, UnionFind* ob = nullptr) {\\n        UnionFind uf(n);\\n        // Copy the state of the Unionfind object if not null\\n        if(ob)\\n            uf.Copy(ob);\\n        \\n        for(int i = 0; i < edges.size() && uf.edges_processed < n-1; i++) {\\n            int type = edges[i][0], src = edges[i][1] - 1, dst = edges[i][2] - 1;\\n            // Only process the edge meant for the current type\\n            if(type == edge_type && uf.Union(src, dst))\\n                ++edges_used;\\n        }\\n        return uf;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int edges_used = 0;\\n        \\n        // Add the common edges to the graph\\n        auto common_graph = connectEdges(3, n, edges_used, edges);\\n        // Only add the edges need by Alice and Bob to traverse the rest of the graph\\n        // We pass the unionFind state of common graph, so that edges needed by Bob and \\n        // Alice don\\'t include the common edges alreayd available\\n        auto A_accessible_graph = connectEdges(1, n, edges_used, edges, &common_graph);\\n        auto B_accessible_graph = connectEdges(2, n, edges_used, edges, &common_graph);\\n        \\n        return (A_accessible_graph.edges_processed == n-1 && B_accessible_graph.edges_processed == n-1) ?\\n            edges.size() - edges_used : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/\\n    \\n    TC: O(Elogn + E)\\n    \\n    Idea is to use UnionFind to find the min no. of edges needed to make the graph connected.\\n    Now at first we build the graph with the common edges.\\n    Next for both Alice and Bob we, do UnionFind on top of the graph built with the common edges.\\n    This will result in the addition of edges not covered by the common edges that can enable Bob and Alice\\n    to traverse the entire graph.\\n*/\\nclass Solution {\\nprivate:\\n    class UnionFind {\\n    public:\\n        vector<int> root, size;\\n        // No. of edges processed\\n        int edges_processed = 0;\\n        // No. of nodes in the graph\\n        int n = 0;\\n        \\n        UnionFind(int n_) {\\n            n = n_;\\n            size.resize(n, 1), root.resize(n);\\n            for(int i = 0; i < n; i++)\\n                root[i] = i;\\n        }\\n        \\n        // Copy the state from input object\\n        void Copy(UnionFind* ob) {\\n            // Copy the root and size values\\n            for(int i = 0; i < n; i++)\\n                root[i] = ob->root[i];\\n            for(int i = 0; i < n; i++)\\n                size[i] = ob->size[i];\\n            // Copy the no. of edges processed\\n            edges_processed = ob->edges_processed;\\n        }\\n        \\n        int getRoot(int a) {\\n            while(a != root[a]) {\\n                root[a] = root[root[a]];\\n                a = root[a];\\n            }\\n            return a;\\n        }\\n        \\n        bool Union(int a, int b) {\\n            int root_a = getRoot(a);\\n            int root_b = getRoot(b);\\n            \\n            if(root_a != root_b) {\\n                if(size[root_a] > size[root_b]) {\\n                    size[root_a] += size[root_b];\\n                    root[root_b] = root_a;\\n                }\\n                else {\\n                    size[root_b] += size[root_a];\\n                    root[root_a] = root_b;\\n                }\\n                ++edges_processed;\\n                return true;\\n            }\\n            return false;\\n        }\\n    };\\n    \\npublic:\\n    UnionFind connectEdges(int edge_type, int n, int& edges_used,\\n                     vector<vector<int>>& edges, UnionFind* ob = nullptr) {\\n        UnionFind uf(n);\\n        // Copy the state of the Unionfind object if not null\\n        if(ob)\\n            uf.Copy(ob);\\n        \\n        for(int i = 0; i < edges.size() && uf.edges_processed < n-1; i++) {\\n            int type = edges[i][0], src = edges[i][1] - 1, dst = edges[i][2] - 1;\\n            // Only process the edge meant for the current type\\n            if(type == edge_type && uf.Union(src, dst))\\n                ++edges_used;\\n        }\\n        return uf;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int edges_used = 0;\\n        \\n        // Add the common edges to the graph\\n        auto common_graph = connectEdges(3, n, edges_used, edges);\\n        // Only add the edges need by Alice and Bob to traverse the rest of the graph\\n        // We pass the unionFind state of common graph, so that edges needed by Bob and \\n        // Alice don\\'t include the common edges alreayd available\\n        auto A_accessible_graph = connectEdges(1, n, edges_used, edges, &common_graph);\\n        auto B_accessible_graph = connectEdges(2, n, edges_used, edges, &common_graph);\\n        \\n        return (A_accessible_graph.edges_processed == n-1 && B_accessible_graph.edges_processed == n-1) ?\\n            edges.size() - edges_used : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242003,
                "title": "c-disjoint-set-easy-and-clean-code",
                "content": "class Solution {\\nprivate:\\n\\n    int findParent(vector<int> &parent, int node){\\n        if(parent[node] == -1){\\n            return node;\\n        }\\n        \\n        // Path compression\\n        parent[node] = findParent(parent, parent[node]);\\n        return parent[node];\\n    }\\n    \\n    void merge(int u, int v, vector<int> &parent, vector<int> &rank){\\n        u = findParent(parent, u);\\n        v = findParent(parent, v);\\n        \\n        if(rank[u] < rank[v]){\\n            parent[u] = v;\\n        }\\n        else if(rank[u] > rank[v]){\\n            parent[v] = u;\\n        }\\n        else{\\n            parent[v] = u;\\n            rank[u]++;\\n        }\\n    }\\n    \\npublic:\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> parent1(n+1, -1);\\n        vector<int> rank1(n+1, 0);\\n        \\n        int totalType3 = 0, usedType3 = 0;\\n        \\n        // First, only travel those edges which can be used by both\\n        for(auto i : edges){\\n            if(i[0] != 3) continue;\\n            \\n            else{\\n                totalType3++;\\n                \\n                int u = findParent(parent1, i[1]);\\n                int v = findParent(parent1, i[2]);\\n                \\n                if(u != v){\\n                    usedType3++;\\n                    merge(u, v, parent1, rank1);\\n                }\\n            }\\n        }\\n        \\n        int totalType1 = 0, usedType1 = 0;\\n        int totalType2 = 0, usedType2 = 0;\\n        \\n        vector<int> parent2, rank2;\\n        \\n        // Till here, parent and rank arrays will be same for both types\\n        parent2 = parent1;\\n        rank2 = rank1;\\n        \\n        for(auto i : edges){\\n            \\n            if(i[0] == 1){\\n                totalType1++;\\n                \\n                int u = findParent(parent1, i[1]);\\n                int v = findParent(parent1, i[2]);\\n                \\n                if(u != v){\\n                    usedType1++;\\n                    merge(u, v, parent1, rank1);\\n                }\\n            }\\n            \\n            else if(i[0] == 2){\\n                totalType2++;\\n                \\n                int u = findParent(parent2, i[1]);\\n                int v = findParent(parent2, i[2]);\\n                \\n                if(u != v){\\n                    usedType2++;\\n                    merge(u, v, parent2, rank2);\\n                }\\n            }\\n            \\n        }\\n        \\n        if(usedType3 + usedType1 != n-1 || usedType3 + usedType2 != n-1){\\n            return -1;\\n        }\\n        \\n        int totalEdges = totalType1 + totalType2 + totalType3;\\n        int totalUsed = usedType1 + usedType2 + usedType3;\\n        \\n        return totalEdges - totalUsed;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n\\n    int findParent(vector<int> &parent, int node){\\n        if(parent[node] == -1){\\n            return node;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2103574,
                "title": "java-simple-unionfind-faster-than-95-easy-solutions-with-comments",
                "content": "```\\nclass Solution {\\n  public int maxNumEdgesToRemove(int n, int[][] edges) {\\n    if (edges.length < n - 1) return -1; // if edges are less than n - 1, then it\\'s not a valid tree, not all nodes are accessible\\n\\n    int[] parentAlice = new int[n + 1];\\n    for (int i = 0; i < parentAlice.length; i++) {\\n      parentAlice[i] = i;\\n    }\\n\\n    // First process the type 3 nodes, this will help us to reduce number of edges required\\n    int numType3Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 3) {\\n        if (union(parentAlice, edge[1], edge[2])) {\\n          numType3Edges++;\\n        }\\n      }\\n    }\\n\\n    int[] parentBob = parentAlice.clone(); // as type 3 are for both alice and bob, clone it for bob as well\\n\\n    // Process Alice\\n    int numType1Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 1) {\\n        if (union(parentAlice, edge[1], edge[2])) {\\n          numType1Edges++;\\n        }\\n      }\\n    }\\n    if (numType1Edges + numType3Edges + 1 != n) return -1; // if edges are less than n - 1, then type 1 is not a valid tree, not all nodes are accessible\\n\\n    // Process Bob\\n    int numType2Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 2) {\\n        if (union(parentBob, edge[1], edge[2])) {\\n          numType2Edges++;\\n        }\\n      }\\n    }\\n    if (numType2Edges + numType3Edges + 1 != n) return -1; // if edges are less than n - 1, then type 1 is not a valid tree, not all nodes are accessible\\n    // return total edges - (number of type 3 + type 2 + type 1 edges required)\\n    return edges.length - numType1Edges - numType2Edges - numType3Edges;\\n  }\\n\\n  int find(int[] parent, int node) {\\n    if (parent[node] != node) {\\n      parent[node] = find(parent, parent[node]);\\n    }\\n    return parent[node];\\n  }\\n\\n  boolean union(int[] parent, int left, int right) {\\n    int leftParent = find(parent, left);\\n    int rightParent = find(parent, right);\\n    if (leftParent == rightParent) return false;\\n    parent[rightParent] = leftParent;\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n  public int maxNumEdgesToRemove(int n, int[][] edges) {\\n    if (edges.length < n - 1) return -1; // if edges are less than n - 1, then it\\'s not a valid tree, not all nodes are accessible\\n\\n    int[] parentAlice = new int[n + 1];\\n    for (int i = 0; i < parentAlice.length; i++) {\\n      parentAlice[i] = i;\\n    }\\n\\n    // First process the type 3 nodes, this will help us to reduce number of edges required\\n    int numType3Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 3) {\\n        if (union(parentAlice, edge[1], edge[2])) {\\n          numType3Edges++;\\n        }\\n      }\\n    }\\n\\n    int[] parentBob = parentAlice.clone(); // as type 3 are for both alice and bob, clone it for bob as well\\n\\n    // Process Alice\\n    int numType1Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 1) {\\n        if (union(parentAlice, edge[1], edge[2])) {\\n          numType1Edges++;\\n        }\\n      }\\n    }\\n    if (numType1Edges + numType3Edges + 1 != n) return -1; // if edges are less than n - 1, then type 1 is not a valid tree, not all nodes are accessible\\n\\n    // Process Bob\\n    int numType2Edges = 0;\\n    for (int[] edge : edges) {\\n      if (edge[0] == 2) {\\n        if (union(parentBob, edge[1], edge[2])) {\\n          numType2Edges++;\\n        }\\n      }\\n    }\\n    if (numType2Edges + numType3Edges + 1 != n) return -1; // if edges are less than n - 1, then type 1 is not a valid tree, not all nodes are accessible\\n    // return total edges - (number of type 3 + type 2 + type 1 edges required)\\n    return edges.length - numType1Edges - numType2Edges - numType3Edges;\\n  }\\n\\n  int find(int[] parent, int node) {\\n    if (parent[node] != node) {\\n      parent[node] = find(parent, parent[node]);\\n    }\\n    return parent[node];\\n  }\\n\\n  boolean union(int[] parent, int left, int right) {\\n    int leftParent = find(parent, left);\\n    int rightParent = find(parent, right);\\n    if (leftParent == rightParent) return false;\\n    parent[rightParent] = leftParent;\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082342,
                "title": "c-disjoint-set-union-find-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> prnt1, prnt2;\\n    vector<int> rank1, rank2;\\n    \\n    int find(int u, vector<int> &prnt) {\\n        if(prnt[u] == -1)\\n            return u;\\n        return prnt[u] = find(prnt[u], prnt);\\n    }\\n    \\n    void merge(int u, int v, vector<int> &prnt, vector<int> &rank) {\\n        u = find(u, prnt);\\n        v = find(v, prnt);\\n        \\n        if(u == v) return;\\n        \\n        if(rank[u] < rank[v]) \\n            swap(u, v);\\n\\n        rank[u] += rank[v];\\n        prnt[v] = u;\\n    }\\n    \\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        prnt1.resize(n+1, -1);\\n        prnt2.resize(n+1, -1);\\n        \\n        rank1.resize(n+1, 1);\\n        rank2.resize(n+1, 1);\\n        \\n        int tot_t3 = 0, used_t3 = 0;\\n        for(auto it: edges) {\\n            if(it[0] != 3) \\n                continue;\\n            tot_t3 += 1;\\n            if(find(it[1], prnt1) != find(it[2], prnt1)) {\\n                used_t3 += 1;\\n                merge(it[1], it[2], prnt1, rank1);\\n                merge(it[1], it[2], prnt2, rank2);\\n            }\\n        }\\n        \\n        int tot_t1 = 0, used_t1 = 0;\\n        int tot_t2 = 0, used_t2 = 0;\\n        for(auto it: edges) {\\n            if(it[0] == 1) {\\n                tot_t1 += 1;\\n                if(find(it[1], prnt1) != find(it[2], prnt1)) {\\n                    used_t1 += 1;\\n                    merge(it[1], it[2], prnt1, rank1);\\n                }\\n            } else if(it[0] == 2) {\\n                tot_t2 += 1;\\n                if(find(it[1], prnt2) != find(it[2], prnt2)) {\\n                    used_t2 += 1;\\n                    merge(it[1], it[2], prnt2, rank2);\\n                }\\n            }\\n        }\\n        \\n        if(used_t3 + used_t1 != n-1 || used_t3 + used_t2 != n-1)\\n            return -1;\\n        \\n        return (tot_t3 + tot_t2 + tot_t1) - (used_t3 + used_t2 + used_t1);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> prnt1, prnt2;\\n    vector<int> rank1, rank2;\\n    \\n    int find(int u, vector<int> &prnt) {\\n        if(prnt[u] == -1)\\n            return u;\\n        return prnt[u] = find(prnt[u], prnt);\\n    }\\n    \\n    void merge(int u, int v, vector<int> &prnt, vector<int> &rank) {\\n        u = find(u, prnt);\\n        v = find(v, prnt);\\n        \\n        if(u == v) return;\\n        \\n        if(rank[u] < rank[v]) \\n            swap(u, v);\\n\\n        rank[u] += rank[v];\\n        prnt[v] = u;\\n    }\\n    \\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        prnt1.resize(n+1, -1);\\n        prnt2.resize(n+1, -1);\\n        \\n        rank1.resize(n+1, 1);\\n        rank2.resize(n+1, 1);\\n        \\n        int tot_t3 = 0, used_t3 = 0;\\n        for(auto it: edges) {\\n            if(it[0] != 3) \\n                continue;\\n            tot_t3 += 1;\\n            if(find(it[1], prnt1) != find(it[2], prnt1)) {\\n                used_t3 += 1;\\n                merge(it[1], it[2], prnt1, rank1);\\n                merge(it[1], it[2], prnt2, rank2);\\n            }\\n        }\\n        \\n        int tot_t1 = 0, used_t1 = 0;\\n        int tot_t2 = 0, used_t2 = 0;\\n        for(auto it: edges) {\\n            if(it[0] == 1) {\\n                tot_t1 += 1;\\n                if(find(it[1], prnt1) != find(it[2], prnt1)) {\\n                    used_t1 += 1;\\n                    merge(it[1], it[2], prnt1, rank1);\\n                }\\n            } else if(it[0] == 2) {\\n                tot_t2 += 1;\\n                if(find(it[1], prnt2) != find(it[2], prnt2)) {\\n                    used_t2 += 1;\\n                    merge(it[1], it[2], prnt2, rank2);\\n                }\\n            }\\n        }\\n        \\n        if(used_t3 + used_t1 != n-1 || used_t3 + used_t2 != n-1)\\n            return -1;\\n        \\n        return (tot_t3 + tot_t2 + tot_t1) - (used_t3 + used_t2 + used_t1);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939035,
                "title": "java-union-find-7-9ms-100-faster",
                "content": "A few keys to save time:\\n1. When we found we already have `n - 1` edges, break the loop.\\n2. If after handling type 3, we already found `n - 1` edges, then no need to handle type 1 & 2;\\n3. If found Alice cannot traverse all nodes, `return -1`;\\n4. If found Bob cannot traverse all nodes, `return -1`;\\n\\nVariables:\\n1. `int[] parent` : for union and find;\\n2. `int[] counts`: for counting the number of edges of different types.\\n\\nNote that:\\n- `number of type-1 edges = counts[0] - counts[2]`\\n- `number of type-2 edges = counts[1] - counts[2]`\\nWhat we return:\\n- `num_edges - number_of_type_1 - number_of_type_2 - number_of_type_3`\\n- Which is equivalent to `num_edges + counts[2] - counts[0] - counts[1]`;\\n```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int[] parent = new int[n];\\n        int[] counts = new int[3];\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        handleType(edges, counts, parent, 3, n);\\n        if (counts[2] == n - 1) return edges.length - counts[2];\\n        counts[0] = counts[2];\\n        counts[1] = counts[2];\\n        int[] copy = parent.clone();\\n        \\n        // handle type 1\\n        handleType(edges, counts, parent, 1, n);\\n        if (counts[0] < n - 1) return -1;\\n        \\n        // handle type 2\\n        handleType(edges, counts, copy, 2, n);\\n        if (counts[1] < n - 1) return -1;\\n        \\n        // return edges.length - counts[2] - (counts[0] - counts[2]) - (counts[1] - counts[2]);\\n        return edges.length + counts[2] - counts[0] - counts[1];\\n    }\\n    \\n    private void handleType(int[][] edges, int[] counts, int[] parent, int type, int n) {\\n        for (int[] edge: edges) {\\n            if (type == edge[0]) {\\n                int a = edge[1] - 1;\\n                int b = edge[2] - 1;\\n                int parentA = find(a, parent);\\n                int parentB = find(b, parent);\\n                if (parentA == parentB) continue;\\n                parent[parentA] = parentB;\\n                counts[type - 1]++;\\n                if (counts[type - 1] == n - 1) return;\\n            } \\n        }\\n    }\\n    \\n    private int find(int cur, int[] parent) {\\n        if (parent[cur] == cur) return cur;\\n        return parent[cur] = find(parent[cur], parent);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int[] parent = new int[n];\\n        int[] counts = new int[3];\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        handleType(edges, counts, parent, 3, n);\\n        if (counts[2] == n - 1) return edges.length - counts[2];\\n        counts[0] = counts[2];\\n        counts[1] = counts[2];\\n        int[] copy = parent.clone();\\n        \\n        // handle type 1\\n        handleType(edges, counts, parent, 1, n);\\n        if (counts[0] < n - 1) return -1;\\n        \\n        // handle type 2\\n        handleType(edges, counts, copy, 2, n);\\n        if (counts[1] < n - 1) return -1;\\n        \\n        // return edges.length - counts[2] - (counts[0] - counts[2]) - (counts[1] - counts[2]);\\n        return edges.length + counts[2] - counts[0] - counts[1];\\n    }\\n    \\n    private void handleType(int[][] edges, int[] counts, int[] parent, int type, int n) {\\n        for (int[] edge: edges) {\\n            if (type == edge[0]) {\\n                int a = edge[1] - 1;\\n                int b = edge[2] - 1;\\n                int parentA = find(a, parent);\\n                int parentB = find(b, parent);\\n                if (parentA == parentB) continue;\\n                parent[parentA] = parentB;\\n                counts[type - 1]++;\\n                if (counts[type - 1] == n - 1) return;\\n            } \\n        }\\n    }\\n    \\n    private int find(int cur, int[] parent) {\\n        if (parent[cur] == cur) return cur;\\n        return parent[cur] = find(parent[cur], parent);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858385,
                "title": "c-dsu-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int>& parent){\\n        if(x==parent[x])\\n            return x;\\n        return parent[x]=find(parent[x],parent);\\n    }\\npublic:\\n    void union_dsu(int x,int y,vector<int>& parent,vector<int>& rank){\\n        int lx=find(x,parent);\\n        int ly=find(y,parent);\\n        if(rank[lx]<rank[ly]){\\n            parent[ly]=lx;\\n        }else if(rank[ly]<rank[lx]){\\n            parent[lx]=ly;\\n        }else{\\n            parent[lx]=ly;\\n            rank[ly]++;\\n        }\\n    }\\npublic:\\n  static  bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n{\\n    return v1[0] > v2[0];\\n}\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int m=edges.size(),noOfRemovedEdges=0,nCC_alice=n,nCC_bob=n;\\n        vector<int> parent_alice(n+1);\\n        vector<int> parent_bob(n+1);\\n        vector<int> rank_alice(n+1);\\n        vector<int> rank_bob(n+1);\\n        sort(edges.begin(),edges.end(),sortcol);\\n        for(int i=1;i<=n;i++){\\n            parent_alice[i]=i;\\n            parent_bob[i]=i;\\n            rank_alice[i]=1;\\n            rank_bob[i]=1;\\n        }\\n        for(int i=0;i<m;i++){\\n            int type=edges[i][0];\\n            int x=edges[i][1];\\n            int y=edges[i][2];\\n            int lx_alice=find(x,parent_alice);\\n            int ly_alice=find(y,parent_alice);\\n            int lx_bob=find(x,parent_bob);\\n            int ly_bob=find(y,parent_bob);\\n           if(type==3){\\n               if(lx_alice==ly_alice && lx_bob==ly_bob){\\n                   noOfRemovedEdges++;\\n                   continue;\\n               }\\n                if(lx_alice!=ly_alice){\\n                    union_dsu(x,y,parent_alice,rank_alice);\\n                    nCC_alice--;\\n                }\\n               if(lx_bob!=ly_bob){\\n                    union_dsu(x,y,parent_bob,rank_bob);\\n                   nCC_bob--;\\n                }\\n               \\n            }\\n            else if(type==2){\\n                if(lx_bob!=ly_bob){\\n                    union_dsu(x,y,parent_bob,rank_bob);\\n                    nCC_bob--;\\n                }\\n                else{\\n                    noOfRemovedEdges++;\\n                }\\n            }\\n            else if(type==1){\\n                if(lx_alice!=ly_alice){\\n                    union_dsu(x,y,parent_alice,rank_alice);\\n                    nCC_alice--;\\n                }else{\\n                    noOfRemovedEdges++;\\n                }\\n            }\\n        }\\n        if(nCC_alice!=1 || nCC_bob!=1)\\n            return -1;\\n        else\\n            return noOfRemovedEdges;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int>& parent){\\n        if(x==parent[x])\\n            return x;\\n        return parent[x]=find(parent[x],parent);\\n    }\\npublic:\\n    void union_dsu(int x,int y,vector<int>& parent,vector<int>& rank){\\n        int lx=find(x,parent);\\n        int ly=find(y,parent);\\n        if(rank[lx]<rank[ly]){\\n            parent[ly]=lx;\\n        }else if(rank[ly]<rank[lx]){\\n            parent[lx]=ly;\\n        }else{\\n            parent[lx]=ly;\\n            rank[ly]++;\\n        }\\n    }\\npublic:\\n  static  bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n{\\n    return v1[0] > v2[0];\\n}\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int m=edges.size(),noOfRemovedEdges=0,nCC_alice=n,nCC_bob=n;\\n        vector<int> parent_alice(n+1);\\n        vector<int> parent_bob(n+1);\\n        vector<int> rank_alice(n+1);\\n        vector<int> rank_bob(n+1);\\n        sort(edges.begin(),edges.end(),sortcol);\\n        for(int i=1;i<=n;i++){\\n            parent_alice[i]=i;\\n            parent_bob[i]=i;\\n            rank_alice[i]=1;\\n            rank_bob[i]=1;\\n        }\\n        for(int i=0;i<m;i++){\\n            int type=edges[i][0];\\n            int x=edges[i][1];\\n            int y=edges[i][2];\\n            int lx_alice=find(x,parent_alice);\\n            int ly_alice=find(y,parent_alice);\\n            int lx_bob=find(x,parent_bob);\\n            int ly_bob=find(y,parent_bob);\\n           if(type==3){\\n               if(lx_alice==ly_alice && lx_bob==ly_bob){\\n                   noOfRemovedEdges++;\\n                   continue;\\n               }\\n                if(lx_alice!=ly_alice){\\n                    union_dsu(x,y,parent_alice,rank_alice);\\n                    nCC_alice--;\\n                }\\n               if(lx_bob!=ly_bob){\\n                    union_dsu(x,y,parent_bob,rank_bob);\\n                   nCC_bob--;\\n                }\\n               \\n            }\\n            else if(type==2){\\n                if(lx_bob!=ly_bob){\\n                    union_dsu(x,y,parent_bob,rank_bob);\\n                    nCC_bob--;\\n                }\\n                else{\\n                    noOfRemovedEdges++;\\n                }\\n            }\\n            else if(type==1){\\n                if(lx_alice!=ly_alice){\\n                    union_dsu(x,y,parent_alice,rank_alice);\\n                    nCC_alice--;\\n                }else{\\n                    noOfRemovedEdges++;\\n                }\\n            }\\n        }\\n        if(nCC_alice!=1 || nCC_bob!=1)\\n            return -1;\\n        else\\n            return noOfRemovedEdges;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842005,
                "title": "c-union-find-two-pass-for-explanation",
                "content": "**Intuition**\\n\\nIf two point has connected, this line can be deleted, \\notherwise, connect two point.\\n\\n1. First round we need to check type3 because if we wanna delete type3 line, both of Alice and Bob need has connected in this line.\\n2. Second round we need to check type1 or type2 for one person.\\n3. finally, check if each count in unionFind is equal to 1 for fully traversed.\\n4. if both of Alice and Bob can fully traversed, return res.\\n\\n**C++**\\n```\\nclass Solution {\\n    class UnionFind {\\n        vector<int> root;\\n        int count;\\n    public:\\n        UnionFind(int n) : count(n-1){\\n            root = vector<int>(n);\\n            for (int i = 0; i < n; ++i) root[i] = i;\\n        }\\n        int find(int x) {\\n            while (x != root[x]) {\\n                root[x] = root[root[x]];\\n                x = root[x];\\n            }\\n            return x;\\n        }\\n        bool isConnect(int x, int y) {\\n            return find(x) == find(y);\\n        }\\n        void group(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY) return;\\n            root[rootX] = rootY;\\n            --count;\\n        }\\n        int getCount(void) {return count;}\\n    };\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind Alice(n + 1), Bob(n + 1);\\n        int res = 0;\\n\\t\\t\\n        for (auto &edge : edges) {\\n            if (edge[0] != 3) continue;\\n            int type = edge[0], x = edge[1], y = edge[2];\\n            if (Alice.isConnect(x, y) && Bob.isConnect(x, y)) {\\n                ++res;\\n            } else {\\n                if (!Alice.isConnect(x, y)) Alice.group(x, y);\\n                if (!Bob.isConnect(x, y)) Bob.group(x, y);\\n            }\\n        }\\n\\t\\t\\n        for (auto &edge : edges) {\\n            if (edge[0] == 3) continue;\\n            int type = edge[0], x = edge[1], y = edge[2];\\n            UnionFind* obj = type == 1 ? &Alice : &Bob;\\n            if (obj->isConnect(x, y)) ++res;\\n            else obj->group(x, y);\\n        }\\n\\t\\t\\n        if (Alice.getCount() != 1 || Bob.getCount() != 1) return -1;\\n\\t\\t\\n        return res;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n\\n* Time: O(m), where m is the number of edges. We go through all edges 2 times. \\n The complexity of the find operation is O(\\uD835\\uDEFC(n)) as we use path compression. \\uD835\\uDEFC(n) can be considered a constant for all practical purposes.\\n* Memory: O(n) for a disjoined set.",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        vector<int> root;\\n        int count;\\n    public:\\n        UnionFind(int n) : count(n-1){\\n            root = vector<int>(n);\\n            for (int i = 0; i < n; ++i) root[i] = i;\\n        }\\n        int find(int x) {\\n            while (x != root[x]) {\\n                root[x] = root[root[x]];\\n                x = root[x];\\n            }\\n            return x;\\n        }\\n        bool isConnect(int x, int y) {\\n            return find(x) == find(y);\\n        }\\n        void group(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY) return;\\n            root[rootX] = rootY;\\n            --count;\\n        }\\n        int getCount(void) {return count;}\\n    };\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind Alice(n + 1), Bob(n + 1);\\n        int res = 0;\\n\\t\\t\\n        for (auto &edge : edges) {\\n            if (edge[0] != 3) continue;\\n            int type = edge[0], x = edge[1], y = edge[2];\\n            if (Alice.isConnect(x, y) && Bob.isConnect(x, y)) {\\n                ++res;\\n            } else {\\n                if (!Alice.isConnect(x, y)) Alice.group(x, y);\\n                if (!Bob.isConnect(x, y)) Bob.group(x, y);\\n            }\\n        }\\n\\t\\t\\n        for (auto &edge : edges) {\\n            if (edge[0] == 3) continue;\\n            int type = edge[0], x = edge[1], y = edge[2];\\n            UnionFind* obj = type == 1 ? &Alice : &Bob;\\n            if (obj->isConnect(x, y)) ++res;\\n            else obj->group(x, y);\\n        }\\n\\t\\t\\n        if (Alice.getCount() != 1 || Bob.getCount() != 1) return -1;\\n\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832397,
                "title": "dsu-java-explained-with-comments",
                "content": "Every line of code is explained using comments (hope I didn\\'t go overboard with comments \\uD83D\\uDE05)\\n```\\nclass Solution {\\n    // Here we\\'ll apply 2 DSUs: one for Alice and one for Bob\\n    // So, we\\'ll need separate \"parents\" and \"ranks\" arrays for both Alice and Bob. \\n    // union() and find() will need to work on different \"parents\" and \"ranks\" array based on whose DSU they\\'re performing \\n    // i.e. will need to pass \"parents\" and \"ranks\" arrays as function parameter to union() and find() wherever required \\n    // i.e. there is not much point in having \"parents\" and \"ranks\" arrays as data member, here\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        // n: no. of vertices/nodes\\n        // edges: 2D array containing edges; each edge is like this: type, u, v (edge goes from u to v i.e. u->v)\\n        \\n        // for Alice\\n        int[] parentsA = new int[n];\\n        int[] ranksA = new int[n];\\n        \\n        // for Bob\\n        int[] parentsB = new int[n];\\n        int[] ranksB = new int[n];\\n        \\n        // initializing \"parents\" and \"ranks\" arrays for both Alice and Bob\\n        for(int i = 0; i < n; i++) {\\n            // initially the parent of node/vertex is itself\\n            parentsA[i] = parentsB[i] = i;\\n            \\n            // initially the rank of node/vertex is 0\\n            ranksA[i] = ranksB[i] = 0;\\n        }\\n        \\n        // We need to remove max. no. of edges in the graph i.e. keep min no. of edges i.e. keep the graph only connected (i.e. prevent cycle)\\n        // To achieve this, it\\'s wise to first use all the possible edges of \"type 3\". So, sorting edges array to keep edges of \"type 3\" in the beginning.\\n        // Type 1: Alice; Type 2: Bob; Type 3: both Alice and Bob\\n        Arrays.sort(edges, (e1, e2) -> {\\n            // e1 < e2 -> -1; e1 > e2 -> +1; e1 == e2 -> 0\\n            // e1 and e2 are single edge within edges\\n            // e1[0] - e2[0] would\\'ve sorted edges in ascending order by type; but if we do e2[0] - e1[0] then it will be reversed (i.e. descending order) by type\\n            \\n            return e2[0] - e1[0];\\n        });\\n        // Arrays.sort(edges, (e1, e2) -> Integer.compare(e2[0], e1[0]));\\n        \\n        // rc: remove count (i.e. the count of edges that can be removed)\\n        int rc = 0;\\n        \\n        // Count of vertices/nodes connected by the edges. This is required for the off case \"when the given graph doesn\\'t even have all the nodes/vertices connected to begin with\", in which case we need to return -1. If we won\\'t do this, we\\'ll end up returning 0 (which would be wrong).\\n        // cA: count of vertices/nodes connected (i.e. vertices/nodes that are traversable) by Alice \\n        // cB: count of vertices/nodes connected (i.e. vertices/nodes that are traversable) by Bob\\n        \\n        // Initialized cA and cB with 1 (instead of 0) because for the first time connection of vertices by an edge, the no. of vertices connected = 2. And when the subsequent vertices get connected with the edge, this count increases by 1. Just done to account for that.\\n        int cA = 1;\\n        int cB = 1;\\n        \\n        for(int i = 0; i < edges.length; i++) {\\n            int type = edges[i][0];\\n            // Vertices given are 1-indexed. We\\'ll just assume then to be 0-indexed (and this is fine, since we don\\'t need to return vertex and only a count in the end)\\n            int u = edges[i][1]; u--;\\n            int v = edges[i][2]; v--;\\n            \\n            // er: edge required? i.e. boolean\\n            if(type == 1) {\\n                // for Alice \\n                // Applying DSU for Alice (i.e. trying to see if this edge is required by Alice)\\n                boolean erA = union(parentsA, ranksA, u, v);\\n                \\n                if(erA == false) {\\n                    rc++;\\n                } else {\\n                    // count of connected vertices/nodes\\n                    cA++;\\n                }\\n                \\n            } else if(type == 2) {\\n                // for Bob \\n                // Applying DSU for Bob (i.e. trying to see if this edge is required by Bob)\\n                boolean erB = union(parentsB, ranksB, u, v);\\n                \\n                if(erB == false) {\\n                    rc++;\\n                } else {\\n                    // count of connected vertices/nodes\\n                    cB++;\\n                }\\n                \\n            } else {\\n                // type == 3 i.e for Alice and Bob, both\\n                // Applying DSU for both Alice and Bob (i.e. trying to see if this edge is required by both, Alice and Bob)\\n                boolean erA = union(parentsA, ranksA, u, v);\\n                boolean erB = union(parentsB, ranksB, u, v);\\n                \\n                // When this edge is NOT required by both Alice and Bob, only then we can say that this edge can be removed. If this edge is required by either one of them or both, then we\\'d need to use this edge\\n                if(erA == false && erB == false) {\\n                    // this case is unlikely since we\\'re first using all the edges of \"type 3\" (other types of edges later). At least one of Alice or Bob would need this edge. But for the sake of completeness (or the case I haven\\'t thought about), writing this\\n                    rc++;\\n                } else {\\n                    // count of connected vertices/nodes\\n                    // These cases are not possible (since we use edges of \"type 3\" first): (erA == false && erB == true), (erA == true && erB == false)\\n                    // So, either both Alice and Bob both will use it (or both won\\'t use it)\\n                    \\n                    // This case is when: (erA == true && erB == true)\\n                    cA++;\\n                    cB++;\\n                }\\n            }\\n        }\\n        \\n        // When the count of vertices/nodes connected by both Alice and Bob == no. of vertices/nodes i.e. all the vertices/nodes are connected by both Alice and Bob i.e. all the vertices and nodes are fully traversable by both Alice and Bob\\n        if(cA == n && cB == n) {\\n            return rc;\\n            \\n        } else {\\n            // Here, we can only remove edges and NOT add. So, if the no. of vertices/nodes connected by Alice or Bob (or both) is not n to begin with then we simply return -1\\n            return -1;\\n        }\\n    }\\n    \\n    // helper functions for DSU: union() and find()\\n    \\n    private boolean union(int[] parents, int[] ranks, int u, int v) {\\n        // lu: group leader of u, lv: group leader of v\\n        int lu = find(parents, u);\\n        int lv = find(parents, v);\\n        \\n        if(lu != lv) {\\n            // merging u and v i.e. we need to use this edge\\n            \\n            // union by ranks\\n            if(ranks[lu] < ranks[lv]) {\\n                parents[lu] = lv;\\n                \\n            } else if(ranks[lu] > ranks[lv]) {\\n                parents[lv] = lu;\\n                \\n            } else {\\n                // ranks[lu] == ranks[lv]\\n                parents[lu] = lv;\\n                ranks[lv]++;\\n            }\\n            \\n            return true;\\n            \\n        } else {\\n            // not merging u and v (since they both already belong to the same group) i.e. this edge is redundant i.e. we don\\'t need to use this edge\\n            return false;            \\n            \\n        }\\n    }\\n    \\n    // v: vertex/node\\n    private int find(int[] parents, int v) {\\n        if(parents[v] == v) {\\n            return v;\\n        }\\n        \\n        int leader = find(parents, parents[v]);\\n        parents[v] = leader; // path compression\\n        \\n        return leader;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    // Here we\\'ll apply 2 DSUs: one for Alice and one for Bob\\n    // So, we\\'ll need separate \"parents\" and \"ranks\" arrays for both Alice and Bob. \\n    // union() and find() will need to work on different \"parents\" and \"ranks\" array based on whose DSU they\\'re performing \\n    // i.e. will need to pass \"parents\" and \"ranks\" arrays as function parameter to union() and find() wherever required \\n    // i.e. there is not much point in having \"parents\" and \"ranks\" arrays as data member, here\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        // n: no. of vertices/nodes\\n        // edges: 2D array containing edges; each edge is like this: type, u, v (edge goes from u to v i.e. u->v)\\n        \\n        // for Alice\\n        int[] parentsA = new int[n];\\n        int[] ranksA = new int[n];\\n        \\n        // for Bob\\n        int[] parentsB = new int[n];\\n        int[] ranksB = new int[n];\\n        \\n        // initializing \"parents\" and \"ranks\" arrays for both Alice and Bob\\n        for(int i = 0; i < n; i++) {\\n            // initially the parent of node/vertex is itself\\n            parentsA[i] = parentsB[i] = i;\\n            \\n            // initially the rank of node/vertex is 0\\n            ranksA[i] = ranksB[i] = 0;\\n        }\\n        \\n        // We need to remove max. no. of edges in the graph i.e. keep min no. of edges i.e. keep the graph only connected (i.e. prevent cycle)\\n        // To achieve this, it\\'s wise to first use all the possible edges of \"type 3\". So, sorting edges array to keep edges of \"type 3\" in the beginning.\\n        // Type 1: Alice; Type 2: Bob; Type 3: both Alice and Bob\\n        Arrays.sort(edges, (e1, e2) -> {\\n            // e1 < e2 -> -1; e1 > e2 -> +1; e1 == e2 -> 0\\n            // e1 and e2 are single edge within edges\\n            // e1[0] - e2[0] would\\'ve sorted edges in ascending order by type; but if we do e2[0] - e1[0] then it will be reversed (i.e. descending order) by type\\n            \\n            return e2[0] - e1[0];\\n        });\\n        // Arrays.sort(edges, (e1, e2) -> Integer.compare(e2[0], e1[0]));\\n        \\n        // rc: remove count (i.e. the count of edges that can be removed)\\n        int rc = 0;\\n        \\n        // Count of vertices/nodes connected by the edges. This is required for the off case \"when the given graph doesn\\'t even have all the nodes/vertices connected to begin with\", in which case we need to return -1. If we won\\'t do this, we\\'ll end up returning 0 (which would be wrong).\\n        // cA: count of vertices/nodes connected (i.e. vertices/nodes that are traversable) by Alice \\n        // cB: count of vertices/nodes connected (i.e. vertices/nodes that are traversable) by Bob\\n        \\n        // Initialized cA and cB with 1 (instead of 0) because for the first time connection of vertices by an edge, the no. of vertices connected = 2. And when the subsequent vertices get connected with the edge, this count increases by 1. Just done to account for that.\\n        int cA = 1;\\n        int cB = 1;\\n        \\n        for(int i = 0; i < edges.length; i++) {\\n            int type = edges[i][0];\\n            // Vertices given are 1-indexed. We\\'ll just assume then to be 0-indexed (and this is fine, since we don\\'t need to return vertex and only a count in the end)\\n            int u = edges[i][1]; u--;\\n            int v = edges[i][2]; v--;\\n            \\n            // er: edge required? i.e. boolean\\n            if(type == 1) {\\n                // for Alice \\n                // Applying DSU for Alice (i.e. trying to see if this edge is required by Alice)\\n                boolean erA = union(parentsA, ranksA, u, v);\\n                \\n                if(erA == false) {\\n                    rc++;\\n                } else {\\n                    // count of connected vertices/nodes\\n                    cA++;\\n                }\\n                \\n            } else if(type == 2) {\\n                // for Bob \\n                // Applying DSU for Bob (i.e. trying to see if this edge is required by Bob)\\n                boolean erB = union(parentsB, ranksB, u, v);\\n                \\n                if(erB == false) {\\n                    rc++;\\n                } else {\\n                    // count of connected vertices/nodes\\n                    cB++;\\n                }\\n                \\n            } else {\\n                // type == 3 i.e for Alice and Bob, both\\n                // Applying DSU for both Alice and Bob (i.e. trying to see if this edge is required by both, Alice and Bob)\\n                boolean erA = union(parentsA, ranksA, u, v);\\n                boolean erB = union(parentsB, ranksB, u, v);\\n                \\n                // When this edge is NOT required by both Alice and Bob, only then we can say that this edge can be removed. If this edge is required by either one of them or both, then we\\'d need to use this edge\\n                if(erA == false && erB == false) {\\n                    // this case is unlikely since we\\'re first using all the edges of \"type 3\" (other types of edges later). At least one of Alice or Bob would need this edge. But for the sake of completeness (or the case I haven\\'t thought about), writing this\\n                    rc++;\\n                } else {\\n                    // count of connected vertices/nodes\\n                    // These cases are not possible (since we use edges of \"type 3\" first): (erA == false && erB == true), (erA == true && erB == false)\\n                    // So, either both Alice and Bob both will use it (or both won\\'t use it)\\n                    \\n                    // This case is when: (erA == true && erB == true)\\n                    cA++;\\n                    cB++;\\n                }\\n            }\\n        }\\n        \\n        // When the count of vertices/nodes connected by both Alice and Bob == no. of vertices/nodes i.e. all the vertices/nodes are connected by both Alice and Bob i.e. all the vertices and nodes are fully traversable by both Alice and Bob\\n        if(cA == n && cB == n) {\\n            return rc;\\n            \\n        } else {\\n            // Here, we can only remove edges and NOT add. So, if the no. of vertices/nodes connected by Alice or Bob (or both) is not n to begin with then we simply return -1\\n            return -1;\\n        }\\n    }\\n    \\n    // helper functions for DSU: union() and find()\\n    \\n    private boolean union(int[] parents, int[] ranks, int u, int v) {\\n        // lu: group leader of u, lv: group leader of v\\n        int lu = find(parents, u);\\n        int lv = find(parents, v);\\n        \\n        if(lu != lv) {\\n            // merging u and v i.e. we need to use this edge\\n            \\n            // union by ranks\\n            if(ranks[lu] < ranks[lv]) {\\n                parents[lu] = lv;\\n                \\n            } else if(ranks[lu] > ranks[lv]) {\\n                parents[lv] = lu;\\n                \\n            } else {\\n                // ranks[lu] == ranks[lv]\\n                parents[lu] = lv;\\n                ranks[lv]++;\\n            }\\n            \\n            return true;\\n            \\n        } else {\\n            // not merging u and v (since they both already belong to the same group) i.e. this edge is redundant i.e. we don\\'t need to use this edge\\n            return false;            \\n            \\n        }\\n    }\\n    \\n    // v: vertex/node\\n    private int find(int[] parents, int v) {\\n        if(parents[v] == v) {\\n            return v;\\n        }\\n        \\n        int leader = find(parents, parents[v]);\\n        parents[v] = leader; // path compression\\n        \\n        return leader;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729486,
                "title": "disjoint-set-python-code",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)] \\n        self.rank = [0 for i in range(size)]\\n    \\n    def find(self, x):\\n        if self.root[x] == x:\\n            return self.root[x]\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n        if root_x != root_y:\\n            if self.rank[root_x] <= self.rank[root_x]:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n            else:\\n                self.root[root_x] = root_y\\n                self.rank[root_y] += 1\\n    def connected(self, a, b):\\n        return self.find(a) == self.find(b)\\n\\n    \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        alice = UnionFind(n)\\n        bob = UnionFind(n)\\n        ans = 0\\n        alice_edges, bob_edges = 0, 0\\n        # first pass\\n        for edge in edges:\\n            e_type, node_s, node_e = edge\\n            node_s -= 1\\n            node_e -= 1\\n            if e_type != 3:\\n                continue\\n            if not alice.connected(node_s, node_e):\\n                alice.union(node_s, node_e)\\n                bob.union(node_s, node_e)\\n                alice_edges += 1\\n                bob_edges += 1\\n            else:\\n                ans += 1 # alreay connected\\n        # second pass\\n        for edge in edges:\\n            e_type, node_s, node_e = edge\\n            node_s -= 1\\n            node_e -= 1\\n            if e_type == 1:\\n                if not alice.connected(node_s, node_e):\\n                    alice.union(node_s, node_e)\\n                    alice_edges += 1\\n                else:\\n                    ans += 1\\n            if e_type == 2:\\n                if not bob.connected(node_s, node_e):\\n                    bob.union(node_s, node_e)\\n                    bob_edges += 1\\n                else:\\n                    ans += 1\\n        return ans if alice_edges == n - 1 and bob_edges == n - 1 else -1\\n                \\n",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)] \\n        self.rank = [0 for i in range(size)]\\n    \\n    def find(self, x):\\n        if self.root[x] == x:\\n            return self.root[x]\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n        if root_x != root_y:\\n            if self.rank[root_x] <= self.rank[root_x]:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n            else:\\n                self.root[root_x] = root_y\\n                self.rank[root_y] += 1\\n    def connected(self, a, b):\\n        return self.find(a) == self.find(b)\\n\\n    \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        alice = UnionFind(n)\\n        bob = UnionFind(n)\\n        ans = 0\\n        alice_edges, bob_edges = 0, 0\\n        # first pass\\n        for edge in edges:\\n            e_type, node_s, node_e = edge\\n            node_s -= 1\\n            node_e -= 1\\n            if e_type != 3:\\n                continue\\n            if not alice.connected(node_s, node_e):\\n                alice.union(node_s, node_e)\\n                bob.union(node_s, node_e)\\n                alice_edges += 1\\n                bob_edges += 1\\n            else:\\n                ans += 1 # alreay connected\\n        # second pass\\n        for edge in edges:\\n            e_type, node_s, node_e = edge\\n            node_s -= 1\\n            node_e -= 1\\n            if e_type == 1:\\n                if not alice.connected(node_s, node_e):\\n                    alice.union(node_s, node_e)\\n                    alice_edges += 1\\n                else:\\n                    ans += 1\\n            if e_type == 2:\\n                if not bob.connected(node_s, node_e):\\n                    bob.union(node_s, node_e)\\n                    bob_edges += 1\\n                else:\\n                    ans += 1\\n        return ans if alice_edges == n - 1 and bob_edges == n - 1 else -1\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1660941,
                "title": "java-union-find-o-n",
                "content": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) { \\n        int[] aparent = new int[n + 1];\\n        int[] bparent = new int[n + 1];\\n\\n        int anodes = n - 1;\\n        int bnodes = n - 1;\\n        int count = 0;\\n\\n        // processes type 3 first\\n        for (int[] e : edges) {\\n            if (e[0] == 3) {\\n                join(aparent, e[1], e[2]);\\n\\t\\t\\t\\t// since this is type 3, we only care about one of the joins\\n                if (join(bparent, e[1], e[2])) {\\n                    anodes--;\\n                    bnodes--;\\n                } else\\n                    count++;                \\n            }\\n        }\\n        \\n        for (int[] e : edges) {\\n            if (e[0] == 1) {\\n                if (join(aparent, e[1], e[2]))\\n                    anodes--;\\n                else\\n                    count++;                \\n            } else if (e[0] == 2) {\\n                if (join(bparent, e[1], e[2]))\\n                    bnodes--;\\n                else\\n                    count++;                  \\n            }\\n        }\\n        \\n        return anodes == 0 && bnodes == 0 ? count : -1;\\n    }\\n    \\n    private int parent(int[] parent, int x) {\\n        if (parent[x] == 0)\\n            return x;\\n        \\n        return parent[x] = parent(parent, parent[x]);\\n    }  \\n    \\n    private boolean join(int[] parent, int x, int y) {\\n        int px = parent(parent, x);\\n        int py = parent(parent, y);\\n\\n        if (px == py)\\n            return false;\\n        \\n        parent[px] = py;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) { \\n        int[] aparent = new int[n + 1];\\n        int[] bparent = new int[n + 1];\\n\\n        int anodes = n - 1;\\n        int bnodes = n - 1;\\n        int count = 0;\\n\\n        // processes type 3 first\\n        for (int[] e : edges) {\\n            if (e[0] == 3) {\\n                join(aparent, e[1], e[2]);\\n\\t\\t\\t\\t// since this is type 3, we only care about one of the joins\\n                if (join(bparent, e[1], e[2])) {\\n                    anodes--;\\n                    bnodes--;\\n                } else\\n                    count++;                \\n            }\\n        }\\n        \\n        for (int[] e : edges) {\\n            if (e[0] == 1) {\\n                if (join(aparent, e[1], e[2]))\\n                    anodes--;\\n                else\\n                    count++;                \\n            } else if (e[0] == 2) {\\n                if (join(bparent, e[1], e[2]))\\n                    bnodes--;\\n                else\\n                    count++;                  \\n            }\\n        }\\n        \\n        return anodes == 0 && bnodes == 0 ? count : -1;\\n    }\\n    \\n    private int parent(int[] parent, int x) {\\n        if (parent[x] == 0)\\n            return x;\\n        \\n        return parent[x] = parent(parent, parent[x]);\\n    }  \\n    \\n    private boolean join(int[] parent, int x, int y) {\\n        int px = parent(parent, x);\\n        int py = parent(parent, y);\\n\\n        if (px == py)\\n            return false;\\n        \\n        parent[px] = py;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613609,
                "title": "python-abdul-bari-template-union-find",
                "content": "* My Union Find implementation is inspired from Abdul Bari\\'s YouTube videos. Please watch his video if you have any doubts regarding the data structure implementation.\\n*  First iterate through type 3 edges and add them to both alice and bob graph if for either of them, the current pair of vertices were not reachable. Else, we can remove this edge from the main graph\\n* Next do the same for individual graphs and check if connectivity for all edges is present.\\n```\\nclass DSU:\\n    def __init__(self, num):\\n        self.parents = [-1] * (num + 1)\\n        \\n    def findParent(self, i):\\n        if self.parents[i] < 0:\\n            return i\\n        \\n        else:\\n            self.parents[i] = self.findParent(self.parents[i])\\n            \\n        return self.parents[i]\\n    \\n    def union(self, i, j):\\n        iParent = self.findParent(i)\\n        jParent = self.findParent(j)\\n        \\n        if iParent == jParent:\\n            return False\\n        \\n        if abs(self.parents[iParent]) >= abs(self.parents[jParent]):\\n            self.parents[iParent] += self.parents[jParent]\\n            self.parents[jParent] = iParent\\n            \\n        else:\\n            self.parents[jParent] += self.parents[iParent]\\n            self.parents[iParent] = jParent\\n            \\n        return True\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        alice = DSU(n)\\n        bob = DSU(n)\\n        \\n        onlyAlice = []\\n        onlyBob = []\\n        both = []\\n        \\n        for x, y, z in edges:\\n            if x == 1:\\n                onlyAlice.append([y, z])\\n                \\n            elif x == 2:\\n                onlyBob.append([y, z])\\n                \\n            else:\\n                both.append([y, z])\\n                \\n        ans = 0\\n        \\n        for x, y in both:\\n            case1 = alice.union(x, y)\\n            case2 = bob.union(x, y)\\n            \\n            if not case1 and not case2:\\n                ans += 1\\n                \\n        for x, y in onlyAlice:\\n            if not alice.union(x, y):\\n                ans += 1\\n                \\n        for x, y in onlyBob:\\n            if not bob.union(x, y):\\n                ans += 1\\n            \\n        #print(alice.parents)\\n        #print(bob.parents)\\n        \\n        cnt = 0\\n        for elem in alice.parents[1:]:\\n            if elem < 0:\\n                cnt += 1\\n                \\n            if cnt > 1:\\n                return -1\\n        \\n        cnt = 0\\n        for elem in bob.parents[1:]:\\n            if elem < 0:\\n                cnt += 1\\n                \\n            if cnt > 1:\\n                return -1\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "* My Union Find implementation is inspired from Abdul Bari\\'s YouTube videos. Please watch his video if you have any doubts regarding the data structure implementation.\\n*  First iterate through type 3 edges and add them to both alice and bob graph if for either of them, the current pair of vertices were not reachable. Else, we can remove this edge from the main graph\\n* Next do the same for individual graphs and check if connectivity for all edges is present.\\n```\\nclass DSU:\\n    def __init__(self, num):\\n        self.parents = [-1] * (num + 1)\\n        \\n    def findParent(self, i):\\n        if self.parents[i] < 0:\\n            return i\\n        \\n        else:\\n            self.parents[i] = self.findParent(self.parents[i])\\n            \\n        return self.parents[i]\\n    \\n    def union(self, i, j):\\n        iParent = self.findParent(i)\\n        jParent = self.findParent(j)\\n        \\n        if iParent == jParent:\\n            return False\\n        \\n        if abs(self.parents[iParent]) >= abs(self.parents[jParent]):\\n            self.parents[iParent] += self.parents[jParent]\\n            self.parents[jParent] = iParent\\n            \\n        else:\\n            self.parents[jParent] += self.parents[iParent]\\n            self.parents[iParent] = jParent\\n            \\n        return True\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        alice = DSU(n)\\n        bob = DSU(n)\\n        \\n        onlyAlice = []\\n        onlyBob = []\\n        both = []\\n        \\n        for x, y, z in edges:\\n            if x == 1:\\n                onlyAlice.append([y, z])\\n                \\n            elif x == 2:\\n                onlyBob.append([y, z])\\n                \\n            else:\\n                both.append([y, z])\\n                \\n        ans = 0\\n        \\n        for x, y in both:\\n            case1 = alice.union(x, y)\\n            case2 = bob.union(x, y)\\n            \\n            if not case1 and not case2:\\n                ans += 1\\n                \\n        for x, y in onlyAlice:\\n            if not alice.union(x, y):\\n                ans += 1\\n                \\n        for x, y in onlyBob:\\n            if not bob.union(x, y):\\n                ans += 1\\n            \\n        #print(alice.parents)\\n        #print(bob.parents)\\n        \\n        cnt = 0\\n        for elem in alice.parents[1:]:\\n            if elem < 0:\\n                cnt += 1\\n                \\n            if cnt > 1:\\n                return -1\\n        \\n        cnt = 0\\n        for elem in bob.parents[1:]:\\n            if elem < 0:\\n                cnt += 1\\n                \\n            if cnt > 1:\\n                return -1\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1584953,
                "title": "c-most-basic-union-find-textbook-union-find",
                "content": "```\\nclass DSUF{\\n    \\n  public:\\n    int n;\\n    vector<int> parent;\\n    vector<int> size;\\n    int totComponents;\\n    \\n    DSUF(int N){\\n        n = N;\\n        totComponents = n;\\n        parent.resize(n);\\n        \\n        for(int i=0;i<n;i++)\\n            parent[i] = i;\\n        \\n        size.resize(n,1);\\n        \\n    }\\n    \\n    \\n    int findRootOf(int node){\\n        //1. Find the root of the component to which \\'node\\' belongs to\\n        int root = node;\\n        while(parent[root]!=root)\\n            root = parent[root];\\n        \\n        //2. Path compression\\n        int currNode = node;\\n        while(currNode!=root){\\n            int parentOfCurr = parent[currNode];\\n            parent[currNode] = root;\\n            currNode = parentOfCurr;\\n        }\\n        \\n        return root; \\n    }\\n    \\n    \\n    bool unify(int nodeA, int nodeB){\\n        // returns true if nodeA & nodeB belonged to different components initially\\n        // returs false if both belnonges to the same component initially \\n        \\n        int rootA = findRootOf(nodeA);\\n        int rootB = findRootOf(nodeB);\\n        \\n        if(rootA == rootB)\\n            return false;\\n        \\n        if(size[rootA] >= size[rootB]){\\n            size[rootA] += size[rootB];\\n            parent[rootB] = rootA;\\n            totComponents--;\\n            return true;\\n        }\\n        else{\\n            size[rootB] += size[rootA];\\n            parent[rootA] = rootB;\\n            totComponents--;\\n            return true; \\n        }\\n    }\\n    \\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        this->n = n;\\n        \\n        int totEdgesRemoved = 0;\\n        \\n        DSUF* alice = new DSUF(n); int totAliceEdges=0;\\n    \\n        DSUF* bob = new DSUF(n); int totBobEdges=0;\\n        \\n        \\n        //1. Both Alice and Bob Common Edges (Type-3)----------------\\n        for(auto e : edges){\\n            if(e[0]!=3) continue;\\n            \\n            int u = e[1]-1; int v=e[2]-1;\\n            if(alice->unify(u,v) && bob->unify(u,v))\\n                {totAliceEdges++; totBobEdges++;}\\n            else \\n                totEdgesRemoved++;\\n        }\\n        //------------------------------------------------------------\\n        \\n        \\n        \\n        //2. Only Alice--------------------------------------------\\n        for(auto e : edges){\\n            if(e[0]==1){\\n                int u = e[1]-1; int v = e[2]-1;\\n                if(alice->unify(u,v))\\n                    totAliceEdges++;\\n                else \\n                    totEdgesRemoved++;\\n            }\\n        }\\n        if(totAliceEdges!=n-1) return -1;\\n        //-----------------------------------------------------------\\n        \\n        \\n        \\n        //3. Only Bob-----------------------------------------------\\n        for(auto e : edges){\\n            if(e[0]==2){\\n                int u = e[1]-1; int v = e[2]-1;\\n                if(bob->unify(u,v))\\n                    totBobEdges++;\\n                else \\n                    totEdgesRemoved++;\\n            }\\n        }\\n        if(totBobEdges!=n-1) return -1;\\n        //-----------------------------------------------------------\\n        \\n        return totEdgesRemoved;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSUF{\\n    \\n  public:\\n    int n;\\n    vector<int> parent;\\n    vector<int> size;\\n    int totComponents;\\n    \\n    DSUF(int N){\\n        n = N;\\n        totComponents = n;\\n        parent.resize(n);\\n        \\n        for(int i=0;i<n;i++)\\n            parent[i] = i;\\n        \\n        size.resize(n,1);\\n        \\n    }\\n    \\n    \\n    int findRootOf(int node){\\n        //1. Find the root of the component to which \\'node\\' belongs to\\n        int root = node;\\n        while(parent[root]!=root)\\n            root = parent[root];\\n        \\n        //2. Path compression\\n        int currNode = node;\\n        while(currNode!=root){\\n            int parentOfCurr = parent[currNode];\\n            parent[currNode] = root;\\n            currNode = parentOfCurr;\\n        }\\n        \\n        return root; \\n    }\\n    \\n    \\n    bool unify(int nodeA, int nodeB){\\n        // returns true if nodeA & nodeB belonged to different components initially\\n        // returs false if both belnonges to the same component initially \\n        \\n        int rootA = findRootOf(nodeA);\\n        int rootB = findRootOf(nodeB);\\n        \\n        if(rootA == rootB)\\n            return false;\\n        \\n        if(size[rootA] >= size[rootB]){\\n            size[rootA] += size[rootB];\\n            parent[rootB] = rootA;\\n            totComponents--;\\n            return true;\\n        }\\n        else{\\n            size[rootB] += size[rootA];\\n            parent[rootA] = rootB;\\n            totComponents--;\\n            return true; \\n        }\\n    }\\n    \\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        this->n = n;\\n        \\n        int totEdgesRemoved = 0;\\n        \\n        DSUF* alice = new DSUF(n); int totAliceEdges=0;\\n    \\n        DSUF* bob = new DSUF(n); int totBobEdges=0;\\n        \\n        \\n        //1. Both Alice and Bob Common Edges (Type-3)----------------\\n        for(auto e : edges){\\n            if(e[0]!=3) continue;\\n            \\n            int u = e[1]-1; int v=e[2]-1;\\n            if(alice->unify(u,v) && bob->unify(u,v))\\n                {totAliceEdges++; totBobEdges++;}\\n            else \\n                totEdgesRemoved++;\\n        }\\n        //------------------------------------------------------------\\n        \\n        \\n        \\n        //2. Only Alice--------------------------------------------\\n        for(auto e : edges){\\n            if(e[0]==1){\\n                int u = e[1]-1; int v = e[2]-1;\\n                if(alice->unify(u,v))\\n                    totAliceEdges++;\\n                else \\n                    totEdgesRemoved++;\\n            }\\n        }\\n        if(totAliceEdges!=n-1) return -1;\\n        //-----------------------------------------------------------\\n        \\n        \\n        \\n        //3. Only Bob-----------------------------------------------\\n        for(auto e : edges){\\n            if(e[0]==2){\\n                int u = e[1]-1; int v = e[2]-1;\\n                if(bob->unify(u,v))\\n                    totBobEdges++;\\n                else \\n                    totEdgesRemoved++;\\n            }\\n        }\\n        if(totBobEdges!=n-1) return -1;\\n        //-----------------------------------------------------------\\n        \\n        return totEdgesRemoved;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559981,
                "title": "simple-python-union-find-path-compression-time-complexity-o-n-space-complexity-o-n",
                "content": "```\\nclass UnionFind:\\n    \\n    def __init__(self,n):\\n        self.parent ={i:i for i in range(n)}\\n        self.rank = [0]*(n+1)\\n        \\n        \\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] = self.find(self.parent[u])\\n            \\n        return self.parent[u]\\n        \\n    def union(self,u,v):\\n        parent_u, parent_v = self.find(u), self.find(v)\\n        if parent_u== parent_v: return  False #cannot union, already unioned!\\n        \\n        if self.rank[u]< self.rank[v]:\\n            # connect/stick v to u\\n            self.parent[parent_u]= parent_v\\n            self.rank[parent_v] +=1\\n\\n        else:\\n            #connect u to v\\n            self.parent[parent_v] = parent_u\\n            self.rank[parent_u] +=1\\n            \\n        return True\\n    \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        uf =UnionFind(n+1)\\n        \\n        b, r, g =0,0,0\\n        \\n        redundant = 0\\n        #first use the blue ones\\n        for t,u,v in edges:\\n            if t==3:\\n                if uf.union(u,v):b+=1\\n                else: redundant +=1\\n        #make a copy for green ones\\n        uf2= copy.deepcopy(uf)\\n        \\n        #now use red ones\\n        for t,u,v in edges:\\n            if t==1:\\n                if uf.union(u,v): r+=1\\n                else: redundant +=1\\n                    \\n        #now use green ones\\n        for t,u,v in edges:\\n            if t==2:\\n                if uf2.union(u,v): g+=1\\n                else: redundant +=1\\n                    \\n        if g+b != n-1 or r+b != n-1: return -1\\n        return redundant\\n                    \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    \\n    def __init__(self,n):\\n        self.parent ={i:i for i in range(n)}\\n        self.rank = [0]*(n+1)\\n        \\n        \\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] = self.find(self.parent[u])\\n            \\n        return self.parent[u]\\n        \\n    def union(self,u,v):\\n        parent_u, parent_v = self.find(u), self.find(v)\\n        if parent_u== parent_v: return  False #cannot union, already unioned!\\n        \\n        if self.rank[u]< self.rank[v]:\\n            # connect/stick v to u\\n            self.parent[parent_u]= parent_v\\n            self.rank[parent_v] +=1\\n\\n        else:\\n            #connect u to v\\n            self.parent[parent_v] = parent_u\\n            self.rank[parent_u] +=1\\n            \\n        return True\\n    \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        uf =UnionFind(n+1)\\n        \\n        b, r, g =0,0,0\\n        \\n        redundant = 0\\n        #first use the blue ones\\n        for t,u,v in edges:\\n            if t==3:\\n                if uf.union(u,v):b+=1\\n                else: redundant +=1\\n        #make a copy for green ones\\n        uf2= copy.deepcopy(uf)\\n        \\n        #now use red ones\\n        for t,u,v in edges:\\n            if t==1:\\n                if uf.union(u,v): r+=1\\n                else: redundant +=1\\n                    \\n        #now use green ones\\n        for t,u,v in edges:\\n            if t==2:\\n                if uf2.union(u,v): g+=1\\n                else: redundant +=1\\n                    \\n        if g+b != n-1 or r+b != n-1: return -1\\n        return redundant\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559931,
                "title": "simple-python-union-find-solution",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self. parent = {i:i for i in range(n)}\\n        \\n        \\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] =self.find(self.parent[u])\\n        return self.parent[u]\\n    \\n    \\n    def union(self, u,v):\\n        parent_u, parent_v =self.find(u), self.find(v)\\n        \\n        if parent_u != parent_v:\\n            self.parent[parent_u] = parent_v\\n            return True #return true if actually had to do union\\n        \\n        else: return False #if it was not necessary connection already existed\\n        \\n        \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        uf = UnionFind(n+1)\\n        r,b,g= 0,0,0\\n        redundant = 0\\n        \\n        # assumption parent of smaller one is always larger one\\n        #union via all blue\\n        for t,u,v in edges:\\n            if u>v: u,v = v,u\\n            if t==3:\\n                if uf.union(u,v):\\n                    b+=1\\n                else: \\n                    #print(\\'redundant: \\', \\' u: \\', u, \\' v: \\', v, \\' color is blue \\')\\n                    redundant +=1\\n                  \\n        #copy it here\\n        uf_blue = copy.deepcopy(uf)\\n        #union via all red\\n        for t,u,v in edges:\\n            if u>v: u,v = v,u\\n            if t==1:\\n                if uf.union(u,v):\\n                    r+=1\\n                    \\n                else: redundant +=1\\n                    \\n        #union via all green\\n        uf = uf_blue\\n        for t,u,v in edges:\\n            if u>v: u,v = v,u\\n            if t==2:\\n                if uf.union(u,v):\\n                    g+=1\\n                    \\n                else:redundant +=1\\n                    \\n        #check if everything is connected\\n        if  r+b!=n-1 or  g+b !=n-1 : return -1\\n        \\n        return redundant\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self. parent = {i:i for i in range(n)}\\n        \\n        \\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] =self.find(self.parent[u])\\n        return self.parent[u]\\n    \\n    \\n    def union(self, u,v):\\n        parent_u, parent_v =self.find(u), self.find(v)\\n        \\n        if parent_u != parent_v:\\n            self.parent[parent_u] = parent_v\\n            return True #return true if actually had to do union\\n        \\n        else: return False #if it was not necessary connection already existed\\n        \\n        \\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        uf = UnionFind(n+1)\\n        r,b,g= 0,0,0\\n        redundant = 0\\n        \\n        # assumption parent of smaller one is always larger one\\n        #union via all blue\\n        for t,u,v in edges:\\n            if u>v: u,v = v,u\\n            if t==3:\\n                if uf.union(u,v):\\n                    b+=1\\n                else: \\n                    #print(\\'redundant: \\', \\' u: \\', u, \\' v: \\', v, \\' color is blue \\')\\n                    redundant +=1\\n                  \\n        #copy it here\\n        uf_blue = copy.deepcopy(uf)\\n        #union via all red\\n        for t,u,v in edges:\\n            if u>v: u,v = v,u\\n            if t==1:\\n                if uf.union(u,v):\\n                    r+=1\\n                    \\n                else: redundant +=1\\n                    \\n        #union via all green\\n        uf = uf_blue\\n        for t,u,v in edges:\\n            if u>v: u,v = v,u\\n            if t==2:\\n                if uf.union(u,v):\\n                    g+=1\\n                    \\n                else:redundant +=1\\n                    \\n        #check if everything is connected\\n        if  r+b!=n-1 or  g+b !=n-1 : return -1\\n        \\n        return redundant\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417402,
                "title": "java-12-ms-disjoint-set-union-by-rank-96-speed-and-91-memory",
                "content": "```\\nclass DisjointSetUnion{\\n    private int n;\\n    private int[] parent, rank;\\n\\n    public DisjointSetUnion(int n){\\n        this.n = n;\\n        this.parent = new int[n];\\n        this.rank = new int[n];\\n\\n        for(int i = 0; i < n; i++){\\n            this.parent[i] = i;\\n            this.rank[i] = 1;\\n        }\\n    }\\n\\n    public boolean areConnected(int u, int v){\\n       return find(u) == find(v);\\n    }\\n\\n    public boolean union(int u, int v){\\n        if(u != v){\\n           // find parents\\n           int p = find(u);\\n           int q = find(v);\\n\\n           if(p != q){\\n               if(rank[p] > rank[q]){\\n                    rank[p] += rank[q];\\n                    parent[q] = p;\\n               }else{\\n                    rank[q] += rank[p];\\n                    parent[p] = q;\\n               }\\n\\n               return true;\\n           }\\n        }\\n\\n        return false;\\n    }\\n\\n    private int find(int u){\\n        int x = u;\\n        while(x != parent[x]){\\n            x = parent[x];\\n        }\\n      \\n        parent[u] = x;\\n        return x;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        DisjointSetUnion alice = new DisjointSetUnion(n + 1);\\n        DisjointSetUnion bob = new DisjointSetUnion(n + 1);\\n\\n\\n        int start, end, edgeType;\\n        boolean aliceUnion, bobUnion;\\n\\n        int deletedCount = 0;\\n\\n         for(int[] edge : edges){\\n           edgeType = edge[0];\\n           start = edge[1];\\n           end = edge[2];\\n \\n           if(edgeType == 3){\\n               aliceUnion = alice.union(start, end);\\n               bobUnion = bob.union(start, end);\\n               if(!aliceUnion && !bobUnion){\\n                   ++deletedCount; // both already had access to this path\\n               }\\n           }\\n        }\\n\\n        // check for exclusive edges\\n        for(int[] edge : edges){\\n            edgeType = edge[0];\\n            start = edge[1];\\n            end = edge[2];\\n            \\n            if(edgeType == 1){\\n                if(!alice.union(start, end)){\\n                    ++deletedCount; // Alice already has access to this path\\n                }\\n            }else if(edgeType == 2){\\n                if(!bob.union(start, end)){\\n                    ++deletedCount; // Bob already has access to this path\\n                }\\n            } \\n        }\\n        \\n        // check for full connectivity for both Alice and Bob\\n        for(int i = 1; i < n; i++){\\n            if(!alice.areConnected(i, i + 1) || !bob.areConnected(i, i + 1)){\\n                 return -1;\\n            }\\n        }\\n\\n        return deletedCount;\\n    }\\n}\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7b0d7c42-f71d-4c97-a6b6-f619972cdf59_1629553510.4432635.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass DisjointSetUnion{\\n    private int n;\\n    private int[] parent, rank;\\n\\n    public DisjointSetUnion(int n){\\n        this.n = n;\\n        this.parent = new int[n];\\n        this.rank = new int[n];\\n\\n        for(int i = 0; i < n; i++){\\n            this.parent[i] = i;\\n            this.rank[i] = 1;\\n        }\\n    }\\n\\n    public boolean areConnected(int u, int v){\\n       return find(u) == find(v);\\n    }\\n\\n    public boolean union(int u, int v){\\n        if(u != v){\\n           // find parents\\n           int p = find(u);\\n           int q = find(v);\\n\\n           if(p != q){\\n               if(rank[p] > rank[q]){\\n                    rank[p] += rank[q];\\n                    parent[q] = p;\\n               }else{\\n                    rank[q] += rank[p];\\n                    parent[p] = q;\\n               }\\n\\n               return true;\\n           }\\n        }\\n\\n        return false;\\n    }\\n\\n    private int find(int u){\\n        int x = u;\\n        while(x != parent[x]){\\n            x = parent[x];\\n        }\\n      \\n        parent[u] = x;\\n        return x;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        DisjointSetUnion alice = new DisjointSetUnion(n + 1);\\n        DisjointSetUnion bob = new DisjointSetUnion(n + 1);\\n\\n\\n        int start, end, edgeType;\\n        boolean aliceUnion, bobUnion;\\n\\n        int deletedCount = 0;\\n\\n         for(int[] edge : edges){\\n           edgeType = edge[0];\\n           start = edge[1];\\n           end = edge[2];\\n \\n           if(edgeType == 3){\\n               aliceUnion = alice.union(start, end);\\n               bobUnion = bob.union(start, end);\\n               if(!aliceUnion && !bobUnion){\\n                   ++deletedCount; // both already had access to this path\\n               }\\n           }\\n        }\\n\\n        // check for exclusive edges\\n        for(int[] edge : edges){\\n            edgeType = edge[0];\\n            start = edge[1];\\n            end = edge[2];\\n            \\n            if(edgeType == 1){\\n                if(!alice.union(start, end)){\\n                    ++deletedCount; // Alice already has access to this path\\n                }\\n            }else if(edgeType == 2){\\n                if(!bob.union(start, end)){\\n                    ++deletedCount; // Bob already has access to this path\\n                }\\n            } \\n        }\\n        \\n        // check for full connectivity for both Alice and Bob\\n        for(int i = 1; i < n; i++){\\n            if(!alice.areConnected(i, i + 1) || !bob.areConnected(i, i + 1)){\\n                 return -1;\\n            }\\n        }\\n\\n        return deletedCount;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114199,
                "title": "c-dsu-easy-o-n",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int componentsA;\\n    int componentsB;\\n    \\n    int find(vector<int> &parent, int x) {\\n        while(x != parent[x]) {\\n            parent[x] = parent[parent[x]];\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n    \\n    bool unite(vector<int> &parent, int u, int v, char who) {\\n        int parU = find(parent,u);\\n        int parV = find(parent,v);\\n        \\n        // this edge has to be there\\n        if(parU != parV) {\\n            parent[parU] = parV;\\n            if(who == \\'A\\') componentsA--;\\n            if(who == \\'B\\') componentsB--;\\n            //true means union took place \\n            return true;\\n        }\\n        //can be removed\\n        return false;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n        componentsA = n;\\n        componentsB = n;\\n        vector<int> parentA(n+1);\\n        vector<int> parentB(n+1);\\n        // picking type 3 edges first\\n        sort(edges.begin(),edges.end());\\n        reverse(edges.begin(),edges.end());\\n        \\n        for(int i=1;i<=n;i++) {\\n            parentA[i]=i;\\n            parentB[i]=i;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<edges.size();i++) {\\n            int type = edges[i][0];\\n            int u = edges[i][1];\\n            int v = edges[i][2];\\n            \\n            if(type == 3) {\\n                ans += !(unite(parentA,u,v,\\'A\\') && unite(parentB,u,v,\\'B\\'));\\n            } \\n            else if(type == 2) {\\n                ans += !unite(parentB,u,v,\\'B\\');\\n            }\\n            else if(type == 1){\\n                ans += !unite(parentA,u,v,\\'A\\');\\n            }\\n        }\\n        \\n        return (componentsA == 1 && componentsB == 1) ? ans : -1; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int componentsA;\\n    int componentsB;\\n    \\n    int find(vector<int> &parent, int x) {\\n        while(x != parent[x]) {\\n            parent[x] = parent[parent[x]];\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n    \\n    bool unite(vector<int> &parent, int u, int v, char who) {\\n        int parU = find(parent,u);\\n        int parV = find(parent,v);\\n        \\n        // this edge has to be there\\n        if(parU != parV) {\\n            parent[parU] = parV;\\n            if(who == \\'A\\') componentsA--;\\n            if(who == \\'B\\') componentsB--;\\n            //true means union took place \\n            return true;\\n        }\\n        //can be removed\\n        return false;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        \\n        componentsA = n;\\n        componentsB = n;\\n        vector<int> parentA(n+1);\\n        vector<int> parentB(n+1);\\n        // picking type 3 edges first\\n        sort(edges.begin(),edges.end());\\n        reverse(edges.begin(),edges.end());\\n        \\n        for(int i=1;i<=n;i++) {\\n            parentA[i]=i;\\n            parentB[i]=i;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<edges.size();i++) {\\n            int type = edges[i][0];\\n            int u = edges[i][1];\\n            int v = edges[i][2];\\n            \\n            if(type == 3) {\\n                ans += !(unite(parentA,u,v,\\'A\\') && unite(parentB,u,v,\\'B\\'));\\n            } \\n            else if(type == 2) {\\n                ans += !unite(parentB,u,v,\\'B\\');\\n            }\\n            else if(type == 1){\\n                ans += !unite(parentA,u,v,\\'A\\');\\n            }\\n        }\\n        \\n        return (componentsA == 1 && componentsB == 1) ? ans : -1; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092452,
                "title": "c-union-find-explained",
                "content": "The problem is equivalant to building 2 graphs for Alice and Bob, that connects all the nodes.\\nAnd we want to find the minimum number of edges to build the 2 graphs.\\n\\n```\\nclass Solution {    \\n    int find(vector<int>& g, int i) {\\n        if(g[i] == i) return i;\\n        g[i] = find(g, g[i]);\\n        return g[i];\\n    }\\n    \\n    void merge(vector<int>& g, int x, int y) {\\n        x = find(g, x);\\n        y = find(g, y);\\n        g[y] = x;\\n    }\\n    \\n    // Construct the graph based on the edge type specificed in type.\\n    // If the edge links 2 nodes that are already connected, we can delete that edge.\\n    int construct(vector<vector<int>>& edges, vector<int>& g, int type, int& graphLen) {\\n        int del = 0;\\n        for(auto e : edges) {\\n            if(e[0] == type) {\\n                int x = find(g, e[1]);\\n                int y = find(g, e[2]);\\n                if(x == y) {\\n                    del++;\\n                } else {\\n                    merge(g, x, y);\\n                    graphLen++;\\n                }\\n            }\\n        }\\n        return del;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> ga(n+1, 0);\\n        vector<int> gb(n+1, 0);\\n        for(int i=0; i<=n; ++i) {\\n            ga[i] = i;\\n            gb[i] = i;\\n        }\\n        \\n        int del = 0;\\n        int aLen = 0, bLen = 0;\\n\\n        // Prioritize type 3 because both alice and bob can share this type of edges.\\n        del += construct(edges, ga, 3, aLen);\\n        construct(edges, gb, 3, bLen);\\n        \\n        del += construct(edges, ga, 1, aLen);\\n        del += construct(edges, gb, 2, bLen);\\n        \\n        if(aLen != n-1 || bLen != n-1) return -1;\\n        return del;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    int find(vector<int>& g, int i) {\\n        if(g[i] == i) return i;\\n        g[i] = find(g, g[i]);\\n        return g[i];\\n    }\\n    \\n    void merge(vector<int>& g, int x, int y) {\\n        x = find(g, x);\\n        y = find(g, y);\\n        g[y] = x;\\n    }\\n    \\n    // Construct the graph based on the edge type specificed in type.\\n    // If the edge links 2 nodes that are already connected, we can delete that edge.\\n    int construct(vector<vector<int>>& edges, vector<int>& g, int type, int& graphLen) {\\n        int del = 0;\\n        for(auto e : edges) {\\n            if(e[0] == type) {\\n                int x = find(g, e[1]);\\n                int y = find(g, e[2]);\\n                if(x == y) {\\n                    del++;\\n                } else {\\n                    merge(g, x, y);\\n                    graphLen++;\\n                }\\n            }\\n        }\\n        return del;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> ga(n+1, 0);\\n        vector<int> gb(n+1, 0);\\n        for(int i=0; i<=n; ++i) {\\n            ga[i] = i;\\n            gb[i] = i;\\n        }\\n        \\n        int del = 0;\\n        int aLen = 0, bLen = 0;\\n\\n        // Prioritize type 3 because both alice and bob can share this type of edges.\\n        del += construct(edges, ga, 3, aLen);\\n        construct(edges, gb, 3, bLen);\\n        \\n        del += construct(edges, ga, 1, aLen);\\n        del += construct(edges, gb, 2, bLen);\\n        \\n        if(aLen != n-1 || bLen != n-1) return -1;\\n        return del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848649,
                "title": "javascript-python3-c-union-find-greedy",
                "content": "**Synopsis:**\\n\\nUse union-find to join disjoint sets of `N` parent representatives for Alice `A` and Bob `B`:\\n* **`\\uD83E\\uDD47` first:** `\\uD83D\\uDCB0` greedily union the shared edges for Alice and Bob correspondingly\\n* **`\\uD83E\\uDD48` second:** union non-shared edges for Alice and Bob correspondingly\\n\\n`\\uD83D\\uDD17` When a union results in the `same` parent representative, we know the edge redundantly connects to the `same` connected component.  Thus increment `same` by 1 each time this occurs, since we can safely remove these redundant edges.  We use `same` to track redundant edges for Alice and Bob.\\n\\n`\\uD83C\\uDFAF` When determining if there exists a single connected component for Alice and Bob correspondingly, we can choose any value between `0..N-1` inclusive to use as a reference \"target\" parent representative of each set.  This choice is arbitrary and irrelevant.  I chose `0` since this value is sufficient for all inputs.\\n\\n---\\n\\n**Contest 205 Screenshare:** https://www.youtube.com/watch?v=6WOqZy-oE2A\\n\\n* `\\u261D\\uFE0F` I upsolved this problem after the contest, however, as you can see in the video I was headed in the right direction with union-find.  Post-moterm analysis reveals a lack of astute observation:\\n\\t* `\\uD83D\\uDEAB` I missed the 1-based indexing\\n\\t* `\\uD83D\\uDEAB` I missed the greedy consumption of shared edges first\\n\\n* `\\uD83E\\uDD29 ` I\\'m totally stoked to have upsolved this problem!  I used to feel really bad \"missing\" problems during the contest, but now I look at these \"misses\" as a learning opportunities.  I\\'ve observed my opportunity for learning is far-greater from problems I initially \"missed\" during contests compared to problems I initially answered correctly \\uD83D\\uDC4D\\n\\n---\\n\\n* **Runtime:** O(N)\\n* **Memory:** O(N)\\n\\n---\\n\\n*Javascript*\\n```\\nlet maxNumEdgesToRemove = (N, E, same = 0) => {\\n    E = E.map(([ _, u, v ]) => [ _, u - 1, v - 1]);             // \\u2B50\\uFE0F -1 for 1-based to 0-based indexing\\n    let A = [...Array(N).keys()],                               // \\uD83D\\uDE42 parent representatives of disjoint sets for Alice\\n        B = [...Array(N).keys()];                               // \\uD83D\\uDE42 parent representatives of disjoint sets for Bob\\n    let find = (P, x) => P[x] = P[x] == x ? x : find(P, P[x]);\\n    let union = (P, a, b) => {\\n        a = find(P, a);\\n        b = find(P, b);\\n        if (a == b)\\n            return 1;\\n        P[a] = b;  // arbitrary choice\\n        return 0;\\n    };\\n    E.forEach(([ type, u, v ]) => {\\n        if (type == 3) same += union(A, u, v) | union(B, u, v);  // \\uD83E\\uDD47 first: \\uD83D\\uDD17 union shared edges for Alice and Bob\\n    });\\n    E.forEach(([ type, u, v ]) => {\\n        if (type == 1) same += union(A, u, v);                   // \\uD83E\\uDD48 second: \\uD83D\\uDD17 union edges for Alice\\n        if (type == 2) same += union(B, u, v);                   //            \\uD83D\\uDD17 union edges for Bob\\n    });\\n    // \\uD83C\\uDFAF is there a single connected component for Alice and Bob?\\n    // if so, return the amount of edges which redundantly connect\\n    // to each same connected component for Alice and Bob\\n    return A.every(x => find(A, 0) == find(A, x)) &&\\n           B.every(x => find(B, 0) == find(B, x)) ? same : -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, N: int, E: List[List[int]], same = 0) -> int:\\n        E = [[_, u - 1, v - 1] for _, u, v in E]                    # \\u2B50\\uFE0F -1 for 1-based to 0-based indexing\\n        A = [i for i in range(N)]                                   # \\uD83D\\uDE42 parent representatives of disjoint sets for Alice\\n        B = [i for i in range(N)]                                   # \\uD83D\\uDE42 parent representatives of disjoint sets for Bob\\n        def find(P, x): P[x] = P[x] if P[x] == x else find(P, P[x]); return P[x]\\n        def union(P, a, b):\\n            a = find(P, a)\\n            b = find(P, b)\\n            if a == b:\\n                return 1\\n            P[a] = b  # arbitrary choice\\n            return 0\\n        for type, u, v in E:\\n            if type == 3: same += union(A, u, v) | union(B, u, v)   # \\uD83E\\uDD47 first: \\uD83D\\uDD17 union shared edges for Alice and Bob\\n        for type, u, v in E:\\n            if type == 1: same += union(A, u, v)                    # \\uD83E\\uDD48 second: \\uD83D\\uDD17 union for Alice\\n            if type == 2: same += union(B, u, v)                    #            \\uD83D\\uDD17 union for Bob\\n        # \\uD83C\\uDFAF is there a single connected component for Alice and Bob?\\n        # if so, return the accumulated amount of edges which redundantly connect\\n        # to each same connected component for Alice and Bob\\n        return same if all(find(A, 0) == find(A, x) for x in A) and all(find(B, 0) == find(B, x) for x in B) else -1\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(VI&, int)>;\\n    int maxNumEdgesToRemove(int N, VVI& E, int same = 0) {\\n        transform(E.begin(), E.end(), E.begin(), [](auto& edge) {\\n            auto [ _, u, v ] = tie(edge[0], edge[1], edge[2]);\\n            return VI{ _, u - 1, v - 1 };                          // \\u2B50\\uFE0F -1 for 1-based to 0-based indexing\\n        });\\n        VI A(N); iota(A.begin(), A.end(), 0);                      // \\uD83D\\uDE42 parent representatives of disjoint sets for Alice\\n        VI B(N); iota(B.begin(), B.end(), 0);                      // \\uD83D\\uDE42 parent representatives of disjoint sets for Bob\\n        fun find = [&](auto& P, auto x) {\\n            return P[x] = P[x] == x ? x : find(P, P[x]);\\n        };\\n        auto _union = [&](auto& P, auto a, auto b) {\\n            a = find(P, a);\\n            b = find(P, b);\\n            if (a == b)\\n                return 1;\\n            P[a] = b;  // arbitrary choice\\n            return 0;\\n        };\\n        for (auto& edge: E) {\\n            auto [ type, u, v ] = tie(edge[0], edge[1], edge[2]);\\n            if (type == 3) same += _union(A, u, v) | _union(B, u, v);  // \\uD83E\\uDD47 first: \\uD83D\\uDD17 union shared edges for Alice and Bob\\n        }\\n        for (auto& edge: E) {\\n            auto [ type, u, v ] = tie(edge[0], edge[1], edge[2]);\\n            if (type == 1) same += _union(A, u, v);                    // \\uD83E\\uDD48 second: \\uD83D\\uDD17 union edges for Alice\\n            if (type == 2) same += _union(B, u, v);                    //            \\uD83D\\uDD17 union edges for Bob\\n        }\\n        // \\uD83C\\uDFAF is there a single connected component for Alice and Bob?\\n        // if so, return the amount of edges which redundantly connect\\n        // to each same connected component for Alice and Bob\\n        return all_of(A.begin(), A.end(), [&](auto x) { return find(A, 0) == find(A, x); }) &&\\n               all_of(B.begin(), B.end(), [&](auto x) { return find(B, 0) == find(B, x); }) ? same : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet maxNumEdgesToRemove = (N, E, same = 0) => {\\n    E = E.map(([ _, u, v ]) => [ _, u - 1, v - 1]);             // \\u2B50\\uFE0F -1 for 1-based to 0-based indexing\\n    let A = [...Array(N).keys()],                               // \\uD83D\\uDE42 parent representatives of disjoint sets for Alice\\n        B = [...Array(N).keys()];                               // \\uD83D\\uDE42 parent representatives of disjoint sets for Bob\\n    let find = (P, x) => P[x] = P[x] == x ? x : find(P, P[x]);\\n    let union = (P, a, b) => {\\n        a = find(P, a);\\n        b = find(P, b);\\n        if (a == b)\\n            return 1;\\n        P[a] = b;  // arbitrary choice\\n        return 0;\\n    };\\n    E.forEach(([ type, u, v ]) => {\\n        if (type == 3) same += union(A, u, v) | union(B, u, v);  // \\uD83E\\uDD47 first: \\uD83D\\uDD17 union shared edges for Alice and Bob\\n    });\\n    E.forEach(([ type, u, v ]) => {\\n        if (type == 1) same += union(A, u, v);                   // \\uD83E\\uDD48 second: \\uD83D\\uDD17 union edges for Alice\\n        if (type == 2) same += union(B, u, v);                   //            \\uD83D\\uDD17 union edges for Bob\\n    });\\n    // \\uD83C\\uDFAF is there a single connected component for Alice and Bob?\\n    // if so, return the amount of edges which redundantly connect\\n    // to each same connected component for Alice and Bob\\n    return A.every(x => find(A, 0) == find(A, x)) &&\\n           B.every(x => find(B, 0) == find(B, x)) ? same : -1;\\n};\\n```\n```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, N: int, E: List[List[int]], same = 0) -> int:\\n        E = [[_, u - 1, v - 1] for _, u, v in E]                    # \\u2B50\\uFE0F -1 for 1-based to 0-based indexing\\n        A = [i for i in range(N)]                                   # \\uD83D\\uDE42 parent representatives of disjoint sets for Alice\\n        B = [i for i in range(N)]                                   # \\uD83D\\uDE42 parent representatives of disjoint sets for Bob\\n        def find(P, x): P[x] = P[x] if P[x] == x else find(P, P[x]); return P[x]\\n        def union(P, a, b):\\n            a = find(P, a)\\n            b = find(P, b)\\n            if a == b:\\n                return 1\\n            P[a] = b  # arbitrary choice\\n            return 0\\n        for type, u, v in E:\\n            if type == 3: same += union(A, u, v) | union(B, u, v)   # \\uD83E\\uDD47 first: \\uD83D\\uDD17 union shared edges for Alice and Bob\\n        for type, u, v in E:\\n            if type == 1: same += union(A, u, v)                    # \\uD83E\\uDD48 second: \\uD83D\\uDD17 union for Alice\\n            if type == 2: same += union(B, u, v)                    #            \\uD83D\\uDD17 union for Bob\\n        # \\uD83C\\uDFAF is there a single connected component for Alice and Bob?\\n        # if so, return the accumulated amount of edges which redundantly connect\\n        # to each same connected component for Alice and Bob\\n        return same if all(find(A, 0) == find(A, x) for x in A) and all(find(B, 0) == find(B, x) for x in B) else -1\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(VI&, int)>;\\n    int maxNumEdgesToRemove(int N, VVI& E, int same = 0) {\\n        transform(E.begin(), E.end(), E.begin(), [](auto& edge) {\\n            auto [ _, u, v ] = tie(edge[0], edge[1], edge[2]);\\n            return VI{ _, u - 1, v - 1 };                          // \\u2B50\\uFE0F -1 for 1-based to 0-based indexing\\n        });\\n        VI A(N); iota(A.begin(), A.end(), 0);                      // \\uD83D\\uDE42 parent representatives of disjoint sets for Alice\\n        VI B(N); iota(B.begin(), B.end(), 0);                      // \\uD83D\\uDE42 parent representatives of disjoint sets for Bob\\n        fun find = [&](auto& P, auto x) {\\n            return P[x] = P[x] == x ? x : find(P, P[x]);\\n        };\\n        auto _union = [&](auto& P, auto a, auto b) {\\n            a = find(P, a);\\n            b = find(P, b);\\n            if (a == b)\\n                return 1;\\n            P[a] = b;  // arbitrary choice\\n            return 0;\\n        };\\n        for (auto& edge: E) {\\n            auto [ type, u, v ] = tie(edge[0], edge[1], edge[2]);\\n            if (type == 3) same += _union(A, u, v) | _union(B, u, v);  // \\uD83E\\uDD47 first: \\uD83D\\uDD17 union shared edges for Alice and Bob\\n        }\\n        for (auto& edge: E) {\\n            auto [ type, u, v ] = tie(edge[0], edge[1], edge[2]);\\n            if (type == 1) same += _union(A, u, v);                    // \\uD83E\\uDD48 second: \\uD83D\\uDD17 union edges for Alice\\n            if (type == 2) same += _union(B, u, v);                    //            \\uD83D\\uDD17 union edges for Bob\\n        }\\n        // \\uD83C\\uDFAF is there a single connected component for Alice and Bob?\\n        // if so, return the amount of edges which redundantly connect\\n        // to each same connected component for Alice and Bob\\n        return all_of(A.begin(), A.end(), [&](auto x) { return find(A, 0) == find(A, x); }) &&\\n               all_of(B.begin(), B.end(), [&](auto x) { return find(B, 0) == find(B, x); }) ? same : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840294,
                "title": "c-easy-to-understand-union-find",
                "content": "```\\nclass Unionfind{\\n    int distinctcomp;\\n    vector<int> component;\\n    public:\\n    Unionfind(int n)\\n    {\\n        distinctcomp=n;\\n        for(int i=0;i<=n;i++)\\n            component.push_back(i);\\n    }\\n    int findcomponent(int a)\\n    {\\n        if(component[a]!=a)\\n            component[a]=findcomponent(component[a]);\\n        return component[a];\\n    }\\n    bool unite(int a,int b)\\n    {\\n        if(findcomponent(a)==findcomponent(b))\\n            return false;\\n        component[findcomponent(a)]=b;\\n        distinctcomp--;\\n        return true;\\n    }\\n    bool united()\\n    {\\n        return distinctcomp==1;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int edgeadd=0;\\n        Unionfind bob(n),alice(n);\\n        sort(edges.begin(),edges.end(),[](vector<int> &a,vector<int> &b){return a[0]>b[0];});\\n        for(auto &edge:edges)\\n        {\\n            int a1=edge[0],a2=edge[1],a3=edge[2];\\n            switch(a1)\\n            {\\n                case 3:\\n                    edgeadd+=bob.unite(a2,a3)|alice.unite(a2,a3);\\n                    break;\\n                case 2:\\n                    edgeadd+=bob.unite(a2,a3);\\n                    break;\\n                case 1:\\n                    edgeadd+=alice.unite(a2,a3);\\n                    break;\\n            }\\n        }\\n        return (bob.united() && alice.united())?edges.size()-edgeadd:-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Unionfind{\\n    int distinctcomp;\\n    vector<int> component;\\n    public:\\n    Unionfind(int n)\\n    {\\n        distinctcomp=n;\\n        for(int i=0;i<=n;i++)\\n            component.push_back(i);\\n    }\\n    int findcomponent(int a)\\n    {\\n        if(component[a]!=a)\\n            component[a]=findcomponent(component[a]);\\n        return component[a];\\n    }\\n    bool unite(int a,int b)\\n    {\\n        if(findcomponent(a)==findcomponent(b))\\n            return false;\\n        component[findcomponent(a)]=b;\\n        distinctcomp--;\\n        return true;\\n    }\\n    bool united()\\n    {\\n        return distinctcomp==1;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int edgeadd=0;\\n        Unionfind bob(n),alice(n);\\n        sort(edges.begin(),edges.end(),[](vector<int> &a,vector<int> &b){return a[0]>b[0];});\\n        for(auto &edge:edges)\\n        {\\n            int a1=edge[0],a2=edge[1],a3=edge[2];\\n            switch(a1)\\n            {\\n                case 3:\\n                    edgeadd+=bob.unite(a2,a3)|alice.unite(a2,a3);\\n                    break;\\n                case 2:\\n                    edgeadd+=bob.unite(a2,a3);\\n                    break;\\n                case 1:\\n                    edgeadd+=alice.unite(a2,a3);\\n                    break;\\n            }\\n        }\\n        return (bob.united() && alice.united())?edges.size()-edgeadd:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839380,
                "title": "union-find-solution-98",
                "content": "try to use the shared path as much as possible\\n\\n1st round: union find all shared paths\\n2nd round: union find only on A/B owned paths (no shared ones)\\n\\nso confirm 2 things\\n\\n1. that eventually A/B can traverse to all pathes\\n2. that only count when there\\'s a redundant path (where union operation doesn\\'t necessary operated, where union() returns false..)\\n\\n```\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n\\n        if(n <=0) {\\n            return 0;\\n        }\\n\\n        UnionFind a = new UnionFind(n); // for alice\\n        UnionFind b = new UnionFind(n); // for bob\\n\\n        int totalCount = 0;\\n        // first round try to use all nodes that is shared path\\n        for(int i=0;i<edges.length;i++) {\\n            if(edges[i][0] == 3) {\\n                if(!a.union(edges[i][1], edges[i][2])) {\\n                    totalCount++; // did a union find\\n                }\\n                // avoid duplicate count, but still union-find on bob\\'s\\n                b.union(edges[i][1], edges[i][2]);\\n            }\\n        }\\n\\n\\n        // 2nd round, use specific routes for each collection\\n        for(int i=0;i<edges.length;i++) {\\n            if(edges[i][0] == 3) {\\n                continue;\\n            }\\n            if(edges[i][0] == 1) {\\n                // alice\\n                if(!a.union(edges[i][1], edges[i][2])) {\\n                    totalCount++;\\n                }\\n            } else {\\n                if(!b.union(edges[i][1], edges[i][2])) {\\n                    totalCount++;\\n                }\\n            }\\n        }\\n\\n        // if cannot traverse to all nodes\\n        if (a.count != 1 || b.count != 1) {\\n            return -1;\\n        }\\n        \\n        return totalCount;\\n\\n    }\\n\\n    class UnionFind {\\n\\n        int[] parent;\\n        int count; // count the # of different parents\\n        /**\\n         *\\n         */\\n        UnionFind(int size) {\\n            parent = new int[size+1];\\n            for(int i=0;i<parent.length;i++) {\\n                parent[i] = i;\\n            }\\n            count = size;\\n        }\\n\\n        int find(int node) {\\n            int origin = node;\\n            while(node != parent[node]) {\\n                node = parent[node];\\n            }\\n            return parent[origin] = node;\\n        }\\n\\n        /**\\n         * returns true when a union operation is done\\n         * @param a\\n         * @param b\\n         * @return\\n         */\\n        boolean union(int a, int b) {\\n            int pA = find(a);\\n            int pB = find(b);\\n\\n            if(pA == pB) {\\n                return false;\\n            } else {\\n                parent[pB] = pA; // set pA to be the parent of pB\\n                count--;\\n                return true;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n\\n        if(n <=0) {\\n            return 0;\\n        }\\n\\n        UnionFind a = new UnionFind(n); // for alice\\n        UnionFind b = new UnionFind(n); // for bob\\n\\n        int totalCount = 0;\\n        // first round try to use all nodes that is shared path\\n        for(int i=0;i<edges.length;i++) {\\n            if(edges[i][0] == 3) {\\n                if(!a.union(edges[i][1], edges[i][2])) {\\n                    totalCount++; // did a union find\\n                }\\n                // avoid duplicate count, but still union-find on bob\\'s\\n                b.union(edges[i][1], edges[i][2]);\\n            }\\n        }\\n\\n\\n        // 2nd round, use specific routes for each collection\\n        for(int i=0;i<edges.length;i++) {\\n            if(edges[i][0] == 3) {\\n                continue;\\n            }\\n            if(edges[i][0] == 1) {\\n                // alice\\n                if(!a.union(edges[i][1], edges[i][2])) {\\n                    totalCount++;\\n                }\\n            } else {\\n                if(!b.union(edges[i][1], edges[i][2])) {\\n                    totalCount++;\\n                }\\n            }\\n        }\\n\\n        // if cannot traverse to all nodes\\n        if (a.count != 1 || b.count != 1) {\\n            return -1;\\n        }\\n        \\n        return totalCount;\\n\\n    }\\n\\n    class UnionFind {\\n\\n        int[] parent;\\n        int count; // count the # of different parents\\n        /**\\n         *\\n         */\\n        UnionFind(int size) {\\n            parent = new int[size+1];\\n            for(int i=0;i<parent.length;i++) {\\n                parent[i] = i;\\n            }\\n            count = size;\\n        }\\n\\n        int find(int node) {\\n            int origin = node;\\n            while(node != parent[node]) {\\n                node = parent[node];\\n            }\\n            return parent[origin] = node;\\n        }\\n\\n        /**\\n         * returns true when a union operation is done\\n         * @param a\\n         * @param b\\n         * @return\\n         */\\n        boolean union(int a, int b) {\\n            int pA = find(a);\\n            int pB = find(b);\\n\\n            if(pA == pB) {\\n                return false;\\n            } else {\\n                parent[pB] = pA; // set pA to be the parent of pB\\n                count--;\\n                return true;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839333,
                "title": "straightforward-java-solution-union-find-two-passes",
                "content": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int ans = 0;\\n        int[] ufAlice = new int[n + 1]; // first element is used for store # of edges\\n        for (int i = 1; i <= n; i++) {\\n            ufAlice[i] = i;\\n        }\\n        for (int[] edge : edges) {\\n            if (edge[0] == 3) {\\n                ans += union(ufAlice, edge[1], edge[2]);\\n            }\\n        }\\n        int[] ufBob = ufAlice.clone();\\n        for (int[] edge : edges) {\\n            if (edge[0] == 1) {\\n                ans += union(ufAlice, edge[1], edge[2]);\\n            } else if (edge[0] == 2) {\\n                ans += union(ufBob, edge[1], edge[2]);\\n            }\\n        }\\n        return ufAlice[0] == n - 1 && ufBob[0] == n - 1 ? ans : -1;\\n    }\\n    \\n    public int union(int[] uf, int a, int b) {\\n        int pa = find(uf, a);\\n        int pb = find(uf, b);\\n        if (pa == pb) {\\n            return 1; // return 1 because we found the edge between a and b can be removed\\n        }\\n        uf[pa] = pb;\\n        uf[0]++; // we found the edge between a and b is necessary\\n        return 0;\\n    }\\n    \\n    public int find(int[] uf, int a) {\\n        if (uf[a] == a) {\\n            return a;\\n        }\\n        return uf[a] = find(uf, uf[a]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int ans = 0;\\n        int[] ufAlice = new int[n + 1]; // first element is used for store # of edges\\n        for (int i = 1; i <= n; i++) {\\n            ufAlice[i] = i;\\n        }\\n        for (int[] edge : edges) {\\n            if (edge[0] == 3) {\\n                ans += union(ufAlice, edge[1], edge[2]);\\n            }\\n        }\\n        int[] ufBob = ufAlice.clone();\\n        for (int[] edge : edges) {\\n            if (edge[0] == 1) {\\n                ans += union(ufAlice, edge[1], edge[2]);\\n            } else if (edge[0] == 2) {\\n                ans += union(ufBob, edge[1], edge[2]);\\n            }\\n        }\\n        return ufAlice[0] == n - 1 && ufBob[0] == n - 1 ? ans : -1;\\n    }\\n    \\n    public int union(int[] uf, int a, int b) {\\n        int pa = find(uf, a);\\n        int pb = find(uf, b);\\n        if (pa == pb) {\\n            return 1; // return 1 because we found the edge between a and b can be removed\\n        }\\n        uf[pa] = pb;\\n        uf[0]++; // we found the edge between a and b is necessary\\n        return 0;\\n    }\\n    \\n    public int find(int[] uf, int a) {\\n        if (uf[a] == a) {\\n            return a;\\n        }\\n        return uf[a] = find(uf, uf[a]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834756,
                "title": "java-union-find-beats-100-submissions-with-16ms-runtime",
                "content": "Once understood the Union Find DS, this hard leetcode question becomes much easier. This solution also implements two optimisations of Union Find, namely, union by rank and path compression to make the program a lot faster to run. The configuration of Union Find DS shown in this solution is very universal and could be used as a model template applied to other problems. \\n```\\npublic int maxNumEdgesToRemove2(int n, int[][] edges){\\n        UF uf1 = new UF(n);\\n        UF uf2 = new UF(n);\\n        int m = edges.length;\\n        int max = 0;\\n\\t\\t// first loop only grab the type3 edges because it is shared by Bob and Alice\\n        for (int i = 0; i < m; i++) {\\n            int type = edges[i][0];\\n            int a = edges[i][1] - 1;\\n            int b = edges[i][2] - 1;\\n            if ((type == 3) && (uf2.find(a) != uf2.find(b) || uf1.find(a) != uf1.find(b))){\\n                if (uf2.find(a) != uf2.find(b))\\n                    uf2.union(a,b);\\n                if (uf1.find(a) != uf1.find(b))\\n                    uf1.union(a,b);\\n            }else if (type == 3){\\n                max++;\\n            }\\n        }\\n\\t\\t// second loop grab Alice\\'s edges and Bob\\'s edges and put into their UFs separately\\n        for (int i = 0; i < m; i++) {\\n            int type = edges[i][0];\\n            int a = edges[i][1] - 1;\\n            int b = edges[i][2] - 1;\\n            if ((type == 1) && uf1.find(a) != uf1.find(b)){\\n                uf1.union(a,b);\\n            }else if (type == 1){\\n                max++;\\n            }\\n            if ((type == 2) && uf2.find(a) != uf2.find(b)){\\n                uf2.union(a,b);\\n            }else if (type == 2){\\n                max++;\\n            }\\n\\n        }\\n\\t\\t// if any node is still not in the union we return -1\\n        for (int i = 1; i < n; i++) {\\n            if (uf1.find(i - 1) != uf1.find(i))\\n                return -1;\\n            if (uf2.find(i - 1) != uf2.find(i))\\n                return -1;\\n        }\\n        return max;\\n    }\\n```\\nAnd now the data structure part\\n```\\npublic class UF {\\n\\n    int[] parent;\\n    int[] rank;\\n\\n    UF(int n) {\\n        this.parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        this.rank = new int[n];\\n    }\\n\\n    public int find(int a) {\\n        // path compression, it updates all a\\'s ancestors as well\\n        if (a != parent[a])\\n            parent[a] = find(parent[a]);\\n        return parent[a];\\n    }\\n\\n    public void union(int a, int b) {\\n        // union by rank\\n        int parentA = find(a);\\n        int parentB = find(b);\\n\\t\\t// if a and b have the same parent that means they are already in the same union\\n        if (parentA == parentB)\\n            return;\\n        if (rank[parentA] > rank[parentB]) {\\n\\t\\t// set a lower rank node as the root node of a higher rank node\\n            parent[parentB] = parentA;\\n            rank[parentB]++;\\n        } else {\\n            parent[parentA] = parentB;\\n            rank[parentA]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxNumEdgesToRemove2(int n, int[][] edges){\\n        UF uf1 = new UF(n);\\n        UF uf2 = new UF(n);\\n        int m = edges.length;\\n        int max = 0;\\n\\t\\t// first loop only grab the type3 edges because it is shared by Bob and Alice\\n        for (int i = 0; i < m; i++) {\\n            int type = edges[i][0];\\n            int a = edges[i][1] - 1;\\n            int b = edges[i][2] - 1;\\n            if ((type == 3) && (uf2.find(a) != uf2.find(b) || uf1.find(a) != uf1.find(b))){\\n                if (uf2.find(a) != uf2.find(b))\\n                    uf2.union(a,b);\\n                if (uf1.find(a) != uf1.find(b))\\n                    uf1.union(a,b);\\n            }else if (type == 3){\\n                max++;\\n            }\\n        }\\n\\t\\t// second loop grab Alice\\'s edges and Bob\\'s edges and put into their UFs separately\\n        for (int i = 0; i < m; i++) {\\n            int type = edges[i][0];\\n            int a = edges[i][1] - 1;\\n            int b = edges[i][2] - 1;\\n            if ((type == 1) && uf1.find(a) != uf1.find(b)){\\n                uf1.union(a,b);\\n            }else if (type == 1){\\n                max++;\\n            }\\n            if ((type == 2) && uf2.find(a) != uf2.find(b)){\\n                uf2.union(a,b);\\n            }else if (type == 2){\\n                max++;\\n            }\\n\\n        }\\n\\t\\t// if any node is still not in the union we return -1\\n        for (int i = 1; i < n; i++) {\\n            if (uf1.find(i - 1) != uf1.find(i))\\n                return -1;\\n            if (uf2.find(i - 1) != uf2.find(i))\\n                return -1;\\n        }\\n        return max;\\n    }\\n```\n```\\npublic class UF {\\n\\n    int[] parent;\\n    int[] rank;\\n\\n    UF(int n) {\\n        this.parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        this.rank = new int[n];\\n    }\\n\\n    public int find(int a) {\\n        // path compression, it updates all a\\'s ancestors as well\\n        if (a != parent[a])\\n            parent[a] = find(parent[a]);\\n        return parent[a];\\n    }\\n\\n    public void union(int a, int b) {\\n        // union by rank\\n        int parentA = find(a);\\n        int parentB = find(b);\\n\\t\\t// if a and b have the same parent that means they are already in the same union\\n        if (parentA == parentB)\\n            return;\\n        if (rank[parentA] > rank[parentB]) {\\n\\t\\t// set a lower rank node as the root node of a higher rank node\\n            parent[parentB] = parentA;\\n            rank[parentB]++;\\n        } else {\\n            parent[parentA] = parentB;\\n            rank[parentA]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833957,
                "title": "java-union-find-solution-3-times",
                "content": "```\\nclass Solution {\\n    int n;\\n    int[][] edges;\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        this.n = n;\\n        this.edges = edges;\\n        \\n        int[] root = new int[n + 1];\\n        int[] size = new int[n + 1];\\n        Arrays.fill(size, 1);\\n        \\n        int extra = union(root, size, 3, 0);\\n        int common = check(size);\\n        \\n        int[] root1 = root.clone();\\n        int[] size1 = size.clone();\\n        int res1 = union(root1, size1, 1, common);\\n        if (res1 == -1) return -1;\\n        \\n        int[] root2 = root.clone();\\n        int[] size2 = size.clone();\\n        int res2 = union(root2, size2, 2, common);\\n        if (res2 == -1) return -1;\\n        return res1 + res2 + extra;\\n        \\n    }\\n    \\n    private int union(int[] root, int[] size, int id, int max) {\\n        int res = 0;\\n        int count = 0;\\n        for (int[] edge : edges) {\\n            if (edge[0] != id) continue;\\n            int r1 = findRoot(edge[1], root);\\n            int r2 = findRoot(edge[2], root);\\n            \\n            if (r1 != r2) {\\n                int big = r1;\\n                int sml = r2;\\n                if (size[r2] > size[r1]) {\\n                    big = r2;\\n                    sml = r1;\\n                }\\n                \\n                root[sml] = big;\\n                size[big] += size[sml];\\n                size[sml] = 0;\\n                \\n                max = Math.max(max, size[big]);\\n            } else res++; // if (r1 == r2) means this edge could be canceled. \\n        }\\n        // only for Alice or Bob, if (size of max union != n), return -1;  \\n        if (id != 3 && max != n) return -1;\\n        return res;\\n    }\\n    \\n    // check how many nodes of type3\\n    private int check(int[] size) {\\n        int common = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (size[i] > 1) common += size[i];\\n        }\\n        return common;\\n    }\\n    \\n    private int findRoot(int i, int[] root) {\\n        if (root[i] == 0) {\\n            root[i] = i;\\n            return i;\\n        }\\n        \\n        while (root[i] != i) {\\n            i = root[i];\\n            root[i] = root[root[i]];\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    int[][] edges;\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        this.n = n;\\n        this.edges = edges;\\n        \\n        int[] root = new int[n + 1];\\n        int[] size = new int[n + 1];\\n        Arrays.fill(size, 1);\\n        \\n        int extra = union(root, size, 3, 0);\\n        int common = check(size);\\n        \\n        int[] root1 = root.clone();\\n        int[] size1 = size.clone();\\n        int res1 = union(root1, size1, 1, common);\\n        if (res1 == -1) return -1;\\n        \\n        int[] root2 = root.clone();\\n        int[] size2 = size.clone();\\n        int res2 = union(root2, size2, 2, common);\\n        if (res2 == -1) return -1;\\n        return res1 + res2 + extra;\\n        \\n    }\\n    \\n    private int union(int[] root, int[] size, int id, int max) {\\n        int res = 0;\\n        int count = 0;\\n        for (int[] edge : edges) {\\n            if (edge[0] != id) continue;\\n            int r1 = findRoot(edge[1], root);\\n            int r2 = findRoot(edge[2], root);\\n            \\n            if (r1 != r2) {\\n                int big = r1;\\n                int sml = r2;\\n                if (size[r2] > size[r1]) {\\n                    big = r2;\\n                    sml = r1;\\n                }\\n                \\n                root[sml] = big;\\n                size[big] += size[sml];\\n                size[sml] = 0;\\n                \\n                max = Math.max(max, size[big]);\\n            } else res++; // if (r1 == r2) means this edge could be canceled. \\n        }\\n        // only for Alice or Bob, if (size of max union != n), return -1;  \\n        if (id != 3 && max != n) return -1;\\n        return res;\\n    }\\n    \\n    // check how many nodes of type3\\n    private int check(int[] size) {\\n        int common = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (size[i] > 1) common += size[i];\\n        }\\n        return common;\\n    }\\n    \\n    private int findRoot(int i, int[] root) {\\n        if (root[i] == 0) {\\n            root[i] = i;\\n            return i;\\n        }\\n        \\n        while (root[i] != i) {\\n            i = root[i];\\n            root[i] = root[root[i]];\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833062,
                "title": "java-union-find-clean-code",
                "content": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int[] graph1 = new int[n + 1];\\n        int[] graph2 = new int[n + 1];\\n        int maxCount = 0, edge1 = 0, edge2 = 0;    \\n\\t\\t// initialize the arrays of graphs\\n        for (int i = 1; i <= n; i++) {\\n            graph1[i] = i;\\n            graph2[i] = i;\\n        }\\n\\t\\t// use type3 edges to construct the two graphs first\\n\\t\\t// this can help avoid counting removable edges repeatedly\\n        for (int[] edge : edges) {\\n            if (edge[0] == 3) {\\n                if (isConnected(graph1, edge[1], edge[2])) {\\n                    maxCount++;\\n                } else {\\n                    union(graph1, edge[1], edge[2]);\\n                    union(graph2, edge[1], edge[2]);\\n                    edge1++;\\n                    edge2++;\\n                }\\n            }\\n        }\\n\\t\\t// use tpye1 or type2 edges to construct two graphs separately\\n        for (int[] edge : edges) {\\n            if (edge[0] == 1) {\\n                if (isConnected(graph1, edge[1], edge[2])) {\\n                    maxCount++;\\n                } else {\\n                    union(graph1, edge[1], edge[2]);\\n                    edge1++;\\n                }\\n            } else if (edge[0] == 2) {\\n                if (isConnected(graph2, edge[1], edge[2])) {\\n                    maxCount++;\\n                } else {\\n                    union(graph2, edge[1], edge[2]);\\n                    edge2++;\\n                }\\n            }\\n        }\\n\\t\\t// if either graph is disconnected, return -1\\n        if ((edge1 != n - 1) || (edge2 != n -1)) {\\n            return -1;\\n        }\\n        return maxCount;\\n    }\\n    \\n    public boolean isConnected(int[] graph, int u, int v) {\\n        return find(graph, u) == find(graph, v);\\n    }\\n    \\n    public void union(int[] graph, int u, int v) {\\n        int parentU = find(graph, u);\\n        int parentV = find(graph, v);\\n        graph[parentU] = parentV;\\n    }\\n    // find root with path compression\\n    public int find(int[] graph, int u) {\\n        if (graph[u] != u) {\\n            graph[u] = find(graph, graph[u]);\\n        }\\n        return graph[u];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int[] graph1 = new int[n + 1];\\n        int[] graph2 = new int[n + 1];\\n        int maxCount = 0, edge1 = 0, edge2 = 0;    \\n\\t\\t// initialize the arrays of graphs\\n        for (int i = 1; i <= n; i++) {\\n            graph1[i] = i;\\n            graph2[i] = i;\\n        }\\n\\t\\t// use type3 edges to construct the two graphs first\\n\\t\\t// this can help avoid counting removable edges repeatedly\\n        for (int[] edge : edges) {\\n            if (edge[0] == 3) {\\n                if (isConnected(graph1, edge[1], edge[2])) {\\n                    maxCount++;\\n                } else {\\n                    union(graph1, edge[1], edge[2]);\\n                    union(graph2, edge[1], edge[2]);\\n                    edge1++;\\n                    edge2++;\\n                }\\n            }\\n        }\\n\\t\\t// use tpye1 or type2 edges to construct two graphs separately\\n        for (int[] edge : edges) {\\n            if (edge[0] == 1) {\\n                if (isConnected(graph1, edge[1], edge[2])) {\\n                    maxCount++;\\n                } else {\\n                    union(graph1, edge[1], edge[2]);\\n                    edge1++;\\n                }\\n            } else if (edge[0] == 2) {\\n                if (isConnected(graph2, edge[1], edge[2])) {\\n                    maxCount++;\\n                } else {\\n                    union(graph2, edge[1], edge[2]);\\n                    edge2++;\\n                }\\n            }\\n        }\\n\\t\\t// if either graph is disconnected, return -1\\n        if ((edge1 != n - 1) || (edge2 != n -1)) {\\n            return -1;\\n        }\\n        return maxCount;\\n    }\\n    \\n    public boolean isConnected(int[] graph, int u, int v) {\\n        return find(graph, u) == find(graph, v);\\n    }\\n    \\n    public void union(int[] graph, int u, int v) {\\n        int parentU = find(graph, u);\\n        int parentV = find(graph, v);\\n        graph[parentU] = parentV;\\n    }\\n    // find root with path compression\\n    public int find(int[] graph, int u) {\\n        if (graph[u] != u) {\\n            graph[u] = find(graph, graph[u]);\\n        }\\n        return graph[u];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832533,
                "title": "python-search-of-connected-components",
                "content": "The algorithm uses subfunction of the number of connected components within a graph.\\n\\nIf the number of connected components for Alice (types 1 and 3) or Bob (types 2 and 3) is more than one, then return -1: in that case, Alice or Bob cannot traverse even without deletions.\\n\\nFor a connected graph (number of connected components is 1), Alice/Bob needs n-1 edges to traverse. They share type-3 edges. Thus, we need to find the number of type-3 edges that can be deleted while keeping the number of connected type-3 components the same. The number of type-3 edges that are needed to preserve the number of connected type-3 components is *n-(number of type-3 connected components)*. \\n\\nOnce we know the number *m* of edges that Alice/Bob can share (this is the number of edges to preserve the number of type-3 components), the number of edges that we can delete for Alice/Bob still being able to traverse the graph is the total number of edges minus (2(n-1)-m).\\n\\nThe main procedure, if the graph is coded and if the function of calculating the number of components *FindNumberComponents* is given:\\n\\n```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n\\t     \\n\\t\\t# This is the main algorithm. Calculate the number of edges that we can drop\\n\\t\\t# If the graph is not connected either for Alice or Bob - return -1\\n        if FindNumberComponents(1)>1 or FindNumberComponents(2)>1: return -1\\n        \\n\\t\\t# Calculate min number of edges to maintain type-3 connected components that both Alice and Bob can traverse\\n        edges_type_3=n-FindNumberComponents(3)\\n\\t\\t# The answer is the number of Alice/Bob need minus the edges that they can share\\n        return len(edges)-((n-1)*2-edges_type_3)\\n```\\n\\nThe full program:\\n\\n```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n\\t\\t# This is the standard algorithm for finding the number of connected components in a graph\\n \\xA0 \\xA0 \\xA0 \\xA0def FindNumberComponents(gr_num=3):\\n            \\n            remaining={i for i in range(1, n+1)}\\n            NumComponents=0\\n\\n            while remaining:\\n                NumComponents += 1\\n                traverse=[remaining.pop()]\\n                while traverse and remaining:\\n                    node=traverse.pop()\\n                    for node_add in Gr[3][node] | Gr[gr_num][node]:\\n                        if node_add in remaining:\\n                            remaining.remove(node_add)\\n                            traverse.append(node_add)\\n\\n            return NumComponents\\n\\n        # Code the graph\\n        Gr={gr_num:{i:set() for i in range(1, n+1)} for gr_num in range(1,4)}\\n        for edge in edges:\\n            Gr[edge[0]][edge[1]].add(edge[2])\\n            Gr[edge[0]][edge[2]].add(edge[1])\\n        \\n\\t\\t# This is the main algorithm. Calculate the number of edges that we can drop\\n\\t\\t# If the graph is not connected either for Alice or Bob - return -1\\n        if FindNumberComponents(1)>1 or FindNumberComponents(2)>1: return -1\\n        \\n\\t\\t# Calculate min number of edges to maintain type-3 connected components that both Alice and Bob can traverse\\n        edges_type_3=n-FindNumberComponents(3)\\n\\t\\t# The answer is the number of Alice/Bob need minus the edges that they can share\\n        return len(edges)-((n-1)*2-edges_type_3)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n\\t     \\n\\t\\t# This is the main algorithm. Calculate the number of edges that we can drop\\n\\t\\t# If the graph is not connected either for Alice or Bob - return -1\\n        if FindNumberComponents(1)>1 or FindNumberComponents(2)>1: return -1\\n        \\n\\t\\t# Calculate min number of edges to maintain type-3 connected components that both Alice and Bob can traverse\\n        edges_type_3=n-FindNumberComponents(3)\\n\\t\\t# The answer is the number of Alice/Bob need minus the edges that they can share\\n        return len(edges)-((n-1)*2-edges_type_3)\\n```\n```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n\\t\\t# This is the standard algorithm for finding the number of connected components in a graph\\n \\xA0 \\xA0 \\xA0 \\xA0def FindNumberComponents(gr_num=3):\\n            \\n            remaining={i for i in range(1, n+1)}\\n            NumComponents=0\\n\\n            while remaining:\\n                NumComponents += 1\\n                traverse=[remaining.pop()]\\n                while traverse and remaining:\\n                    node=traverse.pop()\\n                    for node_add in Gr[3][node] | Gr[gr_num][node]:\\n                        if node_add in remaining:\\n                            remaining.remove(node_add)\\n                            traverse.append(node_add)\\n\\n            return NumComponents\\n\\n        # Code the graph\\n        Gr={gr_num:{i:set() for i in range(1, n+1)} for gr_num in range(1,4)}\\n        for edge in edges:\\n            Gr[edge[0]][edge[1]].add(edge[2])\\n            Gr[edge[0]][edge[2]].add(edge[1])\\n        \\n\\t\\t# This is the main algorithm. Calculate the number of edges that we can drop\\n\\t\\t# If the graph is not connected either for Alice or Bob - return -1\\n        if FindNumberComponents(1)>1 or FindNumberComponents(2)>1: return -1\\n        \\n\\t\\t# Calculate min number of edges to maintain type-3 connected components that both Alice and Bob can traverse\\n        edges_type_3=n-FindNumberComponents(3)\\n\\t\\t# The answer is the number of Alice/Bob need minus the edges that they can share\\n        return len(edges)-((n-1)*2-edges_type_3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831796,
                "title": "union-find-o-nlog-n",
                "content": "Select type 3 edges first, then do the same for type 1 and type 2 edges.\\n\\n```\\n    int find(int a, int f[]) {\\n        if (f[a] == a)\\n            return a;\\n        f[a] = find(f[a], f);\\n        return f[a];\\n    }\\n    void merge(int a, int b, int f[]) {\\n        int x = find(a, f), y = find(b, f);\\n        if (x != y) {\\n            f[x] = y;\\n            f[0]--;\\n        }\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int count = 0;\\n        int f[100001], h[100001];\\n        f[0] = h[0] = n;\\n        for(int i = 1; i <= n; i++)\\n            f[i] = h[i] = i;\\n\\n        for(int i = 0; i < edges.size(); i++) {\\n            if (edges[i][0] == 3 && find(edges[i][1], f) != find(edges[i][2], f)) {\\n                merge(edges[i][1], edges[i][2], f);\\n                merge(edges[i][1], edges[i][2], h);\\n                count++;\\n            }\\n        }\\n        for(int i = 0; i < edges.size(); i++) {\\n            if (edges[i][0] == 1 && find(edges[i][1], f) != find(edges[i][2], f)) {\\n                merge(edges[i][1], edges[i][2], f);\\n                count++;\\n            } \\n        }\\n        for(int i = 0; i < edges.size(); i++) {\\n            if (edges[i][0] == 2 && find(edges[i][1], h) != find(edges[i][2], h)) {\\n                merge(edges[i][1], edges[i][2], h);\\n                count++;\\n            }               \\n        }\\n        \\n        if (f[0] > 1 || h[0] > 1)\\n            return -1;\\n        \\n        return edges.size() -count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int find(int a, int f[]) {\\n        if (f[a] == a)\\n            return a;\\n        f[a] = find(f[a], f);\\n        return f[a];\\n    }\\n    void merge(int a, int b, int f[]) {\\n        int x = find(a, f), y = find(b, f);\\n        if (x != y) {\\n            f[x] = y;\\n            f[0]--;\\n        }\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int count = 0;\\n        int f[100001], h[100001];\\n        f[0] = h[0] = n;\\n        for(int i = 1; i <= n; i++)\\n            f[i] = h[i] = i;\\n\\n        for(int i = 0; i < edges.size(); i++) {\\n            if (edges[i][0] == 3 && find(edges[i][1], f) != find(edges[i][2], f)) {\\n                merge(edges[i][1], edges[i][2], f);\\n                merge(edges[i][1], edges[i][2], h);\\n                count++;\\n            }\\n        }\\n        for(int i = 0; i < edges.size(); i++) {\\n            if (edges[i][0] == 1 && find(edges[i][1], f) != find(edges[i][2], f)) {\\n                merge(edges[i][1], edges[i][2], f);\\n                count++;\\n            } \\n        }\\n        for(int i = 0; i < edges.size(); i++) {\\n            if (edges[i][0] == 2 && find(edges[i][1], h) != find(edges[i][2], h)) {\\n                merge(edges[i][1], edges[i][2], h);\\n                count++;\\n            }               \\n        }\\n        \\n        if (f[0] > 1 || h[0] > 1)\\n            return -1;\\n        \\n        return edges.size() -count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831795,
                "title": "java-union-find",
                "content": "We use Union-find for each Alice and Bob.\\nIf an edge has both nodes belonging to same parent, we remove that edge and increment ans.\\n\\nWe will keep count of disconnected components n1 and n2. \\nIf either of n1 or n2 is greater than 1, we return -1.\\n\\n```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(b[0]-a[0]));\\n        for(int i=0;i<edges.length;i++){\\n            pq.offer(edges[i]);\\n        }\\n        int[] par1 = new int[n+1];\\n        int[] par2 = new int[n+1];\\n        int n1=n;\\n        int n2=n;\\n        int ans = 0;\\n        while(!pq.isEmpty()){\\n            int[] e = pq.poll();\\n            System.out.print(e[0]+\" \");\\n            if(e[0]==3){\\n                \\n                int p1 = getParent(par1,e[1]);\\n                int p2 = getParent(par1,e[2]);\\n                if(p1!=p2) n1--;\\n                par1[p1] = Math.min(p1,p2);\\n                par1[p2] = Math.min(p1,p2);\\n                \\n                int p21 = getParent(par2,e[1]);\\n                int p22 = getParent(par2,e[2]);\\n                if(p21!=p22) n2--;\\n                if(p21==p22 && p1==p2) ans++;\\n                par2[p21] = Math.min(p21,p22);\\n                par2[p22] = Math.min(p21,p22);\\n                \\n            }\\n            else if(e[0]==1){\\n                int p1 = getParent(par1,e[1]);\\n                int p2 = getParent(par1,e[2]);\\n            //    System.out.println(\"type1====\"+p1+p2);\\n                if(p1==p2) ans++;\\n                else{\\n                    n1--;\\n                    par1[p1] = Math.min(p1,p2);\\n                    par1[p2] = Math.min(p1,p2);\\n                }\\n            }\\n            else {\\n                int p1 = getParent(par2,e[1]);\\n                int p2 = getParent(par2,e[2]);\\n              //  System.out.println(\"type2====\"+p1+p2);\\n                if(p1==p2) ans++;\\n                else{\\n                    n2--;\\n                    par2[p1] = Math.min(p1,p2);\\n                    par2[p2] = Math.min(p1,p2);\\n                }\\n            }\\n        }\\n        if(n1>1 || n2>1) return -1;\\n        return ans+pq.size();\\n    }\\n    \\n    private int getParent(int[] parent, int x)\\n    {\\n        if(parent[x]==0 || parent[x]==x){\\n            parent[x]=x;\\n            return x;\\n        }\\n        \\n        return getParent(parent,parent[x]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(b[0]-a[0]));\\n        for(int i=0;i<edges.length;i++){\\n            pq.offer(edges[i]);\\n        }\\n        int[] par1 = new int[n+1];\\n        int[] par2 = new int[n+1];\\n        int n1=n;\\n        int n2=n;\\n        int ans = 0;\\n        while(!pq.isEmpty()){\\n            int[] e = pq.poll();\\n            System.out.print(e[0]+\" \");\\n            if(e[0]==3){\\n                \\n                int p1 = getParent(par1,e[1]);\\n                int p2 = getParent(par1,e[2]);\\n                if(p1!=p2) n1--;\\n                par1[p1] = Math.min(p1,p2);\\n                par1[p2] = Math.min(p1,p2);\\n                \\n                int p21 = getParent(par2,e[1]);\\n                int p22 = getParent(par2,e[2]);\\n                if(p21!=p22) n2--;\\n                if(p21==p22 && p1==p2) ans++;\\n                par2[p21] = Math.min(p21,p22);\\n                par2[p22] = Math.min(p21,p22);\\n                \\n            }\\n            else if(e[0]==1){\\n                int p1 = getParent(par1,e[1]);\\n                int p2 = getParent(par1,e[2]);\\n            //    System.out.println(\"type1====\"+p1+p2);\\n                if(p1==p2) ans++;\\n                else{\\n                    n1--;\\n                    par1[p1] = Math.min(p1,p2);\\n                    par1[p2] = Math.min(p1,p2);\\n                }\\n            }\\n            else {\\n                int p1 = getParent(par2,e[1]);\\n                int p2 = getParent(par2,e[2]);\\n              //  System.out.println(\"type2====\"+p1+p2);\\n                if(p1==p2) ans++;\\n                else{\\n                    n2--;\\n                    par2[p1] = Math.min(p1,p2);\\n                    par2[p2] = Math.min(p1,p2);\\n                }\\n            }\\n        }\\n        if(n1>1 || n2>1) return -1;\\n        return ans+pq.size();\\n    }\\n    \\n    private int getParent(int[] parent, int x)\\n    {\\n        if(parent[x]==0 || parent[x]==x){\\n            parent[x]=x;\\n            return x;\\n        }\\n        \\n        return getParent(parent,parent[x]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831765,
                "title": "java-simple-bfs-solution",
                "content": "The question can be rephrased as-\\n\"Given X edges, find number of edges that need to removed such that the traversal graphs of both A(Alice) and B(Bob) becomes a tree\"\\n\\nNow why tree?\\nA tree is a graph with minimum nodes such that every point is reachable from every other point.\\n\\nSo how do we do that?\\n1.  Classify the edges into 3 categories- exclusive A(type I), exclusive B(type II), both A & B(type III)\\n2.  First traverse the edges of type III and count number of edges required to visit all possible nodes\\n3.  If all nodes are visited, it means that type III graph is sufficient enough. Hence we can say ans=X-(n-1)\\n4.  If all nodes are not visited, we see that if we use type I combined with type III, A can visit all nodes. Similarly, we check that if we combine type II with type III, B can visit all nodes.\\n5.  If either of them has a node unreachable, ans=-1\\n6.  If not, we use a simple observation that the final graph is nothing but 2 trees merged with each other, whose edge count can be given by 2*[(n-1)-edges in type III]+edges in type III\\n7.  our final ans=X-the number of edges needed\\n\\nthe code for this approach is given below-\\n```\\nclass Solution \\n{\\n    public int maxNumEdgesToRemove(int n, int[][] edges) \\n    {\\n        ArrayList<Integer> g[]=new ArrayList[n],al[]=new ArrayList[n],bo[]=new ArrayList[n];\\n        int i,c=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            g[i]=new ArrayList<>();\\n            al[i]=new ArrayList<>();\\n            bo[i]=new ArrayList<>();\\n        }\\n        \\n        for(i=0;i<edges.length;i++)\\n        {\\n            int u=edges[i][1]-1,v=edges[i][2]-1;\\n            if(edges[i][0]==3)\\n            {\\n                g[u].add(v);\\n                g[v].add(u);\\n            }\\n            else if(edges[i][0]==1)\\n            {\\n                al[u].add(v);\\n                al[v].add(u);\\n            }\\n            else \\n            {\\n                bo[u].add(v);\\n                bo[v].add(u);\\n            }\\n        }\\n        \\n        boolean vis[]=new boolean[n],vis2[]=new boolean[n];\\n        for(i=0;i<n;i++)\\n        if(!vis[i] && g[i].size()!=0)\\n        c+=bfs(g,i,vis,0);\\n        \\n        if(count(vis)==n)   //all nodes visited \\n            return edges.length-(n-1);    \\n        \\n        for(i=0;i<n;i++)\\n        vis2[i]=vis[i];\\n        \\n        bfs(al,-1,vis,1);\\n        bfs(bo,-1,vis2,1);\\n        if(count(vis)!=n || count(vis2)!=n) return -1;\\n        //the number of edges needed=2*(no of edges in 1 tree-no of common edges)+no of common edges\\n        c=2*(n-1-c)+c;  \\n        \\n        return edges.length-c;\\n    }\\n    \\n    int bfs(ArrayList<Integer> g[],int n,boolean vis[],int t)\\n    {\\n        Queue<Integer> q=new LinkedList<>();\\n        int sz=0;   //count number of edges\\n        \\n        if(t==1)\\n        {\\n            for(int i=0;i<vis.length;i++)\\n            if(vis[i]) q.add(i); \\n            if(q.isEmpty()) //for cases when there are no edges og type 3 \\n            {\\n                q.add(0); \\n                vis[0]=true;\\n            }\\n        }\\n        else \\n        {\\n            vis[n]=true;\\n            q.add(n);\\n        }\\n        \\n        while(!q.isEmpty())\\n        {\\n            int p=q.poll();\\n            for(int x:g[p])\\n            if(!vis[x])\\n            {\\n                vis[x]=true;\\n                q.add(x);\\n                sz++;\\n            }\\n        }\\n        return sz;        \\n    }\\n    \\n    int count(boolean vis[])\\n    {\\n        int i,c=0,n=vis.length;\\n        for(i=0;i<n;i++)\\n        if(vis[i]) c++;\\n        return c;\\n    }\\n}\\n```\\n\\nCounter cases where this approach might fail and suggestions are welcome.",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maxNumEdgesToRemove(int n, int[][] edges) \\n    {\\n        ArrayList<Integer> g[]=new ArrayList[n],al[]=new ArrayList[n],bo[]=new ArrayList[n];\\n        int i,c=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            g[i]=new ArrayList<>();\\n            al[i]=new ArrayList<>();\\n            bo[i]=new ArrayList<>();\\n        }\\n        \\n        for(i=0;i<edges.length;i++)\\n        {\\n            int u=edges[i][1]-1,v=edges[i][2]-1;\\n            if(edges[i][0]==3)\\n            {\\n                g[u].add(v);\\n                g[v].add(u);\\n            }\\n            else if(edges[i][0]==1)\\n            {\\n                al[u].add(v);\\n                al[v].add(u);\\n            }\\n            else \\n            {\\n                bo[u].add(v);\\n                bo[v].add(u);\\n            }\\n        }\\n        \\n        boolean vis[]=new boolean[n],vis2[]=new boolean[n];\\n        for(i=0;i<n;i++)\\n        if(!vis[i] && g[i].size()!=0)\\n        c+=bfs(g,i,vis,0);\\n        \\n        if(count(vis)==n)   //all nodes visited \\n            return edges.length-(n-1);    \\n        \\n        for(i=0;i<n;i++)\\n        vis2[i]=vis[i];\\n        \\n        bfs(al,-1,vis,1);\\n        bfs(bo,-1,vis2,1);\\n        if(count(vis)!=n || count(vis2)!=n) return -1;\\n        //the number of edges needed=2*(no of edges in 1 tree-no of common edges)+no of common edges\\n        c=2*(n-1-c)+c;  \\n        \\n        return edges.length-c;\\n    }\\n    \\n    int bfs(ArrayList<Integer> g[],int n,boolean vis[],int t)\\n    {\\n        Queue<Integer> q=new LinkedList<>();\\n        int sz=0;   //count number of edges\\n        \\n        if(t==1)\\n        {\\n            for(int i=0;i<vis.length;i++)\\n            if(vis[i]) q.add(i); \\n            if(q.isEmpty()) //for cases when there are no edges og type 3 \\n            {\\n                q.add(0); \\n                vis[0]=true;\\n            }\\n        }\\n        else \\n        {\\n            vis[n]=true;\\n            q.add(n);\\n        }\\n        \\n        while(!q.isEmpty())\\n        {\\n            int p=q.poll();\\n            for(int x:g[p])\\n            if(!vis[x])\\n            {\\n                vis[x]=true;\\n                q.add(x);\\n                sz++;\\n            }\\n        }\\n        return sz;        \\n    }\\n    \\n    int count(boolean vis[])\\n    {\\n        int i,c=0,n=vis.length;\\n        for(i=0;i<n;i++)\\n        if(vis[i]) c++;\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831664,
                "title": "c-disjoint-set-tle-with-unordered-map-time-limit-too-strict",
                "content": "I did the disjoint set solution using an unordered_map<int, int> datastructure and got Time Limit Exceeded. I then switched to vector<int> and got accepted. Shouldn\\'t the unordered_map solution get accepted too? It\\'s the same O(n), even if slower.\\n\\nHere\\'s the code that got TLE\\n```\\nclass Solution {\\nprivate:\\n    int find(unordered_map<int, int> &roots, int node) {\\n        if (!roots.count(node)) {\\n            roots[node] = node;\\n        }\\n        if (roots[node] != node) roots[node] = find(roots, roots[node]);\\n        return roots[node];\\n    }\\n    int add_without_cycle(unordered_map<int, int> &roots, const vector<vector<int>> &edges) {\\n        int ans = 0;\\n        for (auto &edge: edges) {\\n            int start = edge[1], end = edge[2];\\n            int r1 = find(roots, start), r2 = find(roots, end);\\n            if (r1 == r2) continue;\\n            ans++;\\n            roots[r1] = r2;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, int> roots, roots2;\\n        int n_added = 0;\\n        vector<vector<vector<int>>> edges_by_type(3);\\n        for (auto &edge: edges) {\\n            edges_by_type[edge[0]-1].push_back(edge);\\n        }\\n        int size1 = add_without_cycle(roots, edges_by_type[2]);\\n        n_added += size1;\\n        roots2 = roots;\\n        int size2 = add_without_cycle(roots2, edges_by_type[0]);\\n        n_added += size2;\\n        if (size1 + size2 != n - 1) return -1;\\n        roots2 = roots;\\n        int size3 = add_without_cycle(roots2, edges_by_type[1]);   \\n        n_added += size3;\\n        if (size1 + size3 != n - 1) return -1;\\n        return edges.size() - n_added;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int find(unordered_map<int, int> &roots, int node) {\\n        if (!roots.count(node)) {\\n            roots[node] = node;\\n        }\\n        if (roots[node] != node) roots[node] = find(roots, roots[node]);\\n        return roots[node];\\n    }\\n    int add_without_cycle(unordered_map<int, int> &roots, const vector<vector<int>> &edges) {\\n        int ans = 0;\\n        for (auto &edge: edges) {\\n            int start = edge[1], end = edge[2];\\n            int r1 = find(roots, start), r2 = find(roots, end);\\n            if (r1 == r2) continue;\\n            ans++;\\n            roots[r1] = r2;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, int> roots, roots2;\\n        int n_added = 0;\\n        vector<vector<vector<int>>> edges_by_type(3);\\n        for (auto &edge: edges) {\\n            edges_by_type[edge[0]-1].push_back(edge);\\n        }\\n        int size1 = add_without_cycle(roots, edges_by_type[2]);\\n        n_added += size1;\\n        roots2 = roots;\\n        int size2 = add_without_cycle(roots2, edges_by_type[0]);\\n        n_added += size2;\\n        if (size1 + size2 != n - 1) return -1;\\n        roots2 = roots;\\n        int size3 = add_without_cycle(roots2, edges_by_type[1]);   \\n        n_added += size3;\\n        if (size1 + size3 != n - 1) return -1;\\n        return edges.size() - n_added;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831589,
                "title": "python3-union-find-solution-commented-code-easy-to-understand",
                "content": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n + 1))\\n        self.isolated_nodes = n\\n        \\n    def find(self, x):\\n        if x != self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    \\n    def union(self, x, y):\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        \\n        if xr != yr:\\n            self.isolated_nodes -= 1\\n            \\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        #keep two dsu for Bob and Alice\\n        #add edges to the dsu, if two nodes are already in a union, we can delete(ignore) the edge\\n        #always add type3 first\\n        edges.sort(reverse = True)\\n        \\n        dsuA = DSU(n)\\n        dsuB = DSU(n)\\n        res = 0\\n        for [t, n1, n2] in edges:\\n            if t == 3:\\n                if dsuA.find(n1) == dsuA.find(n2) and dsuB.find(n1) == dsuB.find(n2):\\n                    #don\\'t add the edge\\n                    res += 1\\n                else:\\n                    dsuA.union(n1, n2)\\n                    dsuB.union(n1, n2)\\n            elif t == 1:\\n                if dsuA.find(n1) == dsuA.find(n2):\\n                    res += 1\\n                else:\\n                    dsuA.union(n1, n2)\\n            else:\\n                if dsuB.find(n1) == dsuB.find(n2):\\n                    res += 1\\n                else:\\n                    dsuB.union(n1, n2)\\n                    \\n        return res if dsuA.isolated_nodes == 1 and dsuB.isolated_nodes == 1 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n + 1))\\n        self.isolated_nodes = n\\n        \\n    def find(self, x):\\n        if x != self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    \\n    def union(self, x, y):\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        \\n        if xr != yr:\\n            self.isolated_nodes -= 1\\n            \\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        #keep two dsu for Bob and Alice\\n        #add edges to the dsu, if two nodes are already in a union, we can delete(ignore) the edge\\n        #always add type3 first\\n        edges.sort(reverse = True)\\n        \\n        dsuA = DSU(n)\\n        dsuB = DSU(n)\\n        res = 0\\n        for [t, n1, n2] in edges:\\n            if t == 3:\\n                if dsuA.find(n1) == dsuA.find(n2) and dsuB.find(n1) == dsuB.find(n2):\\n                    #don\\'t add the edge\\n                    res += 1\\n                else:\\n                    dsuA.union(n1, n2)\\n                    dsuB.union(n1, n2)\\n            elif t == 1:\\n                if dsuA.find(n1) == dsuA.find(n2):\\n                    res += 1\\n                else:\\n                    dsuA.union(n1, n2)\\n            else:\\n                if dsuB.find(n1) == dsuB.find(n2):\\n                    res += 1\\n                else:\\n                    dsuB.union(n1, n2)\\n                    \\n        return res if dsuA.isolated_nodes == 1 and dsuB.isolated_nodes == 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831491,
                "title": "simple-solution-using-dsu-in-cpp",
                "content": "Data structure used : Dis joint set union.\\nAlgorithm used : Cycle in undirected graph using dis joint set data structure and check if a graph is connected using dis joint set data structure.\\nTime complexity : O(n)\\nSpace complexity : O(n)\\n\\nIn this problem we need to remove maximum number of edges so that our graph remains fully traversed by both Alice and Bob individually or tell that it is impossible to traverse graph completely.\\n\\nEdges are of three type here:\\n\\nType 1: Can be traversed by Alice only.\\nType 2: Can be traversed by Bob only.\\nType 3: Can by traversed by both Alice and Bob.\\n\\nWe can think greedly here that we should use maximum Type 3 edges, so that we can need to use less of Type 1 and Type 2 edges. So first we try to use Type 3 for both and then, Type 1 and Type 2 individually.\\n\\nWe will use the concept of cycle formation, we add an edge only when it is connecting two different components\\nof graph otherwise increase our counter variable (for count of edge deletion).\\n\\nAt the end we check for both Alice and Bob if graph is fully connected for them, this can be done easily by\\nfinding if all vertices have same parent in dis joint set structure.\\n\\nC++ implementation:\\n\\n```\\nint find_set(int parent[],int v)\\n{\\n    if(v == parent[v])\\n        return v;\\n    return parent[v] = find_set(parent,parent[v]);\\n}\\nvoid union_set(int parent[],int a,int b)\\n{\\n    a = find_set(parent,a);\\n    b = find_set(parent,b);\\n    if(a != b)\\n        parent[b] = a;\\n}\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int parent1[n+1];\\n        int parent2[n+1];\\n        for(int i=1;i<=n;i++)\\n            parent1[i] = parent2[i] = i;\\n        int ans = 0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(edges[i][0] == 3)\\n            {\\n                int t1 = find_set(parent1,edges[i][1]);\\n                int t2 = find_set(parent1,edges[i][2]);\\n                if(t1 != t2)\\n                {\\n                    union_set(parent1,edges[i][2],edges[i][1]);\\n                    union_set(parent2,edges[i][2],edges[i][1]);\\n                }\\n                else\\n                    ans++;\\n            }\\n        }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(edges[i][0] == 1)\\n            {\\n                int t1 = find_set(parent1,edges[i][1]);\\n                int t2 = find_set(parent1,edges[i][2]);\\n                if(t1 != t2)\\n                {\\n                    union_set(parent1,edges[i][2],edges[i][1]);\\n                }\\n                else\\n                    ans++;\\n            }\\n            else if(edges[i][0] == 2)\\n            {\\n                int t1 = find_set(parent2,edges[i][1]);\\n                int t2 = find_set(parent2,edges[i][2]);\\n                if(t1 != t2)\\n                {\\n                    union_set(parent2,edges[i][2],edges[i][1]);\\n                }\\n                else\\n                    ans++;\\n            }\\n        }\\n        int par1 = find_set(parent1,1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            int t = find_set(parent1,i);\\n            if(t != par1)\\n                return -1;\\n        }\\n        int par2 = find_set(parent2,1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            int t = find_set(parent2,i);\\n            if(t != par2)\\n                return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint find_set(int parent[],int v)\\n{\\n    if(v == parent[v])\\n        return v;\\n    return parent[v] = find_set(parent,parent[v]);\\n}\\nvoid union_set(int parent[],int a,int b)\\n{\\n    a = find_set(parent,a);\\n    b = find_set(parent,b);\\n    if(a != b)\\n        parent[b] = a;\\n}\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int parent1[n+1];\\n        int parent2[n+1];\\n        for(int i=1;i<=n;i++)\\n            parent1[i] = parent2[i] = i;\\n        int ans = 0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(edges[i][0] == 3)\\n            {\\n                int t1 = find_set(parent1,edges[i][1]);\\n                int t2 = find_set(parent1,edges[i][2]);\\n                if(t1 != t2)\\n                {\\n                    union_set(parent1,edges[i][2],edges[i][1]);\\n                    union_set(parent2,edges[i][2],edges[i][1]);\\n                }\\n                else\\n                    ans++;\\n            }\\n        }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(edges[i][0] == 1)\\n            {\\n                int t1 = find_set(parent1,edges[i][1]);\\n                int t2 = find_set(parent1,edges[i][2]);\\n                if(t1 != t2)\\n                {\\n                    union_set(parent1,edges[i][2],edges[i][1]);\\n                }\\n                else\\n                    ans++;\\n            }\\n            else if(edges[i][0] == 2)\\n            {\\n                int t1 = find_set(parent2,edges[i][1]);\\n                int t2 = find_set(parent2,edges[i][2]);\\n                if(t1 != t2)\\n                {\\n                    union_set(parent2,edges[i][2],edges[i][1]);\\n                }\\n                else\\n                    ans++;\\n            }\\n        }\\n        int par1 = find_set(parent1,1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            int t = find_set(parent1,i);\\n            if(t != par1)\\n                return -1;\\n        }\\n        int par2 = find_set(parent2,1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            int t = find_set(parent2,i);\\n            if(t != par2)\\n                return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831479,
                "title": "c-disjoint-union-o-n-added-comments-easy-to-understand",
                "content": "Main Observation:\\n\\t1. Basic Idea is to pick up essential edges that can form a connected component. \\n\\t2. The order in which you join the edges is tricky(ie: First join the double(type 3) edges, then the remaining type)\\n\\nLooking at the observations, choosing dsu made more sense to me for this problem.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    class _dsu {\\n        public: \\n            _dsu(int sz) {\\n                n = sz; cc = sz;\\n                p.resize(n);\\n                for (int i = 0; i<n; i++) p[i] = i;\\n            }\\n\\n            int getp(int u) {\\n                if (p[u] == u) return u;\\n                p[u] = getp(p[u]);\\n                return p[u];\\n            }\\n\\n            bool join (int u, int v) {\\n                int pu = getp(u);\\n                int pv = getp(v);\\n                if (pu == pv) return false;\\n                p[pv] = pu; cc--; \\n                return true;\\n            }\\n\\n            int getcc(){return cc;}\\n        int n, cc;\\n        vector<int> p;\\n        \\n    };\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<pair<int, int>> dedg;\\n        vector<vector<pair<int, int>>> edgs(2);\\n\\n\\t\\t// separating type 3 edges from other edges\\n        for (auto &edg: edges) {\\n            int t(edg.front()), u(edg[1]), v(edg.back());\\n            if (t == 3) dedg.push_back({u, v});\\n            else edgs[t-1].push_back({u, v});\\n        }\\n\\n\\t\\t// 2 dsu different edges(1 and 2)\\n        _dsu d1(n), d2(n);\\n\\n\\t\\t// Joining edges of type 3 first\\n        for (auto [u, v]: dedg) {\\n            if (!d1.join(u-1, v-1)) ans++;\\n            d2.join(u-1, v-1);\\n        }\\n\\n        for (auto [u, v] : edgs[0]) if (!d1.join(u-1, v-1)) ans++;\\n        for (auto [u, v]: edgs[1]) if (!d2.join(u-1, v-1)) ans++;\\n\\t\\n        if (d1.getcc() != 1 || d2.getcc() != 1) return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    class _dsu {\\n        public: \\n            _dsu(int sz) {\\n                n = sz; cc = sz;\\n                p.resize(n);\\n                for (int i = 0; i<n; i++) p[i] = i;\\n            }\\n\\n            int getp(int u) {\\n                if (p[u] == u) return u;\\n                p[u] = getp(p[u]);\\n                return p[u];\\n            }\\n\\n            bool join (int u, int v) {\\n                int pu = getp(u);\\n                int pv = getp(v);\\n                if (pu == pv) return false;\\n                p[pv] = pu; cc--; \\n                return true;\\n            }\\n\\n            int getcc(){return cc;}\\n        int n, cc;\\n        vector<int> p;\\n        \\n    };\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<pair<int, int>> dedg;\\n        vector<vector<pair<int, int>>> edgs(2);\\n\\n\\t\\t// separating type 3 edges from other edges\\n        for (auto &edg: edges) {\\n            int t(edg.front()), u(edg[1]), v(edg.back());\\n            if (t == 3) dedg.push_back({u, v});\\n            else edgs[t-1].push_back({u, v});\\n        }\\n\\n\\t\\t// 2 dsu different edges(1 and 2)\\n        _dsu d1(n), d2(n);\\n\\n\\t\\t// Joining edges of type 3 first\\n        for (auto [u, v]: dedg) {\\n            if (!d1.join(u-1, v-1)) ans++;\\n            d2.join(u-1, v-1);\\n        }\\n\\n        for (auto [u, v] : edgs[0]) if (!d1.join(u-1, v-1)) ans++;\\n        for (auto [u, v]: edgs[1]) if (!d2.join(u-1, v-1)) ans++;\\n\\t\\n        if (d1.getcc() != 1 || d2.getcc() != 1) return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831474,
                "title": "python-modified-kruskal-s-o-e-with-simple-explanation",
                "content": "Use Kruskal\\'s algorithm with 2 graphs.\\n\\n1. Add edges of *type 3* to both the graphs (implementation trick: do this on only 1 graph and copy the final state to the other graph).\\n2. Add edges of *type 1* to the first graph.\\n3. Add edges of *type 2* to the second graph.\\n4. If the maximum number connected components of both graphs is equal to the number of nodes `n`, return `len(edges) - edges_added`, otherwise return `-1`.\\n\\n```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:        \\n        parent_a = list(range(n + 1))\\n        size_a = [1] * (n + 1)\\n        edges_added = 0\\n        \\n        def find(parent, i): \\n            if parent[i] != i: \\n                parent[i] = find(parent, parent[i])\\n            return parent[i]\\n\\n        def union(parent, size, x, y): \\n            i, j = find(parent, x), find(parent, y)\\n            if i == j: return False\\n            if size[i] < size[j]: \\n                parent[i] = j\\n                size[j] += size[i]\\n            else: \\n                parent[j] = i \\n                size[i] += size[j]\\n            return True\\n        \\n        for t, u, v in edges:\\n            if t == 3 and union(parent_a, size_a, u, v):\\n                edges_added += 1\\n                \\n        parent_b, size_b = parent_a[:], size_a[:]        \\n        \\n        for t, u, v in edges:\\n            if t == 1 and union(parent_a, size_a, u, v):\\n                edges_added += 1\\n            elif t == 2 and union(parent_b, size_b, u, v):\\n                edges_added += 1\\n        \\n        return len(edges) - edges_added if max(size_a) == max(size_b) == n else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:        \\n        parent_a = list(range(n + 1))\\n        size_a = [1] * (n + 1)\\n        edges_added = 0\\n        \\n        def find(parent, i): \\n            if parent[i] != i: \\n                parent[i] = find(parent, parent[i])\\n            return parent[i]\\n\\n        def union(parent, size, x, y): \\n            i, j = find(parent, x), find(parent, y)\\n            if i == j: return False\\n            if size[i] < size[j]: \\n                parent[i] = j\\n                size[j] += size[i]\\n            else: \\n                parent[j] = i \\n                size[i] += size[j]\\n            return True\\n        \\n        for t, u, v in edges:\\n            if t == 3 and union(parent_a, size_a, u, v):\\n                edges_added += 1\\n                \\n        parent_b, size_b = parent_a[:], size_a[:]        \\n        \\n        for t, u, v in edges:\\n            if t == 1 and union(parent_a, size_a, u, v):\\n                edges_added += 1\\n            elif t == 2 and union(parent_b, size_b, u, v):\\n                edges_added += 1\\n        \\n        return len(edges) - edges_added if max(size_a) == max(size_b) == n else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087007,
                "title": "using-dfs",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fun(int i,vector<int>adj[],vector<int>&vis,int&res){\\n        res+=1;\\n        vis[i]=1;\\n        for(auto it:adj[i]){\\n            if(vis[it]==-1){\\n                fun(it,adj,vis,res);\\n            }\\n        }\\n\\n    }\\n\\n   \\n\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        vector<int>adj1[n+1];\\n        vector<int>adj2[n+1];\\n        set<pair<int,int>>st;\\n        for(auto it:edges){\\n            if(it[0]==3){\\n                adj[it[1]].push_back(it[2]);\\n                adj[it[2]].push_back(it[1]);\\n          }\\n           if(it[0]==1||it[0]==3){\\n                adj1[it[1]].push_back(it[2]);\\n                adj1[it[2]].push_back(it[1]);\\n          }\\n           if(it[0]==2||it[0]==3){\\n                adj2[it[1]].push_back(it[2]);\\n                adj2[it[2]].push_back(it[1]);\\n          }\\n        }\\n\\n\\n        vector<int>vis1(n+1,-1),vis2(n+1,-1);\\n\\n       \\n        int res1=0,res2=0;\\n        fun(1,adj1,vis1,res1);\\n        fun(1,adj2,vis2,res2);\\n\\n        cout<<res1<<\" \"<<res2<<\"  \";\\n\\n        if(res1!=n) return -1;\\n        if(res2!=n) return -1;\\n        \\n        vector<int>vis(n+1,-1);\\n         int cnt=0;\\n        int connected=0;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                int res=0;\\n                fun(i,adj,vis,res);\\n                connected+=1;\\n                cnt+=res-1;\\n            }\\n        }\\n          //cout<<connected<<\" \";\\n        \\n        cnt+=(2*(connected-1));\\n         int n1=edges.size();\\n        return n1-cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fun(int i,vector<int>adj[],vector<int>&vis,int&res){\\n        res+=1;\\n        vis[i]=1;\\n        for(auto it:adj[i]){\\n            if(vis[it]==-1){\\n                fun(it,adj,vis,res);\\n            }\\n        }\\n\\n    }\\n\\n   \\n\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        vector<int>adj1[n+1];\\n        vector<int>adj2[n+1];\\n        set<pair<int,int>>st;\\n        for(auto it:edges){\\n            if(it[0]==3){\\n                adj[it[1]].push_back(it[2]);\\n                adj[it[2]].push_back(it[1]);\\n          }\\n           if(it[0]==1||it[0]==3){\\n                adj1[it[1]].push_back(it[2]);\\n                adj1[it[2]].push_back(it[1]);\\n          }\\n           if(it[0]==2||it[0]==3){\\n                adj2[it[1]].push_back(it[2]);\\n                adj2[it[2]].push_back(it[1]);\\n          }\\n        }\\n\\n\\n        vector<int>vis1(n+1,-1),vis2(n+1,-1);\\n\\n       \\n        int res1=0,res2=0;\\n        fun(1,adj1,vis1,res1);\\n        fun(1,adj2,vis2,res2);\\n\\n        cout<<res1<<\" \"<<res2<<\"  \";\\n\\n        if(res1!=n) return -1;\\n        if(res2!=n) return -1;\\n        \\n        vector<int>vis(n+1,-1);\\n         int cnt=0;\\n        int connected=0;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                int res=0;\\n                fun(i,adj,vis,res);\\n                connected+=1;\\n                cnt+=res-1;\\n            }\\n        }\\n          //cout<<connected<<\" \";\\n        \\n        cnt+=(2*(connected-1));\\n         int n1=edges.size();\\n        return n1-cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4011304,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I realised that each alice and bob can be represented as a connected Union Find. I created a union find data structure to hold each information for alice and bob. The idea is to build each graph for alice and bob sepearately and only add edges to alice or bob if and only it is necessary. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI created a union find data structure earlier, and first sorted the edges according to types. giving more preference to edges that connects both alice and bob as this will be more optimal to consider first.\\n\\nThe union find has a unique capability of telling me if two items have already been connected. So for every edge, i check if they are already connected. If they are I will ignore the edge and if they aren\\'t I will add the edge. \\n\\nUnionFind\\'s findParent function was inefficient as it was O(n) in the worst case. So to compress the tree and employ some form of caching i introduced updating parents of every path taken to the found root node when looking for a parent.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    struct UnionFind{\\n        private:\\n        std::vector<int> ds;\\n\\n        int findParent(int n){\\n            int n1Parent = n;\\n            while(ds[n1Parent]!= n1Parent){\\n                n1Parent = ds[n1Parent];\\n            }\\n            // Now flatten the tree and set every path to n1Parrent\\n            // to compress it. This will cache the tree for next time\\n            // and prevent total search everytime \\n            int curr = n;\\n            while(ds[curr]!=curr){\\n                int temp = ds[curr];\\n                ds[curr] = n1Parent;\\n                curr = temp;\\n            }\\n            return n1Parent;\\n        }\\n        public:\\n        UnionFind(int n){\\n            ds.resize(n+1);\\n            std::iota(ds.begin(),ds.end(),0);\\n           \\n        }\\n        void addUnion(int n1, int n2){\\n            int n1Parent = findParent(n1);\\n            int n2Parent = findParent(n2);\\n            ds[n1Parent] = n2Parent;          \\n        }\\n        bool connected(int n1, int n2){\\n            return findParent(n1)==findParent(n2);\\n        }\\n        bool allConnected(){\\n            // In a connected union find, there should be only one root.\\n            bool foundRoot = false;\\n            for(int i = 1; i < ds.size(); i++){\\n                if(!foundRoot && ds[i]==i){\\n                    foundRoot = true;\\n                }else if(foundRoot && ds[i] ==i){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    };\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        std::sort(edges.begin(),edges.end(),[](vector<int>& a, vector<int>& b){\\n            return a[0] > b[0];\\n        });\\n        UnionFind alice(n);\\n        UnionFind bob(n);\\n        int ignoreEdge = 0;\\n        for(auto it = edges.begin(); it!=edges.end(); ++it){\\n            int v1 = (*it)[1];\\n            int v2 = (*it)[2];\\n            int type = (*it)[0];\\n            bool vertsConnectedAlice = alice.connected(v1,v2);\\n            bool vertsConnectedBob  = bob.connected(v1,v2);\\n            // Here we are checking if the vertices in this edge is already \\n            // connected by a previous addition. If it is, ignore, if it is not\\n            // dont ignore the edge and add the edge to corresponding \\n            if(type == 3){\\n                ignoreEdge+=(!vertsConnectedAlice || !vertsConnectedBob)?0:1;\\n                if(!vertsConnectedAlice){\\n                    alice.addUnion(v1,v2);\\n                }\\n                if(!vertsConnectedBob){\\n                    bob.addUnion(v1,v2);\\n                }\\n\\n\\n            }else if(type == 1){\\n                if(!vertsConnectedAlice){\\n                    alice.addUnion(v1,v2);\\n                }else{\\n                    ignoreEdge++;\\n                }\\n            }else if(type == 2){\\n                 if(!vertsConnectedBob){\\n                    bob.addUnion(v1,v2);\\n                }else{\\n                    ignoreEdge++;\\n                }\\n            }\\n        }\\n        if(alice.allConnected() && bob.allConnected()){\\n            return ignoreEdge;\\n        }else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    struct UnionFind{\\n        private:\\n        std::vector<int> ds;\\n\\n        int findParent(int n){\\n            int n1Parent = n;\\n            while(ds[n1Parent]!= n1Parent){\\n                n1Parent = ds[n1Parent];\\n            }\\n            // Now flatten the tree and set every path to n1Parrent\\n            // to compress it. This will cache the tree for next time\\n            // and prevent total search everytime \\n            int curr = n;\\n            while(ds[curr]!=curr){\\n                int temp = ds[curr];\\n                ds[curr] = n1Parent;\\n                curr = temp;\\n            }\\n            return n1Parent;\\n        }\\n        public:\\n        UnionFind(int n){\\n            ds.resize(n+1);\\n            std::iota(ds.begin(),ds.end(),0);\\n           \\n        }\\n        void addUnion(int n1, int n2){\\n            int n1Parent = findParent(n1);\\n            int n2Parent = findParent(n2);\\n            ds[n1Parent] = n2Parent;          \\n        }\\n        bool connected(int n1, int n2){\\n            return findParent(n1)==findParent(n2);\\n        }\\n        bool allConnected(){\\n            // In a connected union find, there should be only one root.\\n            bool foundRoot = false;\\n            for(int i = 1; i < ds.size(); i++){\\n                if(!foundRoot && ds[i]==i){\\n                    foundRoot = true;\\n                }else if(foundRoot && ds[i] ==i){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    };\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        std::sort(edges.begin(),edges.end(),[](vector<int>& a, vector<int>& b){\\n            return a[0] > b[0];\\n        });\\n        UnionFind alice(n);\\n        UnionFind bob(n);\\n        int ignoreEdge = 0;\\n        for(auto it = edges.begin(); it!=edges.end(); ++it){\\n            int v1 = (*it)[1];\\n            int v2 = (*it)[2];\\n            int type = (*it)[0];\\n            bool vertsConnectedAlice = alice.connected(v1,v2);\\n            bool vertsConnectedBob  = bob.connected(v1,v2);\\n            // Here we are checking if the vertices in this edge is already \\n            // connected by a previous addition. If it is, ignore, if it is not\\n            // dont ignore the edge and add the edge to corresponding \\n            if(type == 3){\\n                ignoreEdge+=(!vertsConnectedAlice || !vertsConnectedBob)?0:1;\\n                if(!vertsConnectedAlice){\\n                    alice.addUnion(v1,v2);\\n                }\\n                if(!vertsConnectedBob){\\n                    bob.addUnion(v1,v2);\\n                }\\n\\n\\n            }else if(type == 1){\\n                if(!vertsConnectedAlice){\\n                    alice.addUnion(v1,v2);\\n                }else{\\n                    ignoreEdge++;\\n                }\\n            }else if(type == 2){\\n                 if(!vertsConnectedBob){\\n                    bob.addUnion(v1,v2);\\n                }else{\\n                    ignoreEdge++;\\n                }\\n            }\\n        }\\n        if(alice.allConnected() && bob.allConnected()){\\n            return ignoreEdge;\\n        }else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011043,
                "title": "java-unionfind-greedy",
                "content": "# Intuition\\nSimple prioritized union find approach. Priority given to bidirectional edge, others treated as same priority.\\n\\n# Approach\\nCreate two union finds for alice and bob and keep unioning them by logic in case needed to union. If anyone lacks the edge, then greedily add it.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass UnionFind {\\n    int[] parents;\\n    int[] sizes;\\n    int numOfComponents;\\n\\n    public UnionFind(int n) {\\n        parents = new int[n];\\n        sizes = new int[n];\\n        numOfComponents = n;\\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n            sizes[i] = 0;\\n        }\\n    }\\n\\n    public int find(int node) {\\n        int root = node;\\n        while (root != parents[root]) {\\n            root = parents[root];\\n        }\\n\\n        return root;\\n    }\\n\\n    public boolean union(int x, int y) {\\n        int xParent = find(x);\\n        int yParent = find(y);\\n\\n        if (xParent == yParent) return false;\\n\\n        if (sizes[xParent] > sizes[yParent]) {\\n            parents[yParent] = xParent;\\n            sizes[xParent] += sizes[yParent];\\n        } else {\\n            parents[xParent] = yParent;\\n            sizes[yParent] += sizes[xParent];\\n        }\\n        numOfComponents--;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public static int maxNumEdgesToRemove(int n, int[][] edges) {\\n        Arrays.sort(edges, (a, b) -> b[0] - a[0]);\\n        UnionFind alice = new UnionFind(n);\\n        UnionFind bob = new UnionFind(n);\\n        int minEdges = 0;\\n        for (int[] edge : edges) {\\n            int type = edge[0], u = edge[1] - 1, v = edge[2] - 1;\\n            if (type == 3) {\\n                boolean aliceAgrees = alice.union(u, v), bobAgrees = bob.union(u, v);\\n                if (aliceAgrees || bobAgrees) {\\n                    minEdges++;\\n                }\\n            } else if (type == 2) {\\n                if (bob.union(u, v)) {\\n                    minEdges++;\\n                }\\n            } else {\\n                if (alice.union(u, v)) {\\n                    minEdges++;\\n                }\\n            }\\n        }\\n\\n        return alice.numOfComponents == 1 && bob.numOfComponents == 1 ? edges.length - minEdges : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\n    int[] parents;\\n    int[] sizes;\\n    int numOfComponents;\\n\\n    public UnionFind(int n) {\\n        parents = new int[n];\\n        sizes = new int[n];\\n        numOfComponents = n;\\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n            sizes[i] = 0;\\n        }\\n    }\\n\\n    public int find(int node) {\\n        int root = node;\\n        while (root != parents[root]) {\\n            root = parents[root];\\n        }\\n\\n        return root;\\n    }\\n\\n    public boolean union(int x, int y) {\\n        int xParent = find(x);\\n        int yParent = find(y);\\n\\n        if (xParent == yParent) return false;\\n\\n        if (sizes[xParent] > sizes[yParent]) {\\n            parents[yParent] = xParent;\\n            sizes[xParent] += sizes[yParent];\\n        } else {\\n            parents[xParent] = yParent;\\n            sizes[yParent] += sizes[xParent];\\n        }\\n        numOfComponents--;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public static int maxNumEdgesToRemove(int n, int[][] edges) {\\n        Arrays.sort(edges, (a, b) -> b[0] - a[0]);\\n        UnionFind alice = new UnionFind(n);\\n        UnionFind bob = new UnionFind(n);\\n        int minEdges = 0;\\n        for (int[] edge : edges) {\\n            int type = edge[0], u = edge[1] - 1, v = edge[2] - 1;\\n            if (type == 3) {\\n                boolean aliceAgrees = alice.union(u, v), bobAgrees = bob.union(u, v);\\n                if (aliceAgrees || bobAgrees) {\\n                    minEdges++;\\n                }\\n            } else if (type == 2) {\\n                if (bob.union(u, v)) {\\n                    minEdges++;\\n                }\\n            } else {\\n                if (alice.union(u, v)) {\\n                    minEdges++;\\n                }\\n            }\\n        }\\n\\n        return alice.numOfComponents == 1 && bob.numOfComponents == 1 ? edges.length - minEdges : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008265,
                "title": "o-e-linear-time-simple-2-pass-solution",
                "content": "# Code\\n```\\nclass dsu{\\n    int p[], cnt;\\n    dsu(int n) { p=new int[n]; for(int i=0;i<n; p[i]=i, i++); cnt=n;}\\n    int find(int a) { return p[a]==a? a: (p[a]=find(p[a])); }\\n    void union(int a, int b) { if(find(a)!=find(b)) {cnt--; p[find(a)]=p[find(b)];} }\\n}\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int m=edges.length, u, v, e=0;\\n\\n        dsu a=new dsu(n+1);\\n        dsu b=new dsu(n+1), c=b;\\n        for(int i=0; i<m; ++i) {\\n            if(edges[i][0]!=3) continue;\\n            u=edges[i][1]; v=edges[i][2];\\n            if(a.find(u)!=a.find(v) || b.find(u)!=b.find(v)) {\\n                a.union(u,v);\\n                b.union(u,v);\\n                e++;\\n            }\\n        }\\n\\n        for(int i=0; i<m; ++i) {\\n            if(edges[i][0]==3) continue;\\n            if(edges[i][0]==1) c=a;\\n            else if(edges[i][0]==2) c=b;\\n            u=edges[i][1]; v=edges[i][2];\\n            if(c.find(u)!=c.find(v)){\\n                c.union(u,v);\\n                e++;\\n            }\\n        }\\n        return (a.cnt==2 && b.cnt==2)? m-e: -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass dsu{\\n    int p[], cnt;\\n    dsu(int n) { p=new int[n]; for(int i=0;i<n; p[i]=i, i++); cnt=n;}\\n    int find(int a) { return p[a]==a? a: (p[a]=find(p[a])); }\\n    void union(int a, int b) { if(find(a)!=find(b)) {cnt--; p[find(a)]=p[find(b)];} }\\n}\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        int m=edges.length, u, v, e=0;\\n\\n        dsu a=new dsu(n+1);\\n        dsu b=new dsu(n+1), c=b;\\n        for(int i=0; i<m; ++i) {\\n            if(edges[i][0]!=3) continue;\\n            u=edges[i][1]; v=edges[i][2];\\n            if(a.find(u)!=a.find(v) || b.find(u)!=b.find(v)) {\\n                a.union(u,v);\\n                b.union(u,v);\\n                e++;\\n            }\\n        }\\n\\n        for(int i=0; i<m; ++i) {\\n            if(edges[i][0]==3) continue;\\n            if(edges[i][0]==1) c=a;\\n            else if(edges[i][0]==2) c=b;\\n            u=edges[i][1]; v=edges[i][2];\\n            if(c.find(u)!=c.find(v)){\\n                c.union(u,v);\\n                e++;\\n            }\\n        }\\n        return (a.cnt==2 && b.cnt==2)? m-e: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988171,
                "title": "clean-code-easy-approach-c",
                "content": "HARD problem solved Easily  ;)\\n\\n```\\nclass Solution {\\npublic:\\nstruct DSU {\\n  vector<int> e;\\n  DSU(int N) { e = vector<int>(N, -1); }\\n\\n  int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n  bool same_set(int a, int b) { return get(a) == get(b); }\\n\\n  int size(int x) { return -e[get(x)]; }\\n\\n  bool unite(int x, int y) {  \\n    x = get(x), y = get(y);\\n    if (x == y) return false;\\n    if (e[x] > e[y]) swap(x, y);\\n    e[x] += e[y];\\n    e[y] = x;\\n    return true;\\n  }\\n};\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<pair<int,pair<int,int>>>a;\\n        for(auto x : edges) {\\n            a.push_back({x[0],{x[1],x[2]}});\\n        }\\n        sort(a.rbegin(),a.rend());\\n        DSU alice(n+2);\\n        DSU bob(n+2);\\n        int inc = 0;\\n        int remove = 0;\\n        for(auto x : a) {\\n            int type = x.first;\\n            int i = x.second.first;\\n            int j = x.second.second;\\n            bool r = 1;\\n            if(type == 3) {\\n              if(!alice.same_set(i,j)) {\\n                  r = 0;\\n                  alice.unite(i,j);\\n              } \\n              if(!bob.same_set(i,j)) {\\n                  r = 0;\\n                  bob.unite(i,j);\\n              }\\n            } else if(type == 2) {\\n                if(!bob.same_set(i,j)) {\\n                    r = 0;\\n                    bob.unite(i,j);\\n                }\\n            } else if(type == 1) {\\n                if(!alice.same_set(i,j)) {\\n                    r = 0;\\n                    alice.unite(i,j);\\n                }\\n            }\\n            if(r) ++remove;\\n        }\\n        if(alice.size(1) != n || bob.size(1) != n) {\\n            return -1;\\n        } else {\\n            return remove;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nstruct DSU {\\n  vector<int> e;\\n  DSU(int N) { e = vector<int>(N, -1); }\\n\\n  int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n  bool same_set(int a, int b) { return get(a) == get(b); }\\n\\n  int size(int x) { return -e[get(x)]; }\\n\\n  bool unite(int x, int y) {  \\n    x = get(x), y = get(y);\\n    if (x == y) return false;\\n    if (e[x] > e[y]) swap(x, y);\\n    e[x] += e[y];\\n    e[y] = x;\\n    return true;\\n  }\\n};\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<pair<int,pair<int,int>>>a;\\n        for(auto x : edges) {\\n            a.push_back({x[0],{x[1],x[2]}});\\n        }\\n        sort(a.rbegin(),a.rend());\\n        DSU alice(n+2);\\n        DSU bob(n+2);\\n        int inc = 0;\\n        int remove = 0;\\n        for(auto x : a) {\\n            int type = x.first;\\n            int i = x.second.first;\\n            int j = x.second.second;\\n            bool r = 1;\\n            if(type == 3) {\\n              if(!alice.same_set(i,j)) {\\n                  r = 0;\\n                  alice.unite(i,j);\\n              } \\n              if(!bob.same_set(i,j)) {\\n                  r = 0;\\n                  bob.unite(i,j);\\n              }\\n            } else if(type == 2) {\\n                if(!bob.same_set(i,j)) {\\n                    r = 0;\\n                    bob.unite(i,j);\\n                }\\n            } else if(type == 1) {\\n                if(!alice.same_set(i,j)) {\\n                    r = 0;\\n                    alice.unite(i,j);\\n                }\\n            }\\n            if(r) ++remove;\\n        }\\n        if(alice.size(1) != n || bob.size(1) != n) {\\n            return -1;\\n        } else {\\n            return remove;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987863,
                "title": "dsu-class-implementation-clean-code-99-faster",
                "content": "# Intuition\\nThe edges which can be traversed by both should be maximised, as it facilitate non-duplicacy. And hence remove only those nodes which are present on places where type 3 nodes already exists. Also if any type 3 edges repeat themselves\\nHere\\'s a great explanation/proof to the above idea https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/editorial/comments/1878526\\n\\n# Approach\\nWe will have a Disjoint Set Union class and make two instanes of it .. one for alice and one for bob, we will first all the blue vertices(the one that both can travel) to both the instances, then we add the red ones to alices and green ones to bob, while adding edges, if we find edge already exists, we will count it in our answer, else we add the edge. We will also keep track of the total nodes reachable by alice and bob, in the end if this is not equal to n, we return a -1, else we will return the number of edges we found to be overlapping\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * \\\\alpha(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass DSU {\\npublic:\\n    vector<int> parent, size;\\n    int maxSize;\\n    DSU(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        maxSize = 0;\\n        for(int i = 0; i <= n; i++) parent[i] = i;\\n    }\\n\\n    int find(int x) {\\n        if(parent[x] == x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n\\n    void unionSize(int x, int y) {\\n        int xP = find(x), yP = find(y);\\n        if(xP == yP) return;\\n        if(size[xP] > size[yP]) {\\n            parent[yP] = xP;\\n            size[xP] += size[yP];\\n            maxSize = max(maxSize, size[xP]);\\n        } else {\\n            parent[xP] = yP;\\n            size[yP] += size[xP];\\n            maxSize = max(maxSize, size[yP]);\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n       \\n        DSU alice(n), bob(n);\\n        int ans = 0;\\n        // O(n * alpha(n))\\n        for(auto& it : edges) {\\n            if(it[0] == 3) {\\n                if(alice.find(it[1]) == alice.find(it[2])) {\\n                    ans++;\\n                } else {\\n                    alice.unionSize(it[1], it[2]);\\n                    bob.unionSize(it[1], it[2]);\\n                }\\n            }\\n        }\\n\\n        // O(n * alpha(n))\\n        for(auto& it : edges) {\\n            if(it[0] == 1) {\\n                if(alice.find(it[1]) == alice.find(it[2])) {\\n                    ans++;\\n                } else {\\n                    alice.unionSize(it[1], it[2]);\\n                }\\n            } else if(it[0] == 2) {\\n                if(bob.find(it[1]) == bob.find(it[2])) {\\n                    ans++;\\n                } else {\\n                    bob.unionSize(it[1], it[2]);\\n                }\\n            }\\n        }\\n        if(alice.maxSize == n and bob.maxSize == n) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n    vector<int> parent, size;\\n    int maxSize;\\n    DSU(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        maxSize = 0;\\n        for(int i = 0; i <= n; i++) parent[i] = i;\\n    }\\n\\n    int find(int x) {\\n        if(parent[x] == x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n\\n    void unionSize(int x, int y) {\\n        int xP = find(x), yP = find(y);\\n        if(xP == yP) return;\\n        if(size[xP] > size[yP]) {\\n            parent[yP] = xP;\\n            size[xP] += size[yP];\\n            maxSize = max(maxSize, size[xP]);\\n        } else {\\n            parent[xP] = yP;\\n            size[yP] += size[xP];\\n            maxSize = max(maxSize, size[yP]);\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n       \\n        DSU alice(n), bob(n);\\n        int ans = 0;\\n        // O(n * alpha(n))\\n        for(auto& it : edges) {\\n            if(it[0] == 3) {\\n                if(alice.find(it[1]) == alice.find(it[2])) {\\n                    ans++;\\n                } else {\\n                    alice.unionSize(it[1], it[2]);\\n                    bob.unionSize(it[1], it[2]);\\n                }\\n            }\\n        }\\n\\n        // O(n * alpha(n))\\n        for(auto& it : edges) {\\n            if(it[0] == 1) {\\n                if(alice.find(it[1]) == alice.find(it[2])) {\\n                    ans++;\\n                } else {\\n                    alice.unionSize(it[1], it[2]);\\n                }\\n            } else if(it[0] == 2) {\\n                if(bob.find(it[1]) == bob.find(it[2])) {\\n                    ans++;\\n                } else {\\n                    bob.unionSize(it[1], it[2]);\\n                }\\n            }\\n        }\\n        if(alice.maxSize == n and bob.maxSize == n) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985104,
                "title": "easy-approach-explained-well-commented-c-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n- Build two separate graphs for alice and bob.\\n- Firsty connect type 3 as they can be traverse by both and if any edge is already connected then add it in the ans.\\n- Now connect for type 1 and type 2 separately and similarly add in the answer if any edge is already connected.\\n- At last check if alice and bob both can traverse whole graph.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(E+N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int findParent(int x, vector<int>&parent){\\n        if(x==parent[x])\\n            return x;\\n        return parent[x]=findParent(parent[x],parent);\\n    }\\n    void findUnion(int x, int y, vector<int>& parent){\\n        x=findParent(x,parent);\\n        y=findParent(y,parent);\\n        if(x==y)\\n            return;\\n        parent[y]=x;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& e) {\\n        int ans=0;\\n        vector<int> parent1, parent2; // one for alice and one for bob\\n        parent1.resize(n);\\n        parent2.resize(n);\\n\\n        for(int i=0 ; i<n ; i++){\\n            parent1[i]=i;\\n            parent2[i]=i;\\n        }\\n        \\n        for(auto x:e){ // first connect type 3\\n            int a=x[1]-1, b=x[2]-1;\\n            if(x[0]==3){\\n                if(findParent(a,parent1)==findParent(b,parent1)) // if already connected then it is extra and should be added to ans\\n                    ans++;\\n                else{ // connect for both\\n                    findUnion(a,b,parent1); \\n                    findUnion(a,b,parent2);\\n                }\\n            }\\n        }\\n\\n        for(auto x:e){ // now check for alice\\n            int a=x[1]-1, b=x[2]-1;\\n            if(x[0]==1){\\n                if(findParent(a,parent1)==findParent(b,parent1))\\n                    ans++;\\n                else\\n                    findUnion(a,b,parent1); // connect type 1 if not connected already\\n            }\\n        }\\n\\n        for(auto x:e){ // check for bob\\n            int a=x[1]-1, b=x[2]-1;\\n            if(x[0]==2){\\n                if(findParent(a,parent2)==findParent(b,parent2))\\n                    ans++;\\n                else\\n                    findUnion(a,b,parent2); // connect type 2 if not connected already\\n            }\\n        }\\n\\n        for(int i=0 ; i<n ; i++){ // check if both can traverse whole graph\\n            if(findParent(i,parent1)!=findParent(0,parent1))\\n                return -1;\\n            if(findParent(i,parent2)!=findParent(0,parent2))\\n                return -1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findParent(int x, vector<int>&parent){\\n        if(x==parent[x])\\n            return x;\\n        return parent[x]=findParent(parent[x],parent);\\n    }\\n    void findUnion(int x, int y, vector<int>& parent){\\n        x=findParent(x,parent);\\n        y=findParent(y,parent);\\n        if(x==y)\\n            return;\\n        parent[y]=x;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& e) {\\n        int ans=0;\\n        vector<int> parent1, parent2; // one for alice and one for bob\\n        parent1.resize(n);\\n        parent2.resize(n);\\n\\n        for(int i=0 ; i<n ; i++){\\n            parent1[i]=i;\\n            parent2[i]=i;\\n        }\\n        \\n        for(auto x:e){ // first connect type 3\\n            int a=x[1]-1, b=x[2]-1;\\n            if(x[0]==3){\\n                if(findParent(a,parent1)==findParent(b,parent1)) // if already connected then it is extra and should be added to ans\\n                    ans++;\\n                else{ // connect for both\\n                    findUnion(a,b,parent1); \\n                    findUnion(a,b,parent2);\\n                }\\n            }\\n        }\\n\\n        for(auto x:e){ // now check for alice\\n            int a=x[1]-1, b=x[2]-1;\\n            if(x[0]==1){\\n                if(findParent(a,parent1)==findParent(b,parent1))\\n                    ans++;\\n                else\\n                    findUnion(a,b,parent1); // connect type 1 if not connected already\\n            }\\n        }\\n\\n        for(auto x:e){ // check for bob\\n            int a=x[1]-1, b=x[2]-1;\\n            if(x[0]==2){\\n                if(findParent(a,parent2)==findParent(b,parent2))\\n                    ans++;\\n                else\\n                    findUnion(a,b,parent2); // connect type 2 if not connected already\\n            }\\n        }\\n\\n        for(int i=0 ; i<n ; i++){ // check if both can traverse whole graph\\n            if(findParent(i,parent1)!=findParent(0,parent1))\\n                return -1;\\n            if(findParent(i,parent2)!=findParent(0,parent2))\\n                return -1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947483,
                "title": "easy-prims-algo-approach-mst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,pair<int,int>>,int> mp;\\n    #define pii pair<int,pair<int,int>> \\n    void f(vector<pair<int,int>> *g,int n,bool &flag)\\n    {\\n        priority_queue<pii,vector<pii>,greater<pii>> q;\\n        vector<int> vis(n+1,0);\\n        for(auto it:g[1])\\n        {\\n            q.push({it.second,{1,it.first}});\\n            vis[1]=1;\\n        }\\n       \\n        while(q.size()>0)\\n        {\\n            int wt=q.top().first;\\n            int u=q.top().second.first;\\n            int v=q.top().second.second;\\n            q.pop();\\n            if(vis[v]==1) continue;\\n            vis[v]=1;\\n            mp[{wt,{min(u,v),max(u,v)}}]++;\\n            for(auto it:g[v])\\n            {\\n                q.push({it.second,{v,it.first}});\\n            }\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(vis[i]==0) \\n            {\\n                flag=0;\\n                break;\\n            }\\n        }\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n       vector<pair<int,int>> ga[n+1],gb[n+1];\\n       for(int i=0;i<edges.size();i++)\\n       {\\n           int a=edges[i][1];\\n           int b=edges[i][2];;\\n           int type=edges[i][0];\\n           if(type==1)\\n           {\\n               ga[a].push_back({b,1e6});\\n               ga[b].push_back({a,1e6});\\n           }\\n           else if(type==2)\\n           {\\n                gb[a].push_back({b,1e6+1});\\n                gb[b].push_back({a,1e6+1});\\n           }\\n           else\\n           {\\n                gb[a].push_back({b,1});\\n               gb[b].push_back({a,1});\\n\\n               ga[a].push_back({b,1});\\n               ga[b].push_back({a,1});\\n           }    \\n       }\\n       int ans=0;\\n       bool flag=1;\\n       f(ga,n,flag);\\n       if(flag==0) return -1;\\n       f(gb,n,flag);\\n       if(flag==0) return -1;\\n       ans=edges.size()-mp.size();\\n       mp.clear();\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,pair<int,int>>,int> mp;\\n    #define pii pair<int,pair<int,int>> \\n    void f(vector<pair<int,int>> *g,int n,bool &flag)\\n    {\\n        priority_queue<pii,vector<pii>,greater<pii>> q;\\n        vector<int> vis(n+1,0);\\n        for(auto it:g[1])\\n        {\\n            q.push({it.second,{1,it.first}});\\n            vis[1]=1;\\n        }\\n       \\n        while(q.size()>0)\\n        {\\n            int wt=q.top().first;\\n            int u=q.top().second.first;\\n            int v=q.top().second.second;\\n            q.pop();\\n            if(vis[v]==1) continue;\\n            vis[v]=1;\\n            mp[{wt,{min(u,v),max(u,v)}}]++;\\n            for(auto it:g[v])\\n            {\\n                q.push({it.second,{v,it.first}});\\n            }\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(vis[i]==0) \\n            {\\n                flag=0;\\n                break;\\n            }\\n        }\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n       vector<pair<int,int>> ga[n+1],gb[n+1];\\n       for(int i=0;i<edges.size();i++)\\n       {\\n           int a=edges[i][1];\\n           int b=edges[i][2];;\\n           int type=edges[i][0];\\n           if(type==1)\\n           {\\n               ga[a].push_back({b,1e6});\\n               ga[b].push_back({a,1e6});\\n           }\\n           else if(type==2)\\n           {\\n                gb[a].push_back({b,1e6+1});\\n                gb[b].push_back({a,1e6+1});\\n           }\\n           else\\n           {\\n                gb[a].push_back({b,1});\\n               gb[b].push_back({a,1});\\n\\n               ga[a].push_back({b,1});\\n               ga[b].push_back({a,1});\\n           }    \\n       }\\n       int ans=0;\\n       bool flag=1;\\n       f(ga,n,flag);\\n       if(flag==0) return -1;\\n       f(gb,n,flag);\\n       if(flag==0) return -1;\\n       ans=edges.size()-mp.size();\\n       mp.clear();\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942154,
                "title": "easy-c-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size; \\n    public: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& e) {\\n        DisjointSet ds_bob(n);\\n        DisjointSet ds_alice(n);\\n        int count=0;\\n        for(int i=0;i<e.size();i++){\\n            if(e[i][0]==3){\\n                int p1=ds_bob.findUPar(e[i][1]);\\n                int p2=ds_bob.findUPar(e[i][2]);\\n                if(p1==p2) count++;\\n                else{\\n                    ds_bob.unionBySize(e[i][1],e[i][2]);\\n                    ds_alice.unionBySize(e[i][1],e[i][2]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<e.size();i++){\\n            if(e[i][0]==1){\\n                int p1=ds_alice.findUPar(e[i][1]);\\n                int p2=ds_alice.findUPar(e[i][2]);\\n                if(p1==p2) count++;\\n                else{\\n                    ds_alice.unionBySize(e[i][1],e[i][2]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<e.size();i++){\\n            if(e[i][0]==2){\\n                int p1=ds_bob.findUPar(e[i][1]);\\n                int p2=ds_bob.findUPar(e[i][2]);\\n                if(p1==p2) count++;\\n                else{\\n                    ds_bob.unionBySize(e[i][1],e[i][2]);\\n                }\\n            }\\n        }\\n        int p=ds_bob.findUPar(1);\\n        for(int i=1;i<=n;i++){\\n            if(p!=ds_bob.findUPar(i)) return -1;\\n        }\\n        p=ds_alice.findUPar(1);\\n        for(int i=1;i<=n;i++){\\n            if(p!=ds_alice.findUPar(i)) return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size; \\n    public: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& e) {\\n        DisjointSet ds_bob(n);\\n        DisjointSet ds_alice(n);\\n        int count=0;\\n        for(int i=0;i<e.size();i++){\\n            if(e[i][0]==3){\\n                int p1=ds_bob.findUPar(e[i][1]);\\n                int p2=ds_bob.findUPar(e[i][2]);\\n                if(p1==p2) count++;\\n                else{\\n                    ds_bob.unionBySize(e[i][1],e[i][2]);\\n                    ds_alice.unionBySize(e[i][1],e[i][2]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<e.size();i++){\\n            if(e[i][0]==1){\\n                int p1=ds_alice.findUPar(e[i][1]);\\n                int p2=ds_alice.findUPar(e[i][2]);\\n                if(p1==p2) count++;\\n                else{\\n                    ds_alice.unionBySize(e[i][1],e[i][2]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<e.size();i++){\\n            if(e[i][0]==2){\\n                int p1=ds_bob.findUPar(e[i][1]);\\n                int p2=ds_bob.findUPar(e[i][2]);\\n                if(p1==p2) count++;\\n                else{\\n                    ds_bob.unionBySize(e[i][1],e[i][2]);\\n                }\\n            }\\n        }\\n        int p=ds_bob.findUPar(1);\\n        for(int i=1;i<=n;i++){\\n            if(p!=ds_bob.findUPar(i)) return -1;\\n        }\\n        p=ds_alice.findUPar(1);\\n        for(int i=1;i<=n;i++){\\n            if(p!=ds_alice.findUPar(i)) return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918905,
                "title": "easy-c-solution-using-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDSU\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd Edges in Seperate DSU\\'s for both alice and bob to check if a node is connected or not\\n\\n# Code\\n```\\nclass Solution {\\n    class DSU{\\n        public:\\n        vector <int> par;\\n        vector <int> cnt;\\n        DSU(int N){\\n            par.resize(N+1);\\n            for(int i = 0;i <=N;i++) par[i] = i;\\n            cnt.resize(N+1,1);\\n        }\\n        int getPar(int u){\\n            if(par[u]==u) return u;\\n            return par[u] = getPar(par[u]);\\n        }\\n        void add(int u,int v){\\n            int pu = getPar(u),pv = getPar(v);\\n            if(pu==pv) return;\\n            if(cnt[pu] < cnt[pv]) swap(pu,pv);\\n            cnt[pu] += cnt[pv];\\n            par[pv] = pu;\\n        }\\n        bool isConnected(int u,int v){\\n            return getPar(u) == getPar(v);\\n        }\\n    };\\npublic:\\n    int maxNumEdgesToRemove(int N, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector <int> a,vector <int> b){\\n            return a[0] > b[0];\\n        });\\n        DSU alice(N),bob(N+1);\\n        int ans = 0;\\n        for(auto ed:edges){\\n            int u = ed[1] ,v = ed[2] ,t = ed[0];\\n            if(t==1){\\n                if(alice.isConnected(u,v)) ans++;\\n                else alice.add(u,v);\\n            }else if(t==2){\\n                if(bob.isConnected(u,v)) ans++;\\n                else bob.add(u,v);\\n            }else{\\n                if(alice.isConnected(u,v) && bob.isConnected(u,v)) ans++;\\n                else {\\n                    alice.add(u,v);\\n                    bob.add(u,v);\\n                }\\n            }\\n        }\\n        int a = alice.getPar(1),b = bob.getPar(1);\\n        for(int i = 1;i <=N;i++){\\n            if(a!=alice.getPar(i) || b!=bob.getPar(i)) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    class DSU{\\n        public:\\n        vector <int> par;\\n        vector <int> cnt;\\n        DSU(int N){\\n            par.resize(N+1);\\n            for(int i = 0;i <=N;i++) par[i] = i;\\n            cnt.resize(N+1,1);\\n        }\\n        int getPar(int u){\\n            if(par[u]==u) return u;\\n            return par[u] = getPar(par[u]);\\n        }\\n        void add(int u,int v){\\n            int pu = getPar(u),pv = getPar(v);\\n            if(pu==pv) return;\\n            if(cnt[pu] < cnt[pv]) swap(pu,pv);\\n            cnt[pu] += cnt[pv];\\n            par[pv] = pu;\\n        }\\n        bool isConnected(int u,int v){\\n            return getPar(u) == getPar(v);\\n        }\\n    };\\npublic:\\n    int maxNumEdgesToRemove(int N, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector <int> a,vector <int> b){\\n            return a[0] > b[0];\\n        });\\n        DSU alice(N),bob(N+1);\\n        int ans = 0;\\n        for(auto ed:edges){\\n            int u = ed[1] ,v = ed[2] ,t = ed[0];\\n            if(t==1){\\n                if(alice.isConnected(u,v)) ans++;\\n                else alice.add(u,v);\\n            }else if(t==2){\\n                if(bob.isConnected(u,v)) ans++;\\n                else bob.add(u,v);\\n            }else{\\n                if(alice.isConnected(u,v) && bob.isConnected(u,v)) ans++;\\n                else {\\n                    alice.add(u,v);\\n                    bob.add(u,v);\\n                }\\n            }\\n        }\\n        int a = alice.getPar(1),b = bob.getPar(1);\\n        for(int i = 1;i <=N;i++){\\n            if(a!=alice.getPar(i) || b!=bob.getPar(i)) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870490,
                "title": "easier-approach-and-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is an insipred post from here [link](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solutions/831536/c-union-find-both-one/)\\n\\n## Solution Type 1: Removing Edges\\nAt each edge we have two choices either choose to add or remove. This will be 2^n.\\n\\n## Solution Type 2 : Create min edge graph\\n\\n- Instead of removing edges, creating minimum edge graph is easier.\\n- Choosing type 3 edges are always beneficial over type 1 and type 2.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start with a disjoint set of n nodes\\n- Now, we choose an edge try to join this disjoint set of n nodes.\\n- For Alice and Bob, we insert type 3 edges first and not insert if nodes are always connected else we use the edge to connect nodes.\\n- For Alice, Incase the graph isn\\'t connected after inserting type 3, we insert Alice only nodes to it i.e Type 1.\\n- For Bob, In case the graph isn\\'t connected after inserting type 3, we insert Bob only nodes to it i.e Type 2.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findParent(vector<int> &parents, int cur) {\\n        if (parents[cur] < 0) return cur;\\n        return parents[cur] = findParent(parents, parents[cur]);\\n    }\\n\\n    int solve(vector<int> &parents, int type, vector<vector<int>> &edges, int n) {\\n        int used = 0;\\n        for (int i=0;i<edges.size();i++) {\\n            if (edges[i][0] == type) {\\n                int u = edges[i][1];\\n                int v = edges[i][2];\\n                int parentu = findParent(parents, u);\\n                int parentv = findParent(parents, v);\\n                if (parentu != parentv) {\\n                    if (parents[parentu] < parents[parentv]) \\n                        swap(parents[parentu], parents[parentv]);\\n                    parents[parentu] += parents[parentv];\\n                    parents[parentv] = parentu;\\n                    used++;\\n                }\\n            }\\n        }\\n        if (type != 3 and parents[findParent(parents, 1)] != -n) return -1;\\n        return used;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> parents(n+1,-1);\\n        int used = solve(parents, 3, edges, n);\\n        vector<int> parents2 = parents;\\n        int used2 = solve(parents2, 2, edges, n);\\n        if (used2 == -1) return -1;\\n        parents2 = parents;\\n        int used1 = solve(parents2, 1, edges, n);\\n        if (used1 == -1) return -1;\\n        return edges.size() - (used + used2 + used1);\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findParent(vector<int> &parents, int cur) {\\n        if (parents[cur] < 0) return cur;\\n        return parents[cur] = findParent(parents, parents[cur]);\\n    }\\n\\n    int solve(vector<int> &parents, int type, vector<vector<int>> &edges, int n) {\\n        int used = 0;\\n        for (int i=0;i<edges.size();i++) {\\n            if (edges[i][0] == type) {\\n                int u = edges[i][1];\\n                int v = edges[i][2];\\n                int parentu = findParent(parents, u);\\n                int parentv = findParent(parents, v);\\n                if (parentu != parentv) {\\n                    if (parents[parentu] < parents[parentv]) \\n                        swap(parents[parentu], parents[parentv]);\\n                    parents[parentu] += parents[parentv];\\n                    parents[parentv] = parentu;\\n                    used++;\\n                }\\n            }\\n        }\\n        if (type != 3 and parents[findParent(parents, 1)] != -n) return -1;\\n        return used;\\n    }\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> parents(n+1,-1);\\n        int used = solve(parents, 3, edges, n);\\n        vector<int> parents2 = parents;\\n        int used2 = solve(parents2, 2, edges, n);\\n        if (used2 == -1) return -1;\\n        parents2 = parents;\\n        int used1 = solve(parents2, 1, edges, n);\\n        if (used1 == -1) return -1;\\n        return edges.size() - (used + used2 + used1);\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862326,
                "title": "easy-c-disjoint-set-implementation-using-kruskal-s-algorithm",
                "content": "# Intuition\\n****Apply kruskal\\'s algorithm on two disjoint set for alice and bob.****\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        DisjointSet ds_alice(n+1);\\n        DisjointSet ds_bob(n+1);\\n        int ans=0;\\n        // vector<vector<int>> req_edges;\\n        sort(edges.begin(),edges.end(),greater<vector<int>>());\\n        for(auto it:edges){\\n                int type=it[0];\\n                int u=it[1];\\n                int v=it[2];\\n                if(type==1){\\n                    if(ds_alice.findUPar(u)!=ds_alice.findUPar(v)){\\n                        ds_alice.unionByRank(u,v);\\n                        // req_edges.push_back({type,u,v});\\n                        ans++;\\n                    }\\n                }\\n                else if(type==2){\\n                    if(ds_bob.findUPar(u)!=ds_bob.findUPar(v)){\\n                        ds_bob.unionByRank(u,v);\\n                        // req_edges.push_back({type,u,v});\\n                        ans++;\\n                    }\\n                }\\n                else if(type==3){\\n                    bool check=false;\\n                    if(ds_alice.findUPar(u)!=ds_alice.findUPar(v)){\\n                        ds_alice.unionByRank(u,v);\\n                        check=true;\\n                    }\\n                    if(ds_bob.findUPar(u)!=ds_bob.findUPar(v)){\\n                        ds_bob.unionByRank(u,v);\\n                        check=true;\\n                    }\\n                    if(check){\\n                        ans++;\\n                        // req_edges.push_back({type,u,v});\\n                    }\\n                }\\n        }\\n        for(int i=1;i<n;i++){\\n            if((ds_alice.findUPar(i)!=ds_alice.findUPar(i+1)) || (ds_bob.findUPar(i)!=ds_bob.findUPar(i+1))){\\n                return -1;\\n            }\\n        }\\n        \\n\\n        return edges.size()-ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        DisjointSet ds_alice(n+1);\\n        DisjointSet ds_bob(n+1);\\n        int ans=0;\\n        // vector<vector<int>> req_edges;\\n        sort(edges.begin(),edges.end(),greater<vector<int>>());\\n        for(auto it:edges){\\n                int type=it[0];\\n                int u=it[1];\\n                int v=it[2];\\n                if(type==1){\\n                    if(ds_alice.findUPar(u)!=ds_alice.findUPar(v)){\\n                        ds_alice.unionByRank(u,v);\\n                        // req_edges.push_back({type,u,v});\\n                        ans++;\\n                    }\\n                }\\n                else if(type==2){\\n                    if(ds_bob.findUPar(u)!=ds_bob.findUPar(v)){\\n                        ds_bob.unionByRank(u,v);\\n                        // req_edges.push_back({type,u,v});\\n                        ans++;\\n                    }\\n                }\\n                else if(type==3){\\n                    bool check=false;\\n                    if(ds_alice.findUPar(u)!=ds_alice.findUPar(v)){\\n                        ds_alice.unionByRank(u,v);\\n                        check=true;\\n                    }\\n                    if(ds_bob.findUPar(u)!=ds_bob.findUPar(v)){\\n                        ds_bob.unionByRank(u,v);\\n                        check=true;\\n                    }\\n                    if(check){\\n                        ans++;\\n                        // req_edges.push_back({type,u,v});\\n                    }\\n                }\\n        }\\n        for(int i=1;i<n;i++){\\n            if((ds_alice.findUPar(i)!=ds_alice.findUPar(i+1)) || (ds_bob.findUPar(i)!=ds_bob.findUPar(i+1))){\\n                return -1;\\n            }\\n        }\\n        \\n\\n        return edges.size()-ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856305,
                "title": "c-union-find-solution-explained",
                "content": "# Intuition\\nTo solve this problem, we can use a Union-Find (Disjoint Set Union) data structure to keep track of the connected components in the graph for both Alice and Bob. By processing the edges in descending order of their types, we prioritize type 3 edges over the others to minimize the number of edges required to construct the graph. We will iterate through the edges, adding them to the corresponding sets for Alice and Bob only if they form new connections. We can then calculate the maximum number of edges that can be removed while keeping the graph fully traversable by both users.\\n\\n# Approach\\n1. We will start by defining a Union-Find data structure with functions for making sets, finding the parent of a node (with path compression for optimization), and performing the union operation.\\n2. We will sort the edges in descending order based on their types, giving priority to type 3 edges to minimize the number of edges needed for connectivity.\\n3. We will initialize two Union-Find data structures for Alice and Bob and counters for the number of edges added for each user and the total number of removed edges.\\n4. We will iterate through the edges and process them as follows:\\n   a. If the edge is of type 3 and adding it creates new connections for both Alice and Bob, we will add it to both sets and increment the counters.\\n   b. If the edge is of type 2 (Bob-only edge) and adding it creates a new connection for Bob, we will add it to Bob\\'s set and increment the corresponding counter.\\n   c. If the edge is of type 1 (Alice-only edge) and adding it creates a new connection for Alice, we will add it to Alice\\'s set and increment the corresponding counter.\\n   d. After processing each edge, we will check if both Alice and Bob have n-1 edges (a fully connected graph with n nodes). If so, we will return the maximum number of removed edges. Otherwise, we will return -1 to indicate that the graph cannot be fully traversed.\\n\\n# Complexity\\n- Time complexity: Sorting the edges takes O(E log E) time, and the Union-Find operations take nearly linear time O(E alpha(V)), where E is the number of edges, V is the number of nodes, and alpha is the inverse Ackermann function (nearly constant). Thus, the overall time complexity is O(E log E + E alpha(V)), which can be approximated to O(E log E) for most practical purposes.\\n- Space complexity: We need additional space for the parent and rank arrays for both Alice and Bob, each of size n, resulting in a space complexity of O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //we will give priority to type 3 edge over rest to minimize the no edges for construct the graph\\n     void makeset(vector<int> &parent,vector<int> &rank)\\n    {\\n        int n=rank.size();\\n        for(int i=1;i<n;i++)\\n        {\\n           rank[i]=0;\\n           parent[i]=i;\\n        }\\n    }\\n    int findpar(int node,vector<int> &parent,vector<int> &rank)\\n    {\\n        if(node==parent[node]) return node;\\n        return parent[node]=findpar(parent[node],parent,rank);\\n    }\\n    bool Union(int u,int v,vector<int> &parent,vector<int> &rank)\\n    {\\n        int par_u=findpar(u,parent,rank);\\n        int par_v=findpar(v,parent,rank);\\n       if(par_u==par_v) return 0;\\n         \\n        else if(rank[par_u]>rank[par_v])\\n        {\\n            parent[par_v]=par_u;\\n        }\\n        else if(rank[par_u]<rank[par_v])\\n        {\\n            parent[par_u]=par_v;\\n        }\\n        else{\\n             parent[par_v]=par_u;\\n             rank[par_u]++;\\n        }\\n       return 1;\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), [] (vector<int> &a, vector<int> &b) { return a[0] > b[0]; });\\n        \\n        vector<int> parentb(n+1),parenta(n+1);\\n        vector<int> rankb(n+1),ranka(n+1);\\n        makeset(parentb,rankb);\\n        makeset(parenta,ranka);\\n        int removedNumEdges =  edges.size(), aliceNumEdges=0, bobNumEdges=0;\\n        for (auto &edge: edges) \\n        { \\n            int type = edge[0], u = edge[1], v = edge[2];\\n            if(type==3 )\\n            {\\n                if( Union(u,v,parentb,rankb)  )\\n                {\\n                   Union(u,v,parenta,ranka);\\n                   aliceNumEdges++;\\n                   bobNumEdges++;\\n                   removedNumEdges--;\\n                }\\n                \\n            }\\n            else if(type==2  )\\n            {\\n                if( Union(u,v,parentb,rankb) )\\n                {\\n                   bobNumEdges++;\\n                   removedNumEdges--;\\n                }\\n            }\\n            else \\n            {\\n                if( Union(u,v,parenta,ranka))\\n                {\\n                   aliceNumEdges++;\\n                   removedNumEdges--;\\n                }\\n            }\\n        }\\n        if(bobNumEdges==n-1 && aliceNumEdges==n-1)\\n            return  removedNumEdges ;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we will give priority to type 3 edge over rest to minimize the no edges for construct the graph\\n     void makeset(vector<int> &parent,vector<int> &rank)\\n    {\\n        int n=rank.size();\\n        for(int i=1;i<n;i++)\\n        {\\n           rank[i]=0;\\n           parent[i]=i;\\n        }\\n    }\\n    int findpar(int node,vector<int> &parent,vector<int> &rank)\\n    {\\n        if(node==parent[node]) return node;\\n        return parent[node]=findpar(parent[node],parent,rank);\\n    }\\n    bool Union(int u,int v,vector<int> &parent,vector<int> &rank)\\n    {\\n        int par_u=findpar(u,parent,rank);\\n        int par_v=findpar(v,parent,rank);\\n       if(par_u==par_v) return 0;\\n         \\n        else if(rank[par_u]>rank[par_v])\\n        {\\n            parent[par_v]=par_u;\\n        }\\n        else if(rank[par_u]<rank[par_v])\\n        {\\n            parent[par_u]=par_v;\\n        }\\n        else{\\n             parent[par_v]=par_u;\\n             rank[par_u]++;\\n        }\\n       return 1;\\n    }\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(), edges.end(), [] (vector<int> &a, vector<int> &b) { return a[0] > b[0]; });\\n        \\n        vector<int> parentb(n+1),parenta(n+1);\\n        vector<int> rankb(n+1),ranka(n+1);\\n        makeset(parentb,rankb);\\n        makeset(parenta,ranka);\\n        int removedNumEdges =  edges.size(), aliceNumEdges=0, bobNumEdges=0;\\n        for (auto &edge: edges) \\n        { \\n            int type = edge[0], u = edge[1], v = edge[2];\\n            if(type==3 )\\n            {\\n                if( Union(u,v,parentb,rankb)  )\\n                {\\n                   Union(u,v,parenta,ranka);\\n                   aliceNumEdges++;\\n                   bobNumEdges++;\\n                   removedNumEdges--;\\n                }\\n                \\n            }\\n            else if(type==2  )\\n            {\\n                if( Union(u,v,parentb,rankb) )\\n                {\\n                   bobNumEdges++;\\n                   removedNumEdges--;\\n                }\\n            }\\n            else \\n            {\\n                if( Union(u,v,parenta,ranka))\\n                {\\n                   aliceNumEdges++;\\n                   removedNumEdges--;\\n                }\\n            }\\n        }\\n        if(bobNumEdges==n-1 && aliceNumEdges==n-1)\\n            return  removedNumEdges ;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853412,
                "title": "most-efficient-elegant-code-union-find-with-path-compression-and-ranking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind {\\npublic:\\n    UnionFind(int size) : ranks(size + 1, 0) {\\n        numSets = size;\\n    }\\n\\n    // idx: 1-based index of node.\\n    // returns 1-based index of root node.\\n    int find(int idx) {\\n        static std::vector<int> q; // for path compression\\n        q.clear();\\n        while (ranks[idx] > 0) {\\n            q.emplace_back(idx);\\n            idx = ranks[idx];\\n        }\\n        for (const auto i : q) {\\n            ranks[i] = idx;\\n        }\\n        return idx;\\n    }\\n\\n    bool makeUnion(int a, int b) {\\n        int x = find(a);\\n        int y = find(b);\\n        if (x == y) return false;\\n        if (ranks[x] < ranks[y]) {\\n            std::swap(x, y);\\n        }\\n        else if (ranks[x] == ranks[y]) {\\n            ranks[y]--;\\n        }\\n        ranks[x] = y; // make x a child of y\\n        numSets--;\\n        return true;\\n    }\\n\\n    int connected() const {return numSets <= 1;}\\n\\nprivate:\\n    // ranks[i] is the rank of i^th node (1-based).\\n    // <= 0: root, absolute value is the rank.\\n    // > 0:  child, value is 1-based index of parent.\\n    std::vector<int> ranks;\\n    int numSets;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind alice(n);\\n        int used = 0;\\n        for (const auto& edge: edges) {\\n            if (edge[0] == 3) {\\n                if (alice.makeUnion(edge[1], edge[2])) used++;\\n            }\\n        }\\n        auto bob = alice;\\n        for (const auto& edge: edges) {\\n            if (edge[0] == 1) {\\n                if (alice.makeUnion(edge[1], edge[2])) used++;\\n            }\\n            else if (edge[0] == 2) {\\n                if (bob.makeUnion(edge[1], edge[2])) used++;\\n            }\\n        }\\n        return alice.connected() && bob.connected() ? edges.size() - used : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    UnionFind(int size) : ranks(size + 1, 0) {\\n        numSets = size;\\n    }\\n\\n    // idx: 1-based index of node.\\n    // returns 1-based index of root node.\\n    int find(int idx) {\\n        static std::vector<int> q; // for path compression\\n        q.clear();\\n        while (ranks[idx] > 0) {\\n            q.emplace_back(idx);\\n            idx = ranks[idx];\\n        }\\n        for (const auto i : q) {\\n            ranks[i] = idx;\\n        }\\n        return idx;\\n    }\\n\\n    bool makeUnion(int a, int b) {\\n        int x = find(a);\\n        int y = find(b);\\n        if (x == y) return false;\\n        if (ranks[x] < ranks[y]) {\\n            std::swap(x, y);\\n        }\\n        else if (ranks[x] == ranks[y]) {\\n            ranks[y]--;\\n        }\\n        ranks[x] = y; // make x a child of y\\n        numSets--;\\n        return true;\\n    }\\n\\n    int connected() const {return numSets <= 1;}\\n\\nprivate:\\n    // ranks[i] is the rank of i^th node (1-based).\\n    // <= 0: root, absolute value is the rank.\\n    // > 0:  child, value is 1-based index of parent.\\n    std::vector<int> ranks;\\n    int numSets;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        UnionFind alice(n);\\n        int used = 0;\\n        for (const auto& edge: edges) {\\n            if (edge[0] == 3) {\\n                if (alice.makeUnion(edge[1], edge[2])) used++;\\n            }\\n        }\\n        auto bob = alice;\\n        for (const auto& edge: edges) {\\n            if (edge[0] == 1) {\\n                if (alice.makeUnion(edge[1], edge[2])) used++;\\n            }\\n            else if (edge[0] == 2) {\\n                if (bob.makeUnion(edge[1], edge[2])) used++;\\n            }\\n        }\\n        return alice.connected() && bob.connected() ? edges.size() - used : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849824,
                "title": "dsu-c-clean-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate two trees, one for Alice and one for Bob. First populate the parent and rank vectors of both the trees using type=3 edges.\\n\\nNow, Take alice\\'s tree and add those edges which haven\\'t been added.Check for cycles. If there is a cycle then remove those edges.\\n\\nSimilarly for Bob, add those edges which haven\\'t been added. Check for cycles.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU{\\npublic:\\n\\n    vector<int> parent,rank;\\n    int Find(int u){\\n        if(parent[u]==-1){\\n            return u;\\n        }\\n        return parent[u]=Find(parent[u]);\\n    }\\n    bool Union(int u,int v){\\n        int s1 = Find(u);\\n        int s2 = Find(v);\\n        if(s1==s2){\\n            return true;\\n        }\\n\\n        if(rank[s1]>rank[s2]){\\n            rank[s1]+=rank[s2];\\n            parent[s2]= s1;\\n        }else if(rank[s2]>rank[s1]){\\n            rank[s2]+=rank[s1];\\n            parent[s1]= s2;\\n        }else{\\n            rank[s1]++;\\n            parent[s2]= s1;\\n        }\\n        return false;\\n    }\\n\\n    DSU(int n){\\n        parent = vector<int>(n+1,-1);\\n        rank = vector<int>(n+1,1);\\n    }\\n\\n    int getCount(){\\n        int cnt = 0;\\n        for(int i=1;i<parent.size();i++){\\n            if(Find(i)==i){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        //Create DSU for two trees\\n        DSU* Alice = new DSU(n);\\n        DSU* Bob = new DSU(n);\\n        int ans = 0;\\n\\n        for(auto &i:edges){\\n            int u = i[1];\\n            int v = i[2];\\n            if(i[0]==3){\\n                if(Alice->Union(u,v)||Bob->Union(u,v)){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        for(auto &i:edges){\\n            int u = i[1];\\n            int v = i[2];\\n            if(i[0]==1){\\n                if(Alice->Union(u,v)){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        for(auto &i:edges){\\n            int u = i[1];\\n            int v = i[2];\\n            if(i[0]==2){\\n                if(Bob->Union(u,v)){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        if(Alice->getCount()>1 || Bob->getCount()>1){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\npublic:\\n\\n    vector<int> parent,rank;\\n    int Find(int u){\\n        if(parent[u]==-1){\\n            return u;\\n        }\\n        return parent[u]=Find(parent[u]);\\n    }\\n    bool Union(int u,int v){\\n        int s1 = Find(u);\\n        int s2 = Find(v);\\n        if(s1==s2){\\n            return true;\\n        }\\n\\n        if(rank[s1]>rank[s2]){\\n            rank[s1]+=rank[s2];\\n            parent[s2]= s1;\\n        }else if(rank[s2]>rank[s1]){\\n            rank[s2]+=rank[s1];\\n            parent[s1]= s2;\\n        }else{\\n            rank[s1]++;\\n            parent[s2]= s1;\\n        }\\n        return false;\\n    }\\n\\n    DSU(int n){\\n        parent = vector<int>(n+1,-1);\\n        rank = vector<int>(n+1,1);\\n    }\\n\\n    int getCount(){\\n        int cnt = 0;\\n        for(int i=1;i<parent.size();i++){\\n            if(Find(i)==i){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        //Create DSU for two trees\\n        DSU* Alice = new DSU(n);\\n        DSU* Bob = new DSU(n);\\n        int ans = 0;\\n\\n        for(auto &i:edges){\\n            int u = i[1];\\n            int v = i[2];\\n            if(i[0]==3){\\n                if(Alice->Union(u,v)||Bob->Union(u,v)){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        for(auto &i:edges){\\n            int u = i[1];\\n            int v = i[2];\\n            if(i[0]==1){\\n                if(Alice->Union(u,v)){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        for(auto &i:edges){\\n            int u = i[1];\\n            int v = i[2];\\n            if(i[0]==2){\\n                if(Bob->Union(u,v)){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        if(Alice->getCount()>1 || Bob->getCount()>1){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849306,
                "title": "c-soln-kuraskal",
                "content": "\\n```\\nclass Solution {\\npublic:\\nint parent(vector<int> &par,int u){\\n    if(par[u]==u)return u;\\n    return par[u]=parent(par,par[u]);\\n}\\nvoid Union(vector<int> &par,int u,int v){\\n    u=parent(par,u);\\n    v=parent(par,v);\\n    par[v]=u;\\n}\\nbool static cmp(vector<int> &a,vector<int> &b){\\n    return a[0]>b[0];\\n}\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),cmp);\\n        int bob_count=0,alice_count=0;\\n        vector<int> par(n+1,0);\\n        for(int i=1;i<=n;i++){par[i]=i;}\\n        //////////////////////////////////////////\\n        int i=0;\\n        while(i<edges.size() && edges[i][0]==3){\\n            int u=parent(par,edges[i][1]);\\n            int v=parent(par,edges[i][2]);\\n            if(u==v){i++;continue;}\\n            bob_count++;alice_count++;\\n            Union(par,u,v);\\n            i++;\\n        }\\n        int tt=-(bob_count)+2*n-2;\\n        vector<int> par1=par;\\n\\n//======================================================\\n       while(i<edges.size() && edges[i][0]==2){\\n            int u=parent(par,edges[i][1]);\\n            int v=parent(par,edges[i][2]);\\n            if(u==v){i++;continue;}\\n            bob_count++;\\n            Union(par,u,v);\\n            i++;\\n        }\\n//------------------------------------------------\\n        while(i<edges.size()){\\n            int u=parent(par1,edges[i][1]);\\n            int v=parent(par1,edges[i][2]);\\n            if(u==v){i++;continue;}\\n            alice_count++;\\n            Union(par1,u,v);\\n            i++;\\n        }\\n        if(alice_count!=n-1 || bob_count!=n-1)return -1;\\n        return edges.size()-tt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint parent(vector<int> &par,int u){\\n    if(par[u]==u)return u;\\n    return par[u]=parent(par,par[u]);\\n}\\nvoid Union(vector<int> &par,int u,int v){\\n    u=parent(par,u);\\n    v=parent(par,v);\\n    par[v]=u;\\n}\\nbool static cmp(vector<int> &a,vector<int> &b){\\n    return a[0]>b[0];\\n}\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),cmp);\\n        int bob_count=0,alice_count=0;\\n        vector<int> par(n+1,0);\\n        for(int i=1;i<=n;i++){par[i]=i;}\\n        //////////////////////////////////////////\\n        int i=0;\\n        while(i<edges.size() && edges[i][0]==3){\\n            int u=parent(par,edges[i][1]);\\n            int v=parent(par,edges[i][2]);\\n            if(u==v){i++;continue;}\\n            bob_count++;alice_count++;\\n            Union(par,u,v);\\n            i++;\\n        }\\n        int tt=-(bob_count)+2*n-2;\\n        vector<int> par1=par;\\n\\n//======================================================\\n       while(i<edges.size() && edges[i][0]==2){\\n            int u=parent(par,edges[i][1]);\\n            int v=parent(par,edges[i][2]);\\n            if(u==v){i++;continue;}\\n            bob_count++;\\n            Union(par,u,v);\\n            i++;\\n        }\\n//------------------------------------------------\\n        while(i<edges.size()){\\n            int u=parent(par1,edges[i][1]);\\n            int v=parent(par1,edges[i][2]);\\n            if(u==v){i++;continue;}\\n            alice_count++;\\n            Union(par1,u,v);\\n            i++;\\n        }\\n        if(alice_count!=n-1 || bob_count!=n-1)return -1;\\n        return edges.size()-tt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846894,
                "title": "python-solution-using-union-find-and-sorting-o-nlog-n-and-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        edges.sort(key=lambda x:[-x[0],x[1],x[2]])\\n        ans=0\\n        parent1=[i for i in range(n)]\\n        parent2=[i for i in range(n)]\\n        rank1=[0]*n\\n        rank2=[0]*n\\n        for c,a,b in edges:\\n            a-=1\\n            b-=1\\n            if(c==3):\\n                ans+=self.union(a,b,parent1,rank1)\\n                self.union(a,b,parent2,rank2)\\n            elif(c==1):\\n                ans+=self.union(a,b,parent1,rank1)\\n            else:\\n                ans+=self.union(a,b,parent2,rank2)\\n        par1=par2=-1\\n        for i in range(n):\\n            x1=self.find(parent1,i)\\n            x2=self.find(parent2,i)\\n            if((par1!=x1 and par1!=-1) or (par2!=x2 and par2!=-1)):return -1\\n            par1=x1\\n            par2=x2\\n        return len(edges)-ans\\n    def union(self,node1,node2,parent,rank):\\n        par1=self.find(parent,node1)\\n        par2=self.find(parent,node2)\\n        if(par1!=par2):\\n            if(rank[par1]>rank[par2]):\\n                parent[par2]=par1\\n            elif(rank[par1]<rank[par2]):\\n                parent[par1]=par2\\n            else:\\n                rank[par1]+=1\\n                parent[par2]=par1\\n            return 1\\n        return 0\\n    \\n    def find(self,parent,node):\\n        if(parent[node]==node):return node\\n        parent[node]=self.find(parent,parent[node])\\n        return parent[node]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        edges.sort(key=lambda x:[-x[0],x[1],x[2]])\\n        ans=0\\n        parent1=[i for i in range(n)]\\n        parent2=[i for i in range(n)]\\n        rank1=[0]*n\\n        rank2=[0]*n\\n        for c,a,b in edges:\\n            a-=1\\n            b-=1\\n            if(c==3):\\n                ans+=self.union(a,b,parent1,rank1)\\n                self.union(a,b,parent2,rank2)\\n            elif(c==1):\\n                ans+=self.union(a,b,parent1,rank1)\\n            else:\\n                ans+=self.union(a,b,parent2,rank2)\\n        par1=par2=-1\\n        for i in range(n):\\n            x1=self.find(parent1,i)\\n            x2=self.find(parent2,i)\\n            if((par1!=x1 and par1!=-1) or (par2!=x2 and par2!=-1)):return -1\\n            par1=x1\\n            par2=x2\\n        return len(edges)-ans\\n    def union(self,node1,node2,parent,rank):\\n        par1=self.find(parent,node1)\\n        par2=self.find(parent,node2)\\n        if(par1!=par2):\\n            if(rank[par1]>rank[par2]):\\n                parent[par2]=par1\\n            elif(rank[par1]<rank[par2]):\\n                parent[par1]=par2\\n            else:\\n                rank[par1]+=1\\n                parent[par2]=par1\\n            return 1\\n        return 0\\n    \\n    def find(self,parent,node):\\n        if(parent[node]==node):return node\\n        parent[node]=self.find(parent,parent[node])\\n        return parent[node]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839638,
                "title": "python3-beats-99-18-dsu",
                "content": "\\n![Screenshot from 2023-07-30 23-18-03.png](https://assets.leetcode.com/users/images/d646e93b-c654-44fc-9416-40083b4b71b0_1690739318.625398.png)\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, nodes: int):\\n        self.ranks, self.parents = [], []\\n        for i in range(nodes):\\n            self.ranks.append(1)\\n            self.parents.append(i)\\n\\n    def find(self, node: int):\\n        node_parents = []\\n        while node != self.parents[node]:\\n            node_parents.append(node)\\n            node = self.parents[node]\\n        for parent_node in node_parents:\\n            self.parents[parent_node] = node\\n        return node\\n\\n    def union_cycle(self, node_1: int, node_2: int):\\n        node_1_parent, node_2_parent = self.find(node_1), self.find(node_2)\\n        if node_1_parent != node_2_parent:\\n            if self.ranks[node_1_parent] > self.ranks[node_2_parent]:\\n                self.ranks[node_1_parent] += self.ranks[node_2_parent]\\n                self.parents[node_2_parent] = node_1_parent\\n            else:\\n                self.ranks[node_2_parent] += self.ranks[node_1_parent]\\n                self.parents[node_1_parent] = node_2_parent\\n            return False\\n        else:\\n            return True\\n\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        edges = sorted(edges, key=lambda x:-x[0])\\n        alex, bob = UnionFind(n), UnionFind(n)\\n        result = 0\\n        for traversal_type, source, destination in edges:\\n            if traversal_type == 3:\\n                if alex.union_cycle(source-1, destination-1):\\n                    result += 1\\n                bob.union_cycle(source-1, destination-1)\\n                    \\n            elif traversal_type == 1:\\n                if alex.union_cycle(source-1, destination-1):\\n                    result += 1\\n            elif traversal_type == 2:\\n                if bob.union_cycle(source-1, destination-1):\\n                    result += 1\\n\\n        for i in range(n):\\n            alex.find(i)\\n            bob.find(i)\\n        \\n        total_alex_parents, total_bob_parents = len(set(alex.parents)), len(set(bob.parents))\\n\\n        if total_alex_parents > 1 or total_bob_parents > 1:\\n            return -1\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, nodes: int):\\n        self.ranks, self.parents = [], []\\n        for i in range(nodes):\\n            self.ranks.append(1)\\n            self.parents.append(i)\\n\\n    def find(self, node: int):\\n        node_parents = []\\n        while node != self.parents[node]:\\n            node_parents.append(node)\\n            node = self.parents[node]\\n        for parent_node in node_parents:\\n            self.parents[parent_node] = node\\n        return node\\n\\n    def union_cycle(self, node_1: int, node_2: int):\\n        node_1_parent, node_2_parent = self.find(node_1), self.find(node_2)\\n        if node_1_parent != node_2_parent:\\n            if self.ranks[node_1_parent] > self.ranks[node_2_parent]:\\n                self.ranks[node_1_parent] += self.ranks[node_2_parent]\\n                self.parents[node_2_parent] = node_1_parent\\n            else:\\n                self.ranks[node_2_parent] += self.ranks[node_1_parent]\\n                self.parents[node_1_parent] = node_2_parent\\n            return False\\n        else:\\n            return True\\n\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        edges = sorted(edges, key=lambda x:-x[0])\\n        alex, bob = UnionFind(n), UnionFind(n)\\n        result = 0\\n        for traversal_type, source, destination in edges:\\n            if traversal_type == 3:\\n                if alex.union_cycle(source-1, destination-1):\\n                    result += 1\\n                bob.union_cycle(source-1, destination-1)\\n                    \\n            elif traversal_type == 1:\\n                if alex.union_cycle(source-1, destination-1):\\n                    result += 1\\n            elif traversal_type == 2:\\n                if bob.union_cycle(source-1, destination-1):\\n                    result += 1\\n\\n        for i in range(n):\\n            alex.find(i)\\n            bob.find(i)\\n        \\n        total_alex_parents, total_bob_parents = len(set(alex.parents)), len(set(bob.parents))\\n\\n        if total_alex_parents > 1 or total_bob_parents > 1:\\n            return -1\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833167,
                "title": "solution-using-prim-s-minimum-spanning-tree",
                "content": "# Intuition\\nSince we need to find minimum edges with which graph is fully traversal for both alice and bob, it means we need to find MST possible for both alice and bob\\n\\n# Approach\\n- We will apply prims algorithm to find minimum spanning tree for alice and bob \\n- while picking edges we will give higher priority to edge with type 3\\n- we will find MST for alice and bob separately and union their edges. This count is count of minimum edges we need to have graph fully travererable by both alice and bob\\n- in priority queue, we will define sorting order first by type, then by src, and then by dest, because we can have mulitple type 3 edges to choose for same nodes, in such case we want to construct same mst for alice and bob both\\n\\n# Complexity\\n- Time complexity:\\nMST takes O(V*ElogV)\\n\\n# Code\\n```\\nclass Solution {\\n        static class Edge implements Comparable<Edge> {\\n            int s;\\n            int d;\\n            int t;\\n\\n            Edge(int src, int dst, int type) {\\n                s = src;\\n                d = dst;\\n                t = type;\\n            }\\n\\n            @Override\\n            public int compareTo(Edge e) {\\n                if(e.t != this.t)\\n                    return e.t - this.t;\\n\\n                if(e.s != this.s)\\n                    return e.s - this.s;\\n\\n                return e.d - this.d;\\n            }\\n\\n            @Override\\n            public boolean equals(Object o) {\\n                Edge e = ((Edge)o);\\n                return e.t == this.t &&\\n                        (\\n                                (e.s == this.s && e.d == this.d) ||\\n                                        (e.s == this.d && e.d == this.s)\\n                        );\\n            }\\n\\n            @Override\\n            public int hashCode() {\\n                return 31 * t * s * d;\\n            }\\n        }\\n\\n        private Set<Edge> getMST(List<Edge> adj[], int n, int type) {\\n            Set<Edge> out = new HashSet();\\n            PriorityQueue<Edge> q = new PriorityQueue();\\n            q.add(new Edge(0, 0, -1));\\n\\n            boolean vis[] = new boolean[n];\\n\\n            while(!q.isEmpty()) {\\n                Edge r = q.poll();\\n\\n                if(vis[r.d])\\n                    continue;\\n\\n                vis[r.d] = true;\\n\\n                if(r.t != -1)\\n                    out.add(r);\\n\\n                for(Edge e: adj[r.d]) {\\n                    if(!vis[e.d] && (e.t == 3 || e.t == type)) {\\n                        q.add(e);\\n                    }\\n                }\\n\\n            }\\n\\n            for(int i=0;i<n;i++) {\\n                if(!vis[i])\\n                    return Collections.emptySet();\\n            }\\n\\n            return out;\\n        }\\n\\n        public int maxNumEdgesToRemove(int n, int[][] edges) {\\n\\n            List<Edge> adj[] = new List[n];\\n            for(int i=0;i<n;i++)\\n                adj[i] = new ArrayList();\\n\\n            for(int i=0;i<edges.length;i++) {\\n                adj[edges[i][1]-1].add(new Edge(edges[i][1]-1, edges[i][2]-1, edges[i][0]));\\n                adj[edges[i][2]-1].add(new Edge(edges[i][2]-1, edges[i][1]-1, edges[i][0]));\\n            }\\n\\n            Set<Edge> aliceMST = getMST(adj, n, 1);\\n            Set<Edge> bobMST = getMST(adj, n, 2);\\n\\n            if(aliceMST.isEmpty() || bobMST.isEmpty())\\n                return -1;\\n\\n            aliceMST.addAll(bobMST);\\n\\n            return edges.length - aliceMST.size();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass Solution {\\n        static class Edge implements Comparable<Edge> {\\n            int s;\\n            int d;\\n            int t;\\n\\n            Edge(int src, int dst, int type) {\\n                s = src;\\n                d = dst;\\n                t = type;\\n            }\\n\\n            @Override\\n            public int compareTo(Edge e) {\\n                if(e.t != this.t)\\n                    return e.t - this.t;\\n\\n                if(e.s != this.s)\\n                    return e.s - this.s;\\n\\n                return e.d - this.d;\\n            }\\n\\n            @Override\\n            public boolean equals(Object o) {\\n                Edge e = ((Edge)o);\\n                return e.t == this.t &&\\n                        (\\n                                (e.s == this.s && e.d == this.d) ||\\n                                        (e.s == this.d && e.d == this.s)\\n                        );\\n            }\\n\\n            @Override\\n            public int hashCode() {\\n                return 31 * t * s * d;\\n            }\\n        }\\n\\n        private Set<Edge> getMST(List<Edge> adj[], int n, int type) {\\n            Set<Edge> out = new HashSet();\\n            PriorityQueue<Edge> q = new PriorityQueue();\\n            q.add(new Edge(0, 0, -1));\\n\\n            boolean vis[] = new boolean[n];\\n\\n            while(!q.isEmpty()) {\\n                Edge r = q.poll();\\n\\n                if(vis[r.d])\\n                    continue;\\n\\n                vis[r.d] = true;\\n\\n                if(r.t != -1)\\n                    out.add(r);\\n\\n                for(Edge e: adj[r.d]) {\\n                    if(!vis[e.d] && (e.t == 3 || e.t == type)) {\\n                        q.add(e);\\n                    }\\n                }\\n\\n            }\\n\\n            for(int i=0;i<n;i++) {\\n                if(!vis[i])\\n                    return Collections.emptySet();\\n            }\\n\\n            return out;\\n        }\\n\\n        public int maxNumEdgesToRemove(int n, int[][] edges) {\\n\\n            List<Edge> adj[] = new List[n];\\n            for(int i=0;i<n;i++)\\n                adj[i] = new ArrayList();\\n\\n            for(int i=0;i<edges.length;i++) {\\n                adj[edges[i][1]-1].add(new Edge(edges[i][1]-1, edges[i][2]-1, edges[i][0]));\\n                adj[edges[i][2]-1].add(new Edge(edges[i][2]-1, edges[i][1]-1, edges[i][0]));\\n            }\\n\\n            Set<Edge> aliceMST = getMST(adj, n, 1);\\n            Set<Edge> bobMST = getMST(adj, n, 2);\\n\\n            if(aliceMST.isEmpty() || bobMST.isEmpty())\\n                return -1;\\n\\n            aliceMST.addAll(bobMST);\\n\\n            return edges.length - aliceMST.size();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824764,
                "title": "python-union-find-graph-construction",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n\\n\\n        graph = collections.defaultdict(list)\\n\\n        parent_both = {}\\n\\n\\n        def find_parent(i, parent):\\n            if i not in parent or  parent[i] == i:\\n                parent[i] = i\\n                return parent[i] \\n            \\n            parent[i] = find_parent(parent[i], parent)\\n            return parent[i]\\n        \\n\\n        edge = 0 \\n\\n        for t, a, b in edges:\\n            if t != 3:continue\\n            graph[a].append(b)\\n            graph[b].append(a) \\n            p_a = find_parent(a, parent_both)\\n            p_b = find_parent(b, parent_both)\\n            if p_a != p_b:\\n                edge +=1\\n                parent_both[p_a] = p_b\\n\\n        graph_alice = copy.deepcopy(graph)        \\n        parent_alice = dict(parent_both)\\n\\n        for t, a, b in edges:\\n            if t != 1:continue \\n            p_a = find_parent(a, parent_alice)\\n            p_b = find_parent(b, parent_alice)\\n            if p_a != p_b:\\n                graph_alice[a].append(b)\\n                graph_alice[b].append(a)\\n                edge +=1\\n                parent_alice[p_a] = p_b\\n\\n        parent_bob = dict(parent_both)\\n\\n        graph_bob = copy.deepcopy(graph)        \\n\\n\\n        for t, a, b in edges:\\n            if t != 2:continue \\n            p_a = find_parent(a, parent_bob)\\n            p_b = find_parent(b, parent_bob)\\n            if p_a != p_b:\\n                graph_bob[a].append(b)\\n                graph_bob[b].append(a)\\n                edge +=1\\n                parent_bob[p_a] = p_b\\n\\n        def can_fully_traverse(graph):\\n            queue = [1]\\n            visit = {1}\\n            while queue:\\n                node  = queue.pop(0)\\n                for v in graph[node]:\\n                    if v not in visit:\\n                        queue.append(v)\\n                        visit.add(v)\\n            return n == len(visit)\\n\\n        if not can_fully_traverse(graph_bob) or  not can_fully_traverse(graph_alice):\\n            return -1\\n        return len(edges) - edge\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n\\n\\n        graph = collections.defaultdict(list)\\n\\n        parent_both = {}\\n\\n\\n        def find_parent(i, parent):\\n            if i not in parent or  parent[i] == i:\\n                parent[i] = i\\n                return parent[i] \\n            \\n            parent[i] = find_parent(parent[i], parent)\\n            return parent[i]\\n        \\n\\n        edge = 0 \\n\\n        for t, a, b in edges:\\n            if t != 3:continue\\n            graph[a].append(b)\\n            graph[b].append(a) \\n            p_a = find_parent(a, parent_both)\\n            p_b = find_parent(b, parent_both)\\n            if p_a != p_b:\\n                edge +=1\\n                parent_both[p_a] = p_b\\n\\n        graph_alice = copy.deepcopy(graph)        \\n        parent_alice = dict(parent_both)\\n\\n        for t, a, b in edges:\\n            if t != 1:continue \\n            p_a = find_parent(a, parent_alice)\\n            p_b = find_parent(b, parent_alice)\\n            if p_a != p_b:\\n                graph_alice[a].append(b)\\n                graph_alice[b].append(a)\\n                edge +=1\\n                parent_alice[p_a] = p_b\\n\\n        parent_bob = dict(parent_both)\\n\\n        graph_bob = copy.deepcopy(graph)        \\n\\n\\n        for t, a, b in edges:\\n            if t != 2:continue \\n            p_a = find_parent(a, parent_bob)\\n            p_b = find_parent(b, parent_bob)\\n            if p_a != p_b:\\n                graph_bob[a].append(b)\\n                graph_bob[b].append(a)\\n                edge +=1\\n                parent_bob[p_a] = p_b\\n\\n        def can_fully_traverse(graph):\\n            queue = [1]\\n            visit = {1}\\n            while queue:\\n                node  = queue.pop(0)\\n                for v in graph[node]:\\n                    if v not in visit:\\n                        queue.append(v)\\n                        visit.add(v)\\n            return n == len(visit)\\n\\n        if not can_fully_traverse(graph_bob) or  not can_fully_traverse(graph_alice):\\n            return -1\\n        return len(edges) - edge\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809174,
                "title": "simple-and-clear-union-find-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass dsu{\\n    public:\\n    int *rank;\\n    int *parent;\\n    int n;\\n    dsu(int n){\\n        this->n=n;\\n        rank=new int[n];\\n        parent=new int[n];\\n        for(int i=0;i<n;i++){\\n            rank[i]=0;\\n            parent[i]=i;\\n        }\\n    }\\n    int findparent(int u){\\n        if(u==parent[u]) return u;\\n        return parent[u]=findparent(parent[u]);\\n    }\\n    bool unionByRank(int u,int v){\\n        u=findparent(u);\\n        v=findparent(v);\\n        if(u==v) return 0;\\n        if(rank[u]>=rank[v]){\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n        else{\\n            parent[u]=v;\\n            rank[v]++;\\n        }\\n        return 1;\\n    }\\n    int countcomponents(){\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i) count++;\\n        }\\n        return count;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        dsu dsu1(n),dsu2(n);\\n        int ans=0;\\n        int m=edges.size();\\n        sort(edges.begin(),edges.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]>b[0];\\n        });\\n        for(int i=0;i<m;i++){\\n            int t=edges[i][0];\\n            int u=edges[i][1];\\n            int v=edges[i][2];\\n            --u;\\n            --v;\\n            if(t==3){\\n                dsu1.unionByRank(u,v);\\n                ans+=dsu2.unionByRank(u,v);\\n                \\n            }\\n            else{\\n                if(t==1) ans+=dsu1.unionByRank(u,v);\\n                else ans+=dsu2.unionByRank(u,v);\\n            }\\n        }\\n        if(dsu1.countcomponents()>1 || dsu2.countcomponents()>1) return -1;\\n        return m-ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Union Find"
                ],
                "code": "```\\nclass dsu{\\n    public:\\n    int *rank;\\n    int *parent;\\n    int n;\\n    dsu(int n){\\n        this->n=n;\\n        rank=new int[n];\\n        parent=new int[n];\\n        for(int i=0;i<n;i++){\\n            rank[i]=0;\\n            parent[i]=i;\\n        }\\n    }\\n    int findparent(int u){\\n        if(u==parent[u]) return u;\\n        return parent[u]=findparent(parent[u]);\\n    }\\n    bool unionByRank(int u,int v){\\n        u=findparent(u);\\n        v=findparent(v);\\n        if(u==v) return 0;\\n        if(rank[u]>=rank[v]){\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n        else{\\n            parent[u]=v;\\n            rank[v]++;\\n        }\\n        return 1;\\n    }\\n    int countcomponents(){\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i) count++;\\n        }\\n        return count;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        dsu dsu1(n),dsu2(n);\\n        int ans=0;\\n        int m=edges.size();\\n        sort(edges.begin(),edges.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]>b[0];\\n        });\\n        for(int i=0;i<m;i++){\\n            int t=edges[i][0];\\n            int u=edges[i][1];\\n            int v=edges[i][2];\\n            --u;\\n            --v;\\n            if(t==3){\\n                dsu1.unionByRank(u,v);\\n                ans+=dsu2.unionByRank(u,v);\\n                \\n            }\\n            else{\\n                if(t==1) ans+=dsu1.unionByRank(u,v);\\n                else ans+=dsu2.unionByRank(u,v);\\n            }\\n        }\\n        if(dsu1.countcomponents()>1 || dsu2.countcomponents()>1) return -1;\\n        return m-ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770499,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU{\\n    int comp;\\n    vector<int> par,depth;\\n    public:\\n    DSU(int n){\\n        comp=n;\\n        par.assign(n+1,0);\\n        depth.assign(n+1,0);\\n        for(int i=1;i<=n;i++)par[i]=i;\\n    }\\n    int find_par(int node){\\n        if(par[node]==node)return node;\\n        return  par[node]=find_par(par[node]);\\n    }\\n    void make_union(int u,int v){\\n        u=find_par(u);\\n        v=find_par(v);\\n        if(u==v)return;\\n        if(depth[u]>depth[v])swap(u,v);\\n        par[u]=v;\\n        if(depth[u]==depth[v])depth[v]++;\\n        comp--;\\n    }\\n    int find_comp(){\\n        return comp;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int m=edges.size();\\n        int cont_edges=0;\\n        int rest=0;\\n        \\n        DSU dsu1(n);\\n        DSU dsu2(n);\\n        int t=0;\\n        int main=1;\\n        vector<pair<int,int>> alice,bob;\\n        for(int i=0;i<m;i++){\\n            int type=edges[i][0];\\n            int u=edges[i][1];\\n            int v=edges[i][2];\\n            if(type==1){\\n                alice.push_back({u,v});\\n            }\\n            if(type==2){\\n                bob.push_back({u,v});\\n            }\\n            if(type!=3)continue;\\n            if(dsu1.find_par(u)==dsu1.find_par(v)){continue;}\\n            cont_edges++;\\n            \\n            dsu1.make_union(u,v);\\n            dsu2.make_union(u,v);\\n        }\\n       \\n        int comp=dsu1.find_comp();\\n         comp--;\\n        for(auto it:alice){\\n            dsu1.make_union(it.first,it.second);\\n        }\\n        for(auto it:bob){\\n            dsu2.make_union(it.first,it.second);\\n        }\\n        if(dsu1.find_comp()!=1 || dsu2.find_comp()!=1)return -1;\\n        m-=t;\\n        if(2*comp+cont_edges>m)return -1;\\n        return m-(2*comp+cont_edges);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DSU{\\n    int comp;\\n    vector<int> par,depth;\\n    public:\\n    DSU(int n){\\n        comp=n;\\n        par.assign(n+1,0);\\n        depth.assign(n+1,0);\\n        for(int i=1;i<=n;i++)par[i]=i;\\n    }\\n    int find_par(int node){\\n        if(par[node]==node)return node;\\n        return  par[node]=find_par(par[node]);\\n    }\\n    void make_union(int u,int v){\\n        u=find_par(u);\\n        v=find_par(v);\\n        if(u==v)return;\\n        if(depth[u]>depth[v])swap(u,v);\\n        par[u]=v;\\n        if(depth[u]==depth[v])depth[v]++;\\n        comp--;\\n    }\\n    int find_comp(){\\n        return comp;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int m=edges.size();\\n        int cont_edges=0;\\n        int rest=0;\\n        \\n        DSU dsu1(n);\\n        DSU dsu2(n);\\n        int t=0;\\n        int main=1;\\n        vector<pair<int,int>> alice,bob;\\n        for(int i=0;i<m;i++){\\n            int type=edges[i][0];\\n            int u=edges[i][1];\\n            int v=edges[i][2];\\n            if(type==1){\\n                alice.push_back({u,v});\\n            }\\n            if(type==2){\\n                bob.push_back({u,v});\\n            }\\n            if(type!=3)continue;\\n            if(dsu1.find_par(u)==dsu1.find_par(v)){continue;}\\n            cont_edges++;\\n            \\n            dsu1.make_union(u,v);\\n            dsu2.make_union(u,v);\\n        }\\n       \\n        int comp=dsu1.find_comp();\\n         comp--;\\n        for(auto it:alice){\\n            dsu1.make_union(it.first,it.second);\\n        }\\n        for(auto it:bob){\\n            dsu2.make_union(it.first,it.second);\\n        }\\n        if(dsu1.find_comp()!=1 || dsu2.find_comp()!=1)return -1;\\n        m-=t;\\n        if(2*comp+cont_edges>m)return -1;\\n        return m-(2*comp+cont_edges);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743860,
                "title": "simple-union-find-c-easy-to-understand",
                "content": "# Explanation\\n\\nAdd Type3 first, then check Type 1 and Type 2.\\n\\n\\nIf Alice\\'s\\'graph is connected, e1 == n - 1 should valid.\\nIf Bob\\'s graph is connected, e2 == n - 1 should valid.\\nIn this case we return res,\\notherwise return -1.\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> root;\\n    int find(int i) {\\n        if(i != root[i])\\n            root[i] = find(root[i]);\\n        return root[i];\\n    }\\n    \\n    bool uni(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return false;\\n        root[x] = y;\\n        return true;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int res = 0, e1 = 0, e2 = 0;\\n        root.resize(n+1);\\n        iota(root.begin(), root.end(), 0);  \\n\\n        // For type 3\\n        for(auto edge : edges){\\n            int t = edge[0], i = edge[1], j = edge[2];\\n            if(t == 3){\\n                if(uni(i-1, j-1)) e1++, e2++;\\n                else res++;\\n            }\\n        }\\n        vector<int> root0 = root;  \\n\\n        // For type 1 (Alice)\\n        for(auto edge : edges){\\n            int t = edge[0], i = edge[1], j = edge[2];\\n            if(t == 1){\\n                if(uni(i-1, j-1)) e1++;\\n                else res++;\\n            }\\n        }\\n\\n        // Reset root to root0 for Bob\\n        root = root0;\\n\\n        // For type 2 (Bob)\\n        for(auto edge : edges){\\n            int t = edge[0], i = edge[1], j = edge[2];\\n            if(t == 2){\\n                if(uni(i-1, j-1)) e2++;\\n                else res++;\\n            }\\n        }\\n\\n        return (e1 == n-1 && e2 == n-1) ? res : -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> root;\\n    int find(int i) {\\n        if(i != root[i])\\n            root[i] = find(root[i]);\\n        return root[i];\\n    }\\n    \\n    bool uni(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return false;\\n        root[x] = y;\\n        return true;\\n    }\\npublic:\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        int res = 0, e1 = 0, e2 = 0;\\n        root.resize(n+1);\\n        iota(root.begin(), root.end(), 0);  \\n\\n        // For type 3\\n        for(auto edge : edges){\\n            int t = edge[0], i = edge[1], j = edge[2];\\n            if(t == 3){\\n                if(uni(i-1, j-1)) e1++, e2++;\\n                else res++;\\n            }\\n        }\\n        vector<int> root0 = root;  \\n\\n        // For type 1 (Alice)\\n        for(auto edge : edges){\\n            int t = edge[0], i = edge[1], j = edge[2];\\n            if(t == 1){\\n                if(uni(i-1, j-1)) e1++;\\n                else res++;\\n            }\\n        }\\n\\n        // Reset root to root0 for Bob\\n        root = root0;\\n\\n        // For type 2 (Bob)\\n        for(auto edge : edges){\\n            int t = edge[0], i = edge[1], j = edge[2];\\n            if(t == 2){\\n                if(uni(i-1, j-1)) e2++;\\n                else res++;\\n            }\\n        }\\n\\n        return (e1 == n-1 && e2 == n-1) ? res : -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1877481,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877893,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877497,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877507,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877483,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877533,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877521,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877846,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877490,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877520,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877481,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877893,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877497,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877507,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877483,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877533,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877521,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877846,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877490,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877520,
                "content": [
                    {
                        "username": "Minamikaze392",
                        "content": "LeetCode doesn\\'t want us to have proper holidays."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose there are two separate graphs for Alice and Bob. Alice's graph contains edges of Type 1 and Type 3. Bob's graph contains edges of Type 2 and Type 3. Try to solve this simpler problem for both, where types will not matter anymore.\n\n# Hint 2\nSuppose we had to add some $edges[i]$ ($0 \\le i < j$) in our graph because removing any one of them would have created an unreachable node. How can we decide whether we have to add $edges[j]=[a,b]$ or we can skip it?\n\n# Hint 3\nLet's say we had to add edges $[[1,2],[1,3],[1,4]]$. So, we can traverse any source to destination pair in $[1,2,3,4]$ as they belong to same component. And now comes another edge $[2,3]$. But we don't care that we can traverse directly $2 \\leftrightarrow 3$ that we were doing via $1$ before ($2 \\leftrightarrow 1 \\leftrightarrow 3$). We don't have to keep this edge and we can safely remove it because $2$ and $3$ already belong to same component and there is a path no matter how long.\n\n# Hint 4\nHow can we know if for edge $[a,b]$, there is already a path between $a$ and $b$ or if they already belong to the same component? Yes, we can do traversal but we know it's redundant work again and again. We can make disjoint sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). We should add the new edge only if there was no path between $a$ and $b$ using edges added before. Adding a new edge means taking union of those two disjoint sets.\n\n# Hint 5\nIf there are all three types of edges between $a \\leftrightarrow b$, then we should keep only Type 3 as it can be used by both Alice and Bob and we will be able to delete two edges. So, Type 3 has lowest priority to be removed. So, first add all Type 3 edges $[3,a,b]$ in both graphs of Alice and Bob when there is not already a path between $a$ and $b$.\n\n# Hint 6\nNow, add all Type 1 edges $[1,a,b]$ to Alice's graph if there is not already a path between $a$ and $b$. Same for Bob. At last, if both graphs are completely connected then answer is $totalEdges - edgesNeeded$, else $-1$.\n\nUpvote if helps!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) You\\'re welcome! Maybe check if you\\'re doing path compression while finding parent and pass big arguments by reference everywhere. You can also send your code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513) Really appreciate the detailed hints for all the problems helps me out a lot, without having to look at the solution. For this one I am still getting TLE though, any hints on optimizing for speed? I feel like I do to many find operations, but I also feel I need them... getting to test case 83."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@jumadaru](/jumadaru) nah there is no time limit\\n"
                    },
                    {
                        "username": "jumadaru",
                        "content": "After working all that process will be a problem the time limit."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "3 Hard per week is the pattern now babe."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Daily problems increase in difficulty toward the weekend, especially toward the end of the month. Next few weeks will be easier."
                    },
                    {
                        "username": "user8228j",
                        "content": "its very similar to yesterdays question, i couldn\\'t solve yesterdays and looked at the solution, and doing so made todays much easier\\nFor reference for those not doing the daily: 1697. Checking Existence of Edge Length Limited Paths"
                    },
                    {
                        "username": "aesteve",
                        "content": "Same here! \\n\\nNow I\\'m wondering whether I\\'d have found the intuition without the \"streak\" effect.\\n\\nI guess I\\'ll have to put it on the \"Re-Check intuition later\" todo list!"
                    },
                    {
                        "username": "kennysliding",
                        "content": "I\\'m starting to love these UF problems lol"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "incoming permanent brain/emotional damages"
                    },
                    {
                        "username": "WildPikachu",
                        "content": "I just want to say thanks LC. These daily challenges have been really helpful in keeping me in the loop."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "also they seem to be topic wise too... last three days being DSU, earlier DP week helped me a lot with dp."
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC really wants us to learn Union Find huh"
                    },
                    {
                        "username": "kennysliding",
                        "content": "hint: if you are looking to solve this question with union-find algorithm, you may also want to look at how to optimize it with path compression and union by size/rank. \n\nThis question has a good test case that a vanilla union-find algorithm will result in TLE.\n\nI love it when a test case forces you to go beyond just the implementation but also the optimization."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Also while rank is technically slightly more efficient, in this question I think doing size is better, since you can use the size information at the end to get your final answer. "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Crap Man, not another DSU/UF problem, and it is a 3rd in a row, I am screwed!!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "New algorithm just dropped: 3 Hards per week"
                    }
                ]
            },
            {
                "id": 1877951,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1878088,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1878065,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1877487,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1879402,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1879261,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1878606,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1878135,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1878079,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1878074,
                "content": [
                    {
                        "username": "denar50",
                        "content": "Honestly, UF problems become really easy as you progress through them. Looking back at when I first started these were very painful, but not anymore. Keep it up people! it will get better!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "very similar to yesterday ques, \\nHint: sort the edges 3,2,1;"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "Hard  Hard  Hard \\uD83D\\uDE33"
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on every weekend now? The guy in charge of setting daily questions definitely hates humanity!"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can anyone tell where my code is going wrong . \npls help me out . It's failing on the 23 test case .\n[Question Link ](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942694449/)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "In Union() function, `parent[a] = parentB` you're making parent of A as parentB. Instead, parentB must be the parent of complete component in which A is right now. So make parent of parentA as parentB `parent[parentA] = parentB`.\nThis will be TLE in last 4 test cases, to remove that study path compression [here](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide).\nFinal [code](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/submissions/942714849/)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "my last testcase is giving tle \\nbut the input slot is empty There is no input given from server\\n\\ncan anyone tell me what is the problem ?"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "It might be unethical but if somebody is solving this last minute use this for 82/85\n```\n        if n == 66666:\n            return 0\n```"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Really nice question... the reason why I love solving problems."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Someday I will come back to you and defeat you, but not today."
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "Before this weekend I didn\\'t even know about existence of the DSU data structure and now, I want to apply it to every single problem I encounter in my life!"
                    }
                ]
            },
            {
                "id": 1877486,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1877485,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1974010,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1880392,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1880159,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1879609,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1878459,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1878444,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1878371,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1878355,
                "content": [
                    {
                        "username": "leetcodingm",
                        "content": "i guess leetcode wants us to be experts in union find "
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "three hard union find in a row? Bye bye streak :("
                    },
                    {
                        "username": "tri_jal",
                        "content": "Mine isn\\'t the most optimized approach but could someone please tell me what\\'s wrong in my code, I\\'m getting 0 as the output for all the valid cases (for invalid I get -1 but that\\'s obvious because of the check that I have put in the end).\\n`class Solution {\\npublic:\\n    vector<int> temp1,temp2;\\n    static bool cmp(vector<int>&a, vector<int>& b){\\n        return a[0]>b[0];\\n    }\\n\\n    int findP(vector<int>& parent, int num){\\n        if(parent[num]==num){\\n            return num;\\n        }\\n        return findP(parent,parent[num]);\\n    }\\n\\n    int solveAlice(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==1){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp1=parent;\\n        return count;\\n    }\\n\\n    int solveBob(vector<vector<int>>& edges,vector<int> rank, vector<int>parent){\\n        int count=0;\\n        for(auto it : edges){\\n            if(it[0]==2){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                    count++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                    count++;\\n                }\\n            }\\n        }\\n        temp2=parent;\\n        return count;\\n    }\\n\\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        vector<int> rank(n+1,1);\\n        vector<int> parent(n+1,0);\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            parent[i]=i;\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        for(auto it : edges){\\n            if(it[0]==3){\\n                if(findP(parent,it[1])==findP(parent,it[2])) continue;\\n                if(rank[it[1]]<rank[it[2]]){\\n                    parent[it[1]]=parent[it[2]];\\n                    rank[it[2]]++;\\n                }\\n                else{\\n                    parent[it[2]]=parent[it[1]];\\n                    rank[it[1]]++;\\n                }\\n                count++;\\n            }\\n        }\\n        int a=solveAlice(edges,rank,parent);\\n        int b=solveBob(edges,rank,parent);\\n        for(int i=2;i<=n;i++){\\n            if(parent[i]!=parent[1] && parent[1]!=temp1[i] && parent[1]!=temp2[i]){\\n                return -1;\\n            }\\n        }\\n        return (n-(count+a+b));\\n    }\\n}; `"
                    },
                    {
                        "username": "SunlessCrane",
                        "content": "idk if its just me, but green edges always give me a feeling like they are the ones both players can use..."
                    },
                    {
                        "username": "katalma",
                        "content": "In the last couple of weeks, all the weekends were full of hard problems. For a family person, the weekend is full of family events which can not be postponed for a leetcode or something. Now 3 hard problem in a row for Friday, Saturday and Sunday. Eeeee "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "please help me  why this code is giving wrong answer thanks:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size,rank;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n    }\\n    void unionbyrank(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return;\\n        if(rank[ult_u]<rank[ult_v]){\\n            parent[ult_u]=ult_v;\\n\\n        }\\n        else\\n        if(rank[ult_v]<rank[ult_u]){\\n            parent[ult_v]=ult_u;\\n\\n        }\\n        else{\\n            parent[ult_u]=ult_v;\\n            rank[ult_v]++;\\n        }\\n        \\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\\n        sort(edges.begin(),edges.end(),[&](vector<int>&a,vector<int>&b){\\n       return a[0]>b[0];\\n       }\\n        );\\n        disjointset *al=new disjointset(n);\\n        disjointset *bob=new disjointset(n);\\n        int c=0;\\n        for(auto i:edges){\\n            if((al->findp(i[1])==al->findp(i[2]))&&(bob->findp(i[1])==bob->findp(i[2]))){\\n                c++;\\n                continue;\\n                \\n            }\\n            if(i[0]==3){\\n                al->unionbysize(i[1],i[2]);\\n                bob->unionbysize(i[1],i[2]);\\n                \\n            }\\n            else\\n            if(i[0]==2)bob->unionbysize(i[1],i[2]);\\n            else\\n            al->unionbysize(i[1],i[2]);\\n\\n\\n        }\\n        if((al->size[al->findp(1)]==n)&&(bob->size[bob->findp(1)]==n))return c;\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "No ! not another Union FInd problem T_T"
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone explain this line , what exactly it doing ?\\n(Alice.performUnion(edge[1], edge[2]) | Bob.performUnion(edge[1], edge[2])"
                    },
                    {
                        "username": "King_Pin",
                        "content": "lowkey loving these hard union find daily problems onslaught by lc"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I kept getting TLE with my UnionFind function, so I finally asked GPT how I could implement it with path compression. Only difference was in the find function. I had to replace this: \\n```\\n const find = (i) => {\\n        if( parents[i] !== i) {\\n            return find(parents[i])\\n        }\\n        return i\\n    }\\n```\\nwith this:\\n```\\nconst find = (i) => {\\n    if (parents[i] !== i) {\\n        parents[i] = find(parents[i])\\n    }\\n    return parents[i]\\n}\\n```\\nIt shaved a ton of my runtime and my code passed. Sharing it here because it was such a major improvement with such a minor change. All tutorials/videos/examples I found for path compression were much more complicated. \\n\\n(GPT is truly amazing)"
                    }
                ]
            },
            {
                "id": 1878347,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1878341,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1878332,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1878297,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1878284,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1878159,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1878147,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1878141,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1878047,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1878044,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "These problem make me uncomfortable."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard extreme\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "badge += 1"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "why are we taking union of edges of type 3 first???\\ncant understand why order of union matters for the types?? "
                    },
                    {
                        "username": "zdzichukowalski",
                        "content": "You kill two birds with one stone. When adding one type 3 edge then you += 1 to the count of the used edges. But to get the same effect that type 3 gives you you would need one type 1 and one type 2 edges, and you can end up adding two to the sum instead of one. Check hint 2/4 on top of the page. You stop extending Alice's graph when you make it into a tree (or run out of the edges). In general the order of edges does not matter when you want to check if you can make a tree. But in our case using type 3 first will be more economic. And the problem demands to return the most economic solution."
                    },
                    {
                        "username": "Diamantis",
                        "content": "April weekends rip :\\'c"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "ufff, wasted an hour because of not realizing that the nodes begin from **1** as opposed to the usual 0 \\uD83D\\uDE2A\\uD83D\\uDE2A"
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "sed lyf >_<\\n"
                    },
                    {
                        "username": "GD18",
                        "content": "bruh enough with the hards already ;_;"
                    },
                    {
                        "username": "madiii",
                        "content": "Got DCC April badge. \\n\\nHint: I was getting a TLE because I was using a n^2 to check if the graphs are connected for alice n bob. We can check that by keeping a count of components for both graph and reducing component value by 1 whenever a union operation is performed."
                    },
                    {
                        "username": "halfengineer",
                        "content": "lets appreciate leetcode is brushing up some good algorithm topics for us..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "The hints are helpful this time, you can solve it with the hints, don\\'t jump too quickly to the solution just yet."
                    }
                ]
            },
            {
                "id": 1877977,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            },
            {
                "id": 1877972,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            },
            {
                "id": 1877954,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            },
            {
                "id": 1877902,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            },
            {
                "id": 1877870,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            },
            {
                "id": 1877867,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            },
            {
                "id": 1877864,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            },
            {
                "id": 1877848,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            },
            {
                "id": 1877826,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            },
            {
                "id": 1877800,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "*\"Alice and Bob have an undirected graph...\"*\\nThis is how typical IT love story starts."
                    },
                    {
                        "username": "trpaslik",
                        "content": "freaking HARD WEEK it is!"
                    },
                    {
                        "username": "jumadaru",
                        "content": "It is demonstrated there is no feedback in this portal."
                    },
                    {
                        "username": "vnk01",
                        "content": "plot twist: node number start with 1 !!!"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Bro, why are you so angry with us kids, Leetcode?\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83E\\uDD79\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was very hard\\n"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Leetcode want us to be very good in graphs and dp.....\\uD83E\\uDD72\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "asim35",
                        "content": "Bro Bro, how many more union find ...."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Can someone kindly put some effort to explain the problem description easily? Can\\'t quite get my head around it. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "My brain hurts so good. Come on, leetcode, make it hurt so good."
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove One Element to Make the Array Strictly Increasing",
        "question_content": "<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, return <code>true</code> <em>if it can be made <strong>strictly increasing</strong> after removing <strong>exactly one</strong> element, or </em><code>false</code><em> otherwise. If the array is already strictly increasing, return </em><code>true</code>.</p>\n\n<p>The array <code>nums</code> is <strong>strictly increasing</strong> if <code>nums[i - 1] &lt; nums[i]</code> for each index <code>(1 &lt;= i &lt; nums.length).</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,<u>10</u>,5,7]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> By removing 10 at index 2 from nums, it becomes [1,2,5,7].\n[1,2,5,7] is strictly increasing, so return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong>\n[3,1,2] is the result of removing the element at index 0.\n[2,1,2] is the result of removing the element at index 1.\n[2,3,2] is the result of removing the element at index 2.\n[2,3,1] is the result of removing the element at index 3.\nNo resulting array is strictly increasing, so return false.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The result of removing any element is [1,1].\n[1,1] is not strictly increasing, so return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1299306,
                "title": "two-conditions",
                "content": "When we find a drop, we check if the current number `nums[i]` is greater than the number before the previous one `nums[i - 2]`. \\n\\n1. If so, the number `nums[i - 1]` needs to be removed.\\n2. Otherwise, the current number needs to be removed (`nums[i]`).\\n\\t- For simplicity, I just assign the previous value to the current number (`nums[i] = nums[i - 1]`).\\n\\nAnd, of course, we return `false` if we find a second drop.\\n\\n**C++**\\n```cpp\\nbool canBeIncreasing(vector<int>& nums) {\\n    int cnt = 0;\\n    for (int i = 1; i < nums.size() && cnt < 2; ++i) {\\n        if (nums[i - 1] >= nums[i]) {\\n            ++cnt;\\n            if (i > 1 && nums[i - 2] >= nums[i])\\n                nums[i] = nums[i - 1];\\n        }\\n    }\\n    return cnt < 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool canBeIncreasing(vector<int>& nums) {\\n    int cnt = 0;\\n    for (int i = 1; i < nums.size() && cnt < 2; ++i) {\\n        if (nums[i - 1] >= nums[i]) {\\n            ++cnt;\\n            if (i > 1 && nums[i - 2] >= nums[i])\\n                nums[i] = nums[i - 1];\\n        }\\n    }\\n    return cnt < 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298443,
                "title": "c-o-n-one-pass-explained-multiple-solutions",
                "content": "# O(n), one pass\\nWhen we find two consecutive elements which are not increasing, we have to analyze which one should be removed. If possible we should remove the bigger element.\\nEx: [1, 7, 2, 3] - we should remove 7 when we analyze [7, 2]\\n[6, 7, 2, 3] - we can\\'t remove 7 when we analyze [7, 2] because 2 <= 6\\n```\\nbool canBeIncreasing(vector<int>& nums) {\\n\\tint previous = nums[0];\\n\\tbool used = false;\\n\\tfor (int i = 1; i < nums.size(); i++){\\n\\t\\tif (nums[i] <= previous){ // it\\'s not strictly increasing\\n            if (used)\\n                return false;\\n\\t\\t\\t// we haven\\'t used the element removal yet.\\n            used = true;\\n            if (i == 1 || nums[i] > nums[i - 2]) // we remove the element from i - 1 position because it\\'s bigger, so we update previous.\\n                previous = nums[i];\\n            // else we remove current element and leave previous to it\\'s existing value.\\n\\t\\t} else\\n\\t\\t\\tprevious = nums[i];\\n\\t}\\n\\treturn true;\\n}\\n```\\n# Other O(n) solution\\nWhen we find two consecutive elements that are not strictly increasing, we have to remove one of them.\\nWe just try removing the first and see if the array is strictly increasing. If not, we try removing the second one.\\nComplexity is still O(n) although in the worst case scenario it passes through the array 5 times.\\n```\\nbool canBeIncreasing(vector<int>& nums) {\\n\\tfor (int i = 1; i < nums.size(); i++)\\n\\t\\tif (nums[i] <= nums[i - 1])\\n\\t\\t\\treturn isIncreasing(removeElement(nums, i - 1)) ||\\n\\t\\t\\t\\tisIncreasing(removeElement(nums, i));\\n\\treturn true;\\n}\\nvector<int> removeElement(vector<int> &nums, int removedPoz){\\n\\tvector<int> ans;\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t\\tif (i != removedPoz)\\n\\t\\t\\tans.push_back(nums[i]);\\n\\treturn ans;\\n}\\nbool isIncreasing(vector<int> nums){\\n\\tfor (int i = 1; i < nums.size(); i++)\\n\\t\\tif (nums[i] <= nums[i - 1])\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\\n# Brute Force, square complexity\\nFor every element of the array we check whether the array without that element is strictly increasing.\\n```\\nbool canBeIncreasing(vector<int>& nums) {\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t\\tif (isIncreasing(removeElement(nums, i)))\\n\\t\\t\\treturn true;\\n\\treturn false;\\n}\\nvector<int> removeElement(vector<int> &nums, int removedPoz){\\n\\tvector<int> ans;\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t\\tif (i != removedPoz)\\n\\t\\t\\tans.push_back(nums[i]);\\n\\treturn ans;\\n}\\nbool isIncreasing(vector<int> nums){\\n\\tfor (int i = 1; i < nums.size(); i++)\\n\\t\\tif (nums[i] <= nums[i - 1])\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\\nThis is also accepted although it uses a lot more time and memory. Running times can vary based on system load, but here are the values I encountered:\\nFirst solution uses 0 ms and 9.9 MB\\nSecond solution uses 8 ms and 10.4 MB\\nThird solution uses 384 ms and 158.6 MB",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canBeIncreasing(vector<int>& nums) {\\n\\tint previous = nums[0];\\n\\tbool used = false;\\n\\tfor (int i = 1; i < nums.size(); i++){\\n\\t\\tif (nums[i] <= previous){ // it\\'s not strictly increasing\\n            if (used)\\n                return false;\\n\\t\\t\\t// we haven\\'t used the element removal yet.\\n            used = true;\\n            if (i == 1 || nums[i] > nums[i - 2]) // we remove the element from i - 1 position because it\\'s bigger, so we update previous.\\n                previous = nums[i];\\n            // else we remove current element and leave previous to it\\'s existing value.\\n\\t\\t} else\\n\\t\\t\\tprevious = nums[i];\\n\\t}\\n\\treturn true;\\n}\\n```\n```\\nbool canBeIncreasing(vector<int>& nums) {\\n\\tfor (int i = 1; i < nums.size(); i++)\\n\\t\\tif (nums[i] <= nums[i - 1])\\n\\t\\t\\treturn isIncreasing(removeElement(nums, i - 1)) ||\\n\\t\\t\\t\\tisIncreasing(removeElement(nums, i));\\n\\treturn true;\\n}\\nvector<int> removeElement(vector<int> &nums, int removedPoz){\\n\\tvector<int> ans;\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t\\tif (i != removedPoz)\\n\\t\\t\\tans.push_back(nums[i]);\\n\\treturn ans;\\n}\\nbool isIncreasing(vector<int> nums){\\n\\tfor (int i = 1; i < nums.size(); i++)\\n\\t\\tif (nums[i] <= nums[i - 1])\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\n```\\nbool canBeIncreasing(vector<int>& nums) {\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t\\tif (isIncreasing(removeElement(nums, i)))\\n\\t\\t\\treturn true;\\n\\treturn false;\\n}\\nvector<int> removeElement(vector<int> &nums, int removedPoz){\\n\\tvector<int> ans;\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t\\tif (i != removedPoz)\\n\\t\\t\\tans.push_back(nums[i]);\\n\\treturn ans;\\n}\\nbool isIncreasing(vector<int> nums){\\n\\tfor (int i = 1; i < nums.size(); i++)\\n\\t\\tif (nums[i] <= nums[i - 1])\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387010,
                "title": "java-easy-to-understand-solution-well-explained-with-picture-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/e802e72a-834a-40f4-aed0-2c64819543a5_1631526224.4784555.jpeg)\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count=0;\\n        int p=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]>nums[i+1] || nums[i]==nums[i+1]) {\\n                count++;\\n                p=i;\\n            }\\n        }\\n        if(count>1) return false;\\n        else if(count==1){\\n            if(p==0 || p== nums.length-2) return true;\\n            if(nums[p+1]>nums[p-1] || nums[p+2]>nums[p]) return true;\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**Do upvote if you find it helpful!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count=0;\\n        int p=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]>nums[i+1] || nums[i]==nums[i+1]) {\\n                count++;\\n                p=i;\\n            }\\n        }\\n        if(count>1) return false;\\n        else if(count==1){\\n            if(p==0 || p== nums.length-2) return true;\\n            if(nums[p+1]>nums[p-1] || nums[p+2]>nums[p]) return true;\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298517,
                "title": "python-explained-easy-to-understand-o-n-time-and-o-1-space",
                "content": "![image](https://assets.leetcode.com/users/images/048b6e17-a74f-47c9-86e3-c4c2c9069bf7_1624723377.9367077.png)\\n\\nThe Full Code:\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        indx = -1\\n        count = 0\\n        n = len(nums)\\n        \\n        # count the number of non-increasing elements\\n        for i in range(n-1):\\n            if nums[i] >= nums[i+1]:\\n                indx = i\\n                count += 1\\n        \\n        #the cases explained above\\n        if count==0:\\n            return True\\n        \\n        if count == 1:\\n            if indx == 0 or indx == n-2:\\n                return True\\n            if nums[indx-1] < nums[indx+1] or(indx+2 < n and nums[indx] < nums[indx+2]):\\n                return True\\n            \\n        return False\\n```\\nTime: O(n) for counting the number of non-increasing elements.\\nSpace = O(1).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        indx = -1\\n        count = 0\\n        n = len(nums)\\n        \\n        # count the number of non-increasing elements\\n        for i in range(n-1):\\n            if nums[i] >= nums[i+1]:\\n                indx = i\\n                count += 1\\n        \\n        #the cases explained above\\n        if count==0:\\n            return True\\n        \\n        if count == 1:\\n            if indx == 0 or indx == n-2:\\n                return True\\n            if nums[indx-1] < nums[indx+1] or(indx+2 < n and nums[indx] < nums[indx+2]):\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298607,
                "title": "c-simple-o-n-with-comments",
                "content": "When we find out of order element, there can be two scenarios : **keep i th element or keep i-1 the element.**\\n\\n\\n1. When it\\'s better to keep the i th element? only if its greater than i-2 nd element as that will help in producing the strictly increasing array. (Also we know that it\\'s out of order, so its less than i-1th element for sure, hence greedily better for numbers ahead).\\n\\n2. When it\\'s better to choose i-1 th element : Only If above isn\\'t true then we need to keep i-1 th element and discard the ith element. \\n\\n\\nCode without comments:\\n```\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        int count = 0;\\n        for(int i = 1; i < nums.size(); i++){            \\n            \\n            if(nums[i] <= nums[i-1]){\\n                \\n                if(count == 1)\\n                    return false;\\n                \\n                if( i >= 2 && nums[i-2] >= nums[i])\\n                    nums[i] = nums[i-1];\\n                \\n                count++;\\n            }            \\n        }\\n        \\n        return count <= 1;        \\n    }\\n```\\n\\n\\nCode with comments:\\n```        \\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        int count = 0;\\n        for(int i = 1; i < nums.size(); i++){            \\n            \\n            if(nums[i] <= nums[i-1]){\\n                \\n                //more than one element out of order\\n                if(count == 1)\\n                    return false;\\n                \\n                //Found one out of order element \\n                //Is i -2 th element greater than i th element?\\n                //if yes then we have to delete i th element (simply replace it by i-1 element).                \\n                //N.B. i-1 is mating the increasing scenario for sure (count == 1 check.)\\n                if( i >= 2 && nums[i-2] >= nums[i])\\n                    nums[i] = nums[i-1];\\n                \\n                count++;\\n            }            \\n        }\\n        \\n        return count <= 1;        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        int count = 0;\\n        for(int i = 1; i < nums.size(); i++){            \\n            \\n            if(nums[i] <= nums[i-1]){\\n                \\n                if(count == 1)\\n                    return false;\\n                \\n                if( i >= 2 && nums[i-2] >= nums[i])\\n                    nums[i] = nums[i-1];\\n                \\n                count++;\\n            }            \\n        }\\n        \\n        return count <= 1;        \\n    }\\n```\n```        \\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        int count = 0;\\n        for(int i = 1; i < nums.size(); i++){            \\n            \\n            if(nums[i] <= nums[i-1]){\\n                \\n                //more than one element out of order\\n                if(count == 1)\\n                    return false;\\n                \\n                //Found one out of order element \\n                //Is i -2 th element greater than i th element?\\n                //if yes then we have to delete i th element (simply replace it by i-1 element).                \\n                //N.B. i-1 is mating the increasing scenario for sure (count == 1 check.)\\n                if( i >= 2 && nums[i-2] >= nums[i])\\n                    nums[i] = nums[i-1];\\n                \\n                count++;\\n            }            \\n        }\\n        \\n        return count <= 1;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298827,
                "title": "java-short",
                "content": "```\\npublic boolean canBeIncreasing(int[] nums) {\\n\\tboolean removed = false;\\n\\tfor(int i=1;i<nums.length;i++)\\n\\t\\tif(nums[i] <= nums[i-1]) {  \\n\\t\\t\\tif(removed) return false;\\n\\t\\t\\tremoved = true;\\n\\t\\t\\tif (i>1 && nums[i] <= nums[i-2])\\n\\t\\t\\t\\tnums[i] = nums[i-1];\\n\\t\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canBeIncreasing(int[] nums) {\\n\\tboolean removed = false;\\n\\tfor(int i=1;i<nums.length;i++)\\n\\t\\tif(nums[i] <= nums[i-1]) {  \\n\\t\\t\\tif(removed) return false;\\n\\t\\t\\tremoved = true;\\n\\t\\t\\tif (i>1 && nums[i] <= nums[i-2])\\n\\t\\t\\t\\tnums[i] = nums[i-1];\\n\\t\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362860,
                "title": "c-easy-to-understand-fast-and-efficient-code",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\nint count = 0;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] <= nums[i - 1]) {\\n                if (count == 1) \\n                    return false;\\n                count++;\\n                if (i > 1 && nums[i] <= nums[i - 2] )\\n                    nums[i] = nums[i - 1];\\n            }\\n        }\\n        return true;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\nint count = 0;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] <= nums[i - 1]) {\\n                if (count == 1) \\n                    return false;\\n                count++;\\n                if (i > 1 && nums[i] <= nums[i - 2] )\\n                    nums[i] = nums[i - 1];\\n            }\\n        }\\n        return true;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298457,
                "title": "python3-collect-non-conforming-indices",
                "content": "\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        stack = []\\n        for i in range(1, len(nums)): \\n            if nums[i-1] >= nums[i]: stack.append(i)\\n                \\n        if not stack: return True \\n        if len(stack) > 1: return False\\n        i = stack[0]\\n        return (i == 1 or nums[i-2] < nums[i]) or (i+1 == len(nums) or nums[i-1] < nums[i+1])\\n```\\n\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        prev, seen = -inf, False\\n        for i, x in enumerate(nums): \\n            if prev < x: prev = x\\n            else: \\n                if seen: return False \\n                seen = True \\n                if i == 1 or nums[i-2] < x: prev = x\\n        return True \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        stack = []\\n        for i in range(1, len(nums)): \\n            if nums[i-1] >= nums[i]: stack.append(i)\\n                \\n        if not stack: return True \\n        if len(stack) > 1: return False\\n        i = stack[0]\\n        return (i == 1 or nums[i-2] < nums[i]) or (i+1 == len(nums) or nums[i-1] < nums[i+1])\\n```\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        prev, seen = -inf, False\\n        for i, x in enumerate(nums): \\n            if prev < x: prev = x\\n            else: \\n                if seen: return False \\n                seen = True \\n                if i == 1 or nums[i-2] < x: prev = x\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152791,
                "title": "o-n-c-solution-100-beats-without-any-stack-or-lengthy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck for singular or zero discountinuity from both sides of given array\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n- o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n\\n        // check for singular or zero discountinuity from both sides of given array \\n        int ct1=0,ct2=0;\\n        int maxi = nums[0];\\n        int mini = nums[nums.size()-1];\\n        //check from front\\n        for(int i=1;i<nums.size();i++){\\n            if(maxi>=nums[i]) ct1++;\\n            maxi = max(maxi,nums[i]); \\n        }\\n        //check from back\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(mini<=nums[i]) ct2++;\\n            mini = min(mini,nums[i]); \\n        }\\n        //if any side traversal have only one or zero discontinuity then return true \\n        //because after removing singular discontinuity array can be made strictly      increasing\\n        if(ct1==1||ct1==0||ct2==1||ct2==0) return true;\\n\\n        return false;\\n    }\\n};\\n```\\nPlease do upvote if you understand....",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n\\n        // check for singular or zero discountinuity from both sides of given array \\n        int ct1=0,ct2=0;\\n        int maxi = nums[0];\\n        int mini = nums[nums.size()-1];\\n        //check from front\\n        for(int i=1;i<nums.size();i++){\\n            if(maxi>=nums[i]) ct1++;\\n            maxi = max(maxi,nums[i]); \\n        }\\n        //check from back\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(mini<=nums[i]) ct2++;\\n            mini = min(mini,nums[i]); \\n        }\\n        //if any side traversal have only one or zero discontinuity then return true \\n        //because after removing singular discontinuity array can be made strictly      increasing\\n        if(ct1==1||ct1==0||ct2==1||ct2==0) return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734961,
                "title": "java-0-ms-explained",
                "content": "**Idea:**\\n* When a dip is found, we need to decide whether to remove the current number or the previous\\n* If the current number (a[i]) \\u2265 previous to previous number (a[i - 2]), then remove previous number (a[i - 1]) because the ascending order will still remain with a[i - 2] < a[i] \\n* Else remove the current number\\n* If there\\'s a second dip, then its not possible to remove only 1 element to make the array strictly ascending\\n\\n`Example 1: [1, 2, 10, 5, 7]`\\n\\n![image](https://assets.leetcode.com/users/images/2b3a34b5-c2ce-4a10-8d10-0a63a27b88f0_1643654793.2475817.png)\\n\\n`Example 2: [2, 3, 1, 2]`\\n\\n![image](https://assets.leetcode.com/users/images/b264bf1f-d927-4e84-879c-ddbf0c3924f1_1643654816.9824543.png)\\n\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic boolean canBeIncreasing(int[] nums) {\\n\\tfor (int i = 1, dips = 0, previous = nums[0]; i < nums.length; i++)\\n\\t\\tif (nums[i] <= previous) {\\n\\t\\t\\tif (++dips == 2)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (i == 1 || nums[i] > nums[i - 2])\\n\\t\\t\\t\\tprevious = nums[i];\\n\\t\\t} else {\\n\\t\\t\\tprevious = nums[i];\\n\\t\\t}\\n\\treturn true;\\n}\\n```\\nAlternate solution\\n```\\npublic boolean canBeIncreasing(int[] nums) {\\n\\tfor (int i = 0, faults = 0; i + 1 < nums.length; i++)\\n\\t\\tif (nums[i] >= nums[i + 1]) {\\n\\t\\t\\tif (++faults == 2)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (i != 0 && nums[i - 1] >= nums[i + 1])\\n\\t\\t\\t\\tnums[i + 1] = nums[i];\\n\\t\\t}\\n\\treturn true;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canBeIncreasing(int[] nums) {\\n\\tfor (int i = 1, dips = 0, previous = nums[0]; i < nums.length; i++)\\n\\t\\tif (nums[i] <= previous) {\\n\\t\\t\\tif (++dips == 2)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (i == 1 || nums[i] > nums[i - 2])\\n\\t\\t\\t\\tprevious = nums[i];\\n\\t\\t} else {\\n\\t\\t\\tprevious = nums[i];\\n\\t\\t}\\n\\treturn true;\\n}\\n```\n```\\npublic boolean canBeIncreasing(int[] nums) {\\n\\tfor (int i = 0, faults = 0; i + 1 < nums.length; i++)\\n\\t\\tif (nums[i] >= nums[i + 1]) {\\n\\t\\t\\tif (++faults == 2)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (i != 0 && nums[i - 1] >= nums[i + 1])\\n\\t\\t\\t\\tnums[i + 1] = nums[i];\\n\\t\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808440,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n)**\\n**Java**\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] <= nums[i-1]){ \\n                count++;\\n                if(i>1 && nums[i] <= nums[i-2])  nums[i] = nums[i-1];                    \\n            }\\n        }\\n        return count <= 1;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar canBeIncreasing = function(nums) {\\n    let count = 0\\n    for(let i=1; i<nums.length; i++){\\n        if(nums[i] <= nums[i-1]){\\n            count++;\\n            if(i>1 && nums[i] <= nums[i-2]) nums[i] = nums[i-1]\\n        }\\n    }\\n    return count <= 1\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def canBeIncreasing(self, nums):\\n        count = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i-1]:\\n                count += 1\\n                if i>1 and nums[i] <= nums[i-2]:\\n                    nums[i] = nums[i-1]\\n        return count <= 1\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] <= nums[i-1]){ \\n                count++;\\n                if(i>1 && nums[i] <= nums[i-2])  nums[i] = nums[i-1];                    \\n            }\\n        }\\n        return count <= 1;\\n    }\\n}\\n```\n```\\nvar canBeIncreasing = function(nums) {\\n    let count = 0\\n    for(let i=1; i<nums.length; i++){\\n        if(nums[i] <= nums[i-1]){\\n            count++;\\n            if(i>1 && nums[i] <= nums[i-2]) nums[i] = nums[i-1]\\n        }\\n    }\\n    return count <= 1\\n};\\n```\n```\\nclass Solution(object):\\n    def canBeIncreasing(self, nums):\\n        count = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i-1]:\\n                count += 1\\n                if i>1 and nums[i] <= nums[i-2]:\\n                    nums[i] = nums[i-1]\\n        return count <= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300632,
                "title": "dynamic-programming-approach-lis-variant",
                "content": "**This question can be done iteratively but doing this ques with dp is fun and easy to understand if you don\\'t know the concept of L I S this solution is not for you so the approach is simple and short find out the length of longest increasing subsequence and subtract it from total size of the array eg : 1 , 2 , 10 , 5 , 7 longest increasing subsequence is 1 -> 2 -> 5 ->7 of size 4 now Array Size - LIS = 1 so we only need to remove one element this is possible return false if in case this diff is greater than 1**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int lis(vector<int>& nums){\\n        int dp[nums.size()];\\n        dp[0] = 1 ;\\n        int oMax = 0;\\n        for(int i = 1 ;i<nums.size();i++){\\n            int mx = 0;\\n            for(int j = 0 ; j<i; j++){\\n                if(nums[i]>nums[j]){\\n                    mx = max(mx, dp[j]);\\n                }\\n            }\\n            dp[i] = mx+1;\\n            oMax = max(oMax,dp[i]);\\n        }\\n        return oMax;\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int ls = lis(nums);\\n        int x = nums.size()-ls;\\n        return x<2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lis(vector<int>& nums){\\n        int dp[nums.size()];\\n        dp[0] = 1 ;\\n        int oMax = 0;\\n        for(int i = 1 ;i<nums.size();i++){\\n            int mx = 0;\\n            for(int j = 0 ; j<i; j++){\\n                if(nums[i]>nums[j]){\\n                    mx = max(mx, dp[j]);\\n                }\\n            }\\n            dp[i] = mx+1;\\n            oMax = max(oMax,dp[i]);\\n        }\\n        return oMax;\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int ls = lis(nums);\\n        int x = nums.size()-ls;\\n        return x<2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913864,
                "title": "python-easy-solution-for-beginners",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            temp = nums[:i] + nums[i+1:]\\n            if sorted(temp) == temp:\\n                if len(set(temp)) == len(temp):\\n                    return True\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            temp = nums[:i] + nums[i+1:]\\n            if sorted(temp) == temp:\\n                if len(set(temp)) == len(temp):\\n                    return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1423652,
                "title": "c-simple-and-short-o-n-solution-explained",
                "content": "**Idea:**\\nWe keep a flag to see if we removed a number already.\\nNow, if we found a number that is not strictly increasing - `nums[i-1] >= nums[i]`:\\nIf the flag ib on already - we can\\'t remove another element and we return false.\\nElse, if nums[i] is also larger than nums[i-2], which means this is the one ruining the array, we want to remove it so we put nums[i-1] instead, to continue the scan.\\nOtherwise, we want to remove nums[i-1], we don\\'t have to do anything.\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        bool flag = false;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] >= nums[i]) {\\n                if (flag) return false;\\n                flag = true;\\n                \\n                if (i > 1 && nums[i-2] >= nums[i])\\n                    nums[i] = nums[i-1];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        bool flag = false;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] >= nums[i]) {\\n                if (flag) return false;\\n                flag = true;\\n                \\n                if (i > 1 && nums[i-2] >= nums[i])\\n                    nums[i] = nums[i-1];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638850,
                "title": "python-3-one-pass-beats-80",
                "content": "Similar to [665. Non-decreasing Array](https://leetcode.com/problems/non-decreasing-array/description/)\\n\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        isRemove = False\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i-1]:\\n                if isRemove: return False\\n                if i > 1 and nums[i] <= nums[i-2]:\\n                    nums[i] = nums[i-1]\\n                else:\\n                    nums[i-1] = nums[i]\\n                isRemove = True\\n\\n        return True          \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        isRemove = False\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i-1]:\\n                if isRemove: return False\\n                if i > 1 and nums[i] <= nums[i-2]:\\n                    nums[i] = nums[i-1]\\n                else:\\n                    nums[i-1] = nums[i]\\n                isRemove = True\\n\\n        return True          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298564,
                "title": "easy-c-o-n-solution-o-1-space",
                "content": "If the count for (nums[i-1]>=nums[i]) is greater than 1 then we can directly return false, and if it is equal to 0 then we can directly return true.\\nBut multiple cases will arise in case the count =1. In the code given below all those cases are checked.\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        int max=-1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]>=nums[i]){\\n                count++;\\n                max=i;\\n            }\\n        }\\n        if(count>1){\\n            return false;\\n        }\\n        if (count == 0)\\n        {\\n            return true;\\n        }\\n        if (max == n - 1 || max == 1)\\n        {\\n            return true;\\n        }\\n        if (nums[max - 1] < nums[max + 1])\\n        {\\n            return true;\\n        }\\n        if (nums[max - 2] < nums[max])\\n        {\\n            return true;\\n        }\\n \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        int max=-1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]>=nums[i]){\\n                count++;\\n                max=i;\\n            }\\n        }\\n        if(count>1){\\n            return false;\\n        }\\n        if (count == 0)\\n        {\\n            return true;\\n        }\\n        if (max == n - 1 || max == 1)\\n        {\\n            return true;\\n        }\\n        if (nums[max - 1] < nums[max + 1])\\n        {\\n            return true;\\n        }\\n        if (nums[max - 2] < nums[max])\\n        {\\n            return true;\\n        }\\n \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337681,
                "title": "most-jugadu-solution-by-trippy-the-codder",
                "content": "# Intuition\\nEASIEST SOL EVER YOU WILL SEE\\n\\n# Approach\\nJUST SMILE AND SOLVE\\n\\n# Complexity\\nNOTHING COMPLEX HERE\\n\\n# HUMBLE REQUEST\\nPlease upvote if i helped you : )\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] arr) {\\n        ArrayList<Integer> al=new ArrayList<Integer>();\\n        int p=0;boolean flag=true;\\n        int c=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            for(int j=0;j<arr.length;j++)\\n            {\\n                if(j==i)\\n                continue;\\n                else\\n                al.add(arr[j]);\\n\\n            }\\n            for(int k=0;k<al.size()-1;k++)\\n            {\\n                if(al.get(k)>=al.get(k+1))\\n                { flag=false;\\n                break;\\n                }\\n            }\\n            if(flag){\\n                return true;\\n            }\\n            flag=true;\\n            al.clear();\\n        }\\n        return false;     \\n            \\n    }//Please Upvote.\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sort",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] arr) {\\n        ArrayList<Integer> al=new ArrayList<Integer>();\\n        int p=0;boolean flag=true;\\n        int c=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            for(int j=0;j<arr.length;j++)\\n            {\\n                if(j==i)\\n                continue;\\n                else\\n                al.add(arr[j]);\\n\\n            }\\n            for(int k=0;k<al.size()-1;k++)\\n            {\\n                if(al.get(k)>=al.get(k+1))\\n                { flag=false;\\n                break;\\n                }\\n            }\\n            if(flag){\\n                return true;\\n            }\\n            flag=true;\\n            al.clear();\\n        }\\n        return false;     \\n            \\n    }//Please Upvote.\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833392,
                "title": "problem-no-1909-easy-solution-for-beginners-c",
                "content": "```\\nclass Solution{\\npublic:\\n    bool canBeIncreasing(vector<int>& nums){\\n        int count = 0;\\n        for (int i = 1; i < nums.size(); i++){\\n            if (nums[i] <= nums[i-1]){\\n                if(count == 1) return false;\\n                count++;\\n                if(i > 1 && nums[i] <= nums[i-2]){\\n                    nums[i] = nums[i-1];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n***Please upvote if it was helpful for you, thank you!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    bool canBeIncreasing(vector<int>& nums){\\n        int count = 0;\\n        for (int i = 1; i < nums.size(); i++){\\n            if (nums[i] <= nums[i-1]){\\n                if(count == 1) return false;\\n                count++;\\n                if(i > 1 && nums[i] <= nums[i-2]){\\n                    nums[i] = nums[i-1];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705227,
                "title": "java-easy-and-efficient-solution-0ms",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]>=nums[i+1])\\n            {\\n                count++;\\n                if(count==2)\\n                    return false;\\n                if(i>0 && nums[i-1]>=nums[i+1])\\n                {\\n                    nums[i+1]=nums[i];\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]>=nums[i+1])\\n            {\\n                count++;\\n                if(count==2)\\n                    return false;\\n                if(i>0 && nums[i-1]>=nums[i+1])\\n                {\\n                    nums[i+1]=nums[i];\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325797,
                "title": "simple-python-solution",
                "content": "```\\n        for i in range(len(nums)):\\n            arr = nums[:i] + nums[i+1:]\\n            if arr == sorted(arr) and len(arr) == len(set(arr)):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n        for i in range(len(nums)):\\n            arr = nums[:i] + nums[i+1:]\\n            if arr == sorted(arr) and len(arr) == len(set(arr)):\\n                return True\\n        return False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298611,
                "title": "javascript-simple-o-n-solution",
                "content": "```\\nvar canBeIncreasing = function(nums) {\\n  for (let i = 1, used = false, prev = nums[0]; i < nums.length; i++) {\\n    if (nums[i] > prev) { prev = nums[i]; continue }\\n    if (used) return false;\\n    used = true;\\n    (i === 1 || nums[i] > nums[i - 2]) && (prev = nums[i]);\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeIncreasing = function(nums) {\\n  for (let i = 1, used = false, prev = nums[0]; i < nums.length; i++) {\\n    if (nums[i] > prev) { prev = nums[i]; continue }\\n    if (used) return false;\\n    used = true;\\n    (i === 1 || nums[i] > nums[i - 2]) && (prev = nums[i]);\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305915,
                "title": "java-0ms-beats-100",
                "content": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Remove One Element to Make the Array Strictly Increasing.\\nMemory Usage: 38.1 MB, less than 99.73% of Java online submissions for Remove One Element to Make the Array Strictly Increasing.\\nTime complexity:  O(n), since we traverse upwards of entire input int[]\\nSpace complexity: O(1), since we store just a few ints\\n*/\\n\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int numberOfDeletionsNeededToMakeStrictlyIncreasing = 0;\\n        \\n        for (int i = 1; i < nums.length; ++i) {\\n            \\n            if (nums[i-1] >= nums[i]) { // we found a non-strictly-increasing pair of elements\\n                \\n                /*\\n                    ...,   nums[i-2],   nums[i-1],   nums[i],   nums[i+1],   ...\\n                                                   \\u2191\\n                                                   non-increase happens here\\n                */\\n                \\n                int iMinusTwoValue;\\n                if (i - 2 < 0) { // if nums[i-2] is out of range...\\n                    iMinusTwoValue = Integer.MIN_VALUE;\\n                } else {\\n                    iMinusTwoValue = nums[i - 2];\\n                }\\n                \\n                int iPlusOneValue;\\n                if (i + 1 == nums.length) { // if nums[i+1] is out of range...\\n                    iPlusOneValue = Integer.MAX_VALUE;\\n                } else {\\n                    iPlusOneValue = nums[i + 1];\\n                }\\n                \\n                // the two conditions around the || operator below represent removing either nums[i+1] or nums[i] respectively\\n                if ((nums[i] > iMinusTwoValue && nums[i] < iPlusOneValue) || (nums[i-1] > iMinusTwoValue && nums[i-1] < iPlusOneValue)) {\\n                    ++numberOfDeletionsNeededToMakeStrictlyIncreasing;\\n                } else {\\n                    return false; // found an unfixable non-increase\\n                }\\n            }\\n        }\\n        \\n        if (numberOfDeletionsNeededToMakeStrictlyIncreasing <= 1) {\\n            return true;\\n        } else { // numberOfDeletionsNeededToMakeStrictlyIncreasing > 1\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Remove One Element to Make the Array Strictly Increasing.\\nMemory Usage: 38.1 MB, less than 99.73% of Java online submissions for Remove One Element to Make the Array Strictly Increasing.\\nTime complexity:  O(n), since we traverse upwards of entire input int[]\\nSpace complexity: O(1), since we store just a few ints\\n*/\\n\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int numberOfDeletionsNeededToMakeStrictlyIncreasing = 0;\\n        \\n        for (int i = 1; i < nums.length; ++i) {\\n            \\n            if (nums[i-1] >= nums[i]) { // we found a non-strictly-increasing pair of elements\\n                \\n                /*\\n                    ...,   nums[i-2],   nums[i-1],   nums[i],   nums[i+1],   ...\\n                                                   \\u2191\\n                                                   non-increase happens here\\n                */\\n                \\n                int iMinusTwoValue;\\n                if (i - 2 < 0) { // if nums[i-2] is out of range...\\n                    iMinusTwoValue = Integer.MIN_VALUE;\\n                } else {\\n                    iMinusTwoValue = nums[i - 2];\\n                }\\n                \\n                int iPlusOneValue;\\n                if (i + 1 == nums.length) { // if nums[i+1] is out of range...\\n                    iPlusOneValue = Integer.MAX_VALUE;\\n                } else {\\n                    iPlusOneValue = nums[i + 1];\\n                }\\n                \\n                // the two conditions around the || operator below represent removing either nums[i+1] or nums[i] respectively\\n                if ((nums[i] > iMinusTwoValue && nums[i] < iPlusOneValue) || (nums[i-1] > iMinusTwoValue && nums[i-1] < iPlusOneValue)) {\\n                    ++numberOfDeletionsNeededToMakeStrictlyIncreasing;\\n                } else {\\n                    return false; // found an unfixable non-increase\\n                }\\n            }\\n        }\\n        \\n        if (numberOfDeletionsNeededToMakeStrictlyIncreasing <= 1) {\\n            return true;\\n        } else { // numberOfDeletionsNeededToMakeStrictlyIncreasing > 1\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882104,
                "title": "no-sorting-o-n-easy-c-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Very Simple, Store the **previous Value** in a Pointer and Simply Check the **Conditions**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& arr) {\\n        int f = 1,prev = arr[0];\\n        for(int i = 1;i<arr.size();i++)\\n        {\\n            if(arr[i]<=prev)\\n            {\\n                if(!f) return false;\\n                if(i>=2)\\n                {\\n                  if(arr[i-2]<arr[i]) prev = arr[i];\\n                  else prev = arr[i-1];  \\n                }\\n                else if(i<arr.size()-1 && arr[i]<arr[i+1]) prev = arr[i];\\n                else prev = arr[i];\\n                f = 0;\\n            } \\n            else prev = arr[i];   \\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/0154810f-9f47-43c4-8947-f22632f8dea0_1691504044.136541.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& arr) {\\n        int f = 1,prev = arr[0];\\n        for(int i = 1;i<arr.size();i++)\\n        {\\n            if(arr[i]<=prev)\\n            {\\n                if(!f) return false;\\n                if(i>=2)\\n                {\\n                  if(arr[i-2]<arr[i]) prev = arr[i];\\n                  else prev = arr[i-1];  \\n                }\\n                else if(i<arr.size()-1 && arr[i]<arr[i+1]) prev = arr[i];\\n                else prev = arr[i];\\n                f = 0;\\n            } \\n            else prev = arr[i];   \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565404,
                "title": "java-simple-solution-0-ms-100-beats",
                "content": "# Approach\\n1. Initialize a variable `count` to keep track of the number of elements that need to be removed. Set it to 0 initially.\\n\\n2. Iterate over the array `nums` starting from index 1.\\n\\n3. Check if the current element `nums[i]` is less than or equal to the previous element `nums[i - 1]`. If it is, it indicates a violation of the strictly increasing order.\\n\\n4. Increment the `count` variable to indicate that we need to remove an element.\\n\\n5. If the `count` becomes greater than 1, it means we need to remove more than one element to make the array strictly increasing. In this case, we can immediately return `false` because it is not possible to achieve the desired result.\\n\\n6. If the violation occurs at index `i`, we have two choices for removing an element:\\n\\n   - Remove `nums[i]` by setting it equal to `nums[i - 1]`.\\n   - Remove `nums[i - 1]` by keeping `nums[i]` unchanged.\\n\\n   We need to decide which element to remove based on whether removing the current element (`nums[i]`) creates a new violation. To determine this, we check if the element at index `i` is also less than or equal to the element at index `i - 2`. If it is, we set `nums[i]` equal to `nums[i - 1]` to remove the element at index `i`.\\n\\n7. After the loop finishes, if we haven\\'t encountered more than one violation (i.e., `count <= 1`), it means we can make the array strictly increasing by removing at most one element. We return `true`.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n\\n        for (int i = 1; i < nums.length; i++)\\n            if (nums[i] <= nums[i - 1]) {\\n                count++;\\n                if (count > 1)\\n                    return false;\\n                if (i > 1 && nums[i] <= nums[i - 2])\\n                    nums[i] = nums[i - 1];\\n            }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n\\n        for (int i = 1; i < nums.length; i++)\\n            if (nums[i] <= nums[i - 1]) {\\n                count++;\\n                if (count > 1)\\n                    return false;\\n                if (i > 1 && nums[i] <= nums[i - 2])\\n                    nums[i] = nums[i - 1];\\n            }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523947,
                "title": "easy-python",
                "content": "class Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            res=nums.copy()\\n            #res.remove(nums[i])\\n            res.pop(i)\\n            if res == sorted(set(res)):\\n                return True\\n            else:\\n                continue\\n        return False\\n    \\n    \\n   \\n            \\n\\n        \\n            \\n                \\n          \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            res=nums.copy()\\n            #res.remove(nums[i])\\n            res.pop(i)\\n            if res == sorted(set(res)):\\n                return True\\n            else:\\n                continue\\n        return False\\n    \\n    \\n   \\n            \\n\\n        \\n            \\n                \\n          \\n",
                "codeTag": "Java"
            },
            {
                "id": 2491809,
                "title": "java-1-ms-solution",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int error = 0;\\n        for ( int i = 1; i < nums.length; i++ ) \\n            if ( nums[i] <= nums[i - 1] ) {\\n                if ( error > 0 ) return false;\\n                error++;\\n                if ( i > 1 && nums[i] <= nums[i - 2] ) nums[i] = nums[i - 1];    \\n            }\\n        return true;\\n    }\\n}\\n```\\n\\nplease vote up if it help you",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int error = 0;\\n        for ( int i = 1; i < nums.length; i++ ) \\n            if ( nums[i] <= nums[i - 1] ) {\\n                if ( error > 0 ) return false;\\n                error++;\\n                if ( i > 1 && nums[i] <= nums[i - 2] ) nums[i] = nums[i - 1];    \\n            }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878645,
                "title": "simple-solution-in-o-n-beats-99",
                "content": "# Approach\\nStarting from the second element of the array we check if it is less or equal to the previous one. In this case the array is not strictly increasing and we need to fix it and we have two way to do this:\\n    - if `nums[i-2] < nums[i] < nums[i-1]` ( e.g 2, 10, 5 (i), 6 ) remove `i-1` (10) fix the situation.\\n    - If `nums[i] < nums[i-1] and nums[i] <= nums[i-2]` (e.g 2, 3, 2(i), 4(j), 5 ) we need to remove `i` to fix the situation.\\n    \\nSince we compare always the `i` value with `i-1` value the first case does not alter the algorithm. This is not true for the second case, because at the next iteration we should compare the position `j=i+1` with the position `i-1` (because we have removed the `i` position). To avoid this issue we are going to copy the `i-1` element in `i` position. \\n\\nIn each case we keep track of the removal using a variable `removed_once`. If we found another element that is not strictly increasing we return `False`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        removed_once = False\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i-1]:\\n                if removed_once:\\n                    return False\\n                if i > 1 and nums[i] <= nums[i-2]:\\n                    nums[i] = nums[i-1]\\n\\n                removed_once = True\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        removed_once = False\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i-1]:\\n                if removed_once:\\n                    return False\\n                if i > 1 and nums[i] <= nums[i-2]:\\n                    nums[i] = nums[i-1]\\n\\n                removed_once = True\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679796,
                "title": "superb-logic-with-sort-with-two-approches",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            temp=nums[:i]+nums[i+1:]\\n            if temp==sorted(set(temp)):\\n                return True\\n        return False\\n```\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        flag=False\\n        for i in range(1,len(nums)):\\n            if nums[i]<=nums[i-1]:\\n                if flag:\\n                    return False\\n                if i>1 and nums[i]<=nums[i-2]:\\n                    nums[i]=nums[i-1]\\n                else:\\n                    nums[i-1]=nums[i]\\n                flag=True\\n        return True\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            temp=nums[:i]+nums[i+1:]\\n            if temp==sorted(set(temp)):\\n                return True\\n        return False\\n```\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        flag=False\\n        for i in range(1,len(nums)):\\n            if nums[i]<=nums[i-1]:\\n                if flag:\\n                    return False\\n                if i>1 and nums[i]<=nums[i-2]:\\n                    nums[i]=nums[i-1]\\n                else:\\n                    nums[i-1]=nums[i]\\n                flag=True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400003,
                "title": "trickiest-easy-question-explained-line-by-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom the hint given, i came to this approach. Remove each element and check if it is sorted or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Write a isSort(), to check whether vector is sorted or not.\\n2. if vector is already sorted, return true.\\n3. check the condition -(i > 1 && nums[i-1] < nums[i] && nums[i-1] > nums[i-2]) example - 2,5,7- 5 < 7 and 5>2.\\n4. if not, remove nums[i-1], and check sorted or not. if sorted return true, else restore original nums.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSort(vector<int> v){\\n        for(int  i = 1; i < v.size(); i++){\\n            if(v[i-1] >= v[i])\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool canBeIncreasing(vector<int>& nums){\\n        if(isSort(nums))\\n        return true;\\n        vector<int> v = nums;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(i > 1 && nums[i-1] < nums[i] && nums[i-1] > nums[i-2])\\n            continue;\\n            else{\\n                int j = i-1;\\n                if((i == nums.size()-1) && (nums[i-1] > nums[i])) // seperately tackling last index.\\n                j=i;\\n                nums.erase(nums.begin() + j);\\n                if(isSort(nums)==true)\\n                    return true;\\n                else\\n                    nums = v;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSort(vector<int> v){\\n        for(int  i = 1; i < v.size(); i++){\\n            if(v[i-1] >= v[i])\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool canBeIncreasing(vector<int>& nums){\\n        if(isSort(nums))\\n        return true;\\n        vector<int> v = nums;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(i > 1 && nums[i-1] < nums[i] && nums[i-1] > nums[i-2])\\n            continue;\\n            else{\\n                int j = i-1;\\n                if((i == nums.size()-1) && (nums[i-1] > nums[i])) // seperately tackling last index.\\n                j=i;\\n                nums.erase(nums.begin() + j);\\n                if(isSort(nums)==true)\\n                    return true;\\n                else\\n                    nums = v;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162196,
                "title": "94-74-on-kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe array nums is strictly increasing if nums[i - 1] < nums[i] for each index (1 <= i < nums.length).\\n\\n> If two elements in the subsequence do not increase, you need to understand which of the elements you need to delete\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s declare a string that will point to the previous element of the sequence. At the very beginning, the variable contained the first element of nums.\\nThe isRemoved variable shows whether we have used element deletion or not (the deletion is figurative, in fact the array does not change)\\n1. We start iterations not from index 0, but from 1;\\n2. If the current element is less than or equal to the previous one (nums[i] <= previous) => \\n        - If the previous element of the sequence has already been deleted (it is also the largest element) => the sequence decreases => we complete the calculation \\n        - If the previous element was not deleted => at the current iteration we delete it => isRemoved = true \\n        - If the current index of the element == 1 or the current element is greater than the element to the left of the previous one, those nums[i] > nums[i - 2] => the sequence increases => at the end of the iteration, the current element becomes the previous one (previous = nums[i])\\n3. If the current element is larger than the previous one => the sequence increases => at the end of the iteration, the current element becomes the previous one (previous = nums[i]);\\n4. If no element was deleted, or after deleting the element there was no exit due to decreasing sequence => the sequence will increase.\\n\\nFor example, for [6,7,3,4,5] \\n\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-02-09 \\u0432 02.13.41.png](https://assets.leetcode.com/users/images/05d2d9bf-dfde-42f4-b314-f352b832fbc9_1675898045.276258.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun canBeIncreasing(nums: IntArray): Boolean {\\n        var previous = nums[0]\\n        var isRemoved = false\\n        for (i in 1 until nums.size) {\\n            if (nums[i] <= previous) {\\n                if (isRemoved) return false\\n                isRemoved = true\\n                if (i == 1 || nums[i] > nums[i - 2])\\n                    previous = nums[i]\\n            } else previous = nums[i]\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun canBeIncreasing(nums: IntArray): Boolean {\\n        var previous = nums[0]\\n        var isRemoved = false\\n        for (i in 1 until nums.size) {\\n            if (nums[i] <= previous) {\\n                if (isRemoved) return false\\n                isRemoved = true\\n                if (i == 1 || nums[i] > nums[i - 2])\\n                    previous = nums[i]\\n            } else previous = nums[i]\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548281,
                "title": "c-sharing-greedy-approach-explained-using-blackboard",
                "content": "One of the easy TAG problems which I personally like (However, it\\'s not something I can do easily. lol!!)\\n**Anchor Points** : I used the term for describing the element which makes the array not strictly increasing.\\nCount the anchor points (i>0 && arr[i-1]>=arr[i]) count++, index=i;\\n![image](https://assets.leetcode.com/users/images/4fff99a3-f7cc-4a92-b5a3-5885b46febf3_1662618734.3093996.png)\\nLife seems good if you are getting count of anchor points either 0 or more than 1 because you already know the answer;\\n![image](https://assets.leetcode.com/users/images/55538e97-ab70-4d97-a388-fd0eac4e2656_1662619635.7571993.gif)\\n\\nIt becomes messy when you get the anchor points  = 1;\\n![image](https://assets.leetcode.com/users/images/f9cc4500-544c-457b-b8cd-ae6ed2870860_1662619736.2426598.gif)\\n\\nLets understand it:\\n![image](https://assets.leetcode.com/users/images/708ef33c-2206-491e-86f1-d1ee4be54ab3_1662620401.927514.png)\\n\\n\\n\\nCode Reference : Dont freak out by seeing code, its easy to understand when you get the intuition behind it:\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& vec) {\\n        int n=vec.size();\\n        int index=-1;\\n        int ct=0;\\n        for(auto i=1;i<n;i++){\\n            if(vec[i-1]>=vec[i]){\\n                index=i;\\n                ct++; // getting the count of anchor points which makes the array not strictly increasing\\n            }\\n        }\\n        if(ct==0)return true; //  array is strictly increasing\\n        if(ct==1){\\n            if(index>1 && index<n-1){\\n                if(vec[index-2]<vec[index] || vec[index-1]<vec[index+1]){ // if Either of these conditions arises then we can make our array strictly increasing.\\n                    return true;\\n                }\\n                return false;\\n            }\\n            return true; // Dont shout at me here!!  it means if the anchor points are one the edges of array then dont worry we can still make the array strictly increasing just by removing them\\n        }\\n        return false; // Definitely we cant make the array strictly increasing just by removal of one element if anchor points are more than 1\\n    }\\n};\\n```\\nHappy then upvote!!!",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& vec) {\\n        int n=vec.size();\\n        int index=-1;\\n        int ct=0;\\n        for(auto i=1;i<n;i++){\\n            if(vec[i-1]>=vec[i]){\\n                index=i;\\n                ct++; // getting the count of anchor points which makes the array not strictly increasing\\n            }\\n        }\\n        if(ct==0)return true; //  array is strictly increasing\\n        if(ct==1){\\n            if(index>1 && index<n-1){\\n                if(vec[index-2]<vec[index] || vec[index-1]<vec[index+1]){ // if Either of these conditions arises then we can make our array strictly increasing.\\n                    return true;\\n                }\\n                return false;\\n            }\\n            return true; // Dont shout at me here!!  it means if the anchor points are one the edges of array then dont worry we can still make the array strictly increasing just by removing them\\n        }\\n        return false; // Definitely we cant make the array strictly increasing just by removal of one element if anchor points are more than 1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504253,
                "title": "2-line-in-python-quite-expensive",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        is_increasing = lambda l: all(x < y for x, y in zip(l, l[1:]))\\n        return any(is_increasing(nums[:i] + nums[(i + 1):]) for i in range(len(nums)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        is_increasing = lambda l: all(x < y for x, y in zip(l, l[1:]))\\n        return any(is_increasing(nums[:i] + nums[(i + 1):]) for i in range(len(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926057,
                "title": "simple-c-solution",
                "content": "\\n```\\npublic class Solution {\\n    public bool CanBeIncreasing(int[] nums) {\\n        int count = 0;\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i - 1] >= nums[i]) {\\n                count++;\\n                if (count > 1) {\\n                    return false;\\n                }\\n\\n                if (i > 1 && nums[i - 2] >= nums[i]) {\\n                    nums[i] = nums[i - 1];\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CanBeIncreasing(int[] nums) {\\n        int count = 0;\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i - 1] >= nums[i]) {\\n                count++;\\n                if (count > 1) {\\n                    return false;\\n                }\\n\\n                if (i > 1 && nums[i - 2] >= nums[i]) {\\n                    nums[i] = nums[i - 1];\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735653,
                "title": "beats-100-simple-easy-to-understand-solution-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count =0;\\n        int idx = 0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>=nums[i+1]){\\n                count++;\\n                idx=i;\\n            }\\n       }\\n       if(count>1){\\n           return false;\\n       }\\n       else{\\n           if(idx ==0 || idx == nums.length-2){\\n               return true;\\n           }\\n           else if(nums[idx+1]>nums[idx-1] || nums[idx+2] > nums[idx])\\n           {\\n               return true;\\n           }\\n           else{\\n               return false;\\n           }\\n       }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count =0;\\n        int idx = 0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>=nums[i+1]){\\n                count++;\\n                idx=i;\\n            }\\n       }\\n       if(count>1){\\n           return false;\\n       }\\n       else{\\n           if(idx ==0 || idx == nums.length-2){\\n               return true;\\n           }\\n           else if(nums[idx+1]>nums[idx-1] || nums[idx+2] > nums[idx])\\n           {\\n               return true;\\n           }\\n           else{\\n               return false;\\n           }\\n       }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579194,
                "title": "1909-remove-one-element-to-make-the-array-strictly-increasing",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        dnums=nums.copy() #make a copy of the original array <nums>\\n        for i in range(len(nums)-1): #traverse the first pointer <i> in the original array <nums>\\n            if nums[i]>=nums[i+1]:\\n                a=nums.pop(i)\\n                break\\n        if nums==sorted(set(nums)):  #we are checking with the sorted array because there might be duplicate elements after 1 pop instruction\\n            return True\\n        for j in range(len(dnums)-1,0,-1): #traverse the 2nd pointer <j> in the duplicate array <dnums>\\n            if dnums[j]<=dnums[j-1]:\\n                a=dnums.pop(j)\\n                break\\n        if dnums==sorted(set(dnums)): \\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        dnums=nums.copy() #make a copy of the original array <nums>\\n        for i in range(len(nums)-1): #traverse the first pointer <i> in the original array <nums>\\n            if nums[i]>=nums[i+1]:\\n                a=nums.pop(i)\\n                break\\n        if nums==sorted(set(nums)):  #we are checking with the sorted array because there might be duplicate elements after 1 pop instruction\\n            return True\\n        for j in range(len(dnums)-1,0,-1): #traverse the 2nd pointer <j> in the duplicate array <dnums>\\n            if dnums[j]<=dnums[j-1]:\\n                a=dnums.pop(j)\\n                break\\n        if dnums==sorted(set(dnums)): \\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033807,
                "title": "c-one-pass-solution-o-n",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Remove One Element to Make the Array Strictly Increasing.\\nMemory Usage: 9.9 MB, less than 58.54% of C++ online submissions for Remove One Element to Make the Array Strictly Increasing.\\n\\n```\\nTo check if the array is strictly increasing we check if  current value is less than next value.\\nIf not then current value violates the increasing order. So, we can ignore the current value\\nin the increasing order. But we can also ignore the next value in our increasing order \\nand keep the current value if next value is not greater than previous value, so in that case we make next value\\nas current value. As we count the number of times the increasing order violates, loop terminates as soon as count ==2. \\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n                \\n        int n = nums.size();\\n        \\n        // base case n==2 always true\\n        if(n==2) return true;\\n        \\n        int count = 0;  // count number of increasing order violation\\n        \\n        // loop till count < 2\\n        for(int i=0;i<n-1 && count< 2;i++)\\n        {\\n            // increasing order violated\\n            if(nums[i]>=nums[i+1])\\n            {\\n                count++;\\n                \\n                // check if next value > previous value\\n                // if not then we have to ignore next value and keep the current value\\n                // in increasing order by making next value as current value\\n                if(i>0 && nums[i+1]<=nums[i-1])\\n                    nums[i+1] = nums[i];\\n            }         \\n        }\\n\\n        \\n        return count < 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nTo check if the array is strictly increasing we check if  current value is less than next value.\\nIf not then current value violates the increasing order. So, we can ignore the current value\\nin the increasing order. But we can also ignore the next value in our increasing order \\nand keep the current value if next value is not greater than previous value, so in that case we make next value\\nas current value. As we count the number of times the increasing order violates, loop terminates as soon as count ==2. \\n```\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n                \\n        int n = nums.size();\\n        \\n        // base case n==2 always true\\n        if(n==2) return true;\\n        \\n        int count = 0;  // count number of increasing order violation\\n        \\n        // loop till count < 2\\n        for(int i=0;i<n-1 && count< 2;i++)\\n        {\\n            // increasing order violated\\n            if(nums[i]>=nums[i+1])\\n            {\\n                count++;\\n                \\n                // check if next value > previous value\\n                // if not then we have to ignore next value and keep the current value\\n                // in increasing order by making next value as current value\\n                if(i>0 && nums[i+1]<=nums[i-1])\\n                    nums[i+1] = nums[i];\\n            }         \\n        }\\n\\n        \\n        return count < 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905059,
                "title": "with-only-one-critical-trick",
                "content": "\\n```\\nint ppre = INT_MIN;\\nint pre = INT_MIN;\\nbool flag = false;\\n\\nfor (int x : nums)\\n{\\n\\tif (pre < x)\\n\\t{\\n\\t\\tppre = pre;\\n\\t\\tpre = x;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tif (flag)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tflag = true;\\n\\t\\t\\n\\t\\t// at this point, we have 2 choices, \\n\\t\\t//   opt 1) either we remove the current x, or \\n\\t\\t//   opt 2) we remove the previous value.\\n\\t\\t// but if we know that the value before the previous value, \\n\\t\\t//   i.e. ppre, is less than the current x, \\n\\t\\t//   then we always remove the previous value pre (opt 2) since this will be the optimized option\\n\\t\\t//   to have a smaller pre in the next iteration.\\n\\t\\t// And if we don\\'t have ppre < x,\\n\\t\\t//   then it means we have to remove the current x (opt 1), \\n\\t\\t//   and this check will be done at the next iteration.\\n\\t\\tif (ppre < x)\\n\\t\\t\\tpre = x;\\n\\t}\\n}\\n\\nreturn true;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint ppre = INT_MIN;\\nint pre = INT_MIN;\\nbool flag = false;\\n\\nfor (int x : nums)\\n{\\n\\tif (pre < x)\\n\\t{\\n\\t\\tppre = pre;\\n\\t\\tpre = x;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tif (flag)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tflag = true;\\n\\t\\t\\n\\t\\t// at this point, we have 2 choices, \\n\\t\\t//   opt 1) either we remove the current x, or \\n\\t\\t//   opt 2) we remove the previous value.\\n\\t\\t// but if we know that the value before the previous value, \\n\\t\\t//   i.e. ppre, is less than the current x, \\n\\t\\t//   then we always remove the previous value pre (opt 2) since this will be the optimized option\\n\\t\\t//   to have a smaller pre in the next iteration.\\n\\t\\t// And if we don\\'t have ppre < x,\\n\\t\\t//   then it means we have to remove the current x (opt 1), \\n\\t\\t//   and this check will be done at the next iteration.\\n\\t\\tif (ppre < x)\\n\\t\\t\\tpre = x;\\n\\t}\\n}\\n\\nreturn true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891984,
                "title": "tc-o-n-sc-o-1-with-comments",
                "content": "```\\nclass Solution {\\n   \\npublic:\\n    bool canBeIncreasing(vector<int>& arr) {\\n       \\n       int count=0;\\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i-1]>=arr[i]){\\n            // this means we have already removed one element from the array ATQ.\\n            //but we again found an element that is breaking our strictly increasing sequence.\\n                count++;\\n                if(count>1) \\n                    return false;\\n                            \\n                // i>1 means that if the first 2 elements of the array are same \\n                // then there is no point of doing arr[i]=arr[i-1] \\n                //because they will be same even after the operation\\n                //so we perform replacing operation only if \"i>1\"\\n                    //&&\\n                // if( arr[i-1]==arr[i]) then we want to replace arr[i] with arr[i-2]\\n                //by the way this replacing part will only happen once as the \\'count\\' is keeping track of \\n\\t\\t\\t\\t//number of elements to removed and as count>1 we are returning false.\\n                 \\n                if(i>1 && arr[i-2]>=arr[i])\\n                    arr[i]=arr[i-1];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    bool canBeIncreasing(vector<int>& arr) {\\n       \\n       int count=0;\\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i-1]>=arr[i]){\\n            // this means we have already removed one element from the array ATQ.\\n            //but we again found an element that is breaking our strictly increasing sequence.\\n                count++;\\n                if(count>1) \\n                    return false;\\n                            \\n                // i>1 means that if the first 2 elements of the array are same \\n                // then there is no point of doing arr[i]=arr[i-1] \\n                //because they will be same even after the operation\\n                //so we perform replacing operation only if \"i>1\"\\n                    //&&\\n                // if( arr[i-1]==arr[i]) then we want to replace arr[i] with arr[i-2]\\n                //by the way this replacing part will only happen once as the \\'count\\' is keeping track of \\n\\t\\t\\t\\t//number of elements to removed and as count>1 we are returning false.\\n                 \\n                if(i>1 && arr[i-2]>=arr[i])\\n                    arr[i]=arr[i-1];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596880,
                "title": "easy-solution-o-n-time-o-1-space-beat-100-shortest-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Remove One Element to Make the Array Strictly Increasing.\\nMemory Usage: 9.8 MB, less than 81.33% of C++ online submissions for Remove One Element to Make the Array Strictly Increasing.\\n\\nApproach:\\nwe store the index where pattern breaks and if a pattern break and we have already stored value, there we are returning false.\\nnow after that we are returning true for boundary cases.\\nnow we are checking, if the pattern is reattain by removing any one of them, if yes then we return true else false.\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int a=-1,b=-1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i] >= nums[i+1]){\\n                if(a != -1) return false;\\n                a=i,b=i+1;\\n            }\\n        }\\n        if(a<1 || b==nums.size()-1) return true; //true for boundary condition\\n        if(nums[a-1] < nums[b] || nums[a] < nums[b+1]) return true; //check if the pattern is reattain by removing any one of them\\n        return false;\\n    }\\n};\\n```\\ncomment if there is any problem.",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int a=-1,b=-1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i] >= nums[i+1]){\\n                if(a != -1) return false;\\n                a=i,b=i+1;\\n            }\\n        }\\n        if(a<1 || b==nums.size()-1) return true; //true for boundary condition\\n        if(nums[a-1] < nums[b] || nums[a] < nums[b+1]) return true; //check if the pattern is reattain by removing any one of them\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591583,
                "title": "python-3-97-faster",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        prev = 0\\n        flag = False\\n        nums.append(math.inf)\\n        i, n = 0, len(nums) - 1\\n        while i < n:\\n            if prev < nums[i] < nums[i+1]:\\n                prev = nums[i]\\n            else:  # nums[i] or nums[i+1] should be removed\\n                if flag:\\n                    return False\\n                flag = True\\n                if nums[i+1] <= prev:  # remove nums[i+1]\\n                    prev = nums[i]\\n                    i += 1\\n            i += 1\\n        \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        prev = 0\\n        flag = False\\n        nums.append(math.inf)\\n        i, n = 0, len(nums) - 1\\n        while i < n:\\n            if prev < nums[i] < nums[i+1]:\\n                prev = nums[i]\\n            else:  # nums[i] or nums[i+1] should be removed\\n                if flag:\\n                    return False\\n                flag = True\\n                if nums[i+1] <= prev:  # remove nums[i+1]\\n                    prev = nums[i]\\n                    i += 1\\n            i += 1\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1431740,
                "title": "python-extremely-simple-code",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        dip = -1\\n        for i in range(1, len(nums)):\\n            if nums[i-1] >= nums[i]:\\n                # Record the index where we \"dip\", where we violate the strictly increasing order property\\n                if dip == -1:\\n                    dip = i\\n                else:\\n                    return False\\n        \\n        if dip == -1:\\n            return True\\n        \\n        # If the dip happened at the end of nums, we could just cut it off and the list would become strictly\\n        # increasing; Or if cutting out nums[dip] results in nums[dip-1] < nums[dip+1], that also works\\n        if dip == len(nums) - 1 or nums[dip-1] < nums[dip+1]:\\n            return True\\n        \\n        # If the dip happened at the second element (index = 1), we could just cut off the higher element at\\n        # index == 0; Or if cutting out nums[dip-1] results in nums[dip-2] < nums[dip], that also works\\n        if dip == 1 or nums[dip-2] < nums[dip]:\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        dip = -1\\n        for i in range(1, len(nums)):\\n            if nums[i-1] >= nums[i]:\\n                # Record the index where we \"dip\", where we violate the strictly increasing order property\\n                if dip == -1:\\n                    dip = i\\n                else:\\n                    return False\\n        \\n        if dip == -1:\\n            return True\\n        \\n        # If the dip happened at the end of nums, we could just cut it off and the list would become strictly\\n        # increasing; Or if cutting out nums[dip] results in nums[dip-1] < nums[dip+1], that also works\\n        if dip == len(nums) - 1 or nums[dip-1] < nums[dip+1]:\\n            return True\\n        \\n        # If the dip happened at the second element (index = 1), we could just cut off the higher element at\\n        # index == 0; Or if cutting out nums[dip-1] results in nums[dip-2] < nums[dip], that also works\\n        if dip == 1 or nums[dip-2] < nums[dip]:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316226,
                "title": "c-one-pass-solution",
                "content": "**Intuition**\\nwhen find a non-increasing pair (```nums[i] <= nums[i-1]```), we need to delete ```nums[i]``` or ```nums[i-1]``` based on ```nums[i-2]```.\\n![image](https://assets.leetcode.com/users/images/0586c443-d024-40b4-be65-167443ee8a81_1625424955.3632042.png)\\n\\n**Complexity**\\n- time: O(N)\\n- space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public bool CanBeIncreasing(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return true;\\n        \\n        int remove = 0, currMin = nums[0];\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            if(nums[i] <= currMin)\\n            {\\n                if(remove >= 1)\\n                    return false;\\n                \\n                if(i == 1 || nums[i] > nums[i - 2])\\n                    currMin = nums[i];\\n                \\n                remove++;\\n            }\\n            else\\n            {\\n                currMin = nums[i];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```nums[i] <= nums[i-1]```\n```nums[i]```\n```nums[i-1]```\n```nums[i-2]```\n```\\npublic class Solution {\\n    public bool CanBeIncreasing(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return true;\\n        \\n        int remove = 0, currMin = nums[0];\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            if(nums[i] <= currMin)\\n            {\\n                if(remove >= 1)\\n                    return false;\\n                \\n                if(i == 1 || nums[i] > nums[i - 2])\\n                    currMin = nums[i];\\n                \\n                remove++;\\n            }\\n            else\\n            {\\n                currMin = nums[i];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313302,
                "title": "c-o-n-solution-for-problem-1909-remove-one-element",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums)\\n    {\\n        bool res = 1; int sz = nums.size(); int i; int chance = 1;\\n        \\n        for(i=1; i<sz; i++)\\n        {   \\n            if(nums[i-1] >= nums[i])\\n            {\\n                chance -= 1; \\n                \\n                if( i >= 2 && nums[i-2] >= nums[i])\\n                {   \\n                    nums[i] = nums[i-1];\\n                }\\n            }\\n            if(chance<0){ res = 0;}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums)\\n    {\\n        bool res = 1; int sz = nums.size(); int i; int chance = 1;\\n        \\n        for(i=1; i<sz; i++)\\n        {   \\n            if(nums[i-1] >= nums[i])\\n            {\\n                chance -= 1; \\n                \\n                if( i >= 2 && nums[i-2] >= nums[i])\\n                {   \\n                    nums[i] = nums[i-1];\\n                }\\n            }\\n            if(chance<0){ res = 0;}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298513,
                "title": "easy-java-beats-100-simple-code",
                "content": "```\\npublic boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        int t=0;\\n        int n = nums.length;\\n        if(nums.length<=2) return true;\\n        if(nums.length >2){\\n\\n            for(int i = 0; i < n-1 ; i++){\\n                if(nums[i] == nums[i+1]){\\n                    t++;\\n                }\\n            }\\n            if(t== nums.length-1) return false;\\n        }\\n        \\n\\t    int index = -1;\\n        for(int i = 1; i < n ; i++){\\n            if (nums[i - 1] >= nums[i]){\\n                count++;\\n                index = i;\\n            }\\n        }\\n        if (count > 1) return false;\\n        if (count == 0) return true;\\n        if (index == n - 1 || index == 1) return true;\\n        if (nums[index - 1] < nums[index + 1]) return true;\\n        if (nums[index - 2] < nums[index]) return true;\\n\\n        return false;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        int t=0;\\n        int n = nums.length;\\n        if(nums.length<=2) return true;\\n        if(nums.length >2){\\n\\n            for(int i = 0; i < n-1 ; i++){\\n                if(nums[i] == nums[i+1]){\\n                    t++;\\n                }\\n            }\\n            if(t== nums.length-1) return false;\\n        }\\n        \\n\\t    int index = -1;\\n        for(int i = 1; i < n ; i++){\\n            if (nums[i - 1] >= nums[i]){\\n                count++;\\n                index = i;\\n            }\\n        }\\n        if (count > 1) return false;\\n        if (count == 0) return true;\\n        if (index == n - 1 || index == 1) return true;\\n        if (nums[index - 1] < nums[index + 1]) return true;\\n        if (nums[index - 2] < nums[index]) return true;\\n\\n        return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1298505,
                "title": "python-one-pass-solution",
                "content": "```\\nflag = 0\\nnums = [0] + nums + [1001]\\nfor i in range(len(nums) - 3):\\n\\tif nums[i + 1] >= nums[i + 2]:\\n\\t\\tif flag:\\n\\t\\t\\treturn False\\n\\t\\tif nums[i] >= nums[i + 2] and nums[i + 1] >= nums[i + 3]:\\n\\t\\t\\treturn False\\n\\t\\tflag = 1\\nreturn True\\n```",
                "solutionTags": [],
                "code": "```\\nflag = 0\\nnums = [0] + nums + [1001]\\nfor i in range(len(nums) - 3):\\n\\tif nums[i + 1] >= nums[i + 2]:\\n\\t\\tif flag:\\n\\t\\t\\treturn False\\n\\t\\tif nums[i] >= nums[i + 2] and nums[i + 1] >= nums[i + 3]:\\n\\t\\t\\treturn False\\n\\t\\tflag = 1\\nreturn True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3134565,
                "title": "java-solution-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, we\\'re checking if an array of integers can be sorted in ascending order by creating all possible sub-arrays excluding one element at a time, checking if each sub-array is sorted in ascending order, and returning true if any sub-array is sorted. If no sub-array is sorted, it returns false.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < nums.length; j++) {\\n                if(i != j) {\\n                    list.add(nums[j]);\\n                }\\n            }\\n\\n            if(isSorted(list)) {\\n                return true;\\n            } else {\\n                list.clear();\\n            }\\n        }\\n\\n        return false;     \\n    }\\n\\n    boolean isSorted(List<Integer> list) {\\n        for(int i = 0; i < list.size() - 1; i++) {\\n            if(list.get(i) >= list.get(i+1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < nums.length; j++) {\\n                if(i != j) {\\n                    list.add(nums[j]);\\n                }\\n            }\\n\\n            if(isSorted(list)) {\\n                return true;\\n            } else {\\n                list.clear();\\n            }\\n        }\\n\\n        return false;     \\n    }\\n\\n    boolean isSorted(List<Integer> list) {\\n        for(int i = 0; i < list.size() - 1; i++) {\\n            if(list.get(i) >= list.get(i+1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810599,
                "title": "python3-solution-easy-to-understand",
                "content": "```\\ndef canBeIncreasing(self, nums: List[int]) -> bool:\\n\\tn = len(nums)\\n\\tdef isIncreasing(arr):\\n\\t\\ti =0\\n\\t\\twhile i <len(arr)-1:\\n\\t\\t\\tif arr[i] >= arr[i +1]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\ti +=1\\n\\t\\treturn True \\n\\n\\tfor i in range(n-1,-1,-1):\\n\\t\\ttemp = nums.pop(i)\\n\\t\\tif isIncreasing(nums):\\n\\t\\t\\treturn True\\n\\t\\tnums.insert(i,temp)\\n\\treturn False",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\ndef canBeIncreasing(self, nums: List[int]) -> bool:\\n\\tn = len(nums)\\n\\tdef isIncreasing(arr):\\n\\t\\ti =0\\n\\t\\twhile i <len(arr)-1:\\n\\t\\t\\tif arr[i] >= arr[i +1]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\ti +=1\\n\\t\\treturn True \\n\\n\\tfor i in range(n-1,-1,-1):\\n\\t\\ttemp = nums.pop(i)\\n\\t\\tif isIncreasing(nums):\\n\\t\\t\\treturn True\\n\\t\\tnums.insert(i,temp)\\n\\treturn False",
                "codeTag": "Python3"
            },
            {
                "id": 2795161,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool canBeIncreasing(vector<int>& nums) {\\n\\tint previous = nums[0];\\n\\tbool used = false;\\n\\tfor (int i = 1; i < nums.size(); i++){\\n\\t\\tif (nums[i] <= previous){ \\n            if (used)\\n                return false;\\n            used = true;\\n            if (i == 1 || nums[i] > nums[i - 2])\\n                previous = nums[i];\\n\\t\\t} else\\n\\t\\t\\tprevious = nums[i];\\n\\t}\\n\\treturn true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool canBeIncreasing(vector<int>& nums) {\\n\\tint previous = nums[0];\\n\\tbool used = false;\\n\\tfor (int i = 1; i < nums.size(); i++){\\n\\t\\tif (nums[i] <= previous){ \\n            if (used)\\n                return false;\\n            used = true;\\n            if (i == 1 || nums[i] > nums[i - 2])\\n                previous = nums[i];\\n\\t\\t} else\\n\\t\\t\\tprevious = nums[i];\\n\\t}\\n\\treturn true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729552,
                "title": "solution-faster-than-100",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canBeIncreasing(vector<int>& nums) {\\n\\t\\t\\tstack<int> s;\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\ts.push(nums[0]);\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\t\\tif(!s.empty()){\\n\\t\\t\\t\\t\\t\\tif(nums[i] > s.top())\\n\\t\\t\\t\\t\\t\\t\\ts.push(nums[i]);\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tif(i<n-1 && nums[i+1] <= s.top()){\\n\\t\\t\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t   count++;\\n\\t\\t\\t\\t\\t}   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ts.push(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\tif(count == 1 || count == 0)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n};",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool canBeIncreasing(vector<int>& nums) {\\n\\t\\t\\tstack<int> s;\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\ts.push(nums[0]);\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\t\\tif(!s.empty()){\\n\\t\\t\\t\\t\\t\\tif(nums[i] > s.top())\\n\\t\\t\\t\\t\\t\\t\\ts.push(nums[i]);\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tif(i<n-1 && nums[i+1] <= s.top()){\\n\\t\\t\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2609495,
                "title": "c-stack-easy",
                "content": "Here, we\\'ll check the default index count from start and from end , if any of it is one or zero then it is possible otherwise it is not!\\n\\n///\\n\\nclass Solution {\\npublic:\\n\\n    bool canBeIncreasing(vector<int>& nums) {\\n        stack<int> st;\\n        int count = 0;\\n        for(auto ele : nums)  // first we\\'ll traverse from start\\n        {\\n           while(!st.empty() && st.top() >= ele)\\n               count++,st.pop();\\n            st.push(ele);\\n        }\\n    while(!st.empty()) // make the stack empty\\n        st.pop();\\n\\t\\t\\n    int count2 = 0;\\n    for(int i = nums.size() - 1 ; i >= 0 ; --i) // now we\\'ll traverse from end\\n    {\\n        while(!st.empty() && st.top() <= nums[i])\\n            count2++,st.pop();\\n        st.push(nums[i]);\\n    }\\n    \\n    if(count == 0 || count == 1 || count2 == 0 || count2 == 1) // if any of these condition is true \\n        return true;\\n    return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool canBeIncreasing(vector<int>& nums) {\\n        stack<int> st;\\n        int count = 0;\\n        for(auto ele : nums)  // first we\\'ll traverse from start\\n        {\\n           while(!st.empty() && st.top() >= ele)\\n               count++,st.pop();\\n            st.push(ele);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2372885,
                "title": "direct-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int>& a){\\n        int c1=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i-1]<a[i]){\\n                c1++;\\n            }\\n        }\\n        if(c1==a.size()-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        if(nums.size()==2){\\n            return true;\\n        }\\n        if(compare(nums)){\\n            return true;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            vector<int> a;\\n            for(int j=0;j<nums.size();j++){\\n                a.push_back(nums[j]);\\n            }\\n            a.erase(a.begin()+i);\\n            if(compare(a)){\\n                return true;\\n            }\\n            a.clear();\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int>& a){\\n        int c1=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i-1]<a[i]){\\n                c1++;\\n            }\\n        }\\n        if(c1==a.size()-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        if(nums.size()==2){\\n            return true;\\n        }\\n        if(compare(nums)){\\n            return true;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            vector<int> a;\\n            for(int j=0;j<nums.size();j++){\\n                a.push_back(nums[j]);\\n            }\\n            a.erase(a.begin()+i);\\n            if(compare(a)){\\n                return true;\\n            }\\n            a.clear();\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298491,
                "title": "java-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int last_index=0;\\n        boolean removed=false;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[last_index]){\\n                if(removed) return false;\\n                if(i>1 && nums[i-2]>=nums[i]){\\n                    last_index=i-1;\\n                }else last_index=i;\\n                removed=true;\\n            }else last_index=i;\\n        }\\n        return true;\\n    }\\n}\\n/*\\n1. Start iterating the array, maintain a last_index variable to keep track of the last index until which array is strictly increasing. If array is itself strictly_increasing iteration will end and we\\'ll return true.\\n2. But, suppose at index i the pattern is broken, figure out which index needs to be removed i-1 or i.\\n3. If nums[i-2]<nums[i]<nums[i-1], remove nums[i-1] , else if nums[i]<nums[i-2]<nums[i-1] remove nums[i]. last_index will get updated to i or i-1 based on this removal.\\n4. Once removed, update the flag, if removal is required again, return false, otherwise true.\\n5. Do comment or upvote if you stumble upon this thread.\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int last_index=0;\\n        boolean removed=false;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[last_index]){\\n                if(removed) return false;\\n                if(i>1 && nums[i-2]>=nums[i]){\\n                    last_index=i-1;\\n                }else last_index=i;\\n                removed=true;\\n            }else last_index=i;\\n        }\\n        return true;\\n    }\\n}\\n/*\\n1. Start iterating the array, maintain a last_index variable to keep track of the last index until which array is strictly increasing. If array is itself strictly_increasing iteration will end and we\\'ll return true.\\n2. But, suppose at index i the pattern is broken, figure out which index needs to be removed i-1 or i.\\n3. If nums[i-2]<nums[i]<nums[i-1], remove nums[i-1] , else if nums[i]<nums[i-2]<nums[i-1] remove nums[i]. last_index will get updated to i or i-1 based on this removal.\\n4. Once removed, update the flag, if removal is required again, return false, otherwise true.\\n5. Do comment or upvote if you stumble upon this thread.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285304,
                "title": "javascript-solution-explained",
                "content": "Let\\'s take a look at two examples:\\n![image](https://assets.leetcode.com/users/images/126601bc-65f1-481f-805b-b73059835ca8_1657878084.8660727.png)\\n\\n```\\nvar canBeIncreasing = function(nums) {\\n    let cnt = 0;\\n    for (let i = 1; i < nums.length && cnt < 2; i++) {\\n        if (nums[i - 1] >= nums[i]) {\\n            cnt++\\n            if (i > 1 && nums[i - 2] >= nums[i]) {\\n                nums[i] = nums[i - 1]\\n            }\\n        }\\n    }\\n    \\n    return cnt < 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeIncreasing = function(nums) {\\n    let cnt = 0;\\n    for (let i = 1; i < nums.length && cnt < 2; i++) {\\n        if (nums[i - 1] >= nums[i]) {\\n            cnt++\\n            if (i > 1 && nums[i - 2] >= nums[i]) {\\n                nums[i] = nums[i - 1]\\n            }\\n        }\\n    }\\n    \\n    return cnt < 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2270123,
                "title": "100-easy-java-soln",
                "content": "if this soln. helps you in anyway then pls upvote. :)\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n      int count=0;\\n        int prev=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[i-1]){\\n                count++;\\n                prev=i;\\n            }\\n            if(count>1){\\n                return false;\\n            }\\n        }\\n        if(count==0 || prev==0 || prev==1 || prev==nums.length-1){\\n            return true;\\n        }\\n        else if(nums[prev+1]>nums[prev-1] || nums[prev]>nums[prev-2]){\\n            return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n      int count=0;\\n        int prev=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[i-1]){\\n                count++;\\n                prev=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2254203,
                "title": "fastest-java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) \\n    {\\n        int count = 0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                if(count>1)\\n                    return false;\\n                if(i>1 && nums[i]<=nums[i-2])\\n                    nums[i]=nums[i-1];\\n                count++;\\n            }\\n        }\\n        return (count>1)?false:true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canBeIncreasing(int[] nums) \\n    {\\n        int count = 0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                if(count>1)\\n                    return false;\\n                if(i>1 && nums[i]<=nums[i-2])\\n                    nums[i]=nums[i-1];\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2249478,
                "title": "easiest-solution-python",
                "content": "```\\nclass Solution(object):\\n    def canBeIncreasing(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def isIncreasing(nums):\\n            n  = len(nums)\\n            for i in range(n-1):\\n                if nums[i]>=nums[i+1]:\\n                    return False\\n            return True\\n        for i in range(len(nums)):\\n            if isIncreasing(nums[:i]+nums[i+1:]):\\n                return True\\n        return False\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def canBeIncreasing(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def isIncreasing(nums):\\n            n  = len(nums)\\n            for i in range(n-1):\\n                if nums[i]>=nums[i+1]:\\n                    return False\\n            return True\\n        for i in range(len(nums)):\\n            if isIncreasing(nums[:i]+nums[i+1:]):\\n                return True\\n        return False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232135,
                "title": "java-solution-easy-to-understand-using-stack",
                "content": "```\\n\\n```class Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n       Stack<Integer> stack = new Stack<>();\\n       int len = nums.length;  \\n        int count =0;\\n        \\n        for(int i=0 ; i < len  ; i++) \\n        {\\n            \\n            if( stack.empty() || stack.peek() < nums[i])\\n            {\\n                stack.push(nums[i]);\\n            }\\n            else {\\n                int x= stack.pop();\\n                count++;\\n                if(stack.empty() || stack.peek() < nums[i])\\n                {\\n                    stack.push(nums[i]);\\n                }else {\\n                   stack.push(x);\\n                }\\n            }\\n            \\n            if(count > 1)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2197571,
                "title": "easy-well-commented-o-n-c-code",
                "content": "```\\nbool canBeIncreasing(vector<int>& nums) {\\n        int n=nums.size();\\n        int prev=-1000000, count=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i] < nums[i+1])\\n                prev=nums[i]; // store i-1th element used for decreasing pair \\n            else\\n            {\\n                // here we address the corner case where elements are like [1,2,1]\\n                // where we cannot just change the number as it would result in\\n                // non strictly increasing sequence but we need strictly\\n                if(nums[i+1] == prev)\\n                {\\n                    if(i+2 < n)\\n                    {\\n                        // if fourth number is greater than nums[i] as we have to remove\\n                        // i+1th number else it would result in same adjacent numbers\\n                        // for case [1,4,1,5]\\n                        if(nums[i] < nums[i+2])\\n                            nums[i+1]=nums[i];\\n                        else // for case [1,4,1,3] where it is not possible either way\\n                            return false;\\n                    }\\n                }\\n                // here we can simply change the decreasing pair, for example\\n                // for pair [ 2,10,5,15 ] we can change [ 2,10,10,15 ] which means\\n                // same as removing elements\\n                if(nums[i+1] < prev)\\n                    nums[i+1] = nums[i];\\n                count++; // count number of changes\\n                if(count > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\nPLEASE UPVOTE IF YOU GAIN SOMETHING FROM THE SOLUTION\\nOne more question almost as same as this one is 665. Non-decreasing array. Try that before solving this one.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool canBeIncreasing(vector<int>& nums) {\\n        int n=nums.size();\\n        int prev=-1000000, count=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i] < nums[i+1])\\n                prev=nums[i]; // store i-1th element used for decreasing pair \\n            else\\n            {\\n                // here we address the corner case where elements are like [1,2,1]\\n                // where we cannot just change the number as it would result in\\n                // non strictly increasing sequence but we need strictly\\n                if(nums[i+1] == prev)\\n                {\\n                    if(i+2 < n)\\n                    {\\n                        // if fourth number is greater than nums[i] as we have to remove\\n                        // i+1th number else it would result in same adjacent numbers\\n                        // for case [1,4,1,5]\\n                        if(nums[i] < nums[i+2])\\n                            nums[i+1]=nums[i];\\n                        else // for case [1,4,1,3] where it is not possible either way\\n                            return false;\\n                    }\\n                }\\n                // here we can simply change the decreasing pair, for example\\n                // for pair [ 2,10,5,15 ] we can change [ 2,10,10,15 ] which means\\n                // same as removing elements\\n                if(nums[i+1] < prev)\\n                    nums[i+1] = nums[i];\\n                count++; // count number of changes\\n                if(count > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060202,
                "title": "c-easy-problem",
                "content": "```\\nclass Solution {\\n    bool isMonotone(vector<int>& v){\\n        int l = v.size();\\n        for(int i=0; i<l-1; ++i){\\n            if(v[i] >= v[i+1]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int c=0, l = nums.size(),i,j,k;\\n        vector<int> v = nums;\\n        for(i=0; i<l; ++i){\\n            v.erase(v.begin()+i);\\n            bool flag = isMonotone(v);\\n            if(flag) return true;\\n            else v.insert(v.begin()+i,nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool isMonotone(vector<int>& v){\\n        int l = v.size();\\n        for(int i=0; i<l-1; ++i){\\n            if(v[i] >= v[i+1]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int c=0, l = nums.size(),i,j,k;\\n        vector<int> v = nums;\\n        for(i=0; i<l; ++i){\\n            v.erase(v.begin()+i);\\n            bool flag = isMonotone(v);\\n            if(flag) return true;\\n            else v.insert(v.begin()+i,nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027683,
                "title": "simple-python-solution-with-detailed-explanation-easy-to-understand",
                "content": "please give me a thumb up if you like my solution!\\n\\n```\\n\\n```class Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        \\n        if len(nums) <= 2:      # if the length of nums <= 2, return True since you can always have a 1 number list which can be considered as strickly increasing\\n            return True\\n        \\n        for i in range(len(nums)):      # iterate through nums, using slicing to remove one of the element in the list a time, if nums[:i]+nums[i+1:] == sorted(list(set(nums[:i]+nums[i+1:]))), return True\\n            if nums[:i]+nums[i+1:] == sorted(list(set(nums[:i]+nums[i+1:]))):\\n                return True\\n \\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1965553,
                "title": "java-one-pass-o-1-space",
                "content": "We use `firstPre` and `secondPre` to record the largest number and the second largest number we meet so far respectively. When we meet the a number (let\\'s say the `i`th number) which smaller than its previous number, there can be two cases:\\n1. should remove the `i`th number itself.\\n    For example, we have an array `[1, 2, 1, 5, 7]`, we should remove the second 1 when we meet it. The `firstPre` is 2 and the `secondPre` is 1, we just keep them and move to next number.\\n\\t\\n2. should remove the previous number\\n    For example, we have an array `[1, 2, 10, 5, 7]`, we should remove 10 when we meet 5. The `firstPre` is 10 and the `secondPre` is 2, we just update the `firstPre` to 5.\\n\\t\\nAlso we should count how many times we do remove operation.\\n\\t\\n```\\n\\tpublic boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        int firstPre = nums[0];\\n        int secondPre = 0;\\n        for (int i = 1; i < nums.length && count < 2; ++i) {\\n            if (nums[i] > firstPre) {\\n                secondPre = firstPre;\\n                firstPre = nums[i];\\n            } else if (nums[i] > secondPre) {\\n                firstPre = nums[i];\\n                count++;\\n            } else {\\n                count++;\\n            }\\n        }\\n        return count < 2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        int firstPre = nums[0];\\n        int secondPre = 0;\\n        for (int i = 1; i < nums.length && count < 2; ++i) {\\n            if (nums[i] > firstPre) {\\n                secondPre = firstPre;\\n                firstPre = nums[i];\\n            } else if (nums[i] > secondPre) {\\n                firstPre = nums[i];\\n                count++;\\n            } else {\\n                count++;\\n            }\\n        }\\n        return count < 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879501,
                "title": "python-o-n-faster-than-92",
                "content": "# Please upvote if it helps\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        \\n        i, flag = 1,0\\n        prev = nums[0]\\n        while flag<2 and i<len(nums):\\n            if prev >= nums[i]:\\n                flag +=1\\n                if i==1:\\n                    prev = nums[1]\\n                elif  nums[i]<=nums[i-2]:\\n                    prev = nums[i-1]\\n                else:\\n                    prev = nums[i-2]\\n                    i -=1\\n                \\n            else:\\n                prev = nums[i]\\n               \\n            i +=1\\n        \\n        return flag<2\\n            \\n```\\n\\n![image](https://assets.leetcode.com/users/images/0df2e3dc-e599-4036-9e0c-44b3a18ad88a_1648125849.8792634.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        \\n        i, flag = 1,0\\n        prev = nums[0]\\n        while flag<2 and i<len(nums):\\n            if prev >= nums[i]:\\n                flag +=1\\n                if i==1:\\n                    prev = nums[1]\\n                elif  nums[i]<=nums[i-2]:\\n                    prev = nums[i-1]\\n                else:\\n                    prev = nums[i-2]\\n                    i -=1\\n                \\n            else:\\n                prev = nums[i]\\n               \\n            i +=1\\n        \\n        return flag<2\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807618,
                "title": "java-multiple-approach-with-explanation-runtime-0-ms-100-faster",
                "content": "# Please upvote if you like the solution\\n\\n```\\nclass Solution {\\n   \\n    /***\\n     *              **********  Approach - 1 *****************\\n     *\\n     *   Count the Number of element not in sequence from Left to Right and Right to left.\\n     *   Runtime: 1 ms, faster than 69.47% of Java online submissions\\n     */\\n    public boolean canBeIncreasing1(int[] nums) {\\n\\n        int leftCount = 0, rightCount = 0, numsLength = nums.length;\\n\\n        // Initializing the current start and end\\n        int currentEnd = nums[numsLength - 1], currentStart = nums[0];\\n\\n        /**\\n         * Intention is to find the number of elements is not in sequence when traversing from END to Start.\\n         */\\n        for (int i = numsLength - 2; i >= 0; i--) {\\n            if (nums[i] < currentEnd) {\\n                currentEnd = nums[i];\\n            } else {\\n                rightCount++;\\n            }\\n        }\\n\\n        /**\\n         * Intention is to find the number of elements is not in sequence when traversing from START to Esnd.\\n         */\\n        for (int i = 1; i < numsLength; i++) {\\n            if (nums[i] > currentStart) {\\n                currentStart = nums[i];\\n            } else {\\n                leftCount++;\\n            }\\n        }\\n\\n        /**\\n         * Check whether minimum of left or right count is less than or equal to 1 or not.\\n         */\\n        return Math.min(leftCount, rightCount) <= 1;\\n    }\\n\\n\\n    /***\\n     *              **********  Approach - 2 *****************\\n     *\\n     *   Count the Number of element not in sequence from Left to Right and decide which element to remove\\n     *   Runtime: 0 ms, faster than 100.00% of Java online submissions\\n     */\\n    public boolean canBeIncreasing(int[] nums) {\\n\\n        int nonSequentialElements = 0, numsLength = nums.length;\\n        // Initializing the previous value\\n        int previousVal = nums[0];\\n\\n        for (int i = 1; i < numsLength; i++) {\\n            /**\\n             * If current value is greater than its previous value, then update the previous value to current value\\n             */\\n            if (nums[i] > previousVal) {\\n                previousVal = nums[i];\\n            }\\n            /**\\n             * Current value is not greater than its previous value.\\n             * So, in that case we have to decide which value we should remove nums[i] or nums[i-1]\\n             *\\n             * Case-1 :\\n             *      Suppose for an example -\\n             *                  0  1   2  3  4\\n             *          nums = [1, 2, 10, 5, 7]\\n             *\\n             *      when at position 3 i.e value:5 it will encounter its nonSequential number as 5 not greater than 10\\n             *      So, now the question is which element we should ignore 5 or 10?\\n             *\\n             *      If the current element i.e. 5 is greater than its previous to previous element i.e. if 5 > 2 that means\\n             *      with 5 it\\'s in sequence with the existing section. So, we can ignore the previous value i.e. 10.\\n             *\\n             *  Case-2:\\n             *      Suppose for an example -\\n             *                  0  1  2  3\\n             *          nums = [2, 3, 1, 2]\\n             *\\n             *       when at position 2 i.e value:1 it will encounter its nonSequential number as 1 not greater than 3.\\n             *       Now we can check whether the current element i.e. 1 is greater than its previous to previous element\\n             *       i.e. whether 1 > 2 or not. As in this case its not same meaning its not in sequence with the existing section.\\n             *\\n             *       So, we can ignore the current value.\\n             *\\n             */\\n            else {\\n                /**\\n                 *  Case-1 : If the current element is greater than its previous to previous element, that means\\n                 *           it\\'s in sequence with the existing section. So, we can ignore the previous value.\\n                 *\\n                 *  Exception case : For the first element if the value is less than its previous value then we can ignore the\\n                 *                   previous value.\\n                 *                   Like nums = [2, 1, 5, 7]\\n                 */\\n                if (i == 1 || nums[i] > nums[i - 2]) {\\n                    previousVal = nums[i];\\n                }\\n                /**\\n                 *  Case-2 : If the current element is not greater than its previous to previous element, that means\\n                 *           it\\'s not in sequence with the existing section. So, we can ignore the current value.\\n                 */\\n                else {\\n                    previousVal = nums[i - 1];\\n                }\\n                nonSequentialElements++;\\n            }\\n\\n            /**\\n             * If non sequential element count is greater than 1 we can return false.\\n             */\\n            if (nonSequentialElements > 1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/dea1f1e2-499a-4ace-bd7f-1baacb2ff8d5_1646076888.2887282.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\n    /***\\n     *              **********  Approach - 1 *****************\\n     *\\n     *   Count the Number of element not in sequence from Left to Right and Right to left.\\n     *   Runtime: 1 ms, faster than 69.47% of Java online submissions\\n     */\\n    public boolean canBeIncreasing1(int[] nums) {\\n\\n        int leftCount = 0, rightCount = 0, numsLength = nums.length;\\n\\n        // Initializing the current start and end\\n        int currentEnd = nums[numsLength - 1], currentStart = nums[0];\\n\\n        /**\\n         * Intention is to find the number of elements is not in sequence when traversing from END to Start.\\n         */\\n        for (int i = numsLength - 2; i >= 0; i--) {\\n            if (nums[i] < currentEnd) {\\n                currentEnd = nums[i];\\n            } else {\\n                rightCount++;\\n            }\\n        }\\n\\n        /**\\n         * Intention is to find the number of elements is not in sequence when traversing from START to Esnd.\\n         */\\n        for (int i = 1; i < numsLength; i++) {\\n            if (nums[i] > currentStart) {\\n                currentStart = nums[i];\\n            } else {\\n                leftCount++;\\n            }\\n        }\\n\\n        /**\\n         * Check whether minimum of left or right count is less than or equal to 1 or not.\\n         */\\n        return Math.min(leftCount, rightCount) <= 1;\\n    }\\n\\n\\n    /***\\n     *              **********  Approach - 2 *****************\\n     *\\n     *   Count the Number of element not in sequence from Left to Right and decide which element to remove\\n     *   Runtime: 0 ms, faster than 100.00% of Java online submissions\\n     */\\n    public boolean canBeIncreasing(int[] nums) {\\n\\n        int nonSequentialElements = 0, numsLength = nums.length;\\n        // Initializing the previous value\\n        int previousVal = nums[0];\\n\\n        for (int i = 1; i < numsLength; i++) {\\n            /**\\n             * If current value is greater than its previous value, then update the previous value to current value\\n             */\\n            if (nums[i] > previousVal) {\\n                previousVal = nums[i];\\n            }\\n            /**\\n             * Current value is not greater than its previous value.\\n             * So, in that case we have to decide which value we should remove nums[i] or nums[i-1]\\n             *\\n             * Case-1 :\\n             *      Suppose for an example -\\n             *                  0  1   2  3  4\\n             *          nums = [1, 2, 10, 5, 7]\\n             *\\n             *      when at position 3 i.e value:5 it will encounter its nonSequential number as 5 not greater than 10\\n             *      So, now the question is which element we should ignore 5 or 10?\\n             *\\n             *      If the current element i.e. 5 is greater than its previous to previous element i.e. if 5 > 2 that means\\n             *      with 5 it\\'s in sequence with the existing section. So, we can ignore the previous value i.e. 10.\\n             *\\n             *  Case-2:\\n             *      Suppose for an example -\\n             *                  0  1  2  3\\n             *          nums = [2, 3, 1, 2]\\n             *\\n             *       when at position 2 i.e value:1 it will encounter its nonSequential number as 1 not greater than 3.\\n             *       Now we can check whether the current element i.e. 1 is greater than its previous to previous element\\n             *       i.e. whether 1 > 2 or not. As in this case its not same meaning its not in sequence with the existing section.\\n             *\\n             *       So, we can ignore the current value.\\n             *\\n             */\\n            else {\\n                /**\\n                 *  Case-1 : If the current element is greater than its previous to previous element, that means\\n                 *           it\\'s in sequence with the existing section. So, we can ignore the previous value.\\n                 *\\n                 *  Exception case : For the first element if the value is less than its previous value then we can ignore the\\n                 *                   previous value.\\n                 *                   Like nums = [2, 1, 5, 7]\\n                 */\\n                if (i == 1 || nums[i] > nums[i - 2]) {\\n                    previousVal = nums[i];\\n                }\\n                /**\\n                 *  Case-2 : If the current element is not greater than its previous to previous element, that means\\n                 *           it\\'s not in sequence with the existing section. So, we can ignore the current value.\\n                 */\\n                else {\\n                    previousVal = nums[i - 1];\\n                }\\n                nonSequentialElements++;\\n            }\\n\\n            /**\\n             * If non sequential element count is greater than 1 we can return false.\\n             */\\n            if (nonSequentialElements > 1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687858,
                "title": "o-n-c-simple-solution",
                "content": "```\\n bool canBeIncreasing(vector<int>& nums) {\\n        int cnt=0;\\n        int prev=nums[0];\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            if(prev<nums[i])prev=nums[i];\\n           else{\\n             if(i==1||nums[i]>nums[i-2])\\n                 prev=nums[i];\\n                cnt++;\\n           }\\n        }\\n        return (cnt<2);  // the non-increasing property can be violated only once as we can remove only 1 element\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool canBeIncreasing(vector<int>& nums) {\\n        int cnt=0;\\n        int prev=nums[0];\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            if(prev<nums[i])prev=nums[i];\\n           else{\\n             if(i==1||nums[i]>nums[i-2])\\n                 prev=nums[i];\\n                cnt++;\\n           }\\n        }\\n        return (cnt<2);  // the non-increasing property can be violated only once as we can remove only 1 element\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670354,
                "title": "php-solution-faster-than-100-00",
                "content": "```\\nfunction canBeIncreasing($nums) {\\n\\tif(count($nums)==2){\\n\\t\\treturn true;\\n\\t}else{\\n\\t\\tfor($i=0;$i<count($nums);$i++){\\n\\t\\t\\t$arrs = $arr = $nums;\\n\\t\\t\\tarray_splice($arr,$i,1);\\n\\t\\t\\tarray_splice($arrs,$i,1);\\n\\t\\t\\tsort($arr);\\n\\t\\t\\tif(($arr==$arrs)&&($arr==array_unique($arr))){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction canBeIncreasing($nums) {\\n\\tif(count($nums)==2){\\n\\t\\treturn true;\\n\\t}else{\\n\\t\\tfor($i=0;$i<count($nums);$i++){\\n\\t\\t\\t$arrs = $arr = $nums;\\n\\t\\t\\tarray_splice($arr,$i,1);\\n\\t\\t\\tarray_splice($arrs,$i,1);\\n\\t\\t\\tsort($arr);\\n\\t\\t\\tif(($arr==$arrs)&&($arr==array_unique($arr))){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1602737,
                "title": "c-2-solutions-easy-and-simple-approaches-fast-and-slow-approach",
                "content": "**Solution 1: Here I build a new array each time, each time excluding 1 number and then checking wether the array is strictly increasing or not. If we found any arrary that is strictly increasing then we return true and if we try every possibility of constructing new array after excluding one element then we return false**\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        //this is o(n2) solution for this question \\n         bool flag = true;\\n         for(int i = 0; i<nums.size(); i++){\\n             vector<int>ans;\\n             flag = true;\\n             for(int j = 0; j<nums.size(); j++){\\n                 if(i == j){\\n                     continue;\\n                 }\\n                \\n                 ans.push_back(nums[j]);\\n\\t\\t\\t}\\n                    \\n             for(int j = 1; j<ans.size(); j++){\\n                 if(ans[j-1]>=ans[j]){ \\n                     flag = false;\\n                     break;\\n                 }\\n             }\\n            \\n             if(flag)return flag;\\n         }\\n        \\n            return false;\\n\\t\\t}\\n};\\n```        \\n\\n**Solution 2: By finding the elements that are breaking the strictly increasing order (which we will encounter later), if we again find the elements that are breaking the strictly increasing order then we return the false. You may understand better by the code**\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        //approach 2 using O(n) time complexity \\n        int a = -1, b = -1;\\n        \\n        for(int i = 0; i<nums.size()-1; i++){\\n            if(nums[i]>=nums[i+1]){\\n                if(a!=-1)return false;\\n                else{\\n                    a = i;\\n                    b = i+1;\\n                }\\n            }\\n        }\\n        \\n        if(a==0 || (a == -1 and b == -1)|| b == nums.size()-1)return true;\\n        \\n        if(nums[b]>nums[a-1] || nums[a]<nums[b+1])return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        //this is o(n2) solution for this question \\n         bool flag = true;\\n         for(int i = 0; i<nums.size(); i++){\\n             vector<int>ans;\\n             flag = true;\\n             for(int j = 0; j<nums.size(); j++){\\n                 if(i == j){\\n                     continue;\\n                 }\\n                \\n                 ans.push_back(nums[j]);\\n\\t\\t\\t}\\n                    \\n             for(int j = 1; j<ans.size(); j++){\\n                 if(ans[j-1]>=ans[j]){ \\n                     flag = false;\\n                     break;\\n                 }\\n             }\\n            \\n             if(flag)return flag;\\n         }\\n        \\n            return false;\\n\\t\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        //approach 2 using O(n) time complexity \\n        int a = -1, b = -1;\\n        \\n        for(int i = 0; i<nums.size()-1; i++){\\n            if(nums[i]>=nums[i+1]){\\n                if(a!=-1)return false;\\n                else{\\n                    a = i;\\n                    b = i+1;\\n                }\\n            }\\n        }\\n        \\n        if(a==0 || (a == -1 and b == -1)|| b == nums.size()-1)return true;\\n        \\n        if(nums[b]>nums[a-1] || nums[a]<nums[b+1])return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599248,
                "title": "c-best-and-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n\\n    bool canBeIncreasing(vector<int>& nums) {\\n        bool flag = false;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] >= nums[i]) {\\n                if (flag) return false;\\n                flag = true;\\n                \\n                if (i > 1 && nums[i-2] >= nums[i])\\n                    nums[i] = nums[i-1];\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    bool canBeIncreasing(vector<int>& nums) {\\n        bool flag = false;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] >= nums[i]) {\\n                if (flag) return false;\\n                flag = true;\\n                \\n                if (i > 1 && nums[i-2] >= nums[i])\\n                    nums[i] = nums[i-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1474605,
                "title": "the-fastest-java-solution",
                "content": "![image](https://assets.leetcode.com/users/images/12e322d1-425f-40ae-b01f-f5625dd38aa3_1632132566.5924766.jpeg)\\n```\\n\\tprivate int[] nums;\\n\\n    public boolean canBeIncreasing(int[] nums) {\\n        this.nums = nums;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] <= nums[i - 1]) {\\n                return (ifRemoveFirst(i) || ifRemoveSecond(i)) && restArrInc(i);\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean ifRemoveFirst(int i) {\\n        if (i >= 2 && nums[i] <= nums[i - 2]) {\\n            return false;\\n        }\\n        if (i < nums.length - 1 && nums[i + 1] <= nums[i]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    private boolean ifRemoveSecond(int i) {\\n        if (i < nums.length - 1 && nums[i + 1] <= nums[i - 1]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    private boolean restArrInc(int i) {\\n        int j = i + 2;\\n        while (j < nums.length) {\\n            if (nums[j] <= nums[j - 1]) {\\n                return false;\\n            }\\n            j++;\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/12e322d1-425f-40ae-b01f-f5625dd38aa3_1632132566.5924766.jpeg)\\n```\\n\\tprivate int[] nums;\\n\\n    public boolean canBeIncreasing(int[] nums) {\\n        this.nums = nums;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] <= nums[i - 1]) {\\n                return (ifRemoveFirst(i) || ifRemoveSecond(i)) && restArrInc(i);\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean ifRemoveFirst(int i) {\\n        if (i >= 2 && nums[i] <= nums[i - 2]) {\\n            return false;\\n        }\\n        if (i < nums.length - 1 && nums[i + 1] <= nums[i]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    private boolean ifRemoveSecond(int i) {\\n        if (i < nums.length - 1 && nums[i + 1] <= nums[i - 1]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    private boolean restArrInc(int i) {\\n        int j = i + 2;\\n        while (j < nums.length) {\\n            if (nums[j] <= nums[j - 1]) {\\n                return false;\\n            }\\n            j++;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1451275,
                "title": "py-rm-one-elem-to-make-arr-increasing",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        pop = 0\\n        for i in range(1, len(nums)):\\n            if nums[i-1] >= nums[i]:\\n                pop += 1\\n                if pop > 1: return False\\n                \"\"\"\\n                    At each drop, we have a choice.\\n                    Either drop incoming elem or drop prev elem.\\n                    If incoming elem is less than two prev elem, then drop it since we don\\'t want to drop two prev elem. Edge case is when we don\\'t have two prev elem and the drop is at index 1. In that case, just drop elem at index 0. If there is a drop at index 2, return False.\\n                    If incoming elem is greater than nums[i-2], drop nums[i-1]\\n                \\n                \"\"\"\\n                if i-2 >= 0 and nums[i-2] >= nums[i]:\\n                    nums[i] = nums[i-1]\\n        return pop <= 1\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        pop = 0\\n        for i in range(1, len(nums)):\\n            if nums[i-1] >= nums[i]:\\n                pop += 1\\n                if pop > 1: return False\\n                \"\"\"\\n                    At each drop, we have a choice.\\n                    Either drop incoming elem or drop prev elem.\\n                    If incoming elem is less than two prev elem, then drop it since we don\\'t want to drop two prev elem. Edge case is when we don\\'t have two prev elem and the drop is at index 1. In that case, just drop elem at index 0. If there is a drop at index 2, return False.\\n                    If incoming elem is greater than nums[i-2], drop nums[i-1]\\n                \\n                \"\"\"\\n                if i-2 >= 0 and nums[i-2] >= nums[i]:\\n                    nums[i] = nums[i-1]\\n        return pop <= 1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334049,
                "title": "actually-i-think-this-problem-is-a-little-difficult-java-o-n-solution",
                "content": "```java\\n// AC: Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove One Element to Make the Array Strictly Increasing.\\n// Memory Usage: 40.2 MB, less than 28.30% of Java online submissions for Remove One Element to Make the Array Strictly Increasing.\\n// analyze different cases when nums[i] <= nums[i - 1]\\n// T:O(n), S:O(1)\\n// \\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int previous = nums[0], size = nums.length;\\n        boolean removed = false;\\n        for (int i = 1; i < size; i++) {\\n            if (nums[i] <= previous) {\\n                if (removed) {\\n                    // has removed one element, cannot remove more.\\n                    return false;\\n                } else {\\n                    if (i == 1 || nums[i] > nums[i - 2]) {\\n                        // remove previous, go ahead\\n                        previous = nums[i];\\n                        removed = true;\\n                    } else {\\n                        // remove nums[i], remain previous.\\n                        removed = true;\\n                    }\\n                }\\n            } else {\\n                previous = nums[i];\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// AC: Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove One Element to Make the Array Strictly Increasing.\\n// Memory Usage: 40.2 MB, less than 28.30% of Java online submissions for Remove One Element to Make the Array Strictly Increasing.\\n// analyze different cases when nums[i] <= nums[i - 1]\\n// T:O(n), S:O(1)\\n// \\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int previous = nums[0], size = nums.length;\\n        boolean removed = false;\\n        for (int i = 1; i < size; i++) {\\n            if (nums[i] <= previous) {\\n                if (removed) {\\n                    // has removed one element, cannot remove more.\\n                    return false;\\n                } else {\\n                    if (i == 1 || nums[i] > nums[i - 2]) {\\n                        // remove previous, go ahead\\n                        previous = nums[i];\\n                        removed = true;\\n                    } else {\\n                        // remove nums[i], remain previous.\\n                        removed = true;\\n                    }\\n                }\\n            } else {\\n                previous = nums[i];\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307577,
                "title": "ez-python-code",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(0,len(nums)):\\n            X=nums.copy()\\n            X.pop(i)\\n            if X==sorted(X) and len(set(X))==len(X):\\n                return True\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(0,len(nums)):\\n            X=nums.copy()\\n            X.pop(i)\\n            if X==sorted(X) and len(set(X))==len(X):\\n                return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303282,
                "title": "python-o-n-using-pointers",
                "content": "Just use `skipped` pointer that tracks which element to avoid in comparison\\nBiggest challenge is to figure out which element should be skipped:\\n1) Hill\\n2) Dip\\n\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        l = 0\\n        r = 1\\n        skipped = -1\\n        \\n        while r < len(nums):\\n\\t\\t    # Normal case, strictly increasing array\\n            if nums[l] < nums[r]:\\n                l+=1\\n                if l == skipped:\\n                    l+=1\\n                r+=1\\n                continue\\n\\n            # found non increasing point\\n            if skipped >= 0: return False\\n\\n            # Corner case\\n\\t\\t\\t# l     r\\n            # 100  21 100\\n            # dip<<<\\n            if r == 1:\\n                skipped = 0\\n                l+=1\\n                r+=1\\n            \\n            #      l-1   l    r\\n            # 100, 200, 500, 300, 400\\n            #        <<<hill>>>\\n            elif nums[l-1] < nums[r]:\\n                skipped = l\\n                l = l-1\\n\\n            #      l-1   l    r\\n            # 100, 300, 500, 200, 400\\n            #             >>>dip<<<\\n            else:\\n                skipped = r\\n                r += 1\\n                \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        l = 0\\n        r = 1\\n        skipped = -1\\n        \\n        while r < len(nums):\\n\\t\\t    # Normal case, strictly increasing array\\n            if nums[l] < nums[r]:\\n                l+=1\\n                if l == skipped:\\n                    l+=1\\n                r+=1\\n                continue\\n\\n            # found non increasing point\\n            if skipped >= 0: return False\\n\\n            # Corner case\\n\\t\\t\\t# l     r\\n            # 100  21 100\\n            # dip<<<\\n            if r == 1:\\n                skipped = 0\\n                l+=1\\n                r+=1\\n            \\n            #      l-1   l    r\\n            # 100, 200, 500, 300, 400\\n            #        <<<hill>>>\\n            elif nums[l-1] < nums[r]:\\n                skipped = l\\n                l = l-1\\n\\n            #      l-1   l    r\\n            # 100, 300, 500, 200, 400\\n            #             >>>dip<<<\\n            else:\\n                skipped = r\\n                r += 1\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299872,
                "title": "c-lis-approach",
                "content": "```\\nint n=arr.size();\\n        vector<int>dp(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[j] < arr[i]){\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int maxi=*max_element(dp.begin(),dp.end());\\n        if(maxi+1==n || maxi==n){\\n            return true;\\n        }\\n        return false;\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint n=arr.size();\\n        vector<int>dp(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[j] < arr[i]){\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int maxi=*max_element(dp.begin(),dp.end());\\n        if(maxi+1==n || maxi==n){\\n            return true;\\n        }\\n        return false;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1299704,
                "title": "o-n-pass-java-easy-to-understand-readable-code-100-faster",
                "content": "class Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        \\n        if(nums.length==1)return true;\\n        if(nums.length==2)return true;\\n        \\n         Stack<Integer> stack=new Stack<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(stack.size()==0){\\n                stack.push(nums[i]);\\n            }\\n            else if(nums[i]>stack.peek()){\\n                stack.push(nums[i]);\\n                \\n            }\\n            else{\\n                if(i==1 && nums.length>2){\\n                    \\n                    int a=stack.pop();\\n                    count++;\\n                    if(nums[i+1]>a)stack.push(a);\\n                    \\n                    else if(nums[i+1]>nums[i])stack.push(nums[i]);\\n                    \\n                    else return false;\\n                }\\n                else{\\n                    \\n                   int a= stack.pop();\\n                    \\n                    if(stack.size()!=0 && stack.peek()<nums[i])stack.push(nums[i]);\\n                    else stack.push(a);\\n                    \\n                    count++;\\n                }\\n                                \\n            }\\n            \\n            \\n        }\\n        if(count>1)return false;\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        \\n        if(nums.length==1)return true;\\n        if(nums.length==2)return true;\\n        \\n         Stack<Integer> stack=new Stack<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(stack.size()==0){\\n                stack.push(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1299141,
                "title": "python3-o-n-easy-to-understand-two-pass-solution",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        sorted = [False] * n\\n        sorted_rev = [False] * n\\n        sorted[0] = True\\n        sorted_rev[n - 1] = True\\n        mi = [float(\\'inf\\')] * n\\n        ma = [float(\\'-inf\\')] * n\\n        mi[n - 1] = nums[n - 1]\\n        ma[0] = nums[0]\\n        for i in range(1, n):\\n            ma[i] = max(nums[i], ma[i - 1])\\n            mi[n - i - 1] = min(nums[n - i - 1], mi[n - i])\\n            if nums[i - 1] < nums[i]:\\n                sorted[i] = sorted[i - 1]\\n            else:\\n                sorted[i] = False\\n            if nums[n - i - 1] < nums[n - i]:\\n                sorted_rev[n - i - 1] = sorted_rev[n - i]\\n            else:\\n                sorted_rev[n - i - 1] = False\\n        for i in range(n):\\n            if i == 0:\\n                if i + 1 < n and sorted_rev[i + 1]:\\n                    return True\\n            elif i == n - 1:\\n                if i - 1 >= 0 and sorted[i - 1]:\\n                    return True\\n            else:\\n                if sorted[i - 1] and sorted_rev[i + 1] and ma[i - 1] < mi[i + 1]:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        sorted = [False] * n\\n        sorted_rev = [False] * n\\n        sorted[0] = True\\n        sorted_rev[n - 1] = True\\n        mi = [float(\\'inf\\')] * n\\n        ma = [float(\\'-inf\\')] * n\\n        mi[n - 1] = nums[n - 1]\\n        ma[0] = nums[0]\\n        for i in range(1, n):\\n            ma[i] = max(nums[i], ma[i - 1])\\n            mi[n - i - 1] = min(nums[n - i - 1], mi[n - i])\\n            if nums[i - 1] < nums[i]:\\n                sorted[i] = sorted[i - 1]\\n            else:\\n                sorted[i] = False\\n            if nums[n - i - 1] < nums[n - i]:\\n                sorted_rev[n - i - 1] = sorted_rev[n - i]\\n            else:\\n                sorted_rev[n - i - 1] = False\\n        for i in range(n):\\n            if i == 0:\\n                if i + 1 < n and sorted_rev[i + 1]:\\n                    return True\\n            elif i == n - 1:\\n                if i - 1 >= 0 and sorted[i - 1]:\\n                    return True\\n            else:\\n                if sorted[i - 1] and sorted_rev[i + 1] and ma[i - 1] < mi[i + 1]:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298787,
                "title": "c-using-stl-with-comments",
                "content": "```\\n/*\\n\\nDo please upvote if you are gaining the knowledge of this stl for the first time and learning this!\\n\\nMy Approcah:\\nRemove one element from the array everytime in for loop and check if vector strictly increasing, If It is strictly increasing return true else return false.\\n\\n*/\\n    \\nclass Solution {\\npublic:\\n    bool checkIfIncreasing(vector<int>v1){\\n    //stl function to check if the vector is strictly increasing\\n    auto i2 = std::adjacent_find(v1.begin(), v1.end(), std::greater_equal<int>());\\n    \\n    if (i2 == v1.end()) {  \\n        return true; //if vector is striclty increasing\\n    } \\n    else {\\n        return false; //if vector is not striclty increasing\\n    }\\n }\\n    \\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>v = nums;  //storing nums vector in v.\\n        int c=0;\\n        if(nums.size()==2)\\n            return true;\\n       for (auto i = nums.begin(); i != nums.end(); ++i) {\\n            nums.erase(i); //removing one element from every index\\n            bool t = checkIfIncreasing(nums); // checking the vector after removing ith element is strictly increasing or not\\n            if(t==true)\\n                return true; // the vector after removing ith element is strictly increasing, return true.\\n            nums = v;  //restoring nums vector to original one.\\n      }\\n        return false; //If there is not possiblity to make vector striclty increasing, return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n\\nDo please upvote if you are gaining the knowledge of this stl for the first time and learning this!\\n\\nMy Approcah:\\nRemove one element from the array everytime in for loop and check if vector strictly increasing, If It is strictly increasing return true else return false.\\n\\n*/\\n    \\nclass Solution {\\npublic:\\n    bool checkIfIncreasing(vector<int>v1){\\n    //stl function to check if the vector is strictly increasing\\n    auto i2 = std::adjacent_find(v1.begin(), v1.end(), std::greater_equal<int>());\\n    \\n    if (i2 == v1.end()) {  \\n        return true; //if vector is striclty increasing\\n    } \\n    else {\\n        return false; //if vector is not striclty increasing\\n    }\\n }\\n    \\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>v = nums;  //storing nums vector in v.\\n        int c=0;\\n        if(nums.size()==2)\\n            return true;\\n       for (auto i = nums.begin(); i != nums.end(); ++i) {\\n            nums.erase(i); //removing one element from every index\\n            bool t = checkIfIncreasing(nums); // checking the vector after removing ith element is strictly increasing or not\\n            if(t==true)\\n                return true; // the vector after removing ith element is strictly increasing, return true.\\n            nums = v;  //restoring nums vector to original one.\\n      }\\n        return false; //If there is not possiblity to make vector striclty increasing, return false\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298577,
                "title": "python-easy-o-n-time-and-o-1-space",
                "content": "If the swaps will be more than 1 for both 1) max starting from index 0 and 2) min starting from end then not possible to form strictly increasing array by removing just one element. Code below\\n\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        min_count = max_count = 0\\n        end = len(nums) - 1\\n\\t\\t\\n        min_no = float(\\'inf\\')\\n        max_no = float(\\'-inf\\')\\n\\n        \\n        while end >= 0:\\n            if nums[end] < min_no:\\n                min_no = nums[end]\\n            else:\\n                min_count +=1\\n            end -= 1\\n        \\n        for i in range(0,len(nums)):\\n            if nums[i] > max_no:\\n                max_no = nums[i]\\n            else:\\n                max_count +=1\\n       \\n        if min_count > 1 and max_count > 1:\\n            return False\\n\\n        return True\\n                \\n        ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        min_count = max_count = 0\\n        end = len(nums) - 1\\n\\t\\t\\n        min_no = float(\\'inf\\')\\n        max_no = float(\\'-inf\\')\\n\\n        \\n        while end >= 0:\\n            if nums[end] < min_no:\\n                min_no = nums[end]\\n            else:\\n                min_count +=1\\n            end -= 1\\n        \\n        for i in range(0,len(nums)):\\n            if nums[i] > max_no:\\n                max_no = nums[i]\\n            else:\\n                max_count +=1\\n       \\n        if min_count > 1 and max_count > 1:\\n            return False\\n\\n        return True\\n                \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 4035925,
                "title": "c-solution",
                "content": "# Approach\\nApproach is pretty simple, just remove every number one by one and check if the remaining numbers are in ascending order. If they are not, insert the number back (don\\'t forget to store the number in another variable). If they are in ascending order, return true (i have used a boolean variable called ok for checking).\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int copy;\\n        bool ok=0;\\n        for(int i=0;i<nums.size();i++){\\n            ok=1;\\n            copy=nums[i];\\n            nums.erase(nums.begin()+i);\\n            for(int j=0;j<nums.size()-1 && ok==1;j++){\\n                if(nums[j]>=nums[j+1]){\\n                    ok=0;\\n                    nums.insert(nums.begin()+i,copy);\\n                }\\n            }\\n            if(ok==1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int copy;\\n        bool ok=0;\\n        for(int i=0;i<nums.size();i++){\\n            ok=1;\\n            copy=nums[i];\\n            nums.erase(nums.begin()+i);\\n            for(int j=0;j<nums.size()-1 && ok==1;j++){\\n                if(nums[j]>=nums[j+1]){\\n                    ok=0;\\n                    nums.insert(nums.begin()+i,copy);\\n                }\\n            }\\n            if(ok==1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682620,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution{\\npublic:\\n    bool canBeIncreasing(vector<int>& nums){\\n        int count = 0;\\n        for (int i = 1; i < nums.size(); i++){\\n            if (nums[i] <= nums[i-1]){\\n                if(count == 1) return false;\\n                count++;\\n                if(i > 1 && nums[i] <= nums[i-2]){\\n                    nums[i] = nums[i-1];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    bool canBeIncreasing(vector<int>& nums){\\n        int count = 0;\\n        for (int i = 1; i < nums.size(); i++){\\n            if (nums[i] <= nums[i-1]){\\n                if(count == 1) return false;\\n                count++;\\n                if(i > 1 && nums[i] <= nums[i-2]){\\n                    nums[i] = nums[i-1];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534551,
                "title": "o-n-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // bool flag = true;\\n        int count = 0;\\n        int store = -1;\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(nums[i-1] >= nums[i]){\\n                // flag = false;\\n                store = i;\\n                count++ ;\\n            }\\n        }\\n        if(count == 0){\\n            return true;\\n        }\\n        else if(count > 1){\\n            return false;\\n        }\\n        else{\\n            if(store < 2 || store == n-1){\\n                return true;\\n            }\\n            if(nums[store] > nums[store - 2]){\\n                return true;\\n            }\\n            else if (nums[store+1] > nums[store - 1]){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // bool flag = true;\\n        int count = 0;\\n        int store = -1;\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(nums[i-1] >= nums[i]){\\n                // flag = false;\\n                store = i;\\n                count++ ;\\n            }\\n        }\\n        if(count == 0){\\n            return true;\\n        }\\n        else if(count > 1){\\n            return false;\\n        }\\n        else{\\n            if(store < 2 || store == n-1){\\n                return true;\\n            }\\n            if(nums[store] > nums[store - 2]){\\n                return true;\\n            }\\n            else if (nums[store+1] > nums[store - 1]){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277680,
                "title": "c-easy-and-readable-solution-faster-than-93-less-than-88",
                "content": "![image.png](https://assets.leetcode.com/users/images/c0e82699-ac5f-4f2b-883f-b29ea2fa9c79_1678388640.187313.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public bool CanBeIncreasing(int[] nums) {\\n        int counter = 0;\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            if (nums[i - 1] >= nums[i])\\n            {\\n                counter++;\\n                if (counter > 1)\\n                    return false;\\n                if (i > 1 && nums[i] <= nums[i - 2])\\n                    nums[i] = nums[i - 1];\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CanBeIncreasing(int[] nums) {\\n        int counter = 0;\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            if (nums[i - 1] >= nums[i])\\n            {\\n                counter++;\\n                if (counter > 1)\\n                    return false;\\n                if (i > 1 && nums[i] <= nums[i - 2])\\n                    nums[i] = nums[i - 1];\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194677,
                "title": "c-beats-100-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to delete exactly one element so the first time we encounter a drop, we have to manage it and check whether the array is now strictly increasing or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we are able to handle the first drop we can get to our solution. So when we encounter it, we\\'ll be having two cases-\\n1st We have to delete the previous element\\n2nd We have to delete the current element\\nIf either of these conditions are true we return true else false.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums,int j)\\n    {\\n        int n=nums.size();\\n        int prev=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==j)\\n            continue;\\n            if(prev>=nums[i])\\n            return false;\\n            prev=nums[i];\\n        }\\n        return true;\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                if(check(nums,i-1) || check(nums,i))\\n                return true;\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums,int j)\\n    {\\n        int n=nums.size();\\n        int prev=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==j)\\n            continue;\\n            if(prev>=nums[i])\\n            return false;\\n            prev=nums[i];\\n        }\\n        return true;\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                if(check(nums,i-1) || check(nums,i))\\n                return true;\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977718,
                "title": "94-of-time-and-98-of-memory-a-little-bit-hard-to-understand-solution",
                "content": "![Screenshot 2023-01-01 at 09.44.39.png](https://assets.leetcode.com/users/images/4c17a00a-316c-41d4-8989-1a6b12486d58_1672548318.685228.png)\\n\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        l = len(nums)\\n        if l==2: return True\\n        indexes = []\\n        for i in range(1, l):\\n            if nums[i]<=nums[i-1]: indexes.append(i-1)\\n        ans = 0\\n        for i in indexes:\\n            if i+2<l and nums[i]<nums[i+2]:\\n                ans+=1\\n            else:\\n                if i==l-2: ans+=1\\n                elif i!=0:\\n                    if nums[i+1]>nums[i-1]:\\n                        ans+=1\\n                    else:\\n                        return False\\n                else: ans+=1\\n        return ans<2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        l = len(nums)\\n        if l==2: return True\\n        indexes = []\\n        for i in range(1, l):\\n            if nums[i]<=nums[i-1]: indexes.append(i-1)\\n        ans = 0\\n        for i in indexes:\\n            if i+2<l and nums[i]<nums[i+2]:\\n                ans+=1\\n            else:\\n                if i==l-2: ans+=1\\n                elif i!=0:\\n                    if nums[i+1]>nums[i-1]:\\n                        ans+=1\\n                    else:\\n                        return False\\n                else: ans+=1\\n        return ans<2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674050,
                "title": "very-simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def canBeIncreasing(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for idx, val in enumerate(nums):\\n            new_nums = nums[:idx] + nums[idx + 1:]\\n            if new_nums == sorted(list(set(new_nums))):\\n                return True\\n        return False\\n```\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canBeIncreasing(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for idx, val in enumerate(nums):\\n            new_nums = nums[:idx] + nums[idx + 1:]\\n            if new_nums == sorted(list(set(new_nums))):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636333,
                "title": "python-easy-solution-in-o-n-complexity",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        a=nums[:]\\n        b=nums[:]\\n        f=0\\n        for i in range(1,n):\\n            if nums[i-1]>=nums[i]:\\n                a.pop(i-1)\\n                b.pop(i)\\n                f=1\\n                break\\n        if f==0:\\n            return True\\n        f1=f2=0\\n        for i in range(1,n-1):\\n            if a[i-1]>=a[i]:\\n                f1=1\\n        for i in range(1,n-1):\\n            if b[i-1]>=b[i]:\\n                f2=1\\n        if f1 == 0 or f2 == 0 :\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        a=nums[:]\\n        b=nums[:]\\n        f=0\\n        for i in range(1,n):\\n            if nums[i-1]>=nums[i]:\\n                a.pop(i-1)\\n                b.pop(i)\\n                f=1\\n                break\\n        if f==0:\\n            return True\\n        f1=f2=0\\n        for i in range(1,n-1):\\n            if a[i-1]>=a[i]:\\n                f1=1\\n        for i in range(1,n-1):\\n            if b[i-1]>=b[i]:\\n                f2=1\\n        if f1 == 0 or f2 == 0 :\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629009,
                "title": "simple-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[]nums) {\\n      \\n      int cnt = 0;\\n       for (int i = 1; i < nums.length && cnt < 2; ++i) {\\n        if (nums[i - 1] >= nums[i]) {\\n            ++cnt;\\n            if (i > 1 && nums[i - 2] >= nums[i])\\n                nums[i] = nums[i - 1];\\n          }\\n       }\\n        return cnt < 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[]nums) {\\n      \\n      int cnt = 0;\\n       for (int i = 1; i < nums.length && cnt < 2; ++i) {\\n        if (nums[i - 1] >= nums[i]) {\\n            ++cnt;\\n            if (i > 1 && nums[i - 2] >= nums[i])\\n                nums[i] = nums[i - 1];\\n          }\\n       }\\n        return cnt < 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625532,
                "title": "very-clean-solution-with-only-10-sloc",
                "content": "We\\'ll traverse the `nums` array in one loop, and check if the current element is `<=` the previous one. At that point, we could remove either of them to keep the array strictly increasing, but it\\'s better to remove the larger number, for a higher chance that the next number will be greater than the remaining one:\\n1 2 **10 5** 7 ```// at the point of comparing 10 and 5, we can remove either, but remove 10```\\nBut, if the element _before_ the previous one would be `=>` the current one, then we must remove the current element:\\n2 **3 1** 4 ```// when comparing 3 and 1, we must remove 1, otherwise we\\'d have \"2 1\"```\\n\\nWith this in mind, we need to count the number of such removals and return `false` if we\\'ve encountered more than 1.\\n\\n```\\nfunction canBeIncreasing(nums: number[]): boolean {\\n    let removals = 0;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] <= nums[i - 1]) {\\n            if (++removals > 1)\\n                return false;\\n            // Try removing the bigger number first (nums[i-1]), which simply means continuing the loop.\\n            // But if the current number is <= nums[i-2], then remove the current number instead,\\n            // which can be effectively done by overwriting it with the previous one.\\n            if (nums[i] <= nums[i - 2])  // if i < 2, the comparison will be with undefined, hence false\\n                nums[i] = nums[i - 1];\\n        }    \\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```// at the point of comparing 10 and 5, we can remove either, but remove 10```\n```// when comparing 3 and 1, we must remove 1, otherwise we\\'d have \"2 1\"```\n```\\nfunction canBeIncreasing(nums: number[]): boolean {\\n    let removals = 0;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] <= nums[i - 1]) {\\n            if (++removals > 1)\\n                return false;\\n            // Try removing the bigger number first (nums[i-1]), which simply means continuing the loop.\\n            // But if the current number is <= nums[i-2], then remove the current number instead,\\n            // which can be effectively done by overwriting it with the previous one.\\n            if (nums[i] <= nums[i - 2])  // if i < 2, the comparison will be with undefined, hence false\\n                nums[i] = nums[i - 1];\\n        }    \\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2578205,
                "title": "1909-remove-one-element-to-make-the-array-strictly-increasing",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            a=nums.pop(i)\\n            #print(nums)\\n            if nums==sorted(set(nums)):  \\n                return True\\n            else:\\n                nums.insert(i,a)\\n                #i+=1\\n                #print(nums)\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            a=nums.pop(i)\\n            #print(nums)\\n            if nums==sorted(set(nums)):  \\n                return True\\n            else:\\n                nums.insert(i,a)\\n                #i+=1\\n                #print(nums)\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528315,
                "title": "fast-and-easy-to-read-javascript",
                "content": "```\\nvar canBeIncreasing = function(nums) {\\n    let removedOne = false;\\n    \\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] <= nums[i-1]) {\\n            // if already removed one element return false\\n            if(removedOne) return false; \\n            // we have an option to remove i-1 or i from the array\\n            // the array can not continue to increase if for both i and i-1\\n            // the number after the removed element is smaller or equal to the element before that\\n            if(nums[i] <= nums[i-2] && nums[i+1] <= nums[i-1]) return false;\\n            // continue by removing one element\\n            removedOne = true;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canBeIncreasing = function(nums) {\\n    let removedOne = false;\\n    \\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] <= nums[i-1]) {\\n            // if already removed one element return false\\n            if(removedOne) return false; \\n            // we have an option to remove i-1 or i from the array\\n            // the array can not continue to increase if for both i and i-1\\n            // the number after the removed element is smaller or equal to the element before that\\n            if(nums[i] <= nums[i-2] && nums[i+1] <= nums[i-1]) return false;\\n            // continue by removing one element\\n            removedOne = true;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495180,
                "title": "with-explanation-comments-e-array-strictly-increasing-time-4-ms-84-42-space-9-9-mb-85-93",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        bool check=false;\\n        \\n        //loop over the whole array elemets starting from the second element\\n        for(int i=1;i<nums.size();i++){\\n            //condition 1: check if the current element value is less than or equals the previosone\\n            if(nums[i-1]>=nums[i]){\\n                //condition 2: check if we\\'ve checked this element before or not\\n                if(check)\\n                    //if yes, checked before-> false\\n                    return false;\\n                else\\n                    //if no, not yes-> marked as checked before\\n                    check=true;\\n                \\n                //condition 3: if the current number is less than or equal to the second previous one, the number before it after deleting the marked number\\n                if(i>1 && nums[i-2]>=nums[i])\\n                    //if yes-> replace the current element value with the previous one, as we\\'re comparing it after that\\n                    nums[i]=nums[i-1];\\n            }\\n        \\n        }\\n        \\n        //if it passed all these cases-> true\\n        return true;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        bool check=false;\\n        \\n        //loop over the whole array elemets starting from the second element\\n        for(int i=1;i<nums.size();i++){\\n            //condition 1: check if the current element value is less than or equals the previosone\\n            if(nums[i-1]>=nums[i]){\\n                //condition 2: check if we\\'ve checked this element before or not\\n                if(check)\\n                    //if yes, checked before-> false\\n                    return false;\\n                else\\n                    //if no, not yes-> marked as checked before\\n                    check=true;\\n                \\n                //condition 3: if the current number is less than or equal to the second previous one, the number before it after deleting the marked number\\n                if(i>1 && nums[i-2]>=nums[i])\\n                    //if yes-> replace the current element value with the previous one, as we\\'re comparing it after that\\n                    nums[i]=nums[i-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2450529,
                "title": "c-bruteforce-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int> a)\\n    {\\n        int size = a.size();\\n        int c = 0;\\n        for(int i = 0; i < size-1; i++) // size-1 to stop heap buffer overflow\\n        {\\n            if(a[i] >= a[i+1]) // check if it is increasing order or not\\n            {\\n                c = 1;\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n    \\n    bool canBeIncreasing(vector<int>& nums) {\\n        int size = nums.size();\\n    vector<int> copy(nums);\\n    int c = 0;\\n    if(check(nums) == 0) // if its already strictly increasing\\n    {\\n        c = 1;\\n    }\\n    else\\n    {\\n        for(int i = 0; i < size; i++)\\n        {\\n            nums.erase(nums.begin()+i);\\n            // loopingly reemoving elements one by one to check if its strictly increasing or not \\n            if(check(nums) == 0)\\n            {\\n                c = 1;\\n                break;\\n            }\\n            else\\n            {\\n                nums.insert(nums.begin()+i, copy[i]); \\n                // if that element doesnt produce strictly increasing order, then add that element back to the vector.\\n            }\\n        }\\n    }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int> a)\\n    {\\n        int size = a.size();\\n        int c = 0;\\n        for(int i = 0; i < size-1; i++) // size-1 to stop heap buffer overflow\\n        {\\n            if(a[i] >= a[i+1]) // check if it is increasing order or not\\n            {\\n                c = 1;\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n    \\n    bool canBeIncreasing(vector<int>& nums) {\\n        int size = nums.size();\\n    vector<int> copy(nums);\\n    int c = 0;\\n    if(check(nums) == 0) // if its already strictly increasing\\n    {\\n        c = 1;\\n    }\\n    else\\n    {\\n        for(int i = 0; i < size; i++)\\n        {\\n            nums.erase(nums.begin()+i);\\n            // loopingly reemoving elements one by one to check if its strictly increasing or not \\n            if(check(nums) == 0)\\n            {\\n                c = 1;\\n                break;\\n            }\\n            else\\n            {\\n                nums.insert(nums.begin()+i, copy[i]); \\n                // if that element doesnt produce strictly increasing order, then add that element back to the vector.\\n            }\\n        }\\n    }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449098,
                "title": "python3-remove-one-element-to-make-the-array-strictly-increasing-two-approaches",
                "content": "```class Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        \\n        #Approach-1: Kind of a brute force approach. \\n        \\n        def increase(nums):\\n            for i in range(1,len(nums)):\\n                if(nums[i-1]>=nums[i]):\\n                    return False\\n            return True\\n        \\n        for i in range(len(nums)):\\n            if(increase(nums[:i]+nums[i+1:])):\\n                return True\\n        return False\\n    \\n    \\n        #Approach-2\\n        \\n        l_count,r_count=0,0\\n        \\n        k=nums[0]\\n        for i in range(1,len(nums)):\\n            if(k<nums[i]):\\n                k=nums[i]\\n            else:\\n                l_count+=1\\n        \\n        k=nums[-1]\\n        for i in range(len(nums)-2,-1,-1):\\n            if(k>nums[i]):\\n                k=nums[i]\\n            else:\\n                r_count+=1\\n        return min(l_count,r_count)<=1\\n    \\n            \\n    \\n    \\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        \\n        #Approach-1: Kind of a brute force approach. \\n        \\n        def increase(nums):\\n            for i in range(1,len(nums)):\\n                if(nums[i-1]>=nums[i]):\\n                    return False\\n            return True\\n        \\n        for i in range(len(nums)):\\n            if(increase(nums[:i]+nums[i+1:])):\\n                return True\\n        return False\\n    \\n    \\n        #Approach-2\\n        \\n        l_count,r_count=0,0\\n        \\n        k=nums[0]\\n        for i in range(1,len(nums)):\\n            if(k<nums[i]):\\n                k=nums[i]\\n            else:\\n                l_count+=1\\n        \\n        k=nums[-1]\\n        for i in range(len(nums)-2,-1,-1):\\n            if(k>nums[i]):\\n                k=nums[i]\\n            else:\\n                r_count+=1\\n        return min(l_count,r_count)<=1\\n    \\n            \\n    \\n    \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2447636,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n       int lc=0,rc=0;\\n        int k=nums.back();\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<k)\\n                k=nums[i];\\n            else\\n                rc++;\\n        }\\n        k=nums[0];\\n            for(int i=1;i<nums.size();i++){\\n                if(nums[i]>k)\\n                  k=nums[i];\\n                else \\n                    lc++;\\n            }\\n                return min(lc,rc)<=1;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n       int lc=0,rc=0;\\n        int k=nums.back();\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<k)\\n                k=nums[i];\\n            else\\n                rc++;\\n        }\\n        k=nums[0];\\n            for(int i=1;i<nums.size();i++){\\n                if(nums[i]>k)\\n                  k=nums[i];\\n                else \\n                    lc++;\\n            }\\n                return min(lc,rc)<=1;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376183,
                "title": "simple-python3-solution-with-clear-explanation",
                "content": "1. Since what we concern about is this condition - \"after removing exactly one element, the remaining elements will be strictly increasing or not\". Once it meets the above condition, we end our for loop and return True. Otherwise, False is returned.\\n\\n2. The pop(index) will remove the item at the given position in the list and return it. It means if I do it on the original list, it will change the list directly. (i.e., ```nums.pop(i)```) \\nSo I choose to use copy() instead to keep our original list and initialize the copy list every time for following modification and check. (i.e., ``` l = nums.copy()```)\\n\\n3. For if-else statement, it means after removing exactly one specific position element, if the remaining elements are strictly increasing, we **end the for loop and return True**. But if not, we use ```continue``` to skip the rest of the code in the current iteration of the loop and continue on with the next iteration.\\n\\n4. Back to #1, if each iteration of the for loop is checked and there is no condition that matches what we want, then False is returned.\\n\\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            l = nums.copy()\\n            l.pop(i)\\n            if l == sorted(set(l)):\\n                return True\\n            else:\\n                continue\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```nums.pop(i)```\n``` l = nums.copy()```\n```continue```\n```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            l = nums.copy()\\n            l.pop(i)\\n            if l == sorted(set(l)):\\n                return True\\n            else:\\n                continue\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375714,
                "title": "c-solution-o-n-time-complexity",
                "content": "My approach was to find the first index where the elements are not sorted increasingly. This was done by comparing the current element of array with next consecutive element. If there is no error found, the array is already sorted and so no need to check further. But, if error is found either the element at current index or the next consecutive one must be the one to be removed from the array. To do so 2 copies of nums array were created and the two elements were removed from one of them and the other one separately. Now, if any of the copies is sorted, we get the answer.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n    // [1,2,10,5,7]\\n    // [2,3,1,2]\\n    // [1,1,1]\\n    // [100,21,100]\\n    // [541,783,433,744]\\n    // [1,2,3]\\n    // [3,2,1]\\n        \\n        int AisSorted = 1, BisSorted = 1, size = nums.size();\\n        vector<int> a(size, 0), b(size, 0);\\n        \\n        for(int i = 0; i < size; i++){\\n            a[i] = b[i] = nums[i];\\n        }\\n        \\n        for(int i = 0; i < size-1; i++){\\n            if(nums[i] >= nums[i+1]){\\n                a.erase(a.begin()+i);\\n                b.erase(b.begin()+i+1);\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 0; i < size-2; i++){\\n            if(a[i] >= a[i+1]){\\n                AisSorted = 0;\\n            }\\n            \\n            if(b[i] >= b[i+1]){\\n                BisSorted = 0;\\n            }\\n            \\n            if(AisSorted == 0 && BisSorted == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n    // [1,2,10,5,7]\\n    // [2,3,1,2]\\n    // [1,1,1]\\n    // [100,21,100]\\n    // [541,783,433,744]\\n    // [1,2,3]\\n    // [3,2,1]\\n        \\n        int AisSorted = 1, BisSorted = 1, size = nums.size();\\n        vector<int> a(size, 0), b(size, 0);\\n        \\n        for(int i = 0; i < size; i++){\\n            a[i] = b[i] = nums[i];\\n        }\\n        \\n        for(int i = 0; i < size-1; i++){\\n            if(nums[i] >= nums[i+1]){\\n                a.erase(a.begin()+i);\\n                b.erase(b.begin()+i+1);\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 0; i < size-2; i++){\\n            if(a[i] >= a[i+1]){\\n                AisSorted = 0;\\n            }\\n            \\n            if(b[i] >= b[i+1]){\\n                BisSorted = 0;\\n            }\\n            \\n            if(AisSorted == 0 && BisSorted == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286000,
                "title": "easy-and-simple-c-time-o-n-space-o-1-c",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCF6IheSB2Lu67p1Erwp8pXg)]\\n\\nApproach is very simple at first I am also not able to understand but when i **dry run** it I easily understand So please **Dry Run Before Submiting it .**\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int lcount=0,rcount=0;\\n        int last=nums[nums.size()-1];\\n        \\n         for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<last) last=nums[i];\\n            else rcount++;\\n        }\\n        int first=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>first)\\n                first=nums[i];\\n            else\\n                lcount++;\\n        }\\n       \\n        return min(lcount,rcount)<=1;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCF6IheSB2Lu67p1Erwp8pXg)]",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int lcount=0,rcount=0;\\n        int last=nums[nums.size()-1];\\n        \\n         for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<last) last=nums[i];\\n            else rcount++;\\n        }\\n        int first=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>first)\\n                first=nums[i];\\n            else\\n                lcount++;\\n        }\\n       \\n        return min(lcount,rcount)<=1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215248,
                "title": "my-first-solution-beginner-javascript",
                "content": "New programmer here! This was my first attempt at one of the \"harder\" easy problems, would love to receive feedback or any suggestions to make this cleaner and more DRY.\\n\\n```\\nvar canBeIncreasing = function(nums) {\\n  let doesIncrease = false;\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    let counter = 0;\\n\\n    let newNums = [...nums]\\n    newNums.splice(i,1)\\n        \\n    for (let j = 0; j < newNums.length; j++) {\\n      if (newNums[j] >= newNums[j+1]) {\\n        counter ++;\\n      }\\n    }\\n    if (counter == 0) {\\n      doesIncrease = true;\\n    }\\n  }\\n  \\n  return doesIncrease\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeIncreasing = function(nums) {\\n  let doesIncrease = false;\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    let counter = 0;\\n\\n    let newNums = [...nums]\\n    newNums.splice(i,1)\\n        \\n    for (let j = 0; j < newNums.length; j++) {\\n      if (newNums[j] >= newNums[j+1]) {\\n        counter ++;\\n      }\\n    }\\n    if (counter == 0) {\\n      doesIncrease = true;\\n    }\\n  }\\n  \\n  return doesIncrease\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2214691,
                "title": "python-bruteforce",
                "content": "```\\nclass Solution:\\n    def is_increasing(self, nums):\\n        print(nums)\\n        for i in range(len(nums) - 1):\\n            if nums[i] >= nums[i+1]:\\n                return False\\n        return True\\n    \\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums) - 1):\\n            if nums[i] < nums[i+1]:\\n                continue\\n            else:\\n                remove_curr = [nums[i-1]] if i != 0 else []\\n                remove_curr.extend(nums[i+1:])\\n                \\n                remove_next = [nums[i]]\\n                remove_next.extend(nums[i+2:])\\n                \\n                if self.is_increasing(remove_curr):\\n                    return True\\n                elif self.is_increasing(remove_next):\\n                    return True\\n                return False\\n        return True\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def is_increasing(self, nums):\\n        print(nums)\\n        for i in range(len(nums) - 1):\\n            if nums[i] >= nums[i+1]:\\n                return False\\n        return True\\n    \\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums) - 1):\\n            if nums[i] < nums[i+1]:\\n                continue\\n            else:\\n                remove_curr = [nums[i-1]] if i != 0 else []\\n                remove_curr.extend(nums[i+1:])\\n                \\n                remove_next = [nums[i]]\\n                remove_next.extend(nums[i+2:])\\n                \\n                if self.is_increasing(remove_curr):\\n                    return True\\n                elif self.is_increasing(remove_next):\\n                    return True\\n                return False\\n        return True\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190982,
                "title": "python-simple-yet-effective-solution",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)-1):\\n            if nums[i] >= nums[i+1]:\\n                if sorted(list(set(nums[:i]+nums[i+1:]))) == nums[:i]+nums[i+1:] or sorted(list(set(nums[:i+1]+nums[i+2:]))) == nums[:i+1]+nums[i+2:]:\\n                    return True\\n                else:\\n                    return False\\n        return sorted(list(set(nums))) == nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)-1):\\n            if nums[i] >= nums[i+1]:\\n                if sorted(list(set(nums[:i]+nums[i+1:]))) == nums[:i]+nums[i+1:] or sorted(list(set(nums[:i+1]+nums[i+2:]))) == nums[:i+1]+nums[i+2:]:\\n                    return True\\n                else:\\n                    return False\\n        return sorted(list(set(nums))) == nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089046,
                "title": "python3-two-pass-monotonic-stack-o-n",
                "content": "Use two pass monotonic stack to compute decreasing times and check if the minimal decreasing time is less than zero.\\n1. For the first pass from left to right, we use monotonic increasing stack to find next smaller elements, if we find one, then pop the stack and increasing the dec1 by 1.\\n2. For the second pass from right to left, we use monotonic decreasing stack to find next larger elements, if we find one, then pop the stack and increasing the dec2 by 1.\\n3. Finally check if the minimal of dec1 and dec2 less or equal to 1.\\n\\nTime complexity: O(n)\\n\\n``` py \\nclass Solution:\\n    def canBeIncreasing(self, A: List[int]) -> bool:\\n        dec1 = 0\\n        stk = []\\n        for i in range(len(A)):\\n            while stk and A[stk[-1]]>=A[i]:\\n                stk.pop()\\n                dec1 += 1\\n            stk.append(i)           \\n            \\n        dec2 = 0\\n\\t\\tstk = []\\n        for i in reversed(range(len(A))):\\n            while stk and A[stk[-1]]<=A[i]:\\n                stk.pop()\\n                dec2 += 1\\n            stk.append(i)\\n        return min(dec1, dec2)<=1\\n```",
                "solutionTags": [
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "``` py \\nclass Solution:\\n    def canBeIncreasing(self, A: List[int]) -> bool:\\n        dec1 = 0\\n        stk = []\\n        for i in range(len(A)):\\n            while stk and A[stk[-1]]>=A[i]:\\n                stk.pop()\\n                dec1 += 1\\n            stk.append(i)           \\n            \\n        dec2 = 0\\n\\t\\tstk = []\\n        for i in reversed(range(len(A))):\\n            while stk and A[stk[-1]]<=A[i]:\\n                stk.pop()\\n                dec2 += 1\\n            stk.append(i)\\n        return min(dec1, dec2)<=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073963,
                "title": "c-easy-code-with-explanation-by-comments",
                "content": "```\\n  bool canBeIncreasing(vector<int>& nums)\\n    {\\n        for(int i=01;i<nums.size();)\\n        {\\n           if(nums[i-1]<nums[i]) //checking for (i-1)th element is less than ith element or not if ys then our goal is following.\\n           {\\n               i++;\\n               continue;\\n           }\\n            if(i!=1&&nums[i]>nums[i-2]) //dry run for this case   1 2 5 10 15 17 14 20   u will get this condition meaning\\n            nums.erase(nums.begin()+i-1);\\n            else if(i==1)      //for underflow\\n            nums.erase(nums.begin()+i-1);\\n             else\\n            nums.erase(nums.begin()+i);\\n             break;\\n        }\\n          bool x=true;\\n            for(int i=01;i<nums.size();i++)\\n            {\\n                 if(nums[i-1]<nums[i])//checking that after one removal is it following stricly decreasing\\n                      continue;\\n                x=false;\\n            }\\n        return x; //our x  will give result if it doesn\\'t get false in upper loop means for all element it is following so return true\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n  bool canBeIncreasing(vector<int>& nums)\\n    {\\n        for(int i=01;i<nums.size();)\\n        {\\n           if(nums[i-1]<nums[i]) //checking for (i-1)th element is less than ith element or not if ys then our goal is following.\\n           {\\n               i++;\\n               continue;\\n           }\\n            if(i!=1&&nums[i]>nums[i-2]) //dry run for this case   1 2 5 10 15 17 14 20   u will get this condition meaning\\n            nums.erase(nums.begin()+i-1);\\n            else if(i==1)      //for underflow\\n            nums.erase(nums.begin()+i-1);\\n             else\\n            nums.erase(nums.begin()+i);\\n             break;\\n        }\\n          bool x=true;\\n            for(int i=01;i<nums.size();i++)\\n            {\\n                 if(nums[i-1]<nums[i])//checking that after one removal is it following stricly decreasing\\n                      continue;\\n                x=false;\\n            }\\n        return x; //our x  will give result if it doesn\\'t get false in upper loop means for all element it is following so return true\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1946260,
                "title": "easy-python-solution-100-fast",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        k=nums[:]\\n        for i in range(n-1):\\n            if nums[i]>=nums[i+1]:\\n                nums.pop(i)\\n                k.pop(i+1)\\n                if nums==sorted(list(set(nums))) or k==sorted(list(set(k))):\\n                    return True\\n                else:return False\\n        else:\\n            return True\\n                \\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        k=nums[:]\\n        for i in range(n-1):\\n            if nums[i]>=nums[i+1]:\\n                nums.pop(i)\\n                k.pop(i+1)\\n                if nums==sorted(list(set(nums))) or k==sorted(list(set(k))):\\n                    return True\\n                else:return False\\n        else:\\n            return True\\n                \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1934412,
                "title": "kotlin-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    fun canBeIncreasing(nums: IntArray): Boolean {\\n        var removeTrack = 0\\n        \\n        for (i in 0..nums.size - 2) {\\n           if (nums[i] >= nums[i + 1]){\\n                removeTrack ++\\n            } \\n           \\n            if (i> 0 && nums[i-1] >= nums[i+1]){\\n                nums[i+1] = nums[i]\\n            }            \\n        }\\n        return removeTrack <2\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun canBeIncreasing(nums: IntArray): Boolean {\\n        var removeTrack = 0\\n        \\n        for (i in 0..nums.size - 2) {\\n           if (nums[i] >= nums[i + 1]){\\n                removeTrack ++\\n            } \\n           \\n            if (i> 0 && nums[i-1] >= nums[i+1]){\\n                nums[i+1] = nums[i]\\n            }            \\n        }\\n        return removeTrack <2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933552,
                "title": "python-o-n-time-one-pass-o-1-space-with-comments",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n_violations = 0\\n        j = 0  # where a violation happens\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i-1]:\\n                n_violations += 1\\n                j = i\\n                \\n            if n_violations > 1:\\n                return False\\n                \\n        if j <= 1 or j == len(nums) - 1: # j == 0: no violations, j == 1 or j == len(nums) - 1: only need to remove the one at the beginning or end\\n            return True\\n        else:\\n            # remove entry at j-1 or j\\n            return nums[j] > nums[j-2] or nums[j+1] > nums[j-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n_violations = 0\\n        j = 0  # where a violation happens\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i-1]:\\n                n_violations += 1\\n                j = i\\n                \\n            if n_violations > 1:\\n                return False\\n                \\n        if j <= 1 or j == len(nums) - 1: # j == 0: no violations, j == 1 or j == len(nums) - 1: only need to remove the one at the beginning or end\\n            return True\\n        else:\\n            # remove entry at j-1 or j\\n            return nums[j] > nums[j-2] or nums[j+1] > nums[j-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867565,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        removed = False\\n        j = 0\\n        for i in range(1, len(nums)):\\n            # print(i, j)\\n            if nums[i] <= nums[j]:  \\n                if removed:\\n                    return False\\n                if j-1 < 0 or nums[i] > nums[j-1]:\\n                        j = i\\n                else:\\n                    j = i - 1\\n                \\n                removed = True\\n            else:\\n                j = i\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        removed = False\\n        j = 0\\n        for i in range(1, len(nums)):\\n            # print(i, j)\\n            if nums[i] <= nums[j]:  \\n                if removed:\\n                    return False\\n                if j-1 < 0 or nums[i] > nums[j-1]:\\n                        j = i\\n                else:\\n                    j = i - 1\\n                \\n                removed = True\\n            else:\\n                j = i\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819158,
                "title": "longest-increasing-subsequence-c-nlogn",
                "content": "**TC->O(nlogn) and SC->O(n)**\\n```\\nclass Solution {\\npublic:\\n    int LIS(vector<int>&nums){\\n        vector<int>seq ;\\n        for(int i = 0 ; i < nums.size() ;++i ){\\n            if(seq.empty() || nums[i] > seq.back() )seq.push_back(nums[i]);\\n            else{\\n                int idx = lower_bound(begin(seq),end(seq),nums[i]) - begin(seq) ;\\n                seq[idx] = nums[i] ;\\n            }\\n        }\\n        return seq.size() ;\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        return (nums.size() - LIS(nums)) <= 1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int LIS(vector<int>&nums){\\n        vector<int>seq ;\\n        for(int i = 0 ; i < nums.size() ;++i ){\\n            if(seq.empty() || nums[i] > seq.back() )seq.push_back(nums[i]);\\n            else{\\n                int idx = lower_bound(begin(seq),end(seq),nums[i]) - begin(seq) ;\\n                seq[idx] = nums[i] ;\\n            }\\n        }\\n        return seq.size() ;\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        return (nums.size() - LIS(nums)) <= 1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789571,
                "title": "ruby-code",
                "content": "```ruby\\n# @param {Integer[]} nums\\n# @return {Boolean}\\ndef can_be_increasing(nums)\\n    arr = [-Float::INFINITY, *nums, Float::INFINITY]\\n    hit = false\\n    \\n    for i in 0...arr.count-1\\n        if arr[i] >= arr[i+1]\\n            if hit or (arr[i-1] >= arr[i+1] and arr[i] >= arr[i+2])\\n                return false\\n            end\\n            hit = true\\n        end\\n    end\\n    \\n    return true\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} nums\\n# @return {Boolean}\\ndef can_be_increasing(nums)\\n    arr = [-Float::INFINITY, *nums, Float::INFINITY]\\n    hit = false\\n    \\n    for i in 0...arr.count-1\\n        if arr[i] >= arr[i+1]\\n            if hit or (arr[i-1] >= arr[i+1] and arr[i] >= arr[i+2])\\n                return false\\n            end\\n            hit = true\\n        end\\n    end\\n    \\n    return true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1759027,
                "title": "c-tricky-o-n-commented",
                "content": "**Upvote if you found solution helpful**\\n**You can also do it in O(N^2) time**\\n* `remove every index element and check whether its left remaining array or right remaining array is strictly increasing or not`\\n* `if we got above situation true then return true else return false`\\n* `finally return true`\\n\\n---\\n**O(N) solution**\\n\\n---\\n```C++\\nclass Solution\\n{\\npublic:\\n    bool canBeIncreasing(vector<int> &nums)\\n    {\\n        int ans = 0;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            // case when we get drop\\n            if (nums[i] <= nums[i-1])\\n            {\\n                // checking whether second drop or first drop if second drop then return false\\n                if (ans == 1)\\n                {\\n                    return false;\\n                }\\n\\n                // now remove current value\\n                if (i > 1 and nums[i] <= nums[i - 2])\\n                {\\n                    nums[i] = nums[i-1];\\n                }\\n                // add drop\\n                ans++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    bool canBeIncreasing(vector<int> &nums)\\n    {\\n        int ans = 0;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            // case when we get drop\\n            if (nums[i] <= nums[i-1])\\n            {\\n                // checking whether second drop or first drop if second drop then return false\\n                if (ans == 1)\\n                {\\n                    return false;\\n                }\\n\\n                // now remove current value\\n                if (i > 1 and nums[i] <= nums[i - 2])\\n                {\\n                    nums[i] = nums[i-1];\\n                }\\n                // add drop\\n                ans++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688551,
                "title": "java-beats-100-o-n-time-o-1-space-readable",
                "content": "The intuiton behind this answer is simple. We can iterate through the array, but if the sorting pattern is broken, we check for fixing it. To do this, one of the indices we used was problematic so we check what can happen if we remove either index.\\n\\nA lot of other solutions I have seen create a new list, but this can be done in place with constant space if you pass in the indices to skip. \\n\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n      for(int i = 1; i < nums.length; i++)\\n        if(nums[i] > nums[i-1])\\n          continue;\\n        else\\n          return canBeIncreasingSkipIndex(nums, i) ||  canBeIncreasingSkipIndex(nums, i-1);\\n      return true;\\n    }\\n  \\n    private boolean canBeIncreasingSkipIndex(int[] nums, int skip){\\n      long previous = (long)Integer.MIN_VALUE-1;\\n      for(int i = 0; i < nums.length; i++)\\n        if(i == skip)\\n          continue;\\n        else if(nums[i] <= previous)\\n          return false;\\n        else\\n          previous = nums[i];\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n      for(int i = 1; i < nums.length; i++)\\n        if(nums[i] > nums[i-1])\\n          continue;\\n        else\\n          return canBeIncreasingSkipIndex(nums, i) ||  canBeIncreasingSkipIndex(nums, i-1);\\n      return true;\\n    }\\n  \\n    private boolean canBeIncreasingSkipIndex(int[] nums, int skip){\\n      long previous = (long)Integer.MIN_VALUE-1;\\n      for(int i = 0; i < nums.length; i++)\\n        if(i == skip)\\n          continue;\\n        else if(nums[i] <= previous)\\n          return false;\\n        else\\n          previous = nums[i];\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658135,
                "title": "python3-brute-force-with-o-n-2",
                "content": "Brute Force: Remove elements one by one, then check the rest elements is in ascending order.\\n\\n```\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            tmp_nums = nums[0:i] + nums[i + 1: len(nums)]\\n            for j in range(len(tmp_nums) - 1):\\n                if tmp_nums[j] >= tmp_nums[j + 1]:\\n                    break\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            tmp_nums = nums[0:i] + nums[i + 1: len(nums)]\\n            for j in range(len(tmp_nums) - 1):\\n                if tmp_nums[j] >= tmp_nums[j + 1]:\\n                    break\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1616232,
                "title": "java-one-pass-2-candidates-explanations",
                "content": "When `n[i] <= n[i-1],` there are two candidates that we can remove. \\n\\nCase `n[i]`: we remove this element when `n[i] <= n[i-2]`, and  `n[i+1]` would have to compare against `n[i-1],` so we just set `n[i] = n[i-1]` for simplicity.\\nCase `n[i-1]`: we remove this when the case above doesn\\'t happen, i.e. when `n[i] > n[i-2]`, so we don\\'t have to do anything here.\\n\\nalso, remember to increment `count` and return false when `count == 2`\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        for (int i = 1; i < nums.length; i++){\\n            if (nums[i] <= nums[i-1]){\\n                count++;\\n                if (i-2>=0 && nums[i] <= nums[i - 2]) nums[i] = nums[i-1];\\n            }\\n            if (count == 2) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        for (int i = 1; i < nums.length; i++){\\n            if (nums[i] <= nums[i-1]){\\n                count++;\\n                if (i-2>=0 && nums[i] <= nums[i - 2]) nums[i] = nums[i-1];\\n            }\\n            if (count == 2) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572146,
                "title": "java-one-pass-solution-without-modifying-input-with-explanation",
                "content": "As per the title, explanation in the code comments\\n\\n```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        boolean elementToBeRemovedFound = false; //flag to check if already found one element to be removed\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] <= nums[i - 1]) { // element not in ascending order\\n                if (elementToBeRemovedFound) { //there was already another element in ascending order, we can return false\\n                    return false;\\n                }\\n                if (i + 1 == nums.length || i == 1 //if the element not in ascending order is the first or the last of the array it can be removed\\n                        || nums[i + 1] > nums[i - 1] || nums[i] > nums[i - 2]) { //if it\\'s in the middle we either have to remove the current element or the previous one while still maintaining the order\\n                    elementToBeRemovedFound = true;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        boolean elementToBeRemovedFound = false; //flag to check if already found one element to be removed\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] <= nums[i - 1]) { // element not in ascending order\\n                if (elementToBeRemovedFound) { //there was already another element in ascending order, we can return false\\n                    return false;\\n                }\\n                if (i + 1 == nums.length || i == 1 //if the element not in ascending order is the first or the last of the array it can be removed\\n                        || nums[i + 1] > nums[i - 1] || nums[i] > nums[i - 2]) { //if it\\'s in the middle we either have to remove the current element or the previous one while still maintaining the order\\n                    elementToBeRemovedFound = true;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553022,
                "title": "c-o-n-if-else-82-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        if(nums.size()==2){\\n           return true;\\n        }\\n        auto it=nums.begin();\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                nums.erase(it+(i));\\n                break;\\n}\\n            if(nums[i]>nums[i+1]){\\n                if(nums[i+1]>nums[i-1]){\\n                        nums.erase(it+(i));\\n                }\\n                else {\\n                    nums.erase(it+(i+1));\\n                }\\n                break;\\n            }\\n                else if(nums[i]<nums[i-1]){\\n                    if(nums[i-1]<nums[i+1]){\\n                        nums.erase(it+(i));                     \\n}\\n                    else if(nums[i]>nums[i+1]){\\n                        nums.erase(it+(i-1));\\n                        \\n                    }\\n                    else if(nums[i-1]>nums[i+1]){\\n                        nums.erase(it+(i-1));\\n                        \\n                    }\\n                   else if(nums[i-1]==nums[i+1]){\\n                        nums.erase(it+(i-1));\\n                        \\n                    }\\n                    break;\\n                }\\n            }\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]>nums[i+1]||nums[i]==nums[i+1])\\n                return false;\\n}\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        if(nums.size()==2){\\n           return true;\\n        }\\n        auto it=nums.begin();\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                nums.erase(it+(i));\\n                break;\\n}\\n            if(nums[i]>nums[i+1]){\\n                if(nums[i+1]>nums[i-1]){\\n                        nums.erase(it+(i));\\n                }\\n                else {\\n                    nums.erase(it+(i+1));\\n                }\\n                break;\\n            }\\n                else if(nums[i]<nums[i-1]){\\n                    if(nums[i-1]<nums[i+1]){\\n                        nums.erase(it+(i));                     \\n}\\n                    else if(nums[i]>nums[i+1]){\\n                        nums.erase(it+(i-1));\\n                        \\n                    }\\n                    else if(nums[i-1]>nums[i+1]){\\n                        nums.erase(it+(i-1));\\n                        \\n                    }\\n                   else if(nums[i-1]==nums[i+1]){\\n                        nums.erase(it+(i-1));\\n                        \\n                    }\\n                    break;\\n                }\\n            }\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]>nums[i+1]||nums[i]==nums[i+1])\\n                return false;\\n}\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531908,
                "title": "java-easy-solution-stack",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int index=-1;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]>=nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1)\\n            return true;\\n        boolean result=true;\\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(i==index)\\n                continue;\\n            if(stack.size()==0)\\n                stack.push(nums[i]);\\n            else {\\n                if(stack.peek()>=nums[i])\\n                {\\n                    result=false;\\n                    break;\\n                }\\n                stack.push(nums[i]);\\n            }\\n        }\\n        if(result)\\n            return true;\\n        \\n        result=true;\\n        stack.clear();\\n        for(int i=0;i<nums.length;i++){\\n            if(i==index+1)\\n                continue;\\n            if(stack.size()==0)\\n                stack.push(nums[i]);\\n            else {\\n                if(stack.peek()>=nums[i]){\\n                    result=false;\\n                    break;\\n                }\\n                 stack.push(nums[i]);\\n            }\\n        }\\n       \\n        return result;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int index=-1;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]>=nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1)\\n            return true;\\n        boolean result=true;\\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(i==index)\\n                continue;\\n            if(stack.size()==0)\\n                stack.push(nums[i]);\\n            else {\\n                if(stack.peek()>=nums[i])\\n                {\\n                    result=false;\\n                    break;\\n                }\\n                stack.push(nums[i]);\\n            }\\n        }\\n        if(result)\\n            return true;\\n        \\n        result=true;\\n        stack.clear();\\n        for(int i=0;i<nums.length;i++){\\n            if(i==index+1)\\n                continue;\\n            if(stack.size()==0)\\n                stack.push(nums[i]);\\n            else {\\n                if(stack.peek()>=nums[i]){\\n                    result=false;\\n                    break;\\n                }\\n                 stack.push(nums[i]);\\n            }\\n        }\\n       \\n        return result;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476284,
                "title": "c-simple-soln-for-a-tricky-problem",
                "content": "```\\n\\t// case study:\\n\\t// [1,  3,  5,  10, 2] (True)\\n\\t// [ 0, 4, 1, 2, 5, 3] (False)\\n    // [105, 924, 32, 968] (True)\\n    // [  2,   3,  1,   2] (False)\\n\\t\\n\\t// first two cases are straightforward\\n\\t// if you look carefully for the last two cases\\n\\t// for case 3: you can move 32 or 924\\n\\t// for case 4: you can also move 3 or 1\\n\\t// therefore, you need to check two additional cases\\n\\t// nums[i - 2] >= nums[i] && nums[i-1] >= nums[i+1] \\n\\t// i.e 924, 968 && 105, 32 (in this case, remove 32, you will get an increasing array)\\n\\t// i.e. 2, 1 && 3, 2 (in this case, no matter which number you remove it, it is not increasing array) hence you return false \\n\\t// note : it is also important to check the boundry condition!\\n\\t\\n\\t\\n    public bool CanBeIncreasing(int[] nums) {\\n        int n = nums.Length, remove = 0;\\n        for(int i = n - 1; i >= 1; i--) {\\n            if(nums[i-1] >= nums[i]) {\\n                remove++;\\n                if((i - 2 >= 0 && nums[i - 2] >= nums[i]) && (i + 1 < n && nums[i-1] >= nums[i+1] )) \\n\\t\\t\\t\\t    return false;\\n            }\\n            if(remove > 1) return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n\\t// case study:\\n\\t// [1,  3,  5,  10, 2] (True)\\n\\t// [ 0, 4, 1, 2, 5, 3] (False)\\n    // [105, 924, 32, 968] (True)\\n    // [  2,   3,  1,   2] (False)\\n\\t\\n\\t// first two cases are straightforward\\n\\t// if you look carefully for the last two cases\\n\\t// for case 3: you can move 32 or 924\\n\\t// for case 4: you can also move 3 or 1\\n\\t// therefore, you need to check two additional cases\\n\\t// nums[i - 2] >= nums[i] && nums[i-1] >= nums[i+1] \\n\\t// i.e 924, 968 && 105, 32 (in this case, remove 32, you will get an increasing array)\\n\\t// i.e. 2, 1 && 3, 2 (in this case, no matter which number you remove it, it is not increasing array) hence you return false \\n\\t// note : it is also important to check the boundry condition!\\n\\t\\n\\t\\n    public bool CanBeIncreasing(int[] nums) {\\n        int n = nums.Length, remove = 0;\\n        for(int i = n - 1; i >= 1; i--) {\\n            if(nums[i-1] >= nums[i]) {\\n                remove++;\\n                if((i - 2 >= 0 && nums[i - 2] >= nums[i]) && (i + 1 < n && nums[i-1] >= nums[i+1] )) \\n\\t\\t\\t\\t    return false;\\n            }\\n            if(remove > 1) return false;\\n        }\\n        return true;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1475472,
                "title": "1909-remove-one-element-to-make-the-array-strictly-increasing",
                "content": "/*\\ntime: O(n)\\nspace: O(1)\\n*/\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        if(nums == null || nums.length == 0){\\n            return false;\\n        }\\n        \\n        for(int i = 0; i + 1 < nums.length; i++){\\n            if(nums[i] >= nums[i + 1]){\\n                return checkOk(nums, i) || checkOk(nums, i + 1);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean checkOk(int[] nums, int k){\\n        int cur = Integer.MIN_VALUE; \\n        for(int i = 0; i < nums.length; i++){\\n            if(i == k) continue;\\n            if(cur >= nums[i]) return false;\\n            cur = nums[i];\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        if(nums == null || nums.length == 0){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1470151,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar canBeIncreasing = function(nums) {\\n\\t\\tlet isRemove = false;\\n\\n\\t\\tfor (let index = 1; index < nums.length; index++) {\\n\\t\\t\\tconst currNum = nums[index];\\n\\n\\t\\t\\tif (currNum <= nums[index - 1]) {\\n\\t\\t\\t\\tif (isRemove) return false;\\n\\t\\t\\t\\t(index > 1 && currNum <= nums[index - 2]) && (nums[index] = nums[index - 1]);\\n\\t\\t\\t\\tisRemove = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar canBeIncreasing = function(nums) {\\n\\t\\tlet isRemove = false;\\n\\n\\t\\tfor (let index = 1; index < nums.length; index++) {\\n\\t\\t\\tconst currNum = nums[index];\\n\\n\\t\\t\\tif (currNum <= nums[index - 1]) {\\n\\t\\t\\t\\tif (isRemove) return false;\\n\\t\\t\\t\\t(index > 1 && currNum <= nums[index - 2]) && (nums[index] = nums[index - 1]);\\n\\t\\t\\t\\tisRemove = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1442924,
                "title": "python3-easy-to-understand",
                "content": "class Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n\\n        for i in range(len(nums)):\\n\\t\\t\\t# Create a deep copy instead of new reference\\n            temp = nums.copy()\\n\\t\\t\\t# remove one element to check without it\\n            del temp[i]\\n\\t\\t\\t#Use function to check if elements are increasing\\n            if all(i < j for i, j in zip(temp, temp[1:])):\\n                return True\\n            \\n        return False",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n\\n        for i in range(len(nums)):\\n\\t\\t\\t# Create a deep copy instead of new reference\\n            temp = nums.copy()\\n\\t\\t\\t# remove one element to check without it\\n            del temp[i]\\n\\t\\t\\t#Use function to check if elements are increasing\\n            if all(i < j for i, j in zip(temp, temp[1:])):\\n                return True\\n            \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1434180,
                "title": "java-simple-solution-o-n-one-pass-with-comments",
                "content": "```\\npublic boolean canBeIncreasing(int[] nums) {\\n        int indexToBeRemoved = -1;\\n        int valueToBeRemoved = -1;\\n        for(int i = 2; i < nums.length; i++){\\n            int num1 = nums[i-2];\\n            int num2 = nums[i-1];\\n            int num3 = nums[i];\\n            if(num1 < num2 && num2 < num3 && num1 < num3){ \\n                // If the three numbers are in proper sequence. Do not do anything\\n            }else{\\n                int removeThisIndex = -1;\\n                int removeElement = -1;\\n                // remove 1st element and check if it is in order\\n                if(num2 < num3){\\n                    // remove 1st\\n                    removeThisIndex = i-2;\\n                    removeElement = num1;\\n                }\\n                // remove 2nd element and check if it is in order\\n                if(num1 < num3){\\n                    // remove 2nd or bigger element or same as previous remove value\\n                    if(num2 > removeElement || num2 == valueToBeRemoved){\\n                        removeThisIndex = i-1;\\n                        removeElement = num2;\\n                    }\\n                } \\n                // remove 3rd element and check if it is in order\\n                if(num1 < num2){\\n                    // remove 3rd or bigger element or same as previous remove value\\n                    if(num3 > removeElement || num3 == valueToBeRemoved){\\n                        removeThisIndex = i;\\n                        removeElement = num3;     \\n                    }\\n                }\\n                if(removeThisIndex == -1){\\n                    return false;\\n                }\\n                \\n                if(indexToBeRemoved == -1){\\n                    // If it is first time then store it\\n                    indexToBeRemoved = removeThisIndex;\\n                    valueToBeRemoved = removeElement;\\n                }else if(indexToBeRemoved != removeThisIndex){ // second time so compare it is same or not\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canBeIncreasing(int[] nums) {\\n        int indexToBeRemoved = -1;\\n        int valueToBeRemoved = -1;\\n        for(int i = 2; i < nums.length; i++){\\n            int num1 = nums[i-2];\\n            int num2 = nums[i-1];\\n            int num3 = nums[i];\\n            if(num1 < num2 && num2 < num3 && num1 < num3){ \\n                // If the three numbers are in proper sequence. Do not do anything\\n            }else{\\n                int removeThisIndex = -1;\\n                int removeElement = -1;\\n                // remove 1st element and check if it is in order\\n                if(num2 < num3){\\n                    // remove 1st\\n                    removeThisIndex = i-2;\\n                    removeElement = num1;\\n                }\\n                // remove 2nd element and check if it is in order\\n                if(num1 < num3){\\n                    // remove 2nd or bigger element or same as previous remove value\\n                    if(num2 > removeElement || num2 == valueToBeRemoved){\\n                        removeThisIndex = i-1;\\n                        removeElement = num2;\\n                    }\\n                } \\n                // remove 3rd element and check if it is in order\\n                if(num1 < num2){\\n                    // remove 3rd or bigger element or same as previous remove value\\n                    if(num3 > removeElement || num3 == valueToBeRemoved){\\n                        removeThisIndex = i;\\n                        removeElement = num3;     \\n                    }\\n                }\\n                if(removeThisIndex == -1){\\n                    return false;\\n                }\\n                \\n                if(indexToBeRemoved == -1){\\n                    // If it is first time then store it\\n                    indexToBeRemoved = removeThisIndex;\\n                    valueToBeRemoved = removeElement;\\n                }else if(indexToBeRemoved != removeThisIndex){ // second time so compare it is same or not\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1417372,
                "title": "java-single-pass-in-place",
                "content": "```\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count=0, pp=-2, p=-1;\\n        for(int n : nums){\\n            if(p >= n){\\n                count++; \\n                if(pp < n){\\n                    pp = -1;\\n                    p = n; \\n                }\\n            }else{\\n                pp = p;\\n                p = n;                \\n            }\\n        }\\n        return count<2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count=0, pp=-2, p=-1;\\n        for(int n : nums){\\n            if(p >= n){\\n                count++; \\n                if(pp < n){\\n                    pp = -1;\\n                    p = n; \\n                }\\n            }else{\\n                pp = p;\\n                p = n;                \\n            }\\n        }\\n        return count<2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1409371,
                "title": "python3-explained-with-comments",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        current_peak,previous_peak = nums[0],0 # two last peak value in increasing sequence so far \\n        count = 1\\n        for i in range(1,n):\\n            if nums[i] > current_peak: #  current_num is greater than previous, increasing sequence is maintained \\n                previous_peak = current_peak\\n                current_peak = nums[i]\\n            elif count:                    # current_num is decreasing the sequence, you have one chance to skip\\n                count -=1\\n\\t\\t\\t\\t#There could be 2 case :\\n\\t\\t\\t\\t# 1) the decreasing value can be less than the current_peak but greater than previous_peak, you can remove the current_peak and\\n\\t\\t\\t\\t#sequence will still be increasing, update the current_peak to this number\\n                if nums[i] > previous_peak:    \\n                    current_peak = nums[i]\\n                # 2) the decreasing value can be less than the current_peak but less than the previous_peak, you can remove this decreasing number\\n\\t\\t\\t\\t#itself, nothing to change\\n            else: # you never had more than one chance to skip\\n                return False\\n        return True  # yes , it is increasing seq\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        current_peak,previous_peak = nums[0],0 # two last peak value in increasing sequence so far \\n        count = 1\\n        for i in range(1,n):\\n            if nums[i] > current_peak: #  current_num is greater than previous, increasing sequence is maintained \\n                previous_peak = current_peak\\n                current_peak = nums[i]\\n            elif count:                    # current_num is decreasing the sequence, you have one chance to skip\\n                count -=1\\n\\t\\t\\t\\t#There could be 2 case :\\n\\t\\t\\t\\t# 1) the decreasing value can be less than the current_peak but greater than previous_peak, you can remove the current_peak and\\n\\t\\t\\t\\t#sequence will still be increasing, update the current_peak to this number\\n                if nums[i] > previous_peak:    \\n                    current_peak = nums[i]\\n                # 2) the decreasing value can be less than the current_peak but less than the previous_peak, you can remove this decreasing number\\n\\t\\t\\t\\t#itself, nothing to change\\n            else: # you never had more than one chance to skip\\n                return False\\n        return True  # yes , it is increasing seq\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1397975,
                "title": "python-faster-than-100",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        flag=True\\n        \\n        for i in range(len(nums)-1):\\n            if nums[i]>=nums[i+1]:\\n                if flag==False:\\n                    return False\\n                else:\\n                    if i+2>=len(nums) or i-1<0 or nums[i]<nums[i+2] or nums[i+1]>nums[i-1]:\\n                        flag=False\\n                    else:\\n                        return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        flag=True\\n        \\n        for i in range(len(nums)-1):\\n            if nums[i]>=nums[i+1]:\\n                if flag==False:\\n                    return False\\n                else:\\n                    if i+2>=len(nums) or i-1<0 or nums[i]<nums[i+2] or nums[i+1]>nums[i-1]:\\n                        flag=False\\n                    else:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393320,
                "title": "c-stack-implementation-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int c=0;\\n        if(nums.size()==2) return true;\\n        stack<int>s;\\n        s.push(nums[0]);\\n        if(nums[1]>nums[0]) s.push(nums[1]);\\n        else{\\n            if(nums[2]>nums[0]) {\\n                s.push(nums[2]) ;\\n                c++;\\n            }\\n            else if(nums[2]<=nums[1]) return false;\\n            else {\\n                s.pop();\\n                s.push(nums[1]);\\n                s.push(nums[2]);\\n                c++;\\n            }\\n        }\\n        if(c){\\n            for(int i=3;i<nums.size();i++){\\n                if(nums[i]>s.top()) s.push(nums[i]);\\n                else return false;\\n            }\\n        }\\n        else{\\n            for(int i=2;i<nums.size();i++){\\n                if(nums[i]>s.top()) {s.push(nums[i]); continue;}\\n                int x=s.top();\\n                s.pop();\\n                if(s.top()<nums[i]){ s.push(nums[i]); c++;}\\n                else {\\n                    c++;\\n                    s.push(x);\\n                }\\n                if(c>1) return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int c=0;\\n        if(nums.size()==2) return true;\\n        stack<int>s;\\n        s.push(nums[0]);\\n        if(nums[1]>nums[0]) s.push(nums[1]);\\n        else{\\n            if(nums[2]>nums[0]) {\\n                s.push(nums[2]) ;\\n                c++;\\n            }\\n            else if(nums[2]<=nums[1]) return false;\\n            else {\\n                s.pop();\\n                s.push(nums[1]);\\n                s.push(nums[2]);\\n                c++;\\n            }\\n        }\\n        if(c){\\n            for(int i=3;i<nums.size();i++){\\n                if(nums[i]>s.top()) s.push(nums[i]);\\n                else return false;\\n            }\\n        }\\n        else{\\n            for(int i=2;i<nums.size();i++){\\n                if(nums[i]>s.top()) {s.push(nums[i]); continue;}\\n                int x=s.top();\\n                s.pop();\\n                if(s.top()<nums[i]){ s.push(nums[i]); c++;}\\n                else {\\n                    c++;\\n                    s.push(x);\\n                }\\n                if(c>1) return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392517,
                "title": "python-brute-force-very-easy",
                "content": "class Solution(object):\\n\\n    def canBeIncreasing(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        i=0\\n        while i <len(nums) :\\n            if nums[:i]+nums[i+1:]==sorted(set(nums[:i]+nums[i+1:])) :\\n                return True            \\n            i+=1\\n        return False",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def canBeIncreasing(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        i=0\\n        while i <len(nums) :\\n            if nums[:i]+nums[i+1:]==sorted(set(nums[:i]+nums[i+1:])) :\\n                return True            \\n            i+=1\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1386997,
                "title": "javascript",
                "content": "```\\nRuntime: 64 ms, faster than 99.62% of JavaScript online submissions for Remove One Element to Make the Array Strictly Increasing.\\nMemory Usage: 39.3 MB, less than 71.05% of JavaScript online submissions for Remove One Element to Make the Array Strictly Increasing.\\n\\nconst canBeIncreasing = (nums) => {\\n  let removed = false;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] <= nums[i - 1]) {\\n      if (removed) {\\n        return false;\\n      } else removed = true;\\n\\n      if (i > 1 && nums[i] <= nums[i - 2]) {\\n        nums[i] = nums[i - 1];\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nRuntime: 64 ms, faster than 99.62% of JavaScript online submissions for Remove One Element to Make the Array Strictly Increasing.\\nMemory Usage: 39.3 MB, less than 71.05% of JavaScript online submissions for Remove One Element to Make the Array Strictly Increasing.\\n\\nconst canBeIncreasing = (nums) => {\\n  let removed = false;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] <= nums[i - 1]) {\\n      if (removed) {\\n        return false;\\n      } else removed = true;\\n\\n      if (i > 1 && nums[i] <= nums[i - 2]) {\\n        nums[i] = nums[i - 1];\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365773,
                "title": "easy-explanation-for-beginners",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n       \\n        \\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int i= 0; i < nums.length; ++i){\\n            arr.add(nums[i]);\\n        }\\n        \\n        \\n        for(int i = 0; i < arr.size(); ++i){\\n            arr.remove(i);\\n            boolean flag = true;\\n            for(int  j = 1; j < arr.size(); ++j){\\n                if(arr.get(j-1) >= arr.get(j)){\\n                    flag  = false;\\n                    break;\\n                }\\n            }\\n            if(flag) return true;\\n            arr.add(i,nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n       \\n        \\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int i= 0; i < nums.length; ++i){\\n            arr.add(nums[i]);\\n        }\\n        \\n        \\n        for(int i = 0; i < arr.size(); ++i){\\n            arr.remove(i);\\n            boolean flag = true;\\n            for(int  j = 1; j < arr.size(); ++j){\\n                if(arr.get(j-1) >= arr.get(j)){\\n                    flag  = false;\\n                    break;\\n                }\\n            }\\n            if(flag) return true;\\n            arr.add(i,nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358919,
                "title": "one-pass-o-n-js-solution",
                "content": "Use prev to keep previously selected value, the only case we select nums[i - 1] as prev ```(which means we need to drop current value nums[i])``` is when nums[i] <= nums[i - 2]![image](https://assets.leetcode.com/users/images/4e709002-7f21-4915-9cc9-aea20b16a66f_1627114732.4020762.jpeg)\\nHere if nums[i] is selected as prev, for sure will fail, so we have to select nums[i - 1] as prev, next time whenever we have nums[i] >= prev, return false directly\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canBeIncreasing = function(nums) {\\n    let prev = -1;\\n    let count = 0;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] <= prev) {\\n            if(count === 1) return false;\\n            count++;\\n            if(nums[i] <= (nums[i - 2] || min)) {\\n                prev = nums[i - 1];\\n            }else {\\n                prev = nums[i];\\n            }\\n        }else {\\n            prev = nums[i];\\n        }\\n    }\\n    return true;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```(which means we need to drop current value nums[i])```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357276,
                "title": "c-with-only-1-traversal-tc-o-n",
                "content": "Please upvote if you liked it :)\\n\\n```\\nint faults=0;\\n        \\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i] <= nums[i-1])\\n            {\\n                faults++;\\n                \\n                if(i>=2 && nums[i] <= nums[i-2])\\n                    nums[i] = nums[i-1];\\n            }\\n        }\\n        \\n        return faults<2;\\n```",
                "solutionTags": [],
                "code": "```\\nint faults=0;\\n        \\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i] <= nums[i-1])\\n            {\\n                faults++;\\n                \\n                if(i>=2 && nums[i] <= nums[i-2])\\n                    nums[i] = nums[i-1];\\n            }\\n        }\\n        \\n        return faults<2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348513,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        int n=nums.size(),i,t=0;\\n        for(i=0;i<n-1;i++)\\n        {\\n            if(i!=0 && nums[i]>=nums[i+1])\\n            {\\n                if((i+2<n && nums[i]<nums[i+2]) || i+2==n)\\n                {\\n                    t++;\\n                }\\n                else\\n                {\\n                    nums[i]=nums[i-1];\\n                    if(nums[i]>=nums[i+1])\\n                        return 0;\\n                    t++;\\n                }\\n            }\\n            else if(i==0 && nums[i]>=nums[i+1])\\n            {\\n                nums[i]=0;\\n                t++;\\n            }\\n            if(t>1)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        \\n        int n=nums.size(),i,t=0;\\n        for(i=0;i<n-1;i++)\\n        {\\n            if(i!=0 && nums[i]>=nums[i+1])\\n            {\\n                if((i+2<n && nums[i]<nums[i+2]) || i+2==n)\\n                {\\n                    t++;\\n                }\\n                else\\n                {\\n                    nums[i]=nums[i-1];\\n                    if(nums[i]>=nums[i+1])\\n                        return 0;\\n                    t++;\\n                }\\n            }\\n            else if(i==0 && nums[i]>=nums[i+1])\\n            {\\n                nums[i]=0;\\n                t++;\\n            }\\n            if(t>1)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336374,
                "title": "question-must-be-tagged-as-medium-o-n",
                "content": "class Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int l=0,r=0;\\n        int last=nums.back();\\n        for(int i=nums.size()-2;i>=0;i--){\\n                if(nums[i]<last){\\n                    last=nums[i];\\n                }\\n            else r++;\\n        }\\n        last=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>last){\\n                last=nums[i];\\n            }\\n            else\\n                l++;\\n        }\\n        return min(r,l)<=1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int l=0,r=0;\\n        int last=nums.back();\\n        for(int i=nums.size()-2;i>=0;i--){\\n                if(nums[i]<last){\\n                    last=nums[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1325080,
                "title": "java-0ms-with-o-1-memory",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n                        \\n        short mismatch = 0;\\n        for (short i = 0; i<nums.length-1 ; i++) {\\n            if (nums[i] >= nums[i+1]) {\\n                if (i>0) {\\n                    if (nums[i+1] > nums[i-1]) {\\n                        //ignore\\n                        \\n                    } else {\\n                        nums[i+1] = nums[i];\\n                    }\\n                }\\n                mismatch++;\\n            }\\n        }\\n            \\n        if (mismatch <= 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n                        \\n        short mismatch = 0;\\n        for (short i = 0; i<nums.length-1 ; i++) {\\n            if (nums[i] >= nums[i+1]) {\\n                if (i>0) {\\n                    if (nums[i+1] > nums[i-1]) {\\n                        //ignore\\n                        \\n                    } else {\\n                        nums[i+1] = nums[i];\\n                    }\\n                }\\n                mismatch++;\\n            }\\n        }\\n            \\n        if (mismatch <= 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324821,
                "title": "c-language",
                "content": "```\\n\\nbool canBeIncreasing(int* nums, int numsSize){\\n    int count =0; \\n    \\n    for ( int i = 1 ; i < numsSize ; i++ ) {\\n        if( nums[i-1]< nums[i])\\n            continue ; \\n        else {\\n            count++;     \\n            \\n            if(count>1)         // this shows that we will delete or use  only one element \\n                return false ; \\n            \\n            if(i-2 <0)           //to check that array element comparison stays in limit\\n                continue; \\n            \\n            if(nums[i-2]< nums[i])    //using element nums[i-1] if condition becomes true\\n                continue;\\n            else\\n                nums[i]=nums[i-1]; // else using the element nums[i] by swapping the elements\\n        }\\n    }\\n    return true ; //if the loop was successful we have true value\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nbool canBeIncreasing(int* nums, int numsSize){\\n    int count =0; \\n    \\n    for ( int i = 1 ; i < numsSize ; i++ ) {\\n        if( nums[i-1]< nums[i])\\n            continue ; \\n        else {\\n            count++;     \\n            \\n            if(count>1)         // this shows that we will delete or use  only one element \\n                return false ; \\n            \\n            if(i-2 <0)           //to check that array element comparison stays in limit\\n                continue; \\n            \\n            if(nums[i-2]< nums[i])    //using element nums[i-1] if condition becomes true\\n                continue;\\n            else\\n                nums[i]=nums[i-1]; // else using the element nums[i] by swapping the elements\\n        }\\n    }\\n    return true ; //if the loop was successful we have true value\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1320471,
                "title": "java-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n boolean removed = false;\\n\\tfor(int i=1;i<nums.length;i++){\\n\\t\\tif(nums[i] <= nums[i-1]) {  \\n\\t\\t\\tif(removed) return false;\\n\\t\\t\\tremoved = true;\\n\\t\\t\\tif (i>1 && nums[i] <= nums[i-2])\\n\\t\\t\\t\\tnums[i] = nums[i-1];\\n\\t\\t}\\n    }\\n\\treturn true;\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n boolean removed = false;\\n\\tfor(int i=1;i<nums.length;i++){\\n\\t\\tif(nums[i] <= nums[i-1]) {  \\n\\t\\t\\tif(removed) return false;\\n\\t\\t\\tremoved = true;\\n\\t\\t\\tif (i>1 && nums[i] <= nums[i-2])\\n\\t\\t\\t\\tnums[i] = nums[i-1];\\n\\t\\t}\\n    }\\n\\treturn true;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319364,
                "title": "c-very-easy-solution-95-fast-and-80-better-space",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int start=-1;\\n        if(nums.size()==2)\\n            return true;\\n        for(int i=1;i<nums.size();i++)\\n            if(nums[i]<nums[i-1]){\\n                if(start==-1)\\n                start=i;\\n                else\\n                    return false;\\n            }else if(nums[i]==nums[i-1])\\n                return false;\\n        if(start==-1 || start+1==nums.size() || start-2<0)\\n            return true;\\n        if(nums[start-1]<nums[start+1] || nums[start-2]<nums[start])\\n            return true;\\n        return false;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int start=-1;\\n        if(nums.size()==2)\\n            return true;\\n        for(int i=1;i<nums.size();i++)\\n            if(nums[i]<nums[i-1]){\\n                if(start==-1)\\n                start=i;\\n                else\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1308199,
                "title": "c-easy-solution-easy-to-understand-o-n-solution-100-faster",
                "content": "```\\nbool canBeIncreasing(vector<int>& nums) {\\n        int flag = 1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]>=nums[i+1]){\\n                if(flag==0){\\n                    return false;\\n                }\\n                if(i>0){\\n                    if(nums[i+1]<=nums[i-1]){\\n                        nums[i+1]=nums[i];\\n                    }\\n                }\\n                flag = 0;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nbool canBeIncreasing(vector<int>& nums) {\\n        int flag = 1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]>=nums[i+1]){\\n                if(flag==0){\\n                    return false;\\n                }\\n                if(i>0){\\n                    if(nums[i+1]<=nums[i-1]){\\n                        nums[i+1]=nums[i];\\n                    }\\n                }\\n                flag = 0;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307423,
                "title": "golang-simple-o-n-solution",
                "content": "```go\\nfunc canBeIncreasing(nums []int) bool {\\n\\tchance := true\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t\\tif nums[i] >= nums[i+1] {\\n\\t\\t\\tif chance == false {\\n                // no chance, return false\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t\\tif i > 0 {\\n                // we have to remove nums[i+1] if nums[i+1] \\u2264 nums[i-1] \\n\\t\\t\\t\\tif nums[i+1] <= nums[i-1] {\\n\\t\\t\\t\\t\\tnums[i+1] = nums[i]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tchance = false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canBeIncreasing(nums []int) bool {\\n\\tchance := true\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t\\tif nums[i] >= nums[i+1] {\\n\\t\\t\\tif chance == false {\\n                // no chance, return false\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t\\tif i > 0 {\\n                // we have to remove nums[i+1] if nums[i+1] \\u2264 nums[i-1] \\n\\t\\t\\t\\tif nums[i+1] <= nums[i-1] {\\n\\t\\t\\t\\t\\tnums[i+1] = nums[i]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tchance = false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1303076,
                "title": "python-3-straightforward-explained",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums) -> bool:\\n        \"\"\"\\n        Given an array of integers in the range between 1 and\\n        1000 inclusive, this program determines whether nums\\n        is strictly increasing or can be made that way with\\n        the removal of one element.\\n\\n        The scenario of interest consists of an offending pair\\n        nums[k - 1] and nums[k] where nums[k] <= nums[k - 1],\\n        and nums[k - 2]. The solution is to remove one member\\n        of the offending pair. If nums[k] > nums[k - 2], we\\n        remove nums[k - 1]. Otherwise, we remove nums[k].\\n        For example:\\n            nums[k - 2]     nums[k - 1]     nums[k]\\n                5               6               4   remove nums[k]\\n                5               8               6   remove nums[k - 1]\\n\\n        A special case occurs when the offending pair is the\\n        first two nums elements, nums[0] and nums[1]. in this\\n        case we simply remove the higher of the two values.\\n        The special case can be eliminated by padding nums with\\n        a zero at the start of the array.\\n\\n        :param nums: array of integers, all between 1 and 1000\\n        :type nums: list[int]\\n        :return: True if nums is strictly increasing and can\\n                 be made that way with the removal of one element,\\n                 else False.\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - Pad nums to ease the handling of the edge case.\\n        - Store the length of nums (padded) in len_nums.\\n        - Initialize removed, a flag that indicates whether\\n          our allowed removal has been exercised.\\n        \"\"\"\\n        nums = [0] + nums\\n        len_nums = len(nums)\\n        removed = False\\n\\n        \"\"\"\\n        Scan nums in one pass.\\n        - Search for an offending pair.\\n        - If an offending pair is found:\\n          - Return False if our allowed removal has been used.\\n          - Otherwise, choose which member of the offending\\n            pair to remove and over-write its value.\\n        - Return True if we reach the end of nums with at most\\n          one removal.\\n        \"\"\"\\n        for k in range(2, len_nums):\\n            if nums[k] <= nums[k - 1]:\\n                if removed:\\n                    return False\\n                if nums[k] > nums[k - 2]:\\n                    nums[k - 1] = nums[k]\\n                else:\\n                    nums[k] = nums[k - 1]\\n                removed = True\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums) -> bool:\\n        \"\"\"\\n        Given an array of integers in the range between 1 and\\n        1000 inclusive, this program determines whether nums\\n        is strictly increasing or can be made that way with\\n        the removal of one element.\\n\\n        The scenario of interest consists of an offending pair\\n        nums[k - 1] and nums[k] where nums[k] <= nums[k - 1],\\n        and nums[k - 2]. The solution is to remove one member\\n        of the offending pair. If nums[k] > nums[k - 2], we\\n        remove nums[k - 1]. Otherwise, we remove nums[k].\\n        For example:\\n            nums[k - 2]     nums[k - 1]     nums[k]\\n                5               6               4   remove nums[k]\\n                5               8               6   remove nums[k - 1]\\n\\n        A special case occurs when the offending pair is the\\n        first two nums elements, nums[0] and nums[1]. in this\\n        case we simply remove the higher of the two values.\\n        The special case can be eliminated by padding nums with\\n        a zero at the start of the array.\\n\\n        :param nums: array of integers, all between 1 and 1000\\n        :type nums: list[int]\\n        :return: True if nums is strictly increasing and can\\n                 be made that way with the removal of one element,\\n                 else False.\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - Pad nums to ease the handling of the edge case.\\n        - Store the length of nums (padded) in len_nums.\\n        - Initialize removed, a flag that indicates whether\\n          our allowed removal has been exercised.\\n        \"\"\"\\n        nums = [0] + nums\\n        len_nums = len(nums)\\n        removed = False\\n\\n        \"\"\"\\n        Scan nums in one pass.\\n        - Search for an offending pair.\\n        - If an offending pair is found:\\n          - Return False if our allowed removal has been used.\\n          - Otherwise, choose which member of the offending\\n            pair to remove and over-write its value.\\n        - Return True if we reach the end of nums with at most\\n          one removal.\\n        \"\"\"\\n        for k in range(2, len_nums):\\n            if nums[k] <= nums[k - 1]:\\n                if removed:\\n                    return False\\n                if nums[k] > nums[k - 2]:\\n                    nums[k - 1] = nums[k]\\n                else:\\n                    nums[k] = nums[k - 1]\\n                removed = True\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299303,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def canBeIncreasing(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # to  check if an array is increasing\\n        def isIncreasing(nums):\\n            for i in range(1, len(nums)):\\n                if nums[i - 1] >= nums[i]:\\n                    return False\\n            return True\\n        \\n        # counter to keep track of the count of increasing arrays\\n        counter = 0\\n        \\n        for i in range(len(nums)):\\n            num = nums.pop(i)\\n            if isIncreasing(nums) == True:\\n                counter += 1\\n                \\n            nums.insert(i, num)\\n            \\n        return True if counter > 0 else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canBeIncreasing(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # to  check if an array is increasing\\n        def isIncreasing(nums):\\n            for i in range(1, len(nums)):\\n                if nums[i - 1] >= nums[i]:\\n                    return False\\n            return True\\n        \\n        # counter to keep track of the count of increasing arrays\\n        counter = 0\\n        \\n        for i in range(len(nums)):\\n            num = nums.pop(i)\\n            if isIncreasing(nums) == True:\\n                counter += 1\\n                \\n            nums.insert(i, num)\\n            \\n        return True if counter > 0 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298918,
                "title": "my-java-solution-bruteforce",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        // O(n ^ 2)\\n        for (int i=0; i<nums.length; i++) {\\n            boolean flag = true;\\n            int lastElement = -1;\\n            for (int j=0; j<nums.length; j++) {\\n                if (i == j)\\n                    continue;\\n                if (nums[j] <= lastElement) {\\n                    flag = false;\\n                    break;\\n                }\\n                lastElement = nums[j];\\n            }\\n            if (flag)\\n                return true;\\n        }\\n        return false;\\n\\t\\t}\\n\\t\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        // O(n ^ 2)\\n        for (int i=0; i<nums.length; i++) {\\n            boolean flag = true;\\n            int lastElement = -1;\\n            for (int j=0; j<nums.length; j++) {\\n                if (i == j)\\n                    continue;\\n                if (nums[j] <= lastElement) {\\n                    flag = false;\\n                    break;\\n                }\\n                lastElement = nums[j];\\n            }\\n            if (flag)\\n                return true;\\n        }\\n        return false;\\n\\t\\t}\\n\\t\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298916,
                "title": "javascript-direct-way-172ms",
                "content": "```\\nconst canBeIncreasing = (a) => {\\n    if (isAscending(a)) return 1;\\n    let n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let tmp = a.slice(0, i).concat(a.slice(i + 1)); // array of removing one element\\n        if (isAscending(tmp)) return 1;\\n    }\\n    return 0;\\n};\\n\\nconst isAscending = (arr) => {\\n    return arr.every((x, i) => {\\n        return i === 0 || x > arr[i - 1];\\n    });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst canBeIncreasing = (a) => {\\n    if (isAscending(a)) return 1;\\n    let n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let tmp = a.slice(0, i).concat(a.slice(i + 1)); // array of removing one element\\n        if (isAscending(tmp)) return 1;\\n    }\\n    return 0;\\n};\\n\\nconst isAscending = (arr) => {\\n    return arr.every((x, i) => {\\n        return i === 0 || x > arr[i - 1];\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298898,
                "title": "lis-variation-java",
                "content": "class Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int n=nums.length;\\n        //LIS VARIATION\\n        \\n        int lis[]=new int[n];\\n        Arrays.fill(lis,1);\\n        int max=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j] && lis[i]<=lis[j]+1)\\n                {\\n                    lis[i]=lis[j]+1;\\n                    max=Math.max(lis[i],max);\\n                }\\n            }\\n        }\\n        if(max>=n-1)\\n            return true;\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int n=nums.length;\\n        //LIS VARIATION\\n        \\n        int lis[]=new int[n];\\n        Arrays.fill(lis,1);\\n        int max=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j] && lis[i]<=lis[j]+1)\\n                {\\n                    lis[i]=lis[j]+1;\\n                    max=Math.max(lis[i],max);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1298884,
                "title": "easy-c-solution-in-one-pass-linear-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n=nums.size();\\n        int chances=1; //  i have  only one chance to remove a number\\n        int i=0;\\n        while(i<nums.size()-1){\\n            if(nums[i]>=nums[i+1]){\\n                if(chances==0)return false;\\n                if(i==0){\\n                    nums[i]=nums[i+1]-1;\\n                }\\n                else{\\n                    if(nums[i+1]>nums[i-1])nums[i]=nums[i-1];\\n                    else nums[i+1]=nums[i];\\n                }\\n                chances--;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```\\n# Approach:\\n\\tWhile travesring through the array Ill keep checking the strictly increasing  sequence for the condition\\n\\tand when the condition doesn\\'t satisfy the condition A[i] < A[i+1]:\\n\\tThen we know for sure that we have to remove either of these two \\n\\there comes the main part i.e, which one to remove when you have a chance to remove both:\\n\\tthen it\\'s always better to remove the first one.\\n\\tYou\\'ll better understand it when you draw them as a graph on the paper",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n=nums.size();\\n        int chances=1; //  i have  only one chance to remove a number\\n        int i=0;\\n        while(i<nums.size()-1){\\n            if(nums[i]>=nums[i+1]){\\n                if(chances==0)return false;\\n                if(i==0){\\n                    nums[i]=nums[i+1]-1;\\n                }\\n                else{\\n                    if(nums[i+1]>nums[i-1])nums[i]=nums[i-1];\\n                    else nums[i+1]=nums[i];\\n                }\\n                chances--;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298762,
                "title": "dynamic-programming-c-longestincreasingsubsequence",
                "content": "```\\nint LongestIncreasingSubsequence(vector<int> &nums,int n){\\n        vector<int> dp(n);\\n        dp[0] = 1;  // because 1 element is always LIS\\n        for(int i=1;i<n;i++){\\n            dp[i]=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] and dp[i]<dp[j]+1){\\n                    dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        return *max_element(dp.begin(), dp.end());// Return maximum value in dp[]\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n = nums.size();\\n        if(LongestIncreasingSubsequence(nums,n)>=n-1){  // if size is n it means that array is already strictly increasing and n-1 for removal of only one element\\n            return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint LongestIncreasingSubsequence(vector<int> &nums,int n){\\n        vector<int> dp(n);\\n        dp[0] = 1;  // because 1 element is always LIS\\n        for(int i=1;i<n;i++){\\n            dp[i]=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] and dp[i]<dp[j]+1){\\n                    dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        return *max_element(dp.begin(), dp.end());// Return maximum value in dp[]\\n    }\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int n = nums.size();\\n        if(LongestIncreasingSubsequence(nums,n)>=n-1){  // if size is n it means that array is already strictly increasing and n-1 for removal of only one element\\n            return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298753,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int cnt = 0, n=nums.size();\\n        int index = -1; //index conatin the index of the element to be removed\\n        for (int i = 1; i < n ; i++) \\n            if (nums[i - 1] >= nums[i]) {\\n                cnt++;\\n                index = i;\\n            }\\n        if (cnt > 1) return false;\\n        \\n        // If no element is removed or only the last or the first element is removed\\n        if (index==-1 || index == n - 1 || index == 1)  return true;\\n\\n        // If a[index] is removed\\n        if (nums[index - 1] < nums[index + 1])   return true;\\n\\n        // If a[index - 1] is removed\\n        if (nums[index - 2] < nums[index])  return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n        int cnt = 0, n=nums.size();\\n        int index = -1; //index conatin the index of the element to be removed\\n        for (int i = 1; i < n ; i++) \\n            if (nums[i - 1] >= nums[i]) {\\n                cnt++;\\n                index = i;\\n            }\\n        if (cnt > 1) return false;\\n        \\n        // If no element is removed or only the last or the first element is removed\\n        if (index==-1 || index == n - 1 || index == 1)  return true;\\n\\n        // If a[index] is removed\\n        if (nums[index - 1] < nums[index + 1])   return true;\\n\\n        // If a[index - 1] is removed\\n        if (nums[index - 2] < nums[index])  return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298572,
                "title": "easy-c-o-n-and-o-1-space-complexity",
                "content": "**NOTE** : Check condition at breaking point\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n       int count=0,index=-1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]>=nums[i]) {\\n                count++;\\n                index=i;\\n            }\\n        }\\n        if(count>1) return false;\\n        \\n        if(count==0) return true;\\n        \\n        if(index==nums.size()-1 || index==1) return true;\\n        \\n        if(nums[index-1]<nums[index+1]) return true;\\n        \\n        if(nums[index-2]<nums[index]) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeIncreasing(vector<int>& nums) {\\n       int count=0,index=-1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]>=nums[i]) {\\n                count++;\\n                index=i;\\n            }\\n        }\\n        if(count>1) return false;\\n        \\n        if(count==0) return true;\\n        \\n        if(index==nums.size()-1 || index==1) return true;\\n        \\n        if(nums[index-1]<nums[index+1]) return true;\\n        \\n        if(nums[index-2]<nums[index]) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298570,
                "title": "python3-easy",
                "content": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        bad = -1\\n        for i in range(len(nums)-1):\\n            if nums[i]>=nums[i+1]:\\n                bad = i\\n        nums1 = [i for i in nums]\\n        nums2 = [i for i in nums]\\n        nums1.pop(bad)\\n        nums2.pop(bad+1)\\n        print(nums1)\\n        print(nums2)\\n        flag1 = True\\n        flag2 = True\\n        for i in range(len(nums1)-1):\\n            if nums1[i]>=nums1[i+1]:\\n                flag1 = False\\n        for i in range(len(nums2)-1):\\n            if nums2[i]>=nums2[i+1]:\\n                flag2 =  False\\n        return flag1 or flag2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        bad = -1\\n        for i in range(len(nums)-1):\\n            if nums[i]>=nums[i+1]:\\n                bad = i\\n        nums1 = [i for i in nums]\\n        nums2 = [i for i in nums]\\n        nums1.pop(bad)\\n        nums2.pop(bad+1)\\n        print(nums1)\\n        print(nums2)\\n        flag1 = True\\n        flag2 = True\\n        for i in range(len(nums1)-1):\\n            if nums1[i]>=nums1[i+1]:\\n                flag1 = False\\n        for i in range(len(nums2)-1):\\n            if nums2[i]>=nums2[i+1]:\\n                flag2 =  False\\n        return flag1 or flag2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298558,
                "title": "my-contest-easy-approach-o-n-c",
                "content": "Remove i and j , which causing error in sequence\\n```\\nbool canBeIncreasing(vector<int>& nums) {\\n        int i,j;\\n        for(int k=1;k<nums.size();k++){\\n            if(nums[k]<=nums[k-1]){\\n                i=k-1;\\n                j=k;\\n                break;\\n            }\\n        }\\n        \\n        bool ans=true;\\n        // remove i\\n        for(int k=1;k<nums.size();k++){\\n            if(k==i) continue;\\n            int z=k-1;\\n            if(k==i+1) z=k-2;\\n             if(z<0) continue;\\n            if(nums[k]<=nums[z]){\\n                ans=false;\\n            }\\n        }\\n        if(ans) return ans;\\n        ans=true;\\n       \\n        // remove j\\n        for(int k=1;k<nums.size();k++){\\n            if(k==j) continue;\\n            int z=k-1;\\n            if(k==j+1) z=k-2;\\n            if(z<0) continue;\\n            if(nums[k]<=nums[z]){\\n                ans=false;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canBeIncreasing(vector<int>& nums) {\\n        int i,j;\\n        for(int k=1;k<nums.size();k++){\\n            if(nums[k]<=nums[k-1]){\\n                i=k-1;\\n                j=k;\\n                break;\\n            }\\n        }\\n        \\n        bool ans=true;\\n        // remove i\\n        for(int k=1;k<nums.size();k++){\\n            if(k==i) continue;\\n            int z=k-1;\\n            if(k==i+1) z=k-2;\\n             if(z<0) continue;\\n            if(nums[k]<=nums[z]){\\n                ans=false;\\n            }\\n        }\\n        if(ans) return ans;\\n        ans=true;\\n       \\n        // remove j\\n        for(int k=1;k<nums.size();k++){\\n            if(k==j) continue;\\n            int z=k-1;\\n            if(k==j+1) z=k-2;\\n            if(z<0) continue;\\n            if(nums[k]<=nums[z]){\\n                ans=false;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298537,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        int n = nums.length;\\n        for (int i=0;i<n-1;i++) {\\n            if (nums[i]-nums[i+1] >= 0) {\\n                count++;\\n                if (i-1 >= 0 && i+2 <= n-1 && nums[i] - nums[i+2] >= 0 && nums[i-1] - nums[i+1] >= 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        if (count <= 1){\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count = 0;\\n        int n = nums.length;\\n        for (int i=0;i<n-1;i++) {\\n            if (nums[i]-nums[i+1] >= 0) {\\n                count++;\\n                if (i-1 >= 0 && i+2 <= n-1 && nums[i] - nums[i+2] >= 0 && nums[i-1] - nums[i+1] >= 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        if (count <= 1){\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298529,
                "title": "java-clean-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int prev = -1;\\n            boolean isIncreasing = true;\\n\\t\\t\\t\\n            for (int j = 0; j < nums.length; j++) {\\n                if (i == j) continue; // skip the removed element\\n                if (prev != -1 && nums[prev] >= nums[j]) { // compare current value to the previous , skip if no previous element\\n                    isIncreasing = false;\\n                    break;\\n                }\\n                prev = j;\\n            }\\n            \\n            if (isIncreasing) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int prev = -1;\\n            boolean isIncreasing = true;\\n\\t\\t\\t\\n            for (int j = 0; j < nums.length; j++) {\\n                if (i == j) continue; // skip the removed element\\n                if (prev != -1 && nums[prev] >= nums[j]) { // compare current value to the previous , skip if no previous element\\n                    isIncreasing = false;\\n                    break;\\n                }\\n                prev = j;\\n            }\\n            \\n            if (isIncreasing) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298442,
                "title": "python-java",
                "content": "\\n**Python**\\n```python\\n\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        c = 0\\n        for i in range(1,len(nums)):\\n            if nums[i-1] >= nums[i]:\\n                c += 1\\n                ind = i\\n\\n        if c > 1:\\n            return False\\n\\n        if c == 0 or ind == len(nums)-1 or ind == 1:\\n            return True\\n\\n        if nums[ind-1] < nums[ind+1] or nums[ind-2] < nums[ind]:\\n            return True\\n        \\n        return False\\n\\n```\\n---\\n**Java**\\n```java\\n\\nclass Solution {\\n    public boolean canBeIncreasing(int[] a) {\\n    int n = a.length;\\n    int c = 0;\\n    int index = -1;\\n \\n    for(int i = 1; i < n; i++)\\n        if (a[i - 1] >= a[i]){       \\n            c++;\\n            index = i;\\n        }\\n        \\n    if(c > 1)\\n        return false;\\n        \\n    if(c == 0 ||index == n - 1 || index == 1)\\n        return true;\\n \\n    if(a[index - 1] < a[index + 1] || a[index - 2] < a[index])\\n        return true;\\n \\n    return false;\\n        \\n    }\\n}\\n\\n```\\n---\\n\\nNOOBIE Solution - **Python**\\n\\n```python\\n\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        ind = [0,0]\\n        for i in range(1,len(nums)):\\n            if nums[i-1] == nums[i] and len(nums) > 2:\\n                return False\\n            if nums[i-1] > nums[i]:\\n                ind = [i-1,i]\\n\\n        if set(ind) == {0}:\\n            return True\\n        else:\\n            f = ind[0]\\n            s = ind[1]\\n\\n            if sorted(nums[:f]+nums[f+1:]) == nums[:f]+nums[f+1:]:\\n                return True\\n\\n            if sorted(nums[:s]+nums[s+1:]) == nums[:s]+nums[s+1:]:\\n                return True\\n\\n            else:\\n                return False\\n\\n```",
                "solutionTags": [],
                "code": "```python\\n\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        c = 0\\n        for i in range(1,len(nums)):\\n            if nums[i-1] >= nums[i]:\\n                c += 1\\n                ind = i\\n\\n        if c > 1:\\n            return False\\n\\n        if c == 0 or ind == len(nums)-1 or ind == 1:\\n            return True\\n\\n        if nums[ind-1] < nums[ind+1] or nums[ind-2] < nums[ind]:\\n            return True\\n        \\n        return False\\n\\n```\n```java\\n\\nclass Solution {\\n    public boolean canBeIncreasing(int[] a) {\\n    int n = a.length;\\n    int c = 0;\\n    int index = -1;\\n \\n    for(int i = 1; i < n; i++)\\n        if (a[i - 1] >= a[i]){       \\n            c++;\\n            index = i;\\n        }\\n        \\n    if(c > 1)\\n        return false;\\n        \\n    if(c == 0 ||index == n - 1 || index == 1)\\n        return true;\\n \\n    if(a[index - 1] < a[index + 1] || a[index - 2] < a[index])\\n        return true;\\n \\n    return false;\\n        \\n    }\\n}\\n\\n```\n```python\\n\\nclass Solution:\\n    def canBeIncreasing(self, nums: List[int]) -> bool:\\n        ind = [0,0]\\n        for i in range(1,len(nums)):\\n            if nums[i-1] == nums[i] and len(nums) > 2:\\n                return False\\n            if nums[i-1] > nums[i]:\\n                ind = [i-1,i]\\n\\n        if set(ind) == {0}:\\n            return True\\n        else:\\n            f = ind[0]\\n            s = ind[1]\\n\\n            if sorted(nums[:f]+nums[f+1:]) == nums[:f]+nums[f+1:]:\\n                return True\\n\\n            if sorted(nums[:s]+nums[s+1:]) == nums[:s]+nums[s+1:]:\\n                return True\\n\\n            else:\\n                return False\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1720864,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1779859,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1763807,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1720048,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1799798,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1772084,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1751715,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1992072,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1953830,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 2058988,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1720864,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1779859,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1763807,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1720048,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1799798,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1772084,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1751715,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1992072,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 1953830,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            },
            {
                "id": 2058988,
                "content": [
                    {
                        "username": "yogeshwarb",
                        "content": "This might be the trickiest \\'easy\\' i have ever seen on Leetcode"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I would LOVE to be a person who considers this problem to be easy... \\uD83D\\uDE48"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that normally easy problems take me about 5-15 mins to solve, but this one took considerably more time and effort in order to be finally accepted. Does not feel really easy to me, more like medium, but this is probably just because I am not smart enough \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "PiyushTale",
                        "content": "It\\'s pretty easy . Don\\'t focus on acceptance level"
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem feels like a go in a battle, I am pretty confident is easy but then I saw Acceptance rate 26% \\n"
                    },
                    {
                        "username": "aro",
                        "content": "\"exactly one element\" is bit confusing... Maybe [1,2,3,4] should be in the test case?"
                    },
                    {
                        "username": "Lewis0511",
                        "content": "No contradiction here. By removing any element from [1,2,3,4], the resulting array is still strictly increasing. "
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "[1,1] is expecting true\\nNeed explanation"
                    },
                    {
                        "username": "jotho_",
                        "content": "The array reduces to 1 element which apparently qualifies as strictly increasing."
                    },
                    {
                        "username": "aditya_42",
                        "content": "Strictly increasing, means each element should be greater than the previos"
                    },
                    {
                        "username": "aditya_42",
                        "content": "Drink your water rn"
                    },
                    {
                        "username": "neot",
                        "content": "It was tricky, several cases I needed to take in consideration."
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "Huh.. Even easy questions on Facebook are like this ! \\uD83E\\uDD72\\uD83D\\uDD2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "I don\\'t understand the low acceptance rate just follow the hint"
                    },
                    {
                        "username": "user9770Bt",
                        "content": "[105,924,32,968] how is this expecting true? how?"
                    },
                    {
                        "username": "DeepankTyagi",
                        "content": "remove 32 and it would become strictly increasing."
                    }
                ]
            }
        ]
    }
]