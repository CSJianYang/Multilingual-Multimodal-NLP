[
    {
        "title": "Maximum Subarray",
        "question_content": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n&nbsp;\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-104 <= nums[i] <= 104\n\n&nbsp;\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
        "solutions": [
            {
                "id": 20193,
                "title": "dp-solution-some-thoughts",
                "content": "Analysis of this problem:\\n Apparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem).  The format of the sub problem can be helpful when we are trying to come up with the recursive relation. \\n\\nAt first, I think the sub problem should look like: `maxSubArray(int A[], int i, int j)`, which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what `maxSubArray(A, 0, A.length - 1)` is. However, if we define the format of the sub problem in this way, it's hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can't find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one. \\n\\nSo I change the format of the sub problem into something like: `maxSubArray(int A[], int i)`, which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem's format is less flexible and less powerful than the previous one because there's a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem & the original one becomes clearer:\\n \\n\\n    maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i]; \\n\\nAnd here's the code\\n\\n    public int maxSubArray(int[] A) {\\n            int n = A.length;\\n            int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];\\n            dp[0] = A[0];\\n            int max = dp[0];\\n            \\n            for(int i = 1; i < n; i++){\\n                dp[i] = A[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);\\n                max = Math.max(max, dp[i]);\\n            }\\n            \\n            return max;\\n    }",
                "solutionTags": [],
                "code": "Analysis of this problem:\\n Apparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem).  The format of the sub problem can be helpful when we are trying to come up with the recursive relation. \\n\\nAt first, I think the sub problem should look like: `maxSubArray(int A[], int i, int j)`, which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what `maxSubArray(A, 0, A.length - 1)` is. However, if we define the format of the sub problem in this way, it's hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can't find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one. \\n\\nSo I change the format of the sub problem into something like: `maxSubArray(int A[], int i)`, which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem's format is less flexible and less powerful than the previous one because there's a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem & the original one becomes clearer:\\n \\n\\n    maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i]; \\n\\nAnd here's the code\\n\\n    public int maxSubArray(int[] A) {\\n            int n = A.length;\\n            int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];\\n            dp[0] = A[0];\\n            int max = dp[0];\\n            \\n            for(int i = 1; i < n; i++){\\n                dp[i] = A[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);\\n                max = Math.max(max, dp[i]);\\n            }\\n            \\n            return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1595195,
                "title": "c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer",
                "content": "We are given an array `nums` and we need to return the maximum sum of a subarray in `nums`.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force) [TLE]***\\n\\nWe can start with brute-force by trying out every possible sub-array in `nums` and choosing the one with maximum sum.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = size(nums), ans = INT_MIN;\\n        for(int i = 0; i < n; i++) \\n            for(int j = i, curSum = 0; j < n ; j++) \\n                curSum += nums[j],\\n                ans = max(ans, curSum);        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        ans = -inf\\n        for i in range(len(nums)):\\n            cur_sum = 0\\n            for j in range(i, len(nums)):\\n                cur_sum += nums[j]\\n                ans = max(ans, cur_sum)\\n        return ans\\n```\\n\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>, where  `N` is the number of elements in `nums`. There are `N*(N+1)/2` total sub-arrays and trying out each one takes time of <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u274C ***Solution - II (Recursive) [TLE]***\\n\\nAnother way to consider every subarray and return the one that has maximum sum is using recursive approach. Here we can state the approach as -\\n* At each index `i`, we can either pick that element or not pick it.\\n* If we pick current element, then all future element must also be picked since our array needs to be contiguous.\\n* If we had picked any elements till now, we can either end further recursion at any time by returning sum formed till now or we can choose current element and recurse further. This denotes two choices of either choosing the subarray formed from 1st picked element till now or expanding the subarray by choosing current element respectively.\\n\\nIn the code below, we will use `mustPick` to denote whether we must compulsorily pick current element. When `mustPick` is true, we must either return `0` or pick current element and recurse further. If `pickCur` is false, we have both choices of not picking current element and moving on to next element, or picking the current one.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {    \\n        return solve(nums, 0, false);\\n    }\\n    int solve(vector<int>& A, int i, bool mustPick) {\\n\\t\\t// our subarray must contain atleast 1 element. If mustPick is false at end means no element is picked and this is not valid case\\n        if(i >= size(A)) return mustPick ? 0 : -1e5;       \\n        if(mustPick)\\n            return max(0, A[i] + solve(A, i+1, true));                  // either stop here or choose current element and recurse\\n        return max(solve(A, i+1, false), A[i] + solve(A, i+1, true));   // try both choosing current element or not choosing\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def solve(i, must_pick):\\n            if i >= len(nums): return 0 if must_pick else -inf\\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\\n        return solve(0, False)\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>, we are basically considering every subarray sum and choosing maximum of it. \\n***Space Complexity :*** `O(N)`, for recursive space\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Memoization)***\\n\\nWe can observe a lot of repeated calculations if we draw out the recursive tree for above solution -\\n\\n```python\\n                                                f(0, False)                       \\uD83D\\uDD3D => repeated calculations\\n\\t\\t\\t\\t\\t                          /             \\\\ \\n                       \\t\\t       f(1, False)              f(1, True)\\n\\t\\t\\t                      /          \\\\       \\uD83D\\uDD3D          \\\\      \\uD83D\\uDD3D\\n\\t\\t\\t                 f(2, False)      f(2, True)           f(2, True)\\n\\t\\t\\t\\t\\t\\t\\t/            \\\\  \\uD83D\\uDD3D       \\\\   \\uD83D\\uDD3D           \\\\  \\uD83D\\uDD3D\\n\\t\\t\\t\\t\\t\\tf(3, False)   f(3,True)     f(3, True)           f(3, True)\\n\\t\\t\\t\\t\\t\\t/        \\\\            \\\\           \\\\                  \\\\\\n\\t\\t\\t\\t      ...        ...          ...         ...                ...\\n```\\n\\nThese redundant calculations can be eliminated if we store the results for a given state and reuse them later whenever required rather than recalculating them over and over again. \\n\\nThus, we can use memoization technique here to make our solution more efficient. Here, we use a `dp` array where `dp[mustPick][i]` denotes the maximum sum subarray starting from `i` and `mustPick` denotes wheter the current element must be picked compulsorily or not.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {    \\n        vector<vector<int>> dp(2, vector<int>(size(nums), -1));\\n        return solve(nums, 0, false, dp);\\n    }\\n    int solve(vector<int>& A, int i, bool mustPick, vector<vector<int>>& dp) {\\n        if(i >= size(A)) return mustPick ? 0 : -1e5;\\n        if(dp[mustPick][i] != -1) return dp[mustPick][i];\\n        if(mustPick)\\n            return dp[mustPick][i] = max(0, A[i] + solve(A, i+1, true, dp));\\n        return dp[mustPick][i] = max(solve(A, i+1, false, dp), A[i] + solve(A, i+1, true, dp));\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        @cache\\n        def solve(i, must_pick):\\n            if i >= len(nums): return 0 if must_pick else -inf\\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\\n        return solve(0, False)\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, we are calculating each state of the `dp` just once and memoizing the result. Thus, we are calculating results for `2*N` states and returning them directly in future recursive calls.\\n***Space Complexity :*** `O(N)`, for recursive space\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Tabulation)***\\n\\nWe can employ similar logic in iterative version as well. Here, we again use `dp` array and use bottom-up approach. Here `dp[1][i]` denotes maximum subarray sum ending at `i` (including `nums[i]`) and `dp[0][i]` denotes maximum subarray sum upto `i` (may or may not include `nums[i]`). \\n\\nAt each index, we update `dp[1][i]` as max between either only choosing current element - `nums[i]` or extending from previous subarray and choosing current element as well - `dp[1][i-1] + nums[i]`\\nSimilarly, `dp[0][1]` can be updated as max between maximum sum subarray found till last index - `dp[0][i-1]` or max subarray sum found ending at current index `dp[1][i]`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<vector<int>> dp(2, vector<int>(size(nums)));\\n        dp[0][0] = dp[1][0] = nums[0];\\n        for(int i = 1; i < size(nums); i++) {\\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1]);\\n            dp[0][i] = max(dp[0][i-1], dp[1][i]);\\n        }\\n        return dp[0].back();\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [[0]*len(nums) for i in range(2)]\\n        dp[0][0], dp[1][0] = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1])\\n            dp[0][i] = max(dp[0][i-1], dp[1][i])\\n        return dp[0][-1]\\n```\\n\\nWe can actually do away with just 1 row as well. We denoted `dp[1][i]` as the maximum subarray sum ending at `i`. We can just store that row and calculate the overall maximum subarray sum at the end by choosing the maximum of all max subarray sum ending at `i`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int> dp(nums);\\n        for(int i = 1; i < size(nums); i++) \\n            dp[i] = max(nums[i], nums[i] + dp[i-1]);        \\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [*nums]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\\n        return max(dp)\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, we are just iterating over the `nums` array once to compute the `dp` array and once more over the `dp` at the end to find maximum subarray sum. Thus overall time complexity is `O(N) + O(N) = O(N)`\\n***Space Complexity :*** `O(N)`, for maintaining `dp`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Kadane\\'s Algorithm)***\\n\\nWe can observe that in the previous approach, `dp[i]` only depended on `dp[i-1]`. So do we really need to maintain the whole `dp` array of `N` elements? One might see the last line of previous solution and say that we needed all elements of `dp` at the end to find the maximum sum subarray. But we can simply optimize that by storing the max at each iteration instead of separately calculating it at the end.\\n\\nThus, we only need to maintain `curMax` which is the maximum subarray sum ending at `i` and `maxTillNow` which is the maximum sum we have seen till now. And this way of solving this problem is what we popularly know as **Kadane\\'s Algorithm**\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int curMax = 0, maxTillNow = INT_MIN;\\n        for(auto c : nums)\\n            curMax = max(c, curMax + c),\\n            maxTillNow = max(maxTillNow, curMax);\\n        return maxTillNow;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        cur_max, max_till_now = 0, -inf\\n        for c in nums:\\n            cur_max = max(c, cur_max + c)\\n            max_till_now = max(max_till_now, cur_max)\\n        return max_till_now\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, for iterating over `nums` once\\n***Space Complexity :*** `O(1)`, only constant extra space is being used.\\n\\n*PS:* I have tried running `Solution - IV` and this solution multiple times and this solution, despite being `O(1)` shows higher memory usage(`28.8 MB` on average vs `28 MB` used by solution - IV) by LC consistently. If anyone can figure out the reason behind this, I will be happy to hear it out :)\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - VI (Divide & Conquer)***\\n\\nWe can solve this using divide and conquer strategy. This is the follow-up question asked in this question. This involves modelling the problem by observing that the maximum subarray sum is such that it lies somewhere -\\n\\n* entirely in the left-half of array `[L, mid-1]`, OR\\n* entirely in the right-half of array `[mid+1, R]`, OR\\n* in array consisting of mid element along with some part of left-half and some part of right-half such that these form contiguous subarray - <code>[L\\', R\\'] = [L\\', mid-1] + [mid] + [mid+1,R\\']</code>, where `L\\' >= L` and `R\\' <= R`\\n\\nWith the above observation, we can recursively divide the array into sub-problems on the left and right halves and then combine these results on the way back up to find the maximum subarray sum.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, size(nums)-1);\\n    }\\n    int maxSubArray(vector<int>& A, int L, int R){\\n        if(L > R) return INT_MIN;\\n        int mid = (L + R) / 2, leftSum = 0, rightSum = 0;\\n        // leftSum = max subarray sum in [L, mid-1] and starting from mid-1\\n        for(int i = mid-1, curSum = 0; i >= L; i--)\\n            curSum += A[i],\\n            leftSum=max(leftSum, curSum);\\n        // rightSum = max subarray sum in [mid+1, R] and starting from mid+1\\n        for(int i = mid+1, curSum = 0; i <= R; i++)\\n            curSum += A[i],\\n            rightSum = max(rightSum, curSum);        \\n\\t\\t// return max of 3 cases \\n        return max({ maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), leftSum + A[mid] + rightSum });\\n    }\\t\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def maxSubArray(A, L, R):\\n            if L > R: return -inf\\n            mid, left_sum, right_sum, cur_sum = (L + R) // 2, 0, 0, 0\\n            for i in range(mid-1, L-1, -1):\\n                left_sum = max(left_sum, cur_sum := cur_sum + A[i])\\n            cur_sum = 0\\n            for i in range(mid+1, R+1):\\n                right_sum = max(right_sum, cur_sum := cur_sum + A[i])\\n            return max(maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), left_sum + A[mid] + right_sum)\\n        return maxSubArray(nums, 0, len(nums)-1)\\n```\\n\\n***Time Complexity :*** <code>O(NlogN)</code>, the recurrence relation can be written as `T(N) = 2T(N/2) + O(N)` since we are recurring for left and right half (`2T(N/2)`) and also calculating maximal subarray including mid element which takes `O(N)` to calculate. Solving this recurrence using master theorem, we can get the time complexity as `O(NlogN)`\\n***Space Complexity :*** `O(logN)`, required by recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - VII (Optimized Divide & Conquer)***\\n\\nWe can further optimize the previous solution. The `O(N)` term in the recurrence relation of previous solution was due to computation of max sum subarray involving `nums[mid]` in each recursion. \\n\\nBut we can reduce that term to `O(1)` if we precompute it. This can be done by precomputing two arrays `pre` and `suf` where `pre[i]` will denote maximum sum subarray ending at `i` and `suf[i]` denotes the maximum subarray starting at `i`. `pre` is similar to `dp` array that we computed in dynamic programming solutions and `suf` can be calculated in similar way, just by starting iteration from the end.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> pre, suf;\\n    int maxSubArray(vector<int>& nums) {\\n        pre = suf = nums;\\n        for(int i = 1; i < size(nums); i++)  pre[i] += max(0, pre[i-1]);\\n        for(int i = size(nums)-2; ~i; i--)   suf[i] += max(0, suf[i+1]);\\n        return maxSubArray(nums, 0, size(nums)-1);\\n    }\\n    int maxSubArray(vector<int>& A, int L, int R){\\n        if(L == R) return A[L];\\n        int mid = (L + R) / 2;\\n        return max({ maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1] });\\n    }\\t\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        pre, suf = [*nums], [*nums]\\n        for i in range(1, len(nums)):       pre[i] += max(0, pre[i-1])\\n        for i in range(len(nums)-2,-1,-1):  suf[i] += max(0, suf[i+1])\\n        def maxSubArray(A, L, R):\\n            if L == R: return A[L]\\n            mid = (L + R) // 2\\n            return max(maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1])\\n        return maxSubArray(nums, 0, len(nums)-1)\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, the recurrence relation can be written as `T(N) = 2T(N/2) + O(1)` since we are recurring for left and right half (`2T(N/2)`) and calculating maximal subarray including mid element in `O(1)`. Solving this recurrence using master theorem, we can get the time complexity as `O(N)`\\n***Space Complexity :*** `O(N)`, required by `suf` and `pre`.\\n\\n---\\n\\n\\uD83D\\uDCA1  **Note:**\\n* The above divide and conquer solution works in `O(N)` but is **once you have calculated `pre` and `suf`, does it even make sense to go into divide and conquer approach?** I dont think divide and conquer approach after calculating `pre` & `suf`is useful, unless you Really want to solve it using **\\u275DDivde and Conquer\\u275E only**. You can instead do the following (which is similar to dp)- \\n\\n\\t```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tvector<int> pre = nums;\\n\\t\\t\\tfor(int i = 1; i < size(nums); i++) pre[i] += max(0, pre[i-1]);\\n\\t\\t\\treturn *max_element(begin(pre), end(pre));\\n\\t\\t}\\n\\t};\\n\\t```\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = size(nums), ans = INT_MIN;\\n        for(int i = 0; i < n; i++) \\n            for(int j = i, curSum = 0; j < n ; j++) \\n                curSum += nums[j],\\n                ans = max(ans, curSum);        \\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        ans = -inf\\n        for i in range(len(nums)):\\n            cur_sum = 0\\n            for j in range(i, len(nums)):\\n                cur_sum += nums[j]\\n                ans = max(ans, cur_sum)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {    \\n        return solve(nums, 0, false);\\n    }\\n    int solve(vector<int>& A, int i, bool mustPick) {\\n\\t\\t// our subarray must contain atleast 1 element. If mustPick is false at end means no element is picked and this is not valid case\\n        if(i >= size(A)) return mustPick ? 0 : -1e5;       \\n        if(mustPick)\\n            return max(0, A[i] + solve(A, i+1, true));                  // either stop here or choose current element and recurse\\n        return max(solve(A, i+1, false), A[i] + solve(A, i+1, true));   // try both choosing current element or not choosing\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def solve(i, must_pick):\\n            if i >= len(nums): return 0 if must_pick else -inf\\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\\n        return solve(0, False)\\n```\n```python\\n                                                f(0, False)                       \\uD83D\\uDD3D => repeated calculations\\n\\t\\t\\t\\t\\t                          /             \\\\ \\n                       \\t\\t       f(1, False)              f(1, True)\\n\\t\\t\\t                      /          \\\\       \\uD83D\\uDD3D          \\\\      \\uD83D\\uDD3D\\n\\t\\t\\t                 f(2, False)      f(2, True)           f(2, True)\\n\\t\\t\\t\\t\\t\\t\\t/            \\\\  \\uD83D\\uDD3D       \\\\   \\uD83D\\uDD3D           \\\\  \\uD83D\\uDD3D\\n\\t\\t\\t\\t\\t\\tf(3, False)   f(3,True)     f(3, True)           f(3, True)\\n\\t\\t\\t\\t\\t\\t/        \\\\            \\\\           \\\\                  \\\\\\n\\t\\t\\t\\t      ...        ...          ...         ...                ...\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {    \\n        vector<vector<int>> dp(2, vector<int>(size(nums), -1));\\n        return solve(nums, 0, false, dp);\\n    }\\n    int solve(vector<int>& A, int i, bool mustPick, vector<vector<int>>& dp) {\\n        if(i >= size(A)) return mustPick ? 0 : -1e5;\\n        if(dp[mustPick][i] != -1) return dp[mustPick][i];\\n        if(mustPick)\\n            return dp[mustPick][i] = max(0, A[i] + solve(A, i+1, true, dp));\\n        return dp[mustPick][i] = max(solve(A, i+1, false, dp), A[i] + solve(A, i+1, true, dp));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        @cache\\n        def solve(i, must_pick):\\n            if i >= len(nums): return 0 if must_pick else -inf\\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\\n        return solve(0, False)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<vector<int>> dp(2, vector<int>(size(nums)));\\n        dp[0][0] = dp[1][0] = nums[0];\\n        for(int i = 1; i < size(nums); i++) {\\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1]);\\n            dp[0][i] = max(dp[0][i-1], dp[1][i]);\\n        }\\n        return dp[0].back();\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [[0]*len(nums) for i in range(2)]\\n        dp[0][0], dp[1][0] = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1])\\n            dp[0][i] = max(dp[0][i-1], dp[1][i])\\n        return dp[0][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int> dp(nums);\\n        for(int i = 1; i < size(nums); i++) \\n            dp[i] = max(nums[i], nums[i] + dp[i-1]);        \\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [*nums]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\\n        return max(dp)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int curMax = 0, maxTillNow = INT_MIN;\\n        for(auto c : nums)\\n            curMax = max(c, curMax + c),\\n            maxTillNow = max(maxTillNow, curMax);\\n        return maxTillNow;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        cur_max, max_till_now = 0, -inf\\n        for c in nums:\\n            cur_max = max(c, cur_max + c)\\n            max_till_now = max(max_till_now, cur_max)\\n        return max_till_now\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, size(nums)-1);\\n    }\\n    int maxSubArray(vector<int>& A, int L, int R){\\n        if(L > R) return INT_MIN;\\n        int mid = (L + R) / 2, leftSum = 0, rightSum = 0;\\n        // leftSum = max subarray sum in [L, mid-1] and starting from mid-1\\n        for(int i = mid-1, curSum = 0; i >= L; i--)\\n            curSum += A[i],\\n            leftSum=max(leftSum, curSum);\\n        // rightSum = max subarray sum in [mid+1, R] and starting from mid+1\\n        for(int i = mid+1, curSum = 0; i <= R; i++)\\n            curSum += A[i],\\n            rightSum = max(rightSum, curSum);        \\n\\t\\t// return max of 3 cases \\n        return max({ maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), leftSum + A[mid] + rightSum });\\n    }\\t\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def maxSubArray(A, L, R):\\n            if L > R: return -inf\\n            mid, left_sum, right_sum, cur_sum = (L + R) // 2, 0, 0, 0\\n            for i in range(mid-1, L-1, -1):\\n                left_sum = max(left_sum, cur_sum := cur_sum + A[i])\\n            cur_sum = 0\\n            for i in range(mid+1, R+1):\\n                right_sum = max(right_sum, cur_sum := cur_sum + A[i])\\n            return max(maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), left_sum + A[mid] + right_sum)\\n        return maxSubArray(nums, 0, len(nums)-1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> pre, suf;\\n    int maxSubArray(vector<int>& nums) {\\n        pre = suf = nums;\\n        for(int i = 1; i < size(nums); i++)  pre[i] += max(0, pre[i-1]);\\n        for(int i = size(nums)-2; ~i; i--)   suf[i] += max(0, suf[i+1]);\\n        return maxSubArray(nums, 0, size(nums)-1);\\n    }\\n    int maxSubArray(vector<int>& A, int L, int R){\\n        if(L == R) return A[L];\\n        int mid = (L + R) / 2;\\n        return max({ maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1] });\\n    }\\t\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        pre, suf = [*nums], [*nums]\\n        for i in range(1, len(nums)):       pre[i] += max(0, pre[i-1])\\n        for i in range(len(nums)-2,-1,-1):  suf[i] += max(0, suf[i+1])\\n        def maxSubArray(A, L, R):\\n            if L == R: return A[L]\\n            mid = (L + R) // 2\\n            return max(maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1])\\n        return maxSubArray(nums, 0, len(nums)-1)\\n```\n```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tvector<int> pre = nums;\\n\\t\\t\\tfor(int i = 1; i < size(nums); i++) pre[i] += max(0, pre[i-1]);\\n\\t\\t\\treturn *max_element(begin(pre), end(pre));\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 20211,
                "title": "accepted-o-n-solution-in-java",
                "content": "this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885)\\n\\nthe paragraph below was copied from his paper (with a little modifications)\\n\\nalgorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we've solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximum \\nsum in the first I elements is either the maximum sum in the first i - 1 elements (which we'll call MaxSoFar), or it is that of a subvector that ends in position i (which we'll call MaxEndingHere).  \\n\\nMaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger.\\n\\n    public static int maxSubArray(int[] A) {\\n        int maxSoFar=A[0], maxEndingHere=A[0];\\n        for (int i=1;i<A.length;++i){\\n        \\tmaxEndingHere= Math.max(maxEndingHere+A[i],A[i]);\\n        \\tmaxSoFar=Math.max(maxSoFar, maxEndingHere);\\t\\n        }\\n        return maxSoFar;\\n    }",
                "solutionTags": [],
                "code": "this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885)\\n\\nthe paragraph below was copied from his paper (with a little modifications)\\n\\nalgorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we've solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximum \\nsum in the first I elements is either the maximum sum in the first i - 1 elements (which we'll call MaxSoFar), or it is that of a subvector that ends in position i (which we'll call MaxEndingHere).  \\n\\nMaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger.\\n\\n    public static int maxSubArray(int[] A) {\\n        int maxSoFar=A[0], maxEndingHere=A[0];\\n        for (int i=1;i<A.length;++i){\\n        \\tmaxEndingHere= Math.max(maxEndingHere+A[i],A[i]);\\n        \\tmaxSoFar=Math.max(maxSoFar, maxEndingHere);\\t\\n        }\\n        return maxSoFar;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20396,
                "title": "easy-python-way",
                "content": "    for i in range(1, len(nums)):\\n            if nums[i-1] > 0:\\n                nums[i] += nums[i-1]\\n        return max(nums)",
                "solutionTags": [],
                "code": "    for i in range(1, len(nums)):\\n            if nums[i-1] > 0:\\n                nums[i] += nums[i-1]\\n        return max(nums)",
                "codeTag": "Unknown"
            },
            {
                "id": 1595097,
                "title": "java-kadane-s-algorithm-explanation-using-image",
                "content": "**Intution:** Start traversing your array keep each element in the sum and every time keep the max of currSum and prevSum.\\n**But the catch here is that if at any point sum becomes negative then no point keeping it because 0 is obviously greater than negative, so just make your sum 0.**\\n\\n![image](https://assets.leetcode.com/users/images/2715e7ab-8fad-4f5f-ace9-cfe83acba68f_1637809592.7767313.jpeg)\\n\\nNow here in this question you can see that you can also be asked some more things like :\\n* Length of the max subarray\\n* Elements of the max subarray\\n* Start and End index of max subarray\\n  ##### This is very important concept from interview point so try to get the ans of above mentioned point and have confidence on this algorithm.\\n\\n**CODE :**\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int n = nums.length;\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            max = Math.max(sum,max);\\n            \\n            if(sum<0) sum = 0;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\nP.S. : I see a lots of comments saying this algorithm will not work if all the elements are negative....plz analyze it carefully...this is working for every case. \\n**if(sum<0) sum = 0;** -> this line is doing some magic. Dry run the algorithm carefully and u will get the answer. \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int n = nums.length;\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            max = Math.max(sum,max);\\n            \\n            if(sum<0) sum = 0;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20194,
                "title": "a-python-solution",
                "content": "    class Solution:\\n        # @param A, a list of integers\\n        # @return an integer\\n        # 6:57\\n        def maxSubArray(self, A):\\n            if not A:\\n                return 0\\n    \\n            curSum = maxSum = A[0]\\n            for num in A[1:]:\\n                curSum = max(num, curSum + num)\\n                maxSum = max(maxSum, curSum)\\n    \\n            return maxSum",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param A, a list of integers\\n        # @return an integer\\n        # 6:57\\n        def maxSubArray(self, A):\\n            if not A:\\n                return 0\\n    \\n            curSum = maxSum = A[0]\\n            for num in A[1:]:\\n                curSum = max(num, curSum + num)\\n                maxSum = max(maxSum, curSum)\\n    \\n            return maxSum",
                "codeTag": "Java"
            },
            {
                "id": 20452,
                "title": "c-dp-and-divide-and-conquer",
                "content": "**Dynamic Programming**\\n\\nThere is a nice introduction to the DP algorithm in this [Wikipedia article](https://en.wikipedia.org/wiki/Maximum_subarray_problem). The idea is to maintain a running maximum `smax` and a current summation `sum`. When we visit each `num` in `nums`, add `num` to `sum`, then update `smax` if necessary or reset `sum` to `0` if it becomes negative.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum = 0, smax = INT_MIN;\\n        for (int num : nums) {\\n            sum += num;\\n            smax = max(smax, sum);\\n            if (sum < 0) {\\n                sum = 0;\\n            }\\n        }\\n        return smax;\\n    }\\n};\\n```\\n\\n**Divide and Conquer**\\n\\nThe Divide-and-Conquer algorithm breaks `nums` into two halves and find the maximum subarray sum in them recursively. Well, the most tricky part is to handle the case that the maximum subarray spans the two halves. For this case, we use a linear algorithm: starting from the middle element and move to both ends (left and right ends), record the maximum sum we have seen. In this case, the maximum sum is finally equal to the middle element plus the maximum sum of moving leftwards and the maximum sum of moving rightwards.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, nums.size() - 1);\\n    }\\nprivate:\\n    int maxSubArray(vector<int>& nums, int l, int r) {\\n        if (l > r) {\\n            return INT_MIN;\\n        }\\n        int m = l + (r - l) / 2, ml = 0, mr = 0;\\n        int lmax = maxSubArray(nums, l, m - 1);\\n        int rmax = maxSubArray(nums, m + 1, r);\\n        for (int i = m - 1, sum = 0; i >= l; i--) {\\n            sum += nums[i];\\n            ml = max(sum, ml);\\n        }\\n        for (int i = m + 1, sum = 0; i <= r; i++) {\\n            sum += nums[i];\\n            mr = max(sum, mr);\\n        }\\n        return max(max(lmax, rmax), ml + mr + nums[m]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum = 0, smax = INT_MIN;\\n        for (int num : nums) {\\n            sum += num;\\n            smax = max(smax, sum);\\n            if (sum < 0) {\\n                sum = 0;\\n            }\\n        }\\n        return smax;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, nums.size() - 1);\\n    }\\nprivate:\\n    int maxSubArray(vector<int>& nums, int l, int r) {\\n        if (l > r) {\\n            return INT_MIN;\\n        }\\n        int m = l + (r - l) / 2, ml = 0, mr = 0;\\n        int lmax = maxSubArray(nums, l, m - 1);\\n        int rmax = maxSubArray(nums, m + 1, r);\\n        for (int i = m - 1, sum = 0; i >= l; i--) {\\n            sum += nums[i];\\n            ml = max(sum, ml);\\n        }\\n        for (int i = m + 1, sum = 0; i <= r; i++) {\\n            sum += nums[i];\\n            mr = max(sum, mr);\\n        }\\n        return max(max(lmax, rmax), ml + mr + nums[m]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470547,
                "title": "c-easy-clean-solution-fastest-0ms-all-methods-follow-ups-detailed-explanation",
                "content": "#### Idea:\\n\\nInitialise: **currMaxSum** and **globalMaxSum** as nums[0] since, for i = 0, we only have 1 choice i.e to include it into the maxSum SubArray.\\n\\nFor any index i [ 1 <= i <= n [:= nums.size()] - 1 ], we have **two choices** for maxSum SubArray: \\n1. It expands itself by including nums[i] (or ith index).\\n2. It discards itself and starts fresh from nums[i] (or ith index).\\n\\nAt each step, we choose **max** of above two choices for ith index and update our currMaxSum.\\nAt each step, we **update** globalMaxSum to store the global maxSum SubArray.\\n\\n##### Method1: Recursive [T(n) = O(n) and S(n) = O(n) [recursion stack space]]\\n\\n```\\nclass Solution {\\npublic:\\n\\tint globalMaxSum;\\n\\tint maxSubArray(vector<int> &nums, int n) {\\n\\t\\tif (n == 1) return nums[0];\\n\\t\\tint currMaxSum = max(nums[n - 1], maxSubArray(nums, n - 1) + nums[n - 1]);\\n\\t\\tglobalMaxSum = max(globalMaxSum, currMaxSum);\\n\\t\\treturn currMaxSum;\\n\\t}\\n    int maxSubArray(vector<int> &nums) {\\n        globalMaxSum = nums[0];\\n\\t\\tmaxSubArray(nums, nums.size());\\n        return globalMaxSum;\\n    }\\n};\\n```\\n\\n##### Method2: Iterative [T(n) = O(n) and S(n) = O(1)]\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int> &nums) {\\n        int globalMaxSum = nums[0], currMaxSum = nums[0];\\n        for (int ind = 1; ind < nums.size(); ind++) {\\n            currMaxSum = max(currMaxSum + nums[ind], nums[ind]);\\n            globalMaxSum = max(globalMaxSum, currMaxSum);\\n        }\\n        return globalMaxSum;\\n    }\\n};\\n```\\n\\n#### Follow Up Question:\\n\\nWhat if we need to find the length OR print the maxSum SubArray? Note that there can be many such SubArrays, So, we want to print the subArray with maxLength. If more than 1 subArray exist with maxLength then we can print anyone of them.\\n\\n##### Idea:\\n\\nUse three variables: **currStart**, **globalStart** and **globalEnd** for storing starting index of **currMaxSum** SubArray, starting and ending index of **globalMaxSum** SubArray **respectively**. Note that there is no need to store ending index of **currMaxSum** SubArray as it can be maintained using current index.\\n\\nThe idea is to update currStart whenever we prefer choice 2 (detail mentioned above at starting of the post) and update globalStart and globalEnd whenver we update globalMaxSum. Doing this will give us starting and ending index of anyone of the possible subArrays with globalMaxSum.\\nNow, to find the maxLen maxSum (=globalMaxSum) SubArray, we can update globalStart and globalEnd whenever we find a potential candidate for the maxLen i.e whenver we have: `globalMaxSum = currMaxSum` such that this candidate have larger length than the current candidate i.e: `globalLen < currLen => globalEnd - globalStart + 1 < currEnd - currStart + 1 => globalEnd - globalStart < ind - currStart`\\nThis is a very useful trick that can be used/ applied in many such similar problems.\\n\\n```\\n// Use below utility function to print the subArray\\nvoid printSubArray(vector<int> &nums, int low, int high) {\\n\\tfor (int ind = low; ind <= high; ind++)\\n\\t\\tcout << nums[ind] << \" \";\\n\\tcout << \"\\\\n\";\\n}\\n```\\n\\n##### Method1: Recursive [T(n) = O(n) and S(n) = O(n) [recursion stack space]]\\n\\n```\\nclass Solution {\\npublic:\\n\\tint globalMaxSum, globalStart = 0, globalEnd = 0, currStart = 0;\\n\\tint maxSubArray(vector<int> &nums, int n) {\\n\\t\\tif (n == 1) return nums[0];\\n\\t\\tint currMaxSum = maxSubArray(nums, n - 1);\\n\\t\\tif (currMaxSum < 0)    // same as: currMaxSum + nums[n - 1] < nums[n - 1]\\n\\t\\t\\tcurrMaxSum = nums[n - 1], currStart = n - 1;\\n\\t\\telse currMaxSum += nums[n - 1];\\n\\t\\t// use only below if cond. to find anyone of all subArrays with globalMaxSum\\n\\t\\tif (globalMaxSum < currMaxSum)\\n\\t\\t\\tglobalMaxSum = currMaxSum, globalStart = currStart, globalEnd = n - 1;\\n\\t\\t// use below to find anyone of all maxLen subArrays with globalMaxSum\\n\\t\\telse if (globalMaxSum == currMaxSum and globalEnd - globalStart < (n - 1) - currStart)\\n\\t\\t\\tglobalStart = currStart, globalEnd = n - 1;\\n\\t\\treturn currMaxSum;\\n\\t}\\n    void printMaxSubArray(vector<int> &nums) {\\n        globalMaxSum = nums[0];\\n\\t\\tmaxSubArray(nums, nums.size());\\n\\t\\tcout << \"Following SubArray has maxSum: \" << globalMaxSum;\\n\\t\\tcout << \" and has length: \" << globalEnd - globalStart + 1 << \" :\\\\n\";\\n\\t\\tprintSubArray(nums, globalStart, globalEnd);\\n\\t\\t\\n    }\\n};\\n```\\n\\n##### Method2: Iterative [T(n) = O(n) and S(n) = O(1)]\\n\\n```\\nclass Solution {\\npublic:\\n    void maxSubArray(vector<int> &nums) {\\n        int globalMaxSum = nums[0], currMaxSum = nums[0];\\n\\t\\tint globalStart = 0, globalEnd = 0, currStart = 0;\\n        for (int ind = 1; ind < nums.size(); ind++) {\\n            if (currMaxSum < 0)    // same as: currMaxSum + nums[ind] < nums[ind]\\n\\t\\t\\t\\tcurrMaxSum = nums[ind], currStart = ind;\\n\\t\\t\\telse currMaxSum += nums[ind];\\n\\t\\t\\t// use only below if cond. to find anyone of all subArrays with globalMaxSum\\n\\t\\t\\tif (globalMaxSum < currMaxSum)\\n\\t\\t\\t\\tglobalMaxSum = currMaxSum, globalStart = currStart, globalEnd = ind;\\n\\t\\t\\t// use below to find anyone of all maxLen subArrays with globalMaxSum\\n\\t\\t\\telse if (globalMaxSum == currMaxSum and globalEnd - globalStart < ind - currStart)\\n\\t\\t\\t\\tglobalStart = currStart, globalEnd = ind;\\n        }\\n\\t\\tcout << \"Following SubArray has maxSum: \" << globalMaxSum;\\n\\t\\tcout << \" and has length: \" << globalEnd - globalStart + 1 << \" :\\\\n\";\\n\\t\\tprintSubArray(nums, globalStart, globalEnd);\\n    }\\n};\\n```\\n\\n#### Important Points:\\n\\nThis solution is inspired by Kadane\\'s Algorithm (Google for more info). We can also use this concept to find min/ max sum/ product subarray [obviously with some added intuition/ tweaks :)].\\n\\nSimilar problems on Leetcode are:\\n1. [918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/)\\n2. [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)\\n3. [1567. Maximum Length of Subarray With Positive Product](https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/)\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written a post on all C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint globalMaxSum;\\n\\tint maxSubArray(vector<int> &nums, int n) {\\n\\t\\tif (n == 1) return nums[0];\\n\\t\\tint currMaxSum = max(nums[n - 1], maxSubArray(nums, n - 1) + nums[n - 1]);\\n\\t\\tglobalMaxSum = max(globalMaxSum, currMaxSum);\\n\\t\\treturn currMaxSum;\\n\\t}\\n    int maxSubArray(vector<int> &nums) {\\n        globalMaxSum = nums[0];\\n\\t\\tmaxSubArray(nums, nums.size());\\n        return globalMaxSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int> &nums) {\\n        int globalMaxSum = nums[0], currMaxSum = nums[0];\\n        for (int ind = 1; ind < nums.size(); ind++) {\\n            currMaxSum = max(currMaxSum + nums[ind], nums[ind]);\\n            globalMaxSum = max(globalMaxSum, currMaxSum);\\n        }\\n        return globalMaxSum;\\n    }\\n};\\n```\n```\\n// Use below utility function to print the subArray\\nvoid printSubArray(vector<int> &nums, int low, int high) {\\n\\tfor (int ind = low; ind <= high; ind++)\\n\\t\\tcout << nums[ind] << \" \";\\n\\tcout << \"\\\\n\";\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tint globalMaxSum, globalStart = 0, globalEnd = 0, currStart = 0;\\n\\tint maxSubArray(vector<int> &nums, int n) {\\n\\t\\tif (n == 1) return nums[0];\\n\\t\\tint currMaxSum = maxSubArray(nums, n - 1);\\n\\t\\tif (currMaxSum < 0)    // same as: currMaxSum + nums[n - 1] < nums[n - 1]\\n\\t\\t\\tcurrMaxSum = nums[n - 1], currStart = n - 1;\\n\\t\\telse currMaxSum += nums[n - 1];\\n\\t\\t// use only below if cond. to find anyone of all subArrays with globalMaxSum\\n\\t\\tif (globalMaxSum < currMaxSum)\\n\\t\\t\\tglobalMaxSum = currMaxSum, globalStart = currStart, globalEnd = n - 1;\\n\\t\\t// use below to find anyone of all maxLen subArrays with globalMaxSum\\n\\t\\telse if (globalMaxSum == currMaxSum and globalEnd - globalStart < (n - 1) - currStart)\\n\\t\\t\\tglobalStart = currStart, globalEnd = n - 1;\\n\\t\\treturn currMaxSum;\\n\\t}\\n    void printMaxSubArray(vector<int> &nums) {\\n        globalMaxSum = nums[0];\\n\\t\\tmaxSubArray(nums, nums.size());\\n\\t\\tcout << \"Following SubArray has maxSum: \" << globalMaxSum;\\n\\t\\tcout << \" and has length: \" << globalEnd - globalStart + 1 << \" :\\\\n\";\\n\\t\\tprintSubArray(nums, globalStart, globalEnd);\\n\\t\\t\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void maxSubArray(vector<int> &nums) {\\n        int globalMaxSum = nums[0], currMaxSum = nums[0];\\n\\t\\tint globalStart = 0, globalEnd = 0, currStart = 0;\\n        for (int ind = 1; ind < nums.size(); ind++) {\\n            if (currMaxSum < 0)    // same as: currMaxSum + nums[ind] < nums[ind]\\n\\t\\t\\t\\tcurrMaxSum = nums[ind], currStart = ind;\\n\\t\\t\\telse currMaxSum += nums[ind];\\n\\t\\t\\t// use only below if cond. to find anyone of all subArrays with globalMaxSum\\n\\t\\t\\tif (globalMaxSum < currMaxSum)\\n\\t\\t\\t\\tglobalMaxSum = currMaxSum, globalStart = currStart, globalEnd = ind;\\n\\t\\t\\t// use below to find anyone of all maxLen subArrays with globalMaxSum\\n\\t\\t\\telse if (globalMaxSum == currMaxSum and globalEnd - globalStart < ind - currStart)\\n\\t\\t\\t\\tglobalStart = currStart, globalEnd = ind;\\n        }\\n\\t\\tcout << \"Following SubArray has maxSum: \" << globalMaxSum;\\n\\t\\tcout << \" and has length: \" << globalEnd - globalStart + 1 << \" :\\\\n\";\\n\\t\\tprintSubArray(nums, globalStart, globalEnd);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 20210,
                "title": "o-n-java-solution",
                "content": "The catch here is that we have to take care of negative value.\\nThe solution does 1 iteration with constant space and no DP.\\n\\n    public class Solution {\\n    public int maxSubArray(int[] A) {\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (sum < 0) \\n                sum = A[i];\\n            else \\n                sum += A[i];\\n            if (sum > max)\\n                max = sum;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSubArray(int[] A) {\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (sum < 0) \\n                sum = A[i];\\n            else \\n                sum += A[i];\\n            if (sum > max)\\n                max = sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1595186,
                "title": "java-kadane-divide-and-conquer-dp",
                "content": "\\n\\n> ### Approch 1: Divide and Conquer Approch\\n\\n*Split our array into two halves*\\n**case1:** maxSum subaaray occur in left half , \\n**case2:**  maxSum subarray occur in right half\\n**case3:** maxSum subaaray lies about middle of array \\n\\nWe use here divide and conquer approch here , split array into two halves about middle \\ntake anwer from left , right , and subArray about middle.\\nLet assume recusion will give us answer for left and right part , how do we calculate maxsum subarray about mid :\\n **[-2,1,-3,4,-1,2,1,-5,4]**\\n i = 0  , j =  8\\n mid =  (0+8)/2 =  4\\n **step 1) Caluate maxSum (maximum positive sum) from mid to left**\\n   \\n```\\n     int sum = 0,leftMaxSUM = Integer.MIN_VALUE;\\n\\tfor(int l =  mid;l>=i;l--){\\n\\t\\tsum+=nums[l];\\n\\t\\tif(sum>leftMaxSUM ){\\n\\t\\t\\tleftMaxSUM =  sum;\\n\\t\\t}                                    \\n\\t}\\n```\\n **step 2) calculate maxSum(maximum positive sum ) from mid+1 to right side** \\n \\n ```\\nint rightMaxSUM = Integer.MIN_VALUE; \\nsum = 0;    // reset sum to 0\\n        for (int l = mid + 1; l <=j; l++)\\n        {\\n            sum += nums[l];\\n            if (sum > rightMaxSUM ) {\\n                rightMaxSUM = sum;\\n            }\\n        }\\n \\n```\\n`   int midSum = leftMaxSUM+rightMaxSUM   `\\n\\n\\n**Let code it**\\n **---- divide and conquer approch -------------------**\\n \\n```\\npublic int maxSubArray(int[] nums) {\\n    \\n        return helper(nums,0,nums.length-1);\\n    }\\n    \\n    public int helper(int nums[],int i,int j){\\n\\n        if(i==j){\\n            return nums[i];\\n        }\\n                          \\n        int mid  =  (i+j)/2;\\n        int sum = 0,leftMaxSUM = Integer.MIN_VALUE;\\n        \\n        for(int l =  mid;l>=i;l--){\\n            sum+=nums[l];\\n            if(sum>leftMaxSUM){\\n                leftMaxSUM =  sum;\\n            }                                    \\n        }\\n        \\n     int rightMaxSUM = Integer.MIN_VALUE;\\n        sum = 0;    // reset sum to 0\\n        for (int l = mid + 1; l <=j; l++)\\n        {\\n            sum += nums[l];\\n            if (sum > rightMaxSUM ) {\\n                rightMaxSUM = sum;\\n            }\\n        }\\n        \\n       int maxLeftRight = Math.max(helper(nums, i, mid),\\n                                    helper(nums, mid + 1, j ));\\n        return Math.max(maxLeftRight, leftMaxSUM + rightMaxSUM );\\n        \\n        \\n    \\n    }\\n```\\n \\n ---\\n \\n > ### Approch 2 : Dynamic Programming\\n \\n Take one varibale as a global maximum , say   max (To keep track maximum value)\\n **dp[i] means max sum subarray ending at index i**\\n  **If sum till i-1 is is usefull ,  then take it other wise take current cell as sum till i**\\n \\n   \\n ```\\npublic int maxSubArray(int[] nums) {\\n\\tint storage []=  new int[nums.length];\\n    int max  =  nums[0];\\n    storage[0 ] =  nums[0];\\n    for( int i=1;i<nums.length ;i++  ){\\n        storage[i] =  Math.max( storage[i-1]+nums[i] ,  nums[i]);\\n        if(storage[i]>max){\\n            max=  storage[i];\\n        }\\n    }\\n    return max;    \\n      }\\n```\\n \\n \\n\\n \\n ---\\n \\n \\n \\n> ###  Approch 3 : Kadane Algorithm (Best Approch) -  O(n) time Complexity \\n\\n\\n\\n \\n \\n * if overall sum become negative then it is better to take reinitialize sum to **zero** , beacuse may be possible later we have positive sum , but if we move with negative sum then it only decrease our positive sum , so it better to **reinitialize sum to 0 means start new subarray from next index** , \\n \\n ```\\n\\n   public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int  i =0;i<nums.length;i++){\\n            sum+=nums[i];\\n            maxSum =  Math.max(maxSum,sum);\\n            if(sum<0){\\n                sum = 0;\\n            }\\n        }\\n            return maxSum;\\n        \\n    }\\n```\\n\\n\\nIf found usefull then **upvote it **\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\n     int sum = 0,leftMaxSUM = Integer.MIN_VALUE;\\n\\tfor(int l =  mid;l>=i;l--){\\n\\t\\tsum+=nums[l];\\n\\t\\tif(sum>leftMaxSUM ){\\n\\t\\t\\tleftMaxSUM =  sum;\\n\\t\\t}                                    \\n\\t}\\n```\n```\\nint rightMaxSUM = Integer.MIN_VALUE; \\nsum = 0;    // reset sum to 0\\n        for (int l = mid + 1; l <=j; l++)\\n        {\\n            sum += nums[l];\\n            if (sum > rightMaxSUM ) {\\n                rightMaxSUM = sum;\\n            }\\n        }\\n \\n```\n```\\npublic int maxSubArray(int[] nums) {\\n    \\n        return helper(nums,0,nums.length-1);\\n    }\\n    \\n    public int helper(int nums[],int i,int j){\\n\\n        if(i==j){\\n            return nums[i];\\n        }\\n                          \\n        int mid  =  (i+j)/2;\\n        int sum = 0,leftMaxSUM = Integer.MIN_VALUE;\\n        \\n        for(int l =  mid;l>=i;l--){\\n            sum+=nums[l];\\n            if(sum>leftMaxSUM){\\n                leftMaxSUM =  sum;\\n            }                                    \\n        }\\n        \\n     int rightMaxSUM = Integer.MIN_VALUE;\\n        sum = 0;    // reset sum to 0\\n        for (int l = mid + 1; l <=j; l++)\\n        {\\n            sum += nums[l];\\n            if (sum > rightMaxSUM ) {\\n                rightMaxSUM = sum;\\n            }\\n        }\\n        \\n       int maxLeftRight = Math.max(helper(nums, i, mid),\\n                                    helper(nums, mid + 1, j ));\\n        return Math.max(maxLeftRight, leftMaxSUM + rightMaxSUM );\\n        \\n        \\n    \\n    }\\n```\n```\\npublic int maxSubArray(int[] nums) {\\n\\tint storage []=  new int[nums.length];\\n    int max  =  nums[0];\\n    storage[0 ] =  nums[0];\\n    for( int i=1;i<nums.length ;i++  ){\\n        storage[i] =  Math.max( storage[i-1]+nums[i] ,  nums[i]);\\n        if(storage[i]>max){\\n            max=  storage[i];\\n        }\\n    }\\n    return max;    \\n      }\\n```\n```\\n\\n   public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int  i =0;i<nums.length;i++){\\n            sum+=nums[i];\\n            maxSum =  Math.max(maxSum,sum);\\n            if(sum<0){\\n                sum = 0;\\n            }\\n        }\\n            return maxSum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666304,
                "title": "beats-100-c-java-python-beginner-friendly",
                "content": "# Intuition\\nThe Intuition behind the code is to find the maximum sum of a contiguous subarray within the given array `nums`. It does this by scanning through the array and keeping track of the current sum of the subarray. Whenever the current sum becomes greater than the maximum sum encountered so far, it updates the maximum sum. If the current sum becomes negative, it resets the sum to 0 and starts a new subarray. By the end of the loop, the code returns the maximum sum found.\\n\\n# Approach:\\n\\n1. We start by initializing two variables: `maxSum` and `currentSum`.\\n   - `maxSum` represents the maximum sum encountered so far and is initially set to the minimum possible integer value to ensure that any valid subarray sum will be greater than it.\\n   - `currentSum` represents the current sum of the subarray being considered and is initially set to 0.\\n2. We iterate through the `nums` array using a for loop, starting from the first element and going up to the last element.\\n3. For each element in the array, we add it to the current sum `currentSum`. This calculates the sum of the subarray ending at the current element.\\n4. Next, we check if the current sum `currentSum` is greater than the current maximum sum `maxSum`.\\n   - If it is, we update `maxSum` with the new value of `currentSum`. This means we have found a new maximum subarray sum.\\n5. If the current sum `currentSum` becomes negative, it indicates that including the current element in the subarray would reduce the overall sum. In such cases, we reset `currentSum` to 0. This effectively discards the current subarray and allows us to start a fresh subarray from the next element.\\n6. We repeat steps 3 to 5 for each element in the array.\\n7. After iterating through the entire array, the variable `maxSum` will contain the maximum subarray sum encountered.\\n8. Finally, we return the value of `maxSum` as the result, representing the maximum sum of a contiguous subarray within the given array `nums`.\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = INT_MIN;\\n        int currentSum = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            currentSum += nums[i];\\n            \\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            \\n            if (currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int currentSum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            currentSum += nums[i];\\n            \\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            \\n            if (currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = float(\\'-inf\\')\\n        currentSum = 0\\n        \\n        for num in nums:\\n            currentSum += num\\n            \\n            if currentSum > maxSum:\\n                maxSum = currentSum\\n            \\n            if currentSum < 0:\\n                currentSum = 0\\n        \\n        return maxSum\\n```\\n\\n# clean code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = nums[0];\\n        int currentSum = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            currentSum = max(nums[i], currentSum + nums[i]);\\n            maxSum = max(maxSum, currentSum);\\n        }\\n\\n        return maxSum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = nums[0];\\n        int currentSum = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            currentSum = Math.max(nums[i], currentSum + nums[i]);\\n            maxSum = Math.max(maxSum, currentSum);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = nums[0]\\n        currentSum = nums[0]\\n\\n        for num in nums[1:]:\\n            currentSum = max(num, currentSum + num)\\n            maxSum = max(maxSum, currentSum)\\n\\n        return maxSum\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/188f09ad-b402-49a2-88cc-daae4c8acbf2_1687364129.8941426.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = INT_MIN;\\n        int currentSum = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            currentSum += nums[i];\\n            \\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            \\n            if (currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int currentSum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            currentSum += nums[i];\\n            \\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            \\n            if (currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = float(\\'-inf\\')\\n        currentSum = 0\\n        \\n        for num in nums:\\n            currentSum += num\\n            \\n            if currentSum > maxSum:\\n                maxSum = currentSum\\n            \\n            if currentSum < 0:\\n                currentSum = 0\\n        \\n        return maxSum\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = nums[0];\\n        int currentSum = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            currentSum = max(nums[i], currentSum + nums[i]);\\n            maxSum = max(maxSum, currentSum);\\n        }\\n\\n        return maxSum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = nums[0];\\n        int currentSum = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            currentSum = Math.max(nums[i], currentSum + nums[i]);\\n            maxSum = Math.max(maxSum, currentSum);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = nums[0]\\n        currentSum = nums[0]\\n\\n        for num in nums[1:]:\\n            currentSum = max(num, currentSum + num)\\n            maxSum = max(maxSum, currentSum)\\n\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20189,
                "title": "simplest-and-fastest-o-n-c-solution",
                "content": "Idea is very simple. Basically, keep adding each integer to the sequence until the sum drops below 0. \\nIf sum is negative, then should reset the sequence.\\n\\n    class Solution {\\n    public:\\n        int maxSubArray(int A[], int n) {\\n            int ans=A[0],i,j,sum=0;\\n            for(i=0;i<n;i++){\\n                sum+=A[i];\\n                ans=max(sum,ans);\\n                sum=max(sum,0);\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxSubArray(int A[], int n) {\\n            int ans=A[0],i,j,sum=0;\\n            for(i=0;i<n;i++){\\n                sum+=A[i];\\n                ans=max(sum,ans);\\n                sum=max(sum,0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 20200,
                "title": "share-my-solutions-both-greedy-and-divide-and-conquer",
                "content": "**greedy:**\\n\\n    class Solution {\\n    public:\\n        int maxSubArray(int A[], int n) {\\n            int sum = 0, min = 0, res = A[0];\\n            for(int i = 0; i < n; i++) {\\n                sum += A[i];\\n                if(sum - min > res) res = sum - min;\\n                if(sum < min) min = sum;\\n            }\\n            return res;\\n        }\\n    };\\n\\nThe idea is to find the largest difference between the sums when you summing up the array from left to right. The largest difference corresponds to the sub-array with largest sum. I worked it out independently although It is very  close to lucastan's solution https://oj.leetcode.com/discuss/11288/simple-o-n-c-solution-no-dp-no-divide-and-conquer\\n\\n**divide and conquer:**\\n\\n    struct val {\\n        int l, m, r, s;\\n        val(int l, int m, int r, int s):l(l), m(m), r(r), s(s){}\\n    };\\n    \\n    class Solution {\\n    public:\\n        val dac(int A[], int n) {\\n            if(n == 1) return val(A[0], A[0], A[0], A[0]);\\n            val v1 = dac(A, n / 2), v2 = dac(A + n / 2, n - n / 2);\\n            int l, m, r, s;\\n            l = max(v1.l, v1.s + v2.l);\\n            m = max(v1.r + v2.l, max(v1.m, v2.m));\\n            r = max(v2.r, v1.r + v2.s);\\n            s = v1.s + v2.s;\\n            return val(l, m, r, s);\\n        }\\n        int maxSubArray(int A[], int n) {\\n            val v = dac(A, n);\\n            return v.m;\\n        }\\n    };\\n\\nthe idea is: for each sub array we calculate 4 values in O(1) time based on the return values of its two halves. The meaning of the values:\\n\\n - l: the sum of the sub array with largest sum starting from the  first\\n   element\\n - m: the sum of the sub array with largest sum\\n - r: the sum of the sub array with largest sum ending at the  last\\n   element\\n - s: the sum of the whole array\\n\\nthe recursive relation is clear in the code.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxSubArray(int A[], int n) {\\n            int sum = 0, min = 0, res = A[0];\\n            for(int i = 0; i < n; i++) {\\n                sum += A[i];\\n                if(sum - min > res) res = sum - min;\\n                if(sum < min) min = sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 898915,
                "title": "python-easy-solution-with-explanation-two-approaches-dp-with-and-without-table",
                "content": "####         At each index, keep track of the maximum sum using DP table , till that point\\n* ####             Save the maximum between [cur_value, max_so_far+cur_value]\\n* ####             Finally,  return the maximum out of the table\\n#### time O(n)\\n#### space O(n)\\n\\n```\\ndef maxSubArray(self, nums):\\n\\t\\tdp = [0]*len(nums)\\n        for i,num in enumerate(nums):            \\n            dp[i] = max(dp[i-1] + num, num)\\n        return max(dp)\\n```\\n#### To save space, implementation without using DP table \\n####         At each index, keep track of the maximum sum using variable (max_sum_until_i, and max_sum_sofar)\\n* ####             max_until_i = max (max_until_i, max_until_i+cur_value)\\n* ####             max_sum_sofar = max(max_until_i, max_sum_sofar,cur_value)\\n* #### Finally,  return the max_sum_sofar\\n#### time O(n)\\n#### space O(1)\\n```\\ndef maxSubArray(self, nums):\\n        max_sum_until_i = max_sum= nums[0]\\n        for i, num in enumerate(nums[1:],start=1):\\n            max_sum_until_i = max(max_sum_until_i+num, num)\\n            max_sum = max(max_sum,max_sum_until_i,max_sum)\\n        return max_sum\\n```\\n#### I hope you\\'ve found this helpful\\n##### Please upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03\\n##### PS: Search for Abeni tag in the discussion, if I have solved it, You will find a detial explanation there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxSubArray(self, nums):\\n\\t\\tdp = [0]*len(nums)\\n        for i,num in enumerate(nums):            \\n            dp[i] = max(dp[i-1] + num, num)\\n        return max(dp)\\n```\n```\\ndef maxSubArray(self, nums):\\n        max_sum_until_i = max_sum= nums[0]\\n        for i, num in enumerate(nums[1:],start=1):\\n            max_sum_until_i = max(max_sum_until_i+num, num)\\n            max_sum = max(max_sum,max_sum_until_i,max_sum)\\n        return max_sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2401258,
                "title": "very-easy-100-fully-explained-java-c-python-javascript-c-python3",
                "content": "# **Java Solution (Dynamic Programming Approach):**\\nRuntime: 1 ms, faster than 89.13% of Java online submissions for Maximum Subarray.\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        // Initialize currMaxSum & take first element of array from which we start to do sum...\\n        int maxSum = nums[0];\\n        // Initialize the current sum of our subarray as nums[0]...\\n        int currSum = nums[0];\\n        // Traverse all the element through the loop...\\n        for (int i = 1; i < nums.length; i++) {\\n            // Do sum of elements contigous with curr sum...\\n            // Compare it with array element to get maximum result...\\n            currSum = Math.max(currSum + nums[i], nums[i]);\\n            // Compare current sum and max sum.\\n            maxSum = Math.max(maxSum, currSum);\\n        }\\n        return maxSum;      // return the contiguous subarray which has the largest sum...\\n    }\\n}\\n```\\n\\n# **C++ Solution (Kadane\\u2019s approach):**\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        // Initialize maxSum as an integer that cannot store any value below the limit...\\n        int maxSum = INT_MIN;\\n        // Initialize maxSum...\\n        int maxSumSoFar = 0;\\n        // Traverse all the element through the loop...\\n        for(int i = 0; i < nums.size(); i++){\\n            // Keep adding the current value...\\n            maxSumSoFar += nums[i];\\n            // Update maxSum to maxSum and maxSumSoFar...\\n            if(maxSum < maxSumSoFar){\\n                maxSum = maxSumSoFar;\\n            }\\n            // if maxSumSoFar is less than 0 then update it to 0...\\n            if(maxSumSoFar < 0){\\n                maxSumSoFar = 0;\\n            }\\n        }\\n        return maxSum;      // Return the contiguous subarray which has the largest sum...\\n    }\\n};\\n```\\n\\n# **Python Solution (Dynamic Programming Approach):**\\nRuntime: 585 ms, faster than 95.18% of Python online submissions for Maximum Subarray.\\nMemory Usage: 25.3 MB, less than 97.76% of Python online submissions for Maximum Subarray.\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        # Create an array...\\n        arr = []\\n        arr.append(nums[0])\\n        # Initialize the max sum...\\n        maxSum = arr[0]\\n        # Traverse all the element through the loop...\\n        for i in range(1, len(nums)):\\n            # arr[i] represents the largest sum of all subarrays ending with index i...\\n            # then its value should be the larger one between nums[i]...\\n            # arr[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n            # calculate arr[0], arr[1]\\u2026, arr[n] while comparing each one with current largest sum...\\n            arr.append(max(arr[i-1] + nums[i], nums[i]))\\n            # if arr[i] > maxSum then maxSum = arr[i].\\n            if arr[i] > maxSum:\\n                maxSum = arr[i]\\n        return maxSum       # Return the contiguous subarray which has the largest sum...\\n```\\n                    \\n# **JavaScript Solution (Dynamic Programming Approach):**\\nRuntime: 103 ms, faster than 75.34% of JavaScript online submissions for Maximum Subarray.\\n```\\nvar maxSubArray = function(nums) {\\n    // Initialize the max sum...\\n    let maxSum = nums[0];\\n    // Traverse all the element through the loop...\\n    for (let i = 1; i < nums.length; i++) {\\n        // nums[i] represents the largest sum of all subarrays ending with index i...\\n        // then its value should be the larger one between nums[i]...\\n        // nums[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n        // calculate nums[0], nums[1]\\u2026, nums[n] while comparing each one with current largest sum...\\n        nums[i] = Math.max(0, nums[i - 1]) + nums[i];\\n        // if nums[i] > maxSum then maxSum = nums[i]...\\n        if (nums[i] > maxSum)\\n            maxSum = nums[i];\\n    }\\n    return maxSum;      // return the contiguous subarray which has the largest sum...\\n};\\n```\\n\\n# **C Language (Kadane\\u2019s approach):**\\n```\\nint maxSubArray(int* nums, int numsSize){\\n    // Initialize maxSum as an integer that cannot store any value below the limit...\\n    int maxSum = nums[0];\\n    // Initialize maxSum...\\n    int maxSumSoFar = 0;\\n    // Traverse all the element through the loop...\\n    for(int i = 0; i < numsSize; i++){\\n        // Keep adding the current value...\\n        maxSumSoFar += nums[i];\\n        // Update maxSum to maxSum and maxSumSoFar...\\n        if(maxSum < maxSumSoFar){\\n            maxSum = maxSumSoFar;\\n        }\\n        // if maxSumSoFar is less than 0 then update it to 0...\\n        if(maxSumSoFar < 0){\\n            maxSumSoFar = 0;\\n        }\\n    }\\n    return maxSum;      // Return the contiguous subarray which has the largest sum...\\n}\\n```\\n\\n# **Python3 Solution (Dynamic Programming Approach):**\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        # Create an array...\\n        arr = []\\n        arr.append(nums[0])\\n        # Initialize the max sum...\\n        maxSum = arr[0]\\n        for i in range(1, len(nums)):\\n            # arr[i] represents the largest sum of all subarrays ending with index i...\\n            # then its value should be the larger one between nums[i]...\\n            # arr[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n            # calculate arr[0], arr[1]\\u2026, arr[n] while comparing each one with current largest sum...\\n            arr.append(max(arr[i-1] + nums[i], nums[i]))\\n            # if arr[i] > maxSum then maxSum = arr[i].\\n            if arr[i] > maxSum:\\n                maxSum = arr[i]\\n        return maxSum       # Return the contiguous subarray which has the largest sum...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        // Initialize currMaxSum & take first element of array from which we start to do sum...\\n        int maxSum = nums[0];\\n        // Initialize the current sum of our subarray as nums[0]...\\n        int currSum = nums[0];\\n        // Traverse all the element through the loop...\\n        for (int i = 1; i < nums.length; i++) {\\n            // Do sum of elements contigous with curr sum...\\n            // Compare it with array element to get maximum result...\\n            currSum = Math.max(currSum + nums[i], nums[i]);\\n            // Compare current sum and max sum.\\n            maxSum = Math.max(maxSum, currSum);\\n        }\\n        return maxSum;      // return the contiguous subarray which has the largest sum...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        // Initialize maxSum as an integer that cannot store any value below the limit...\\n        int maxSum = INT_MIN;\\n        // Initialize maxSum...\\n        int maxSumSoFar = 0;\\n        // Traverse all the element through the loop...\\n        for(int i = 0; i < nums.size(); i++){\\n            // Keep adding the current value...\\n            maxSumSoFar += nums[i];\\n            // Update maxSum to maxSum and maxSumSoFar...\\n            if(maxSum < maxSumSoFar){\\n                maxSum = maxSumSoFar;\\n            }\\n            // if maxSumSoFar is less than 0 then update it to 0...\\n            if(maxSumSoFar < 0){\\n                maxSumSoFar = 0;\\n            }\\n        }\\n        return maxSum;      // Return the contiguous subarray which has the largest sum...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        # Create an array...\\n        arr = []\\n        arr.append(nums[0])\\n        # Initialize the max sum...\\n        maxSum = arr[0]\\n        # Traverse all the element through the loop...\\n        for i in range(1, len(nums)):\\n            # arr[i] represents the largest sum of all subarrays ending with index i...\\n            # then its value should be the larger one between nums[i]...\\n            # arr[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n            # calculate arr[0], arr[1]\\u2026, arr[n] while comparing each one with current largest sum...\\n            arr.append(max(arr[i-1] + nums[i], nums[i]))\\n            # if arr[i] > maxSum then maxSum = arr[i].\\n            if arr[i] > maxSum:\\n                maxSum = arr[i]\\n        return maxSum       # Return the contiguous subarray which has the largest sum...\\n```\n```\\nvar maxSubArray = function(nums) {\\n    // Initialize the max sum...\\n    let maxSum = nums[0];\\n    // Traverse all the element through the loop...\\n    for (let i = 1; i < nums.length; i++) {\\n        // nums[i] represents the largest sum of all subarrays ending with index i...\\n        // then its value should be the larger one between nums[i]...\\n        // nums[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n        // calculate nums[0], nums[1]\\u2026, nums[n] while comparing each one with current largest sum...\\n        nums[i] = Math.max(0, nums[i - 1]) + nums[i];\\n        // if nums[i] > maxSum then maxSum = nums[i]...\\n        if (nums[i] > maxSum)\\n            maxSum = nums[i];\\n    }\\n    return maxSum;      // return the contiguous subarray which has the largest sum...\\n};\\n```\n```\\nint maxSubArray(int* nums, int numsSize){\\n    // Initialize maxSum as an integer that cannot store any value below the limit...\\n    int maxSum = nums[0];\\n    // Initialize maxSum...\\n    int maxSumSoFar = 0;\\n    // Traverse all the element through the loop...\\n    for(int i = 0; i < numsSize; i++){\\n        // Keep adding the current value...\\n        maxSumSoFar += nums[i];\\n        // Update maxSum to maxSum and maxSumSoFar...\\n        if(maxSum < maxSumSoFar){\\n            maxSum = maxSumSoFar;\\n        }\\n        // if maxSumSoFar is less than 0 then update it to 0...\\n        if(maxSumSoFar < 0){\\n            maxSumSoFar = 0;\\n        }\\n    }\\n    return maxSum;      // Return the contiguous subarray which has the largest sum...\\n}\\n```\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        # Create an array...\\n        arr = []\\n        arr.append(nums[0])\\n        # Initialize the max sum...\\n        maxSum = arr[0]\\n        for i in range(1, len(nums)):\\n            # arr[i] represents the largest sum of all subarrays ending with index i...\\n            # then its value should be the larger one between nums[i]...\\n            # arr[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n            # calculate arr[0], arr[1]\\u2026, arr[n] while comparing each one with current largest sum...\\n            arr.append(max(arr[i-1] + nums[i], nums[i]))\\n            # if arr[i] > maxSum then maxSum = arr[i].\\n            if arr[i] > maxSum:\\n                maxSum = arr[i]\\n        return maxSum       # Return the contiguous subarray which has the largest sum...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785522,
                "title": "python-3-91-63-faster-single-pass-algo-explanation-added",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nMy approaches to solve this problem evolved like this:\\n**1. Approach 1:** Using 2 for loops\\n   Starting from index i, start adding the numbers and record the maximum sum with all the next elements.\\n   Doing this for every i element (n-i) times will cause time complexity to become O(n^2).\\n   \\n**2. Approach 2**: Let\\'s create another list that can store the maximum of total or nums[i]. Here total = (previous num + nums[i]).\\n   Then to find the maximum of all the sums, we\\'ll have to traverse the list and return the maximum. This was O(n) time and O(n) space.\\n   \\n**3. Approach 3:** In above approach, we stored maximum total until nums[i] and then found the maximum subarray total in the end. We aren\\'t doing anything good with the new list because in the end we are traversing the list to find the maximum total. So, eliminate creating new list and start tracking the new sum and maximum number. This becomes O(n) time and O(1) space\\n\\n```\\ndef maxSubArray(self, nums: List[int]) -> int:        \\n\\tnewNum = maxTotal = nums[0]        \\n\\t\\n\\tfor i in range(1, len(nums)):\\n\\t\\tnewNum = max(nums[i], nums[i] + newNum)\\n\\t\\tmaxTotal = max(newNum, maxTotal)\\n\\n\\treturn maxTotal\\t\\n```\\n\\n**If above solution was helpful, please upvote it for it to reach others**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\ndef maxSubArray(self, nums: List[int]) -> int:        \\n\\tnewNum = maxTotal = nums[0]        \\n\\t\\n\\tfor i in range(1, len(nums)):\\n\\t\\tnewNum = max(nums[i], nums[i] + newNum)\\n\\t\\tmaxTotal = max(newNum, maxTotal)\\n\\n\\treturn maxTotal\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 199163,
                "title": "python-o-n-divide-and-conquer-solution-with-explanations",
                "content": "```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def divide_and_conquer(nums, i, j):\\n            if i == j-1:\\n                return nums[i],nums[i],nums[i],nums[i]\\n            \\n            # we will compute :\\n            # a which is max contiguous sum in nums[i:j] including the first value\\n            # m which is max contiguous sum in nums[i:j] anywhere \\n            # b which is max contiguous sum in nums[i:j] including the last value\\n            # s which is the sum of all values in nums[i:j]\\n                \\n            # compute middle index to divide array in two halves\\n            i_mid = i+(j-i)//2\\n            \\n            # compute a, m, b, s for left half\\n            a1, m1, b1, s1 = divide_and_conquer(nums, i, i_mid)\\n            \\n            # compute a, m, b, s for right half\\n            a2, m2, b2, s2 = divide_and_conquer(nums, i_mid, j)\\n            \\n            # combine a, m, b, s values from left and right halves to form a, m, b, s for whole array (bottom up)\\n            a = max(a1, s1+a2)\\n            b = max(b2, s2+b1)\\n            m = max(m1,m2,b1+a2)\\n            s = s1+s2\\n            return a,m,b,s\\n                  \\n        _,m,_,_ = divide_and_conquer(nums, 0, len(nums))\\n        return m\\n```\\nEach call to divide_and_conquer takes O(1) time and there are O(N) calls thus global time complexity is O(N).",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def divide_and_conquer(nums, i, j):\\n            if i == j-1:\\n                return nums[i],nums[i],nums[i],nums[i]\\n            \\n            # we will compute :\\n            # a which is max contiguous sum in nums[i:j] including the first value\\n            # m which is max contiguous sum in nums[i:j] anywhere \\n            # b which is max contiguous sum in nums[i:j] including the last value\\n            # s which is the sum of all values in nums[i:j]\\n                \\n            # compute middle index to divide array in two halves\\n            i_mid = i+(j-i)//2\\n            \\n            # compute a, m, b, s for left half\\n            a1, m1, b1, s1 = divide_and_conquer(nums, i, i_mid)\\n            \\n            # compute a, m, b, s for right half\\n            a2, m2, b2, s2 = divide_and_conquer(nums, i_mid, j)\\n            \\n            # combine a, m, b, s values from left and right halves to form a, m, b, s for whole array (bottom up)\\n            a = max(a1, s1+a2)\\n            b = max(b2, s2+b1)\\n            m = max(m1,m2,b1+a2)\\n            s = s1+s2\\n            return a,m,b,s\\n                  \\n        _,m,_,_ = divide_and_conquer(nums, 0, len(nums))\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227063,
                "title": "kadane-s-algo-o-n-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem:\\nWe can solve this problem using **Kadane\\'s Algorithm**\\n\\n**LETS DRY RUN THIS CODE WITH ONE EXAPMPLE :**\\n\\nSuppose we have the following input vector: **[-2, 1, -3, 4, -1, 2, 1, -5, 4].**\\n\\nWe initialize the maximumSum = INT_MIN (-2147483648) and currSumSubarray = 0.\\n\\nWe loop through the input vector and perform the following operations:\\n\\nAt the first iteration, currSumSubarray becomes -2 and since it is less than 0, we set it to 0. maximumSum remains at INT_MIN.\\n\\nAt the second iteration, currSumSubarray becomes 1, which is greater than 0, so we keep it as it is. We update maximumSum to 1.\\n\\nAt the third iteration, currSumSubarray becomes -2, which is less than 0, so we set it to 0. maximumSum remains at 1.\\n\\nAt the fourth iteration, currSumSubarray becomes 4, which is greater than 0, so we keep it as it is. We update maximumSum to 4.\\n\\nAt the fifth iteration, currSumSubarray becomes 3, which is greater than 0, so we keep it as it is. maximumSum remains at 4.\\n\\nAt the sixth iteration, currSumSubarray becomes 5, which is greater than 0, so we keep it as it is. We update maximumSum to 5.\\n\\nAt the seventh iteration, currSumSubarray becomes 6, which is greater than 0, so we keep it as it is. We update maximumSum to 6.\\n\\nAt the eighth iteration, currSumSubarray becomes 1, which is greater than 0, so we keep it as it is. maximumSum remains at 6.\\n\\nAt the ninth iteration, currSumSubarray becomes 5, which is greater than 0, so we keep it as it is. maximumSum remains at 6.\\n\\nAfter iterating through the input vector, we return maximumSum which is equal to 6. Therefore, the maximum sum subarray of the given input vector is [4, -1, 2, 1], and the sum of this subarray is 6.\\n\\n\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Initialize two variables, maximumSum and currSumSubarray to the minimum integer value (INT_MIN) and 0, respectively.\\n2. Loop through the array from index 0 to n-1, where n is the size of the array.\\n3. In each iteration, add the current element of the array to the currSumSubarray variable.\\n4. Take the maximum between maximumSum and currSumSubarray and store it in the maximumSum variable.\\n5. Take the maximum between currSumSubarray and 0 and store it in currSumSubarray. This is done because if the currSumSubarray becomes negative, it means that we should start a new subarray, so we reset currSumSubarray to 0.\\n6. After the loop ends, return the maximumSum variable, which contains the maximum sum of a subarray.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        //maximumSum will calculate our ans and currSumSubarray will calculate maximum sum subarray till ith position \\n        int maximumSum = INT_MIN, currSumSubarray = 0;\\n        for (int i = 0; i < n; i++) {\\n            currSumSubarray += nums[i]; \\n            maximumSum = max(maximumSum, currSumSubarray);\\n            //here we are taking max with 0 bcz if currSumSubarray = -1 or any negative value then it again starts with currSumSubarray = 0\\n            currSumSubarray = max(currSumSubarray, 0);\\n        } \\n        return maximumSum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int n = nums.length;\\n        int maximumSum = Integer.MIN_VALUE, currSumSubarray = 0;\\n        for (int i = 0; i < n; i++) {\\n            currSumSubarray += nums[i]; \\n            maximumSum = Math.max(maximumSum, currSumSubarray);\\n            currSumSubarray = Math.max(currSumSubarray, 0);\\n        } \\n        return maximumSum;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        maximumSum, currSumSubarray = float(\\'-inf\\'), 0\\n        for i in range(n):\\n            currSumSubarray += nums[i]\\n            maximumSum = max(maximumSum, currSumSubarray)\\n            currSumSubarray = max(currSumSubarray, 0)\\n        return maximumSum\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the size of the input array. The algorithm has to loop through the array only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, since the algorithm is using only a constant amount of extra space regardless of the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        //maximumSum will calculate our ans and currSumSubarray will calculate maximum sum subarray till ith position \\n        int maximumSum = INT_MIN, currSumSubarray = 0;\\n        for (int i = 0; i < n; i++) {\\n            currSumSubarray += nums[i]; \\n            maximumSum = max(maximumSum, currSumSubarray);\\n            //here we are taking max with 0 bcz if currSumSubarray = -1 or any negative value then it again starts with currSumSubarray = 0\\n            currSumSubarray = max(currSumSubarray, 0);\\n        } \\n        return maximumSum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int n = nums.length;\\n        int maximumSum = Integer.MIN_VALUE, currSumSubarray = 0;\\n        for (int i = 0; i < n; i++) {\\n            currSumSubarray += nums[i]; \\n            maximumSum = Math.max(maximumSum, currSumSubarray);\\n            currSumSubarray = Math.max(currSumSubarray, 0);\\n        } \\n        return maximumSum;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        maximumSum, currSumSubarray = float(\\'-inf\\'), 0\\n        for i in range(n):\\n            currSumSubarray += nums[i]\\n            maximumSum = max(maximumSum, currSumSubarray)\\n            currSumSubarray = max(currSumSubarray, 0)\\n        return maximumSum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405559,
                "title": "easy-understand-java-solutions-with-explanations-b-f-divide-and-conquer-dp",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/maximum-subarray/)\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n## Problem\\n\\n> Given an integer array `nums`, find the contiguous subarray (**containing at least one number**) which has the largest sum and return its sum.\\n\\n\\n**Example:** \\n\\n```java\\nInput: [-5]\\nOutput: -5\\n\\nInput: [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: [4,-1,2,1] has the largest sum = 6.\\n```\\n\\n**Follow up:** If you have figured out the `O(N)` solution, try coding another solution using the divide and conquer approach, which is more subtle.\\n\\n\\n\\n\\n## Analysis\\n\\n### Most Stupid Solution\\n\\nFor each element, we construct all possible subarrays starting from this element. Totally there are at most `N^2` subarrays. Also, calculating the sum of each subarray takes `O(N)`.\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int maxSum = Integer.MIN_VALUE;\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      int sum = 0;\\n      for (int k = i; k <= j; ++k) {\\n        sum += nums.get(k);\\n      }\\n      maxSum = Math.max(maxSum, sum);\\n    }\\n  }\\n  return maxSum;\\n}\\n```\\n\\n**Time:** `O(N^3)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Brute-Force\\n\\nWhy did you calculate the sum separately?\\n\\n**Note:** In the inner loop, start from `i + 1`. Don\\'t initialize `sum` as `0` and start from `i`.\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int maxSum = Integer.MIN_VALUE; // can\\'t be 0\\n  for (int i = 0; i < n; ++i) { // starts at i\\n    int sum = nums[i];\\n    maxSum = Math.max(maxSum, sum);\\n    for (int j = i + 1; j < n; ++j) { // starts from the next element\\n      sum += nums[j];\\n      maxSum = Math.max(maxSum, sum);\\n    }\\n  }\\n  return maxSum;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Divide and Conquer\\n\\nDivide-and-conquer consider 3 cases:\\n\\n- **Case 1:** Subarray in the left half -> `leftSum`\\n- **Case 2:** Subarray in the right half -> `rightSum`\\n- **Case 3:** Subarray crosses the middle -> `crossSum`\\n\\nWe need to compare three max values: `leftSum`, `rightSum`, and `crossSum`. By constructing the `crossSum`, we propagate from the right-end of the left subarray `[lo, mid]` and from the left-end of the right subarray `[mid + 1, hi]`. In each direction, we are continuously updating the maximum sum.\\n\\n```java\\n// Example\\nindex: 0  1  2  3  4  5  6\\n      -5  7  3 -1  1  2  3\\n               mid\\nFor the left half, we go through from -1 to -5. The maximum sum is (-1) + 3 + 7 = 9.\\nIt can\\'t be 3 + 7 = 10, because -1 must be included (crossing).\\n```\\n\\n**BTW, Index lo/hi/mid Caveat:** (skip it. Just my person notes~)\\n\\nWrite the condition as `if (lo == hi)` (stops at one element) or `if (lo >= hi)` (stops at `0` element). Why?\\n\\nWrite the subproblem as `[lo, mid]` and `[mid + 1, hi]`, which is not like binary search (`hi = mid - 1` and `lo = mid + 1`).\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/vtoj4.jpg)\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  return maxSubArray(nums, 0, n - 1);\\n}\\n\\nprivate int maxSubArray(int[] nums, int lo, int hi) {\\n  if (lo == hi) { // base case: one number\\n    return nums[lo];\\n  }\\n  // divide\\n  int mid = lo + (hi - lo) / 2;\\n  // conquer\\n  int leftSum = maxSubArray(nums, lo, mid);\\n  int rightSum = maxSubArray(nums, mid + 1, hi);\\n  // combine\\n  int crossSum = crossSum(nums, lo, hi);\\n  return Math.max(crossSum, Math.max(leftSum, rightSum));\\n}\\n\\n// invariant: lo < hi (left part and right part both have at least 1 element\\nprivate int crossSum(int[] nums, int lo, int hi) {\\n  int mid = lo + (hi - lo) / 2;\\n  // left\\n  int leftSum = 0, leftMax = Integer.MIN_VALUE; // the invariant means that leftMax and rightMax will be updated\\n  for (int i = mid; i >= lo; --i) {\\n    leftSum += nums[i];\\n    leftMax = Math.max(leftMax, leftSum);\\n  }\\n  // right\\n  int rightSum = 0, rightMax = Integer.MIN_VALUE;\\n  for (int i = mid + 1; i <= hi; ++i) {\\n    rightSum += nums[i];\\n    rightMax = Math.max(rightMax, rightSum);\\n  }\\n  return leftMax + rightMax;\\n}\\n```\\n\\nAnother version, initialize sums and max values as the first element.\\n\\n```java\\nprivate int crossSum(int[] nums, int lo, int hi, int mid) {\\n  // left\\n  int leftSum = nums[mid]; // okay because 0 <= lo <= mid < hi <= n - 1\\n  int leftMax = leftSum;\\n  for (int i = mid - 1; i >= lo; --i) {\\n    leftSum += nums[i];\\n    leftMax = Math.max(leftMax, leftSum);\\n  }\\n  // right\\n  int rightSum = nums[mid + 1]; // lo < hi is guaranteed\\n  int rightMax = rightSum;\\n  for (int i = mid + 2; i <= hi; ++i) {\\n    rightSum += nums[i];\\n    rightMax = Math.max(rightMax, rightSum);\\n  }\\n  return leftMax + rightMax;\\n}\\n```\\n\\n**Time:** `O(N\\\\log{N})` since `T(N) = 2T(N/2) + O(N)`.\\n**Space:** `O(\\\\log{N})`\\n\\n\\n\\n### DP\\n\\nSuppose we know the maximum subarray ending at `i` (inclusive). We denote `SUM(i)` as the maximum sum of a subarray ending at index `i` and denote `OPT(i)` as the maximum sum in the subarray `[0, i]`. Our final result is `OPT(n - 1)`. (notice the difference since it is very trivial)\\n\\nFor an element `nums[i]`, we have two choices: Appending it to a previous subarray `SUM(i - 1)` or start a new subarray from itself. Then we can write the recurrence for `SUM(i)` and `OPT(i)` as follows:\\n\\n`SUM(i)` = max(`SUM(i - 1) + nums[i]`, `nums[i]`)\\n`OPT(i)` = max(`OPT(i - 1)`, `SUM(i)`).\\n\\nNote: `OPT` is updated when a larger `SUM[i]` is discovered.\\n\\nThe initial values are `SUM(0) = nums[0]` and `OPT(0) = nums[0]`. We can do it in one pass. So here is the code:\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int[] SUM = new int[n];\\n  int[] OPT = new int[n];\\n  SUM[0] = nums[0]; // init\\n  OPT[0] = nums[0];\\n  for (int i = 1; i < n; ++i) {\\n    SUM[i] = Math.max(SUM[i - 1] + nums[i], nums[i]);\\n    OPT[i] = Math.max(OPT[i - 1], SUM[i]);\\n  }\\n  return OPT[n - 1];\\n}\\n```\\n\\nSince `SUM(i)` and `OPT(i)` could be calculated by the previous values, we don\\'t need arrays of size `n` to store all information. Here is the code that reduces the space complexity:\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int SUM = nums[0];\\n  int OPT = nums[0];\\n  for (int i = 1; i < n; ++i) {\\n    SUM = Math.max(SUM + nums[i], nums[i]);\\n    OPT = Math.max(OPT, SUM);\\n  }\\n  return OPT;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: [-5]\\nOutput: -5\\n\\nInput: [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: [4,-1,2,1] has the largest sum = 6.\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int maxSum = Integer.MIN_VALUE;\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      int sum = 0;\\n      for (int k = i; k <= j; ++k) {\\n        sum += nums.get(k);\\n      }\\n      maxSum = Math.max(maxSum, sum);\\n    }\\n  }\\n  return maxSum;\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int maxSum = Integer.MIN_VALUE; // can\\'t be 0\\n  for (int i = 0; i < n; ++i) { // starts at i\\n    int sum = nums[i];\\n    maxSum = Math.max(maxSum, sum);\\n    for (int j = i + 1; j < n; ++j) { // starts from the next element\\n      sum += nums[j];\\n      maxSum = Math.max(maxSum, sum);\\n    }\\n  }\\n  return maxSum;\\n}\\n```\n```java\\n// Example\\nindex: 0  1  2  3  4  5  6\\n      -5  7  3 -1  1  2  3\\n               mid\\nFor the left half, we go through from -1 to -5. The maximum sum is (-1) + 3 + 7 = 9.\\nIt can\\'t be 3 + 7 = 10, because -1 must be included (crossing).\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  return maxSubArray(nums, 0, n - 1);\\n}\\n\\nprivate int maxSubArray(int[] nums, int lo, int hi) {\\n  if (lo == hi) { // base case: one number\\n    return nums[lo];\\n  }\\n  // divide\\n  int mid = lo + (hi - lo) / 2;\\n  // conquer\\n  int leftSum = maxSubArray(nums, lo, mid);\\n  int rightSum = maxSubArray(nums, mid + 1, hi);\\n  // combine\\n  int crossSum = crossSum(nums, lo, hi);\\n  return Math.max(crossSum, Math.max(leftSum, rightSum));\\n}\\n\\n// invariant: lo < hi (left part and right part both have at least 1 element\\nprivate int crossSum(int[] nums, int lo, int hi) {\\n  int mid = lo + (hi - lo) / 2;\\n  // left\\n  int leftSum = 0, leftMax = Integer.MIN_VALUE; // the invariant means that leftMax and rightMax will be updated\\n  for (int i = mid; i >= lo; --i) {\\n    leftSum += nums[i];\\n    leftMax = Math.max(leftMax, leftSum);\\n  }\\n  // right\\n  int rightSum = 0, rightMax = Integer.MIN_VALUE;\\n  for (int i = mid + 1; i <= hi; ++i) {\\n    rightSum += nums[i];\\n    rightMax = Math.max(rightMax, rightSum);\\n  }\\n  return leftMax + rightMax;\\n}\\n```\n```java\\nprivate int crossSum(int[] nums, int lo, int hi, int mid) {\\n  // left\\n  int leftSum = nums[mid]; // okay because 0 <= lo <= mid < hi <= n - 1\\n  int leftMax = leftSum;\\n  for (int i = mid - 1; i >= lo; --i) {\\n    leftSum += nums[i];\\n    leftMax = Math.max(leftMax, leftSum);\\n  }\\n  // right\\n  int rightSum = nums[mid + 1]; // lo < hi is guaranteed\\n  int rightMax = rightSum;\\n  for (int i = mid + 2; i <= hi; ++i) {\\n    rightSum += nums[i];\\n    rightMax = Math.max(rightMax, rightSum);\\n  }\\n  return leftMax + rightMax;\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int[] SUM = new int[n];\\n  int[] OPT = new int[n];\\n  SUM[0] = nums[0]; // init\\n  OPT[0] = nums[0];\\n  for (int i = 1; i < n; ++i) {\\n    SUM[i] = Math.max(SUM[i - 1] + nums[i], nums[i]);\\n    OPT[i] = Math.max(OPT[i - 1], SUM[i]);\\n  }\\n  return OPT[n - 1];\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int SUM = nums[0];\\n  int OPT = nums[0];\\n  for (int i = 1; i < n; ++i) {\\n    SUM = Math.max(SUM + nums[i], nums[i]);\\n    OPT = Math.max(OPT, SUM);\\n  }\\n  return OPT;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336498,
                "title": "simple-java-1ms-beats-100-easy-to-understand-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# ***simple sliding window approach***\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# ***simple sliding window approach***\\n# Complexity\\n# ***- Time complexity: O(n)***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# ***- Space complexity: O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0 , maxi = Integer.MIN_VALUE;;\\n        int i = 0 , j = 0;\\n        while(j<nums.length){\\n           \\n            if(sum < 0 && nums[j] >= sum){\\n                sum = 0;\\n                i = j;\\n            }\\n             sum += nums[j];\\n            maxi = Math.max(maxi , sum);\\n            j++;\\n        }\\n        return maxi;\\n    }\\n}\\n```\\n**If this solution helped you, give it an up-vote to help others**![download.jfif](https://assets.leetcode.com/users/images/ebeb56c7-dcb5-4061-8db1-be85a2c2dce8_1679675105.9124558.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0 , maxi = Integer.MIN_VALUE;;\\n        int i = 0 , j = 0;\\n        while(j<nums.length){\\n           \\n            if(sum < 0 && nums[j] >= sum){\\n                sum = 0;\\n                i = j;\\n            }\\n             sum += nums[j];\\n            maxi = Math.max(maxi , sum);\\n            j++;\\n        }\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411166,
                "title": "c-brute-force-to-optimal-3-solutions-easy-to-understand",
                "content": "**Approach 1 - TC: O(n3) TLE** \\nRun three loops,  get all possible subarrays in two loops and their sum in another loop, then return the maximum of them.\\n         \\n**Approach 2- TC: O(n2)**\\nIf we optimise the above approach, we can get sum of all possible subarrays in two loops only, then return the maximum so far.\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            int curr_sum = 0;\\n            for(int j=i; j<nums.size(); j++){\\n                curr_sum += nums[j];\\n                //cout<<curr_sum<<endl;\\n                max_sum = max(max_sum, curr_sum);\\n            }\\n        }\\n    return max_sum;\\n    }\\n};\\n```\\n\\n**Approach 3 Kadane Algorithm - TC: O(n)**\\nUsing this approach we can get the maximum sum of subarray in just O(n) time complexity.\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int MAX = INT_MIN;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            MAX = max(sum, MAX);\\n            if(sum < 0) sum = 0;\\n        }\\n        return MAX;\\n    }\\n};\\n```\\n\\nThanks, upvote if you liked it. Comment down below if you have any doubts or suggestions.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            int curr_sum = 0;\\n            for(int j=i; j<nums.size(); j++){\\n                curr_sum += nums[j];\\n                //cout<<curr_sum<<endl;\\n                max_sum = max(max_sum, curr_sum);\\n            }\\n        }\\n    return max_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int MAX = INT_MIN;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            MAX = max(sum, MAX);\\n            if(sum < 0) sum = 0;\\n        }\\n        return MAX;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 20471,
                "title": "javascript-solution",
                "content": "    function maxSubArray(A) {\\n      var prev = 0;\\n      var max = -Number.MAX_VALUE;\\n    \\n      for (var i = 0; i < A.length; i++) {\\n        prev = Math.max(prev + A[i], A[i]);\\n        max = Math.max(max, prev);\\n      }\\n      return max;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function maxSubArray(A) {\\n      var prev = 0;\\n      var max = -Number.MAX_VALUE;\\n    \\n      for (var i = 0; i < A.length; i++) {\\n        prev = Math.max(prev + A[i], A[i]);\\n        max = Math.max(max, prev);\\n      }\\n      return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3169660,
                "title": "best-c-4-solution-dp-divide-and-conquer-kadane-s-algorithm-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches.\\n\\n1. Solved using Array(Two Nested Loops). Brute Force Approach.\\n2. Solved using Array + Divide and Conquer.\\n3. Solved using Dynamic Programming Approach(tabulation).\\n4. Solved using Kadane\\u2019s Algorithm. Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the array. Here total number of iterations are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maximumSumSubarray = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int currSum = 0;\\n            for(int j=i; j<n; j++){\\n                currSum += nums[j];\\n                if(currSum > maximumSumSubarray){\\n                    maximumSumSubarray = currSum;\\n                }\\n            }\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), One linear scans of length N and Each recursive call to performs two recursive\\n    calls on subslices of size N/2. Therefore, the time complexity of the divide & conquer approach can be\\n    represented by the following recurrence relation: T(N)=2T(N/2)+N. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(logN), Recursion Stack Space. \\n\\n    Solved using Array + Divide and Conquer.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int maxSubArray(vector<int>& nums, int low, int high){\\n        if(low == high){\\n            return nums[low];\\n        }\\n        int leftMaxSumSubarray = INT_MIN, rightMaxSumSubarray = INT_MIN;\\n\\n        int mid = (low + high) >> 1;\\n        int currSum = 0;\\n        for(int i=mid; i>=low; i--){\\n            currSum += nums[i];\\n            leftMaxSumSubarray = max(leftMaxSumSubarray, currSum);\\n        }\\n\\n        currSum = 0;\\n        for(int i=mid+1; i<=high; i++){\\n            currSum += nums[i];\\n            rightMaxSumSubarray = max(rightMaxSumSubarray, currSum);\\n        }\\n\\n        int maxSumSubarray =  leftMaxSumSubarray +  rightMaxSumSubarray;\\n        int leftAnsSum = maxSubArray(nums, low, mid);\\n        int rightAnsSum = maxSubArray(nums, mid+1, high);\\n\\n        return max(maxSumSubarray, max(leftAnsSum, rightAnsSum));\\n    }\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, nums.size()-1);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N). Where N is the size of the Array(nums).\\n    Space Complexity : O(N), Array(dp) space.\\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = nums[0];\\n        int maximumSumSubarray = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i] = nums[i] + (dp[i-1] > 0 ? dp[i-1] : 0);\\n            maximumSumSubarray = max(maximumSumSubarray, dp[i]);\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Since we traversed the array(nums) only ones. Where N is the size of the nums.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Kadane\\u2019s Algorithm.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currSum = 0, maximumSumSubarray = INT_MIN;\\n        for(auto num : nums){\\n            currSum += num;\\n            if(currSum > maximumSumSubarray){\\n                maximumSumSubarray = currSum;\\n            }\\n            if(currSum < 0){\\n                currSum = 0;\\n            }\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the array. Here total number of iterations are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maximumSumSubarray = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int currSum = 0;\\n            for(int j=i; j<n; j++){\\n                currSum += nums[j];\\n                if(currSum > maximumSumSubarray){\\n                    maximumSumSubarray = currSum;\\n                }\\n            }\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), One linear scans of length N and Each recursive call to performs two recursive\\n    calls on subslices of size N/2. Therefore, the time complexity of the divide & conquer approach can be\\n    represented by the following recurrence relation: T(N)=2T(N/2)+N. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(logN), Recursion Stack Space. \\n\\n    Solved using Array + Divide and Conquer.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int maxSubArray(vector<int>& nums, int low, int high){\\n        if(low == high){\\n            return nums[low];\\n        }\\n        int leftMaxSumSubarray = INT_MIN, rightMaxSumSubarray = INT_MIN;\\n\\n        int mid = (low + high) >> 1;\\n        int currSum = 0;\\n        for(int i=mid; i>=low; i--){\\n            currSum += nums[i];\\n            leftMaxSumSubarray = max(leftMaxSumSubarray, currSum);\\n        }\\n\\n        currSum = 0;\\n        for(int i=mid+1; i<=high; i++){\\n            currSum += nums[i];\\n            rightMaxSumSubarray = max(rightMaxSumSubarray, currSum);\\n        }\\n\\n        int maxSumSubarray =  leftMaxSumSubarray +  rightMaxSumSubarray;\\n        int leftAnsSum = maxSubArray(nums, low, mid);\\n        int rightAnsSum = maxSubArray(nums, mid+1, high);\\n\\n        return max(maxSumSubarray, max(leftAnsSum, rightAnsSum));\\n    }\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, nums.size()-1);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N). Where N is the size of the Array(nums).\\n    Space Complexity : O(N), Array(dp) space.\\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = nums[0];\\n        int maximumSumSubarray = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i] = nums[i] + (dp[i-1] > 0 ? dp[i-1] : 0);\\n            maximumSumSubarray = max(maximumSumSubarray, dp[i]);\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Since we traversed the array(nums) only ones. Where N is the size of the nums.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Kadane\\u2019s Algorithm.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currSum = 0, maximumSumSubarray = INT_MIN;\\n        for(auto num : nums){\\n            currSum += num;\\n            if(currSum > maximumSumSubarray){\\n                maximumSumSubarray = currSum;\\n            }\\n            if(currSum < 0){\\n                currSum = 0;\\n            }\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364839,
                "title": "divide-conquer-commented-explanation-and-big-o-js",
                "content": "It took me a while to understand the divide and conquer approach because the solutions I was seeing didn\\'t have much explanation, rarely had code comments, and had cryptic variable names. I\\'ve added extensive comments below and more descriptive variable names. Let me know of any improvements to the explanations!\\n\\nTime complexity seems to be O(n * log(n)) based on case 2 of the Master Theorem: T(n) = a T(n/b) + f(n). Plus, it follows the pattern of merge sort, which can be analyzed in the same way and is O(n * log(n)). Resources for understanding the Master Theorem:\\nhttps://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\\nhttps://www.youtube.com/watch?v=6CX7s7JnXs0\\n```\\nvar maxSubArray = function(nums) {\\n\\t// Return the results of the recursive function\\n    return findMaxSumInArr(nums);\\n    \\n\\t// Recursive function that will divide and conquer to find the maximum sum from a subarray of the array provided as a parameter\\n    function findMaxSumInArr(arr){\\n        // BASE CASES: \\n        // if there is only one arr item, then you can simply return that value\\n        if (arr.length === 1){\\n            return arr[0];\\n        }\\n\\t\\t\\n        /* if there isn\\'t an arr item, then return -Infinity (we need a valid number for the calculations below. \\n\\t\\tSince JS can only store numbers > -Infinity, -Infinity will never be the max) */\\n        if (arr.length === 0){\\n            return -Infinity;\\n        }\\n        \\n\\t\\t// Declare zero-indexed length and midpoint\\n        let length = arr.length - 1;\\n        let mid = Math.floor( length/2 );\\n        \\n        // DIVIDE: Recursively find max sum in the left and right sub arrays\\n        let lMaxSumInSubArr = findMaxSumInArr( arr.slice(0, mid) );\\n        let rMaxSumInSubArr = findMaxSumInArr( arr.slice(mid + 1, length + 1) );\\n        \\n        /* MERGE: The divide step gave use the max sum on the left and right side, but we still need to account\\n\\t\\tfor the possibility of a contiguous array that goes from left to right through the midpoint */\\n\\t\\t\\n        // Declare variables to record the maximum contiguous sums for each side\\n        let lMaxContiguousSum = 0,\\n            rMaxContiguousSum = 0;\\n        \\n        // On the left side, find sum of contiguous array and keep an updated record of the maximum\\n        /* (NOTE: in order to account for contiguous arrays that traverse the midpoint, start the search from\\n\\t\\tthe midpoint - 1 index and traverse leftwards towards index 0. This directionality guarantees that\\n\\t\\ta contiguous array traversing the midpoint will be able to add the midpoint itself and the right side\\'s\\n\\t\\tcontiguous arr [this is exactly what is checked in the final return statement below]) */\\n        for (let i = mid - 1, currContiguousSum = 0; i >= 0; i--){\\n            currContiguousSum += arr[i];\\n            lMaxContiguousSum = Math.max(lMaxContiguousSum, currContiguousSum);\\n        }\\n       \\n        // On the left side, find sum of contiguous array and keep an updated record of the maximum\\n        /* (NOTE: in accordance with the last note, to account for sub arrays that traverse the midpoint, \\n\\t\\tstart the search from the midpoint + 1 index and traverse rightwards */\\n        for (let i = mid + 1, currContiguousSum = 0; i <= length; i++){\\n            currContiguousSum += arr[i];\\n            rMaxContiguousSum = Math.max(rMaxContiguousSum, currContiguousSum);\\n        }\\n        \\n        /* RETURN the max sum from the current array: either from the left side, right side, or a contiguous\\n\\t\\tsub arrary traversing from left to right through the midpoint */\\n        return Math.max(\\n            // The maximum sum from a contiguous subarray that traverses the midpoint\\n            lMaxContiguousSum + arr[mid] + rMaxContiguousSum, \\n            // The max sum from each side (whether it was a single value or a contiguous sum) \\n            lMaxSumInSubArr, \\n            rMaxSumInSubArr  \\n        );\\n    }\\n}\\n```\\n\\nExtra Notes:\\n- For the divide step, slicing the array made the most sense to me, but you could also keep the original array unaltered and simply update left and right bounds (this would necessitate changing code throughout the function, like the initial base cases would have to check for ```left === right``` and `left > right` respectively)",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n\\t// Return the results of the recursive function\\n    return findMaxSumInArr(nums);\\n    \\n\\t// Recursive function that will divide and conquer to find the maximum sum from a subarray of the array provided as a parameter\\n    function findMaxSumInArr(arr){\\n        // BASE CASES: \\n        // if there is only one arr item, then you can simply return that value\\n        if (arr.length === 1){\\n            return arr[0];\\n        }\\n\\t\\t\\n        /* if there isn\\'t an arr item, then return -Infinity (we need a valid number for the calculations below. \\n\\t\\tSince JS can only store numbers > -Infinity, -Infinity will never be the max) */\\n        if (arr.length === 0){\\n            return -Infinity;\\n        }\\n        \\n\\t\\t// Declare zero-indexed length and midpoint\\n        let length = arr.length - 1;\\n        let mid = Math.floor( length/2 );\\n        \\n        // DIVIDE: Recursively find max sum in the left and right sub arrays\\n        let lMaxSumInSubArr = findMaxSumInArr( arr.slice(0, mid) );\\n        let rMaxSumInSubArr = findMaxSumInArr( arr.slice(mid + 1, length + 1) );\\n        \\n        /* MERGE: The divide step gave use the max sum on the left and right side, but we still need to account\\n\\t\\tfor the possibility of a contiguous array that goes from left to right through the midpoint */\\n\\t\\t\\n        // Declare variables to record the maximum contiguous sums for each side\\n        let lMaxContiguousSum = 0,\\n            rMaxContiguousSum = 0;\\n        \\n        // On the left side, find sum of contiguous array and keep an updated record of the maximum\\n        /* (NOTE: in order to account for contiguous arrays that traverse the midpoint, start the search from\\n\\t\\tthe midpoint - 1 index and traverse leftwards towards index 0. This directionality guarantees that\\n\\t\\ta contiguous array traversing the midpoint will be able to add the midpoint itself and the right side\\'s\\n\\t\\tcontiguous arr [this is exactly what is checked in the final return statement below]) */\\n        for (let i = mid - 1, currContiguousSum = 0; i >= 0; i--){\\n            currContiguousSum += arr[i];\\n            lMaxContiguousSum = Math.max(lMaxContiguousSum, currContiguousSum);\\n        }\\n       \\n        // On the left side, find sum of contiguous array and keep an updated record of the maximum\\n        /* (NOTE: in accordance with the last note, to account for sub arrays that traverse the midpoint, \\n\\t\\tstart the search from the midpoint + 1 index and traverse rightwards */\\n        for (let i = mid + 1, currContiguousSum = 0; i <= length; i++){\\n            currContiguousSum += arr[i];\\n            rMaxContiguousSum = Math.max(rMaxContiguousSum, currContiguousSum);\\n        }\\n        \\n        /* RETURN the max sum from the current array: either from the left side, right side, or a contiguous\\n\\t\\tsub arrary traversing from left to right through the midpoint */\\n        return Math.max(\\n            // The maximum sum from a contiguous subarray that traverses the midpoint\\n            lMaxContiguousSum + arr[mid] + rMaxContiguousSum, \\n            // The max sum from each side (whether it was a single value or a contiguous sum) \\n            lMaxSumInSubArr, \\n            rMaxSumInSubArr  \\n        );\\n    }\\n}\\n```\n```left === right```",
                "codeTag": "Unknown"
            },
            {
                "id": 20225,
                "title": "my-divide-and-conquer-solution-in-java-under-instruction-of-clrs-o-nlogn",
                "content": "    public class Solution {//divdie and conquer\\n        public int maxSubArray(int[] nums) {\\n            return Subarray(nums, 0 ,nums.length -1 );\\n        }\\n        public int Subarray(int[] A,int left, int right){\\n            if(left == right){return A[left];}\\n            int mid = left + (right - left) / 2;\\n            int leftSum = Subarray(A,left,mid);// left part \\n            int rightSum = Subarray(A,mid+1,right);//right part\\n            int crossSum = crossSubarray(A,left,right);// cross part\\n            if(leftSum >= rightSum && leftSum >= crossSum){// left part is max\\n                return leftSum;\\n            }\\n            if(rightSum >= leftSum && rightSum >= crossSum){// right part is max\\n                return rightSum;\\n            }\\n            return crossSum; // cross part is max\\n        }\\n        public int crossSubarray(int[] A,int left,int right){\\n            int leftSum = Integer.MIN_VALUE;\\n            int rightSum = Integer.MIN_VALUE;\\n            int sum = 0;\\n            int mid = left + (right - left) / 2;\\n            for(int i = mid; i >= left ; i--){\\n                sum = sum + A[i];\\n                if(leftSum < sum){\\n                    leftSum = sum;\\n                }\\n            }\\n            sum = 0;\\n            for(int j = mid + 1; j <= right; j++){\\n                sum = sum + A[j];\\n                if(rightSum < sum){\\n                    rightSum = sum;\\n                }\\n            }\\n            return leftSum + rightSum;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "class Solution {//divdie and conquer\\n        public int maxSubArray(int[] nums) {\\n            return Subarray(nums, 0 ,nums.length -1 );\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20442,
                "title": "my-concise-o-n-dp-java-solution",
                "content": "**Explanation**\\n\\nAlthough there're some other simplified solutions, but DP solution can make the original thought for this problem clearer. In this solution, dp[i] means the largest sum among the subarrays whose last element is A[i].\\n\\n**Solution1. DP Solution - O(n) time, O(n) space**\\n   \\n\\n    public int maxSubArray(int[] A) {\\n    \\tint dp[] = new int[A.length]; int max = A[0]; dp[0] = A[0]; \\n    \\tfor (int i = 1; i < A.length; i++) {\\t\\t\\t\\n    \\t\\tdp[i] = Math.max(dp[i-1] + A[i] ,A[i]);\\n    \\t\\tmax = Math.max(max, dp[i]);\\n    \\t}\\n    \\treturn max;\\n    }\\n\\n**Solution2. Simplified DP Solution - O(n) time, O(1) space** *- Special thanks for TWiStErRob's smart comment*\\n\\nThe basic idea is to check previous sum, reset it to 0 if it's less than 0.\\n\\n    public int maxSubArray(int[] A) {\\n        int res = Integer.MIN_VALUE, sum = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            sum = Math.max(sum, 0) + A[i];\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }  \\n\\n\\n**Solution3. Pre-Sum Array Solution - O(n) time, O(n) space**\\n\\nThe basic idea is to use pre-sum array, max =  Math.max(max, sum[i] - minSum). (minSum is the minimum sum before A[i])\\n\\n    public int maxSubArray(int[] A) {\\n    \\tif (A == null || A.length == 0) return 0;\\n    \\tint max = A[0], minSum = Integer.MAX_VALUE;\\n    \\tint sum[] = new int[A.length];\\n    \\tsum[0] = A[0];\\t\\n    \\tfor (int i = 1; i < A.length; i++) {\\n    \\t\\tsum[i] = sum[i-1] + A[i];\\n    \\t\\tminSum = Math.min(0, Math.min(minSum, sum[i-1]));\\n    \\t\\tmax = Math.max(max, sum[i] - minSum); \\n    \\t}\\n    \\treturn max;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nAlthough there're some other simplified solutions, but DP solution can make the original thought for this problem clearer. In this solution, dp[i] means the largest sum among the subarrays whose last element is A[i].\\n\\n**Solution1. DP Solution - O(n) time, O(n) space**\\n   \\n\\n    public int maxSubArray(int[] A) {\\n    \\tint dp[] = new int[A.length]; int max = A[0]; dp[0] = A[0]; \\n    \\tfor (int i = 1; i < A.length; i++) {\\t\\t\\t\\n    \\t\\tdp[i] = Math.max(dp[i-1] + A[i] ,A[i]);\\n    \\t\\tmax = Math.max(max, dp[i]);\\n    \\t}\\n    \\treturn max;\\n    }\\n\\n**Solution2. Simplified DP Solution - O(n) time, O(1) space** *- Special thanks for TWiStErRob's smart comment*\\n\\nThe basic idea is to check previous sum, reset it to 0 if it's less than 0.\\n\\n    public int maxSubArray(int[] A) {\\n        int res = Integer.MIN_VALUE, sum = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            sum = Math.max(sum, 0) + A[i];\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }  \\n\\n\\n**Solution3. Pre-Sum Array Solution - O(n) time, O(n) space**\\n\\nThe basic idea is to use pre-sum array, max =  Math.max(max, sum[i] - minSum). (minSum is the minimum sum before A[i])\\n\\n    public int maxSubArray(int[] A) {\\n    \\tif (A == null || A.length == 0) return 0;\\n    \\tint max = A[0], minSum = Integer.MAX_VALUE;\\n    \\tint sum[] = new int[A.length];\\n    \\tsum[0] = A[0];\\t\\n    \\tfor (int i = 1; i < A.length; i++) {\\n    \\t\\tsum[i] = sum[i-1] + A[i];\\n    \\t\\tminSum = Math.min(0, Math.min(minSum, sum[i-1]));\\n    \\t\\tmax = Math.max(max, sum[i] - minSum); \\n    \\t}\\n    \\treturn max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 139218,
                "title": "javascript-very-clear-and-short-dp-solution",
                "content": "```\\nvar maxSubArray = function(nums) {\\n    for (let i = 1; i < nums.length; i++){\\n        nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);\\n    }\\n    return Math.max(...nums);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSubArray = function(nums) {\\n    for (let i = 1; i < nums.length; i++){\\n        nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);\\n    }\\n    return Math.max(...nums);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20360,
                "title": "c-an-clear-o-n-divide-and-conquer-solution-with-comments",
                "content": "For each subarray, calculate four attributes: \\n\\n    mx (largest sum of this subarray), \\n    lmx(largest sum starting from the left most element), \\n    rmx(largest sum ending with the right most element), \\n    sum(the sum of the total subarray). \\nThe recurrence is: T(n) = 2T(n / 2) + O(1). So the running time of this algorithm is O(n).\\n\\n    class Solution {\\n    public:\\n        void maxSubArray(vector<int>& nums, int l, int r, int& mx, int& lmx, int& rmx, int& sum) {\\n            if (l == r) {\\n                mx = lmx = rmx = sum = nums[l];\\n            }\\n            else {\\n                int m = (l + r) / 2;\\n                int mx1, lmx1, rmx1, sum1;\\n                int mx2, lmx2, rmx2, sum2;\\n                maxSubArray(nums, l, m, mx1, lmx1, rmx1, sum1);\\n                maxSubArray(nums, m + 1, r, mx2, lmx2, rmx2, sum2);\\n                mx = max(max(mx1, mx2), rmx1 + lmx2);\\n                lmx = max(lmx1, sum1 + lmx2);\\n                rmx = max(rmx2, sum2 + rmx1);\\n                sum = sum1 + sum2;\\n            }\\n        }\\n        int maxSubArray(vector<int>& nums) {\\n            if (nums.size() == 0) {\\n                return 0;\\n            }\\n            int mx, lmx, rmx, sum;\\n            maxSubArray(nums, 0, nums.size() - 1, mx, lmx, rmx, sum);\\n            return mx;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n    public:\\n        void maxSubArray(vector<int>& nums, int l, int r, int& mx, int& lmx, int& rmx, int& sum) {\\n            if (l == r) {\\n                mx = lmx = rmx = sum = nums[l];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 20481,
                "title": "java-o-n-time-o-1-space-5-lines-of-code",
                "content": "    public int maxSubArray(int[] nums) {\\n        int currMax=nums[0],max=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            currMax=Math.max(currMax+nums[i],nums[i]);\\n            max=Math.max(max,currMax);\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int maxSubArray(int[] nums) {\\n        int currMax=nums[0],max=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            currMax=Math.max(currMax+nums[i],nums[i]);\\n            max=Math.max(max,currMax);\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 562928,
                "title": "javascript-kadane-s-algorithm-implementation-w-explanation",
                "content": "if you had difficulties with this problem, just like me, then I hope it will be useful to you\\n\\n1. set initials\\n1.1 first value in the array. It doesn\\u2019t matter to us whether `max` is positive or negative.\\n1.2 we need an intermediate `current` positive value, because a negative value does not interest us, since -2 is always more than -5 and it means `0 + -2 > -5`.\\n2. At this point we\\'ve covered first value in the array, that\\'s why we will move through array starting from the `1` index.\\n3. `current += nums[i]` means that every time we take a new value, we will sum it with the past `current` value. This will help us discard lower values in the next step.\\n4. `max = Math.max(max, current)` means that we choose only the highest value (previous `max` or new `current`).\\n5. `current = Math.max(current, 0)` means that if the value was negative, then we throw it away and set zero as default. Why? Because it makes no sense to summarize the negative values, they simply do not interest us. The previous step is enough to compare negative values. There we will choose the minimum negative value (if it is the case i.e     `[-10, -3, -5, -2, -6]` will return only `-2` because it is the highest value from the negative ones.\\n\\n```javascript\\nconst maxSubArray = nums => {\\n    let max = nums[0];\\n    let current = Math.max(max, 0);\\n    \\n    for (let i = 1; i < nums.length; i += 1) {\\n        current += nums[i];\\n        max = Math.max(max, current);\\n        current = Math.max(current, 0);\\n    }\\n    \\n    return max;\\n};\\n```\\n\\nHappy coding :)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst maxSubArray = nums => {\\n    let max = nums[0];\\n    let current = Math.max(max, 0);\\n    \\n    for (let i = 1; i < nums.length; i += 1) {\\n        current += nums[i];\\n        max = Math.max(max, current);\\n        current = Math.max(current, 0);\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164670,
                "title": "javascript-solution-comparisons",
                "content": "So I was implementing a dynamic appraoch, and I though it would be good practice to implement a the different solutions that I could think of and analyze the Big O of each of them.\\n\\n### O(n\\xB2) Time - O(1) Space - Naive approach\\n##### 320ms on my connection\\n```Javascript\\nvar maxSubArray = function(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 0; i < nums.length; i += 1) {\\n    let currentMax = nums[i];\\n    for (let j = i + 1; j <nums.length; j += 1) {\\n      currentMax = Math.max(currentMax + nums[j], nums[j]);\\n      max = Math.max(currentMax, max);\\n    }\\n  }\\n  \\n  return max;\\n};\\n```\\n\\nWhat is going on here is that we check from the start of number at i, and then add each sequential number at j. Each iteration will check to see what the ```currentMax``` is, either ```nums[j]``` or ```nums[j] + currentMax```, and them compare the ```max``` to the ```currentMax```. This will run for every number and thus we have a time quadratic time complexity with a constant space complexity. This is passing, however, there should be more tests that should get filter out this solution. O(n\\xB2) should be avoided if there is a better solution.\\n\\n### O(n) Time - O(n) Space - Dynamic Hashing\\n##### 88ms on my connection\\n```Javascript\\nvar maxSubArray = function(nums) {\\n  const hash = { 0: nums[0]}\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i += 1) {\\n    hash[i] = Math.max(hash[i - 1] + nums[i], nums[i]);\\n    max = Math.max(hash[i], max);\\n  }\\n  \\n  return max;\\n};\\n```\\n\\nFor this solution we are utilizing a hash to keep track of the max for the previous number. What we calculate the maximum based on the previous maximum and the current value. The **KEY** point here is that we are looking for the largest **SEQUENTIAL** max.\\n\\nExample, take this array of four numbers:\\n```Javascript\\nconst nums = [1, -10, 5, 6];\\n```\\nThe maximum value that you can get from a subarray from index 0 to 0 (```nums[0]```) is the value itself. When we look at the next value, the maximum value you can get would either be the previous value plus the current value or the current value itself. So what we do is create a hash to keep track of the maxes at each index:\\n```Javascript\\n// Key : Value => index : max at that index\\nconst hash = {\\n  0: 1 // nums[0] since there was no previous max\\n  1: -9 // hash[0] + nums[1] > nums[1] => 1 + -10 > -10\\n  2: 5 // hash[1] + nums[2] < nums[2] => -9 + 5 < 5\\n  3: 11 // hash[2] + nums[3] > nums[3] => 5 + 6 > 6\\n}\\n```\\nThis may seem strange since we are not technically checking at every single possibility, but the pattern allows us to come to this solution. Whe have a O(n) time solution with a O(n) space complexity. However, it is far faster than the previous solution. We can, however, improve this even more to utilize constant space.\\n\\n### O(n) Time - O(1) Space - No Hashing!\\n##### 60ms on my connection\\n```Javascript\\nvar maxSubArray = function(nums) {\\n  let currentMax = nums[0];\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i += 1) {\\n    currentMax = Math.max(currentMax + nums[i], nums[i]);\\n    max = Math.max(currentMax, max);\\n  }\\n  \\n  return max;\\n};\\n```\\n\\nIf you\\'ve noticed, we only needed to worry about the previous max value at each index of the array, so we don\\'t need to keep track of every max at each instance for this function. By just storing the previous maximum for each element, we can check the ```currentMax``` like we have been in the previous examples and set the ```max``` accordingly. This solution retain the O(n) time complexity, but removes the necessity for keeping track of every element we come across.",
                "solutionTags": [],
                "code": "```Javascript\\nvar maxSubArray = function(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 0; i < nums.length; i += 1) {\\n    let currentMax = nums[i];\\n    for (let j = i + 1; j <nums.length; j += 1) {\\n      currentMax = Math.max(currentMax + nums[j], nums[j]);\\n      max = Math.max(currentMax, max);\\n    }\\n  }\\n  \\n  return max;\\n};\\n```\n```currentMax```\n```nums[j]```\n```nums[j] + currentMax```\n```max```\n```currentMax```\n```Javascript\\nvar maxSubArray = function(nums) {\\n  const hash = { 0: nums[0]}\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i += 1) {\\n    hash[i] = Math.max(hash[i - 1] + nums[i], nums[i]);\\n    max = Math.max(hash[i], max);\\n  }\\n  \\n  return max;\\n};\\n```\n```Javascript\\nconst nums = [1, -10, 5, 6];\\n```\n```nums[0]```\n```Javascript\\n// Key : Value => index : max at that index\\nconst hash = {\\n  0: 1 // nums[0] since there was no previous max\\n  1: -9 // hash[0] + nums[1] > nums[1] => 1 + -10 > -10\\n  2: 5 // hash[1] + nums[2] < nums[2] => -9 + 5 < 5\\n  3: 11 // hash[2] + nums[3] > nums[3] => 5 + 6 > 6\\n}\\n```\n```Javascript\\nvar maxSubArray = function(nums) {\\n  let currentMax = nums[0];\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i += 1) {\\n    currentMax = Math.max(currentMax + nums[i], nums[i]);\\n    max = Math.max(currentMax, max);\\n  }\\n  \\n  return max;\\n};\\n```\n```currentMax```\n```max```",
                "codeTag": "Unknown"
            },
            {
                "id": 118509,
                "title": "c-kadane-s-algorithm",
                "content": "The following solution uses the an algorithm called **`Kadane\\'s Algorithm`**.\\n\\nTo know more about this algorithm, check this video from CS Dojo: \\nhttps://www.youtube.com/watch?v=86CQq3pKSUw\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        \\n        int currentSum =nums[0], totalSum = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            \\n            //Current max sum is either the current element OR current element + Previous Maximum subarray)\\n            currentSum = max(nums[i], currentSum+nums[i]); \\n            \\n            //If the current maximum array sum is greater than the global total. Update it\\n            totalSum = max(totalSum, currentSum);\\n    }\\n        return totalSum;\\n    }\\n};\\n```\\n\\n\\nI would like to thank [@kadoyan](https://leetcode.com/problems/maximum-subarray/discuss/110801/Kadane\\'s-Algorithm-in-Javascript-O(n)/117997?page=1) for his Solution.\\n\\n\\nMethod 2 : Coding Ninja Method\\n```\\nint maxSubArray(vector<int>& nums) {\\n        \\n        int currentSum = 0, totalSum = INT_MIN;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            \\n            //Sum till this point ======= Current Sum till this point + this element\\n            currentSum = currentSum + nums[i]; \\n            \\n            //If the current maximum array sum is greater than the global total. Update it\\n            totalSum = max(totalSum, currentSum);\\n            \\n            //If you get current as less thn 0 then its no point in carrying forward. Make it 0\\n            currentSum = max(0,currentSum);\\n    }\\n        return totalSum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        \\n        int currentSum =nums[0], totalSum = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            \\n            //Current max sum is either the current element OR current element + Previous Maximum subarray)\\n            currentSum = max(nums[i], currentSum+nums[i]); \\n            \\n            //If the current maximum array sum is greater than the global total. Update it\\n            totalSum = max(totalSum, currentSum);\\n    }\\n        return totalSum;\\n    }\\n};\\n```\n```\\nint maxSubArray(vector<int>& nums) {\\n        \\n        int currentSum = 0, totalSum = INT_MIN;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            \\n            //Sum till this point ======= Current Sum till this point + this element\\n            currentSum = currentSum + nums[i]; \\n            \\n            //If the current maximum array sum is greater than the global total. Update it\\n            totalSum = max(totalSum, currentSum);\\n            \\n            //If you get current as less thn 0 then its no point in carrying forward. Make it 0\\n            currentSum = max(0,currentSum);\\n    }\\n        return totalSum;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369797,
                "title": "kadane-s-algorithm-with-detailed-explanation-and-example-python",
                "content": "Can be solved using **Kadane\\'s algorithm** in linear time and without using additional space. The main ideas are:\\n* Use the input vector `nums` to store the candidate subarrays sum (i.e. the greatest contiguous sum so far).\\n* Ignore cumulative negatives, as they don\\'t contribute positively to the sum.\\n\\n**Example:**\\nGiven `nums = [-2, 1, -3, 4]`. \\nCompare all elements with the cumulative sum stored in the previous index. \\n1. Since `-2 < 0`, value `-2` doesn\\'t contribute to the sum. Thus, ignore it and proceed to the next index.\\n2. Since `1 > 0`,  value `1` does contribute. Hence, compute `-3+1 = -2` and store it in index `2`.\\n3. The result vector is so far: `[-2, 1, -2, 4]`. Last element to evaluate is `4`.\\n4. Since `-2 < 0`, `-2` does not contribute positively to the sum. Thus, ignore it.\\n5. Having checked all elements, the final result vector is: `[-2, 1, -2, 4]`. \\n6. The maximum subarray is `max(num)=4`.\\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1, len(nums)):\\n            if nums[i - 1] > 0: \\n                nums[i] += nums[i - 1]\\n        return max(nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1, len(nums)):\\n            if nums[i - 1] > 0: \\n                nums[i] += nums[i - 1]\\n        return max(nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378937,
                "title": "python-dynamic-programming-solution",
                "content": "For the dynamic programming approach, this is O(n). Let\\'s think about the example [2, -1, 3, -2]. In the base case, [2] is the smallest subarray possible (starting from index 0). Its maximum subarray sum is the sole element itself, 2. The next subproblem is [2, 1]. You could either have [2, -1] (sum=1) or [-1] (sum=-1). Since the sum for the former is greater, we store 1 as the maximum subarray sum. Just by going through this example, we\\'ve discovered the recurrence relation! You could either start a new subarray for a maximum sum at index i, or you could tack on the element at index i to the previous subproblem. So, the relation here is as shown on line 4 below. Draw out an example if you can\\'t figure it out! \\n```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i], nums[i])\\n        return max(dp)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i], nums[i])\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 20406,
                "title": "accepted-as-best-in-c",
                "content": "    int maxSubArray(int* nums, int size)\\n    {\\n        int sum = 0;\\n        int max = INT_MIN;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(sum >= 0)\\n                sum += nums[i];\\n            else\\n                sum = nums[i];\\n            if(sum > max)\\n                max = sum;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "    int maxSubArray(int* nums, int size)\\n    {\\n        int sum = 0;\\n        int max = INT_MIN;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(sum >= 0)\\n                sum += nums[i];\\n            else\\n                sum = nums[i];\\n            if(sum > max)\\n                max = sum;\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1320621,
                "title": "swift-maximum-subarray-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxSubArray(_ nums: [Int]) -> Int {\\n        var curSum = nums[0], maxSum = nums[0]\\n        for i in 1..<nums.count {\\n            curSum = max(nums[i], curSum + nums[i])\\n            maxSum = max(maxSum, curSum)\\n        }\\n        return maxSum\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.007 (0.009) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\\n        XCTAssertEqual(res, 6)\\n    }\\n    func test2() {\\n        let res = s.maxSubArray([1])\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test3() {\\n        let res = s.maxSubArray([5,4,-1,7,8])\\n        XCTAssertEqual(res, 23)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxSubArray(_ nums: [Int]) -> Int {\\n        var curSum = nums[0], maxSum = nums[0]\\n        for i in 1..<nums.count {\\n            curSum = max(nums[i], curSum + nums[i])\\n            maxSum = max(maxSum, curSum)\\n        }\\n        return maxSum\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.007 (0.009) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\\n        XCTAssertEqual(res, 6)\\n    }\\n    func test2() {\\n        let res = s.maxSubArray([1])\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test3() {\\n        let res = s.maxSubArray([5,4,-1,7,8])\\n        XCTAssertEqual(res, 23)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992938,
                "title": "simple-java-1ms-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the maximum sum of the sub-array. That means we have to **avoid negative numbers** as much as possible.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use **Kadane\\'s Algorithm** to optimize the code. See the steps below:\\n\\n    1. Create two variables to store current and maximum sub-array sum.\\n    2. Initialize both the variable with nums[0], i.e., 1st element.\\n    3. Iterate from index 1 to n-1.\\n    4. Keep increasing the current sub-array sum.\\n    5. If, at any point, curSum is negative, reset it to 0.\\n    6. If, at any point, curSum is greater than maxSum then update maxSum.\\nFinally, return the maxSum.\\nFollow the code below to understand the solution.\\n\\n           **If this solution helped you, give it an up-vote to help others**\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n\\n\\n//      We will need two variables. One will store current sub-array sum.\\n//      Other will store maximum sub-array sum.\\n\\n        int curSum = nums[0];\\n        int maxSum = nums[0];   // consider 1st element to be greatest sub-array.\\n\\n        for(int i = 1; i < nums.length; i++){\\n\\n            // If the cur sub-array sum is negative then reset is to 0.\\n            if(curSum < 0)\\n            {\\n                curSum = 0;\\n            }\\n\\n            // Iterate over the array and calculate sub-array sum.\\n            curSum += nums[i];\\n\\n            // maxSum will be greater of curSum and maxSum.\\n            maxSum = Math.max(maxSum, curSum);\\n\\n        }\\n\\n        // finally, return the maxSum.\\n        return maxSum;\\n\\n    }\\n}\\n```\\n**What if there are only negative numbers?**\\n\\na.----->> if(curSum < 0)\\n{\\ncurSum = 0;\\n}\\n\\nb.---->> curSum += nums[i];\\n\\nc.----->> maxSum = Math.max(maxSum, curSum);\\n\\n1. Initially, the max sub-array sum is nums[0] i.e., the first element. Let\\'s say nums[0] is -2.\\n2. If the curSum is negative, then it is rest to 0. (step a)\\nThat means in the step b, curSum = nums [ i ]. (equal to single element) lets say it is -1.\\n3. In step c, we store the maximum of maxSum and curSum in maxSum. (max of -1 and -2 is -1).\\n4. So, if there are only negative numbers. The greatest negative number will be stored in maxSum.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n\\n\\n//      We will need two variables. One will store current sub-array sum.\\n//      Other will store maximum sub-array sum.\\n\\n        int curSum = nums[0];\\n        int maxSum = nums[0];   // consider 1st element to be greatest sub-array.\\n\\n        for(int i = 1; i < nums.length; i++){\\n\\n            // If the cur sub-array sum is negative then reset is to 0.\\n            if(curSum < 0)\\n            {\\n                curSum = 0;\\n            }\\n\\n            // Iterate over the array and calculate sub-array sum.\\n            curSum += nums[i];\\n\\n            // maxSum will be greater of curSum and maxSum.\\n            maxSum = Math.max(maxSum, curSum);\\n\\n        }\\n\\n        // finally, return the maxSum.\\n        return maxSum;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028920,
                "title": "divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        return findMaxSum(nums, 0, nums.length-1);     \\n    }\\n    \\n    private int findMaxSum(int[] nums, int s, int e){\\n        if(s==e) return nums[s];\\n        \\n        int mid = s + (e-s)/2;\\n        \\n        int leftMax = findMaxSum(nums, s, mid);\\n        int rightMax = findMaxSum(nums, mid+1, e);\\n        int arrMax = findMaxCrossSum(nums, s, mid, e);\\n      \\n        \\n        return Math.max(leftMax, Math.max(rightMax, arrMax));\\n    }\\n    \\n    private int findMaxCrossSum(int []nums, int s, int m, int e){\\n\\n        int lSum=0, lMax=Integer.MIN_VALUE;\\n\\t\\t\\n        for(int i=m; i>=s; i--){\\n            lSum+=nums[i];\\n            lMax = Math.max(lMax, lSum);        \\n        }\\n        \\n        int rSum=0, rMax=Integer.MIN_VALUE;\\n\\t\\t\\n        for(int i=m+1; i<=e; i++){\\n            rSum+=nums[i];\\n            rMax = Math.max(rMax, rSum);\\n        }\\n        \\n        return lMax+rMax;\\n    }\\n}\\n```\\n\\nReference: https://www.youtube.com/watch?v=yBCzO0FpsVc&list=LL&index=6",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        return findMaxSum(nums, 0, nums.length-1);     \\n    }\\n    \\n    private int findMaxSum(int[] nums, int s, int e){\\n        if(s==e) return nums[s];\\n        \\n        int mid = s + (e-s)/2;\\n        \\n        int leftMax = findMaxSum(nums, s, mid);\\n        int rightMax = findMaxSum(nums, mid+1, e);\\n        int arrMax = findMaxCrossSum(nums, s, mid, e);\\n      \\n        \\n        return Math.max(leftMax, Math.max(rightMax, arrMax));\\n    }\\n    \\n    private int findMaxCrossSum(int []nums, int s, int m, int e){\\n\\n        int lSum=0, lMax=Integer.MIN_VALUE;\\n\\t\\t\\n        for(int i=m; i>=s; i--){\\n            lSum+=nums[i];\\n            lMax = Math.max(lMax, lSum);        \\n        }\\n        \\n        int rSum=0, rMax=Integer.MIN_VALUE;\\n\\t\\t\\n        for(int i=m+1; i<=e; i++){\\n            rSum+=nums[i];\\n            rMax = Math.max(rMax, rSum);\\n        }\\n        \\n        return lMax+rMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457517,
                "title": "dynamic-programming-approach-python-o-n",
                "content": "**Note: If you find this post useful, please upvote for my motivation to continue with more of these, thank you <3**\\n\\n# Idea:\\n* **Suppose there is a max sum of a subarray starting from position i+1 (we can call it val[i+1]). At position i, we want to get the max sum of subarray starting from i, the top-down question will be: Should we add val[i+1] to nums[i]?**\\n```\\nval[i] = max(nums[i], nums[i] + val[i+1])\\n#Where val[i] is the max sum of the subarray that starts from i (must include nums[i])\\n```\\n# Steps:\\n1. * By traversing the whole nums array in a reversed order, we get the val array which contain the result somewhere in it. \\n2. * Now we just need to traverse that val array again and get that max value.\\n\\n\\n# Code:\\n**In my code, because once I traverse an element in the nums, I won\\'t reuse that element anymore, therefore I don\\'t have to create the \"val\" array, instead I just set the \"val\" value to the existing nums array, just for memory saving.**\\n```\\nINF = -10**5\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2, -1, -1):\\n            nums[i] = max(nums[i], nums[i] + nums[i+1])\\n        result = INF\\n        for i in range(len(nums)):\\n            result = max(result, nums[i])\\n        return result\\n```\\nThe above code is to let you understand the idea thoroughly, another compressed solution (with same idea) will be:\\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        result = nums[-1]\\n        for i in range(len(nums)-2, -1, -1):\\n            nums[i] = max(nums[i], nums[i] + nums[i+1])\\n            result = max(result, nums[i])\\n        return result\\n```\\n\\n# Complexity Analysis:\\n* Time complexity: O(2n) -> O(n)\\n* Space complexity: O(1) - (Because I didn\\'t initiate any array)\\n\\n**Note: If you find this post useful, please upvote for my motivation to continue with more of these, thank you <3**\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nval[i] = max(nums[i], nums[i] + val[i+1])\\n#Where val[i] is the max sum of the subarray that starts from i (must include nums[i])\\n```\n```\\nINF = -10**5\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2, -1, -1):\\n            nums[i] = max(nums[i], nums[i] + nums[i+1])\\n        result = INF\\n        for i in range(len(nums)):\\n            result = max(result, nums[i])\\n        return result\\n```\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        result = nums[-1]\\n        for i in range(len(nums)-2, -1, -1):\\n            nums[i] = max(nums[i], nums[i] + nums[i+1])\\n            result = max(result, nums[i])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380007,
                "title": "javascript-beats-99-super-simple",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n  for (let i = 1; i < nums.length; i++) {\\n    nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);\\n  }\\n  return Math.max(...nums)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n  for (let i = 1; i < nums.length; i++) {\\n    nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);\\n  }\\n  return Math.max(...nums)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136682,
                "title": "javascript-divide-and-conquer-with-bonus-pictures",
                "content": "I understood the O(n) kadane\\'s algorithm fine, but had trouble wrapping my head around the divide and conquer approach. I drew out what was happening which helped me understand it and wanted to share.\\n\\nThe first part, the divide, looks a lot like diagrams of merge sort. We keep splitting the array into left and right until we get to our base case, a single item.\\n\\n![image](https://assets.leetcode.com/users/images/76451586-0084-462a-b242-75185e1bc868_1617247482.9558964.png)\\n\\nNow for conquering on the way up. At each division, we check is the max array in the left side or the right side? The special case is that the max array exists across the left and right side, so for each division we check from the middle out to find the crossing max sum.\\n\\nAn example of each case.\\n\\n[1,-1] -> left side has max\\n[-5, 2] -> right side has max\\n[1,2] -> the max exists \"crossing\" both sides\\n\\nAnd from the problems example, green show where the max array was found and the small text box shows when it was right, left or crossing.\\n\\n![image](https://assets.leetcode.com/users/images/edcb42d7-951c-4b17-a5dd-1bb09f77c48e_1617247490.616707.png)\\n\\nAnd now pictures to code...\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    return findMax(nums, 0, nums.length - 1)\\n};\\n\\nvar findMax = function (nums, l, r) {\\n    if (l == r) {\\n        //Base case, return num here\\n        return nums[l]\\n    }\\n    \\n    let mid = Math.floor((l + r)/2)\\n    let leftSum = findMax(nums, l, mid) //Recursively check left side for max sum\\n    let rightSum = findMax(nums, mid+1, r) //recursively check right side for max sum\\n    const crossingSum = findCrossingSum(nums, l, mid, r) //Find max sum that includes left and right side\\n    return Math.max (crossingSum, leftSum, rightSum) //return whichever is largest\\n}\\n\\nvar findCrossingSum = function(nums, l, mid, r) { \\n    //A crossing sum exists on the left side and right side\\n    // so if we count mid as on the left side, the crossing sum MUST\\n    // include nums[mid] and nums[mid+1]. From these starting points we search for the max sum\\n    let sum=0\\n    let maxLSum = -Infinity\\n    for(let i = mid; i >= l; i--) {\\n        sum += nums[i]\\n        maxLSum = Math.max(maxLSum, sum)\\n    }\\n    sum =0\\n    let maxRSum = -Infinity\\n    for (let i = mid + 1; i <= r; i++) {\\n        sum += nums[i]\\n        maxRSum = Math.max(maxRSum, sum)\\n    }\\n    \\n    return maxRSum + maxLSum\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    return findMax(nums, 0, nums.length - 1)\\n};\\n\\nvar findMax = function (nums, l, r) {\\n    if (l == r) {\\n        //Base case, return num here\\n        return nums[l]\\n    }\\n    \\n    let mid = Math.floor((l + r)/2)\\n    let leftSum = findMax(nums, l, mid) //Recursively check left side for max sum\\n    let rightSum = findMax(nums, mid+1, r) //recursively check right side for max sum\\n    const crossingSum = findCrossingSum(nums, l, mid, r) //Find max sum that includes left and right side\\n    return Math.max (crossingSum, leftSum, rightSum) //return whichever is largest\\n}\\n\\nvar findCrossingSum = function(nums, l, mid, r) { \\n    //A crossing sum exists on the left side and right side\\n    // so if we count mid as on the left side, the crossing sum MUST\\n    // include nums[mid] and nums[mid+1]. From these starting points we search for the max sum\\n    let sum=0\\n    let maxLSum = -Infinity\\n    for(let i = mid; i >= l; i--) {\\n        sum += nums[i]\\n        maxLSum = Math.max(maxLSum, sum)\\n    }\\n    sum =0\\n    let maxRSum = -Infinity\\n    for (let i = mid + 1; i <= r; i++) {\\n        sum += nums[i]\\n        maxRSum = Math.max(maxRSum, sum)\\n    }\\n    \\n    return maxRSum + maxLSum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799981,
                "title": "say-goodbye-to-kadane-hello-to-intuitive-o-n-prefix-sum-solution-java",
                "content": "Why wrap your head around complicated kadane logic?\\n\\nWhenever you see finding subarrays that meet a certain criteria, prefix sums should be the first thing that jump to your head.\\n\\nHow does prefix sums work? \\nYou just keep a running sum of the array.\\nYou subtract previous runningsums from the current running sum to get your desired sub array.\\n\\nSo to get the maximum subarray at any given point, you subtract the minimum running sum from the current running sum.\\n\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int min = 0;\\n        \\n        int runningSum = 0;\\n        \\n        int max = nums[0];\\n        for (int num: nums) {\\n            runningSum += num;\\n            max = Math.max(max, runningSum - min);\\n            min = Math.min(runningSum, min);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nI also have an prefix sum explanation for the Maximum product subarray\\nhttps://leetcode.com/problems/maximum-product-subarray/discuss/843820/Say-goodbye-to-Kadane-hello-to-intuitive-O(n)-prefix-sum-solution-Java",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int min = 0;\\n        \\n        int runningSum = 0;\\n        \\n        int max = nums[0];\\n        for (int num: nums) {\\n            runningSum += num;\\n            max = Math.max(max, runningSum - min);\\n            min = Math.min(runningSum, min);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465258,
                "title": "cpp-easy-and-simple-with-explanation-0-ms-faster-than-100-of-c",
                "content": "Hey guyz kindly refer **Kadane\\u2019s Algorithm** for easier understanding (else skip to code \\uD83D\\uDE03):\\n\\n##### The idea of Kadane\\u2019s algorithm is to look for all positive contiguous segments of the array (maxendinghere is used for this). And keep track of maximum sum contiguous segment among all positive segments (maxsofar is used for this). Each time we get a positive-sum compare it with maxsofar and update maxsofar if it is greater than maxsofar .\\n\\nInitialize:\\n    max_so_far = INT_MIN\\n    max_ending_here = 0\\n\\nLoop for each element of the array\\n  (a) max_ending_here = max_ending_here + a[i]\\n  (b) if(max_so_far < max_ending_here)\\n            max_so_far = max_ending_here\\n  (c) if(max_ending_here < 0)\\n            max_ending_here = 0\\nreturn max_so_far\\n\\n\\n\\n\\n***CODE With Kadane\\u2019s Algorithm :***\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum=INT_MIN, curr_sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr_sum+=nums[i];\\n            if(curr_sum>max_sum)\\n                max_sum=curr_sum;\\n        \\n            if(curr_sum<0)\\n                curr_sum=0;\\n        }\\n        return max_sum;\\n    }\\n};\\n```\\n***CODE With 0ms time :***\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n                  \\n        int cs=nums[0], ms=nums[0];\\n        for(int i=1; i<nums.size();i++)\\n        {\\n            cs = max(nums[i], cs+nums[i]);\\n            ms=max(cs, ms);\\n        }\\n        return ms;\\n    }\\n};\\n```\\nIf any doubts feel free to ask :)\\nPlz Upvote if it helped you \\uD83D\\uDE0A ..\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum=INT_MIN, curr_sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr_sum+=nums[i];\\n            if(curr_sum>max_sum)\\n                max_sum=curr_sum;\\n        \\n            if(curr_sum<0)\\n                curr_sum=0;\\n        }\\n        return max_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n                  \\n        int cs=nums[0], ms=nums[0];\\n        for(int i=1; i<nums.size();i++)\\n        {\\n            cs = max(nums[i], cs+nums[i]);\\n            ms=max(cs, ms);\\n        }\\n        return ms;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252058,
                "title": "c-solution",
                "content": "Runtime: 112 ms, faster than 81.41% of C# online submissions for Maximum Subarray.\\nMemory Usage: 23.2 MB, less than 68.87% of C# online submissions for Maximum Subarray.\\n\\nMy solution:\\n\\n```\\npublic int MaxSubArray(int[] nums) {\\n\\tint sum = 0;\\n\\tint maxSum = nums[0];\\n\\n\\tfor (int i=0; i<nums.Length; i++) {\\n\\t\\tsum += nums[i];\\n\\t\\tif (nums[i] > sum) {\\n\\t\\t\\tsum = nums[i];\\n\\t\\t}\\n\\t\\tif (sum > maxSum) { \\n\\t\\t\\tmaxSum = sum; \\n\\t\\t}\\n\\t}\\n\\treturn maxSum;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int MaxSubArray(int[] nums) {\\n\\tint sum = 0;\\n\\tint maxSum = nums[0];\\n\\n\\tfor (int i=0; i<nums.Length; i++) {\\n\\t\\tsum += nums[i];\\n\\t\\tif (nums[i] > sum) {\\n\\t\\t\\tsum = nums[i];\\n\\t\\t}\\n\\t\\tif (sum > maxSum) { \\n\\t\\t\\tmaxSum = sum; \\n\\t\\t}\\n\\t}\\n\\treturn maxSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503255,
                "title": "dp-thought-process-from-top-down-to-optimized-bottom-up",
                "content": "This approach was inspired by [this](https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.) post where the OP talks about how to approach the problem in DP way. Sure, there are many other ways to solve this problem, but I find DP to be a lot more straight forward to come up with answers and optimize from there.\\n\\n**Step 1**. Figure out recurrence relation\\nWith each index denoted by ``i``, you have two options to determine the maximum sum:\\na) stop counting the running sum and start over with current index\\nb) keep on counting the running sum\\nThose two options ^ are determined based on the current running sum. Thus, we can denote the recurrence relation as:\\n``maxSum(i) = Math.max(nums[i], nums[i] + maxSum(nums, i + 1))``\\nUsing the formula above, we can now move on to next step.\\n\\n**Step 2**. Top-down approach (Recursive)\\nNow that we found out the recurrence relations, we just need to find out the base case (a place to stop recursing). This case, it would return 0 when the index gets out of index.\\n```java\\nint max;\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tmax = nums[0];\\n\\tmaxSum(nums, 0);\\n\\treturn max;\\n}\\npublic int maxSum(int[] nums, int i) {\\n\\tif (i == nums.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint res = Math.max(nums[i], nums[i] + maxSum(nums, i + 1));\\n\\tmax = Math.max(max, res);\\n\\treturn res;\\n}\\n```\\nWhile this would work for most cases, it could be done better.\\n\\n**Step 3**. Top-down approach with memoization (Still recursive)\\nThis step should be pretty trivial. Now we add some memory so that we do not try to compute subproblems that has already been solved.\\n```java\\nint max;\\nInteger[] memo;\\n\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tmax = nums[0];\\n\\tmemo = new Integer[nums.length];\\n\\tmaxSum(nums, 0);\\n\\treturn max;\\n}\\n\\npublic int maxSum(int[] nums, int i) {\\n\\tif (i == nums.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (memo[i] != null) {\\n\\t\\treturn memo[i];\\n\\t}\\n\\tint res = Math.max(nums[i], nums[i] + maxSum(nums, i + 1));\\n\\tmax = Math.max(max, res);\\n\\tmemo[i] = res;\\n\\treturn res;\\n}\\n```\\n\\n**Step 4**. Bottom-up approach (Iteration)\\nLooking at pattern above, now we can try to convert it into iteration. Time and space complexity should still be the same as step 3, but now we do not have to rely on recursion stack to solve the problem. (Also gets rid of pesky global variables)\\n```java\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);\\n\\t\\tmax = Math.max(max, dp[i]);\\n\\t}\\n\\treturn max;\\n}\\n```\\n**Step 5**. Bottom-up approach with space optimized (Iteration)\\nWhile converting it into bottom up, we notice that we are only concerned with the previous maximum element. Thus, we can simply replace an array with one variable to make the space constant!\\n```java\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint prev = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tint localMax = Math.max(nums[i], nums[i] + prev);\\n\\t\\tmax = Math.max(max, localMax);\\n\\t\\tprev = localMax;\\n\\t}\\n\\treturn max;\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\nint max;\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tmax = nums[0];\\n\\tmaxSum(nums, 0);\\n\\treturn max;\\n}\\npublic int maxSum(int[] nums, int i) {\\n\\tif (i == nums.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint res = Math.max(nums[i], nums[i] + maxSum(nums, i + 1));\\n\\tmax = Math.max(max, res);\\n\\treturn res;\\n}\\n```\n```java\\nint max;\\nInteger[] memo;\\n\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tmax = nums[0];\\n\\tmemo = new Integer[nums.length];\\n\\tmaxSum(nums, 0);\\n\\treturn max;\\n}\\n\\npublic int maxSum(int[] nums, int i) {\\n\\tif (i == nums.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (memo[i] != null) {\\n\\t\\treturn memo[i];\\n\\t}\\n\\tint res = Math.max(nums[i], nums[i] + maxSum(nums, i + 1));\\n\\tmax = Math.max(max, res);\\n\\tmemo[i] = res;\\n\\treturn res;\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);\\n\\t\\tmax = Math.max(max, dp[i]);\\n\\t}\\n\\treturn max;\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint prev = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tint localMax = Math.max(nums[i], nums[i] + prev);\\n\\t\\tmax = Math.max(max, localMax);\\n\\t\\tprev = localMax;\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561904,
                "title": "easiest-java-solution-o-n-2-lines-in-1-loop",
                "content": "This code is fairly simple:\\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n    sum += nums[i];\\n    if(sum > max)\\n        max = sum;\\n    if(sum < 0)\\n        sum = 0;\\n}\\nreturn max;\\n```\\nThe reasoning behind this is fairly straight forward. \\nThe first line of the loop is increasing our sum. \\nThe first `if-statement` is checking to see if it\\'s the best we\\'ve found so far\\nThe second `if-statement` is checking if the sum is less than 0. If it is, it\\'s better to discard whatever we have so far, and start fresh from 0. A negative number + `x` will always be less than `x`. \\n\\nThese can be shortened further if you wish to be like so:\\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n    sum += nums[i];\\n    max = Math.max(sum, max);\\n    sum = Math.max(sum, 0);\\n}\\nreturn max;\\n```\\nLastly, here\\'s a java tip:\\nThe return value of an assignment operation is the value that was assigned. This allows for some more shortening of the code to the following:\\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n        max = Math.max(sum+=nums[i], max);\\n        sum = Math.max(sum, 0);\\n}\\nreturn max;\\n```\\n`sum += nums[i]` is usually a line all by itself, but because it\\'s an assignment operation, it also has a return value that is equal to the value assigned. This allows you to both assign a value AND use the value immediately. \\nFor example:\\n`(i=1)==1` -> always true because `1 == 1`\\n`(sum = sum + nums[i]) > nums[i]` is true only if `sum` was non-negative beforehand. \\nThe += operation is shorthand for something like the line directly above where something is added to a variable and then stored back in that same variable.",
                "solutionTags": [],
                "code": "```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n    sum += nums[i];\\n    if(sum > max)\\n        max = sum;\\n    if(sum < 0)\\n        sum = 0;\\n}\\nreturn max;\\n```\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n    sum += nums[i];\\n    max = Math.max(sum, max);\\n    sum = Math.max(sum, 0);\\n}\\nreturn max;\\n```\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n        max = Math.max(sum+=nums[i], max);\\n        sum = Math.max(sum, 0);\\n}\\nreturn max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1553058,
                "title": "53-maximum-subarray-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = nums[0];\\n        for(int i=0; i<nums.length; i++){\\n            sum += nums[i];\\n            if(sum > max){\\n                max = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = nums[0];\\n        for(int i=0; i<nums.length; i++){\\n            sum += nums[i];\\n            if(sum > max){\\n                max = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562046,
                "title": "simple-5-lines-o-n-solution-in-c-using-kadane-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum=nums[0], sum=nums[0];\\n        for(int i=1; i<nums.size(); i++) {\\n            sum = max(nums[i], sum+nums[i]);\\n            if(sum>max_sum) {\\n                max_sum=sum;\\n            }\\n        }\\n        \\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum=nums[0], sum=nums[0];\\n        for(int i=1; i<nums.size(); i++) {\\n            sum = max(nums[i], sum+nums[i]);\\n            if(sum>max_sum) {\\n                max_sum=sum;\\n            }\\n        }\\n        \\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20294,
                "title": "evolve-from-brute-force-to-optimal-a-review-of-all-solutions",
                "content": "1. O(n^2), try all subarrays\\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++) {\\n            int s=0;\\n            for(int j=i;j<n;j++) {\\n                s+=nums[j];\\n                ma = max(ma, s);\\n            }    \\n        }\\n        return ma;\\n    }\\n```\\n2. O(nlogn) Naive divide and conquer. the max subarray is the max of the left, right, and the one that spans the boundary.\\n```\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(0,nums.size()-1,nums);\\n    }\\n    int maxSubArray(int l, int r, vector<int>& nums) {\\n        if(l==r) return nums[l];\\n        int mid= (l+r)/2;\\n        int ms=maxSubArray(l,mid,nums);\\n        ms=max(ms,maxSubArray(mid+1,r,nums));\\n        int pre=0, ml=INT_MIN;\\n        for(int i=mid;i>=l;i--) {\\n            pre+=nums[i];\\n            ml=max(ml,pre);\\n        }\\n        pre=0;\\n        int mr=INT_MIN;\\n        for(int i=mid+1;i<=r;i++) {\\n            pre+=nums[i];\\n            mr=max(mr,pre);\\n        }\\n        return max(ms,ml+mr);\\n    }\\n```\\n3. O(n) recursion. For sub array/string problems, it is natrual to enumerate all sub arrays/strings first as in #1 and then optimize it. However, there seems no obvious way to improve over #1. In this case, we can try enumerate all start positions. \\n```\\n\\tint max=Integer.MIN_VALUE;\\n    public int maxSubArray(int[] nums) {\\n        maxSubArray(0,nums);\\n        return max;\\n    }\\n    private int maxSubArray(int i, int[] nums) {\\n        if(i==nums.length) return 0;\\n        int nxt=maxSubArray(i+1,nums), sum=nxt>0?nxt+nums[i]:nums[i];\\n        max=Math.max(max,sum);\\n        return sum;\\n    }\\n```\\n4. O(n), dp, as in #3, the tricky part is we are not creating recursive formular to solve max subarray directly. The recursive relation solves max subarray starting at i but the max subarray can be computed along the way. f(i)=max(nums[i], nums[i] + f(i+1))\\n* java\\n```\\n\\tpublic int maxSubArray(int[] nums) {\\n        int max=Integer.MIN_VALUE, pre=0;\\n        for(int num:nums) {\\n            pre = pre>0?pre+num:num;\\n            max = Math.max(max, pre);\\n        }\\n        return max;\\n    }\\n```\\n* c++\\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int pre =0, ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++) {\\n            pre = pre>0? pre+nums[i]:nums[i];\\n            ma= max(ma,pre);\\n        }\\n        return ma;\\n    }\\n```\\n5. O(n) divide and conquer, the max subarray starting and ending at the boundary can be computed at the leaves and passed up. Idea is from [@wyattliu ](https://discuss.leetcode.com/topic/25396/c-an-clear-o-n-divide-and-conquer-solution-with-comments)\\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int ml, mr, sum;\\n        return maxSubArray(0,nums.size()-1, ml, mr, sum, nums);\\n    }\\n    int maxSubArray(int l, int r, int& ml, int& mr, int& sum, vector<int>& nums) {\\n        if(l==r) return ml = mr = sum = nums[l];\\n        int mid= (l+r)/2, lml, lmr, lsum, rml, rmr, rsum;\\n        int ms=maxSubArray(l,mid,lml,lmr,lsum,nums);\\n        ms=max(ms,maxSubArray(mid+1,r,rml,rmr,rsum,nums));\\n        ml = max(lml, lsum+rml);\\n        mr = max(rmr, rsum+lmr);\\n        sum = lsum+rsum;\\n        return max(ms,lmr+rml);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++) {\\n            int s=0;\\n            for(int j=i;j<n;j++) {\\n                s+=nums[j];\\n                ma = max(ma, s);\\n            }    \\n        }\\n        return ma;\\n    }\\n```\n```\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(0,nums.size()-1,nums);\\n    }\\n    int maxSubArray(int l, int r, vector<int>& nums) {\\n        if(l==r) return nums[l];\\n        int mid= (l+r)/2;\\n        int ms=maxSubArray(l,mid,nums);\\n        ms=max(ms,maxSubArray(mid+1,r,nums));\\n        int pre=0, ml=INT_MIN;\\n        for(int i=mid;i>=l;i--) {\\n            pre+=nums[i];\\n            ml=max(ml,pre);\\n        }\\n        pre=0;\\n        int mr=INT_MIN;\\n        for(int i=mid+1;i<=r;i++) {\\n            pre+=nums[i];\\n            mr=max(mr,pre);\\n        }\\n        return max(ms,ml+mr);\\n    }\\n```\n```\\n\\tint max=Integer.MIN_VALUE;\\n    public int maxSubArray(int[] nums) {\\n        maxSubArray(0,nums);\\n        return max;\\n    }\\n    private int maxSubArray(int i, int[] nums) {\\n        if(i==nums.length) return 0;\\n        int nxt=maxSubArray(i+1,nums), sum=nxt>0?nxt+nums[i]:nums[i];\\n        max=Math.max(max,sum);\\n        return sum;\\n    }\\n```\n```\\n\\tpublic int maxSubArray(int[] nums) {\\n        int max=Integer.MIN_VALUE, pre=0;\\n        for(int num:nums) {\\n            pre = pre>0?pre+num:num;\\n            max = Math.max(max, pre);\\n        }\\n        return max;\\n    }\\n```\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int pre =0, ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++) {\\n            pre = pre>0? pre+nums[i]:nums[i];\\n            ma= max(ma,pre);\\n        }\\n        return ma;\\n    }\\n```\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int ml, mr, sum;\\n        return maxSubArray(0,nums.size()-1, ml, mr, sum, nums);\\n    }\\n    int maxSubArray(int l, int r, int& ml, int& mr, int& sum, vector<int>& nums) {\\n        if(l==r) return ml = mr = sum = nums[l];\\n        int mid= (l+r)/2, lml, lmr, lsum, rml, rmr, rsum;\\n        int ms=maxSubArray(l,mid,lml,lmr,lsum,nums);\\n        ms=max(ms,maxSubArray(mid+1,r,rml,rmr,rsum,nums));\\n        ml = max(lml, lsum+rml);\\n        mr = max(rmr, rsum+lmr);\\n        sum = lsum+rsum;\\n        return max(ms,lmr+rml);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1779660,
                "title": "python-simple-python-solution-using-kadane-algorithm",
                "content": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef maxSubArray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tmax_sum = -1000000000000000\\n\\n\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tcurrent_sum = current_sum + num\\n\\n\\t\\t\\t\\tmax_sum = max(max_sum , current_sum)\\n\\n\\t\\t\\t\\tif current_sum < 0:\\n\\n\\t\\t\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\treturn max_sum\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef maxSubArray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tmax_sum = -1000000000000000\\n\\n\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tcurrent_sum = current_sum + num\\n\\n\\t\\t\\t\\tmax_sum = max(max_sum , current_sum)\\n\\n\\t\\t\\t\\tif current_sum < 0:\\n\\n\\t\\t\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\treturn max_sum\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 185856,
                "title": "explanation-of-the-o-n-solution-in-python",
                "content": "The O(n) solution to this problem is a reduction algorithm that uses a key observation:\n\n**If the first *n* elements of an array have a negative sum, those elements either contain the optimal subarray or are not part of the optimal solution.**\n\nConsider a list: \n\n**[-5, 3, 2, -10, 4, 8, 1]**\n\nIt is intuitive that the sum of the array equals the *value of the first element* plus the *sum of all the other elements*. Since the value of the first element is negative, it can only detract from the total sum, so we can safely \"discard\" the first element:\n\n**[3, 2, -10, 4, 8 1]**\n\nHowever, to generalize this to deal with positive numbers, we have to \"reduce\" the array. We can do this by reducing the first *n* elements to the sum of the first *n* elements, then discarding the first element when it becomes negative.\n\nHere's what that looks like:\n1. **[3, 2, -10, 4, 8 1] -- sum = array[0] -> 3, max sum -> 3**\n2. **[5, -10, 4, 8 1] -- sum += array[1] -> 5, max sum -> 5**\n3. **[-5, 4, 8 1] -- sum += array[2] -> -5, max_sum -> 5** \n\nSince the \"first element\" is now negative, we can safely discard it and start anew. This means resetting the value of sum to be 0.\n\n4. **[4, 8 1] -- sum = array[0] -> 4, max sum -> 5**\n5. **[12, 1] -- sum += array[1] -> 12, max sum -> 12**\n6. **[13] -- sum += array[2] -> 13, max sum -> 13**\n\nIn the implementation, we don't delete elements of the list--rather, we just move our pointer forward, forget about the previous element, and use the current sum as the \"first\" element.\n\nCode:\n```\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_sum, cur_sum = max(nums), 0\n        for num in nums:\n            cur_sum += num\n            max_sum = max(max_sum, cur_sum)\n            if cur_sum < 0:\n                cur_sum = 0\n        return max_sum",
                "solutionTags": [],
                "code": "The O(n) solution to this problem is a reduction algorithm that uses a key observation:\n1. **[3, 2, -10, 4, 8 1] -- sum = array[0] -> 3, max sum -> 3**\n2. **[5, -10, 4, 8 1] -- sum += array[1] -> 5, max sum -> 5**\n3. **[-5, 4, 8 1] -- sum += array[2] -> -5, max_sum -> 5** \n4. **[4, 8 1] -- sum = array[0] -> 4, max sum -> 5**\n5. **[12, 1] -- sum += array[1] -> 12, max sum -> 12**\n6. **[13] -- sum += array[2] -> 13, max sum -> 13**\nclass Solution(object):\n    def maxSubArray(self, nums):\n        max_sum, cur_sum = max(nums), 0\n            cur_sum += num\n            max_sum = max(max_sum, cur_sum)\n                cur_sum = 0",
                "codeTag": "Java"
            },
            {
                "id": 1227240,
                "title": "c-very-easy-code-100-faster",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector <int>& nums) {\\n        int sum=nums[0],maxi=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n             sum=std::max(nums[i],sum+nums[i]);\\n           maxi=std::max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/cf27bf5e-d004-4e64-a76e-c7ed6d522292_1621838771.333952.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector <int>& nums) {\\n        int sum=nums[0],maxi=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n             sum=std::max(nums[i],sum+nums[i]);\\n           maxi=std::max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880966,
                "title": "python3-kadane-s-algorithm-explained",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n\\t\\n        local_max = -pow(10, 4)         # as per provided constraints\\n        global_max = -pow(10, 4)        # as per provided constraints\\n        \\n        for i in range(len(nums)):\\n            local_max = max(nums[i], nums[i] + local_max)\\n            if local_max > global_max:\\n                global_max = local_max\\n        \\n        return global_max\\n            \\n```\\n\\nFirst, let us check why we are preferring **Kadane\\'s algorithm** over **Divide and Conquer** :\\n\\n\\t\\t\\t\\t\\t\\tApproach                      Time Complexity         Space Complexity\\n\\t---------------------------------------------------------------------------------------------\\n\\t   Kadane\\'s Algorithm (Dynamic Programming)            O(n)                     O(1)\\n\\t   Divide and Conquer                                  O(n)                     O(n)\\n\\nKadane\\u2019s algorithm is able to find the maximum sum of a contiguous subarray in an array with a **Time Complexity of O(n)** and **Space Complexity of O(1)** unlike Divide and Conquer.\\n\\nAn important property of **Dynamic Programming** is that **results of past computations are remembered** and used to build the optimal solution i.e. remembering the results of sub-problems (memoization).\\n\\nKadane\\'s algorithm originates from the same property, thus it can be considered as Dynamic Programming.\\n\\nKadane\\'s algorithm: **local_maximum at index i is the maximum of arr[i] and the sum of arr[i] and local_maximum at index i-1.**\\n        \\n        local_maximum[i] = max(arr[i], arr[i] + local_maximum[i-1])\\n\\n**This Problem :**\\n\\nNormally, we can find all possible subarrays by placing i at each element, and iterating j over all other elements while calculating and comparing the values of sum of the subarrays.\\n\\nInspired from Kadane\\'s algorithm, instead of the above approach we can place i at each element, calculate maximum value of sum upto that element and store it in local_maximum; so that when we move i to the next element, we already have the maximum sum that is possible until that element, now the current/next possible maximum sum can either be one of:\\n\\t\\t**1)** sum of the current ith element and previously existing value of local_maximum\\n\\t\\t**2)** only the value of current ith element\\n        whichever is **greater**.\\n\\nTherefore, everytime **local_maximum = max(arr[i], arr[i] + local_maximum)**, and **global_maximum = local_maximum when current local_maximum is greater than exisiting global_maximum**.\\n\\nWe see that arr[i], i.e. the current ith element is always included while calculating the local_maximum, this is because we cannot skip one element and add the later subarray with the earlier local_maximum subarray (even if it would give us a greater value of sum) as that will not form a contiguous subarray (which is our aim here).\\n\\n**Upvote** if the solution and explanation were **helpful** :)\\n\\nReferences :\\n1. https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n\\t\\n        local_max = -pow(10, 4)         # as per provided constraints\\n        global_max = -pow(10, 4)        # as per provided constraints\\n        \\n        for i in range(len(nums)):\\n            local_max = max(nums[i], nums[i] + local_max)\\n            if local_max > global_max:\\n                global_max = local_max\\n        \\n        return global_max\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 462212,
                "title": "c-sliding-window",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tif(nums.size()==0) return 0;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tint res=INT_MIN;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\t\\tcur+=nums[i];\\n\\t\\t\\t\\tif(cur<nums[i]){\\n\\t\\t\\t\\t\\tcur=nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres=max(cur,res);\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tif(nums.size()==0) return 0;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tint res=INT_MIN;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\t\\tcur+=nums[i];\\n\\t\\t\\t\\tif(cur<nums[i]){\\n\\t\\t\\t\\t\\tcur=nums[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1680930,
                "title": "python-simple-solution-o-n-time-explained",
                "content": "**Approach**\\n\\tHere, we can obviously generate all the subarrays of nums and find the maximum array like that. However, that will give us O(n^2) which is not what we are looking for in this case. We want to do this in one pass which leads us to the current solution. The goal is to iterate the list and, for every element, we want to see if it is more advantageous to keep the current contiguous line going, or if it is better to start a new contiguous line at the current element. Finally, by keeping track of the largest sum thus far, we will reach our final answer.\\n**Code Breakdown**\\n\\tWe can initialize both the currSum and maxSum to the first element because that will be the first contiguous line. Then, as we are iterating, we will update the currSum to be the maximum between currVal and currVal + currSum. This tells us if it is more adventagous to start a new line at the current element or continue with the previous line. As an example, with [4,-5,10] as nums and 10 as currVal, we want to start a new line starting at 10 rather than continuing the previous subarray [4,-5]. This is because the subarray [4,-5,10] is smaller than the subarray [10].\\n\\tFinally, we can track the maxSum which is the max of the currSum and maxSum so far.\\n**Big O Breakdown**\\nThis is O(n) because we are only looking at each element in the list one time, and every calculation in the list is O(1).\\n\\nLeave a like if it helped! Let me know if you have any questions/things to add!\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        currSum = maxSum = nums[0]\\n        for i in range(1,len(nums)):\\n            currVal = nums[i]\\n            currSum = max(currVal, currSum + currVal)\\n            maxSum = max(currSum, maxSum)\\n        return maxSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        currSum = maxSum = nums[0]\\n        for i in range(1,len(nums)):\\n            currVal = nums[i]\\n            currSum = max(currVal, currSum + currVal)\\n            maxSum = max(currSum, maxSum)\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20388,
                "title": "share-my-3-lines-python-solution",
                "content": "    class Solution(object):\\n        def maxSubArray(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            for i in xrange(1,len(nums)):\\n                    nums[i] = max(nums[i - 1] + nums[i], nums[i])\\n            return max(nums)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    class Solution(object):\\n        def maxSubArray(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            for i in xrange(1,len(nums)):\\n                    nums[i] = max(nums[i - 1] + nums[i], nums[i])\\n            return max(nums)",
                "codeTag": "Java"
            },
            {
                "id": 1890617,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction maxSubArray(nums: number[]): number {\\n  let local = 0\\n  let global = -Infinity\\n\\n  for (const num of nums) {\\n    local = Math.max(num, local + num)\\n    if (local > global) { global = local }\\n  }\\n\\n  return global\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction maxSubArray(nums: number[]): number {\\n  let local = 0\\n  let global = -Infinity\\n\\n  for (const num of nums) {\\n    local = Math.max(num, local + num)\\n    if (local > global) { global = local }\\n  }\\n\\n  return global\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981146,
                "title": "java-approach-recursive-dp-kadane-divide-and-conquer",
                "content": "**Recursive**\\n* Base case: if `nums[index]` reached the end then `maxSoFar` will be the `nums[index]`\\n* recursive case: compare the current `nums[index]` with the sum of  current `nums[index]` from recursion output of the next `index+1`\\n* compute `maxOverall` and return at the end\\n```\\nclass Solution {\\n\\t private int maxOverall = Integer.MIN_VALUE;\\n     protected int recurse(int[] nums, int index){\\n         int maxSoFar = 0;\\n         if (index == nums.length-1)\\n             maxSoFar = nums[index];\\n         else\\n             maxSoFar = Math.max(nums[index], nums[index] + recurse(nums, index+1));\\n         maxOverall = Math.max(maxOverall, maxSoFar);\\n         return maxSoFar;\\n     }\\n    \\n     public int maxSubArray(int[] nums) {\\n         recurse(nums, 0);\\n         return maxOverall;\\n       }\\n}\\n```\\n**Bottom Up - DP**\\n* just converting the logic to `dp` array with recurrence of `maxSoFar = max(nums[i], nums[i] + dp[i-1])`\\n```\\nclass Solution {\\n public int maxSubArray(int[] nums) {\\n        int length = nums.length;\\n        int[] dp = new int[length];\\n        dp[0] = nums[0];\\n        int maxOverall = dp[0];\\n        for (int i=1;i<length;i++){\\n            dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);\\n            maxOverall = Math.max(maxOverall, dp[i]);\\n        }\\n        return maxOverall;\\n    }\\n}\\n```\\n**Kadane**\\n```\\nclass Solution {\\npublic int maxSubArray(int[] nums) {\\n         int max = nums[0];\\n         int maxOverall = nums[0];\\n          for (int i=1;i<nums.length;i++){\\n              max = Math.max(nums[i], max + nums[i]);\\n              maxOverall = Math.max(maxOverall, max);\\n          }\\n         return maxOverall;\\n    }\\n}\\n```\\n**Divide and Conquer**\\n```\\nprotected int helper(int[] nums, int start, int mid , int end){\\n        int lSum = Integer.MIN_VALUE;\\n        int rSum = Integer.MIN_VALUE;\\n        \\n        int sum = 0;\\n        for (int i=mid;i>=start;i--){\\n            sum += nums[i];\\n            lSum = Math.max(sum , lSum);\\n        }\\n            \\n        sum = 0;\\n        for (int i=mid+1;i<=end;i++){\\n            sum += nums[i];\\n            rSum = Math.max(sum, rSum);\\n        }\\n            \\n        return lSum + rSum;\\n        \\n    }\\n    protected int helper(int[] nums, int start, int end){\\n        if (start == end)\\n            return nums[start];\\n        int mid = start + (end - start ) / 2 ;\\n        int left = helper(nums, start, mid);\\n        int right = helper(nums, mid+1, end);\\n        int both = helper(nums, start, mid , end);\\n        return Math.max(left, Math.max(right, both));\\n        \\n    }\\n    public int maxSubArray(int[] nums) {\\n        return helper(nums, 0, nums.length - 1);    \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\t private int maxOverall = Integer.MIN_VALUE;\\n     protected int recurse(int[] nums, int index){\\n         int maxSoFar = 0;\\n         if (index == nums.length-1)\\n             maxSoFar = nums[index];\\n         else\\n             maxSoFar = Math.max(nums[index], nums[index] + recurse(nums, index+1));\\n         maxOverall = Math.max(maxOverall, maxSoFar);\\n         return maxSoFar;\\n     }\\n    \\n     public int maxSubArray(int[] nums) {\\n         recurse(nums, 0);\\n         return maxOverall;\\n       }\\n}\\n```\n```\\nclass Solution {\\n public int maxSubArray(int[] nums) {\\n        int length = nums.length;\\n        int[] dp = new int[length];\\n        dp[0] = nums[0];\\n        int maxOverall = dp[0];\\n        for (int i=1;i<length;i++){\\n            dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);\\n            maxOverall = Math.max(maxOverall, dp[i]);\\n        }\\n        return maxOverall;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic int maxSubArray(int[] nums) {\\n         int max = nums[0];\\n         int maxOverall = nums[0];\\n          for (int i=1;i<nums.length;i++){\\n              max = Math.max(nums[i], max + nums[i]);\\n              maxOverall = Math.max(maxOverall, max);\\n          }\\n         return maxOverall;\\n    }\\n}\\n```\n```\\nprotected int helper(int[] nums, int start, int mid , int end){\\n        int lSum = Integer.MIN_VALUE;\\n        int rSum = Integer.MIN_VALUE;\\n        \\n        int sum = 0;\\n        for (int i=mid;i>=start;i--){\\n            sum += nums[i];\\n            lSum = Math.max(sum , lSum);\\n        }\\n            \\n        sum = 0;\\n        for (int i=mid+1;i<=end;i++){\\n            sum += nums[i];\\n            rSum = Math.max(sum, rSum);\\n        }\\n            \\n        return lSum + rSum;\\n        \\n    }\\n    protected int helper(int[] nums, int start, int end){\\n        if (start == end)\\n            return nums[start];\\n        int mid = start + (end - start ) / 2 ;\\n        int left = helper(nums, start, mid);\\n        int right = helper(nums, mid+1, end);\\n        int both = helper(nums, start, mid , end);\\n        return Math.max(left, Math.max(right, both));\\n        \\n    }\\n    public int maxSubArray(int[] nums) {\\n        return helper(nums, 0, nums.length - 1);    \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20472,
                "title": "kadane-s-algo-5-line-algo",
                "content": "class Solution \\n{\\n public:\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=nums[0],lgsum=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            sum=max(nums[i],sum+nums[i]);\\n            lgsum=max(lgsum,sum);\\n        }\\n        return lgsum;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{\\n public:\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=nums[0],lgsum=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            sum=max(nums[i],sum+nums[i]);\\n            lgsum=max(lgsum,sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1595497,
                "title": "python-2-solutions-explained",
                "content": "#### Solution 1\\nWe can easily do it with DP in `O(n)` time. Define by `dp[i]` maximum sum ending with element with index `i`. Then we have two options: either continue subarray or take single element. \\n\\n#### Complexity\\nTime and space is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\\n        return max(dp)\\n```\\n\\n#### Solution 2 \\nAlso there is divide and conquer solution where we split array into two parts.\\n\\n#### Complexity\\nIt is `O(n log n)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def helper(beg, end):\\n            if beg + 1 == end: return nums[beg]\\n            mid = (beg + end)//2\\n            sum_1 = helper(beg, mid)\\n            sum_2 = helper(mid, end)\\n            right = max(accumulate(nums[beg:mid][::-1]))\\n            left  = max(accumulate(nums[mid:end]))\\n            return max(sum_1, sum_2, left + right)\\n\\n        return helper(0, len(nums))\\n``` \\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\\n        return max(dp)\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def helper(beg, end):\\n            if beg + 1 == end: return nums[beg]\\n            mid = (beg + end)//2\\n            sum_1 = helper(beg, mid)\\n            sum_2 = helper(mid, end)\\n            right = max(accumulate(nums[beg:mid][::-1]))\\n            left  = max(accumulate(nums[mid:end]))\\n            return max(sum_1, sum_2, left + right)\\n\\n        return helper(0, len(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563106,
                "title": "python-simple-and-short-solution",
                "content": "**Python :**\\n\\n```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n\\tcurrent_max = nums[0]\\n\\tmax_sum = nums[0]\\n\\n\\tfor i in nums[1:]:\\n\\t\\tcurrent_max = max(i, current_max + i)\\n\\t\\tmax_sum = max(max_sum, current_max)\\n\\n\\treturn max_sum\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n\\tcurrent_max = nums[0]\\n\\tmax_sum = nums[0]\\n\\n\\tfor i in nums[1:]:\\n\\t\\tcurrent_max = max(i, current_max + i)\\n\\t\\tmax_sum = max(max_sum, current_max)\\n\\n\\treturn max_sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 764810,
                "title": "from-brute-force-to-dp-to-kadane-s-alogrithm",
                "content": "\\nIn computer science, maximum subarray problem is the task to find a contiguous subarray with the largest sum. This problem was proposed by Uif Grenander in 1977. In 1984, Jay Kadane designed an O(n) algorithm to solve the problem. We call the algorithm \"Kadane\\'s algorithm\".\\n\\n## Brute-force approach\\nWe can use brute-force to calculate sum of all possible subarray, and then get the maximum sum. Time complexity of brute-force solution will be O(n^3).\\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSum = nums[0];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                int currSum = 0;\\n                \\n                for(int k = i; k <= j; k++)\\n                {\\n                    currSum += nums[k];\\n                }\\n                \\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n\\nThe brute-force solution can be improved to O(n^2) time complexity by using a variable to store the running sum at all possible positions.\\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSum = nums[0];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int currSum = 0;\\n                \\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                currSum += nums[j];\\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n\\n## Dynamic Programming approach\\nInstead of using each index as the starting position of subarray in the brute-force approach, DP approach uses each index as the ending point, so that when calculating sum of the next subarray, the algorithm can take advantage of the previous calculations. The formula is: sum[i] = sum[i-1] + nums[i]. This DP approach will improve the time complexity to O(n) and has O(n) space complexity.\\n\\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int[] dp = new int[nums.Length];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            dp[i] = Math.Max(dp[i - 1] + nums[i], nums[i]);\\n        }\\n        \\n        return dp.Max();        \\n    }\\n}\\n```\\n\\n## Kadane\\'s algorithm\\nKadane\\'s algorithm is implemented on top of the DP approach. It uses a local variable to track maximum sum of all subarray. This can improve the space complexity to O(1).\\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSumSoFar = nums[0], maxSumEndingHere = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            maxSumEndingHere = Math.Max(maxSumEndingHere + nums[i], nums[i]);\\n            maxSumSoFar = Math.Max(maxSumSoFar, maxSumEndingHere);\\n        }\\n        \\n        return maxSumSoFar;        \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSum = nums[0];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                int currSum = 0;\\n                \\n                for(int k = i; k <= j; k++)\\n                {\\n                    currSum += nums[k];\\n                }\\n                \\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSum = nums[0];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int currSum = 0;\\n                \\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                currSum += nums[j];\\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int[] dp = new int[nums.Length];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            dp[i] = Math.Max(dp[i - 1] + nums[i], nums[i]);\\n        }\\n        \\n        return dp.Max();        \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSumSoFar = nums[0], maxSumEndingHere = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            maxSumEndingHere = Math.Max(maxSumEndingHere + nums[i], nums[i]);\\n            maxSumSoFar = Math.Max(maxSumSoFar, maxSumEndingHere);\\n        }\\n        \\n        return maxSumSoFar;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193128,
                "title": "c-solution-beats-100-optimized-tc-o-n-kadane-s-algorithm",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Explanation:**\\n\\n* Set maximum to the minimum number (INT_MIN) because there may be a array filled with only negative elements, therefore we want to take the maximum value out of the elements present.\\n\\n* Initialize sum = 0.\\n\\n* Traverse through the array and add the current element to the sum.\\n\\n* If the sum is greater then the maximum sum, assign the new sum to the maximum.\\n\\n* If the current sum is less than zero - reset the sum to 0.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum = 0;\\n        int maximum = INT_MIN;\\n        \\n//         for(int i=0; i<nums.size();i++)\\n//         {\\n//             sum += nums[i];\\n            \\n//             if(maximum<sum)\\n//                 maximum = sum;\\n            \\n//             if(sum<0)\\n//                 sum=0;\\n//         }\\n        \\n        // Using iterator for traversal ( iterator is always faster )\\n        for(auto i : nums)\\n        {\\n            sum += i;\\n            \\n            maximum = max(maximum,sum);\\n            \\n            if(sum<0)\\n                sum = 0;\\n        }\\n        \\n        return maximum;\\n    }\\n};\\n```\\n\\nTC -> `O(n)`\\nSc -> `O(1)`",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum = 0;\\n        int maximum = INT_MIN;\\n        \\n//         for(int i=0; i<nums.size();i++)\\n//         {\\n//             sum += nums[i];\\n            \\n//             if(maximum<sum)\\n//                 maximum = sum;\\n            \\n//             if(sum<0)\\n//                 sum=0;\\n//         }\\n        \\n        // Using iterator for traversal ( iterator is always faster )\\n        for(auto i : nums)\\n        {\\n            sum += i;\\n            \\n            maximum = max(maximum,sum);\\n            \\n            if(sum<0)\\n                sum = 0;\\n        }\\n        \\n        return maximum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520747,
                "title": "java-tc-o-n-sc-o-1-kadane-s-algorithm-optimal-dp-solution",
                "content": "```java\\n/**\\n * Kadane\\'s Algorithm.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int maxEndingHere = nums[0];\\n        int maxSoFar = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            /**\\n             * maxEndingHere + nums[i] --> Adding the current number to previous SubArray\\n             * nums[i] -> Starting a new SubArray with just this element. This will be max in case above value is negative or zero\\n             *\\n             * maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i];\\n             */\\n            maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);\\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\\n        }\\n\\n        return maxSoFar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```java\\n/**\\n * Kadane\\'s Algorithm.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int maxEndingHere = nums[0];\\n        int maxSoFar = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            /**\\n             * maxEndingHere + nums[i] --> Adding the current number to previous SubArray\\n             * nums[i] -> Starting a new SubArray with just this element. This will be max in case above value is negative or zero\\n             *\\n             * maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i];\\n             */\\n            maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);\\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\\n        }\\n\\n        return maxSoFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353578,
                "title": "java-solution-3-optimal-approaches",
                "content": "**Approach 1:  using Kadane\\'s algorithm\\nBig O analysis - O(N) Time | O(1) Space**\\n```\\npublic int maxSubArray(int[] nums) {\\n\\n\\tint maxsum = Integer.MIN_VALUE;\\n\\tint currsum = 0;\\n\\n\\tfor (int n : nums) {\\n\\n\\t\\tcurrsum += n;\\n\\t\\tmaxsum = Math.max(currsum, maxsum);\\n\\n\\t\\tif (currsum < 0)\\n\\t\\t\\tcurrsum = 0;\\n\\t}\\n\\n\\treturn maxsum;        \\n}\\n```\\n\\n**Approach 2: using Dynamic Programming \\nComplexity analysis - O(N) Time | O(N) Space**\\n```\\npublic int maxSubArray(int[] nums) {\\n\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = nums[0];\\n\\n\\tint maxsum = nums[0];\\n\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + dp[i-1]);\\n\\n\\t\\tmaxsum = Math.max(maxsum, dp[i]);\\n\\t}\\n\\n\\treturn maxsum;\\n}   \\n```\\n**Approach 3: using divide and conquer**\\n```\\nprivate int[] numsArr; // global reference\\n\\npublic int maxSubArray(int[] nums) {\\n\\tnumsArr = nums;\\n\\treturn findMaxSubarray(0, numsArr.length - 1);\\n}\\n\\n// helper recusive method\\nprivate int findMaxSubarray(int left, int right) {\\n\\n\\tif (left > right)\\n\\t\\treturn Integer.MIN_VALUE;\\n\\n\\tint mid = left + (right - left) / 2;\\n\\tint currSum = 0;\\n\\tint leftMaxSum = 0, rightMaxSum = 0;\\n\\n\\t// finding max subarray sum in left half\\n\\tfor (int i = mid - 1; i >= left; i--) {\\n\\t\\tcurrSum += numsArr[i];\\n\\t\\tleftMaxSum = Math.max(leftMaxSum, currSum);\\n\\t}\\n\\n\\t// finding in right half\\n\\tcurrSum = 0;\\n\\tfor (int i = mid + 1; i <= right; i++) {\\n\\t\\tcurrSum += numsArr[i];\\n\\t\\trightMaxSum = Math.max(rightMaxSum, currSum);\\n\\t}\\n\\n\\t// considering middle element also\\n\\tint combinedSum = numsArr[mid] + leftMaxSum + rightMaxSum;\\n\\n\\tint leftHalfSum = findMaxSubarray(left, mid - 1);\\n\\tint rightHalfSum = findMaxSubarray(mid + 1, right);\\n\\n\\tint result = Math.max(combinedSum, Math.max(leftHalfSum, rightHalfSum));\\n\\n\\treturn result;\\n\\t}    \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int maxSubArray(int[] nums) {\\n\\n\\tint maxsum = Integer.MIN_VALUE;\\n\\tint currsum = 0;\\n\\n\\tfor (int n : nums) {\\n\\n\\t\\tcurrsum += n;\\n\\t\\tmaxsum = Math.max(currsum, maxsum);\\n\\n\\t\\tif (currsum < 0)\\n\\t\\t\\tcurrsum = 0;\\n\\t}\\n\\n\\treturn maxsum;        \\n}\\n```\n```\\npublic int maxSubArray(int[] nums) {\\n\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = nums[0];\\n\\n\\tint maxsum = nums[0];\\n\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + dp[i-1]);\\n\\n\\t\\tmaxsum = Math.max(maxsum, dp[i]);\\n\\t}\\n\\n\\treturn maxsum;\\n}   \\n```\n```\\nprivate int[] numsArr; // global reference\\n\\npublic int maxSubArray(int[] nums) {\\n\\tnumsArr = nums;\\n\\treturn findMaxSubarray(0, numsArr.length - 1);\\n}\\n\\n// helper recusive method\\nprivate int findMaxSubarray(int left, int right) {\\n\\n\\tif (left > right)\\n\\t\\treturn Integer.MIN_VALUE;\\n\\n\\tint mid = left + (right - left) / 2;\\n\\tint currSum = 0;\\n\\tint leftMaxSum = 0, rightMaxSum = 0;\\n\\n\\t// finding max subarray sum in left half\\n\\tfor (int i = mid - 1; i >= left; i--) {\\n\\t\\tcurrSum += numsArr[i];\\n\\t\\tleftMaxSum = Math.max(leftMaxSum, currSum);\\n\\t}\\n\\n\\t// finding in right half\\n\\tcurrSum = 0;\\n\\tfor (int i = mid + 1; i <= right; i++) {\\n\\t\\tcurrSum += numsArr[i];\\n\\t\\trightMaxSum = Math.max(rightMaxSum, currSum);\\n\\t}\\n\\n\\t// considering middle element also\\n\\tint combinedSum = numsArr[mid] + leftMaxSum + rightMaxSum;\\n\\n\\tint leftHalfSum = findMaxSubarray(left, mid - 1);\\n\\tint rightHalfSum = findMaxSubarray(mid + 1, right);\\n\\n\\tint result = Math.max(combinedSum, Math.max(leftHalfSum, rightHalfSum));\\n\\n\\treturn result;\\n\\t}    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366137,
                "title": "python3-dynamic-programming",
                "content": "* dp[i] represents the largest sum at index i.\\n* There are two possible stage of dp[i]:\\n\\t1. add nums[i] to previous stage: dp[i] = nums[i] +dp[i-1]\\n\\t2. don\\'t add to precious stage, we have a fresh start of the subarray: nums[i]: dp[i] = nums[i]\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        \"\"\"\\n        dp[1] = max(dp[0]+nums[1],nums[1])\\n        dp[2] = max(dp[1]+nums[2],nums[2])\\n        \"\"\"\\n        for i in range(1,len(nums)):\\n            dp[i] = max(dp[i-1] +nums[i],nums[i])\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        \"\"\"\\n        dp[1] = max(dp[0]+nums[1],nums[1])\\n        dp[2] = max(dp[1]+nums[2],nums[2])\\n        \"\"\"\\n        for i in range(1,len(nums)):\\n            dp[i] = max(dp[i-1] +nums[i],nums[i])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293318,
                "title": "c-concise-o-n-time-o-1-space-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        for (int i = 1; i < nums.Length; i++)\\n            if (nums[i - 1] + nums[i] > nums[i])\\n                nums[i] += nums[i - 1];\\n        return nums.Max();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        for (int i = 1; i < nums.Length; i++)\\n            if (nums[i - 1] + nums[i] > nums[i])\\n                nums[i] += nums[i - 1];\\n        return nums.Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293206,
                "title": "python-one-liner-using-itertools-beating-99-70",
                "content": "```\\nfrom itertools import accumulate\\n\\ndef maxSubArray(self, nums: List[int]) -> int:\\n    return max(accumulate(nums, lambda x, y: max(y, x+y) ))\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import accumulate\\n\\ndef maxSubArray(self, nums: List[int]) -> int:\\n    return max(accumulate(nums, lambda x, y: max(y, x+y) ))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 20495,
                "title": "divide-conquer-easy-to-understand",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n         \\n    \\n         def maxSubArrayHelper(self,nums, l, r):\\n            if l > r:\\n                return -2147483647\\n            m = (l+r) / 2\\n            \\n            leftMax = sumNum = 0\\n            for i in range(m - 1, l - 1, -1):\\n                sumNum += nums[i]\\n                leftMax = max(leftMax, sumNum)\\n            \\n            rightMax = sumNum = 0\\n            for i in range(m + 1, r + 1):\\n                sumNum += nums[i]\\n                rightMax = max(rightMax, sumNum)\\n                \\n            leftAns = self.maxSubArrayHelper(nums, l, m - 1)\\n            rightAns = self.maxSubArrayHelper(nums, m + 1, r)\\n                \\n            return max(leftMax + nums[m] + rightMax, max(leftAns, rightAns))\\n            \\n         def maxSubArray(self, nums):\\n            return self.maxSubArrayHelper(nums, 0, len(nums) - 1)",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 20505,
                "title": "3-4-lines-ruby-and-c",
                "content": "Walk straight over the input array. Let `best` hold the best sum found overall and `curr` hold the best sum ending with the current element. For the latter, we can either use the current element alone (that's `n`) or also use the best sum ending with the previous element (that's `curr+n`, with the previous value of `curr`).\\n\\n**Ruby:**\\n\\n    def max_sub_array(nums)\\n        best, curr = nums[0], 0\\n        nums.each { |n| best = [best, curr = [n, curr+n].max].max }\\n        best\\n    end\\n\\n**C++:**\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int best = nums[0], curr = 0;\\n        for (int n : nums)\\n            best = max(best, curr = max(n, curr+n));\\n        return best;\\n    }",
                "solutionTags": [
                    "C++",
                    "Ruby"
                ],
                "code": "Walk straight over the input array. Let `best` hold the best sum found overall and `curr` hold the best sum ending with the current element. For the latter, we can either use the current element alone (that's `n`) or also use the best sum ending with the previous element (that's `curr+n`, with the previous value of `curr`).\\n\\n**Ruby:**\\n\\n    def max_sub_array(nums)\\n        best, curr = nums[0], 0\\n        nums.each { |n| best = [best, curr = [n, curr+n].max].max }\\n        best\\n    end\\n\\n**C++:**\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int best = nums[0], curr = 0;\\n        for (int n : nums)\\n            best = max(best, curr = max(n, curr+n));\\n        return best;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2175671,
                "title": "c-easy-fast-kadane-s-algorithm-solution",
                "content": "***PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL <3\\nHAPPY CODING!***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums){\\n        int max=INT_MIN;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            n+=nums[i];\\n            if(max<n){\\n                max=n;\\n            }\\n            if(n<0){\\n                n=0;\\n            }\\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums){\\n        int max=INT_MIN;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            n+=nums[i];\\n            if(max<n){\\n                max=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1912517,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func maxSubArray(_ nums: [Int]) -> Int {\\n        var max = nums[0]\\n        var sum = 0\\n        var i = 0\\n        \\n        while i < nums.count {\\n            let num = nums[i]\\n            sum += num\\n            \\n            if sum > 0 {\\n                max = max > sum ? max : sum\\n            } else {\\n                max = max > num ? max : num\\n                sum = 0\\n            }\\n            \\n            i += 1\\n        }\\n        \\n        return max\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSubArray(_ nums: [Int]) -> Int {\\n        var max = nums[0]\\n        var sum = 0\\n        var i = 0\\n        \\n        while i < nums.count {\\n            let num = nums[i]\\n            sum += num\\n            \\n            if sum > 0 {\\n                max = max > sum ? max : sum\\n            } else {\\n                max = max > num ? max : num\\n                sum = 0\\n            }\\n            \\n            i += 1\\n        }\\n        \\n        return max\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952353,
                "title": "divide-and-conquer-explanation-c",
                "content": "### Approach 1: - Divide and Conquer\\n\\n```\\nclass Solution {\\nprivate:\\n\\tint maxSubArrayHelper(vector<int>& nums, int left, int right) {\\n\\t\\tif (left > right)\\n\\t\\t\\treturn INT_MIN;\\n\\n\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\tint maxLeft = maxSubArrayHelper(nums, left, mid - 1);\\n\\t\\tint maxRight = maxSubArrayHelper(nums, mid + 1, right);\\n\\n\\t\\tint maxLeftSum = 0, maxRightSum = 0;\\n\\t\\t//use any indication, large mininmum won\\'t burst some cases\\n\\n\\t\\tfor (int i = mid - 1, sum = 0; i >= left; i--) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxLeftSum = max(maxLeftSum, sum);\\n\\t\\t}\\n\\n\\t\\tfor (int i = mid + 1, sum = 0; i <= right; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxRightSum = max(maxRightSum, sum);\\n\\t\\t}\\n\\n\\t\\tint maxSubarrays = max(maxLeft, maxRight);\\n\\t\\tint currSubarray =  nums[mid] + maxLeftSum + maxRightSum;\\n\\n\\t\\treturn max(maxSubarrays, currSubarray);\\n\\t}\\npublic:\\n\\tint maxSubArray(vector<int>& nums) {\\n\\t\\treturn maxSubArrayHelper(nums, 0, nums.size() - 1);\\n\\t}\\n};\\n```\\n***If anything from here helps you, UpVote this so others can also get something from this...***",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tint maxSubArrayHelper(vector<int>& nums, int left, int right) {\\n\\t\\tif (left > right)\\n\\t\\t\\treturn INT_MIN;\\n\\n\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\tint maxLeft = maxSubArrayHelper(nums, left, mid - 1);\\n\\t\\tint maxRight = maxSubArrayHelper(nums, mid + 1, right);\\n\\n\\t\\tint maxLeftSum = 0, maxRightSum = 0;\\n\\t\\t//use any indication, large mininmum won\\'t burst some cases\\n\\n\\t\\tfor (int i = mid - 1, sum = 0; i >= left; i--) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxLeftSum = max(maxLeftSum, sum);\\n\\t\\t}\\n\\n\\t\\tfor (int i = mid + 1, sum = 0; i <= right; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxRightSum = max(maxRightSum, sum);\\n\\t\\t}\\n\\n\\t\\tint maxSubarrays = max(maxLeft, maxRight);\\n\\t\\tint currSubarray =  nums[mid] + maxLeftSum + maxRightSum;\\n\\n\\t\\treturn max(maxSubarrays, currSubarray);\\n\\t}\\npublic:\\n\\tint maxSubArray(vector<int>& nums) {\\n\\t\\treturn maxSubArrayHelper(nums, 0, nums.size() - 1);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20446,
                "title": "2-lines-python-solution",
                "content": "    class Solution(object):\\n    def maxSubArray(self, nums):\\n        for i in xrange(1,len(nums)):nums[i]=max(nums[i], nums[i]+nums[i-1])\\n        return max(nums)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def maxSubArray(self, nums):\\n        for i in xrange(1,len(nums)):nums[i]=max(nums[i], nums[i]+nums[i-1])\\n        return max(nums)",
                "codeTag": "Java"
            },
            {
                "id": 3520775,
                "title": "c-java-python-javascript-kadane-s-algorithm-easy-to-understand",
                "content": "# Intuition:\\nThe problem asks for finding the maximum sum of a subarray within the given array. To solve this, we can use a technique called Kadane\\'s algorithm.\\n\\n# Approach:\\n1. Initialize two variables, \"max\" and \"meh,\" to keep track of the maximum sum found so far and the sum of the current subarray, respectively. Set \"max\" to the smallest possible integer value (INT_MIN) and \"meh\" to 0.\\n2. Iterate through the input array \"nums\" from left to right.\\n3. Add the current element to \"meh\" to extend the current subarray.\\n4. If \"meh\" is greater than \"max,\" update \"max\" with the value of \"meh\" since we have found a new maximum subarray sum.\\n5. If \"meh\" becomes negative (indicating that the current subarray has a negative sum), reset \"meh\" to 0, as any negative sum would only decrease the sum of any future subarrays.\\n6. After iterating through the entire array, return the value of \"max,\" which represents the maximum subarray sum.\\n\\n# Complexity:\\n- The time complexity of this solution is O(n), where n is the size of the input array \"nums.\" We iterate through the array once.\\n- The space complexity is O(1) since we only use a constant amount of additional space to store the variables \"max\" and \"meh.\"\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        // meh \\u2013 max sum ending at ith index\\n        int max = INT_MIN, meh = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            meh = meh + nums[i];\\n            if (meh > max) {\\n                max = meh;\\n            }\\n            if (meh < 0) {\\n                meh = 0;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int meh = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            meh = meh + nums[i];\\n            if (meh > max) {\\n                max = meh;\\n            }\\n            if (meh < 0) {\\n                meh = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        max_sum = float(\\'-inf\\')\\n        meh = 0\\n        for num in nums:\\n            meh = meh + num\\n            if meh > max_sum:\\n                max_sum = meh\\n            if meh < 0:\\n                meh = 0\\n        return max_sum\\n```\\n\\n---\\n# JavaScript\\n```\\nvar maxSubArray = function(nums) {\\n    let max = -Infinity;\\n    let meh = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        meh += nums[i];\\n        if (meh > max) {\\n            max = meh;\\n        }\\n        if (meh < 0) {\\n            meh = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        // meh \\u2013 max sum ending at ith index\\n        int max = INT_MIN, meh = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            meh = meh + nums[i];\\n            if (meh > max) {\\n                max = meh;\\n            }\\n            if (meh < 0) {\\n                meh = 0;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int meh = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            meh = meh + nums[i];\\n            if (meh > max) {\\n                max = meh;\\n            }\\n            if (meh < 0) {\\n                meh = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        max_sum = float(\\'-inf\\')\\n        meh = 0\\n        for num in nums:\\n            meh = meh + num\\n            if meh > max_sum:\\n                max_sum = meh\\n            if meh < 0:\\n                meh = 0\\n        return max_sum\\n```\n```\\nvar maxSubArray = function(nums) {\\n    let max = -Infinity;\\n    let meh = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        meh += nums[i];\\n        if (meh > max) {\\n            max = meh;\\n        }\\n        if (meh < 0) {\\n            meh = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594975,
                "title": "c-divide-and-conquer-kadane-s-algo-concise-solution",
                "content": "**Most intuitive :: KADANE\\'s Algorithm  ---->>>\\n   The idea of Kadane\\u2019s algorithm is to look for all positive contiguous segments of the array (sum is used for this). And keep track of maximum sum contiguous segment among all positive segments (ans is used for this). Each time we get a positive-sum compare it with ans and update ans if it is greater than ans so far .And update sum with 0 if it becomes negative at some point because we won\\'t use that negative part in any upcoming subarrays !!\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int ans = INT_MIN;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            ans = max(sum, ans);\\n            if(sum < 0) sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\nTime complexity O(n)\\n```\\n\\n\\n    \\n####     **The follow up :: Divide and conquer  ---->>>\\nThis is one of those situations where the solution with higher Time complexity is more complex to come up with ...\\nIf we divide the the original problem into two equal parts: [0, n) -> [0, mid) & [mid, n), so the longest subarray must be in either [0, mid) or [mid, n) -- recursive to solve, but notice that it could also be cross from the two(i...mid...j), and actually it is the trivial case, which we would just add from mid to 0 and from mid to n and keep the two temp max and then add them together -- time complexity would not beyond O(n). Then, what we need to do is to choose the global biggest one from the above three.\\nT(n) reprensent the time of the original problem, we divide it into two equal parts 2*T(n/2), and O(n) for the cross case. So we could get T(n) = 2*T(n/2) + O(n) = (2^log(n))*T(1) + O(n)*log(n) = O(n*log(n)).\\n```\\nclass Solution {\\nprivate:\\n\\tint helper(vector<int>& nums, int left, int right) {\\n\\t\\tif (left > right)\\n\\t\\t\\treturn INT_MIN;\\n\\n\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\tint maxLeft_ans = helper(nums, left, mid - 1);\\n\\t\\tint maxRight_ans = helper(nums, mid + 1, right);\\n\\n\\t\\tint maxLeftSum = 0, maxRightSum = 0;\\n\\n\\t\\tfor (int i = mid - 1, sum = 0; i >= left; i--) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxLeftSum = max(maxLeftSum, sum);\\n\\t\\t}\\n\\n\\t\\tfor (int i = mid + 1, sum = 0; i <= right; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxRightSum = max(maxRightSum, sum);\\n\\t\\t}\\n\\n\\t\\tint maxSubarrays = max(maxLeft_ans, maxRight_ans);\\n\\t\\tint currSubarray =  nums[mid] + maxLeftSum + maxRightSum;\\n\\n\\t\\treturn max(maxSubarrays, currSubarray);\\n\\t}\\npublic:\\n\\tint maxSubArray(vector<int>& nums) {\\n\\t\\treturn helper(nums, 0, nums.size() - 1);\\n\\t}\\n};\\n\\n\\nTime compexity is O(n*log(n)) for T(n) = 2*T(n/2) + O(n)",
                "solutionTags": [
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int ans = INT_MIN;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            ans = max(sum, ans);\\n            if(sum < 0) sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\nTime complexity O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108980,
                "title": "thought-process-and-o-n-java-solution",
                "content": "\\nLets understand logic through analogy. \\n1. if our ancestor have some property for us we say that they are my ancestor and we take that happily.\\n2. if they have some loan then we say we are self made no relation with them..\\n\\njokes apart the key thing is if previous subarray have positive sum we will be part of that else we will start subarray from us. and maintain the overall maximum(maximum till now) and current maximum(including me whats the maximum).\\n\\n**Time : O(N) and Space :O(1)**\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int omax=nums[0];  // omax: overall maximum\\n        int cmax=nums[0]; //  cmax: current maximum\\n        \\n        for(int i=1;i<nums.length;i++){\\n            cmax=Math.max(nums[i],nums[i] + cmax);\\n            \\n            omax=Math.max(cmax,omax);\\n        }\\n        return omax;\\n    }\\n}\\n```\\nPlease **Upvote** if found it helpful :)\\nSimilar Question :[Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int omax=nums[0];  // omax: overall maximum\\n        int cmax=nums[0]; //  cmax: current maximum\\n        \\n        for(int i=1;i<nums.length;i++){\\n            cmax=Math.max(nums[i],nums[i] + cmax);\\n            \\n            omax=Math.max(cmax,omax);\\n        }\\n        return omax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290007,
                "title": "go-4-ms-100-00-easy-code",
                "content": "```\\nfunc maxSubArray(nums []int) int {\\n\\tmax, sum := nums[0],nums[0]\\n\\tfor _, v := range nums[1:] {\\n\\t\\tif sum < 0 {\\n\\t\\t\\tsum = v\\n\\t\\t} else {\\n\\t\\t\\tsum += v\\n\\t\\t}\\n\\t\\tif max < sum {\\n\\t\\t\\tmax = sum\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxSubArray(nums []int) int {\\n\\tmax, sum := nums[0],nums[0]\\n\\tfor _, v := range nums[1:] {\\n\\t\\tif sum < 0 {\\n\\t\\t\\tsum = v\\n\\t\\t} else {\\n\\t\\t\\tsum += v\\n\\t\\t}\\n\\t\\tif max < sum {\\n\\t\\t\\tmax = sum\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20487,
                "title": "python-solutions-dp-o-n-space-o-1-space",
                "content": "        \\n    # DP, O(n) space\\n    def maxSubArray(self, nums):\\n        if not nums:\\n            return None\\n        dp = [0] * len(nums)\\n        res = dp[0] = nums[0]\\n        for i in xrange(1, len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i], nums[i])\\n            res = max(res, dp[i])\\n        return res\\n        \\n    # DP, constant space\\n    def maxSubArray2(self, nums):\\n        if not nums:\\n            return None\\n        loc = glo= nums[0]\\n        for i in xrange(1, len(nums)):\\n            loc = max(loc+nums[i], nums[i])\\n            glo = max(loc, glo)\\n        return glo",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # DP, O(n) space\\n    def maxSubArray(self, nums):\\n        if not nums:\\n            return None\\n        dp = [0] * len(nums)\\n        res = dp[0] = nums[0]\\n        for i in xrange(1, len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i], nums[i])\\n            res = max(res, dp[i])\\n        return res\\n        \\n    # DP, constant space\\n    def maxSubArray2(self, nums):\\n        if not nums:\\n            return None\\n        loc = glo= nums[0]\\n        for i in xrange(1, len(nums)):\\n            loc = max(loc+nums[i], nums[i])\\n            glo = max(loc, glo)\\n        return glo",
                "codeTag": "Python3"
            },
            {
                "id": 20509,
                "title": "o-n-time-o-1-space-dp-solution-java",
                "content": "Base case: 1 element, return nums[0]\\n\\nOther cases: \\n\\n- If dp[i-1] < 0, dp[i] = nums[i]\\n\\n- if dp[i-1] >0, dp[i] = nums[i] + dp[i-1]\\n\\nthen pick the max sum. \\n\\nWe only need dp[i-1], so i use prev to record it, the space complexity is reduced to O(1). \\n\\n    public int maxSubArray(int[] nums) {\\n        if (nums.length == 0){\\n            return 0;\\n        }\\n\\n        int prev = nums[0];\\n        int cur = nums[0];\\n        int max = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++){\\n            if (prev > 0){\\n                cur = prev + nums[i];\\n            }else{\\n                cur = nums[i];\\n            }\\n            max = Math.max(max, cur);\\n            prev = cur; \\n        }\\n        \\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Base case: 1 element, return nums[0]\\n\\nOther cases: \\n\\n- If dp[i-1] < 0, dp[i] = nums[i]\\n\\n- if dp[i-1] >0, dp[i] = nums[i] + dp[i-1]\\n\\nthen pick the max sum. \\n\\nWe only need dp[i-1], so i use prev to record it, the space complexity is reduced to O(1). \\n\\n    public int maxSubArray(int[] nums) {\\n        if (nums.length == 0){\\n            return 0;\\n        }\\n\\n        int prev = nums[0];\\n        int cur = nums[0];\\n        int max = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++){\\n            if (prev > 0){\\n                cur = prev + nums[i];\\n            }else{\\n                cur = nums[i];\\n            }\\n            max = Math.max(max, cur);\\n            prev = cur; \\n        }\\n        \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 964113,
                "title": "my-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            nums[i]=max(nums[i-1]+nums[i],nums[i])\\n        return max(nums)\\n```\\n\\n```\\nRuntime: 88 ms, faster than 7.10% of Python3 online submissions for Maximum Subarray.\\nMemory Usage: 15.1 MB, less than 5.01% of Python3 online submissions for Maximum Subarray.\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            nums[i]=max(nums[i-1]+nums[i],nums[i])\\n        return max(nums)\\n```\n```\\nRuntime: 88 ms, faster than 7.10% of Python3 online submissions for Maximum Subarray.\\nMemory Usage: 15.1 MB, less than 5.01% of Python3 online submissions for Maximum Subarray.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898149,
                "title": "javascript-solution-with-explanation",
                "content": "Runtime: 88 ms\\nMemory Usage: 39.2 MB\\n\\n```\\nvar maxSubArray = function(nums) {\\n\\t//Declare a variable for our current overall maximum sum\\n    let maxSum = nums[0];\\n\\t//Declare a temporary sum for comparison\\n    let tempSum = nums[0];\\n\\t//Iterate over nums starting at nums[1] since we set our initial sums to nums[0]\\n    for (let i = 1; i < nums.length; i++) {\\n\\t\\t//The temporary sum is either the current number if the prior tempSum was negative for example\\n\\t\\t//Or it is the sum of tempSum and the new sum if that figure is larger \\n        tempSum = Math.max(nums[i], tempSum + nums[i]);\\n\\t\\t//Every time we have a new tempSum we want to compare it to our running maxSum \\n        maxSum = Math.max(tempSum, maxSum);\\n    };\\n\\t//return the max sum\\n  return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n\\t//Declare a variable for our current overall maximum sum\\n    let maxSum = nums[0];\\n\\t//Declare a temporary sum for comparison\\n    let tempSum = nums[0];\\n\\t//Iterate over nums starting at nums[1] since we set our initial sums to nums[0]\\n    for (let i = 1; i < nums.length; i++) {\\n\\t\\t//The temporary sum is either the current number if the prior tempSum was negative for example\\n\\t\\t//Or it is the sum of tempSum and the new sum if that figure is larger \\n        tempSum = Math.max(nums[i], tempSum + nums[i]);\\n\\t\\t//Every time we have a new tempSum we want to compare it to our running maxSum \\n        maxSum = Math.max(tempSum, maxSum);\\n    };\\n\\t//return the max sum\\n  return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236505,
                "title": "simple-c-solution-o-n",
                "content": "**Solution 1**\\n```\\nint maxSubArray(int* nums, int numsSize)\\n{\\n    int i, max, tmp;\\n    \\n    for (i = 0, tmp = 0, max = nums[0]; i < numsSize; i++) {\\n        tmp += nums[i];\\n\\n        if (tmp > max)\\n            max = tmp;\\n        \\n        if (tmp < 0)\\n            tmp = 0;\\n    }\\n\\n    return max;\\n}\\n```\\n**Solution 2 - Divide and Conquer**\\n```\\nstatic int midCrossMax(int* arr, int size)\\n{\\n    int lmax, rmax, tmp, i, m = (size / 2) - 1;\\n    \\n    for (i = m, tmp = 0, lmax = arr[m]; i >= 0; i--) {\\n        tmp += arr[i];\\n        lmax = tmp > lmax ? tmp : lmax;\\n    }\\n    \\n    for (i = m + 1, tmp = 0, rmax = arr[m + 1]; i < size; i++) {\\n        tmp += arr[i];\\n        rmax = tmp > rmax ? tmp : rmax;\\n    }\\n\\n    return lmax + rmax;\\n}\\n\\nint maxSubArray(int* nums, int numsSize)\\n{\\n    int m = numsSize / 2;\\n    int max, l, r, c;\\n    \\n    if (numsSize == 1)\\n        return *nums;\\n    \\n    l = maxSubArray(nums, m);\\n    r = maxSubArray(nums + m, numsSize - m);\\n    c = midCrossMax(nums, numsSize);\\n    \\n    max = l > r ? l : r;\\n    max = max > c ? max : c;\\n\\n    return max;\\n    \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nint maxSubArray(int* nums, int numsSize)\\n{\\n    int i, max, tmp;\\n    \\n    for (i = 0, tmp = 0, max = nums[0]; i < numsSize; i++) {\\n        tmp += nums[i];\\n\\n        if (tmp > max)\\n            max = tmp;\\n        \\n        if (tmp < 0)\\n            tmp = 0;\\n    }\\n\\n    return max;\\n}\\n```\n```\\nstatic int midCrossMax(int* arr, int size)\\n{\\n    int lmax, rmax, tmp, i, m = (size / 2) - 1;\\n    \\n    for (i = m, tmp = 0, lmax = arr[m]; i >= 0; i--) {\\n        tmp += arr[i];\\n        lmax = tmp > lmax ? tmp : lmax;\\n    }\\n    \\n    for (i = m + 1, tmp = 0, rmax = arr[m + 1]; i < size; i++) {\\n        tmp += arr[i];\\n        rmax = tmp > rmax ? tmp : rmax;\\n    }\\n\\n    return lmax + rmax;\\n}\\n\\nint maxSubArray(int* nums, int numsSize)\\n{\\n    int m = numsSize / 2;\\n    int max, l, r, c;\\n    \\n    if (numsSize == 1)\\n        return *nums;\\n    \\n    l = maxSubArray(nums, m);\\n    r = maxSubArray(nums + m, numsSize - m);\\n    c = midCrossMax(nums, numsSize);\\n    \\n    max = l > r ? l : r;\\n    max = max > c ? max : c;\\n\\n    return max;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1820428,
                "title": "99-faster-python3-easy-dp-solution-in-5-lines-using-kadane-s-algorithm-o-n",
                "content": "[This is a classic problem of theoretical computer science](https://en.wikipedia.org/wiki/Maximum_subarray_problem)\\n\\nBecause the *maximum subarray problem* is essentially  an **optimization problem** we can thus break it up into smaller problems\\nand return the best result of the said smaller problems..\\nSince we are breaking it up into smaller subarrays anyway we can **eliminate/ignore** subarrays that are *guaranteed* to not provide the optimal solution.\\nThe question we have to contend with now is *What criterea for elimination allows us to reduce the problem space efficiently?*\\n**[010]** Well it becomes a lot easier to establish this critereon if we have a starting point to compare subsequent subarrays to, since our function will not know much about the input array without analyzing it first lets just use the subarray of just the first index to start with and take its value as both our initial maximum value and our initial current value.\\n**[020]** Now that we have both a current subarray and a \\'maximum\\' to compare to lets consider some conditions\\n**[030]** If the sum of the current subarray is negative we can just toss that whole subarray out and start over with the new subbaray being the next index. because that whole subarray is a net drain on the optimal solution we are trying to build\\n**[035]** if the sum of the current subarray is non-negative add the next index to it, even if we lose some value with this addition we\\'re only keeping track of the highest valued subarray & the current subarray. As long as this subarray we\\'re currently keeping track of is a net positive it might be included in the maximum\\n**[040]** If this new current\\'s sum is greater than the \\'maximum\\'s make it the new maximum\\n**[050]** repeat from [020] until we have visited all items in nums\\n\\nNow that we have an algorithm lets see it in action with the example of one of the testcases:\\n```[-2,1,-3,4,-1,2,1,-5,4]```\\nInitially we\\'ll start with the leftmost value **-2**:\\n```\\nmax = -2, current sum = -2\\nmaximum subarray:\\n[-2]\\ncurrent subarray:\\n[-2]\\nremainder:\\n[1,-3,4,-1,2,1,-5,4]\\n```\\nsince **-2** is negative it\\'ll be a net drain on the optimal solution so we\\'ll just ignore it going forward and start a new\\nsubarray on the next value **1** which happens to be greater than -2\\n```\\nmax = 1, current sum= 1\\nmaximum subarray:\\n[1]\\ncurrent subarray:\\n[1]\\nremainder:\\n[-3,4,-1,2,1,-5,4]\\n```\\nadding the next value of **-3** brings us down a value of **-2**\\nmeaning the subarray is a net negative now and we\\'ll just discard it going forward\\n```\\nmax = 1, current sum=  -2\\nmaximum subarray:\\n[1]\\ncurrent subarray:\\n[1, -3]\\nremainder:\\n[4,-1,2,1,-5,4]\\n```\\nThe next value of **4** is greater than our previous maximum so we\\'ll just continue on from there\\n```\\nmax = 4, current sum=  4\\nmaximum subarray:\\n[4]\\ncurrent subarray:\\n[4]\\nremainder:\\n[-1,2,1,-5,4]\\n```\\nAdding the next value of **-1** doesnt produce a new maximum so we wont replace the old mximum but since it doesnt make the current a net negative we\\'ll keep working with it\\n```\\nmax = 4, current sum=  3\\nmaximum subarray:\\n[4]\\ncurrent subarray:\\n[4, -1]\\nremainder:\\n[2,1,-5,4]\\n```\\nAha! Adding this next value of **2** produces a new maximum of **5**\\n```\\nmax = 5, current sum=  5\\nmaximum subarray:\\n[4, -1, 2]\\ncurrent subarray:\\n[4, -1, 2]\\nremainder:\\n[1,-5,4]\\n```\\nIterating again brings us to a max of **6**\\n```\\nmax = 6, current sum= 6\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1]\\nremainder:\\n[-5,4]\\n```\\nPerforming the remaining iterations doesnt produce a new max \\n```\\nmax = 6, current sum= 1\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1,-5]\\nremainder:\\n[4]\\n```\\n```\\nmax = 6, current sum= 5\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1,-5,4]\\nremainder:\\n[]\\n```\\nThis will leave us with a maximum subarray sum of 6 so we return that.\\n\\nNow that we have an algorithm that works lets implement it in python:\\n```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n        maxsum = cursum = nums[0]\\n    \\n        for n in range(1,len(nums)):\\n            if cursum < 0: cursum = 0\\n            cursum += nums[n]\\n            if cursum > maxsum: maxsum = cursum\\n        \\n        return maxsum\\n```\\nThis solution provides a time complexity of ```T(n)=O(n)``` and a space complexity of ```S(n) = O(1)```  (ignoring the memory allocation of passing ```nums``` to the function by value.)\\nThis particular implentation gives a best runtime of 648ms  (99.83th percentile) and a best memory use of 27.7mb (97.42th percentile) \\nTheres many different ways to implement kadane\\'s algorithm (leftwise comparison to maximum) in python but as long as it mostly matches the optimal implementation (only keeping track of the current and max sum, iterating over nums instead of generating a new list to iterate over, etc.)  the particulars of any given implementation will be optimized out when compiled to bytecode. You should be more concerned with writing code for clarity and being idiomatic in the language of your choice instead of making micro-optimizations.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```[-2,1,-3,4,-1,2,1,-5,4]```\n```\\nmax = -2, current sum = -2\\nmaximum subarray:\\n[-2]\\ncurrent subarray:\\n[-2]\\nremainder:\\n[1,-3,4,-1,2,1,-5,4]\\n```\n```\\nmax = 1, current sum= 1\\nmaximum subarray:\\n[1]\\ncurrent subarray:\\n[1]\\nremainder:\\n[-3,4,-1,2,1,-5,4]\\n```\n```\\nmax = 1, current sum=  -2\\nmaximum subarray:\\n[1]\\ncurrent subarray:\\n[1, -3]\\nremainder:\\n[4,-1,2,1,-5,4]\\n```\n```\\nmax = 4, current sum=  4\\nmaximum subarray:\\n[4]\\ncurrent subarray:\\n[4]\\nremainder:\\n[-1,2,1,-5,4]\\n```\n```\\nmax = 4, current sum=  3\\nmaximum subarray:\\n[4]\\ncurrent subarray:\\n[4, -1]\\nremainder:\\n[2,1,-5,4]\\n```\n```\\nmax = 5, current sum=  5\\nmaximum subarray:\\n[4, -1, 2]\\ncurrent subarray:\\n[4, -1, 2]\\nremainder:\\n[1,-5,4]\\n```\n```\\nmax = 6, current sum= 6\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1]\\nremainder:\\n[-5,4]\\n```\n```\\nmax = 6, current sum= 1\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1,-5]\\nremainder:\\n[4]\\n```\n```\\nmax = 6, current sum= 5\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1,-5,4]\\nremainder:\\n[]\\n```\n```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n        maxsum = cursum = nums[0]\\n    \\n        for n in range(1,len(nums)):\\n            if cursum < 0: cursum = 0\\n            cursum += nums[n]\\n            if cursum > maxsum: maxsum = cursum\\n        \\n        return maxsum\\n```\n```T(n)=O(n)```\n```S(n) = O(1)```\n```nums```",
                "codeTag": "Python3"
            },
            {
                "id": 561639,
                "title": "simplest-o-n-time-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if(nums.length == 0)\\n            return Integer.MIN_VALUE;\\n        \\n        int currentWindowSum = nums[0];\\n        int largestSum = nums[0];\\n        for(int i=1; i<nums.length ; i++){\\n            //start a new window , if starting is a better option than extending\\n            currentWindowSum = Math.max(currentWindowSum+nums[i],nums[i]);\\n            largestSum = Math.max(largestSum,currentWindowSum);\\n        }\\n        return largestSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if(nums.length == 0)\\n            return Integer.MIN_VALUE;\\n        \\n        int currentWindowSum = nums[0];\\n        int largestSum = nums[0];\\n        for(int i=1; i<nums.length ; i++){\\n            //start a new window , if starting is a better option than extending\\n            currentWindowSum = Math.max(currentWindowSum+nums[i],nums[i]);\\n            largestSum = Math.max(largestSum,currentWindowSum);\\n        }\\n        return largestSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399490,
                "title": "beat-94-76-python-users-no-dp-kadane-algorithm",
                "content": "\\tclass Solution(object):\\n\\t\\tdef maxSubArray(self, nums):\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\tif nums[i - 1] > 0: \\n\\t\\t\\t\\t\\tnums[i] += nums[i - 1]\\n\\t\\t\\treturn max(nums)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef maxSubArray(self, nums):\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\tif nums[i - 1] > 0: \\n\\t\\t\\t\\t\\tnums[i] += nums[i - 1]\\n\\t\\t\\treturn max(nums)",
                "codeTag": "Java"
            },
            {
                "id": 182866,
                "title": "javascript",
                "content": "```\nvar maxSubArray = function(nums) {\n    if(nums.length == 0) return 0;\n    let result = Number.MIN_SAFE_INTEGER;\n    let sum = 0;\n    for(let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        result = Math.max(sum, result);\n        sum = sum < 0 ? 0 : sum;\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar maxSubArray = function(nums) {\n    if(nums.length == 0) return 0;\n    let result = Number.MIN_SAFE_INTEGER;\n    let sum = 0;\n    for(let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        result = Math.max(sum, result);\n        sum = sum < 0 ? 0 : sum;\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163139,
                "title": "solution-with-divide-and-conquer-as-well-as-normal-iterative-both-acccepted",
                "content": "straight forward approach is commented, the solution is typical implementation of the maximum suarray algorithm for divide and conquer . \\nTo solve it using divide and conquer, think about three possibilities, either the left sub array is having maximum sum, or the right sub array is having the maximum sum. Or the middle element is there in the Sum. so with left subarray and right subarray, problem can be broken down to a recursive call. The crossing subarray , the one with the middle element needs to be solved as a base case, and it is easy to solve as we already know from where to start, you just start from the middle and traverse towards left, till you get an increase in total sum, so keep track of two sums , similarly do this for right side, and return the sum. \\n```\\nclass Solution {\\n    int getCrossSum(vector<int> &nums,int low,int high)\\n    {\\n        if(low >=high)\\n            return nums[low];\\n        int mid = low+high;\\n        mid =mid/2;\\n        int sum = nums[mid];\\n        int tsum=sum;\\n        for(int i = mid-1;i>=low;i--)\\n        {\\n            tsum+=nums[i];\\n            if(sum<tsum)\\n                sum=tsum;\\n        }\\n        tsum=sum;\\n        for(int i = mid+1; i<=high; i++)\\n        {\\n            tsum+=nums[i];\\n            if(sum<tsum)\\n                sum=tsum;\\n        }\\n        return sum;\\n    }\\n    int maxSum(vector<int> &nums,int low, int high) {\\n        if(low>=high)\\n            return nums[low];\\n        int mid = low+high;\\n        mid = mid/2;\\n        int crossSum = getCrossSum(nums,low,high);\\n        int leftSum = maxSum(nums,low,mid);\\n        int rightSum = maxSum(nums,mid+1,high);\\n        if(leftSum> rightSum && leftSum> crossSum)\\n            return leftSum; \\n        if(rightSum> crossSum)\\n            return rightSum;\\n        return crossSum;\\n    }\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSum(nums,0,nums.size()-1);\\n    }\\n    /*int maxSubArray(vector<int>& nums) {\\n        if(nums.empty())\\n            return 0; \\n        int cur = 0,res=nums[0]; \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            cur = max(nums[i],cur+=nums[i]);\\n            res = max(cur,res);\\n        }\\n        return res;\\n    }*/\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int getCrossSum(vector<int> &nums,int low,int high)\\n    {\\n        if(low >=high)\\n            return nums[low];\\n        int mid = low+high;\\n        mid =mid/2;\\n        int sum = nums[mid];\\n        int tsum=sum;\\n        for(int i = mid-1;i>=low;i--)\\n        {\\n            tsum+=nums[i];\\n            if(sum<tsum)\\n                sum=tsum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20283,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/80136/python-solution-with-detailed-explanation\\n\\n**Maximum Subarray** https://leetcode.com/problems/maximum-subarray/\\n\\n**Dynamic Programming **\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_so_far, curr_sum = -2**31, 0\\n        for i in range(len(nums)):\\n            if curr_sum+nums[i] < 0:\\n                curr_sum, max_so_far = 0, max(max_so_far, nums[i])\\n            else:\\n                curr_sum, max_so_far = curr_sum + nums[i], max(max_so_far, curr_sum + nums[i])\\n        return max_so_far\\n\\n```\\n\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_so_far, curr_sum = max(nums), 0\\n        for i in range(len(nums)):\\n            if curr_sum+nums[i] < 0:\\n                curr_sum = 0\\n            else:\\n                curr_sum, max_so_far = curr_sum + nums[i], max(max_so_far, curr_sum + nums[i])\\n        return max_so_far\\n```\\n\\n**Divide and Conquer**\\n* Divide and Conquer solution, the solution can lie entirely in left or in right or span in between.\\n* When it spans in between, we can use principle of optimality. The middle sum can be broken into sum from middle-1 towards left, and sum from middle+1 towards an index <= high. Lets call these sums as lmax and rmax. \\n* Now the maximum middle sum must be max(lmax,0)+max(rmax,0)+nums[mid]. \\n* Why? We have to include nums[mid]. Now the left sum or right sum will only be included if the sum is positive. \\n\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        return self.helper(nums, 0, len(nums)-1)\\n    \\n    def helper(self, nums, low, high):\\n        if low > high:\\n            return 0\\n        if low == high:\\n            return nums[low]\\n        mid = low + (high-low)//2\\n        x_left = self.helper(nums, low, mid)\\n        x_right = self.helper(nums, mid+1, high)\\n        lmax, rmax = float('-inf'), float('-inf')\\n        lsum, rsum = 0,0\\n        for i in range(mid-1, low-1, -1): ### Important Insight in NlgN solutions\\n            lsum = lsum + nums[i]\\n            lmax = max(lmax, lsum)\\n        for i in range(mid+1, high+1, 1):\\n            rsum = rsum + nums[i]\\n            rmax = max(rmax, rsum)\\n        return max(x_left, x_right, max(0,lmax)+max(0,rmax)+nums[mid])        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_so_far, curr_sum = -2**31, 0\\n        for i in range(len(nums)):\\n            if curr_sum+nums[i] < 0:\\n                curr_sum, max_so_far = 0, max(max_so_far, nums[i])\\n            else:\\n                curr_sum, max_so_far = curr_sum + nums[i], max(max_so_far, curr_sum + nums[i])\\n        return max_so_far\\n\\n```\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_so_far, curr_sum = max(nums), 0\\n        for i in range(len(nums)):\\n            if curr_sum+nums[i] < 0:\\n                curr_sum = 0\\n            else:\\n                curr_sum, max_so_far = curr_sum + nums[i], max(max_so_far, curr_sum + nums[i])\\n        return max_so_far\\n```\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        return self.helper(nums, 0, len(nums)-1)\\n    \\n    def helper(self, nums, low, high):\\n        if low > high:\\n            return 0\\n        if low == high:\\n            return nums[low]\\n        mid = low + (high-low)//2\\n        x_left = self.helper(nums, low, mid)\\n        x_right = self.helper(nums, mid+1, high)\\n        lmax, rmax = float('-inf'), float('-inf')\\n        lsum, rsum = 0,0\\n        for i in range(mid-1, low-1, -1): ### Important Insight in NlgN solutions\\n            lsum = lsum + nums[i]\\n            lmax = max(lmax, lsum)\\n        for i in range(mid+1, high+1, 1):\\n            rsum = rsum + nums[i]\\n            rmax = max(rmax, rsum)\\n        return max(x_left, x_right, max(0,lmax)+max(0,rmax)+nums[mid])        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764848,
                "title": "easy-to-understand-all-approaches-covered-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int current_sum=0;\\n        int maximum_sum=INT_MIN;\\n        int n=nums.size(); //size\\n\\n// ---------------------------1st Approach------------------------\\n// Brute Force...\\n// it\\'ll give TLE... \\n// reason, Time complexity is greater than req.\\n// time O(n^2) ; Space O(1)\\n    // for (int i = 0; i <= n - 1; i++) \\n    // {\\n    //     int current_sum = 0;\\n    //     for (int j = i; j <= n - 1; j++) \\n    //     {\\n    //     current_sum += nums[j];\\n    //         if (current_sum > maximum_sum) \\n    //         {\\n    //             maximum_sum = current_sum;\\n    //         }\\n    //     }\\n    // }\\n    // return maximum_sum;\\n\\n\\n// ---------------------------2nd Approach------------------------\\n// This algorithmn is also popularly known as,\\n// ***\"Kadan\\'s Algo\"***\\n// time O(n)\\n// space O(1)\\n        for(int i=0; i<n; i++)\\n        {\\n            current_sum += nums[i];\\n            maximum_sum = max(maximum_sum,current_sum);\\n\\n            if(current_sum<0) \\n                current_sum=0;\\n        }\\n\\n        return maximum_sum;\\n    }\\n};\\n```\\nCoded By Harsh Pandey\\nPlease Upvote if it Helped... Thank You...\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int current_sum=0;\\n        int maximum_sum=INT_MIN;\\n        int n=nums.size(); //size\\n\\n// ---------------------------1st Approach------------------------\\n// Brute Force...\\n// it\\'ll give TLE... \\n// reason, Time complexity is greater than req.\\n// time O(n^2) ; Space O(1)\\n    // for (int i = 0; i <= n - 1; i++) \\n    // {\\n    //     int current_sum = 0;\\n    //     for (int j = i; j <= n - 1; j++) \\n    //     {\\n    //     current_sum += nums[j];\\n    //         if (current_sum > maximum_sum) \\n    //         {\\n    //             maximum_sum = current_sum;\\n    //         }\\n    //     }\\n    // }\\n    // return maximum_sum;\\n\\n\\n// ---------------------------2nd Approach------------------------\\n// This algorithmn is also popularly known as,\\n// ***\"Kadan\\'s Algo\"***\\n// time O(n)\\n// space O(1)\\n        for(int i=0; i<n; i++)\\n        {\\n            current_sum += nums[i];\\n            maximum_sum = max(maximum_sum,current_sum);\\n\\n            if(current_sum<0) \\n                current_sum=0;\\n        }\\n\\n        return maximum_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770357,
                "title": "c-easy-kadane-s-algorithm",
                "content": "\\'\\'\\'   \\n**PLEASE DO UPVOTE IF YOU UNDERSTAND.**\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\n    \\n\\t/*------KADANE\\'s ALGORITHM-------*/\\n    \\n    int maxSubArray(vector<int>& nums) {\\n        \\n        int ans=INT_MIN;\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            sum+=nums[i];\\n            \\n            if(nums[i]>sum) sum=nums[i];\\n            \\n            ans=max(sum,ans);\\n        }\\n        \\n        return ans;\\n    }\\n\\t};\\n\\t**PLEASE DO UPVOTE IF YOU UNDERSTAND.**\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\n    \\n\\t/*------KADANE\\'s ALGORITHM-------*/\\n    \\n    int maxSubArray(vector<int>& nums) {\\n        \\n        int ans=INT_MIN;\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            sum+=nums[i];\\n            \\n            if(nums[i]>sum) sum=nums[i];\\n            \\n            ans=max(sum,ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1609650,
                "title": "easy-solution-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int ans= nums[0];\\n        int n= nums.size();\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            sum += nums[i];\\n            ans = max(ans, sum);\\n            \\n            if(sum<0)\\n                sum=0;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n---\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int ans= nums[0];\\n        int n= nums.size();\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            sum += nums[i];\\n            ans = max(ans, sum);\\n            \\n            if(sum<0)\\n                sum=0;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533366,
                "title": "python-soultion-easy-to-understand",
                "content": "The idea for this question is that negative numbers do not help us with the sum so if we see a negative number we want to ignore them. \\n```\\n def maxSubArray(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentSum = nums[0] #setting current sum to be the first element\\n        maxSum = nums[0] #same thing for maxSum\\n        for i in range(1,len(nums)):\\n            if currentSum < 0:  #if currentsum is negative then that means ignore all the prev elements\\n                currentSum = nums[i]\\n            else:\\n                currentSum += nums[i] #if not add the current element to the currentSum\\n                    \\n            maxSum = max(currentSum, maxSum) #compare currentSum to maxSum. \\n            \\n        return maxSum    \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n def maxSubArray(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentSum = nums[0] #setting current sum to be the first element\\n        maxSum = nums[0] #same thing for maxSum\\n        for i in range(1,len(nums)):\\n            if currentSum < 0:  #if currentsum is negative then that means ignore all the prev elements\\n                currentSum = nums[i]\\n            else:\\n                currentSum += nums[i] #if not add the current element to the currentSum\\n                    \\n            maxSum = max(currentSum, maxSum) #compare currentSum to maxSum. \\n            \\n        return maxSum    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 561756,
                "title": "python-o-n-solution-44ms-beats-95",
                "content": "```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        windowSum = nums[0]\\n        maxSum = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            windowSum = max(windowSum+nums[i], nums[i])\\n            maxSum = max(windowSum, maxSum)\\n        return maxSum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        windowSum = nums[0]\\n        maxSum = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            windowSum = max(windowSum+nums[i], nums[i])\\n            maxSum = max(windowSum, maxSum)\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423761,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    let max = -Infinity;\\n    let currentMax = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        currentMax = Math.max(nums[i], currentMax + nums[i]);\\n        max = Math.max(currentMax, max);               \\n    }\\n    \\n    return max;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    let max = -Infinity;\\n    let currentMax = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        currentMax = Math.max(nums[i], currentMax + nums[i]);\\n        max = Math.max(currentMax, max);               \\n    }\\n    \\n    return max;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 254481,
                "title": "javascript-3-solutions-aggregate-kadane-s-algorithm-divide-and-conquer",
                "content": "**Aggregate**\\n```\\nvar maxSubArray = function(nums) {\\n    let maxSum = nums[0], val = 0\\n    nums.forEach(num => {\\n        maxSum = Math.max(maxSum, val += num)\\n        val = Math.max(val, 0)\\n    })\\n    return maxSum\\n}\\n```\\n\\n**Kadane\\'s Algorithm(DP)**\\n```\\nvar maxSubArray = function(nums) {\\n    let maxSoFar = nums[0]\\n    for(let i = 1, maxEndHere = nums[0]; i < nums.length; ++i) {\\n        maxEndHere = Math.max(nums[i], maxEndHere + nums[i])\\n        maxSoFar = Math.max(maxSoFar, maxEndHere)\\n    }\\n    return maxSoFar\\n}\\n```\\n\\n**Divide and Conquer**\\n```\\nconst maxSub = (nums, left, right) => {\\n    if(left === right)\\n        return nums[left]\\n    else if(left > right)\\n        return Number.NEGATIVE_INFINITY\\n    \\n    let mid = Math.floor((left + right) / 2)\\n    let lmax = maxSub(nums, left, mid - 1)\\n    let rmax = maxSub(nums, mid + 1, right)\\n    \\n    let leftExtendMaxSum = rightExtendMaxSum = 0\\n    for(let i = mid - 1, tempTotal = 0; i >= left; --i)\\n        leftExtendMaxSum = Math.max(tempTotal += nums[i], leftExtendMaxSum)\\n\\n    for(let i = mid + 1, tempTotal = 0; i <= right; ++i)\\n        rightExtendMaxSum = Math.max(tempTotal += nums[i], rightExtendMaxSum)\\n\\n    return Math.max(leftExtendMaxSum + nums[mid] + rightExtendMaxSum, lmax, rmax)\\n}\\n\\nvar maxSubArray = nums =>\\n    maxSub(nums, 0, nums.length - 1)\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n    let maxSum = nums[0], val = 0\\n    nums.forEach(num => {\\n        maxSum = Math.max(maxSum, val += num)\\n        val = Math.max(val, 0)\\n    })\\n    return maxSum\\n}\\n```\n```\\nvar maxSubArray = function(nums) {\\n    let maxSoFar = nums[0]\\n    for(let i = 1, maxEndHere = nums[0]; i < nums.length; ++i) {\\n        maxEndHere = Math.max(nums[i], maxEndHere + nums[i])\\n        maxSoFar = Math.max(maxSoFar, maxEndHere)\\n    }\\n    return maxSoFar\\n}\\n```\n```\\nconst maxSub = (nums, left, right) => {\\n    if(left === right)\\n        return nums[left]\\n    else if(left > right)\\n        return Number.NEGATIVE_INFINITY\\n    \\n    let mid = Math.floor((left + right) / 2)\\n    let lmax = maxSub(nums, left, mid - 1)\\n    let rmax = maxSub(nums, mid + 1, right)\\n    \\n    let leftExtendMaxSum = rightExtendMaxSum = 0\\n    for(let i = mid - 1, tempTotal = 0; i >= left; --i)\\n        leftExtendMaxSum = Math.max(tempTotal += nums[i], leftExtendMaxSum)\\n\\n    for(let i = mid + 1, tempTotal = 0; i <= right; ++i)\\n        rightExtendMaxSum = Math.max(tempTotal += nums[i], rightExtendMaxSum)\\n\\n    return Math.max(leftExtendMaxSum + nums[mid] + rightExtendMaxSum, lmax, rmax)\\n}\\n\\nvar maxSubArray = nums =>\\n    maxSub(nums, 0, nums.length - 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20369,
                "title": "java-6-line-dp-soulution",
                "content": "```\\npublic class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = nums[0], length = nums.length;\\n        for(int i = 1; i<length; i++) {\\n        \\tif(nums[i-1]>0) nums[i] = nums[i-1]+nums[i];\\n        \\tif(maxSum<nums[i]) maxSum = nums[i];\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = nums[0], length = nums.length;\\n        for(int i = 1; i<length; i++) {\\n        \\tif(nums[i-1]>0) nums[i] = nums[i-1]+nums[i];\\n        \\tif(maxSum<nums[i]) maxSum = nums[i];\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20485,
                "title": "simple-c-dp-8ms",
                "content": "Just do DP, use curMax to calculate the maximum sum ending at nums[i], so the recurisve equation is \\ncurMax at i+1 = max(0, curMax) + nums[i+1] \\n\\n    class Solution {\\n    public:\\n        int maxSubArray(vector<int>& nums) {\\n            int curMax = 0, res = INT_MIN, i;\\n            for(auto x:nums)\\n            {\\n                curMax = curMax>0? (curMax + x):x ;\\n                if(curMax > res ) res = curMax;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxSubArray(vector<int>& nums) {\\n            int curMax = 0, res = INT_MIN, i;\\n            for(auto x:nums)\\n            {\\n                curMax = curMax>0? (curMax + x):x ;\\n                if(curMax > res ) res = curMax;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3596596,
                "title": "3-approaches-brute-to-optimised-kadane-s-algorithm",
                "content": "# **Approach 1:**\\n\\n# **Intuition**\\n\\nThe first intuition is to generate all subarrays and then compute sum of all subarrays.\\n\\n# **Approach**\\n\\nIterate i ->0 to n and j -> i to n and then k -> i(start) to j (end) to generate all subarray and compute sum inside k loop.\\n\\n# **Complexity**\\n\\n- Time complexity:\\n\\n```\\nO(n^3)\\n```\\n\\n- Space complexity:\\n\\n```\\nO(1)\\n```\\n\\n# **Code**\\n\\n```cpp\\n class Solution {\\n    public:\\n        int maxSubArray(vector<int>& nums) {\\n            int sum=0,maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                sum=0;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    sum+=nums[k];\\n                }\\n                maxSum=max(maxSum,sum);\\n            }\\n        }\\n        return maxSum;\\n        }\\n    };\\n```\\n\\n# **Approach 2:**\\n\\n# **Intuition**\\n\\nThe intuition is to maintain to pointers to mark the start and end and compute sum of numbers in the range.\\n\\n# **Approach**\\n\\nIterate i ->0 to n and j -> i to n  to generate all subarray and compute sum inside loop.\\n\\n# **Complexity**\\n\\n- Time complexity:\\n\\n```\\nO(n^2)\\n```\\n\\n- Space complexity:\\n\\n```\\nO(1)\\n```\\n\\n# **Code**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0,maxSum=INT_MIN;\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         sum=0;\\n         for(int j=i;j<nums.size();j++)\\n         {\\n             sum+=nums[j];\\n             maxSum=max(maxSum,sum);\\n         }\\n     }\\n     return maxSum;\\n    }\\n};\\n```\\n\\n# **Approach 3:**\\n\\n# **Intuition**\\n\\nUsing Kadane\\'s Algorithm.\\n\\n# **Approach**\\n\\nRun a loop from i -> 1 to n. Our motivate is to ignore sum if negative and start with a new subarray. Keep on adding values to sum variable maintain a maximum variable to store the maximum seen so far. If sum exceeds max then store sum in max. If sum is negative then set sum to 0 because we do not need negative sum and the sum needs to be continous as subarray is specified in the question so for starting the sum for a new subarray we need to set the sum to 0.\\n\\n# **Complexity**\\n\\n- Time complexity:\\n\\n```\\nO(n)\\n```\\n\\n- Space complexity:\\n\\n```\\nO(1)\\n```\\n\\n# **Code**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0,max=nums[0];\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         sum+=nums[i];\\n         if(sum>max)\\n            max=sum;\\n        if(sum<0)\\n            sum=0;\\n     }   \\n     return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(n^3)\\n```\n```\\nO(1)\\n```\n```cpp\\n class Solution {\\n    public:\\n        int maxSubArray(vector<int>& nums) {\\n            int sum=0,maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                sum=0;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    sum+=nums[k];\\n                }\\n                maxSum=max(maxSum,sum);\\n            }\\n        }\\n        return maxSum;\\n        }\\n    };\\n```\n```\\nO(n^2)\\n```\n```\\nO(1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0,maxSum=INT_MIN;\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         sum=0;\\n         for(int j=i;j<nums.size();j++)\\n         {\\n             sum+=nums[j];\\n             maxSum=max(maxSum,sum);\\n         }\\n     }\\n     return maxSum;\\n    }\\n};\\n```\n```\\nO(n)\\n```\n```\\nO(1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0,max=nums[0];\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         sum+=nums[i];\\n         if(sum>max)\\n            max=sum;\\n        if(sum<0)\\n            sum=0;\\n     }   \\n     return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115907,
                "title": "javascript-fast-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/kMSVhfhX2YQ\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    \\n    for(let i =1; i<nums.length;i++){\\n        nums[i] = Math.max(nums[i],nums[i]+nums[i-1])\\n    }\\n    return Math.max(...nums)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    \\n    for(let i =1; i<nums.length;i++){\\n        nums[i] = Math.max(nums[i],nums[i]+nums[i-1])\\n    }\\n    return Math.max(...nums)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680489,
                "title": "javascript-solution-with-explanation-o-n-time-complexity",
                "content": "By brute force, the time complexity will be O(n^2). In this we will check all posible subarrays and find out their sums.\\n\\nBetter solution :\\nWhenever we need to find out maximum or minimum of anything, we can try dynamic programming way as the solution. \\nThe key part in DP is to find out the sub-problem. \\nConsider the max sum till the index previous to the index under consideration. There are 2 ways to move ahead. \\n1. add the current index element to the max sum till the previous index. \\n2. only consider this new element \\n\\nWhichever is the bigger of above two, we will consider that.\\n\\nHere time complexity will be  O(n).\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    let maxSum = nums[0];   \\n\\tlet sum = nums[0];\\n\\tfor(let i=1; i< nums.length; i++){   // start with 2nd element.\\n\\t\\tsum = Math.max(nums[i], nums[i]+sum);\\n\\t\\tif(sum > maxSum) maxSum = sum;\\n\\t}\\n\\treturn maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    let maxSum = nums[0];   \\n\\tlet sum = nums[0];\\n\\tfor(let i=1; i< nums.length; i++){   // start with 2nd element.\\n\\t\\tsum = Math.max(nums[i], nums[i]+sum);\\n\\t\\tif(sum > maxSum) maxSum = sum;\\n\\t}\\n\\treturn maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435684,
                "title": "java-step-by-step-optimization-explained",
                "content": "Inefficient solution.\\n\\ntime: O(n^3), space: O(1)\\nLet\\'s do better :(\\n```java\\npublic int solution1(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tfor (int j = i; j < nums.length; j++) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int k = i; k <= j; k++) {\\n\\t\\t\\t\\tsum += nums[k];\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max, sum);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\\n</br>\\n\\nRealize that the third loop repeats work. On each subsequent iteration of j, it is simply readding everything it did in the previous iteration except it just adds the next nums value. An example is [2,-1,3]. It first sums the subarray [2], then [2,-1], [2,-1,3]... We can simply store the previous results in an array (memoization) and add the new nums value with the previous cumulative sum. This removes the third loop.\\n\\ntime: O(n^2), space: O(n)\\nWe can still do better :|\\n```\\npublic int solution2(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint memo[] = new int[nums.length + 1 - i];\\n\\t\\tmemo[0] = nums[i];\\n\\t\\tmax = Math.max(max, memo[0]);\\n\\t\\tfor (int j = 1; j < memo.length - 1; j++) {\\n\\t\\t\\tmemo[j] = memo[j - 1] + nums[i + j];\\n\\t\\t\\tmax = Math.max(max, memo[j]);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\\n</br>\\n\\nWe can make memo smaller cause we don\\'t need all the previous results, just the most recent previous. A very typical memoization optimization technique.\\n\\ntime: O(n^2), space: O(1)\\nConstant space :)\\n```java\\npublic int solution3(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint memo = nums[i];\\n\\t\\tmax = Math.max(max, nums[i]);\\n\\t\\tfor (int j = 1; j < nums.length - i; j++) {\\n\\t\\t\\tmemo = memo + nums[i + j]; // currVal = prevVal + currNum\\n\\t\\t\\tmax = Math.max(max, memo);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\\n</br>\\n\\nThis one is difficult. Notice that the results won\\'t change for the above if we change memo update to the following: `memo = Math.max(nums[i + j], memo + nums[i + j]);` We then realize the second loop is unnecesary. We notice that we don\\'t actually need to compare every cumulative sum all the way from i + j. We just need to know the current valid one at i. Let me explain. \\nOur memo is currently storing the cumulative sum. Our objective is to find the max cumulative sum possible in our array. On every step in this array, we know the maximum sum at the moment can either be the current cumulative sum (what was added up so far) or it could start from the current value. The current cumulative sum can fall below the current nums value (cause negative values are possible), in which we have to reassign our cumulative sum variable as the current nums value (cause it can never grow bigger if it\\'s subtracting from our cumulative sum at that point). We then can compare every valid cumulative sum with each other by keeping track of the global maximum like we\\'ve been doing in the previous solutions.\\n\\nA different way to visualize it can be a sliding-window. Imagine that we\\'re changing the starting index of our subarray, once we find that the sum of the current subarray is smaller than the nums value at our current index. So we update the start index to be the current index. But we don\\'t actually needed to keep track of the indices of our \"subarray window\" cause we can just keep track of the cumulative sum. If you approach this problem through the sliding-window way, you should still arrive at the same optimized answer I have given below once you realize you don\\'t need to keep track of the indices.\\n\\nAn explanation for more proofy people, the invariant holds true that we can\\'t increase the cumulative sum anymore on every iteration when we know that the current cumulative sum (includes the curr value) falls below our curr value. The current cumulative sum will never be bigger than if we just start the cumulative sum from the curr index. We can then just keep track of a global maximum value, to find which valid cumulative sums are possible.\\n\\nI basically said the same thing 3 times... You get the point.\\n\\ntime: O(n), space: O(1)\\n100%! :))\\n```java\\npublic int solution4(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint currSum = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tcurrSum += nums[i];\\n\\t\\tcurrSum = Math.max(nums[i], currSum); // curr value vs curr cumulativee\\n\\t\\tmax = Math.max(max, currSum);\\n\\t}\\n\\treturn max;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int solution1(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tfor (int j = i; j < nums.length; j++) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int k = i; k <= j; k++) {\\n\\t\\t\\t\\tsum += nums[k];\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max, sum);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\n```\\npublic int solution2(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint memo[] = new int[nums.length + 1 - i];\\n\\t\\tmemo[0] = nums[i];\\n\\t\\tmax = Math.max(max, memo[0]);\\n\\t\\tfor (int j = 1; j < memo.length - 1; j++) {\\n\\t\\t\\tmemo[j] = memo[j - 1] + nums[i + j];\\n\\t\\t\\tmax = Math.max(max, memo[j]);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\n```java\\npublic int solution3(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint memo = nums[i];\\n\\t\\tmax = Math.max(max, nums[i]);\\n\\t\\tfor (int j = 1; j < nums.length - i; j++) {\\n\\t\\t\\tmemo = memo + nums[i + j]; // currVal = prevVal + currNum\\n\\t\\t\\tmax = Math.max(max, memo);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\n```java\\npublic int solution4(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint currSum = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tcurrSum += nums[i];\\n\\t\\tcurrSum = Math.max(nums[i], currSum); // curr value vs curr cumulativee\\n\\t\\tmax = Math.max(max, currSum);\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428422,
                "title": "javascript-maximum-subarray-written-explanation-code-demo",
                "content": "# Table of Contents:\\n* High level overview of the problem\\n* Translate words to solution\\n* Code demo\\n\\n## **High level overview of the problem:**\\n\\n*Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.*\\n\\n*A subarray is a contiguous part of an array.*\\n\\nFind a combination of the array that has the largest sum. The problem states that is has to be contiguous, which implies that the order of the index cannot be random, it needs to be in order.\\n\\n**There are 2 ways to solve this problem:**\\n1. Brute Force\\n2. Kadane\\'s Algorithm\\n\\n## **Translate words to solution:**\\n\\n**Solution #1 Brute Force:**\\n\\nWe need to iterate over the array with one for loop and we need an additional for loop to scan the elements to the right of it, with this in mind, we can accumulate the combinations of the sub array to achieve the largest sum.\\n\\nThe reason we need to accumulate the combinations is because we need to keep track of the locally optimal max sum sub array while simultaneously comparing it to the global max sum sub array. Also, by accumulating the numbers in the sub array we might run into negative numbers that will decrease the total value of the sum, which is why we need to always compare the local sum to the global sum.\\n\\nAfter going through the entire array with double for loops, you should be able to return the global max sum sub array.\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(1)\\n\\n**Solution #2 Kadane\\'s Algorithm:**\\n\\nKadane\\'s algorithm is a combination of the greedy algorithm and dynamic programming. \\n\\nGreedy algorithm:\\nWe keep track of the locally optimal solution while simultaneously comparing it to our global solution.\\n\\nDynamic programming:\\nOnce we solved the sub problem, in this case, the maximum sum of the sub array then we can use memoization to keep track of the solution. By keeping track of our previous solution (local solution), it allows us to solve the problem once and we can build the next solution. These overlapping sub problems plus the greedy algorithm allows us to build the solution piece by piece in O(n) time.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n## **Code demo:**\\n\\n**Solution #1 Brute Force:**\\n\\n```\\nfunction maxSubArray(nums) {\\n  let globalMaxSum = -Infinity;\\n\\n  //  the reason we are looping through the entire nums.length is because a sub array can be the entire length\\n  for (let i = 0; i < nums.length; i++) {\\n\\tlet localMaxSum = 0;\\n\\t// the reason j is to i is because we are scanning all the combinations of the nums[i]\\n\\t// on every iteration of nums[i], localMaxSum will reset and the second for loop (j) will accumulate all the combinations \\n    for (let j = i; j < nums.length; j++) {\\n\\t\\tlocalMaxSum +=  nums[j];\\n\\n\\t\\tif (localMaxSum > globalMaxSum) {\\n\\t\\t\\tglobalMaxSum = localMaxSum;\\n\\t\\t}\\n    }\\n  }\\n\\n  return globalMaxSum;\\n}\\n\\n```\\n\\n**Solution #2 Kadane\\'s Algorithm:**\\n\\n```\\nfunction maxSubArray(nums) {\\n  let globalMaxSum = nums[0];\\n  let localMaxSum = nums[0];\\n\\t\\n  // We start the for loop at index 1 because localMaxSum + globalMaxSum has already been solved!\\n  // Now we can actually take the previous solution and apply it to index 1.\\n  for (let i = 1; i < nums.length; i++) {\\n\\t\\t// We keep track of the previous solution (localMaxSum[i - 1]) and we memoization it by storing it in localMaxSum\\n\\t\\t// As we iterate the array, do we keep nums[i] or do we keep accumlating our memoized solution?\\n\\t\\tlocalMaxSum = Math.max(nums[i], localMaxSum + nums[i]);\\n\\t\\t// Greedy algorithm, compare local solution to the global solution\\n\\t\\tglobalMaxSum = Math.max(localMaxSum, globalMaxSum);\\n  }\\n\\n  return globalMaxSum;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction maxSubArray(nums) {\\n  let globalMaxSum = -Infinity;\\n\\n  //  the reason we are looping through the entire nums.length is because a sub array can be the entire length\\n  for (let i = 0; i < nums.length; i++) {\\n\\tlet localMaxSum = 0;\\n\\t// the reason j is to i is because we are scanning all the combinations of the nums[i]\\n\\t// on every iteration of nums[i], localMaxSum will reset and the second for loop (j) will accumulate all the combinations \\n    for (let j = i; j < nums.length; j++) {\\n\\t\\tlocalMaxSum +=  nums[j];\\n\\n\\t\\tif (localMaxSum > globalMaxSum) {\\n\\t\\t\\tglobalMaxSum = localMaxSum;\\n\\t\\t}\\n    }\\n  }\\n\\n  return globalMaxSum;\\n}\\n\\n```\n```\\nfunction maxSubArray(nums) {\\n  let globalMaxSum = nums[0];\\n  let localMaxSum = nums[0];\\n\\t\\n  // We start the for loop at index 1 because localMaxSum + globalMaxSum has already been solved!\\n  // Now we can actually take the previous solution and apply it to index 1.\\n  for (let i = 1; i < nums.length; i++) {\\n\\t\\t// We keep track of the previous solution (localMaxSum[i - 1]) and we memoization it by storing it in localMaxSum\\n\\t\\t// As we iterate the array, do we keep nums[i] or do we keep accumlating our memoized solution?\\n\\t\\tlocalMaxSum = Math.max(nums[i], localMaxSum + nums[i]);\\n\\t\\t// Greedy algorithm, compare local solution to the global solution\\n\\t\\tglobalMaxSum = Math.max(localMaxSum, globalMaxSum);\\n  }\\n\\n  return globalMaxSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341945,
                "title": "easy-java-solution-100-0-ms",
                "content": "If you like the solution please up vote :)\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int max =   nums[0];\\n        int prev = nums[0];       \\n        for(int i = 1 ; i < nums.length ;i++ ){\\n            if(prev + nums[i]  > nums[i]){\\n                prev =  prev + nums[i];             \\n            }else{\\n                prev = nums[i];                \\n            }\\n             max = Math.max(max , prev);\\n        }        \\n        return max;        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int max =   nums[0];\\n        int prev = nums[0];       \\n        for(int i = 1 ; i < nums.length ;i++ ){\\n            if(prev + nums[i]  > nums[i]){\\n                prev =  prev + nums[i];             \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1280721,
                "title": "c-two-soln-o-n-o-n-2-explained",
                "content": "# KADEN\\'S ALGO\\n```\\n int maxSubArray(vector<int>& nums) {\\n        //Kaden\\'s algorithm\\n        \\n        int n=nums.size();\\n        int sum=0;\\n        int max_sum=INT_MIN; //if all the numbers are negative it works \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];        \\n            max_sum=max(sum,max_sum); //taking max at each index\\n            if(sum<0) \\n            {               //if the sum till the present index is less than 0,\\n                            //we will skip all the numers till then\\n                sum=0;\\n            }\\n            \\n        }\\n        return max_sum;\\n\\t\\t}\\n```\\n\\n# BRUTE FORCE\\n```\\nint maxSubArray(vector<int>& nums) {\\n\\tint n=nums.size();\\n        int max_sum=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                sum=sum+nums[j];\\n                max_sum=max(max_sum,sum);\\n                \\n            }\\n        }\\n        return max_sum;\\n\\t}\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int maxSubArray(vector<int>& nums) {\\n        //Kaden\\'s algorithm\\n        \\n        int n=nums.size();\\n        int sum=0;\\n        int max_sum=INT_MIN; //if all the numbers are negative it works \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];        \\n            max_sum=max(sum,max_sum); //taking max at each index\\n            if(sum<0) \\n            {               //if the sum till the present index is less than 0,\\n                            //we will skip all the numers till then\\n                sum=0;\\n            }\\n            \\n        }\\n        return max_sum;\\n\\t\\t}\\n```\n```\\nint maxSubArray(vector<int>& nums) {\\n\\tint n=nums.size();\\n        int max_sum=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                sum=sum+nums[j];\\n                max_sum=max(max_sum,sum);\\n                \\n            }\\n        }\\n        return max_sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152811,
                "title": "kadane-s-algorithm-javascript",
                "content": "Runtime: 80 ms, faster than 88.41% of JavaScript online submissions for Maximum Subarray.\\nMemory Usage: 39 MB, less than 85.87% of JavaScript online submissions for Maximum Subarray.\\n\\n```\\nvar maxSubArray = function(nums) {\\n    let sum = 0;\\n    let maxSum = -Infinity;\\n    \\n    if(nums.length === 0) return 0;\\n    if(nums.length === 1) return nums[0]\\n    \\n    for(let i = 0;i<nums.length;i++){\\n        sum+=nums[i];\\n        maxSum = Math.max(maxSum,sum);\\n        if(sum < 0) sum = 0;\\n    }\\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n    let sum = 0;\\n    let maxSum = -Infinity;\\n    \\n    if(nums.length === 0) return 0;\\n    if(nums.length === 1) return nums[0]\\n    \\n    for(let i = 0;i<nums.length;i++){\\n        sum+=nums[i];\\n        maxSum = Math.max(maxSum,sum);\\n        if(sum < 0) sum = 0;\\n    }\\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20422,
                "title": "python-o-n-simple-kadane-s-algo",
                "content": "https://en.wikipedia.org/wiki/Maximum_subarray_problem\\n\\n    def maxSubArray(nums):\\n        sum = res = nums[0]\\n        for i in range(1,len(nums)):\\n            sum = max(nums[i], sum+nums[i])\\n            res = max(res, sum)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "https://en.wikipedia.org/wiki/Maximum_subarray_problem\\n\\n    def maxSubArray(nums):\\n        sum = res = nums[0]\\n        for i in range(1,len(nums)):\\n            sum = max(nums[i], sum+nums[i])\\n            res = max(res, sum)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 20546,
                "title": "explanation-on-applying-the-dynamic-programming-method-for-this-problem",
                "content": "The dynamic programming method to solve this problem relies on the following formulas: \\n\\n    L[i] = max(L[i-1] + A[i], A[i])\\n\\nwhere L[i] stores the maximum sum of continuous subarray starting from the element A[i] towards the end of A[0].\\n\\nNote that, the subarray that has the maximum value does not necessarily need to contain the element A[i]. It is just that L[i] holds the value, so that it can be used by the next iteration. \\n\\nOnce we reach the end of the array with L[i], which is to say that, we obtain the maximum sum of continuous subarray for the entire array. \\n\\n    public int maxSubArray(int[] A) {\\n        \\tif(A.length == 0){\\n        \\t\\treturn 0;\\n        \\t}\\n        \\t\\n        \\tint [] dp = new int[A.length]; \\n            \\n            int max_sum = A[0];\\n            dp[0] = A[0];\\n        \\t\\n            for(int i=1; i<A.length; i++){\\n                dp[i] = Math.max(dp[i-1] + A[i], A[i]);\\n                max_sum = Math.max(dp[i], max_sum);\\n        \\t}\\n            \\n            return max_sum;\\t \\n        }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The dynamic programming method to solve this problem relies on the following formulas: \\n\\n    L[i] = max(L[i-1] + A[i], A[i])\\n\\nwhere L[i] stores the maximum sum of continuous subarray starting from the element A[i] towards the end of A[0].\\n\\nNote that, the subarray that has the maximum value does not necessarily need to contain the element A[i]. It is just that L[i] holds the value, so that it can be used by the next iteration. \\n\\nOnce we reach the end of the array with L[i], which is to say that, we obtain the maximum sum of continuous subarray for the entire array. \\n\\n    public int maxSubArray(int[] A) {\\n        \\tif(A.length == 0){\\n        \\t\\treturn 0;\\n        \\t}\\n        \\t\\n        \\tint [] dp = new int[A.length]; \\n            \\n            int max_sum = A[0];\\n            dp[0] = A[0];\\n        \\t\\n            for(int i=1; i<A.length; i++){\\n                dp[i] = Math.max(dp[i-1] + A[i], A[i]);\\n                max_sum = Math.max(dp[i], max_sum);\\n        \\t}\\n            \\n            return max_sum;\\t \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3401689,
                "title": "very-easy-solution-beats-100-java-o-n-timecomplexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int count=0;\\n        int max=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            count+=nums[i];\\n            if(max<count){\\n                max=count;\\n            }\\n            if(count<0){\\n                count=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\nUpvote if you Like it \\uD83D\\uDE0A\\n\\u2B07\\uFE0F",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int count=0;\\n        int max=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            count+=nums[i];\\n            if(max<count){\\n                max=count;\\n            }\\n            if(count<0){\\n                count=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067286,
                "title": "simple-c-vey-short-and-clear-explanation-kadane-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo if there is not any negative number then the whole array wil be answer and keeping this in mind when a negative number comes if our sum is still positive we can include that but if our sum becomes negative then we gonna start out subarry after this . Basically we have to include as many elements as we can but when negative comes in between we have to check if sum is still postive because if sum is negative then they are not good to include ....\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just keep two variables sum and maxi and check if our sum beomes less than zero then  start form the next elemnt if not then keep adding the elements in the sum and keep upadating our maxi .\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxi=arr[0],sum=arr[0];\\n        for(int i=1;i<n;i++){\\n           if(sum<0)sum=arr[i];\\n           else sum+=arr[i];\\n           maxi=max(sum,maxi);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxi=arr[0],sum=arr[0];\\n        for(int i=1;i<n;i++){\\n           if(sum<0)sum=arr[i];\\n           else sum+=arr[i];\\n           maxi=max(sum,maxi);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704505,
                "title": "c-java-python3-javascript-faster-than-95-o-n",
                "content": "### C#,Java,Python3,JavaScript  solution with explanation\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-53-maximum-subarray-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-53-maximum-subarray-solution-and-explanation-en/)\\u2B50**\\n\\n \\n#### **Example : JavaScript( \\u2B06To see other languages \\u2B06)**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    var max = nums[0];\\n    var tmp =0;\\n    for(var i = 0;i<nums.length;i++)\\n    {\\n        tmp+=nums[i];\\n        if(tmp>max)\\n        {\\n            max = tmp;\\n        }\\n        if(tmp<0)\\n        {\\n            tmp = 0;\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).\\n\\n**Thanks!**\\n\\nYou can find out other LeetCode problems solution here\\n**\\uD83E\\uDDE1[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    var max = nums[0];\\n    var tmp =0;\\n    for(var i = 0;i<nums.length;i++)\\n    {\\n        tmp+=nums[i];\\n        if(tmp>max)\\n        {\\n            max = tmp;\\n        }\\n        if(tmp<0)\\n        {\\n            tmp = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693020,
                "title": "c-easy-fast-and-short-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int> dp(nums.size());\\n        int ans = nums[0];\\n        dp[0]=nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            dp[i]=max(nums[i], nums[i]+dp[i-1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int> dp(nums.size());\\n        int ans = nums[0];\\n        dp[0]=nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            dp[i]=max(nums[i], nums[i]+dp[i-1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625218,
                "title": "python-three-liner",
                "content": "```\\ndef maxSubArray(self, nums):\\n        for i in range(1, len(nums)):\\n            nums[i] = max(nums[i-1] + nums[i], nums[i])\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxSubArray(self, nums):\\n        for i in range(1, len(nums)):\\n            nums[i] = max(nums[i-1] + nums[i], nums[i])\\n        return max(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2239330,
                "title": "python-kadane-s-algorithm-time-o-n-space-o-1-explained",
                "content": "# Explaination:\\nThis problem is basically asking us, if we were to check every sum of every single subarray in the input array we were given, what would be the max sum?\\n**Example Input:** [1,2,-2]\\n**Subarrays:**\\n[1] -> Sum = 1\\n[1,2] -> Sum = 3\\n[1,2,-2] -> Sum = 1\\n[2] -> Sum = 2\\n[2,-2] -> Sum = 0\\n[-2] -> Sum = -2\\nThe Max Sum would be 3 from the subarray [1,2]\\n\\nA subarray basically means there are no breaks in-between. \\nSo for the example, that input [1,2,-2]\\nA valid subarray is [1,2] or [1,2,-2]. \\nBut [1,-2] would NOT be a subarray because it skipped 2.\\n\\n**Solution Explaination:**\\nTo solve this problem we break it down into sub problems. Basically we will use Kadane\\'s Algorithm. All we will be doing is, on every iteration we ask ourselves, **\"Do we want to extend the subarray we have seen so far? Or do we want to start a new subarray?\"**\\n\\nTo answer these questions, we look at the sum of the previous subarray and add it to the current number we are on, this will be the sum if we extend the subarray we have seen so far.\\nThen we just compare the sum of the extension to the number we are at currently, if the number we are at currently is bigger than the sum after extending the previous subarray, we start a new subarray. \\n**Lets see an example:** [1,2,-2]\\nLets say we visited 1 already, so our currentSum is 1.\\nNow we are at 2, we ask ourselves, \"should I extend my previous subarray `[1]` with the sum of 1, or should I start a new subarray at `[2]`?\\nIf we extend, the new subarray will be `[1,2]` with a sum of 3\\nIf we don\\'t extend and start a new subarray, the new subarray will be `[2]` with a sum of 2.\\n3 is greater than 2, so we choose to extend our previous subarray.\\n\\nBut now we are at -2.\\nDo we extend our previous subarray or start a new?\\nWell, our previous subarray `[1,2]` has a sum 3, and if we add -2, it becomes 1\\nSo if we start a new subarray it will be `[-2]` with a sum of -2.\\n1 is greater than -2 so we extend our previous subarray.\\n\\nWhat if our input was instead, [1,2,-4, 1]?\\nLets say we reach -3, our previous subarray would be 3 so if we extend we do 3 + -4 which would be -1 and -1 is greater than -4 so we just extend the subarray.\\nBut notice, now we reach 1, the last input in the array.\\n\\nIf we extend we will do -1 + 1 which will be 0.\\nIf we start a new subarray, it will be 1.\\n1 is greater than 0, so we start a new subarray. This is the case we must handle and watch out for because this can change our entire answer.\\n\\n**Solution Breakdown:**\\n1. We create a variable `maxSum` to keep track of the max sum we have seen from all the subarrays.\\n2. We create a variable `curSum` to keep track of the current subarray sum\\n3. Now we just use a `for` loop to iterate through every number in `nums`\\n4. Now we ask ourselves the question on every iteration. **\"Do we want to extend from our previous subarray sum? Or do we want to start a new subarray?**\\n5. `curSum + num` represents the sum we will get if we extend from our previous subarray and `num` just represents the new sum we will have if we start a new subarray. If the sum after extending the previous subarray is smaller than the sum of the current number we are on, we just start a new subarray and save the current number to `curSum`\\n6. If the sum after extending the previous subarray is bigger or equal, then we just add the current number to our previous subarray sum `curSum` to continue extending.\\n7. On every iteration we check if our `curSum` for the subarray we are on is bigger than our previous `maxSum` and if it is, we save it in `maxSum`\\n8. Finally we just return `maxSum`\\n\\n**Time O(N) | Space O(1)**\\nTime is O(N) because we just iterate through the entire array once.\\nSpace is O(1) because we are using scaling memory/space which scales with the input. We only have variables that we are modifiyng. \\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = nums[0] # Keep track of max sub-array sum\\n        curSum = 0 # Keep track of current sub-array sum\\n        \\n        for num in nums:\\n            if curSum + num < num:\\n                curSum = num # Start a new sub-array\\n            else:\\n                curSum = curSum + num # Extend from our previous sub-array\\n            maxSum = max(maxSum, curSum)\\n        return maxSum\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = nums[0] # Keep track of max sub-array sum\\n        curSum = 0 # Keep track of current sub-array sum\\n        \\n        for num in nums:\\n            if curSum + num < num:\\n                curSum = num # Start a new sub-array\\n            else:\\n                curSum = curSum + num # Extend from our previous sub-array\\n            maxSum = max(maxSum, curSum)\\n        return maxSum\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213371,
                "title": "c-recursive-mmemoized-and-divide-and-conquor-methods-no-kadanes-algo",
                "content": "Method 1- Recursion - TLE( O(n^2) )\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums,int idx,bool takeit)\\n    {\\n\\t   //took a value and reached the end, now cannot take anything so return 0, else it means you havent taken anything till now, not a valid case\\n        if(idx>=nums.size())\\n        {\\n            return takeit?0:-1e9;\\n        }\\n        //if taken a value previosuly, either return with that value, or take curr value again and recurse\\n        if(takeit)\\n        {\\n            return max(0,nums[idx]+f(nums,idx+1,true));\\n        }\\n        //if not taken any value before, take currvalue and recurse or not take curr value and recurse\\n        return max(nums[idx]+f(nums,idx+1,true) , f(nums,idx+1,false));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        return f(nums,0,false);\\n    }\\n};\\n```\\n\\nMethod -2 Memoized Code (O(n))\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&dp,vector<int>& nums,int idx,bool takeit)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            return takeit?0:-1e9;\\n        }\\n        if(dp[idx][takeit]!=-1)\\n        {\\n            return dp[idx][takeit];\\n        }\\n        //if taken a value previosuly, either return with that value, or take curr value again and recurse\\n        if(takeit)\\n        {\\n            return dp[idx][takeit]=max(0,nums[idx]+f(dp,nums,idx+1,true));\\n        }\\n        //if not taken any value before, take currvalue and recurse or not take curr value and recurse\\n        return dp[idx][takeit]=max(nums[idx]+f(dp,nums,idx+1,true) , f(dp,nums,idx+1,false));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(),vector<int>(2,-1));\\n        return f(dp,nums,0,false);\\n    }\\n};\\n```\\n\\nMethod-3 Divide and Conqour (O(nlogn)\\nat any index i, \\n* Either max subarray sum lies in left half of i \\n* or right half of i\\n* or some part on left of i and some part on right of i including i\\n\\n```\\nclass Solution {\\npublic:\\n    int dc(vector<int>& nums,int l,int r)\\n    {\\n        //invalid case,no elements are there to take in sum\\n        if(l>r)\\n        {\\n            return INT_MIN;\\n        }\\n        int mid=(l+r)/2;\\n        int leftsum=0;\\n        int rightsum=0;\\n        int curr=0;\\n        for(int i=mid-1;i>=l;i--)\\n        {\\n            curr+=nums[i];\\n            leftsum=max(leftsum,curr);\\n        }\\n        curr=0;\\n        for(int i=mid+1;i<=r;i++)\\n        {\\n            curr+=nums[i];\\n            rightsum=max(rightsum,curr);\\n        }\\n        \\n        return max(leftsum+nums[mid]+rightsum ,max(dc(nums,l,mid-1) , dc(nums,mid+1,r)));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        return dc(nums,l,r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums,int idx,bool takeit)\\n    {\\n\\t   //took a value and reached the end, now cannot take anything so return 0, else it means you havent taken anything till now, not a valid case\\n        if(idx>=nums.size())\\n        {\\n            return takeit?0:-1e9;\\n        }\\n        //if taken a value previosuly, either return with that value, or take curr value again and recurse\\n        if(takeit)\\n        {\\n            return max(0,nums[idx]+f(nums,idx+1,true));\\n        }\\n        //if not taken any value before, take currvalue and recurse or not take curr value and recurse\\n        return max(nums[idx]+f(nums,idx+1,true) , f(nums,idx+1,false));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        return f(nums,0,false);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&dp,vector<int>& nums,int idx,bool takeit)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            return takeit?0:-1e9;\\n        }\\n        if(dp[idx][takeit]!=-1)\\n        {\\n            return dp[idx][takeit];\\n        }\\n        //if taken a value previosuly, either return with that value, or take curr value again and recurse\\n        if(takeit)\\n        {\\n            return dp[idx][takeit]=max(0,nums[idx]+f(dp,nums,idx+1,true));\\n        }\\n        //if not taken any value before, take currvalue and recurse or not take curr value and recurse\\n        return dp[idx][takeit]=max(nums[idx]+f(dp,nums,idx+1,true) , f(dp,nums,idx+1,false));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(),vector<int>(2,-1));\\n        return f(dp,nums,0,false);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dc(vector<int>& nums,int l,int r)\\n    {\\n        //invalid case,no elements are there to take in sum\\n        if(l>r)\\n        {\\n            return INT_MIN;\\n        }\\n        int mid=(l+r)/2;\\n        int leftsum=0;\\n        int rightsum=0;\\n        int curr=0;\\n        for(int i=mid-1;i>=l;i--)\\n        {\\n            curr+=nums[i];\\n            leftsum=max(leftsum,curr);\\n        }\\n        curr=0;\\n        for(int i=mid+1;i<=r;i++)\\n        {\\n            curr+=nums[i];\\n            rightsum=max(rightsum,curr);\\n        }\\n        \\n        return max(leftsum+nums[mid]+rightsum ,max(dc(nums,l,mid-1) , dc(nums,mid+1,r)));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        return dc(nums,l,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990093,
                "title": "python-simple-iterative-solution-kadane-s-algorithm",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        \\n        max_sub = nums[0]\\n        current_sum = 0\\n        \\n        for n in nums:\\n            if current_sum < 0:\\n                current_sum = 0\\n            current_sum += n\\n            \\n            max_sub = max(max_sub, current_sum)\\n        \\n        return max_sub\\n        \\n```\\nTime complexity: O(N)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        \\n        max_sub = nums[0]\\n        current_sum = 0\\n        \\n        for n in nums:\\n            if current_sum < 0:\\n                current_sum = 0\\n            current_sum += n\\n            \\n            max_sub = max(max_sub, current_sum)\\n        \\n        return max_sub\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859798,
                "title": "o-n-solution-start-and-end-index-of-subarray-follow-up",
                "content": "**Motivation:**\\nIt is intuitive to find the maximum subarray sum in linear time (use Kadane\\'s algo or dynamic programming). \\nBut what if we are asked to find the elements in the maximum subarray? (Follow-up question)\\nHow do we find the start and end index of the maximum subarray?\\n\\n**Explanation:**\\nWe need 2 variables to keep track of local (\"current\") subarray start/end index as we traverse the input array.\\nWe also need 2 variables that store the \"global\" start/end index of the maximum subarray. We update the \"global\" start/end index whenever we find a \"better\" subarray with a greater sum.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return\\n        max_sum = curr_sum = -math.inf\\n        start = end = 0 # init vars\\n        \\n        for i, n in enumerate(nums):\\n            if curr_sum + n < n: \\n                curr_sum = n # don\\'t need previous subarr sum\\n                curr_start = curr_end = i # reset indices \\n            else:\\n                curr_sum += n # need previous subarr\\n                curr_end = i # update right index\\n            if curr_sum > max_sum: # found a subarr with greater sum\\n                max_sum = curr_sum\\n                start, end = curr_start, curr_end # assign indices for later use\\n    \\n        return sum(nums[start:end+1]) # max sum using start/end index\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return\\n        max_sum = curr_sum = -math.inf\\n        start = end = 0 # init vars\\n        \\n        for i, n in enumerate(nums):\\n            if curr_sum + n < n: \\n                curr_sum = n # don\\'t need previous subarr sum\\n                curr_start = curr_end = i # reset indices \\n            else:\\n                curr_sum += n # need previous subarr\\n                curr_end = i # update right index\\n            if curr_sum > max_sum: # found a subarr with greater sum\\n                max_sum = curr_sum\\n                start, end = curr_start, curr_end # assign indices for later use\\n    \\n        return sum(nums[start:end+1]) # max sum using start/end index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849465,
                "title": "divide-and-conquer-approach-with-python",
                "content": "After splitting into two sub arrays, in addition to the max sum in each sub array, we need also consider the case that contains the both left tail and right head element. As in graph shown below:\\n1. (Green): Max sum from left sub array.\\n1. (Orance): Max sum from right sub array.\\n1. (Red): Max sum which must include both left tail (**mid**) and right head (**mid + 1**).\\n![image](https://assets.leetcode.com/users/images/211149ea-8d22-4ca2-81e1-3afab2558f8e_1647277866.9101987.png)\\n\\nThe first two can be obtained by directly calling recursive function. \\nFor the 3rd one, we can start from tail/head and iterate through the entire sub array to get the max sums. Then we can add them together and compare with the two sums from #1 and #2.  \\n\\xB7\\xB7\\xB7\\n\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        def helper_subArray(left, right):\\n            if left == right:\\n                return (nums[left])\\n\\n            # Calculate max sum of left and right sub array\\n            mid = left + (right - left) // 2\\n            left_max = helper_subArray(left, mid)\\n            right_max = helper_subArray(mid + 1, right)\\n\\n            # Calculate max sum which contains both left tail and right head\\n            \\n            # Get left max with the tail of left sub array included\\n            left_cross_max = -2 * (10 ** 4)\\n            left_cross_sum = 0\\n            for i in range(mid, left - 1, -1):\\n                left_cross_sum += nums[i]\\n                left_cross_max = max(left_cross_max, left_cross_sum)\\n            \\n            # Get right max with the head of right sub array included\\n            right_cross_max = nums[mid + 1]\\n            right_cross_sum = 0\\n            for j in range(mid + 1, right + 1):\\n                right_cross_sum += nums[j]\\n                right_cross_max = max(right_cross_max, right_cross_sum)\\n            \\n            # Compare 3 and return grand max\\n            cross_max = left_cross_max + right_cross_max\\n            return max(cross_max, max(left_max, right_max))\\n\\n        return helper_subArray(0, len(nums) - 1)\\n\\n\\xB7\\xB7\\xB7",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "After splitting into two sub arrays, in addition to the max sum in each sub array, we need also consider the case that contains the both left tail and right head element. As in graph shown below:\\n1. (Green): Max sum from left sub array.\\n1. (Orance): Max sum from right sub array.\\n1. (Red): Max sum which must include both left tail (**mid**) and right head (**mid + 1**).\\n![image](https://assets.leetcode.com/users/images/211149ea-8d22-4ca2-81e1-3afab2558f8e_1647277866.9101987.png)\\n\\nThe first two can be obtained by directly calling recursive function. \\nFor the 3rd one, we can start from tail/head and iterate through the entire sub array to get the max sums. Then we can add them together and compare with the two sums from #1 and #2.  \\n\\xB7\\xB7\\xB7\\n\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        def helper_subArray(left, right):\\n            if left == right:\\n                return (nums[left])\\n\\n            # Calculate max sum of left and right sub array\\n            mid = left + (right - left) // 2\\n            left_max = helper_subArray(left, mid)\\n            right_max = helper_subArray(mid + 1, right)\\n\\n            # Calculate max sum which contains both left tail and right head\\n            \\n            # Get left max with the tail of left sub array included\\n            left_cross_max = -2 * (10 ** 4)\\n            left_cross_sum = 0\\n            for i in range(mid, left - 1, -1):\\n                left_cross_sum += nums[i]\\n                left_cross_max = max(left_cross_max, left_cross_sum)\\n            \\n            # Get right max with the head of right sub array included\\n            right_cross_max = nums[mid + 1]\\n            right_cross_sum = 0\\n            for j in range(mid + 1, right + 1):\\n                right_cross_sum += nums[j]\\n                right_cross_max = max(right_cross_max, right_cross_sum)\\n            \\n            # Compare 3 and return grand max\\n            cross_max = left_cross_max + right_cross_max\\n            return max(cross_max, max(left_max, right_max))\\n\\n        return helper_subArray(0, len(nums) - 1)\\n\\n\\xB7\\xB7\\xB7",
                "codeTag": "Python3"
            },
            {
                "id": 1661797,
                "title": "1ms-100-faster-java-solution-super-easy-to-understand",
                "content": "Here we have taken two counters, basically int tillNow check the **MAX** between **tillNow+nums[i] and nums[i].**\\n*(nums[i] is nothing but the next index\\'s value.)*\\nAnd on the other hand, int soFar checks which one is **MAX** between **soFar and tillNow.**\\n\\nThis way we are taking time to decide what if we add the next index\\'s value, will it be smaller than the next element? if not then it\\'ll **continue adding**.\\n\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int soFar = nums[0], tillNow = nums[0], i=1;\\n        while(i<nums.length) {\\n            tillNow = Math.max(tillNow+nums[i], nums[i]);\\n            soFar = Math.max(soFar, tillNow);\\n            i++;\\n        }\\n        return soFar;\\n    }\\n}\\n```\\n\\n\\n**Why we are not using for loop?**\\nAns: While loop took 1ms & 49.8 MB whereas for loop took >=2 ms & 90MB.\\n\\t\\tThere\\'s no issue with for loop. It\\'s upto the programmer.\\n\\n**An Upvote will be appreciated!\\nThank You!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int soFar = nums[0], tillNow = nums[0], i=1;\\n        while(i<nums.length) {\\n            tillNow = Math.max(tillNow+nums[i], nums[i]);\\n            soFar = Math.max(soFar, tillNow);\\n            i++;\\n        }\\n        return soFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523778,
                "title": "java-optimised-solution",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : nums){\\n            sum += i;\\n            max = Math.max(max, sum);\\n            sum = sum < 0  ? 0 : sum;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n\\n***Please upvote if you like the solution***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : nums){\\n            sum += i;\\n            max = Math.max(max, sum);\\n            sum = sum < 0  ? 0 : sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454327,
                "title": "easy-c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i] =max(0, dp[i-1]) + nums[i];\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i] =max(0, dp[i-1]) + nums[i];\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077530,
                "title": "four-line-solution-mja-aa-jayega",
                "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {  \\n     for(int i=1;i<nums.size();i++)\\n     {nums[i]=max(nums[i],nums[i]+nums[i-1]);\\n      nums[0]=max(nums[0],nums[i]);}\\n     return nums[0];   \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {  \\n     for(int i=1;i<nums.size();i++)\\n     {nums[i]=max(nums[i],nums[i]+nums[i-1]);\\n      nums[0]=max(nums[0],nums[i]);}",
                "codeTag": "Java"
            },
            {
                "id": 745456,
                "title": "python-sliding-window-in-o-n",
                "content": "The idea is similar to the sliding window approach.\\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        max_sum = float(\\'-inf\\')\\n        curr_sum = 0\\n        for num in nums:\\n            # compute sum for previous subarray\\n            curr_sum += num\\n            \\n            # if current sum <= the current number,\\n            # no need to include previous subarray\\n            if curr_sum <= num:\\n                curr_sum = num\\n                \\n            max_sum = max(max_sum, curr_sum)  \\n        return max_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        max_sum = float(\\'-inf\\')\\n        curr_sum = 0\\n        for num in nums:\\n            # compute sum for previous subarray\\n            curr_sum += num\\n            \\n            # if current sum <= the current number,\\n            # no need to include previous subarray\\n            if curr_sum <= num:\\n                curr_sum = num\\n                \\n            max_sum = max(max_sum, curr_sum)  \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194598,
                "title": "python-kadane-s-algorithm-self-explanatory-code",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        currsum, overallsum = nums[0], nums[0]\\n        if len(nums)==1: return nums[0]\\n        for i in range (1,len(nums)):\\n            if currsum>=0: currsum+=nums[i]\\n            else: currsum=nums[i]\\n            if currsum>overallsum: overallsum=currsum\\n        return overallsum\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        currsum, overallsum = nums[0], nums[0]\\n        if len(nums)==1: return nums[0]\\n        for i in range (1,len(nums)):\\n            if currsum>=0: currsum+=nums[i]\\n            else: currsum=nums[i]\\n            if currsum>overallsum: overallsum=currsum\\n        return overallsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047442,
                "title": "java-simple-runtime-1ms-100",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int max = nums[0];\\n        int sec = 0;\\n        for (int num : nums) {\\n            sec += num;\\n            if (max < sec) max = sec;\\n            if (sec < 0)  sec = 0;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int max = nums[0];\\n        int sec = 0;\\n        for (int num : nums) {\\n            sec += num;\\n            if (max < sec) max = sec;\\n            if (sec < 0)  sec = 0;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029740,
                "title": "python-easy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        # init max sum, curr sum to the first element\\n        curr_sum, max_sum = nums[0], nums[0]\\n        \\n        # iterate nums\\n        for num in nums[1:]:\\n            # for each num, we have 2 options:\\n            # we can choose to add it to the cumulative sum,\\n            # or start a new cumulative sum from the current num\\n            \\n            # if the current number is greater than current sum + current number, we\\'ll reset the sum to curr number\\n            if num > num + curr_sum:\\n                curr_sum = num\\n            else:\\n                curr_sum += num\\n            \\n            # we\\'ll update the max sum each time\\n            max_sum = max(curr_sum, max_sum)\\n        \\n        return max_sum\\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        # init max sum, curr sum to the first element\\n        curr_sum, max_sum = nums[0], nums[0]\\n        \\n        # iterate nums\\n        for num in nums[1:]:\\n            # for each num, we have 2 options:\\n            # we can choose to add it to the cumulative sum,\\n            # or start a new cumulative sum from the current num\\n            \\n            # if the current number is greater than current sum + current number, we\\'ll reset the sum to curr number\\n            if num > num + curr_sum:\\n                curr_sum = num\\n            else:\\n                curr_sum += num\\n            \\n            # we\\'ll update the max sum each time\\n            max_sum = max(curr_sum, max_sum)\\n        \\n        return max_sum\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850628,
                "title": "simplest-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int currentSum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            currentSum += nums[i];\\n            if(currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            if(currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int currentSum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            currentSum += nums[i];\\n            if(currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            if(currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749512,
                "title": "simple-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            nums[i] = max(nums[i]+nums[i-1],nums[i])\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            nums[i] = max(nums[i]+nums[i-1],nums[i])\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611064,
                "title": "java-divide-and-conquer-solution",
                "content": "**Note**: Kadane\\'s algorithm is better because it has linear complexity. \\nThis post is limited to divide and conquer solution, more generic approach.\\n\\nIn divide and conquer we divide array in half and solve both halves recursively.\\n\\n**There are 3 cases:**\\n1. best subarray sum is on the left\\n1. best subarray sum is on the right\\n1. best subarray sum is crossing the middle element\\n\\nWe solve 1. and 2. recursively\\nFor 3. we go over array from the middle to both sides keeping track of best sum for left and right side\\n\\n**Pseudocode**\\n```\\nmaxSubarray(A, lo, hi) {\\n\\tif lo == hi return A[lo]\\n\\tmid = (lo + hi) / 2\\n\\tL = maxSubarray(A, lo, mid - 1)\\n\\tR = maxSubarray(A, mid + 1, hi)\\n\\tC = maxCrossingSubarray(A, lo, mid, hi)\\n\\treturn max(L, R, C)\\n}\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        return solve(nums, 0, nums.length - 1);\\n    }\\n    \\n    int solve(int[] nums, int lo, int hi) {\\n        if(lo >= hi) {\\n            return nums[lo];\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        int L = solve(nums, lo, mid - 1);\\n        int R = solve(nums, mid + 1, hi);\\n        int C = cross(nums, lo, mid, hi);\\n        return Math.max(L, Math.max(R, C));\\n    }\\n    \\n    int cross(int[] nums, int lo, int mid, int hi) {\\n        int left = 0, maxLeft = 0;\\n        int right = 0, maxRight = 0;\\n        for(int i = mid - 1; i >= lo; i--) {\\n            left += nums[i];\\n            maxLeft = Math.max(left, maxLeft);\\n        }\\n        for(int i = mid + 1; i <= hi; i++) {\\n            right += nums[i];\\n            maxRight = Math.max(right, maxRight);\\n        }\\n        return maxLeft + maxRight + nums[mid];\\n    }\\n}\\n```\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return rec(nums, 0, nums.size());\\n    }\\n\\n    int rec(vector<int>& nums, int lo, int hi) {\\n        if(lo >= hi) {\\n            return -1e9;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        int L = rec(nums, lo, mid);\\n        int R = rec(nums, mid + 1, hi);\\n        int Cross = cross(nums, lo, mid, hi);\\n        return max({L, R, Cross});\\n    }\\n\\n    int cross(vector<int>& nums, int lo, int mid, int hi) {        \\n        int left = 0, curr = 0;\\n        for(int i = mid - 1; i >= lo; i--) {\\n            curr += nums[i];\\n            left = max(left, curr);\\n        }\\n        curr = 0;\\n        int right = 0;\\n        for(int i = mid + 1; i < hi; i++) {\\n            curr += nums[i];\\n            right = max(right, curr);\\n        }\\n        return left + nums[mid] + right;        \\n    }\\n};\\n```\\n\\n**Time complexity:** O(n * log(n))",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nmaxSubarray(A, lo, hi) {\\n\\tif lo == hi return A[lo]\\n\\tmid = (lo + hi) / 2\\n\\tL = maxSubarray(A, lo, mid - 1)\\n\\tR = maxSubarray(A, mid + 1, hi)\\n\\tC = maxCrossingSubarray(A, lo, mid, hi)\\n\\treturn max(L, R, C)\\n}\\n```\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        return solve(nums, 0, nums.length - 1);\\n    }\\n    \\n    int solve(int[] nums, int lo, int hi) {\\n        if(lo >= hi) {\\n            return nums[lo];\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        int L = solve(nums, lo, mid - 1);\\n        int R = solve(nums, mid + 1, hi);\\n        int C = cross(nums, lo, mid, hi);\\n        return Math.max(L, Math.max(R, C));\\n    }\\n    \\n    int cross(int[] nums, int lo, int mid, int hi) {\\n        int left = 0, maxLeft = 0;\\n        int right = 0, maxRight = 0;\\n        for(int i = mid - 1; i >= lo; i--) {\\n            left += nums[i];\\n            maxLeft = Math.max(left, maxLeft);\\n        }\\n        for(int i = mid + 1; i <= hi; i++) {\\n            right += nums[i];\\n            maxRight = Math.max(right, maxRight);\\n        }\\n        return maxLeft + maxRight + nums[mid];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return rec(nums, 0, nums.size());\\n    }\\n\\n    int rec(vector<int>& nums, int lo, int hi) {\\n        if(lo >= hi) {\\n            return -1e9;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        int L = rec(nums, lo, mid);\\n        int R = rec(nums, mid + 1, hi);\\n        int Cross = cross(nums, lo, mid, hi);\\n        return max({L, R, Cross});\\n    }\\n\\n    int cross(vector<int>& nums, int lo, int mid, int hi) {        \\n        int left = 0, curr = 0;\\n        for(int i = mid - 1; i >= lo; i--) {\\n            curr += nums[i];\\n            left = max(left, curr);\\n        }\\n        curr = 0;\\n        int right = 0;\\n        for(int i = mid + 1; i < hi; i++) {\\n            curr += nums[i];\\n            right = max(right, curr);\\n        }\\n        return left + nums[mid] + right;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594944,
                "title": "c-simple-and-clean-one-pass-solution-brief-explanation",
                "content": "**Idea:**\\nWe iterate through the array, while summing it.\\nEach time, we check what\\'s worth more: the running sum or only the current element.\\nWhich means, that if the running sum went below zero and the current number is positive, we will want to try starting our subarray from here.\\nIn `max_sum` we keep the maximum subarray so far.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:  \\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = nums[0], sum = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            sum = max(sum + nums[i], nums[i]);\\n            max_sum = max(max_sum, sum);\\n        }\\n        return max_sum;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = nums[0], sum = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            sum = max(sum + nums[i], nums[i]);\\n            max_sum = max(max_sum, sum);\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485418,
                "title": "python-kadane-s-algorithm-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current, result = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            current = max(current + nums[i], nums[i] )\\n            result = max(current, result)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current, result = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            current = max(current + nums[i], nums[i] )\\n            result = max(current, result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304544,
                "title": "go-easy-o-1-space",
                "content": "Do upvote if it helps! :)\\n```\\nfunc max(a int, b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\nfunc maxSubArray(nums []int) int {\\n    running_sum:=nums[0]\\n    sum:=nums[0]\\n    for i:=1;i<len(nums);i++{\\n        running_sum=max(running_sum+nums[i],nums[i])\\n        if(running_sum>sum){\\n            sum=running_sum\\n        }\\n        if(running_sum<0){\\n            running_sum=0\\n        }\\n    }\\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(a int, b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\nfunc maxSubArray(nums []int) int {\\n    running_sum:=nums[0]\\n    sum:=nums[0]\\n    for i:=1;i<len(nums);i++{\\n        running_sum=max(running_sum+nums[i],nums[i])\\n        if(running_sum>sum){\\n            sum=running_sum\\n        }\\n        if(running_sum<0){\\n            running_sum=0\\n        }\\n    }\\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1243564,
                "title": "c-3-interview-approaches",
                "content": "```\\n//Approach-1 (Time : O(n^2))\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n   = nums.size();\\n        for(int i = 1; i<n; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        int maxS = INT_MIN;\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = i; j<n; j++) {\\n                int end   =  nums[j];\\n                int start =  i > 0 ? nums[i-1] : 0;\\n                maxS = max(maxS, end-start);\\n            }\\n        }\\n        \\n        return maxS;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Time : O(nlogn))\\nclass Solution {\\npublic:\\n    int divideConquer(vector<int>& nums, int l, int r) {\\n        if(l > r) {\\n            return INT_MIN;\\n        }\\n        \\n        int mid   = l + (r-l)/2;\\n        int Lsum  = divideConquer(nums, l, mid-1);\\n        int Rsum  = divideConquer(nums, mid+1, r);\\n        \\n        int leftSum  = 0;\\n        int rightSum = 0;\\n        int tempSum  =  0 ;\\n        for(int i = mid-1; i >= l; i--) {\\n            tempSum += nums[i];\\n            leftSum = max(leftSum, tempSum);\\n        }\\n        \\n        tempSum = 0;\\n        for(int i = mid+1; i <= r; i++) {\\n            tempSum += nums[i];\\n            rightSum = max(rightSum, tempSum);\\n        }\\n        \\n        return max({Lsum, Rsum, leftSum + rightSum + nums[mid]});\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        int n   = nums.size();\\n        \\n        return divideConquer(nums, 0, n-1);\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (Time : O(n)) Kadane\\'s Algorithm\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n       = nums.size();\\n        int sum     = nums[0];\\n        int maxSum  = nums[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            sum     = max(sum + nums[i], nums[i]);\\n            maxSum  = max(maxSum, sum);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Time : O(n^2))\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n   = nums.size();\\n        for(int i = 1; i<n; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        int maxS = INT_MIN;\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = i; j<n; j++) {\\n                int end   =  nums[j];\\n                int start =  i > 0 ? nums[i-1] : 0;\\n                maxS = max(maxS, end-start);\\n            }\\n        }\\n        \\n        return maxS;\\n    }\\n};\\n```\n```\\n//Approach-2 (Time : O(nlogn))\\nclass Solution {\\npublic:\\n    int divideConquer(vector<int>& nums, int l, int r) {\\n        if(l > r) {\\n            return INT_MIN;\\n        }\\n        \\n        int mid   = l + (r-l)/2;\\n        int Lsum  = divideConquer(nums, l, mid-1);\\n        int Rsum  = divideConquer(nums, mid+1, r);\\n        \\n        int leftSum  = 0;\\n        int rightSum = 0;\\n        int tempSum  =  0 ;\\n        for(int i = mid-1; i >= l; i--) {\\n            tempSum += nums[i];\\n            leftSum = max(leftSum, tempSum);\\n        }\\n        \\n        tempSum = 0;\\n        for(int i = mid+1; i <= r; i++) {\\n            tempSum += nums[i];\\n            rightSum = max(rightSum, tempSum);\\n        }\\n        \\n        return max({Lsum, Rsum, leftSum + rightSum + nums[mid]});\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        int n   = nums.size();\\n        \\n        return divideConquer(nums, 0, n-1);\\n    }\\n};\\n```\n```\\n//Approach-3 (Time : O(n)) Kadane\\'s Algorithm\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n       = nums.size();\\n        int sum     = nums[0];\\n        int maxSum  = nums[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            sum     = max(sum + nums[i], nums[i]);\\n            maxSum  = max(maxSum, sum);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234480,
                "title": "python-o-n-logn-divide-conquer-o-n-using-kadane-s-algorithm",
                "content": "**Following is the O(n) solution using the Kadane\\'s Algorithm**\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        add = 0                                     # A variable to store the sum of the elements\\n        ans = 0                                     # A variable to store the last positive sum value\\n        cnt = 0                                     # A variable to store the count of negative numbers in the list\\n        \\n        maxNegative = -math.inf                     # A variable to store the max negative value in the list, initial value of -infinity\\n        \\n        for i in nums:                              # Traverse all the elements in the list\\n            if i < 0:                               # If the ith element is negative\\n                cnt += 1                            # Then, increase the count value of negative elements in the list\\n                maxNegative = max(i, maxNegative)   # And update the value of \\'maxNegative\\'\\n                \\n            if add + i > 0:                         # If the summed value of \\'add\\' & the ith element is greater than 0\\n                add += i                            # Then, add the ith element with \\'add\\' & and store it to \\'add\\'\\n                \\n            else:                                   # Else if the summed value is negative\\n                add = 0                             # Then, reset the value of \\'add\\'\\n                \\n            ans = max(add, ans)                     # Update the value of \\'ans\\' with the max of \\'add\\' & \\'ans\\'\\n        \\n        # Check if all the values in the list are negative or not, if yes then return \\'maxNegative\\', else return \\'ans\\'\\n        return maxNegative if cnt==len(nums) else ans\\n\\n```\\n\\n**Following is the O(n.logn) solution using Divide & Conquer with Recursion**\\n```\\ndef maxSumSubarray(nums, low, high):\\n    if low == high:                                      # The base case, if the array has a single element,\\n        return nums[0]                                   # Then return it as the sub-array sum value\\n    \\n    mid = (low+high)//2                                  # Else, get the mid index\\n    leftMaxSubarray = maxSumSubarray(nums, low, mid)     # And, recall the \\'maxSumSubarray\\' fuction for the left subarray and store the max sum from that part in \\'leftMaxSubarray\\'\\n    rightMaxSubarray = maxSumSubarray(nums, mid+1, high) # And, recall the \\'maxSumSubarray\\' fuction for the right subarray and store the max sum from that part in \\'rightMaxSubarray\\'\\n    \\n                                                         # Now, get only the left half\\'s and right half\\'s sum and store\\n    leftSum = -math.inf                                  # To store the sum of the left half, initial value of negative infinity \\n    rightSum = -math.inf                                 # To store the sum of the right half, initial value of negative infinity \\n    \\n    add = 0                                              # To store the sum of the right sub-arrays, initialize with 0\\n\\n    i = mid                                              # First, the right sub-array, starting from the \\'mid\\' index\\n    while i < high:                                      # Traverse till the last index\\n        add += nums[i]                                   # Add each element to the \\'add\\' variable \\n        rightSum = max(add, rightSum)                    # Update the value of \\'rightSum\\' by taking the max between \\'add\\' & \\'rightSum\\'\\n        i += 1                                           # Move \\'i\\' to the next index\\n    \\n    add = 0                                              # To store the sum of the left sub-arrays, initialize with 0\\n    \\n    i = 0                                                # Then, the left sub-array, starting from the 1st index\\n    while i < mid:                                       # Traverse till the \\'mid\\' index\\n        add += nums[i]                                   # Add each element to the \\'add\\' variable \\n        leftSum = max(add, leftSum)                      # Update the value of \\'leftSum\\' by taking the max between \\'add\\' & \\'leftSum\\'\\n        i += 1                                           # Move \\'i\\' to the next index\\n        \\n    ans = max(leftMaxSubarray, rightMaxSubarray)         # Store the max of the max values of the left and right sub-arrays to \\'ans\\'\\n    return max(ans, leftSum+rightSum)                    # Return the max between \\'ans\\' and the sum of \\'leftSum\\' & \\'rightSum\\'\\n    \\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        return maxSumSubarray(nums, 0, len(nums))        # Return the value returned from the \\'maxSumSubarray\\' function\\n\\t\\t\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        add = 0                                     # A variable to store the sum of the elements\\n        ans = 0                                     # A variable to store the last positive sum value\\n        cnt = 0                                     # A variable to store the count of negative numbers in the list\\n        \\n        maxNegative = -math.inf                     # A variable to store the max negative value in the list, initial value of -infinity\\n        \\n        for i in nums:                              # Traverse all the elements in the list\\n            if i < 0:                               # If the ith element is negative\\n                cnt += 1                            # Then, increase the count value of negative elements in the list\\n                maxNegative = max(i, maxNegative)   # And update the value of \\'maxNegative\\'\\n                \\n            if add + i > 0:                         # If the summed value of \\'add\\' & the ith element is greater than 0\\n                add += i                            # Then, add the ith element with \\'add\\' & and store it to \\'add\\'\\n                \\n            else:                                   # Else if the summed value is negative\\n                add = 0                             # Then, reset the value of \\'add\\'\\n                \\n            ans = max(add, ans)                     # Update the value of \\'ans\\' with the max of \\'add\\' & \\'ans\\'\\n        \\n        # Check if all the values in the list are negative or not, if yes then return \\'maxNegative\\', else return \\'ans\\'\\n        return maxNegative if cnt==len(nums) else ans\\n\\n```\n```\\ndef maxSumSubarray(nums, low, high):\\n    if low == high:                                      # The base case, if the array has a single element,\\n        return nums[0]                                   # Then return it as the sub-array sum value\\n    \\n    mid = (low+high)//2                                  # Else, get the mid index\\n    leftMaxSubarray = maxSumSubarray(nums, low, mid)     # And, recall the \\'maxSumSubarray\\' fuction for the left subarray and store the max sum from that part in \\'leftMaxSubarray\\'\\n    rightMaxSubarray = maxSumSubarray(nums, mid+1, high) # And, recall the \\'maxSumSubarray\\' fuction for the right subarray and store the max sum from that part in \\'rightMaxSubarray\\'\\n    \\n                                                         # Now, get only the left half\\'s and right half\\'s sum and store\\n    leftSum = -math.inf                                  # To store the sum of the left half, initial value of negative infinity \\n    rightSum = -math.inf                                 # To store the sum of the right half, initial value of negative infinity \\n    \\n    add = 0                                              # To store the sum of the right sub-arrays, initialize with 0\\n\\n    i = mid                                              # First, the right sub-array, starting from the \\'mid\\' index\\n    while i < high:                                      # Traverse till the last index\\n        add += nums[i]                                   # Add each element to the \\'add\\' variable \\n        rightSum = max(add, rightSum)                    # Update the value of \\'rightSum\\' by taking the max between \\'add\\' & \\'rightSum\\'\\n        i += 1                                           # Move \\'i\\' to the next index\\n    \\n    add = 0                                              # To store the sum of the left sub-arrays, initialize with 0\\n    \\n    i = 0                                                # Then, the left sub-array, starting from the 1st index\\n    while i < mid:                                       # Traverse till the \\'mid\\' index\\n        add += nums[i]                                   # Add each element to the \\'add\\' variable \\n        leftSum = max(add, leftSum)                      # Update the value of \\'leftSum\\' by taking the max between \\'add\\' & \\'leftSum\\'\\n        i += 1                                           # Move \\'i\\' to the next index\\n        \\n    ans = max(leftMaxSubarray, rightMaxSubarray)         # Store the max of the max values of the left and right sub-arrays to \\'ans\\'\\n    return max(ans, leftSum+rightSum)                    # Return the max between \\'ans\\' and the sum of \\'leftSum\\' & \\'rightSum\\'\\n    \\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        return maxSumSubarray(nums, 0, len(nums))        # Return the value returned from the \\'maxSumSubarray\\' function\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794989,
                "title": "kadane-s-algorithm-o-n-js-solution",
                "content": "```\\n// Kadane\\'s Algorithm\\nvar maxSubArray = function(nums) {\\n\\tif (!nums.length) return 0;\\n    let subArrSum = nums[0], maxSum = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        subArrSum = Math.max(nums[i], subArrSum + nums[i])\\n        maxSum = Math.max(maxSum, subArrSum);\\n    }\\n    return maxSum;\\n    \\n    /*\\n    1. Initialise two variables, subArrSum and maxSum, both to the first element of input , because the first element is the only subarray sum and maximum sum we can have at this point.\\n    2. Loop over the array from second element and compare the element with the subarray sum + the element. So, we are basically deciding whether to include this element in our subarray sum we have had so far or start a new subarray sum from this element. We choose the greater one since we want to maximise our sum.\\n    3. For every iteration, we update our return variable to store the maximum subarry sum.\\n    4. Return the return varianle.\\n    \\n    Time Complexity: O(n)\\n    Space Complexity: O(1)\\n    */\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Kadane\\'s Algorithm\\nvar maxSubArray = function(nums) {\\n\\tif (!nums.length) return 0;\\n    let subArrSum = nums[0], maxSum = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        subArrSum = Math.max(nums[i], subArrSum + nums[i])\\n        maxSum = Math.max(maxSum, subArrSum);\\n    }\\n    return maxSum;\\n    \\n    /*\\n    1. Initialise two variables, subArrSum and maxSum, both to the first element of input , because the first element is the only subarray sum and maximum sum we can have at this point.\\n    2. Loop over the array from second element and compare the element with the subarray sum + the element. So, we are basically deciding whether to include this element in our subarray sum we have had so far or start a new subarray sum from this element. We choose the greater one since we want to maximise our sum.\\n    3. For every iteration, we update our return variable to store the maximum subarry sum.\\n    4. Return the return varianle.\\n    \\n    Time Complexity: O(n)\\n    Space Complexity: O(1)\\n    */\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 608209,
                "title": "4-approaches-o-n-3-o-n-2-o-nlogn-o-n-interview-java",
                "content": "**/*\\n*   There are almost 4 methods to do this problem with varying Time Complexity\\n* 1) Brute force by making 2 nested loops for picking all subarrays and third nested loop for calculating sum from i-->j    TC O(N^3)\\n* 2) Better Approch is to Maintain a prefix sum from index i->j and use only outer two loops for calculting sum   TC O(N^2)\\n* 3) Using Divide and Conquer based approach with Recurence similer to merge sort Algorithm  TC O(NlogN)\\n* 4) Using Some Sliding window based approach or better known as Kadanes Algorithm TC  O(N)\\n*\\n*/**\\n\\n```\\n // Approach 1   TC=O(N^3)       SC=O(1)\\n    public int maxSubArray(final int[] nums) {\\n              if(nums==null || nums.length==0)return 0;\\n              int max=Integer.MIN_VALUE;\\n              int sum=0;\\n              for(int i=0;i<nums.length;i++){\\n                   for(int j=i;j< nums.length;j++){\\n                       //Compute sum b/w i-->j\\n                       sum=0;\\n                       for(int k=i;k<=j;k++){\\n                           sum+=nums[k];\\n                       }\\n                       if(max<sum)\\n                           max=sum;\\n                   }\\n               }\\n              return max;\\n    }\\n```\\n\\n```\\n// Approach 2   TC=O(N^2)       SC=O(N)\\n    public int maxSubArray(final int[] nums) {\\n        if(nums==null || nums.length==0)return 0;// Invalid\\n        int max=Integer.MIN_VALUE;\\n        int[] prefix=new int[nums.length+1];\\n        // Generate the prefix sum\\n        for(int i=0;i<nums.length;i++){\\n            prefix[i+1]=prefix[i] + nums[i];\\n        }\\n\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j< nums.length;j++){\\n                sum=prefix[j+1] - prefix[i];\\n                if(max<sum)\\n                    max=sum;\\n            }\\n        }\\n          return max;\\n    }\\n```\\n\\n```\\n\\n        // Approach 3   TC=O(NlogN)       SC=O(N)           // Quite Similer to merge sort\\n        private int Conquer(final int[] arr,int low,int mid,int high){\\n\\n                    int left_contagious_sum=Integer.MIN_VALUE;\\n                    int right_contagious_sum=Integer.MIN_VALUE;\\n\\n                    // Moving to left side from mid included to low included\\n                    int temp_left_sum=0;\\n                    for(int i=mid;i>=low;i--){\\n                        temp_left_sum+=arr[i];\\n                        if(left_contagious_sum<temp_left_sum)\\n                            left_contagious_sum=temp_left_sum;\\n                    }\\n\\n                    // Moving to right side from mid excluded to high included\\n                    int temp_right_sum=0;\\n                    for(int i=mid+1;i<=high;i++){\\n                        temp_right_sum+=arr[i];\\n                        if(right_contagious_sum<temp_right_sum)\\n                            right_contagious_sum=temp_right_sum;\\n                    }\\n\\n                    return left_contagious_sum+right_contagious_sum;\\n        }\\n        private int Divide(final int[] arr,int low,int high){\\n                    if(low==high)return arr[low];      // Single element is itself the maximum sum in that subarray\\n\\n                    int mid=(low + (high-low)/2);\\n\\n                    int left_sum=  Divide(arr,low,mid);        // Divide the array with left part containing extra element in case of total odd elements\\n                    int right_sum= Divide(arr,mid+1,high);\\n                    // Conquer step or merge step\\n                    int merged_sum=Conquer(arr,low,mid,high);// This step would provide their maximum sum considering them contagious\\n                    return Math.max(left_sum,Math.max(right_sum,merged_sum));\\n        }\\n        public int maxSubArray(final int[] nums) {\\n            if (nums == null || nums.length == 0) return 0;// Invalid\\n            return Divide(nums,0,nums.length-1);\\n        }\\n\\n```\\n\\n```\\n // Approach 4    kadanes Algorithm        TC(O(N))   SC(O(1))   // Basically sliding window approach\\n                                                                        // The Main idea is that, we should restart counting the sum, as soon as sum becomes -ve\\n\\n\\n\\n    public int maxSubArray(final int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;// Invalid\\n        int maxsum=Integer.MIN_VALUE;\\n        int currsum=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            currsum+=nums[i];\\n            if(maxsum<currsum)\\n                maxsum=currsum;\\n\\n            if(currsum<0)\\n                currsum=0;//Rest for fresh start\\n\\n        }\\n        return maxsum;\\n    }\\n\\n\\n```\\n\\nIf you have made it till here ,\\n***Please up vote if you liked my code so that it can also help others ***\\nThanks a lot !",
                "solutionTags": [],
                "code": "```\\n // Approach 1   TC=O(N^3)       SC=O(1)\\n    public int maxSubArray(final int[] nums) {\\n              if(nums==null || nums.length==0)return 0;\\n              int max=Integer.MIN_VALUE;\\n              int sum=0;\\n              for(int i=0;i<nums.length;i++){\\n                   for(int j=i;j< nums.length;j++){\\n                       //Compute sum b/w i-->j\\n                       sum=0;\\n                       for(int k=i;k<=j;k++){\\n                           sum+=nums[k];\\n                       }\\n                       if(max<sum)\\n                           max=sum;\\n                   }\\n               }\\n              return max;\\n    }\\n```\n```\\n// Approach 2   TC=O(N^2)       SC=O(N)\\n    public int maxSubArray(final int[] nums) {\\n        if(nums==null || nums.length==0)return 0;// Invalid\\n        int max=Integer.MIN_VALUE;\\n        int[] prefix=new int[nums.length+1];\\n        // Generate the prefix sum\\n        for(int i=0;i<nums.length;i++){\\n            prefix[i+1]=prefix[i] + nums[i];\\n        }\\n\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j< nums.length;j++){\\n                sum=prefix[j+1] - prefix[i];\\n                if(max<sum)\\n                    max=sum;\\n            }\\n        }\\n          return max;\\n    }\\n```\n```\\n\\n        // Approach 3   TC=O(NlogN)       SC=O(N)           // Quite Similer to merge sort\\n        private int Conquer(final int[] arr,int low,int mid,int high){\\n\\n                    int left_contagious_sum=Integer.MIN_VALUE;\\n                    int right_contagious_sum=Integer.MIN_VALUE;\\n\\n                    // Moving to left side from mid included to low included\\n                    int temp_left_sum=0;\\n                    for(int i=mid;i>=low;i--){\\n                        temp_left_sum+=arr[i];\\n                        if(left_contagious_sum<temp_left_sum)\\n                            left_contagious_sum=temp_left_sum;\\n                    }\\n\\n                    // Moving to right side from mid excluded to high included\\n                    int temp_right_sum=0;\\n                    for(int i=mid+1;i<=high;i++){\\n                        temp_right_sum+=arr[i];\\n                        if(right_contagious_sum<temp_right_sum)\\n                            right_contagious_sum=temp_right_sum;\\n                    }\\n\\n                    return left_contagious_sum+right_contagious_sum;\\n        }\\n        private int Divide(final int[] arr,int low,int high){\\n                    if(low==high)return arr[low];      // Single element is itself the maximum sum in that subarray\\n\\n                    int mid=(low + (high-low)/2);\\n\\n                    int left_sum=  Divide(arr,low,mid);        // Divide the array with left part containing extra element in case of total odd elements\\n                    int right_sum= Divide(arr,mid+1,high);\\n                    // Conquer step or merge step\\n                    int merged_sum=Conquer(arr,low,mid,high);// This step would provide their maximum sum considering them contagious\\n                    return Math.max(left_sum,Math.max(right_sum,merged_sum));\\n        }\\n        public int maxSubArray(final int[] nums) {\\n            if (nums == null || nums.length == 0) return 0;// Invalid\\n            return Divide(nums,0,nums.length-1);\\n        }\\n\\n```\n```\\n // Approach 4    kadanes Algorithm        TC(O(N))   SC(O(1))   // Basically sliding window approach\\n                                                                        // The Main idea is that, we should restart counting the sum, as soon as sum becomes -ve\\n\\n\\n\\n    public int maxSubArray(final int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;// Invalid\\n        int maxsum=Integer.MIN_VALUE;\\n        int currsum=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            currsum+=nums[i];\\n            if(maxsum<currsum)\\n                maxsum=currsum;\\n\\n            if(currsum<0)\\n                currsum=0;//Rest for fresh start\\n\\n        }\\n        return maxsum;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578388,
                "title": "divide-and-conquer",
                "content": "Subarray can be either entirely in left sub array or right subarray or crossing between two.\\nclass Solution(object):\\n\\n    class Solution(object):\\n    def maxcrossingSubArray(self,nums,mid):\\n        max_l_sum = max_r_sum = float(\\'-inf\\')\\n        sum = 0\\n        for i in xrange(mid-1,-1,-1):\\n            sum += nums[i]\\n            max_l_sum = max( max_l_sum ,sum)\\n        sum = 0\\n       \\n        for i in xrange(mid,len(nums),1):\\n            sum += nums[i]\\n            max_r_sum = max( max_r_sum ,sum)\\n        return max_l_sum + max_r_sum\\n        \\n        \\n        \\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) ==  1 :\\n            return nums[0]\\n        elif not nums:\\n            return 0\\n        else :\\n            mid = len(nums)/2\\n            print(mid)\\n            l_sum = self.maxSubArray(nums[:mid])\\n            r_sum = self.maxSubArray(nums[mid:])\\n            c_sum = self.maxcrossingSubArray(nums,mid)\\n            print(l_sum,r_sum,c_sum)\\n            return max(l_sum,r_sum,c_sum)\\n            \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "Subarray can be either entirely in left sub array or right subarray or crossing between two.\\nclass Solution(object):\\n\\n    class Solution(object):\\n    def maxcrossingSubArray(self,nums,mid):\\n        max_l_sum = max_r_sum = float(\\'-inf\\')\\n        sum = 0\\n        for i in xrange(mid-1,-1,-1):\\n            sum += nums[i]\\n            max_l_sum = max( max_l_sum ,sum)\\n        sum = 0\\n       \\n        for i in xrange(mid,len(nums),1):\\n            sum += nums[i]\\n            max_r_sum = max( max_r_sum ,sum)\\n        return max_l_sum + max_r_sum\\n        \\n        \\n        \\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) ==  1 :\\n            return nums[0]\\n        elif not nums:\\n            return 0\\n        else :\\n            mid = len(nums)/2\\n            print(mid)\\n            l_sum = self.maxSubArray(nums[:mid])\\n            r_sum = self.maxSubArray(nums[mid:])\\n            c_sum = self.maxcrossingSubArray(nums,mid)\\n            print(l_sum,r_sum,c_sum)\\n            return max(l_sum,r_sum,c_sum)\\n            \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 561967,
                "title": "53-javascript-1-line-solution",
                "content": "> Runtime: **60 ms**, faster than *67.95%* of JavaScript online submissions\\n> Memory Usage: **38 MB**, less than *5.55%* of JavaScript online submissions\\n\\n```javascript\\nconst maxSubArray = nums =>\\n  nums.reduce(\\n    ([localMax, globalMax], curr) => [\\n      Math.max(curr, localMax + curr),\\n      Math.max(curr, localMax + curr, globalMax),\\n    ],\\n    [-Infinity, -Infinity],\\n  )[1];\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst maxSubArray = nums =>\\n  nums.reduce(\\n    ([localMax, globalMax], curr) => [\\n      Math.max(curr, localMax + curr),\\n      Math.max(curr, localMax + curr, globalMax),\\n    ],\\n    [-Infinity, -Infinity],\\n  )[1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553204,
                "title": "simple-easy-to-understand-o-n-solution-in-python",
                "content": "We use the fact that the max sum at any index will \\n1)either be the value at that index itself\\n2)or it would be the extension of the best subarray till the prev index added to the current idex\\'s value\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        maxcurr = nums[0]\\n        maxglobal = nums[0]\\n        for i in range(1,len(nums)):\\n            maxcurr = max(nums[i], maxcurr + nums[i]) \\n            maxglobal = max(maxcurr, maxglobal)\\n        return maxglobal\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        maxcurr = nums[0]\\n        maxglobal = nums[0]\\n        for i in range(1,len(nums)):\\n            maxcurr = max(nums[i], maxcurr + nums[i]) \\n            maxglobal = max(maxcurr, maxglobal)\\n        return maxglobal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540951,
                "title": "c-divide-and-conquer-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> arr;\\n\\n\\t\\tint cross(int left,int right,int mid){\\n\\t\\t\\t//if(left==right) return arr[left];\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tint ans1=INT_MIN;\\n\\t\\t\\tint ans2=INT_MIN;\\n\\t\\t\\tfor(int i=mid;i>=left;i--){\\n\\t\\t\\t\\tcur+=arr[i];\\n\\t\\t\\t\\tans1=max(ans1,cur);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcur=0;\\n\\t\\t\\tfor(int i=mid+1;i<=right;i++){\\n\\t\\t\\t\\tcur+=arr[i];\\n\\t\\t\\t\\tans2=max(ans2,cur);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans1+ans2;\\n\\n\\n\\t\\t}\\n\\n\\t\\tint helper(int left, int right){\\n\\t\\t\\tif(left>=right){\\n\\t\\t\\t\\treturn arr[left];\\n\\t\\t\\t}\\n\\t\\t\\tint mid=(left+right)/2;\\n\\n\\t\\t\\tint sumLeft=helper(left,mid);\\n\\t\\t\\tint sumRight=helper(mid+1,right);\\n\\t\\t\\tint sumCross=cross(left,right,mid);\\n\\n\\t\\t\\treturn max(sumCross,max(sumLeft,sumRight));\\n\\t\\t}\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tarr=nums;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\treturn helper(0,n-1);\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> arr;\\n\\n\\t\\tint cross(int left,int right,int mid){\\n\\t\\t\\t//if(left==right) return arr[left];\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tint ans1=INT_MIN;\\n\\t\\t\\tint ans2=INT_MIN;\\n\\t\\t\\tfor(int i=mid;i>=left;i--){\\n\\t\\t\\t\\tcur+=arr[i];\\n\\t\\t\\t\\tans1=max(ans1,cur);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 353745,
                "title": "convert-to-the-best-time-to-buy-and-sell-stock-problem",
                "content": "This problem can be converted to the \"Best Time to Buy and Sell Stock\" Problem. It would be easier to understand in this way.\\n\\nFirst, we can create an array in which the i-th element is the sum from nums[0] to nums[i]. To implement this in-place by Python, we have \\n```\\nlen_nums=len(nums)\\nfor i in range(1,len_nums):\\n\\tnums[i]+=nums[i-1]\\n```\\n\\nNow, nums[j]-nums[i] is the sum of contiguous subarray (from i+1 to j).  If we insert a 0 to head of nums, then finding Maximum Subarray becomes the \"Best Time to Buy and Sell Stock\" Problem. Any solution in the Sell Stock problem can be used here.  My Python solution is\\n```\\nmin_price=0\\nmax_profit=float(\\'-inf\\')\\nfor num in nums:\\n\\tprofit=num-min_price\\n\\tif profit>max_profit:\\n\\t\\tmax_profit=profit\\n\\tif num<min_price:\\n\\t\\tmin_price=num\\nreturn max_profit\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nlen_nums=len(nums)\\nfor i in range(1,len_nums):\\n\\tnums[i]+=nums[i-1]\\n```\n```\\nmin_price=0\\nmax_profit=float(\\'-inf\\')\\nfor num in nums:\\n\\tprofit=num-min_price\\n\\tif profit>max_profit:\\n\\t\\tmax_profit=profit\\n\\tif num<min_price:\\n\\t\\tmin_price=num\\nreturn max_profit\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165323,
                "title": "scala-1-line-dp",
                "content": "```nums.tail.scan(nums.head){(s,e) => math.max(s+e, e)}.max```",
                "solutionTags": [],
                "code": "```nums.tail.scan(nums.head){(s,e) => math.max(s+e, e)}.max```",
                "codeTag": "Unknown"
            },
            {
                "id": 20428,
                "title": "o-n-time-o-1-space-dynamic-programming-8-line-java-solution-with-comment",
                "content": "Define: sum[i] as the maximum subarray sum of [0...i], and this subarray MUST END WITH nums[i].\\n\\n(Some thought -- when facing \"consecutive sequence problems\" such as subarray or substring, the subproblems usually MUST END WITH current element, so that when NEXT element comes, the sequence will still remain consecutive).\\n\\n    /*Then, from i --> i+1:\\n    -- if sum[i] >= 0, it gives non-negative contribution, sum[i+1] = sum[i] + a[i+1]\\n    -- if sum[i] < 0, it gives negative contribution, sum[i+1] = a[i+1]*/\\n \\n    public class Solution {\\n        public int maxSubArray(int[] nums) {\\n            if (nums==null || nums.length==0) { return 0; }\\n            int max = nums[0], sum = nums[0];\\n            for (int i=1; i<nums.length; ++i) {\\n                if (sum >= 0) { sum += nums[i]; }\\n                else { sum = nums[i]; }\\n                max = Math.max(max, sum);\\n            }\\n            return max;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int maxSubArray(int[] nums) {\\n            if (nums==null || nums.length==0) { return 0; }",
                "codeTag": "Java"
            },
            {
                "id": 2803078,
                "title": "beats-81-51-tc-using-simple-python-solution-for-maximum-subarray",
                "content": "![image.png](https://assets.leetcode.com/users/images/3add05d1-a7ac-45d8-a4b7-871005f88074_1668161027.768722.png)\\n\\n# Intuition\\nIgnore elements which results in negative value by sum, and compare the values to get max subarray value\\n\\n# Approach\\n1. Declare first element as max_val, and temp as 0\\n2. Loop through the nums list\\n    1. if temp is less than 0, assign temp as 0\\n    2. add current element to temp\\n    3. get max by comparing max_val and temp.\\n3. return max_val \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_val = nums[0]\\n        temp = 0\\n\\n        for i in nums:\\n            if temp < 0:\\n                temp = 0            \\n            temp += i\\n            max_val = max(max_val, temp)\\n        \\n        return max_val\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_val = nums[0]\\n        temp = 0\\n\\n        for i in nums:\\n            if temp < 0:\\n                temp = 0            \\n            temp += i\\n            max_val = max(max_val, temp)\\n        \\n        return max_val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603051,
                "title": "easy-logic-linear-o-n-kadane-python-solution",
                "content": "**Leave an upvote if you like the solution :)**\\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        ans = -inf\\n        currSum = 0\\n        \\n        for num in nums:\\n            currSum += num\\n            ans = max(ans, currSum)\\n            \\n\\t\\t\\t# if currSum < 0 then why to accumulate it further just ignore it and make it 0\\n            if currSum < 0:\\n                currSum = 0\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        ans = -inf\\n        currSum = 0\\n        \\n        for num in nums:\\n            currSum += num\\n            ans = max(ans, currSum)\\n            \\n\\t\\t\\t# if currSum < 0 then why to accumulate it further just ignore it and make it 0\\n            if currSum < 0:\\n                currSum = 0\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113078,
                "title": "effective-solution-time-complexity-o-n",
                "content": "```class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int c = 0,  ans = INT_MIN;\\n        for(int i = 0; i < nums.size(); i++){\\n            c = max(nums[i], c + nums[i]);\\n            ans = max(ans, c);\\n        }\\n        return ans;  \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int c = 0,  ans = INT_MIN;\\n        for(int i = 0; i < nums.size(); i++){\\n            c = max(nums[i], c + nums[i]);\\n            ans = max(ans, c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2062511,
                "title": "python-o-n-time-o-1-space",
                "content": "## method 3\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        \\n        recent_sum = 0\\n        for num in nums:\\n            recent_sum += num\\n                \\n            if recent_sum > max_sum:\\n                max_sum = recent_sum\\n            \\n            if recent_sum < 0:\\n                recent_sum = 0\\n        \\n        return max_sum\\n```\\nLet `n` be the length of `nums`\\nTime: O(n)\\nSpace: O(1)\\n\\n## method 2: faster brute force (time limit exceeded)\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        accumulations = [0] * n\\n        accumulations[0] = nums[0]\\n        for i in range(1, n):\\n            accumulations[i] = accumulations[i - 1] + nums[i]\\n        \\n        max_sum = max(accumulations)\\n        \\n        for i in range(n):\\n            for j in range(i+1, n):\\n                max_sum = max(max_sum, accumulations[j] - accumulations[i])\\n        \\n        return max_sum\\n```\\nLet `n` be the length of `nums`\\nTime: O(n^2) \\nSpace: O(n)\\n\\n## method 1: brute force (time limit exceeded)\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        max_sum = nums[0]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                max_sum = max(max_sum, sum(nums[i : j+1]))\\n        \\n        return max_sum\\n```\\nLet `n` be the length of `nums`\\nTime: O(n^3)\\nSpace: O(n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        \\n        recent_sum = 0\\n        for num in nums:\\n            recent_sum += num\\n                \\n            if recent_sum > max_sum:\\n                max_sum = recent_sum\\n            \\n            if recent_sum < 0:\\n                recent_sum = 0\\n        \\n        return max_sum\\n```\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        accumulations = [0] * n\\n        accumulations[0] = nums[0]\\n        for i in range(1, n):\\n            accumulations[i] = accumulations[i - 1] + nums[i]\\n        \\n        max_sum = max(accumulations)\\n        \\n        for i in range(n):\\n            for j in range(i+1, n):\\n                max_sum = max(max_sum, accumulations[j] - accumulations[i])\\n        \\n        return max_sum\\n```\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        max_sum = nums[0]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                max_sum = max(max_sum, sum(nums[i : j+1]))\\n        \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753529,
                "title": "faster-than-100-very-easy-java-solution",
                "content": "```\\n#**Please upvote if you like the Solution\\nclass Solution {\\n    public int maxSubArray(int[] nums) \\n    {\\n        int sum=0;\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum=sum+nums[i];\\n             maxi=Math.max(sum,maxi);\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }\\n           \\n        }\\n        return maxi;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxSubArray(int[] nums) \\n    {\\n        int sum=0;\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum=sum+nums[i];\\n             maxi=Math.max(sum,maxi);\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1667107,
                "title": "js-97-faster-than-other-solutions",
                "content": "```\\nvar maxSubArray = function(nums) {\\n    if (!nums || !nums.length) {\\n        return 0;\\n    }\\n    let max = nums[0];\\n    for (let i = 1; i < nums.length; i++) {\\n        nums[i] = Math.max(nums[i], nums[i] + nums[i-1]);\\n        if (nums[i] > max) {\\n            max = nums[i];\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n    if (!nums || !nums.length) {\\n        return 0;\\n    }\\n    let max = nums[0];\\n    for (let i = 1; i < nums.length; i++) {\\n        nums[i] = Math.max(nums[i], nums[i] + nums[i-1]);\\n        if (nums[i] > max) {\\n            max = nums[i];\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1489447,
                "title": "no-magic-only-2-simple-steps",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        \\n        // Store 1st element in for maxSum and currSum\\n        int currSum = nums[0];\\n        int maxSum = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            // If ongoing subarray sum is less than 0, discard it and start taking sum for new sub array\\n            if(currSum<0){\\n                currSum =0;\\n            }\\n            \\n            // add current element from nums arr to our ongoing subarray sum\\n            currSum += nums[i];\\n            \\n            // check if current sum of going subarray is greater than max sum till now, \\n\\t\\t\\t// then set max sum to current sum\\n            if(currSum > maxSum){\\n                maxSum = currSum;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        \\n        // Store 1st element in for maxSum and currSum\\n        int currSum = nums[0];\\n        int maxSum = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            // If ongoing subarray sum is less than 0, discard it and start taking sum for new sub array\\n            if(currSum<0){\\n                currSum =0;\\n            }\\n            \\n            // add current element from nums arr to our ongoing subarray sum\\n            currSum += nums[i];\\n            \\n            // check if current sum of going subarray is greater than max sum till now, \\n\\t\\t\\t// then set max sum to current sum\\n            if(currSum > maxSum){\\n                maxSum = currSum;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564960,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1568734,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1565011,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566595,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1567101,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566592,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1568228,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566067,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1565942,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1569914,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1564960,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1568734,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1565011,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566595,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1567101,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566592,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1568228,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566067,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1565942,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1569914,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means youre not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1564999,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1569319,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1809640,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1568251,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1774345,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1570888,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1570803,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1574280,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1685368,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1570942,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1570884,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1570681,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1568451,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569760,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1965096,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1807084,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569968,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569720,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569454,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569199,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1571128,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1565023,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 2034118,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1848008,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1842361,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1811188,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1795783,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1757905,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1575794,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1574347,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1573793,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1573569,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1573333,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1572710,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1572229,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1571129,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1568877,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1568876,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1568643,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1569527,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1570097,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 1574740,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2075112,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2067517,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2064540,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2063545,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2059278,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2057715,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2048087,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2039301,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2022927,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 2019956,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 2014770,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 2005635,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1995170,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1990559,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1990207,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1980794,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1974176,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1968762,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1961672,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1951753,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1940352,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1935176,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1932884,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1921831,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1906078,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1897977,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1897004,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1896232,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1895160,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1892215,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1891155,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1889374,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1880559,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1874197,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1873146,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1872667,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1867481,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1859957,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1854476,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1848680,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1848532,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1840595,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1839347,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1805449,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1800502,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1798382,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1797071,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1790818,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1787843,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1786013,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1784392,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1783745,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1782108,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1777596,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1776296,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1774898,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1769442,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1767288,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1764472,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1762823,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1762711,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1761056,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1758381,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1756024,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1752678,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1752639,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1752561,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1751686,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1743946,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1740886,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1739945,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1738123,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1735697,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1732940,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1732126,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1731229,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1729317,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1726426,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1726360,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1726268,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724067,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1723734,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1722832,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1716318,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1710408,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1709681,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1704485,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1695088,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1689647,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1688787,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1687649,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1687028,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1677997,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1675185,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1674645,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1672938,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1671186,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1668150,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            }
        ]
    }
]