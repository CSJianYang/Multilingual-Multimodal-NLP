[
    {
        "title": "Number of Ways to Build Sturdy Brick Wall",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568750,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1708150,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1955096,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1930709,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1825547,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Counting Words With a Given Prefix",
        "question_content": "<p>You are given an array of strings <code>words</code> and a string <code>pref</code>.</p>\n\n<p>Return <em>the number of strings in </em><code>words</code><em> that contain </em><code>pref</code><em> as a <strong>prefix</strong></em>.</p>\n\n<p>A <strong>prefix</strong> of a string <code>s</code> is any leading contiguous substring of <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;pay&quot;,&quot;<strong><u>at</u></strong>tention&quot;,&quot;practice&quot;,&quot;<u><strong>at</strong></u>tend&quot;], <code>pref </code>= &quot;at&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The 2 strings that contain &quot;at&quot; as a prefix are: &quot;<u><strong>at</strong></u>tention&quot; and &quot;<u><strong>at</strong></u>tend&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;leetcode&quot;,&quot;win&quot;,&quot;loops&quot;,&quot;success&quot;], <code>pref </code>= &quot;code&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no strings that contain &quot;code&quot; as a prefix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> and <code>pref</code> consist of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1802497,
                "title": "c-easiest-solution-substring",
                "content": "```\\n// The easiest solution to this problem is:\\n// Step 1: Calculate length of \"pref\"\\n// Step 2: find substring of \"words\" from 0 to length of \"pref\"\\n// if both match increment count by 1;\\n\\n\\n\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count\\n        \\n    }\\n};\\n```\\nPlease Upvote, if you liked my solution.\\nDont forget to visit my repo: https://github.com/tarunsahnan/LeetCode-Solutions",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// The easiest solution to this problem is:\\n// Step 1: Calculate length of \"pref\"\\n// Step 2: find substring of \"words\" from 0 to length of \"pref\"\\n// if both match increment count by 1;\\n\\n\\n\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802490,
                "title": "java-python-3-1-liners-and-a-follow-up",
                "content": "\\n\\n```java\\n    public int prefixCount(String[] words, String pref) {\\n        return (int)Stream.of(words).filter(w -> w.startsWith(pref)).count();\\n    }\\n```\\n```python\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(w.startswith(pref) for w in words)\\n```\\n\\n----\\n\\n**Follow-up:**\\n\\n*Q*: A followup question from Google: what if the words are sorted lexicographically? -- credit to **@blackspinner**\\n*A*: We can use binary search twice to locate the lower and upper bounds of the words that have the same prefix. Therefore, the time cost is O(klogn). e.g., \\nAssume `perf = \"abcd\"`, we can search `\"abcd\"` and `\"abce\"` respectively.\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int prefixCount(String[] words, String pref) {\\n        return (int)Stream.of(words).filter(w -> w.startsWith(pref)).count();\\n    }\\n```\n```python\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(w.startswith(pref) for w in words)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1803108,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int c = 0;\\n    for(String s : words) {\\n        if(s.indexOf(pref)==0) \\n            c++;\\n    }\\n    return c; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int c = 0;\\n    for(String s : words) {\\n        if(s.indexOf(pref)==0) \\n            c++;\\n    }\\n    return c; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802494,
                "title": "python3-java-c-find-indexof",
                "content": "\\n<iframe src=\"https://leetcode.com/playground/8dV5wFQP/shared\" frameBorder=\"0\" width=\"480\" height=\"160\"></iframe>\\n",
                "solutionTags": [],
                "code": "\\n<iframe src=\"https://leetcode.com/playground/8dV5wFQP/shared\" frameBorder=\"0\" width=\"480\" height=\"160\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802788,
                "title": "one-liner-count-if",
                "content": "**C++**\\n```cpp\\nint prefixCount(vector<string>& ws, string pref) {\\n    return count_if(begin(ws), end(ws), [&](const string &w){\\n       return w.compare(0, pref.size(), pref) == 0; \\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint prefixCount(vector<string>& ws, string pref) {\\n    return count_if(begin(ws), end(ws), [&](const string &w){\\n       return w.compare(0, pref.size(), pref) == 0; \\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809593,
                "title": "python-one-line-simple-solution",
                "content": "**Python**\\n\\n```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n\\treturn sum([word.startswith(pref) for word in words])\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n\\treturn sum([word.startswith(pref) for word in words])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802715,
                "title": "trie-vs-brute-force-vs-find",
                "content": "**Trie Method**:\\n\\n1. First put all the words in the trie and keep on incrementing counting of prefix after every letter.\\n2. Now traverse prefix and get the count , number of word this prefix has occured.\\n\\n**It is a Standard Trie Implementation ALgorithm**\\n**C++**\\n  \\n    struct Node{\\n      Node* links[26];\\n      int prefix=0;\\n        \\n      bool contains(char c){\\n         return links[c-\\'a\\']!=0;\\n      }    \\n    \\n      void create(char c,Node* node){\\n          links[c-\\'a\\']=node;\\n      }\\n    \\n      void increment(){\\n          prefix++;\\n      }\\n    \\n      int count(){\\n          return prefix;\\n      }\\n    \\n      Node* next(char c){\\n          return links[c-\\'a\\'];\\n      }\\n    };\\n\\t\\n\\t//Trie Class\\n    class Trie{\\n      Node* root; \\n      public:\\n   \\n      Trie(){\\n          root=new Node();\\n      }\\n\\t  \\n      //insert words\\n      void insert(string word){\\n          Node* ptr=root;\\n          for(auto i:word){\\n             if(!ptr->contains(i))  ptr->create(i,new Node());\\n             ptr=ptr->next(i);\\n             ptr->increment();\\n          }\\n      }\\n\\t  \\n      //return count of given prefix\\n      int cnt_pref(string word){\\n          Node* ptr=root;\\n          for(auto i:word){\\n              if(!ptr->contains(i)) return 0;\\n              ptr=ptr->next(i);\\n          }\\n          return ptr->count();\\n      }\\n    };\\n\\t\\n\\t//input class\\n\\tclass Solution {\\n    public:\\n    int prefixCount(vector<string>& words, string pref) {\\n        Trie trie;\\n        for(auto i:words) trie.insert(i);  //no. of words*average length of strings\\n        int cnt= trie.cnt_pref(pref);  //length of prefix\\n        return cnt;\\n    }\\n    };\\n**Time** - O(number of words * average length of words + prefix_length)\\n**Space** - O(Average length * 26)\\n\\n# Find() Algorithm Method:\\n   \\n   \\n    int prefixCount(vector<string>& words, string &pref) {\\n        int cnt=0;\\n        for(auto i:words){\\n            auto q= i.find(pref);\\n            if(q!=string::npos and q==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n**Time** - O(N * M)\\n**Space** - O(1)\\n\\t\\n# Brute Force\\t\\n\\n     bool check(string &x,string &y,int i){\\n\\t        if(i==y.size()) return true;\\n            return x[i]==y[i]? check(x,y,i+1) : false;\\n\\t }\\n\\t \\n     int prefixCount(vector<string>& words, string &pref){\\n        int cnt=0;\\n        for(auto i:words){\\n            if(i.size()<pref.size()) continue;\\n            cnt+= check(i,pref,0)? 1 : 0 ;\\n        }\\n        return cnt;\\n    }\\n**Time** - O(N * min(pref.size(),average length of strings)\\n**Space** - O(1)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int prefixCount(vector<string>& words, string pref) {\\n        Trie trie;\\n        for(auto i:words) trie.insert(i);  //no. of words*average length of strings\\n        int cnt= trie.cnt_pref(pref);  //length of prefix\\n        return cnt;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1802447,
                "title": "c-with-explanation-easy",
                "content": "**Explanation-**\\nCheck if word contains pref, and if it contains then it should be at ```0th``` position\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto & word:words)\\n            if(word.find(pref)==0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```0th```\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto & word:words)\\n            if(word.find(pref)==0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581816,
                "title": "python-easy-and-straight-forward-approach",
                "content": "\\tclass Solution:\\n\\t\\tdef prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\t\\tn = len(pref)\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor w in words:\\n\\t\\t\\t\\tif w[:n] == pref:\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\t\\tn = len(pref)\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor w in words:\\n\\t\\t\\t\\tif w[:n] == pref:\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 1814309,
                "title": "javascript-easy-to-understand-1-line",
                "content": "The core strategy for this problem is straightforward:\\n- traverse the list\\n- check each word is with a given prefix\\n\\nI guess there won\\'t be any problem with how to do the traversal. So, the only problem is how to check the prefix?\\n\\nWe could use `RegExp`, `indexOf`, `startsWith`, or even `slice` the first part.\\nJust choose anyone you like, here are 2 samples from me:\\n\\n## Sample 1\\n\\n```js\\nconst prefixCount = (words, pref) => {\\n  let count = 0;\\n  for (const word of words) {\\n    word.startsWith(pref) && ++count;\\n  }\\n  return count;\\n}\\n```\\n\\n## Sample 2\\n\\n```js\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst prefixCount = (words, pref) => {\\n  let count = 0;\\n  for (const word of words) {\\n    word.startsWith(pref) && ++count;\\n  }\\n  return count;\\n}\\n```\n```js\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802677,
                "title": "javascript-1-line-solution",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(word => word.slice(0, pref.length) === pref).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(word => word.slice(0, pref.length) === pref).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555249,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848590,
                "title": "c-solution-using-substr",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto x:words){\\n            if(x.substr(0,pref.size()) == pref)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto x:words){\\n            if(x.substr(0,pref.size()) == pref)\\n            {\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1802520,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\n    bool check(string &s , string &p){\\n          if(s.length() < p.length())\\n              return false;\\n          int i = 0;\\n        for(i = 0 ; i < p.length() ; i++){\\n           if(p[i] != s[i])\\n               return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt = 0;\\n        int n = words.size();\\n        for(int i = 0 ; i < n ; i++){\\n           if(check(words[i] , pref))\\n               cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool check(string &s , string &p){\\n          if(s.length() < p.length())\\n              return false;\\n          int i = 0;\\n        for(i = 0 ; i < p.length() ; i++){\\n           if(p[i] != s[i])\\n               return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt = 0;\\n        int n = words.size();\\n        for(int i = 0 ; i < n ; i++){\\n           if(check(words[i] , pref))\\n               cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682359,
                "title": "simplest-python-solution-use-startswith",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        cnt = 0\\n        for s in words:\\n            if s.startswith(pref):\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        cnt = 0\\n        for s in words:\\n            if s.startswith(pref):\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534682,
                "title": "simple-easy-java-solution-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160664,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n\\n    int prefix_size = pref.size();\\n    int n=words.size();\\n    int count = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        string s1 = words[i].substr(0, prefix_size);\\n        if (s1 == pref)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n\\n    int prefix_size = pref.size();\\n    int n=words.size();\\n    int count = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        string s1 = words[i].substr(0, prefix_size);\\n        if (s1 == pref)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854383,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word: words) {\\n            if (word.indexOf(pref) == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word: words) {\\n            if (word.indexOf(pref) == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726749,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n        for(int i = 0; i<words.length; i++){\\n        if(words[i].startsWith(pref)){\\n            count++;\\n        }\\n    }\\n    return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n        for(int i = 0; i<words.length; i++){\\n        if(words[i].startsWith(pref)){\\n            count++;\\n        }\\n    }\\n    return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034337,
                "title": "java-beginner-friendly-fast-solution",
                "content": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0 ;\\n      for(int i = 0 ;i<words.length ;i++){\\n        int l = pref.length();\\n       if(l<=words[i].length()){\\n          String sub = words[i].substring(0,l);\\n        if(pref.equals(sub))\\n          count++;\\n       }\\n      }\\n      return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0 ;\\n      for(int i = 0 ;i<words.length ;i++){\\n        int l = pref.length();\\n       if(l<=words[i].length()){\\n          String sub = words[i].substring(0,l);\\n        if(pref.equals(sub))\\n          count++;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1823579,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n*m)**\\n**Java**\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words){\\n            if(word.indexOf(pref) == 0) count++;   \\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words){\\n        if(word.indexOf(pref) == 0) count++;\\n    }\\n    return count;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        count = 0\\n        for word in words:\\n            if pref in word and word.index(pref) == 0:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words){\\n            if(word.indexOf(pref) == 0) count++;   \\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words){\\n        if(word.indexOf(pref) == 0) count++;\\n    }\\n    return count;\\n};\\n```\n```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        count = 0\\n        for word in words:\\n            if pref in word and word.index(pref) == 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803163,
                "title": "python-1-liner-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.find(pref) == 0 for word in words)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.find(pref) == 0 for word in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802965,
                "title": "simple-short-c",
                "content": "**Counting Words With a Given Prefix**\\nTravel each word in words and check if it\\'s size is greater or equal to size if prefix and compare the substring of length n(size of prefix) with prefix, if equal increase count.\\n\\n```\\nint prefixCount(vector<string>& words, string p) {\\n        int n=p.size();\\n        int ans=0;\\n        for(auto w:words)\\n        {\\n            if(w.size()>=n and w.substr(0,n)==p)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint prefixCount(vector<string>& words, string p) {\\n        int n=p.size();\\n        int ans=0;\\n        for(auto w:words)\\n        {\\n            if(w.size()>=n and w.substr(0,n)==p)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802930,
                "title": "easy-c-solution-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(auto it : words){\\n            bool flag = true;\\n            for(int i=0;i<pref.size();i++){\\n                if(pref[i] != it[i]) {flag = false; break;}\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(auto it : words){\\n            bool flag = true;\\n            for(int i=0;i<pref.size();i++){\\n                if(pref[i] != it[i]) {flag = false; break;}\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802627,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        int n=pref.size();\\n        for(auto s:words)\\n        {\\n            if(s.size()>=pref.size())\\n            {\\n                if(s.substr(0,n)==pref)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        int n=pref.size();\\n        for(auto s:words)\\n        {\\n            if(s.size()>=pref.size())\\n            {\\n                if(s.substr(0,n)==pref)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802436,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans  = 0;\\n            for(int i = 0; i < words.size(); i++){\\n                    int j = 0;\\n                    int n = words[i].length();\\n                    if(n<pref.length())continue;\\n                    {\\n        while(j<pref.length()){\\n        if(pref[j] == words[i][j])\\n               j++;\\n                    }\\n                      else \\n                          break;            \\n                    }\\n                    if(j==pref.length())ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans  = 0;\\n            for(int i = 0; i < words.size(); i++){\\n                    int j = 0;\\n                    int n = words[i].length();\\n                    if(n<pref.length())continue;\\n                    {\\n        while(j<pref.length()){\\n        if(pref[j] == words[i][j])\\n               j++;\\n                    }\\n                      else \\n                          break;            \\n                    }\\n                    if(j==pref.length())ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968993,
                "title": "check-if-a-word-occurs-o-n-javascript-memory-95-45-meaningful-vars",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    for (let index = 0; index < words.length; index++) {\\n        words[index] = words[index].substring(0, pref.length);\\n    }\\n    let count = 0;\\n    for (const iterator of words) {\\n        if (iterator === pref) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/15db9f0b-0bd0-4e79-90ae-f5166da971ac_1693163848.8008177.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    for (let index = 0; index < words.length; index++) {\\n        words[index] = words[index].substring(0, pref.length);\\n    }\\n    let count = 0;\\n    for (const iterator of words) {\\n        if (iterator === pref) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853168,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(s.length)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] s, String t) {\\n        int n=s.length;\\n        int count=0;\\n        int m=t.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i].startsWith(t))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] s, String t) {\\n        int n=s.length;\\n        int count=0;\\n        int m=t.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i].startsWith(t))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579916,
                "title": "one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(1 for i in words if i.startswith(pref))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(1 for i in words if i.startswith(pref))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575096,
                "title": "java-easy-solution-100-beats",
                "content": "# Approach\\n\\n1. Initialize a variable `count` to 0. This variable will keep track of the number of strings in the `words` array that contain `pref` as a prefix.\\n\\n2. Iterate through each string `word` in the `words` array using a for-each loop.\\n\\n3. For each `word`, check if it starts with the `pref` string using the `startsWith()` method. This method returns `true` if the `word` starts with the `pref` string, and `false` otherwise.\\n\\n4. If the `startsWith()` method returns `true`, increment the `count` variable by 1.\\n\\n5. After iterating through all the strings in the `words` array, the `count` variable will contain the total number of strings that have `pref` as a prefix.\\n\\n6. Return the value of the `count` variable.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words)\\n            if(word.startsWith(pref)) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words)\\n            if(word.startsWith(pref)) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533558,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String x : words) {\\n            if(x.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String x : words) {\\n            if(x.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443720,
                "title": "substr-solution-easy-c",
                "content": "`Please Upvote If you Like !!!!`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = pref.size();\\n        int ans  = 0;\\n        for(auto & w : words) {\\n            if(w.substr(0,n) == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = pref.size();\\n        int ans  = 0;\\n        for(auto & w : words) {\\n            if(w.substr(0,n) == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338829,
                "title": "simple-approach-explained-for-beginners",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all understand the question take your time ; \\nAfter this Google it what you want;\\nDo not use chatGPT it will directly jumps to the solution with example.\\nFor example I don\\'t know about startsWith() func;\\nJust type on google \"i want to check a string contains at prefix or not\";\\nThe only you need in programming is to apply basic if, else and for loop and that is more than enough to enter in the world of DSA\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            boolean ans = words[i].startsWith(pref);\\n            if (ans) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            boolean ans = words[i].startsWith(pref);\\n            if (ans) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254512,
                "title": "counting-words-with-a-given-prefix-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int i, j, count=0, flag=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<pref.length() ; j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int i, j, count=0, flag=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<pref.length() ; j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247423,
                "title": "counting-words-with-a-given-prefix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![countingwords.PNG](https://assets.leetcode.com/users/images/8d68c99b-176b-4804-a2bf-630bc38328e6_1677757448.8018465.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if pref in i and i.index(pref)==0:\\n                print(i)\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if pref in i and i.index(pref)==0:\\n                print(i)\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864108,
                "title": "c-short-4-line-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(wd.find(pref) < 1) // check if first occurrence of sub-string in the specified string\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(wd.find(pref) < 1) // check if first occurrence of sub-string in the specified string\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2705558,
                "title": "cpp-simple-solution-95-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& arr, string pref) \\n    {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string word = arr[i];\\n            bool flag=true;\\n            \\n            int temp1=0;\\n            int temp2=0;\\n\\n            while(temp1<pref.length() and temp2<word.length())\\n            {\\n               if(pref[temp1]!=word[temp2])\\n               {\\n                  flag=false;\\n                  break;\\n               }\\n               temp1++;\\n               temp2++;\\n            }\\n            if(temp1>=pref.length() and flag==true)\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& arr, string pref) \\n    {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string word = arr[i];\\n            bool flag=true;\\n            \\n            int temp1=0;\\n            int temp2=0;\\n\\n            while(temp1<pref.length() and temp2<word.length())\\n            {\\n               if(pref[temp1]!=word[temp2])\\n               {\\n                  flag=false;\\n                  break;\\n               }\\n               temp1++;\\n               temp2++;\\n            }\\n            if(temp1>=pref.length() and flag==true)\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695836,
                "title": "python-simple-solution-in-5-lines-faster-than-93-39",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c,l=0,len(pref)\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c,l=0,len(pref)\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694136,
                "title": "java-1ms-fast-solution",
                "content": "```\\n\\t\\tint count=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)){\\n                count++;\\n            }\\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint count=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)){\\n                count++;\\n            }\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594345,
                "title": "java-trie",
                "content": "```\\nclass Solution {\\n    TrieNode root = new TrieNode();\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        insertPrefix(pref);\\n        \\n        for (String word : words) {\\n            if (hasPrefix(word)) res++;\\n        }\\n        return res;\\n    }\\n    \\n    private void insertPrefix(String pref) {\\n        TrieNode node = root;\\n        for (char c : pref.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isEnd = true;\\n    }\\n    \\n    private boolean hasPrefix(String word) {\\n        boolean res = false;\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                break;\\n            }\\n            if (node.children[c - \\'a\\'].isEnd) { // easy to mistake as node.isEnd\\n                res = true;\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        return res;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isEnd;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TrieNode root = new TrieNode();\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        insertPrefix(pref);\\n        \\n        for (String word : words) {\\n            if (hasPrefix(word)) res++;\\n        }\\n        return res;\\n    }\\n    \\n    private void insertPrefix(String pref) {\\n        TrieNode node = root;\\n        for (char c : pref.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isEnd = true;\\n    }\\n    \\n    private boolean hasPrefix(String word) {\\n        boolean res = false;\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                break;\\n            }\\n            if (node.children[c - \\'a\\'].isEnd) { // easy to mistake as node.isEnd\\n                res = true;\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        return res;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isEnd;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572272,
                "title": "4-lines-java-easy-code",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String s :words){\\n            if(s.length()>=pref.length() && s.substring(0,pref.length()).equals(pref))count++;\\n        }\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String s :words){\\n            if(s.length()>=pref.length() && s.substring(0,pref.length()).equals(pref))count++;\\n        }\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189043,
                "title": "java-stream-for-loop-solution",
                "content": "# For LOOP && STRING.STARTSWITH || STREAM FILTER && COUNT #\\n`Unfortunately, both functions are not as fast as you think \\uD83D\\uDE29`\\n\\n``Faster function than the latter \\uD83E\\uDD13``\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word : words) {\\n            if (word.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n``Eazy function \\uD83D\\uDE0E ``\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n\\t\\treturn (int) Arrays.stream(words).filter(item -> item.startsWith(pref)).count();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word : words) {\\n            if (word.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n\\t\\treturn (int) Arrays.stream(words).filter(item -> item.startsWith(pref)).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175494,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048962,
                "title": "easy-python-solution-for-beginners",
                "content": "```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n        l=len(pref)\\n        c=0\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n        l=len(pref)\\n        c=0\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1903737,
                "title": "easy-solution-o-n-complexity-one-liner-without-using-startswith-inbuilt-function",
                "content": "Aint no brainer to use startswith function and compare the prefix of string. \\nI came up with the easiest solution that can be easiily understood by anyone , be it a beginner or a pro!\\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\treturn sum([1 for i in words if i[:len(pref)]==pref])\\n```\\n\\n**If this helped PLEASE UPVOTE!**\\nThanks for stopping by!\\nHave a good day:)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\treturn sum([1 for i in words if i[:len(pref)]==pref])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862998,
                "title": "java-one-liner",
                "content": "```\\npublic int prefixCount(String[] words, String pref) {\\n        return (int) Arrays.stream(words).filter(w -> w.startsWith(pref)).count();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int prefixCount(String[] words, String pref) {\\n        return (int) Arrays.stream(words).filter(w -> w.startsWith(pref)).count();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1819619,
                "title": "kotlin-1-line",
                "content": "```\\nfun prefixCount(a: Array<String>, p: String) = a.count { it.startsWith(p) }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun prefixCount(a: Array<String>, p: String) = a.count { it.startsWith(p) }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1807311,
                "title": "c-1-liner-linq",
                "content": "```cs\\npublic int PrefixCount(string[] words, string pref) =>\\n    words.Count(w => w.StartsWith(pref));\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [],
                "code": "```cs\\npublic int PrefixCount(string[] words, string pref) =>\\n    words.Count(w => w.StartsWith(pref));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1806042,
                "title": "java-indexof-100",
                "content": "if you like this solution pls upvote :)\\n\\nJAVA\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for(String word: words) \\n            res += (word.indexOf(pref) == 0) ? 1 : 0;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for(String word: words) \\n            res += (word.indexOf(pref) == 0) ? 1 : 0;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804613,
                "title": "c-simple-solution-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(auto word:words){\\n            int i=0;\\n            int j=0;\\n            while(i<word.size() && j<pref.size()){\\n                if(i!=pref.size()-1 && word[i]==pref[j]){\\n                    i++;\\n                    j++;\\n                }\\n                else if(word[i]==pref[i] && i==pref.size()-1){\\n                    i++;\\n                    j++;\\n                    cnt++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(auto word:words){\\n            int i=0;\\n            int j=0;\\n            while(i<word.size() && j<pref.size()){\\n                if(i!=pref.size()-1 && word[i]==pref[j]){\\n                    i++;\\n                    j++;\\n                }\\n                else if(word[i]==pref[i] && i==pref.size()-1){\\n                    i++;\\n                    j++;\\n                    cnt++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804393,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words.iter().filter(|word| word.starts_with(pref.as_str())).count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words.iter().filter(|word| word.starts_with(pref.as_str())).count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803276,
                "title": "leetcode-2185-counting-words-with-a-given-prefix-100-faster",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n      int c=0;\\n      int n=pref.length();\\n      for(int i=0; i<words.length; i++)\\n      {\\n          if(words[i].length()>=n && words[i].substring(0,n).equals(pref))c++;\\n      }\\n     return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n      int c=0;\\n      int n=pref.length();\\n      for(int i=0; i<words.length; i++)\\n      {\\n          if(words[i].length()>=n && words[i].substring(0,n).equals(pref))c++;\\n      }\\n     return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802865,
                "title": "javascript-startswith-method",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words) {\\n        if(word.startsWith(pref)) count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words) {\\n        if(word.startsWith(pref)) count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802740,
                "title": "simple-python-solution",
                "content": "\\t\\tclass Solution(object):\\n\\t\\t\\tdef prefixCount(self, words, pref):\\n\\t\\t\\t  c=0\\n\\t\\t\\t  for i in words:\\n\\t\\t\\t\\t if(pref in i):\\n\\t\\t\\t\\t\\tif(i.index(pref)==0):\\n\\t\\t\\t\\t\\t  c=c+1           \\n\\t\\t\\treturn c",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tclass Solution(object):\\n\\t\\t\\tdef prefixCount(self, words, pref):\\n\\t\\t\\t  c=0\\n\\t\\t\\t  for i in words:\\n\\t\\t\\t\\t if(pref in i):\\n\\t\\t\\t\\t\\tif(i.index(pref)==0):\\n\\t\\t\\t\\t\\t  c=c+1           \\n\\t\\t\\treturn c",
                "codeTag": "Java"
            },
            {
                "id": 1802639,
                "title": "c-readable-code-concise-solution",
                "content": "```\\nbool check(string s,string pre){\\n        if(pre.length()>s.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pre.length();i++){\\n            if(pre[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        int res = 0;\\n        for(auto s:words){\\n            \\n            if(check(s,pref)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(string s,string pre){\\n        if(pre.length()>s.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pre.length();i++){\\n            if(pre[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        int res = 0;\\n        for(auto s:words){\\n            \\n            if(check(s,pref)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802620,
                "title": "can-t-be-more-easy",
                "content": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int n = words.size(); \\n        int k = pref.length(); \\n        \\n        int count = 0; \\n        for(int i  =0; i<n; i++)\\n        {\\n            if(words[i].length() >= k)\\n            {\\n                if(words[i].substr(0,k) == pref)\\n                    count++; \\n            }\\n        }\\n        return count; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int n = words.size(); \\n        int k = pref.length(); \\n        \\n        int count = 0; \\n        for(int i  =0; i<n; i++)\\n        {\\n            if(words[i].length() >= k)\\n            {\\n                if(words[i].substr(0,k) == pref)\\n                    count++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4009632,
                "title": "different-approach-using-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n*Initialize a count variable to keep track of words with the given prefix.\\n*Iterate through each word in the array.\\n*Compare characters between the word and the prefix.\\n*If they match, increment the count.\\n*If the count reaches the length of the prefix, increment the count of words with the prefix.\\nReturn the count as the result.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int original=0;\\n        for(int i=0;i<words.length;i++){\\n            String sw=words[i];\\n            int index=0;\\n            int count=0;\\n            while(index<sw.length() && index<pref.length()){\\n                if(sw.charAt(index)==pref.charAt(index)){\\n                    count++;\\n                }\\n                if(count==pref.length()){\\n                    original++;\\n                }\\n                index++;\\n            }\\n        }\\n        return original ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int original=0;\\n        for(int i=0;i<words.length;i++){\\n            String sw=words[i];\\n            int index=0;\\n            int count=0;\\n            while(index<sw.length() && index<pref.length()){\\n                if(sw.charAt(index)==pref.charAt(index)){\\n                    count++;\\n                }\\n                if(count==pref.length()){\\n                    original++;\\n                }\\n                index++;\\n            }\\n        }\\n        return original ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656007,
                "title": "beginners-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    read the code once you will get it\\n\\n# Complexity\\n- Time complexity: O(nm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String word: words){\\n            if(word.length()>=pref.length() && word.substring(0,pref.length()).equals(pref)) count++;\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String word: words){\\n            if(word.length()>=pref.length() && word.substring(0,pref.length()).equals(pref)) count++;\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498495,
                "title": "rust-0-ms",
                "content": "\\n```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words\\n            .into_iter()\\n            .filter(|word| word.starts_with(&pref))\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words\\n            .into_iter()\\n            .filter(|word| word.starts_with(&pref))\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337663,
                "title": "easy-to-understand-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int pl=pref.length(),count=0,l=0; //pl is prefix length\\n\\n        for(String y:words){\\n            l=Math.min(pl,y.length());  //comparing identify the smallest length\\n           y=y.substring(0,l);   \\n           System.out.println(y);\\n            if(y.equals(pref))\\n            count++;\\n        }\\n        return count;\\n        \\n    \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int pl=pref.length(),count=0,l=0; //pl is prefix length\\n\\n        for(String y:words){\\n            l=Math.min(pl,y.length());  //comparing identify the smallest length\\n           y=y.substring(0,l);   \\n           System.out.println(y);\\n            if(y.equals(pref))\\n            count++;\\n        }\\n        return count;\\n        \\n    \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301114,
                "title": "very-easy-simple-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count=0;\\n        for(int i=0;i<words.length;i++) {\\n            if(words[i].startsWith(pref)) \\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count=0;\\n        for(int i=0;i<words.length;i++) {\\n            if(words[i].startsWith(pref)) \\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210317,
                "title": "java-solution-using-method",
                "content": "This method uses the method (startsWith),which is used to check the starting of both the string.\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int cnt=0;\\n        for(String str:words){\\n            if(str.startsWith(pref)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int cnt=0;\\n        for(String str:words){\\n            if(str.startsWith(pref)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163839,
                "title": "beats-100-time-complexity",
                "content": "![Screenshot 2023-02-09 at 4.10.32 PM.png](https://assets.leetcode.com/users/images/6fee551e-5497-4942-9fc7-ab61903482cc_1675939587.9287362.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare the first pref.length characters of words[i] and pref, and keep count.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i = 0; i<words.length; i++) {\\n        if(pref === words[i].slice(0, pref.length)) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i = 0; i<words.length; i++) {\\n        if(pref === words[i].slice(0, pref.length)) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3161282,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.length())==pref)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.length())==pref)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131974,
                "title": "best-c-code-easy-to-understand-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        for(int i=0;i<words.size();i++)\\n        {   \\n            int b=0;\\n            for( int j=0;j<pref.size();j++)\\n            {\\n                // if(words.size()<=pref.size())\\n                // {\\n                //     break;\\n                // }\\n                 if(words[i][j]!=pref[j])\\n                 { \\n                     break;\\n                 }\\n                 else\\n                 {\\n                     b++;\\n                 }\\n            }\\n            if(b==pref.size())\\n            {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nIF FOUND USEFULL DO UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        for(int i=0;i<words.size();i++)\\n        {   \\n            int b=0;\\n            for( int j=0;j<pref.size();j++)\\n            {\\n                // if(words.size()<=pref.size())\\n                // {\\n                //     break;\\n                // }\\n                 if(words[i][j]!=pref[j])\\n                 { \\n                     break;\\n                 }\\n                 else\\n                 {\\n                     b++;\\n                 }\\n            }\\n            if(b==pref.size())\\n            {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131970,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "Beats 95%+ in Runtime.....\\u270C\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n        for(auto word:words){\\n            int b=0;\\n            for(int i=0;i<pref.size();i++){\\n                if(word[i]!=pref[i]){\\n                    break;\\n                }else{\\n                    b++;\\n                }\\n            }\\n            if(b==pref.size()){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\nHope you like the code implementation, make sure to upvote \\u270C\\nGood day, keep coding .....",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n        for(auto word:words){\\n            int b=0;\\n            for(int i=0;i<pref.size();i++){\\n                if(word[i]!=pref[i]){\\n                    break;\\n                }else{\\n                    b++;\\n                }\\n            }\\n            if(b==pref.size()){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099858,
                "title": "c-no-built-in-functions",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        var count = 0;\\n\\n        var j = 0;\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i].Length < pref.Length) continue;\\n            var hasPrefix = true;\\n            while (j < pref.Length)\\n            {\\n                if (pref[j] != words[i][j])\\n                {\\n                    hasPrefix = false;\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            if (hasPrefix) count++;\\n            j = 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        var count = 0;\\n\\n        var j = 0;\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i].Length < pref.Length) continue;\\n            var hasPrefix = true;\\n            while (j < pref.Length)\\n            {\\n                if (pref[j] != words[i][j])\\n                {\\n                    hasPrefix = false;\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            if (hasPrefix) count++;\\n            j = 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868181,
                "title": "javascript-faster-than-98-23-memory-beats-96-25",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let includesPref = 0\\n    for (let word in words) {\\n        if (words[word].startsWith(pref)) includesPref++;\\n    }\\n    return includesPref;\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/2d582eb8-b759-41f7-9c46-1653faf86581_1669947042.89424.png)\\n![image.png](https://assets.leetcode.com/users/images/73988b56-2668-4549-b940-e30511568004_1669946746.8101223.png)\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let includesPref = 0\\n    for (let word in words) {\\n        if (words[word].startsWith(pref)) includesPref++;\\n    }\\n    return includesPref;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2825979,
                "title": "javascript",
                "content": "var prefixCount = function(words, pref) {\\n    let count=0;\\n    for( let i=0 ;i<words.length ;i++){\\n        let count1=0\\n        for( let j=0 ;j<words.length ;j++){\\n            if(words[i][j]!==pref[j]){\\n                  count1=0\\n                break;\\n              \\n            }\\n            else if(words[i][j]===pref[j]){\\n                 count1++;\\n                if(count1===pref.length){\\n             \\n                    break;\\n                }\\n               \\n                \\n            }\\n        }\\n        if(count1>0){\\n        count++\\n        }\\n      \\n    }\\n      return count;\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var prefixCount = function(words, pref) {\\n    let count=0;\\n    for( let i=0 ;i<words.length ;i++){\\n        let count1=0\\n        for( let j=0 ;j<words.length ;j++){\\n            if(words[i][j]!==pref[j]){\\n                  count1=0\\n                break;\\n              \\n            }\\n            else if(words[i][j]===pref[j]){\\n                 count1++;\\n                if(count1===pref.length){\\n             \\n                    break;\\n                }\\n               \\n                \\n            }\\n        }\\n        if(count1>0){\\n        count++\\n        }\\n      \\n    }\\n      return count;\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2825074,
                "title": "rust-oneline-beats-100-vim-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHave a loop go over all words, check if it starts with pref, then count a variable up that will be returned at the end.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\npub fn solution(words: Vec<String>, pref: String) -> i32 {\\n\\n    let mut count = 0;\\n\\n    for word in &words {\\n    \\n        if word.starts_with(&pref) { count += 1 }\\n\\n    }\\n\\n    count\\n}\\n\\n```\\nThen relaised I was writing rust and filter() exists so I rewrote it.\\n\\n# Code\\n```\\nimpl Solution {\\n  \\n  pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n\\n    return words.into_iter().filter(|e| e.starts_with(&pref)).collect::<Vec<_>>().len() as i32;\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn solution(words: Vec<String>, pref: String) -> i32 {\\n\\n    let mut count = 0;\\n\\n    for word in &words {\\n    \\n        if word.starts_with(&pref) { count += 1 }\\n\\n    }\\n\\n    count\\n}\\n\\n```\n```\\nimpl Solution {\\n  \\n  pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n\\n    return words.into_iter().filter(|e| e.starts_with(&pref)).collect::<Vec<_>>().len() as i32;\\n\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733892,
                "title": "trie-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean eow = false;\\n        int count = 0;\\n    }\\n\\n    class Trie {\\n        TrieNode root = new TrieNode();\\n\\n        public void insert(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.getOrDefault(ch, new TrieNode());\\n                temp.count++;\\n                curr.children.put(ch, temp);\\n                curr = temp;\\n            }\\n            curr.eow = true;\\n        }\\n\\n        public int getCount(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.get(ch);\\n                \\n                if (temp == null) {\\n                    return 0;\\n                }\\n                curr = temp;\\n            }\\n            return curr.count;\\n        }\\n    }\\n\\n    public int prefixCount(String[] words, String pref) {\\n        Trie trie = new Trie();\\n\\n        for (String word : words) {\\n            trie.insert(word);\\n        }\\n        return trie.getCount(pref);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean eow = false;\\n        int count = 0;\\n    }\\n\\n    class Trie {\\n        TrieNode root = new TrieNode();\\n\\n        public void insert(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.getOrDefault(ch, new TrieNode());\\n                temp.count++;\\n                curr.children.put(ch, temp);\\n                curr = temp;\\n            }\\n            curr.eow = true;\\n        }\\n\\n        public int getCount(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.get(ch);\\n                \\n                if (temp == null) {\\n                    return 0;\\n                }\\n                curr = temp;\\n            }\\n            return curr.count;\\n        }\\n    }\\n\\n    public int prefixCount(String[] words, String pref) {\\n        Trie trie = new Trie();\\n\\n        for (String word : words) {\\n            trie.insert(word);\\n        }\\n        return trie.getCount(pref);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694295,
                "title": "java",
                "content": "```\\n\\n    public int prefixCount(String[] words, String pref) {\\n       int size = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].indexOf(pref) == 0) {\\n                size++;\\n            }\\n        }\\n\\n        return size;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public int prefixCount(String[] words, String pref) {\\n       int size = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].indexOf(pref) == 0) {\\n                size++;\\n            }\\n        }\\n\\n        return size;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2672549,
                "title": "java-startswith-easy",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for (String s : words) {\\n            if (s.startsWith(pref)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for (String s : words) {\\n            if (s.startsWith(pref)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655074,
                "title": "javascript-easy-solution-in-one-line",
                "content": "```\\nvar prefixCount = function (words, pref) {\\n  return words.filter(word => word.startsWith(pref)).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function (words, pref) {\\n  return words.filter(word => word.startsWith(pref)).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630977,
                "title": "3-line-c-solution",
                "content": "class Solution {\\npublic:\\nint prefixCount(vector<string>&words, string pref) {int ans=0;\\nfor(int i=0;i<words.size();i++)\\nif( words[i].substr(0,pref.size()) == pref ) ans++;\\nreturn ans;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint prefixCount(vector<string>&words, string pref) {int ans=0;\\nfor(int i=0;i<words.size();i++)\\nif( words[i].substr(0,pref.size()) == pref ) ans++;\\nreturn ans;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2627768,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n                                                                                                                        int c=0;\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].length()<pref.length())continue;\\n            int j=0,f=0;string s=words[i];\\n            for( j=0;j<pref.length();j++){\\n                if(pref[j]!=s[j])f=1;\\n            }\\n            if(f==0)c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n                                                                                                                        int c=0;\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].length()<pref.length())continue;\\n            int j=0,f=0;string s=words[i];\\n            for( j=0;j<pref.length();j++){\\n                if(pref[j]!=s[j])f=1;\\n            }\\n            if(f==0)c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608393,
                "title": "2185-javascript-1-line-solution-o-nm",
                "content": "```\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567197,
                "title": "simple-c-solution",
                "content": "int count=0;\\n        for(int i=0;i<words.size();i++){\\n            int ans=words[i].find(pref);\\n            if(ans==0){\\n                count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [],
                "code": "int count=0;\\n        for(int i=0;i<words.size();i++){\\n            int ans=words[i].find(pref);\\n            if(ans==0){\\n                count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 2540990,
                "title": "one-line-python-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return len([word for word in words if pref==word[0:len(pref)]])\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return len([word for word in words if pref==word[0:len(pref)]])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531620,
                "title": "python-counting-words-with-a-given-prefix",
                "content": "```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        \"\"\"\\n        :type words: List[str]\\n        :type pref: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for elem in words:\\n            if elem.startswith(pref):\\n                count += 1\\n        \\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        \"\"\"\\n        :type words: List[str]\\n        :type pref: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for elem in words:\\n            if elem.startswith(pref):\\n                count += 1\\n        \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 2460351,
                "title": "c-faster-than-98-easy",
                "content": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n\\t\\n        int count=0;\\n        for(auto  i:words){\\n            if(i.size()>=pref.size()){            \\n             int j;\\n            for(j=0;j<pref.size();j++)\\n                if(i[j]!=pref[j])break;\\n            if(j==pref.size())count++;\\n            } \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n\\t\\n        int count=0;\\n        for(auto  i:words){\\n            if(i.size()>=pref.size()){            \\n             int j;\\n            for(j=0;j<pref.size();j++)\\n                if(i[j]!=pref[j])break;\\n            if(j==pref.size())count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457824,
                "title": "java-solution-1ms-runtime-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String s) {\\n        int cnt = 0;\\n        for (String str : words) {\\n            if (str.startsWith(s)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String s) {\\n        int cnt = 0;\\n        for (String str : words) {\\n            if (str.startsWith(s)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446970,
                "title": "javascript-best-solution-easy-understanding-100-faster-approach-beginner-friendly",
                "content": "```\\nconst prefixCount = (words, pref) => {\\n    let count = 0;\\n    \\n    words.forEach(word => {\\n        if(word.startsWith(pref)) count++;\\n    })\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst prefixCount = (words, pref) => {\\n    let count = 0;\\n    \\n    words.forEach(word => {\\n        if(word.startsWith(pref)) count++;\\n    })\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437628,
                "title": "easy-to-understand-implementation-java",
                "content": "Initiate linear loop in the array and check if length of word is greater then prefix length so you skip\\nelse you check for matching condition using equals.\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        \\n        int ans =0;\\n        int len = words.length;\\n        int plen = pref.length();\\n        \\n        for(int i=0;i<len;i++){\\n            \\n            if(words[i].length() < plen)continue;\\n            \\n            if(pref.equals(words[i].substring(0,plen))==true)ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        \\n        int ans =0;\\n        int len = words.length;\\n        int plen = pref.length();\\n        \\n        for(int i=0;i<len;i++){\\n            \\n            if(words[i].length() < plen)continue;\\n            \\n            if(pref.equals(words[i].substring(0,plen))==true)ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398493,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            bool check=true;\\n            if(pref.size()<=words[i].size())\\n            {\\n            for(int j=0;j<pref.size();j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    check=false;\\n                }\\n            }\\n                if(check==true)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            bool check=true;\\n            if(pref.size()<=words[i].size())\\n            {\\n            for(int j=0;j<pref.size();j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    check=false;\\n                }\\n            }\\n                if(check==true)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384110,
                "title": "python-trie-prefix-tree-solution",
                "content": "A simple python solution using [Trie](https://en.wikipedia.org/wiki/Trie)\\nDoes this problem need a trie? No! But I solved it using a Tire anyway. \\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        trie = {}\\n        \\n        for word in words:\\n            self.insert(trie, word)\\n        return self.getPrefixCount(trie, pref)\\n\\n    def insert(self, trie, word):\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = [1, {}]\\n            else:\\n                trie[ch][0] += 1\\n        \\n            trie = trie[ch][1]\\n        \\n            \\n    def getPrefixCount(self, trie, pref):\\n        lastNode = None\\n        for ch in pref:\\n            if ch not in trie:\\n                return 0\\n            \\n            lastNode = trie[ch][0]\\n            trie = trie[ch][1]\\n            \\n        return lastNode\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        trie = {}\\n        \\n        for word in words:\\n            self.insert(trie, word)\\n        return self.getPrefixCount(trie, pref)\\n\\n    def insert(self, trie, word):\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = [1, {}]\\n            else:\\n                trie[ch][0] += 1\\n        \\n            trie = trie[ch][1]\\n        \\n            \\n    def getPrefixCount(self, trie, pref):\\n        lastNode = None\\n        for ch in pref:\\n            if ch not in trie:\\n                return 0\\n            \\n            lastNode = trie[ch][0]\\n            trie = trie[ch][1]\\n            \\n        return lastNode\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336912,
                "title": "counting-words-with-a-given-prefix",
                "content": "var prefixCount = function(words, pref) {\\n    let cnt=0;\\n    for(let i=0;i<words.length;i++)\\n        {\\n           if(words[i].slice(0,pref.length)==pref)\\n           cnt++;\\n        }\\n    return cnt;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "var prefixCount = function(words, pref) {\\n    let cnt=0;\\n    for(let i=0;i<words.length;i++)\\n        {\\n           if(words[i].slice(0,pref.length)==pref)\\n           cnt++;\\n        }\\n    return cnt;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2321239,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n            int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n                if(!(isSubstring(pref , words[i])))\\n                        count++;\\n        }\\n            return count;\\n    }\\n     int isSubstring(string s1, string s2) {\\n             if (s2.find(s1) != string::npos)\\n             return s2.find(s1);\\n             return -1;\\n         }\\n};\\n```\\n\\n##### Please upvote\\n[https://github.com/Reehan9/Leetcode-Solutions](http://)",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n            int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n                if(!(isSubstring(pref , words[i])))\\n                        count++;\\n        }\\n            return count;\\n    }\\n     int isSubstring(string s1, string s2) {\\n             if (s2.find(s1) != string::npos)\\n             return s2.find(s1);\\n             return -1;\\n         }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321058,
                "title": "easy-c-solution-using-substring-operations",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint count=0;\\t\\t\\n\\t\\tfor(auto i : words){\\n\\t\\t\\tif(i.substr(0,pref.size())==pref)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```\\n\\n**Please Upvote If You Find It Useful\\n   Thank You!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint count=0;\\t\\t\\n\\t\\tfor(auto i : words){\\n\\t\\t\\tif(i.substr(0,pref.size())==pref)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298978,
                "title": "counting-words-with-a-given-prefix-with-python3",
                "content": "\\tdef prefixcount(words,pref):\\n\\t\\tcount = 0\\n\\t\\tfor element in words:\\n\\t\\t\\tif pref == element[0:len(pref)]:\\n\\t\\t\\t\\tcount +=1\\n\\t\\treturn count\\n\\twords = [\"pay\",\"attention\",\"practice\",\"attend\"]\\n\\tpref = \"at\"\\n\\tprefixcount(words,pref)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tdef prefixcount(words,pref):\\n\\t\\tcount = 0\\n\\t\\tfor element in words:\\n\\t\\t\\tif pref == element[0:len(pref)]:\\n\\t\\t\\t\\tcount +=1\\n\\t\\treturn count\\n\\twords = [\"pay\",\"attention\",\"practice\",\"attend\"]\\n\\tpref = \"at\"\\n\\tprefixcount(words,pref)",
                "codeTag": "Python3"
            },
            {
                "id": 2278482,
                "title": "easy-javascript-solution",
                "content": "# Runtime: 58 ms, faster than 98.27% of JavaScript online submissions for Counting Words With a Given Prefix.\\nMemory Usage: 42.5 MB, less than 80.94% of JavaScript online submissions for Counting Words With a Given Prefix.\\n\\n```\\n\\nvar prefixCount = function(words, pref) {\\n    \\n    let count = 0;\\n    \\n    for(var i=0; i< words.length; i++){\\n        let matchFTwo = words[i].slice(0, pref.length);\\n        \\n        matchFTwo === pref ? count++ : count\\n        \\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar prefixCount = function(words, pref) {\\n    \\n    let count = 0;\\n    \\n    for(var i=0; i< words.length; i++){\\n        let matchFTwo = words[i].slice(0, pref.length);\\n        \\n        matchFTwo === pref ? count++ : count\\n        \\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235920,
                "title": "c-using-substr-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        int s=pref.size();\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].substr(0,s)==pref){\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        int s=pref.size();\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].substr(0,s)==pref){\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221645,
                "title": "python-solution-for-beginners-by-beginner",
                "content": "**Runtime: 45 ms, faster than 84.18% of Python3 online submissions for Counting Words With a Given Prefix.\\nMemory Usage: 13.9 MB, less than 96.55% of Python3 online submissions for Counting Words With a Given Prefix.**\\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        ans = 0\\n        for i in words:\\n            if i[:len(pref)] == pref:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        ans = 0\\n        for i in words:\\n            if i[:len(pref)] == pref:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219621,
                "title": "c-one-line-count-if",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        return count_if(words.begin(), words.end(), [&](const string& w){return w.substr(0, pref.size()) == pref;});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        return count_if(words.begin(), words.end(), [&](const string& w){return w.substr(0, pref.size()) == pref;});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179351,
                "title": "easy-c-solution",
                "content": "```\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.size())==pref)\\n                count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.size())==pref)\\n                count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2117918,
                "title": "c-best-one-liner-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n      for(auto x:words)  {\\n          if(x.find(pref)==0){//if pref is on the starting index of every words string then c++;\\n              c++;            \\n          }\\n      }\\n        return c;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n      for(auto x:words)  {\\n          if(x.find(pref)==0){//if pref is on the starting index of every words string then c++;\\n              c++;            \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2104242,
                "title": "javascript-solution-without-using-any-built-in-functions",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(foundPref(words[i],pref))\\n            count++;\\n    }\\n    return count;\\n};\\n\\nlet foundPref = function(word,pref) {\\n    for(let i=0; i<pref.length; i++) {\\n        if(word[i] != pref[i]) \\n\\t\\t\\treturn false;               \\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(foundPref(words[i],pref))\\n            count++;\\n    }\\n    return count;\\n};\\n\\nlet foundPref = function(word,pref) {\\n    for(let i=0; i<pref.length; i++) {\\n        if(word[i] != pref[i]) \\n\\t\\t\\treturn false;               \\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067484,
                "title": "easy-c-approach",
                "content": "```\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count=0;\\n       for(auto i : words){\\n           bool check = true;\\n           for(int j = 0;j<pref.size();j++){\\n               if(i[j]!=pref[j]){\\n                   check=false;\\n                   break;\\n               }\\n           }\\n           if(check){count++;}\\n       }\\n        return count;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count=0;\\n       for(auto i : words){\\n           bool check = true;\\n           for(int j = 0;j<pref.size();j++){\\n               if(i[j]!=pref[j]){\\n                   check=false;\\n                   break;\\n               }\\n           }\\n           if(check){count++;}\\n       }\\n        return count;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2044122,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count  = 0;\\n        for(int i = 0;i<words.size();i++)\\n        {\\n            string ss = words[i];\\n            int n = pref.length();\\n            string sub = ss.substr(0,n);\\n            \\n            if(sub == pref) {\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count  = 0;\\n        for(int i = 0;i<words.size();i++)\\n        {\\n            string ss = words[i];\\n            int n = pref.length();\\n            string sub = ss.substr(0,n);\\n            \\n            if(sub == pref) {\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965549,
                "title": "using-trie-data-structure",
                "content": "\\tclass TrieNode{\\n\\t\\tpublic :\\n\\t\\tchar data;\\n\\t\\tTrieNode* child[26];\\n\\t\\tint wordend;\\n\\t\\tbool is_end;\\n\\t\\tTrieNode(){\\n\\t\\t\\twordend=0;\\n\\t\\t\\tis_end=false;\\n\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\tchild[i]=NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid insert(TrieNode* root,string s){\\n\\t\\t\\tTrieNode* curr=root;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tint  index=s[i]-\\'a\\';\\n\\t\\t\\t\\tif(curr->child[index]==NULL){\\n\\t\\t\\t\\t\\tcurr->child[index]= new TrieNode();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr->child[index]->wordend++;\\n\\t\\t\\t\\tcurr=curr->child[index];\\n\\t\\t\\t}\\n\\t\\t\\tcurr->is_end=true;\\n\\t\\t}\\n\\t\\tint count_prefix(TrieNode* root,string prefix){\\n\\t\\t\\tTrieNode* curr=root;\\n\\t\\t\\tfor(int i=0; i<prefix.size(); i++){\\n\\t\\t\\t\\tint index=prefix[i]-\\'a\\';\\n\\t\\t\\t\\tif(curr->child[index]==NULL)\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\tcurr=curr->child[index];\\n\\t\\t\\t}\\n\\t\\t\\treturn curr->wordend;        \\n\\t\\t}\\n\\n\\t};\\n\\tclass Solution :public TrieNode{\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tTrieNode* root= new TrieNode();\\n\\t\\t\\tfor(string word: words){\\n\\t\\t\\t\\tinsert(root,word);\\n\\t\\t\\t}\\n\\t\\t\\treturn count_prefix(root,pref);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution :public TrieNode{\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tTrieNode* root= new TrieNode();\\n\\t\\t\\tfor(string word: words){\\n\\t\\t\\t\\tinsert(root,word);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1960839,
                "title": "basic-c-o-n-time-complexity-code",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool isprefix(string word,string prefix)\\n    {\\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        while(i<word.length() && j<prefix.length())\\n        {\\n            if(word[i]!=prefix[j])\\n            {\\n                break;\\n            }\\n            i++;\\n            j++;\\n            c++;\\n        }\\n        if(c==prefix.length())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(isprefix(words[i],pref))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925154,
                "title": "java-1ms",
                "content": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)) count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1877195,
                "title": "simple-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string pref, string s){\\n        \\n        int n=pref.size();\\n        int i=0;\\n        int c=0;\\n        \\n        while(i<n){\\n            \\n            if(pref[i]==s[i])c++;\\n            \\n            else return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int ans=0;\\n        \\n        for(string x:words){\\n            \\n            if(check(pref,x))ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string pref, string s){\\n        \\n        int n=pref.size();\\n        int i=0;\\n        int c=0;\\n        \\n        while(i<n){\\n            \\n            if(pref[i]==s[i])c++;\\n            \\n            else return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int ans=0;\\n        \\n        for(string x:words){\\n            \\n            if(check(pref,x))ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871318,
                "title": "python3-1-line",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(el.startswith(pref) for el in words)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(el.startswith(pref) for el in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867008,
                "title": "simple-python-solution-easy-to-understand",
                "content": "\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        #basic check\\n        if words is None or len(words) == 0: return 0\\n        \\n        #initialization\\n        \\n        count = 0\\n        for word in words:\\n            if word.startswith(pref):\\n                count = count + 1\\n                \\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        #basic check\\n        if words is None or len(words) == 0: return 0\\n        \\n        #initialization\\n        \\n        count = 0\\n        for word in words:\\n            if word.startswith(pref):\\n                count = count + 1\\n                \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1861908,
                "title": "python-trie-solution",
                "content": "```\\nclass Node(object):\\n    def __init__(self, key, data=None):\\n        self.key = key\\n        self.data = data\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(None)\\n        \\n    def insert(self, string: str) -> None:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char not in current_node.children:\\n                current_node.children[char] = Node(char)\\n            current_node = current_node.children[char]\\n        current_node.data = string\\n        \\n    def search(self, string: str) -> bool:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char in current_node.children:\\n                current_node = current_node.children[char]\\n            else:\\n                return False\\n\\n        if current_node.data:\\n            return True\\n        else:\\n            return False\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        current_node = self.head\\n        words = []\\n\\n        for p in prefix:\\n            if p in current_node.children:\\n                current_node = current_node.children[p]\\n            else:\\n                return []\\n\\n        current_node = [current_node]\\n        next_node = []\\n        while True:\\n            for node in current_node:\\n                if node.data:\\n                    words.append(node.data)\\n                next_node.extend(list(node.children.values()))\\n            if len(next_node) != 0:\\n                current_node = next_node\\n                next_node = []\\n            else:\\n                break\\n\\n        return words\\n\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n  \\n        trie = Trie()\\n        count = defaultdict(int)\\n        for word in words:\\n            trie.insert(word)\\n            count[word] += 1\\n        result = trie.startsWith(pref)\\n        res = 0 \\n     \\n        for word in result:\\n            res += count[word]\\n        return res \\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass Node(object):\\n    def __init__(self, key, data=None):\\n        self.key = key\\n        self.data = data\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(None)\\n        \\n    def insert(self, string: str) -> None:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char not in current_node.children:\\n                current_node.children[char] = Node(char)\\n            current_node = current_node.children[char]\\n        current_node.data = string\\n        \\n    def search(self, string: str) -> bool:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char in current_node.children:\\n                current_node = current_node.children[char]\\n            else:\\n                return False\\n\\n        if current_node.data:\\n            return True\\n        else:\\n            return False\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        current_node = self.head\\n        words = []\\n\\n        for p in prefix:\\n            if p in current_node.children:\\n                current_node = current_node.children[p]\\n            else:\\n                return []\\n\\n        current_node = [current_node]\\n        next_node = []\\n        while True:\\n            for node in current_node:\\n                if node.data:\\n                    words.append(node.data)\\n                next_node.extend(list(node.children.values()))\\n            if len(next_node) != 0:\\n                current_node = next_node\\n                next_node = []\\n            else:\\n                break\\n\\n        return words\\n\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n  \\n        trie = Trie()\\n        count = defaultdict(int)\\n        for word in words:\\n            trie.insert(word)\\n            count[word] += 1\\n        result = trie.startsWith(pref)\\n        res = 0 \\n     \\n        for word in result:\\n            res += count[word]\\n        return res \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854979,
                "title": "1ms-java-solution-easy-to-understand",
                "content": "Hope this helps!!\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0; \\n        for(int i = 0; i<words.length; i++){\\n            if(words[i].startsWith(pref)){\\n                count++; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0; \\n        for(int i = 0; i<words.length; i++){\\n            if(words[i].startsWith(pref)){\\n                count++; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852307,
                "title": "python-ez-readable-code-2-ways-regex-solution",
                "content": "```\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tfor word in words:\\n\\t  if word.startswith(pref):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```\\nNow, We can use the ^ if we want to attack it by way of RegEx:\\n```\\nimport re\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tpref = \\'^\\'+ pref\\n\\tfor word in words:\\n\\t  if re.match(pref, word):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tfor word in words:\\n\\t  if word.startswith(pref):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```\n```\\nimport re\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tpref = \\'^\\'+ pref\\n\\tfor word in words:\\n\\t  if re.match(pref, word):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1842983,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if(words[i][:len(pref)])==pref:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if(words[i][:len(pref)])==pref:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841783,
                "title": "simple-and-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        pref_len=len(pref)\\n        count=0\\n        for i in words:\\n            if pref==i[:pref_len]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        pref_len=len(pref)\\n        count=0\\n        for i in words:\\n            if pref==i[:pref_len]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838595,
                "title": "straightforward-java-solution-without-string-functions-runtime-0-ms",
                "content": "**Runtime**: 0 ms, faster than 100.00%, **Memory Usage**: 42.2 MB, less than 90.31%.\\n\\n```\\n  public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n\\n    for (String word : words) {\\n      if (startsWith(word, pref)) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n\\n  private boolean startsWith(String word, String prefix) {\\n    if (word.length() < prefix.length()) {\\n      return false;\\n    }\\n    for (int i = 0; i < prefix.length(); i++) {\\n      if (word.charAt(i) != prefix.charAt(i)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n\\n    for (String word : words) {\\n      if (startsWith(word, pref)) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n\\n  private boolean startsWith(String word, String prefix) {\\n    if (word.length() < prefix.length()) {\\n      return false;\\n    }\\n    for (int i = 0; i < prefix.length(); i++) {\\n      if (word.charAt(i) != prefix.charAt(i)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836245,
                "title": "best-simplest-easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = words.size();\\n        int c = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            bool res = true;\\n            string s = words[i];\\n            if(s.length()<pref.length())\\n            {\\n                continue;\\n            }\\n            int k = 0;\\n            for(int j=0; j<pref.length() && k<s.length(); j++)\\n            {\\n                if(pref[j] != s[k])\\n                {\\n                    res = false;\\n                    break;\\n                }\\n                k++;\\n            }\\n            \\n            if(res)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n//pls upvote if you find solution helpful...! Thanks...!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = words.size();\\n        int c = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            bool res = true;\\n            string s = words[i];\\n            if(s.length()<pref.length())\\n            {\\n                continue;\\n            }\\n            int k = 0;\\n            for(int j=0; j<pref.length() && k<s.length(); j++)\\n            {\\n                if(pref[j] != s[k])\\n                {\\n                    res = false;\\n                    break;\\n                }\\n                k++;\\n            }\\n            \\n            if(res)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n//pls upvote if you find solution helpful...! Thanks...!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828878,
                "title": "java-1-liner",
                "content": ">**T/S:** O(mn)/O(1), where m = size(words), n = size(pref)\\n```\\npublic int prefixCount(String[] words, String pref) {\\n\\tvar count = 0;\\n\\tfor (var word : words)\\n\\t\\tif (word.startsWith(pref))\\n\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\\n**Version 2:** 1 liner using [Streams](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)\\n```\\npublic int prefixCount(String[] words, String pref) {\\n\\treturn (int) Arrays.stream(words)\\n\\t\\t\\t\\t\\t   .filter(word -> word.startsWith(pref))\\n\\t\\t\\t\\t\\t   .count();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int prefixCount(String[] words, String pref) {\\n\\tvar count = 0;\\n\\tfor (var word : words)\\n\\t\\tif (word.startsWith(pref))\\n\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\n```\\npublic int prefixCount(String[] words, String pref) {\\n\\treturn (int) Arrays.stream(words)\\n\\t\\t\\t\\t\\t   .filter(word -> word.startsWith(pref))\\n\\t\\t\\t\\t\\t   .count();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828550,
                "title": "c-simplest-and-cleanest-code-for-quick-understanding",
                "content": "```\\n    int prefixCount(vector<string>& words, string pref)     {\\n        int ans = 0                                         ;\\n        for(auto &word : words)                             {\\n            if(word.length() < pref.length()) continue      ;\\n            int i = 0                                       ;\\n            for(i; i < pref.length(); i++)                  {\\n                if(pref[i] != word[i]) break                ;}\\n            if(i == pref.length()) ans++                    ;\\n                                                            }\\n        return ans                                          ;}\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n    int prefixCount(vector<string>& words, string pref)     {\\n        int ans = 0                                         ;\\n        for(auto &word : words)                             {\\n            if(word.length() < pref.length()) continue      ;\\n            int i = 0                                       ;\\n            for(i; i < pref.length(); i++)                  {\\n                if(pref[i] != word[i]) break                ;}\\n            if(i == pref.length()) ans++                    ;\\n                                                            }\\n        return ans                                          ;}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826783,
                "title": "easy-c-solution",
                "content": "\\'\\'\\'\\n\\n    int prefixCount(vector<string>& words, string pref) {\\n        int l = pref.length();\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].length()>=l)\\n            {\\n                if(words[i].substr(0,l) == pref)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\n\\n    int prefixCount(vector<string>& words, string pref) {\\n        int l = pref.length();\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].length()>=l)\\n            {\\n                if(words[i].substr(0,l) == pref)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1825064,
                "title": "6-lines-python-code-intuitive-approach",
                "content": "Count length of prefix and check the starting part of every word in words for the prefix and increment count.\\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        n=len(pref)\\n        cnt=0\\n        for i in words:\\n            if i[:n] == pref:\\n                cnt+=1\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        n=len(pref)\\n        cnt=0\\n        for i in words:\\n            if i[:n] == pref:\\n                cnt+=1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824609,
                "title": "python-97-45-faster-easy-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][:len(pref)] == pref:\\n                count += 1\\n        return count",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][:len(pref)] == pref:\\n                count += 1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1818658,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            bool check = true;\\n            for(int j = 0; j < pref.size(); j++)\\n                if(words[i][j] != pref[j]){\\n                    check = false;\\n                    break;\\n                }\\n            if(check) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0, pre = pref.size();\\n        \\n        for(auto w : words){\\n            string s = w.substr(0, pre);\\n            if(s == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            bool check = true;\\n            for(int j = 0; j < pref.size(); j++)\\n                if(words[i][j] != pref[j]){\\n                    check = false;\\n                    break;\\n                }\\n            if(check) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0, pre = pref.size();\\n        \\n        for(auto w : words){\\n            string s = w.substr(0, pre);\\n            if(s == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818362,
                "title": "simple-easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int count=0;\\n        bool flag=true;\\n        for(int i=0;i<n;i++){\\n            string w = words[i];\\n            int j=0;\\n            while(j<pref.length()){\\n                if(pref[j]!=w[j]){\\n                    flag=false;\\n                    break;\\n                }\\n                j++;\\n                \\n            }\\n            if(flag) count++;\\n            else flag=!flag;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int count=0;\\n        bool flag=true;\\n        for(int i=0;i<n;i++){\\n            string w = words[i];\\n            int j=0;\\n            while(j<pref.length()){\\n                if(pref[j]!=w[j]){\\n                    flag=false;\\n                    break;\\n                }\\n                j++;\\n                \\n            }\\n            if(flag) count++;\\n            else flag=!flag;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818244,
                "title": "java-2-solutions-easy-implementations",
                "content": "**Solution 1:**\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            String temp=\"\";\\n            if(words[i].length()>=pref.length()) temp=words[i].substring(0,pref.length());\\n            \\n            if(pref.equals(temp)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].indexOf(pref)==0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            String temp=\"\";\\n            if(words[i].length()>=pref.length()) temp=words[i].substring(0,pref.length());\\n            \\n            if(pref.equals(temp)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].indexOf(pref)==0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809765,
                "title": "super-easy-to-understand-c-code",
                "content": "```\\nint prefixCount(vector<string>& words, string pref) {\\n\\tint ans = 0;\\n\\tfor (auto word : words)\\n\\t{\\n\\t\\tif (word.length() >= pref.length() && word.substr(0, pref.length()) == pref)\\n\\t\\t\\tans++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint prefixCount(vector<string>& words, string pref) {\\n\\tint ans = 0;\\n\\tfor (auto word : words)\\n\\t{\\n\\t\\tif (word.length() >= pref.length() && word.substr(0, pref.length()) == pref)\\n\\t\\t\\tans++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809676,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(auto str:words){ \\n        //This fuction returns the first index where string pref occurs    \\n            int index=str.find(pref);\\n            if (index==0)\\n                count++;\\n            }\\n            return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(auto str:words){ \\n        //This fuction returns the first index where string pref occurs    \\n            int index=str.find(pref);\\n            if (index==0)\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1807915,
                "title": "c-one-line-linq-solution",
                "content": "```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        return words.Count(o => o.StartWith(pref));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        return words.Count(o => o.StartWith(pref));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806964,
                "title": "my-java-solution-1-straight-forward-approach-2-using-trie-ds",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int prefixCount = 0;\\n        int prefixLength = pref.length();\\n        for (String word : words) {\\n            if (word.length() < prefixLength) {\\n                continue;\\n            }\\n            int index = 0;\\n            boolean prefixFound = true;\\n            while (index < prefixLength) {\\n                if (word.charAt(index) != pref.charAt(index)) {\\n                    prefixFound = false;\\n                    break;\\n                }\\n                index++;\\n            }\\n            if (prefixFound) {\\n                prefixCount++;\\n            }\\n        }\\n        return prefixCount;\\n    }\\n}\\n```\\n\\n\\n```\\nUsing trie\\n\\nclass Solution {\\n    \\n    private TrieNode root;\\n    public Solution() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String word) {\\n        TrieNode node = root;\\n        for (char ch : word.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                node.child[index] = new TrieNode();\\n            }\\n            node.ch = ch;\\n            node = node.child[index];\\n            node.count++;\\n        }\\n        node.word = word;\\n    }\\n    \\n    public int prefixFinder(String prefix) {\\n        TrieNode node = root;\\n        for (char ch : prefix.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                return 0;\\n            }\\n            node = node.child[index];\\n        }\\n        return node.count;\\n    }\\n    \\n    public int prefixCount(String[] words, String prefix) {\\n        int prefixCount = 0;\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        return prefixFinder(prefix);\\n    }\\n}\\n\\nclass TrieNode {\\n    char ch;\\n    String word;\\n    int count = 0;\\n    TrieNode [] child;\\n    TrieNode(){\\n        this.child = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int prefixCount = 0;\\n        int prefixLength = pref.length();\\n        for (String word : words) {\\n            if (word.length() < prefixLength) {\\n                continue;\\n            }\\n            int index = 0;\\n            boolean prefixFound = true;\\n            while (index < prefixLength) {\\n                if (word.charAt(index) != pref.charAt(index)) {\\n                    prefixFound = false;\\n                    break;\\n                }\\n                index++;\\n            }\\n            if (prefixFound) {\\n                prefixCount++;\\n            }\\n        }\\n        return prefixCount;\\n    }\\n}\\n```\n```\\nUsing trie\\n\\nclass Solution {\\n    \\n    private TrieNode root;\\n    public Solution() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String word) {\\n        TrieNode node = root;\\n        for (char ch : word.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                node.child[index] = new TrieNode();\\n            }\\n            node.ch = ch;\\n            node = node.child[index];\\n            node.count++;\\n        }\\n        node.word = word;\\n    }\\n    \\n    public int prefixFinder(String prefix) {\\n        TrieNode node = root;\\n        for (char ch : prefix.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                return 0;\\n            }\\n            node = node.child[index];\\n        }\\n        return node.count;\\n    }\\n    \\n    public int prefixCount(String[] words, String prefix) {\\n        int prefixCount = 0;\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        return prefixFinder(prefix);\\n    }\\n}\\n\\nclass TrieNode {\\n    char ch;\\n    String word;\\n    int count = 0;\\n    TrieNode [] child;\\n    TrieNode(){\\n        this.child = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806641,
                "title": "simple-solution",
                "content": "\\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count",
                "solutionTags": [],
                "code": "\\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count",
                "codeTag": "Unknown"
            },
            {
                "id": 1805758,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n     int c=0;\\n        int x=pref.size();\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string s=words[i];\\n            if(s.length()<x)\\n            continue;\\n            else\\n            {\\n                \\n                string str=s.substr(0,x);\\n                if(str==pref)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n     int c=0;\\n        int x=pref.size();\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string s=words[i];\\n            if(s.length()<x)\\n            continue;\\n            else\\n            {\\n                \\n                string str=s.substr(0,x);\\n                if(str==pref)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805056,
                "title": "scala-one-liner",
                "content": "```\\nobject Solution {\\n    def prefixCount(words: Array[String], pref: String): Int = {\\n        words.count(_.startsWith(pref))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def prefixCount(words: Array[String], pref: String): Int = {\\n        words.count(_.startsWith(pref))\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1804593,
                "title": "java-multiple-approaches",
                "content": "**Approach 1:** Using String charAt and comparing char by char\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && hasPrefix(word,pref)) count++;\\n        }\\n        return count;\\n    }\\n    \\n    public boolean hasPrefix(String word, String prefix){\\n        for(int i=0; i<prefix.length(); i++){\\n            if(prefix.charAt(i) != word.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**Approach 2:** Using string indexOf\\n```\\nint\\tindexOf(String str) - Returns the index within this string of the first occurrence of the specified substring.\\n```\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.indexOf(pref)==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Approach 3:** Using String startsWith\\n```\\nboolean\\tstartsWith (String prefix) - Tests if this string starts with the specified prefix.\\n```\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Approach 4:** Using Trie data structure. One can argue trie might not be required for this problem but its a good way to practice and implement it\\n\\n```\\npublic class Trie {\\n\\tNode root;\\n\\n\\tTrie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\');\\n\\t}\\n\\n\\tpublic void insert(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null) {\\n\\t\\t\\t\\tcurr.children[c - \\'a\\'] = new Node(c);\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n            curr.wordCount++;\\n\\t\\t}\\n\\t\\tcurr.isWord = true;\\n\\t}\\n\\n\\tpublic boolean hasPrefix(String prefix) {\\n\\t\\treturn findNode(prefix) != null;\\n\\t}\\n\\n\\tpublic boolean hasWord(String word) {\\n\\t\\tNode curr = findNode(word);\\n\\t\\treturn curr != null && curr.isWord;\\n\\t}\\n\\n\\tpublic Node findNode(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n\\t\\t}\\n\\t\\treturn curr;\\n\\t}\\n}\\n\\nclass Node {\\n\\tboolean isWord;\\n\\tchar c;\\n\\tNode[] children;\\n    int wordCount; // maintain word count of number of words or prefixes this character is shared with\\n\\t\\n    Node(char c) {\\n\\t\\tthis.c = c;\\n\\t\\tthis.children = new Node[26];\\n\\t}\\n}\\n\\n\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        Trie trie = new Trie();\\n        for(String word : words){\\n           trie.insert(word);\\n        }\\n        // find if this prefix exists\\n        Node curr = trie.findNode(pref); \\n        if(curr != null){\\n\\t\\t\\t// if it exists return the word count i.e number of words in which this prefix exists\\n             return curr.wordCount;\\n         }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && hasPrefix(word,pref)) count++;\\n        }\\n        return count;\\n    }\\n    \\n    public boolean hasPrefix(String word, String prefix){\\n        for(int i=0; i<prefix.length(); i++){\\n            if(prefix.charAt(i) != word.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nint\\tindexOf(String str) - Returns the index within this string of the first occurrence of the specified substring.\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.indexOf(pref)==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nboolean\\tstartsWith (String prefix) - Tests if this string starts with the specified prefix.\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Trie {\\n\\tNode root;\\n\\n\\tTrie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\');\\n\\t}\\n\\n\\tpublic void insert(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null) {\\n\\t\\t\\t\\tcurr.children[c - \\'a\\'] = new Node(c);\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n            curr.wordCount++;\\n\\t\\t}\\n\\t\\tcurr.isWord = true;\\n\\t}\\n\\n\\tpublic boolean hasPrefix(String prefix) {\\n\\t\\treturn findNode(prefix) != null;\\n\\t}\\n\\n\\tpublic boolean hasWord(String word) {\\n\\t\\tNode curr = findNode(word);\\n\\t\\treturn curr != null && curr.isWord;\\n\\t}\\n\\n\\tpublic Node findNode(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n\\t\\t}\\n\\t\\treturn curr;\\n\\t}\\n}\\n\\nclass Node {\\n\\tboolean isWord;\\n\\tchar c;\\n\\tNode[] children;\\n    int wordCount; // maintain word count of number of words or prefixes this character is shared with\\n\\t\\n    Node(char c) {\\n\\t\\tthis.c = c;\\n\\t\\tthis.children = new Node[26];\\n\\t}\\n}\\n\\n\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        Trie trie = new Trie();\\n        for(String word : words){\\n           trie.insert(word);\\n        }\\n        // find if this prefix exists\\n        Node curr = trie.findNode(pref); \\n        if(curr != null){\\n\\t\\t\\t// if it exists return the word count i.e number of words in which this prefix exists\\n             return curr.wordCount;\\n         }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803726,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public static int prefixCount(String[] words, String pref) {\\n        int ans = 0;\\n        for (String str : words) {\\n            if (isEqual(str, pref)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static boolean isEqual(String str, String pref) {\\n        if (pref.length() > str.length()) return false;\\n        for (int i = 0; i < pref.length(); i++) {\\n            if (str.charAt(i) != pref.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int prefixCount(String[] words, String pref) {\\n        int ans = 0;\\n        for (String str : words) {\\n            if (isEqual(str, pref)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static boolean isEqual(String str, String pref) {\\n        if (pref.length() > str.length()) return false;\\n        for (int i = 0; i < pref.length(); i++) {\\n            if (str.charAt(i) != pref.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803668,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        # one-liner \\n        return sum(word.find(pref) == 0 for word in words)\\n    \\n        # detail approach \\n#         ans = 0\\n#         for i in range(len(words)):\\n#             a = words[i]\\n#             lp = len(pref)\\n#             cnt = 0\\n#             if len(a) < lp:\\n#                 continue\\n#             for j in range(lp):\\n#                 if pref[j] == a[j]:\\n#                     j += 1\\n#                     cnt += 1\\n#                 if cnt == lp:\\n#                     break\\n#                 if pref[j] != a[j]:\\n#                     break\\n                    \\n#             if cnt == lp:\\n#                 ans += 1\\n#         return ans\\n    \\n    # take each word and check if lenght is less then continue, as its not the candidate solution \\n    # else \\n    # compare with pref, increment count, if count equals length of prf, its the solution, add to ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        # one-liner \\n        return sum(word.find(pref) == 0 for word in words)\\n    \\n        # detail approach \\n#         ans = 0\\n#         for i in range(len(words)):\\n#             a = words[i]\\n#             lp = len(pref)\\n#             cnt = 0\\n#             if len(a) < lp:\\n#                 continue\\n#             for j in range(lp):\\n#                 if pref[j] == a[j]:\\n#                     j += 1\\n#                     cnt += 1\\n#                 if cnt == lp:\\n#                     break\\n#                 if pref[j] != a[j]:\\n#                     break\\n                    \\n#             if cnt == lp:\\n#                 ans += 1\\n#         return ans\\n    \\n    # take each word and check if lenght is less then continue, as its not the candidate solution \\n    # else \\n    # compare with pref, increment count, if count equals length of prf, its the solution, add to ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803656,
                "title": "c-easy-to-understand",
                "content": "*here we are watching for prefixes in every string in vector of strings.*\\n*the simple way or brtue force approach is to check for the prefixes that matches or not and for that we use **substr** function to access the substring which we require to check for the prefix* \\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint len=pref.length(),n=words.size(),ctr=0;\\n\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring sub=words[i].substr(0,len); \\n\\t\\t\\t\\t// it takes substring from the ith string from words vector\\n\\t\\t\\t\\t// then sub matches with the pref \\n\\t\\t\\t\\t// if sub matches it will increase the counter othwerwise it will check for next\\n\\t\\t\\t\\tif(sub==pref)\\n\\t\\t\\t\\t\\tctr++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ctr;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint len=pref.length(),n=words.size(),ctr=0;\\n\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring sub=words[i].substr(0,len); \\n\\t\\t\\t\\t// it takes substring from the ith string from words vector\\n\\t\\t\\t\\t// then sub matches with the pref \\n\\t\\t\\t\\t// if sub matches it will increase the counter othwerwise it will check for next\\n\\t\\t\\t\\tif(sub==pref)\\n\\t\\t\\t\\t\\tctr++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1803645,
                "title": "1-liner-in-js",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(w=>w.substring(0,pref.length)===pref).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(w=>w.substring(0,pref.length)===pref).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803451,
                "title": "c-very-easy-easy-to-understand-simple-code",
                "content": "Just do the dry one line by line this code, very easy to understand\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            string w = words[i];\\n            int n = w.size();\\n            \\n            string w1 = w.substr(0,pref.size());\\n            \\n            if(w1 == pref)\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            string w = words[i];\\n            int n = w.size();\\n            \\n            string w1 = w.substr(0,pref.size());\\n            \\n            if(w1 == pref)\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803429,
                "title": "java-c-solution-100",
                "content": "**C++ Solution**\\n\\n```\\nlass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        int ans = 0;\\n\\t\\t\\n\\t\\tfor(auto &it : words)\\n\\t\\t{\\n\\t\\t\\tint i = 0;          // for iterating in the pref\\n\\t\\t\\twhile( it[i] == pref[i]){    // if starting elements are matched then keep looping\\n            count++;\\n            i++;\\n            \\n            if(i==pref.size()){        // if i reaches the size means it got all the elements\\n                break;                  // so break the while loop\\n            }\\n        }\\n        if(count == pref.size()){    // is it equal to size ?? means all elements are found??\\n            ans++;                   // no. of string in vector that have this pefix\\n        }\\n        count=0;        // for again incrementing for other strinngs in vector\\n      }\\n\\nreturn ans;\\n    }\\n};\\n```\\n\\n**JAVA Solution**\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for(String w : words)\\n\\t\\t{\\n            if(w.indexOf(pref) == 0){\\n                count++;\\n            } else {\\n                count+= 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nlass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        int ans = 0;\\n\\t\\t\\n\\t\\tfor(auto &it : words)\\n\\t\\t{\\n\\t\\t\\tint i = 0;          // for iterating in the pref\\n\\t\\t\\twhile( it[i] == pref[i]){    // if starting elements are matched then keep looping\\n            count++;\\n            i++;\\n            \\n            if(i==pref.size()){        // if i reaches the size means it got all the elements\\n                break;                  // so break the while loop\\n            }\\n        }\\n        if(count == pref.size()){    // is it equal to size ?? means all elements are found??\\n            ans++;                   // no. of string in vector that have this pefix\\n        }\\n        count=0;        // for again incrementing for other strinngs in vector\\n      }\\n\\nreturn ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for(String w : words)\\n\\t\\t{\\n            if(w.indexOf(pref) == 0){\\n                count++;\\n            } else {\\n                count+= 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803323,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int n=pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length()>=n &&words[i].substring(0,n).equals(pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int n=pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length()>=n &&words[i].substring(0,n).equals(pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803176,
                "title": "swift-1-liner-24-ms-14-8-mb",
                "content": "```\\nclass Solution {\\n    func prefixCount(_ words: [String], _ pref: String) -> Int {\\n        return words.reduce(0, {$0 + ($1.hasPrefix(pref) ? 1 : 0)})\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func prefixCount(_ words: [String], _ pref: String) -> Int {\\n        return words.reduce(0, {$0 + ($1.hasPrefix(pref) ? 1 : 0)})\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802989,
                "title": "c-easy-solution-only-5-line",
                "content": "int prefixCount(vector<string>& words, string pref) {\\n        int c=0; //count of the strings which contained prefix\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0) // if pref found in the string at 0 \\'0--> begin index of string\\'\\n                c++;\\n        }\\n        return c;\\n    }",
                "solutionTags": [],
                "code": "int prefixCount(vector<string>& words, string pref) {\\n        int c=0; //count of the strings which contained prefix\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0) // if pref found in the string at 0 \\'0--> begin index of string\\'\\n                c++;\\n        }\\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1802900,
                "title": "c-solution",
                "content": "bool compare(char* s, char* pref){\\n\\n    char *temp=s;   \\n    if(strlen(pref) > strlen(s))\\n        return false;\\n    \\n    while((*temp == *pref)&& (*pref != \\'\\\\0\\')){\\n        temp ++;pref++;        \\n    }\\n    if(*pref == \\'\\\\0\\')return true;\\nreturn false;\\n}\\n\\n\\nint prefixCount(char ** words, int wordsSize, char * pref){\\n    \\n    int count=0;    \\n    for(int i=0; i <wordsSize;i++){\\n        if(compare(words[i],pref))count++;\\n    }\\n   return count;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "bool compare(char* s, char* pref){\\n\\n    char *temp=s;   \\n    if(strlen(pref) > strlen(s))\\n        return false;\\n    \\n    while((*temp == *pref)&& (*pref != \\'\\\\0\\')){\\n        temp ++;pref++;        \\n    }\\n    if(*pref == \\'\\\\0\\')return true;\\nreturn false;\\n}\\n\\n\\nint prefixCount(char ** words, int wordsSize, char * pref){\\n    \\n    int count=0;    \\n    for(int i=0; i <wordsSize;i++){\\n        if(compare(words[i],pref))count++;\\n    }\\n   return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1802858,
                "title": "very-simple-solution-with-explnation",
                "content": "\\tIst we traverse  then we find the  pref ans should we conatin 0th postion  then ans ++\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int c=0;\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int c=0;\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802840,
                "title": "easy-js-javascript",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    \\n    for (const word of words) {\\n        if (word.slice(0, pref.length) === pref) count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    \\n    for (const word of words) {\\n        if (word.slice(0, pref.length) === pref) count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802793,
                "title": "java-100-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int len = pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length() >= len && words[i].substring(0,len).equals(pref))\\n          {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int len = pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length() >= len && words[i].substring(0,len).equals(pref))\\n          {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1802737,
                "title": "easy-and-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count = 0;\\n       int n = pref.size();\\n       for(string s : words){\\n          if(s.size() >= n){\\n                  if(s.substr(0, n) == pref) count++;\\n          }          \\n       }\\n            return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count = 0;\\n       int n = pref.size();\\n       for(string s : words){\\n          if(s.size() >= n){\\n                  if(s.substr(0, n) == pref) count++;\\n          }          \\n       }\\n            return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802718,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int len = pref.length();\\n        int count = 0;\\n        for(String word : words){\\n            if(word.length() < len)\\n                continue;\\n            if(check(word,pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n    private static boolean check(String word, String pref){\\n        int len = pref.length();\\n        for(int i = 0; i < len; i++){\\n            if(word.charAt(i) != pref.charAt(i))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int len = pref.length();\\n        int count = 0;\\n        for(String word : words){\\n            if(word.length() < len)\\n                continue;\\n            if(check(word,pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n    private static boolean check(String word, String pref){\\n        int len = pref.length();\\n        for(int i = 0; i < len; i++){\\n            if(word.charAt(i) != pref.charAt(i))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802705,
                "title": "c-easy-to-understand-simple-solution",
                "content": "**Do upvote If this helped!!**\\n```\\n    int prefixCount(vector<string>& words, string pref) {\\n        int pre_size = pref.size();\\n        int n = words.size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            string temp = words[i];\\n            int j=0;\\n            \\n            while(j < pre_size)\\n            {\\n                if(temp[j] == pref[j])\\n                {\\n                    j++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            \\n            if(j== pre_size)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int prefixCount(vector<string>& words, string pref) {\\n        int pre_size = pref.size();\\n        int n = words.size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            string temp = words[i];\\n            int j=0;\\n            \\n            while(j < pre_size)\\n            {\\n                if(temp[j] == pref[j])\\n                {\\n                    j++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            \\n            if(j== pre_size)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802702,
                "title": "c-simple-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint ans = 0;\\n\\t\\tint n = pref.size();\\n\\t\\tfor (auto s : words)\\n\\t\\t{\\n\\t\\t\\tif (s.substr(0, n) == pref)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint ans = 0;\\n\\t\\tint n = pref.size();\\n\\t\\tfor (auto s : words)\\n\\t\\t{\\n\\t\\t\\tif (s.substr(0, n) == pref)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802672,
                "title": "cpp-easiset-solution-begineer-friendly",
                "content": "**Apporaoch** \\n* Just Traverse through each and every word.\\n* Find if any substring from starting position and of preifix size matches to prefix.\\n```\\n   int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto i:words){\\n            if(i.substr(0,pref.size())==pref) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto i:words){\\n            if(i.substr(0,pref.size())==pref) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802644,
                "title": "python3-1-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6f8a2c98f0feab59d2e0ec35f928e3ee1d3e4456) for solutions of weekly 282. \\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.startswith(pref) for word in words)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.startswith(pref) for word in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802624,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = words[i];\\n            if (temp.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = words[i];\\n            if (temp.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802623,
                "title": "java-string-startswtih-simple-solution",
                "content": "```\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for (String s : words)\\n        \\tif (s.startsWith(pref))\\n        \\t\\tres++;\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for (String s : words)\\n        \\tif (s.startsWith(pref))\\n        \\t\\tres++;\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802591,
                "title": "easiest-short-sol-99-faster",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if i.startswith(pref) is True:\\n                count+=1         \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if i.startswith(pref) is True:\\n                count+=1         \\n        return count\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1857039,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845553,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865308,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1846487,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1837157,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1835596,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Steps to Make Two Strings Anagram II",
        "question_content": "<p>You are given two strings <code>s</code> and <code>t</code>. In one step, you can append <strong>any character</strong> to either <code>s</code> or <code>t</code>.</p>\n\n<p>Return <em>the minimum number of steps to make </em><code>s</code><em> and </em><code>t</code><em> <strong>anagrams</strong> of each other.</em></p>\n\n<p>An <strong>anagram</strong> of a string is a string that contains the same characters with a different (or the same) ordering.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;<strong><u>lee</u></strong>tco<u><strong>de</strong></u>&quot;, t = &quot;co<u><strong>a</strong></u>t<u><strong>s</strong></u>&quot;\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> \n- In 2 steps, we can append the letters in &quot;as&quot; onto s = &quot;leetcode&quot;, forming s = &quot;leetcode<strong><u>as</u></strong>&quot;.\n- In 5 steps, we can append the letters in &quot;leede&quot; onto t = &quot;coats&quot;, forming t = &quot;coats<u><strong>leede</strong></u>&quot;.\n&quot;leetcodeas&quot; and &quot;coatsleede&quot; are now anagrams of each other.\nWe used a total of 2 + 5 = 7 steps.\nIt can be shown that there is no way to make them anagrams of each other with less than 7 steps.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;night&quot;, t = &quot;thing&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The given strings are already anagrams of each other. Thus, we do not need any further steps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1802438,
                "title": "python3-java-c-counter-o-len-s-len-t",
                "content": "* Count the number of characters in each string \\n* Compare the counts for each character\\n* If the counts of the characters don\\'t match, add the difference of the counts to answer\\n<iframe src=\"https://leetcode.com/playground/TrFoEYxb/shared\" frameBorder=\"0\" width=\"600\" height=\"200\"></iframe>\\n\\nTime complexity: `O(len(s) + (len(t))`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "* Count the number of characters in each string \\n* Compare the counts for each character\\n* If the counts of the characters don\\'t match, add the difference of the counts to answer\\n<iframe src=\"https://leetcode.com/playground/TrFoEYxb/shared\" frameBorder=\"0\" width=\"600\" height=\"200\"></iframe>\\n\\nTime complexity: `O(len(s) + (len(t))`",
                "codeTag": "Unknown"
            },
            {
                "id": 1802780,
                "title": "c-o-n-hashmap",
                "content": "An **anagram** is a word or phrase formed by rearranging the letters of a different word or phrase.\\nSo in the given question we need to count the frequecy of letter which are different.\\n**APPROACH**\\nFirst counted the frequecy of charachters in s and then counted the frequecy of t and in count variable store the mod (mean the positive value) of the difference\\n`\\n\\nint minSteps(string s, string t) {\\n\\t\\tunordered_map<char, int> mp;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n            mp[s[i]]++;\\n        n=t.size();\\n        for(int i=0;i<n;i++)\\n            mp[t[i]]--;\\n        int cnt=0;\\n        for(auto i:mp)\\n            cnt+=abs(i.second);\\n        return cnt;\\n    }`\\n\\t**Time Complexity:** for both the string we are going to every letter once, therefore it is O(N).\\n\\t**Space Complexity:** here we are using unordered_map to store frequecy of every letter in string so at we can have all english letter in the string, therfore it is O(26) or O(1).\\n\\tDo like it if this you in any way!\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "An **anagram** is a word or phrase formed by rearranging the letters of a different word or phrase.\\nSo in the given question we need to count the frequecy of letter which are different.\\n**APPROACH**\\nFirst counted the frequecy of charachters in s and then counted the frequecy of t and in count variable store the mod (mean the positive value) of the difference\\n`\\n\\nint minSteps(string s, string t) {\\n\\t\\tunordered_map<char, int> mp;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n            mp[s[i]]++;\\n        n=t.size();\\n        for(int i=0;i<n;i++)\\n            mp[t[i]]--;\\n        int cnt=0;\\n        for(auto i:mp)\\n            cnt+=abs(i.second);\\n        return cnt;\\n    }`\\n\\t**Time Complexity:** for both the string we are going to every letter once, therefore it is O(N).\\n\\t**Space Complexity:** here we are using unordered_map to store frequecy of every letter in string so at we can have all english letter in the string, therfore it is O(26) or O(1).\\n\\tDo like it if this you in any way!\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1802572,
                "title": "c-easiest-solution",
                "content": "```\\n// The simplest solution one can think is:\\n// Find the number of different characters in both the strings.\\n\\n// I have implemented the same solution but in memory efficient solution\\n\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int count=0;\\n        //take an array of 26 size to store frequency of alphabets\\n        vector<int> arr(26,0);\\n        \\n        \\n        //increment the frequency of character by 1 in the array\\n        for(auto i:s)\\n            arr[i-\\'a\\']++;\\n        \\n        //decrement the frequency of character by 1 in the array\\n        for(auto i:t)\\n            arr[i-\\'a\\']--;\\n        \\n        // Now the array will only store the frequency of characters that are different\\n        for(auto i:arr)\\n            count+=abs(i);\\n        \\n        return count;\\n        \\n        \\n        \\n    }\\n};\\n```\\nPlease **Upvote**, if you liked my solution.\\nDont forget to visit my repo: https://github.com/tarunsahnan/LeetCode-Solutions\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// The simplest solution one can think is:\\n// Find the number of different characters in both the strings.\\n\\n// I have implemented the same solution but in memory efficient solution\\n\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int count=0;\\n        //take an array of 26 size to store frequency of alphabets\\n        vector<int> arr(26,0);\\n        \\n        \\n        //increment the frequency of character by 1 in the array\\n        for(auto i:s)\\n            arr[i-\\'a\\']++;\\n        \\n        //decrement the frequency of character by 1 in the array\\n        for(auto i:t)\\n            arr[i-\\'a\\']--;\\n        \\n        // Now the array will only store the frequency of characters that are different\\n        for(auto i:arr)\\n            count+=abs(i);\\n        \\n        return count;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802471,
                "title": "java-python-3-count-the-difference-w-analysis",
                "content": "**Java**\\n\\nA more readable Java code:\\n```java\\n    public int minSteps(String s, String t) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++cnt[s.charAt(i) - \\'a\\'];\\n       \\t}\\n       \\tfor (int i = 0; i < t.length(); ++i) {\\n            --cnt[t.charAt(i) - \\'a\\'];\\n       \\t}\\n       \\tint minSteps = 0;\\n       \\tfor (int c : cnt) {\\n            minSteps += Math.abs(c);\\n       \\t}\\n       \\treturn minSteps;        \\n    }\\n```\\n\\n----\\n\\n----\\n\\n\\n```java\\n    public int minSteps(String s, String t) {\\n        int[] cnt = new int[26];\\n        s.chars().forEach(c -> ++cnt[c - \\'a\\']);\\n        t.chars().forEach(c -> --cnt[c - \\'a\\']);\\n        return IntStream.of(cnt).map(i -> Math.abs(i)).sum();\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\n\\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt = [0] * 26\\n        for c in s:\\n            cnt[ord(c) - ord(\\'a\\')] += 1\\n        for c in t:\\n            cnt[ord(c) - ord(\\'a\\')] -= 1\\n        return sum(map(abs, cnt))\\n```\\n\\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs, ct = map(Counter, (s, t))\\n        return sum(((cs - ct) + (ct - cs)).values())\\n```\\n**Analysis for above 4 codes:**\\n\\nTime: `O(S + T)`, space: `O(1)` where `T = t.length(), S = s.length()`.",
                "solutionTags": [],
                "code": "```java\\n    public int minSteps(String s, String t) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++cnt[s.charAt(i) - \\'a\\'];\\n       \\t}\\n       \\tfor (int i = 0; i < t.length(); ++i) {\\n            --cnt[t.charAt(i) - \\'a\\'];\\n       \\t}\\n       \\tint minSteps = 0;\\n       \\tfor (int c : cnt) {\\n            minSteps += Math.abs(c);\\n       \\t}\\n       \\treturn minSteps;        \\n    }\\n```\n```java\\n    public int minSteps(String s, String t) {\\n        int[] cnt = new int[26];\\n        s.chars().forEach(c -> ++cnt[c - \\'a\\']);\\n        t.chars().forEach(c -> --cnt[c - \\'a\\']);\\n        return IntStream.of(cnt).map(i -> Math.abs(i)).sum();\\n    }\\n```\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt = [0] * 26\\n        for c in s:\\n            cnt[ord(c) - ord(\\'a\\')] += 1\\n        for c in t:\\n            cnt[ord(c) - ord(\\'a\\')] -= 1\\n        return sum(map(abs, cnt))\\n```\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs, ct = map(Counter, (s, t))\\n        return sum(((cs - ct) + (ct - cs)).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802805,
                "title": "counter",
                "content": "For some reason, I misread the description, and tried to solve another problem.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs, ct = Counter(s), Counter(t)\\n        return sum(cnt for ch, cnt in ((cs - ct) + (ct - cs)).items())\\n```\\n**C++**\\n```cpp\\nint minSteps(string s, string t) {\\n    int cnt[26] = {};\\n    for (char ch : s) \\n        ++cnt[ch - \\'a\\'];\\n    for (char ch : t) \\n        --cnt[ch - \\'a\\'];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int sum, int n){ return sum + abs(n); });\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs, ct = Counter(s), Counter(t)\\n        return sum(cnt for ch, cnt in ((cs - ct) + (ct - cs)).items())\\n```\n```cpp\\nint minSteps(string s, string t) {\\n    int cnt[26] = {};\\n    for (char ch : s) \\n        ++cnt[ch - \\'a\\'];\\n    for (char ch : t) \\n        --cnt[ch - \\'a\\'];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int sum, int n){ return sum + abs(n); });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802652,
                "title": "python3-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6f8a2c98f0feab59d2e0ec35f928e3ee1d3e4456) for solutions of weekly 282. \\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        fs, ft = Counter(s), Counter(t)\\n        return sum((fs-ft).values()) + sum((ft-fs).values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        fs, ft = Counter(s), Counter(t)\\n        return sum((fs-ft).values()) + sum((ft-fs).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802657,
                "title": "c-counting-hashmap-easy-approach",
                "content": "Increment the count of each character in the 1st string.\\nDecrease the count of characters in the 2nd string.\\n    \\n    character from \\'a\\' to \\'z\\' whose count is positive is needed to be added in string 2 and whose count is negative is needed to be added in string 1.\\n    So, the summation of abs(0-(count of character)) for each charatcer from \\'a\\' to \\'z\\' will give the result !!\\n    \\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>freq(26,0);\\n        for(auto i: s)freq[i-\\'a\\']++;\\n        for(auto i: t)freq[i-\\'a\\']--;\\n        int steps=0;\\n        for(int i=0;i<26;i++)steps+=abs(0-freq[i]);\\n        return steps;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>freq(26,0);\\n        for(auto i: s)freq[i-\\'a\\']++;\\n        for(auto i: t)freq[i-\\'a\\']--;\\n        int steps=0;\\n        for(int i=0;i<26;i++)steps+=abs(0-freq[i]);\\n        return steps;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1802576,
                "title": "c-java-counting",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-282/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt[26] = {}, ans = 0;\\n        for (char c : s) cnt[c - \\'a\\']++;\\n        for (char c : t) cnt[c - \\'a\\']--;\\n        for (int n : cnt) ans += abs(n);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n\\n```java\\n// OJ: https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int cnt[] = new int[26], ans = 0;\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (char c : t.toCharArray()) cnt[c - \\'a\\']--;\\n        for (int n : cnt) ans += Math.abs(n);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-282/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt[26] = {}, ans = 0;\\n        for (char c : s) cnt[c - \\'a\\']++;\\n        for (char c : t) cnt[c - \\'a\\']--;\\n        for (int n : cnt) ans += abs(n);\\n        return ans;\\n    }\\n};\\n```\n```java\\n// OJ: https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int cnt[] = new int[26], ans = 0;\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (char c : t.toCharArray()) cnt[c - \\'a\\']--;\\n        for (int n : cnt) ans += Math.abs(n);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297662,
                "title": "easily-understandable-no-need-of-sorting",
                "content": "```\\nclass Solution {\\n    public static int minSteps(String s, String t) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < t.length(); i++) {\\n\\t\\t\\t\\tfreq[t.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tcount += Math.abs(freq[i]);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minSteps(String s, String t) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < t.length(); i++) {\\n\\t\\t\\t\\tfreq[t.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tcount += Math.abs(freq[i]);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802606,
                "title": "c-easy-to-understand-hashmap",
                "content": "\\nGoal: find the minimum numbers of step to make the strings anagram.\\nApproach:\\n```\\nwe need to make all the occurances of a character in both the string equal.\\n          for example:    leetcode        c d eee l o t\\n                          coats         a c         o t  s\\n          so in the first string d eee l are present in the string 1 which is not present in string 2\\n          these 5 character need to be appended to string 2\\n          and similarly string1 doesn\\'t contain a and s which is in string 2.\\n          so these 2 character need to be added.\\n          \\n          from this we can have a array which increases the the value when a character occurs in string 1 and reduces the\\n          value when a character occurs in string 2.\\n\\n          and then we can traverse the array and add the absolute value of all the entries in the array.\\n```\\n\\nCode: \\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt=0;\\n        vector<int> v(26,0);\\n        // for each character in string s we will increment the value present at the index corresponding to the character\\n        for(int i=0;i<s.size();i++)\\n            v[s[i]-\\'a\\']++;\\n        // we will decrement the value for the same\\n        for(int i=0;i<t.size();i++)\\n            v[t[i]-\\'a\\']--;\\n        for(int i=0;i<26;i++)\\n        {\\n            // add the aboslute value of every entry\\n            cnt+=abs(v[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\ntime complexity:  O(n)\\nspace complexity: O(1)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwe need to make all the occurances of a character in both the string equal.\\n          for example:    leetcode        c d eee l o t\\n                          coats         a c         o t  s\\n          so in the first string d eee l are present in the string 1 which is not present in string 2\\n          these 5 character need to be appended to string 2\\n          and similarly string1 doesn\\'t contain a and s which is in string 2.\\n          so these 2 character need to be added.\\n          \\n          from this we can have a array which increases the the value when a character occurs in string 1 and reduces the\\n          value when a character occurs in string 2.\\n\\n          and then we can traverse the array and add the absolute value of all the entries in the array.\\n```\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt=0;\\n        vector<int> v(26,0);\\n        // for each character in string s we will increment the value present at the index corresponding to the character\\n        for(int i=0;i<s.size();i++)\\n            v[s[i]-\\'a\\']++;\\n        // we will decrement the value for the same\\n        for(int i=0;i<t.size();i++)\\n            v[t[i]-\\'a\\']--;\\n        for(int i=0;i<26;i++)\\n        {\\n            // add the aboslute value of every entry\\n            cnt+=abs(v[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802531,
                "title": "javascript-frequency-map",
                "content": "**Solution: Two Frequency Arrays**\\n\\nUse two arrays of size 26 to store the frequency of each character in s and t.\\nReturn the sum of the absolute differences between each sFreq[i] and tFreq[i].\\n\\nn = s.length, m = t.length\\nTime Complexity: O(n + m)\\nSpace Complexity: O(1)\\n\\n```\\nvar minSteps = function(s, t) {\\n  let sFreq = Array(26).fill(0), tFreq = Array(26).fill(0);\\n  for (let char of s) sFreq[char.charCodeAt() - 97]++;\\n  for (let char of t) tFreq[char.charCodeAt() - 97]++;\\n  let ans = 0;\\n  for (let i = 0; i < 26; i++) {\\n    ans += Math.abs(sFreq[i] - tFreq[i]);\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSteps = function(s, t) {\\n  let sFreq = Array(26).fill(0), tFreq = Array(26).fill(0);\\n  for (let char of s) sFreq[char.charCodeAt() - 97]++;\\n  for (let char of t) tFreq[char.charCodeAt() - 97]++;\\n  let ans = 0;\\n  for (let i = 0; i < 26; i++) {\\n    ans += Math.abs(sFreq[i] - tFreq[i]);\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799022,
                "title": "very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arrS = func(s);\\n        int[] arrT = func(t);\\n\\n        int steps = 0;\\n        for(int i = 0; i < arrS.length; i++) {\\n            steps += Math.abs(arrS[i] - arrT[i]);\\n        }\\n        return steps;\\n\\n    }\\n    public int[] func(String s){\\n        int[] arr = new int[26];\\n        for(char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arrS = func(s);\\n        int[] arrT = func(t);\\n\\n        int steps = 0;\\n        for(int i = 0; i < arrS.length; i++) {\\n            steps += Math.abs(arrS[i] - arrT[i]);\\n        }\\n        return steps;\\n\\n    }\\n    public int[] func(String s){\\n        int[] arr = new int[26];\\n        for(char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218306,
                "title": "time-o-n-space-1-c-6line-code-store-frequency-of-each-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v(26,0);\\n        for(auto &i: s)v[i-\\'a\\']++;\\n        for(auto &i: t)v[i-\\'a\\']--;\\n        int ans = 0;\\n        for(auto &i: v)ans += abs(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v(26,0);\\n        for(auto &i: s)v[i-\\'a\\']++;\\n        for(auto &i: t)v[i-\\'a\\']--;\\n        int ans = 0;\\n        for(auto &i: v)ans += abs(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112227,
                "title": "python-easy-solution-using-counter",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848584,
                "title": "very-easy-cpp-solution-using-hashmap",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>v(26,0);\\n        for(auto i:s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto i:t){\\n            v[i-\\'a\\']--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            ans+=abs(v[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>v(26,0);\\n        for(auto i:s){\\n            v[i-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1811018,
                "title": "swift-hashmap-counter",
                "content": "This is the first time I have tried to post something here :D\\n\\nAn **anagram** of a string is a string that contains the same characters with a different (or the same) ordering. The idea is to use a `counter` to keep track the difference of each character in two strings to produce the result.\\n\\n1. Iterate over every character in `s` and increase the counter by 1\\n2. Iterate over every character in `t` and decrease the counter by 1\\n3. Now, the items remaining in `counter` are the difference of each character between `s` and `t`. Let\\'s say `diff` is value of key `c`, we have 3 cases:\\n  - `diff == 0` means the occurences in `s` and `t` are the same --> We don\\'t need to append `c` neither to `s` or `t`\\n  - `diff > 0` means `s` has more character `c` than `t` --> we need to append `diff` times to `t`\\n  - `diff < 0` means `t` has more character `c` than `s` --> we need to append `diff` times to `s`\\n\\n**Swift**\\n```swift\\nclass Solution {\\n  func minSteps(_ s: String, _ t: String) -> Int {\\n    var counter = [Character: Int]()\\n    for c in s {\\n      counter[c, default: 0] += 1 \\n    }\\n    \\n    for c in t {\\n      counter[c, default: 0] -= 1 \\n    }\\n    \\n    var res = 0 \\n    for diff in counter.values {\\n      res += abs(diff)\\n    }\\n    \\n    return res\\n  }\\n} \\n\\n// Time complexity: O(m + n) where m is s.count and n is t.count. \\n// Space complexity: O(26) = O(1) since s and t only consist of lowercase English letters.\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n  func minSteps(_ s: String, _ t: String) -> Int {\\n    var counter = [Character: Int]()\\n    for c in s {\\n      counter[c, default: 0] += 1 \\n    }\\n    \\n    for c in t {\\n      counter[c, default: 0] -= 1 \\n    }\\n    \\n    var res = 0 \\n    for diff in counter.values {\\n      res += abs(diff)\\n    }\\n    \\n    return res\\n  }\\n} \\n\\n// Time complexity: O(m + n) where m is s.count and n is t.count. \\n// Space complexity: O(26) = O(1) since s and t only consist of lowercase English letters.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806796,
                "title": "python3-easy-approach-using-hashmap",
                "content": "### Kindly Upvote if you found the explanation useful.\\n\\nThe approach is pretty simple. \\n1. Create two dictionaries (hashmaps) and count the frequency of every character.\\n2. Initialize a counting variable which will count the characters required to be appended in each of the string.\\n3. First we iterate on hashmap of string `s`:\\n\\t*   For each (key, value) in hashmap of `s`, if the value is greater than or equal to the corresponding value of the character in hashmap of `t`. We simply add the difference of the two values to the variable `count`.\\n4. Then we iterate on hashmap of string `t`:\\n\\t*   For each (key, value) in hashmap of `t`, if the value is greater than or equal to the corresponding value of the character in hashmap of `s`. We simply add the difference of the two values to the variable `count`.\\n5. Finally we return `count` as our final answer.\\n\\n**Code:**\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sMap = dict()\\n        tMap = dict()\\n        \\n        for character in s:\\n            sMap[character] = sMap.get(character, 0) + 1\\n        \\n        for character in t:\\n            tMap[character] = tMap.get(character, 0) + 1\\n            \\n        count = 0\\n        \\n        for key, value in sMap.items():\\n            if value >= tMap.get(key, 0):\\n                count += (value - tMap.get(key, 0))\\n        \\n        for key, value in tMap.items():\\n            if value >= sMap.get(key, 0):\\n                count += (value - sMap.get(key, 0))\\n        \\n        return count\\n```\\n<br>\\n\\nBut, if we observe, we really don\\'t need 2 hashmaps for the same task. The approach is, \\nfor each character in string `s` **increment** the frequency in the hashmap then, \\nfor each character in string `t` **decrement** the frequency in the hashmap. \\nFinally sum up all the (absolute) values in the hashmap.\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        mp = dict()\\n        \\n        for character in s:\\n            mp[character] = mp.get(character, 0) + 1\\n        \\n        for character in t:\\n            mp[character] = mp.get(character, 0) - 1\\n        \\n        count = 0\\n        for key, value in mp.items():\\n            count += abs(value)\\n        \\n        return count\\n```\\n\\n<br>\\n\\nWe can use Counter class from collections, which can count the frequencies at one. \\nThen using a simple comprehension we can count the required difference for each character from the hashmaps and print the sum of those individual differences.\\n\\n```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sCount, tCount = Counter(s), Counter(t)\\n        return sum(abs(sCount[character] - tCount[character]) for character in string.ascii_lowercase)\\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sMap = dict()\\n        tMap = dict()\\n        \\n        for character in s:\\n            sMap[character] = sMap.get(character, 0) + 1\\n        \\n        for character in t:\\n            tMap[character] = tMap.get(character, 0) + 1\\n            \\n        count = 0\\n        \\n        for key, value in sMap.items():\\n            if value >= tMap.get(key, 0):\\n                count += (value - tMap.get(key, 0))\\n        \\n        for key, value in tMap.items():\\n            if value >= sMap.get(key, 0):\\n                count += (value - sMap.get(key, 0))\\n        \\n        return count\\n```\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        mp = dict()\\n        \\n        for character in s:\\n            mp[character] = mp.get(character, 0) + 1\\n        \\n        for character in t:\\n            mp[character] = mp.get(character, 0) - 1\\n        \\n        count = 0\\n        for key, value in mp.items():\\n            count += abs(value)\\n        \\n        return count\\n```\n```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sCount, tCount = Counter(s), Counter(t)\\n        return sum(abs(sCount[character] - tCount[character]) for character in string.ascii_lowercase)\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803049,
                "title": "easy-understandable-freq",
                "content": "```\\nclass Solution {\\n    public static int minSteps(String s, String t) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < t.length(); i++) {\\n\\t\\t\\t\\tfreq[t.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tcount += Math.abs(freq[i]);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minSteps(String s, String t) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < t.length(); i++) {\\n\\t\\t\\t\\tfreq[t.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tcount += Math.abs(freq[i]);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802784,
                "title": "javascript-hashing-170ms-easy-understanding",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar minSteps = function(s1, s2) {\\n    let count = 0;\\n    let a = \\'a\\'.charCodeAt(0);\\n    let char_count = new Array(26).fill(0);\\n     \\n    // Iterate though the String and update count\\n    for(let s of s1)\\n        char_count[s.charCodeAt(0) - a]++;      \\n \\n    for(let s of s2)\\n        char_count[s.charCodeAt(0) - a]--;\\n    \\n    for(let i = 0; i < 26; ++i)\\n        if (char_count[i] !== 0)\\n            count += Math.abs(char_count[i]);\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar minSteps = function(s1, s2) {\\n    let count = 0;\\n    let a = \\'a\\'.charCodeAt(0);\\n    let char_count = new Array(26).fill(0);\\n     \\n    // Iterate though the String and update count\\n    for(let s of s1)\\n        char_count[s.charCodeAt(0) - a]++;      \\n \\n    for(let s of s2)\\n        char_count[s.charCodeAt(0) - a]--;\\n    \\n    for(let i = 0; i < 26; ++i)\\n        if (char_count[i] !== 0)\\n            count += Math.abs(char_count[i]);\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802755,
                "title": "c-brute-force-easy-to-understand",
                "content": "\\n        \\n\\t\\tvector<int> vs(26,0),vt(26,0);\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            vs[s[i] - \\'a\\']++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            vt[t[i] - \\'a\\']++;\\n        }\\n        \\n        int cnt = 0;\\n    \\n        for(int i=0;i<26;i++)\\n        {\\n            cnt += (abs(vs[i] - vt[i]));\\n        }\\n        return cnt;\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n        \\n\\t\\tvector<int> vs(26,0),vt(26,0);\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            vs[s[i] - \\'a\\']++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            vt[t[i] - \\'a\\']++;\\n        }\\n        \\n        int cnt = 0;\\n    \\n        for(int i=0;i<26;i++)\\n        {\\n            cnt += (abs(vs[i] - vt[i]));\\n        }\\n        return cnt;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802736,
                "title": "self-understandable-python-2-methods",
                "content": "**Method 1:**\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        a=Counter(s)\\n        b=Counter(t)\\n        c=(a-b)+(b-a)\\n        \\n        count=0\\n        for i in c:\\n            count+=c[i]\\n        return count\\n```\\n**Method 2:**\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        a=Counter(s)\\n        b=Counter(t)\\n        \\n        count=0\\n        for i in set(s + t):\\n             count+=abs(a[i]-b[i])\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        a=Counter(s)\\n        b=Counter(t)\\n        c=(a-b)+(b-a)\\n        \\n        count=0\\n        for i in c:\\n            count+=c[i]\\n        return count\\n```\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        a=Counter(s)\\n        b=Counter(t)\\n        \\n        count=0\\n        for i in set(s + t):\\n             count+=abs(a[i]-b[i])\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802610,
                "title": "very-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt = 0;\\n        vector<int>freq(26 , 0) , freq1(26 , 0);\\n        for(char ch : s)\\n            freq[ch - \\'a\\']++;\\n        for(char ch : t)\\n            freq1[ch - \\'a\\']++;\\n        for(int i = 0 ; i <26 ; i++)\\n            cnt += abs(freq1[i] - freq[i]);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt = 0;\\n        vector<int>freq(26 , 0) , freq1(26 , 0);\\n        for(char ch : s)\\n            freq[ch - \\'a\\']++;\\n        for(char ch : t)\\n            freq1[ch - \\'a\\']++;\\n        for(int i = 0 ; i <26 ; i++)\\n            cnt += abs(freq1[i] - freq[i]);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802574,
                "title": "c-count-missing-characters-trick-explained",
                "content": "We just need to find the characters that are present in one string but not in another \\nThe trick here is not to find the missing characters for each string instead just subtract the intersection elements from the universal set.\\n\\nSince **(A-B + B-A) = (A union B) - (A int B)**\\n\\n```\\nint minSteps(string s, string t) {\\n        map<char,int> m1,m2;\\n        int ans =0;\\n\\t\\t\\n\\t\\t//count frequency of characters in each string\\n        for(auto i:s){\\n            m1[i]++;\\n        }\\n        for(auto i:t){\\n            m2[i]++;\\n        }\\n        string x = \"abcdefghijklmnopqrstuvwxyz\";\\n\\t\\t\\n\\t\\t//count characters that are present in one string but not in another\\n        for(auto i:x){\\n                ans += abs(m1[i]-m2[i]);\\n        }\\n    \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        map<char,int> m1,m2;\\n        int ans =0;\\n\\t\\t\\n\\t\\t//count frequency of characters in each string\\n        for(auto i:s){\\n            m1[i]++;\\n        }\\n        for(auto i:t){\\n            m2[i]++;\\n        }\\n        string x = \"abcdefghijklmnopqrstuvwxyz\";\\n\\t\\t\\n\\t\\t//count characters that are present in one string but not in another\\n        for(auto i:x){\\n                ans += abs(m1[i]-m2[i]);\\n        }\\n    \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825726,
                "title": "approach-using-single-map-c-implementation",
                "content": "# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL) ;\\n        cout.tie(NULL);\\n        \\n        unordered_map<char, int> m1;\\n        int n = s.size(), m = t.size();\\n\\n        for(int i=0; i<n; i++) m1[s[i]]++;\\n        for(int i=0; i<m; i++) m1[t[i]]--;\\n\\n        int ans = 0;\\n        for(auto it: m1){\\n            ans += abs(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL) ;\\n        cout.tie(NULL);\\n        \\n        unordered_map<char, int> m1;\\n        int n = s.size(), m = t.size();\\n\\n        for(int i=0; i<n; i++) m1[s[i]]++;\\n        for(int i=0; i<m; i++) m1[t[i]]--;\\n\\n        int ans = 0;\\n        for(auto it: m1){\\n            ans += abs(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3712042,
                "title": "5-lines-code-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the frequency of characters in both the string s and t and calculate the **sum of the absolute differences between the character frequencies.**\\n\\n# Complexity\\n- Time complexity:O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int n = s.size(),m = t.size(),ans = 0;\\n        vector<int> v1(26,0),v2(26,0);\\n        for(int i = 0;i<n;i++)  v1[s[i]-\\'a\\']++;\\n        for(int i = 0;i<m;i++)  v2[t[i]-\\'a\\']++;\\n        for(int i = 0;i<26;i++)  ans+=(abs(v1[i]-v2[i]));\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/e1dc8032-a119-4206-90e0-383ec656ec57_1688375760.472194.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int n = s.size(),m = t.size(),ans = 0;\\n        vector<int> v1(26,0),v2(26,0);\\n        for(int i = 0;i<n;i++)  v1[s[i]-\\'a\\']++;\\n        for(int i = 0;i<m;i++)  v2[t[i]-\\'a\\']++;\\n        for(int i = 0;i<26;i++)  ans+=(abs(v1[i]-v2[i]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309103,
                "title": "java-frequency-array-easy",
                "content": "# Intuition:\\nNumber of characters to be appended into one of the strings is the difference of the frequencies of that character in the two strings.\\n\\n---\\n# Steps:\\n- Record the frequencies of the characters in strings `s` and `t`.\\n- Iterate over the frequency arrays and take the absolute difference of the character frequencies and add them to number of operations.\\n---\\n# Code:\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] sFreq = new int[26];\\n        int[] tFreq = new int[26];\\n        for (int i = 0; i < Math.max(s.length(), t.length()); i++) {\\n            if (i < s.length()) sFreq[s.charAt(i) - \\'a\\']++;\\n            if (i < t.length()) tFreq[t.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int ops = 0;\\n        for (int i = 0; i < 26; i++) {\\n            ops += Math.abs(sFreq[i] - tFreq[i]);\\n        }\\n\\n        return ops;\\n    }\\n}\\n```\\n---\\n##### Time complexity: $$O(max(len(s), len(t)) + 26)$$\\n##### Space complexity: $$O(26) => O(1)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] sFreq = new int[26];\\n        int[] tFreq = new int[26];\\n        for (int i = 0; i < Math.max(s.length(), t.length()); i++) {\\n            if (i < s.length()) sFreq[s.charAt(i) - \\'a\\']++;\\n            if (i < t.length()) tFreq[t.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int ops = 0;\\n        for (int i = 0; i < 26; i++) {\\n            ops += Math.abs(sFreq[i] - tFreq[i]);\\n        }\\n\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235478,
                "title": "simple-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int str1[26]={},str2[26]={};\\n        for(int i=0;i<s.size();i++) str1[s[i]-\\'a\\']++;\\n        for(int i=0;i<t.size();i++) str2[t[i]-\\'a\\']++;\\n        int ans=0;\\n        for(int i=0;i<26;i++) ans+=abs(str1[i]-str2[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int str1[26]={},str2[26]={};\\n        for(int i=0;i<s.size();i++) str1[s[i]-\\'a\\']++;\\n        for(int i=0;i<t.size();i++) str2[t[i]-\\'a\\']++;\\n        int ans=0;\\n        for(int i=0;i<26;i++) ans+=abs(str1[i]-str2[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083313,
                "title": "c-4-lines-of-code-single-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>map;\\n        int count=0;\\n        for(auto x:s) map[x]++;\\n        for(auto x:t) map[x]--;\\n        for(auto x:map) count+=abs(x.second);\\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>map;\\n        int count=0;\\n        for(auto x:s) map[x]++;\\n        for(auto x:t) map[x]--;\\n        for(auto x:map) count+=abs(x.second);\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062113,
                "title": "o-m-n-time-using-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int total=s.length()+t.length();\\n        int cnt=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            if(mp.find(t[i])!=mp.end() && mp[t[i]]>0){\\n                cnt++;\\n                mp[t[i]]--;\\n            }\\n        }\\n        return total-(cnt*2);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int total=s.length()+t.length();\\n        int cnt=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            if(mp.find(t[i])!=mp.end() && mp[t[i]]>0){\\n                cnt++;\\n                mp[t[i]]--;\\n            }\\n        }\\n        return total-(cnt*2);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974868,
                "title": "beats-90-easiest-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n    int[]string1=new int[26];\\n    int[]string2=new int[26];\\n\\n    for(int i=0;i<s.length();i++){\\n    \\n    string1[s.charAt(i)-\\'a\\']++;\\n    \\n    }\\n\\n    for(int i=0;i<t.length();i++){\\n\\n    string2[t.charAt(i)-\\'a\\']++;\\n    \\n    }\\n\\n    int count=0;\\n\\n    for(int i=0;i<26;i++){\\n\\n    if(string1[i]<string2[i]){\\n\\n    count+=string2[i]-string1[i];\\n\\n    }\\n    else if(string2[i]<string1[i]){\\n        count+=string1[i]-string2[i];\\n    }\\n\\n    }\\n\\n    return count;\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n    int[]string1=new int[26];\\n    int[]string2=new int[26];\\n\\n    for(int i=0;i<s.length();i++){\\n    \\n    string1[s.charAt(i)-\\'a\\']++;\\n    \\n    }\\n\\n    for(int i=0;i<t.length();i++){\\n\\n    string2[t.charAt(i)-\\'a\\']++;\\n    \\n    }\\n\\n    int count=0;\\n\\n    for(int i=0;i<26;i++){\\n\\n    if(string1[i]<string2[i]){\\n\\n    count+=string2[i]-string1[i];\\n\\n    }\\n    else if(string2[i]<string1[i]){\\n        count+=string1[i]-string2[i];\\n    }\\n\\n    }\\n\\n    return count;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974100,
                "title": "q-2186-accepted-c-used-count-logic-easiest-simple-explained",
                "content": "CRUX\\n1) The elements of same frequency need not to changed.\\n2) Thus, only the complement of intersection need to returned as output\\n\\t s = \"leetcode\", t = \"coats\" Intersection : c t s \\n\\t Other\\'s need to be added.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector <int> v(26,0);\\n        for(char i:s)\\n            v[i-\\'a\\']++;\\n        for(char i:t)\\n            v[i-\\'a\\']--;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++)\\n\\t\\t\\t count+=abs(v[i]);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector <int> v(26,0);\\n        for(char i:s)\\n            v[i-\\'a\\']++;\\n        for(char i:t)\\n            v[i-\\'a\\']--;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++)\\n\\t\\t\\t count+=abs(v[i]);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935182,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int v1[26]={0};\\n        int v2[26]={0};\\n        for(auto &i:s) v1[i-\\'a\\']++;\\n        for(auto &i:t) v2[i-\\'a\\']++;\\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            ans+=abs(v2[i]-v1[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int v1[26]={0};\\n        int v2[26]={0};\\n        for(auto &i:s) v1[i-\\'a\\']++;\\n        for(auto &i:t) v2[i-\\'a\\']++;\\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            ans+=abs(v2[i]-v1[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504506,
                "title": "cpp-o-n-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>v(26,0);\\n        int sum=0;\\n        for(char x:s)\\n            v[x-\\'a\\']++;\\n        for(char x:t)\\n            v[x-\\'a\\']--;\\n        for(int i=0;i<26;i++){\\n            sum+=abs(v[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>v(26,0);\\n        int sum=0;\\n        for(char x:s)\\n            v[x-\\'a\\']++;\\n        for(char x:t)\\n            v[x-\\'a\\']--;\\n        for(int i=0;i<26;i++){\\n            sum+=abs(v[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415115,
                "title": "c-hashing-using-2-vectors-easiest-solution-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n      \\n    vector<int>freq_S(26,0);    // frequency vectors to store frequency of letters in  each string\\n    vector<int>freq_T(26,0); \\n    int result=0;              // final result\\n    \\n     for(auto it:s)            \\n     {\\n       freq_S[it-\\'a\\']++;       // incrementing the vector index using ascii values for s\\n     }\\n      \\n     for(auto it:t)\\n     {\\n        freq_T[it-\\'a\\']++;     // incrementing the vector index using ascii values for s\\n     }\\n      \\n     for(int i=0;i<26;++i)   // taking absolute of difference between 2 frequencies\\n     {\\n        \\n        result+=abs(freq_S[i]-freq_T[i]);     \\n        \\n     }\\n      \\n      return result;   \\n     }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n      \\n    vector<int>freq_S(26,0);    // frequency vectors to store frequency of letters in  each string\\n    vector<int>freq_T(26,0); \\n    int result=0;              // final result\\n    \\n     for(auto it:s)            \\n     {\\n       freq_S[it-\\'a\\']++;       // incrementing the vector index using ascii values for s\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2221318,
                "title": "simple-solution-without-hashing-simple-counting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int i = 0;\\n        int j = 0;\\n        int n = s.size();\\n        int m = t.size();\\n        int count = 0;\\n\\t\\t//creating 2 arrays to count the letters and then simply just the difference between the arrays will give the ans\\n        vector<int>v(26,0), e(26,0);\\n        for(int i = 0 ; i < s.size() ; i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0 ; i < t.size() ; i++){\\n            e[t[i]-\\'a\\']++;\\n        }\\n        for(int i = 0 ; i < 26 ; i++){\\n            count += abs(v[i]-e[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int i = 0;\\n        int j = 0;\\n        int n = s.size();\\n        int m = t.size();\\n        int count = 0;\\n\\t\\t//creating 2 arrays to count the letters and then simply just the difference between the arrays will give the ans\\n        vector<int>v(26,0), e(26,0);\\n        for(int i = 0 ; i < s.size() ; i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0 ; i < t.size() ; i++){\\n            e[t[i]-\\'a\\']++;\\n        }\\n        for(int i = 0 ; i < 26 ; i++){\\n            count += abs(v[i]-e[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179441,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> m;\\n        int c=0;\\n        for(auto& i : s){\\n            m[i]++;\\n        }\\n        for(auto& i : t){\\n            m[i]--;\\n        }\\n        for(auto& itr : m){\\n            c += fabs(itr.second);\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> m;\\n        int c=0;\\n        for(auto& i : s){\\n            m[i]++;\\n        }\\n        for(auto& i : t){\\n            m[i]--;\\n        }\\n        for(auto& itr : m){\\n            c += fabs(itr.second);\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020803,
                "title": "two-fast-solutions-beat-99-and-beat-60",
                "content": "The main idea is to find the differences of value frequency in s and t and sum them up.\\n\\n* Approach 1: find the difference using collections.Count\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count_s, count_t = collections.Counter(s), collections.Counter(t)\\n        difference = (count_s - count_t) + (count_t - count_s)\\n        return sum(difference.values())\\n```\\n* Approach 2: remove the common\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n\\t\\ttotal = len(s) + len(t)\\n\\t\\tfor i in set(s):\\n\\t\\t\\ttotal -= min(s.count(i),t.count(i)) * 2\\n\\t\\treturn total\\n```\\nNote that a common element shows twice in total. \\n\\nApproach 2 is faster and beats 99% in python. The first approach beats 60%.",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count_s, count_t = collections.Counter(s), collections.Counter(t)\\n        difference = (count_s - count_t) + (count_t - count_s)\\n        return sum(difference.values())\\n```\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n\\t\\ttotal = len(s) + len(t)\\n\\t\\tfor i in set(s):\\n\\t\\t\\ttotal -= min(s.count(i),t.count(i)) * 2\\n\\t\\treturn total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848041,
                "title": "c-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int cnt=0;\\n       vector<int>res(26,0);\\n        for(auto x:s1){\\n            res[x-\\'a\\']++;\\n        }\\n        for(auto x:s2){\\n            res[x-\\'a\\']--;       //idea is simple we are discarding the similar words and couting the rest words\\n        }\\n        for(auto x:res){\\n            cnt+=abs(x);\\n        }\\n        return cnt;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int cnt=0;\\n       vector<int>res(26,0);\\n        for(auto x:s1){\\n            res[x-\\'a\\']++;\\n        }\\n        for(auto x:s2){\\n            res[x-\\'a\\']--;       //idea is simple we are discarding the similar words and couting the rest words\\n        }\\n        for(auto x:res){\\n            cnt+=abs(x);\\n        }\\n        return cnt;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1834487,
                "title": "java-pretty-simple-solution-with-constant-space-without-hashmap",
                "content": "***Please upvote if you like the solution!***\\n\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int steps = 0;\\n        \\n        int[] arr = new int[26];\\n        \\n        for(char c: s.toCharArray())\\n            arr[c - \\'a\\']++;\\n        \\n        for(char c: t.toCharArray())\\n            arr[c - \\'a\\']--;\\n        \\n        for(int ch: arr){\\n            steps += Math.abs(ch);\\n        }\\n            \\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int steps = 0;\\n        \\n        int[] arr = new int[26];\\n        \\n        for(char c: s.toCharArray())\\n            arr[c - \\'a\\']++;\\n        \\n        for(char c: t.toCharArray())\\n            arr[c - \\'a\\']--;\\n        \\n        for(int ch: arr){\\n            steps += Math.abs(ch);\\n        }\\n            \\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816872,
                "title": "easy-to-understand-solution-time-o-nlogn-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n\\t// Sort Both the strings.\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        int i = 0, j = 0;\\n        int m = s.size(), n = t.size();\\n        int count = 0;\\n        while (i < m && j < n)\\n        {\\n\\t\\t// If character at i and j are not same increment the counter.\\n            if (s[i] != t[j])\\n            {\\n                count++;\\n            }\\n\\t\\t\\t// In case s[i] != t[j] increment the position of the smaller character.\\n\\t\\t\\t// If s[i] == t[j] increment the position of both the characters.\\n            if (s[i] < t[j])\\n                i++;\\n            else if (s[i] > t[j])\\n                j++;\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n\\t\\t// When one of the string is exausted you\\'ll need all the characters from the remaining string to make them anagram of one another.\\n        if (j < n)\\n            count += n - j;\\n        if (i < m)\\n            count += m - i;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n\\t// Sort Both the strings.\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        int i = 0, j = 0;\\n        int m = s.size(), n = t.size();\\n        int count = 0;\\n        while (i < m && j < n)\\n        {\\n\\t\\t// If character at i and j are not same increment the counter.\\n            if (s[i] != t[j])\\n            {\\n                count++;\\n            }\\n\\t\\t\\t// In case s[i] != t[j] increment the position of the smaller character.\\n\\t\\t\\t// If s[i] == t[j] increment the position of both the characters.\\n            if (s[i] < t[j])\\n                i++;\\n            else if (s[i] > t[j])\\n                j++;\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n\\t\\t// When one of the string is exausted you\\'ll need all the characters from the remaining string to make them anagram of one another.\\n        if (j < n)\\n            count += n - j;\\n        if (i < m)\\n            count += m - i;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814946,
                "title": "python-3-counter-difference-between-counts-beats-91",
                "content": "Find the count for each character in s and t and store in counter arrays.\\nFind the absolute difference between the counts of each character.\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count1 = [0]*26\\n        count2 = [0]*26\\n        for i in s:\\n            count1[ord(i)-ord(\\'a\\')] += 1\\n        for i in t:\\n            count2[ord(i)-ord(\\'a\\')] += 1\\n        \\n        steps = 0\\n        for i in range(26):\\n            steps += abs(count1[i]-count2[i])\\n        \\n        return steps\\n```\\nTime Complexity: O(len(s)+len(t))\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count1 = [0]*26\\n        count2 = [0]*26\\n        for i in s:\\n            count1[ord(i)-ord(\\'a\\')] += 1\\n        for i in t:\\n            count2[ord(i)-ord(\\'a\\')] += 1\\n        \\n        steps = 0\\n        for i in range(26):\\n            steps += abs(count1[i]-count2[i])\\n        \\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808958,
                "title": "c-solution-using-hashmap",
                "content": "smjh\\n```\\n unordered_map<char,int>umap;\\n        \\n        int n = s.length();\\n        int m = t.length();\\n        int count =0;\\n        for(auto it : s){\\n            umap[it]++;\\n        }\\n        for(auto it: t){\\n            umap[it]--;\\n        }\\n        for(auto it:umap){\\n            count +=abs(it.second);\\n        }\\n        return count;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n unordered_map<char,int>umap;\\n        \\n        int n = s.length();\\n        int m = t.length();\\n        int count =0;\\n        for(auto it : s){\\n            umap[it]++;\\n        }\\n        for(auto it: t){\\n            umap[it]--;\\n        }\\n        for(auto it:umap){\\n            count +=abs(it.second);\\n        }\\n        return count;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805793,
                "title": "c-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> c1(26,0), c2(26,0);\\n        \\n        for(auto &x : s)    c1[x-\\'a\\']++;\\n        for(auto &x : t)    c2[x-\\'a\\']++;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<26; i++) ans += abs(c1[i]-c2[i]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> c1(26,0), c2(26,0);\\n        \\n        for(auto &x : s)    c1[x-\\'a\\']++;\\n        for(auto &x : t)    c2[x-\\'a\\']++;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<26; i++) ans += abs(c1[i]-c2[i]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803630,
                "title": "c-o-n-map",
                "content": "//solution\\n\\n\\tclass Solution {\\n\\tpublic :\\n\\t\\tint minSteps(string s, string t) {\\n\\t\\t\\n\\t\\t\\t//creating map and inserting values in it\\n\\t\\t\\tunordered_map<char,int> ss,ts;\\n\\t\\t\\tfor(char c:s)\\n\\t\\t\\t\\tss[c]++;\\n\\t\\t\\tfor(char c:t)\\n\\t\\t\\t\\tts[c]++;\\n\\t\\t\\n\\t\\t\\t// checking for common values and removing their count\\n\\t\\t\\tfor(auto it=t.begin();it!=t.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tss[*it]--;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto it=s.begin();it!=s.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tts[*it]--;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// summation of all the remaining items in both the maps\\n\\t\\t\\tint cs=0,ct=0;\\n\\t\\t\\tfor(auto it=ss.begin();it!=ss.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((it->second)>0)\\n\\t\\t\\t\\t\\tcs+=it->second;\\n\\t\\t\\t} \\n\\t\\t\\tfor(auto it=ts.begin();it!=ts.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((it->second)>0)\\n\\t\\t\\t\\t\\tct+=it->second;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// cs has total values of ss map and ct has total of ts map\\n\\t\\t\\treturn ct+cs;\\n\\t\\t}\\t\\n\\t};\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic :\\n\\t\\tint minSteps(string s, string t) {\\n\\t\\t\\n\\t\\t\\t//creating map and inserting values in it\\n\\t\\t\\tunordered_map<char,int> ss,ts;\\n\\t\\t\\tfor(char c:s)\\n\\t\\t\\t\\tss[c]++;\\n\\t\\t\\tfor(char c:t)\\n\\t\\t\\t\\tts[c]++;\\n\\t\\t\\n\\t\\t\\t// checking for common values and removing their count\\n\\t\\t\\tfor(auto it=t.begin();it!=t.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tss[*it]--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1803608,
                "title": "c-frequency-array-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int sf[26],tf[26]; //frequency arrays for each string\\n        int diff=0; //for storing the number of different characters\\n        \\n        memset(sf,0,sizeof(sf)); //set both arrays to 0 first\\n        memset(tf,0,sizeof(tf));\\n        \\n        for(int i=0;i<s.size();i++) sf[s[i]-\\'a\\']++; //storing frequency of each character in s\\n        for(int i=0;i<t.size();i++) tf[t[i]-\\'a\\']++; //storing frequency of each character in t\\n        \\n        for(int i=0;i<26;i++) \\n            diff+=abs(sf[i]-tf[i]); //store the amount of different characters\\n        \\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int sf[26],tf[26]; //frequency arrays for each string\\n        int diff=0; //for storing the number of different characters\\n        \\n        memset(sf,0,sizeof(sf)); //set both arrays to 0 first\\n        memset(tf,0,sizeof(tf));\\n        \\n        for(int i=0;i<s.size();i++) sf[s[i]-\\'a\\']++; //storing frequency of each character in s\\n        for(int i=0;i<t.size();i++) tf[t[i]-\\'a\\']++; //storing frequency of each character in t\\n        \\n        for(int i=0;i<26;i++) \\n            diff+=abs(sf[i]-tf[i]); //store the amount of different characters\\n        \\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803149,
                "title": "python-solution-counting-o-n",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        table = [0]*26\\n        for ch in s:\\n            table[ord(ch)-97] += 1\\n        for ch in t:\\n            table[ord(ch)-97] -= 1\\n        return sum([abs(i) for i in table])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        table = [0]*26\\n        for ch in s:\\n            table[ord(ch)-97] += 1\\n        for ch in t:\\n            table[ord(ch)-97] -= 1\\n        return sum([abs(i) for i in table])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803004,
                "title": "java-o-n-100ms-faster-runtime-27-no-hashmap",
                "content": "Increment the freq[i] for the elements in string s and decrement the freq[i] for the elements in string t. \\nStore the absolute sum of non zero elements in the frequency map.\\n\\n\\n```\\n public int minSteps(String s, String t) {\\n            \\n        int[] freq1 = new int[26];\\n            for(int i = 0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                \\n                freq1[ch -\\'a\\']++;\\n            }\\n            \\n             for(int i = 0;i<t.length();i++){\\n                char ch = t.charAt(i);\\n                \\n                freq1[ch -\\'a\\']--;\\n            }\\n            int count = 0;\\n            for(int i = 0;i<freq1.length;i++){\\n                count += Math.abs(freq1[i]);\\n            }\\n            return count;\\n        }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n public int minSteps(String s, String t) {\\n            \\n        int[] freq1 = new int[26];\\n            for(int i = 0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                \\n                freq1[ch -\\'a\\']++;\\n            }\\n            \\n             for(int i = 0;i<t.length();i++){\\n                char ch = t.charAt(i);\\n                \\n                freq1[ch -\\'a\\']--;\\n            }\\n            int count = 0;\\n            for(int i = 0;i<freq1.length;i++){\\n                count += Math.abs(freq1[i]);\\n            }\\n            return count;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802973,
                "title": "easy-short-using-map-c",
                "content": "**Minimum Number of Steps to Make Two Strings Anagram II**\\nKeep the frequncy map of charcters of both stings s and t. take the absolut different of frqucncy for each characters in s and t.\\n\\n```\\nint minSteps(string s, string t) {\\n        unordered_map<char,int>mp;\\n        for(auto c:s)\\n        {\\n            mp[c]++;\\n        }\\n        for(auto c:t)\\n        {\\n            mp[c]--;\\n        }\\n        int ans=0;\\n        for(auto m:mp)\\n        {\\n            ans+=abs(m.second);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        unordered_map<char,int>mp;\\n        for(auto c:s)\\n        {\\n            mp[c]++;\\n        }\\n        for(auto c:t)\\n        {\\n            mp[c]--;\\n        }\\n        int ans=0;\\n        for(auto m:mp)\\n        {\\n            ans+=abs(m.second);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802935,
                "title": "c-easy-solution-hashmap-bruceforce-solution",
                "content": "```\\nint minSteps(string s, string t)\\n   {\\n       unordered_map<char,int>mp;\\n       for(int i=0; i<s.size(); i++)\\n       {\\n           mp[s[i]]++;\\n       }\\n       for(int i=0; i<t.size(); i++)\\n       {\\n           mp[t[i]]--;\\n       }\\n       int steps=0;\\n       for(auto x:mp)\\n       {\\n           steps+=abs(x.second);\\n       }\\n       return steps;\\n   }\\n```\\n\\n*If you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)*",
                "solutionTags": [],
                "code": "```\\nint minSteps(string s, string t)\\n   {\\n       unordered_map<char,int>mp;\\n       for(int i=0; i<s.size(); i++)\\n       {\\n           mp[s[i]]++;\\n       }\\n       for(int i=0; i<t.size(); i++)\\n       {\\n           mp[t[i]]--;\\n       }\\n       int steps=0;\\n       for(auto x:mp)\\n       {\\n           steps+=abs(x.second);\\n       }\\n       return steps;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802897,
                "title": "c-easy-o-n-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int a[26]={0};\\n        for(int i=0;i<s.size();i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            a[t[i]-\\'a\\']--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            ans+=abs(a[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Hash Table",
                    "Counting"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int a[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1802835,
                "title": "c-easiest-solution",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int minSteps(string s1, string s2) {\\n        int ans = 0;\\n \\n\\n        int char_count[26];\\n         \\n        for (int i = 0; i < 26; i++)\\n        {\\n            char_count[i] = 0;\\n        }\\n \\n       \\n        for (int i = 0; i < s1.length(); i++)\\n            char_count[s1[i] - \\'a\\']++;\\n \\n      \\n        for (int i = 0; i < s2.length(); i++)\\n        {\\n            char_count[s2[i] - \\'a\\']--;      \\n        }\\n       \\n        for(int i = 0; i < 26; ++i)\\n        {\\n          if(char_count[i] != 0)\\n          {\\n            ans+=abs(char_count[i]);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int minSteps(string s1, string s2) {\\n        int ans = 0;\\n \\n\\n        int char_count[26];\\n         \\n        for (int i = 0; i < 26; i++)\\n        {\\n            char_count[i] = 0;\\n        }\\n \\n       \\n        for (int i = 0; i < s1.length(); i++)\\n            char_count[s1[i] - \\'a\\']++;\\n \\n      \\n        for (int i = 0; i < s2.length(); i++)\\n        {\\n            char_count[s2[i] - \\'a\\']--;      \\n        }\\n       \\n        for(int i = 0; i < 26; ++i)\\n        {\\n          if(char_count[i] != 0)\\n          {\\n            ans+=abs(char_count[i]);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802728,
                "title": "cpp-easiset-solution",
                "content": "**Approach**\\n* Just keep the counter of each and every word and find if how many \\n* Differences are there in both of them.\\n\\n*First Implementation.*\\n```\\nint minSteps(string s, string t) {\\n         vector<int> a(26),b(26);\\n         int ans=0;\\n         for(int i=0;i<s.size();i++) a[s[i]-\\'a\\']++;\\n         for(int i=0;i<t.size();i++) b[t[i]-\\'a\\']++;\\n         for(int i=0;i<26;i++) ans+=abs(a[i]-b[i]);\\n         return ans;\\n    }\\n```\\n*Second Implementation.*\\n\\n```\\n       int ans=0;\\n        unordered_map<int,int> m;\\n        for(auto i:s) m[i]++;\\n        for(auto i:t) m[i]--;\\n        for(auto i:m) ans+=abs(i.second);\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\nint minSteps(string s, string t) {\\n         vector<int> a(26),b(26);\\n         int ans=0;\\n         for(int i=0;i<s.size();i++) a[s[i]-\\'a\\']++;\\n         for(int i=0;i<t.size();i++) b[t[i]-\\'a\\']++;\\n         for(int i=0;i<26;i++) ans+=abs(a[i]-b[i]);\\n         return ans;\\n    }\\n```\n```\\n       int ans=0;\\n        unordered_map<int,int> m;\\n        for(auto i:s) m[i]++;\\n        for(auto i:t) m[i]--;\\n        for(auto i:m) ans+=abs(i.second);\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802593,
                "title": "cpp-short-and-consize-solution",
                "content": "```\\nint minSteps(string s, string t) {\\n        int ans=0;\\n        vector<int> v(26);\\n        for(char c:s)v[c-\\'a\\']++;\\n        for(char c:t)v[c-\\'a\\']--;\\n        for(int i=0;i<26;i++)ans+=abs(v[i]);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        int ans=0;\\n        vector<int> v(26);\\n        for(char c:s)v[c-\\'a\\']++;\\n        for(char c:t)v[c-\\'a\\']--;\\n        for(int i=0;i<26;i++)ans+=abs(v[i]);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802542,
                "title": "c-easy-hash-map-easy-understanding-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n    \\n       int mps[26] = {0}; \\n        int mpt[26] = {0}; \\n        for(int i = 0 ; i< s.length(); i++)\\n        {\\n            mps[s[i] - \\'a\\']++; \\n        }\\n        for(int i =0; i<t.length(); i++)\\n        {\\n            mpt[t[i] -\\'a\\']++; \\n        }\\n        \\n        int count = 0; \\n        for(int i = 0; i<26; i++)\\n        {\\n            count += (abs(mps[i] - mpt[i])); \\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n    \\n       int mps[26] = {0}; \\n        int mpt[26] = {0}; \\n        for(int i = 0 ; i< s.length(); i++)\\n        {\\n            mps[s[i] - \\'a\\']++; \\n        }\\n        for(int i =0; i<t.length(); i++)\\n        {\\n            mpt[t[i] -\\'a\\']++; \\n        }\\n        \\n        int count = 0; \\n        for(int i = 0; i<26; i++)\\n        {\\n            count += (abs(mps[i] - mpt[i])); \\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802503,
                "title": "c-solution-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int  n = s.length(), m = t.length();\\n            \\n            int a[26]={0}, b[26]={0};\\n            int ans = 0;\\n            for(auto it : s)a[it-\\'a\\']++;\\n            for(auto it : t)b[it-\\'a\\']++;\\n            for(int i = 0; i < 26; i++){\\n               ans +=(abs(a[i]-b[i]));\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int  n = s.length(), m = t.length();\\n            \\n            int a[26]={0}, b[26]={0};\\n            int ans = 0;\\n            for(auto it : s)a[it-\\'a\\']++;\\n            for(auto it : t)b[it-\\'a\\']++;\\n            for(int i = 0; i < 26; i++){\\n               ans +=(abs(a[i]-b[i]));\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802464,
                "title": "python3-best-solution",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1,c2=Counter(s),Counter(t)\\n        c=(c1-c2)+(c2-c1)\\n        k=0\\n        for i in c:\\n            k=k+c[i]\\n        return (k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1,c2=Counter(s),Counter(t)\\n        c=(c1-c2)+(c2-c1)\\n        k=0\\n        for i in c:\\n            k=k+c[i]\\n        return (k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054818,
                "title": "easy-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] freq=new int[256];\\n        for(int i=0; i<s.length(); i++){\\n            freq[s.charAt(i)]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            freq[t.charAt(i)]--;\\n        }\\n        int count=0;\\n        for(int i=0; i<256; i++){\\n            count+=Math.abs(freq[i]);\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] freq=new int[256];\\n        for(int i=0; i<s.length(); i++){\\n            freq[s.charAt(i)]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            freq[t.charAt(i)]--;\\n        }\\n        int count=0;\\n        for(int i=0; i<256; i++){\\n            count+=Math.abs(freq[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010254,
                "title": "c-check-out-this-simple-and-clean-solution-beats-96",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> map (26, 0);\\n        int cnt = 0;\\n        for (char ch: s) {map[ch-\\'a\\']++; cnt++;}\\n        for (char ch: t) {\\n            if (map[ch-\\'a\\'] > 0) {map[ch-\\'a\\']--; cnt--;}\\n            else cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> map (26, 0);\\n        int cnt = 0;\\n        for (char ch: s) {map[ch-\\'a\\']++; cnt++;}\\n        for (char ch: t) {\\n            if (map[ch-\\'a\\'] > 0) {map[ch-\\'a\\']--; cnt--;}\\n            else cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592126,
                "title": "use-of-map-o-distinct-elements-in-s-distinct-elements-in-t-beginner-friendly-approach-c",
                "content": "- Approach\\n          Firstly, I create two unordered map(m,n) and declare cnt variable and store those characters in s into m map and store those characters in t into n map.\\n          Now, I firstly traverse m map and I check those elements which is present in both map and add difference of those both maps of that character into cnt variable and if that character is not  present in n map then I add simply frequency in cnt variable.\\n          After traversing of m map I traverse n map and now I add frequency of n map of that character which is not present in m map I mean those character which is present only in n map.\\n          Now, I simply return cnt varible.\\n\\n# Complexity\\n- **Time complexity: O(distinct elements in s * distinct elements in t)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(distinct elements in s) + O( * distinct elements in t)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> m,n;\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int j=0;j<t.size();j++)\\n        {\\n            n[t[j]]++;\\n        }\\n        for(auto i : m)\\n        {\\n            if(n[i.first]>0)\\n            {\\n                cnt+=(max(m[i.first],n[i.first])-min(m[i.first],n[i.first]));\\n            }\\n            else{\\n                cnt+=m[i.first];\\n            }\\n        }\\n        for(auto i : n)\\n        {\\n            if(m[i.first]==0)\\n            {\\n                cnt+=n[i.first];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/565e0f2e-4580-4df7-b629-605123069755_1685778566.6075146.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> m,n;\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int j=0;j<t.size();j++)\\n        {\\n            n[t[j]]++;\\n        }\\n        for(auto i : m)\\n        {\\n            if(n[i.first]>0)\\n            {\\n                cnt+=(max(m[i.first],n[i.first])-min(m[i.first],n[i.first]));\\n            }\\n            else{\\n                cnt+=m[i.first];\\n            }\\n        }\\n        for(auto i : n)\\n        {\\n            if(m[i.first]==0)\\n            {\\n                cnt+=n[i.first];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562633,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int ans = 0;\\n        unordered_map<char, int> mp1;\\n        unordered_map<char, int> mp2;\\n        for(int i=0;i<s.length();i++){\\n            mp1[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            mp2[t[i]]++;\\n        }\\n\\n        for(auto i:mp1){\\n            if(mp2.find(i.first) == mp2.end()){\\n                ans += i.second;\\n            }\\n            else if(mp2[i.first] != i.second){\\n                ans += abs(mp2[i.first] - i.second);\\n                mp2.erase(i.first);\\n            }\\nelse{\\n    mp2.erase(i.first);\\n}\\n        }\\n        for(auto i:mp2){\\n            if(mp1.find(i.first) == mp1.end()){\\n                ans += i.second;\\n            }\\n            else if(mp1[i.first] != i.second){\\n                ans += abs(mp1[i.first] - i.second);\\n                mp1.erase(i.first);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int ans = 0;\\n        unordered_map<char, int> mp1;\\n        unordered_map<char, int> mp2;\\n        for(int i=0;i<s.length();i++){\\n            mp1[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            mp2[t[i]]++;\\n        }\\n\\n        for(auto i:mp1){\\n            if(mp2.find(i.first) == mp2.end()){\\n                ans += i.second;\\n            }\\n            else if(mp2[i.first] != i.second){\\n                ans += abs(mp2[i.first] - i.second);\\n                mp2.erase(i.first);\\n            }\\nelse{\\n    mp2.erase(i.first);\\n}\\n        }\\n        for(auto i:mp2){\\n            if(mp1.find(i.first) == mp1.end()){\\n                ans += i.second;\\n            }\\n            else if(mp1[i.first] != i.second){\\n                ans += abs(mp1[i.first] - i.second);\\n                mp1.erase(i.first);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065001,
                "title": "c-easy-and-short-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int ans=0;\\n        map<char,int>mp1,mp2,temp1,temp2;\\n        for(int i=0;i<s.size();i++){\\n            mp1[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            mp2[t[i]]++;\\n        }\\n        set<char>st;\\n        for(auto it:s)\\n        st.insert(it);\\n         for(auto it:t)\\n        st.insert(it);\\n        \\n        vector<char>v(st.begin(),st.end());\\n        for(int i=0;i<v.size();i++){\\n            ans+=abs(mp1[v[i]]-mp2[v[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int ans=0;\\n        map<char,int>mp1,mp2,temp1,temp2;\\n        for(int i=0;i<s.size();i++){\\n            mp1[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            mp2[t[i]]++;\\n        }\\n        set<char>st;\\n        for(auto it:s)\\n        st.insert(it);\\n         for(auto it:t)\\n        st.insert(it);\\n        \\n        vector<char>v(st.begin(),st.end());\\n        for(int i=0;i<v.size();i++){\\n            ans+=abs(mp1[v[i]]-mp2[v[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996689,
                "title": "cpp-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing maps we can solve the problem easily\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m,m1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            m1[t[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            if(m.find(t[i])!=m.end())\\n            {\\n                m[t[i]]--;\\n                if(m[t[i]]==0)\\n                {\\n                    m.erase(t[i]);\\n                }\\n            }\\n        }\\n        int ans=0,ans1=0;\\n         for(auto it:m)\\n        {\\n            ans+=it.second;\\n        }\\n        cout<<ans<<\" \";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(m1.find(s[i])!=m1.end())\\n            {\\n                m1[s[i]]--;\\n                if(m1[s[i]]==0)\\n                {\\n                    m1.erase(s[i]);\\n                }\\n            }\\n        }\\n        //if(m.size()==0)return 0;\\n        \\n        for(auto it:m1)\\n        {\\n            ans1+=it.second;\\n        }\\n        ans+=ans1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m,m1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            m1[t[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            if(m.find(t[i])!=m.end())\\n            {\\n                m[t[i]]--;\\n                if(m[t[i]]==0)\\n                {\\n                    m.erase(t[i]);\\n                }\\n            }\\n        }\\n        int ans=0,ans1=0;\\n         for(auto it:m)\\n        {\\n            ans+=it.second;\\n        }\\n        cout<<ans<<\" \";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(m1.find(s[i])!=m1.end())\\n            {\\n                m1[s[i]]--;\\n                if(m1[s[i]]==0)\\n                {\\n                    m1.erase(s[i]);\\n                }\\n            }\\n        }\\n        //if(m.size()==0)return 0;\\n        \\n        for(auto it:m1)\\n        {\\n            ans1+=it.second;\\n        }\\n        ans+=ans1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2642786,
                "title": "c-very-easy-soln-hashmap",
                "content": "```\\n//TC -> O(max(len(s),len(t)))\\nint minSteps(string s, string t) {\\n        int ans = 0;\\n        unordered_map<char,int> m;\\n\\t\\t//Just map all the characters\\n        for(auto i:s) m[i]++;\\n        for(auto i:t) m[i]--;\\n\\t\\t//Retrieve the absolute value stored in the mapping\\n        for(auto j:m){\\n            ans+=abs(j.second);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//TC -> O(max(len(s),len(t)))\\nint minSteps(string s, string t) {\\n        int ans = 0;\\n        unordered_map<char,int> m;\\n\\t\\t//Just map all the characters\\n        for(auto i:s) m[i]++;\\n        for(auto i:t) m[i]--;\\n\\t\\t//Retrieve the absolute value stored in the mapping\\n        for(auto j:m){\\n            ans+=abs(j.second);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626910,
                "title": "c-hash-table-o-max-len-s-len-t-easy-and-fastest",
                "content": "```\\nint minSteps(string s, string t) {\\n        int steps=0;\\n        vector<int>v(26,0);\\n        for(int i=0;i<size(s);i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<size(t);i++){\\n            v[t[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<size(v);i++){\\n            steps+=abs(v[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        int steps=0;\\n        vector<int>v(26,0);\\n        for(int i=0;i<size(s);i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<size(t);i++){\\n            v[t[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<size(v);i++){\\n            steps+=abs(v[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563601,
                "title": "simplest-solution-using-hashmap-o-n",
                "content": "**PLEASE UPVOTE \\nIF YOU FIND THIS HELPFUL**\\n\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       unordered_map<char,pair<int,int>> hash;\\n        int count=0;\\n        for(auto i:s)\\n            hash[i].first++;\\n        for(auto i:t)\\n            hash[i].second++;\\n        for(auto it:hash)\\n            count+=abs(it.second.second-it.second.first);\\n            return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       unordered_map<char,pair<int,int>> hash;\\n        int count=0;\\n        for(auto i:s)\\n            hash[i].first++;\\n        for(auto i:t)\\n            hash[i].second++;\\n        for(auto it:hash)\\n            count+=abs(it.second.second-it.second.first);\\n            return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543370,
                "title": "c-simple-o-n-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        int n=s.length();\\n        int m=t.length();\\n        for(int i=0;i<n;i++){\\n            v1[s[i]-97]++;\\n        }\\n        for(int i=0;i<m;i++){\\n            v2[t[i]-97]++;\\n        }\\n        int commonchar=0;\\n        for(int i=0;i<26;i++){\\n            commonchar+=min(v1[i],v2[i]);\\n        }\\n        return (n+m)-2*commonchar;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        int n=s.length();\\n        int m=t.length();\\n        for(int i=0;i<n;i++){\\n            v1[s[i]-97]++;\\n        }\\n        for(int i=0;i<m;i++){\\n            v2[t[i]-97]++;\\n        }\\n        int commonchar=0;\\n        for(int i=0;i<26;i++){\\n            commonchar+=min(v1[i],v2[i]);\\n        }\\n        return (n+m)-2*commonchar;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519197,
                "title": "python-2-liner-faster-than-95",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        ctrS, ctrT = Counter(s), Counter(t)\\n        return sum((ctrS - ctrT).values()) + sum((ctrT - ctrS).values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        ctrS, ctrT = Counter(s), Counter(t)\\n        return sum((ctrS - ctrT).values()) + sum((ctrT - ctrS).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514404,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n     int[] sCharCount = new int[26];\\n     int[] tCharCount = new int[26];\\n     for(int i = 0; i < s.length(); i++) {\\n         sCharCount[s.charAt(i) - \\'a\\']+=1;\\n     } \\n     for(int i = 0; i < t.length(); i++) {\\n         tCharCount[t.charAt(i) - \\'a\\']+=1;\\n     }  \\n\\n        int count = 0;\\n     for(int i = 0; i < 26; i++) {\\n         count+=Math.abs(tCharCount[i]-sCharCount[i]);\\n     }   \\n        return count; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n     int[] sCharCount = new int[26];\\n     int[] tCharCount = new int[26];\\n     for(int i = 0; i < s.length(); i++) {\\n         sCharCount[s.charAt(i) - \\'a\\']+=1;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2458230,
                "title": "c-accepted-best-approach-with-good-explanation-easy-to-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it!!***\\n\\n**Approach:**\\n1. Take a unordered map.\\n2. Take a loop for first string and increment by 1 for each character specific in map\\n3. Similarly take a loop for second string and decrement by 1 for each character specific in map.\\n4. At last return absolute count of all char in mp.\\n\\n**~Time Complexity: O(s.size())+O(t.size())+O(K) k=total no. of char used in string**\\n\\n**~Space Complexity: O(K) k=total no. of char used in string**\\n* **Reason:** we are using unordered map.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            mp[t[i]]--;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            count+=abs(x.second);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            mp[t[i]]--;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            count+=abs(x.second);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242933,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        for(char ch:s.toCharArray()) \\n            hmap.put(ch,hmap.getOrDefault(ch,0)+1);\\n        for(char ch:t.toCharArray())\\n            hmap.put(ch,hmap.getOrDefault(ch,0)-1);\\n        int count=0;\\n        for(char key:hmap.keySet())\\n            if(hmap.get(key)!=0)\\n                count+=(Math.abs(hmap.get(key)));\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        for(char ch:s.toCharArray()) \\n            hmap.put(ch,hmap.getOrDefault(ch,0)+1);\\n        for(char ch:t.toCharArray())\\n            hmap.put(ch,hmap.getOrDefault(ch,0)-1);\\n        int count=0;\\n        for(char key:hmap.keySet())\\n            if(hmap.get(key)!=0)\\n                count+=(Math.abs(hmap.get(key)));\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2219319,
                "title": "very-easy-solution",
                "content": "```\\n int minSteps(string s, string t) {\\n        \\n       vector<int>freq(26,0),freq1(26,0);\\n        \\n        for(auto x : s) freq[x-\\'a\\']++;\\n        \\n        for(auto x : t) freq[x-\\'a\\']--;\\n        \\n        \\n        for(auto x : t) freq1[x-\\'a\\']++;\\n        \\n        for(auto x : s) freq1[x-\\'a\\']--;\\n        \\n        int sum=0;\\n        \\n        for(auto x : freq) if(x>0) sum+=x;\\n        \\n        for(auto x : freq1) if(x>0) sum+=x;\\n        \\n        return sum;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int minSteps(string s, string t) {\\n        \\n       vector<int>freq(26,0),freq1(26,0);\\n        \\n        for(auto x : s) freq[x-\\'a\\']++;\\n        \\n        for(auto x : t) freq[x-\\'a\\']--;\\n        \\n        \\n        for(auto x : t) freq1[x-\\'a\\']++;\\n        \\n        for(auto x : s) freq1[x-\\'a\\']--;\\n        \\n        int sum=0;\\n        \\n        for(auto x : freq) if(x>0) sum+=x;\\n        \\n        for(auto x : freq1) if(x>0) sum+=x;\\n        \\n        return sum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137921,
                "title": "python-counterrrrrr-2-liner",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        f,g=Counter(s),Counter(t)\\n        return sum(abs(g[i]-f[i]) for i in set(f.keys()).union(g.keys()))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        f,g=Counter(s),Counter(t)\\n        return sum(abs(g[i]-f[i]) for i in set(f.keys()).union(g.keys()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127187,
                "title": "java-solution-faster-than-100-easy-solution-without-hashmap",
                "content": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n        for (char ch : s.toCharArray()) count[ch - \\'a\\']++;\\n        for (char ch : t.toCharArray()) count[ch - \\'a\\']--;\\n        int ans = 0;\\n        for (int i = 0; i < 26; i++) ans += Math.abs(count[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n        for (char ch : s.toCharArray()) count[ch - \\'a\\']++;\\n        for (char ch : t.toCharArray()) count[ch - \\'a\\']--;\\n        int ans = 0;\\n        for (int i = 0; i < 26; i++) ans += Math.abs(count[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061604,
                "title": "java-solution-o-math-max-len-s-len-t",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n        int result = 0;\\n        int i = 0,j = 0;\\n        while( i < s.length() || j < t.length()){\\n            if(i < s.length()){\\n                count[s.charAt(i++) -\\'a\\']++;\\n            }\\n            if(j < t.length()){\\n                count[t.charAt(j++) - \\'a\\']--;\\n            }\\n        }\\n        for(i = 0; i < 26; i++){\\n            result += Math.abs(count[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n        int result = 0;\\n        int i = 0,j = 0;\\n        while( i < s.length() || j < t.length()){\\n            if(i < s.length()){\\n                count[s.charAt(i++) -\\'a\\']++;\\n            }\\n            if(j < t.length()){\\n                count[t.charAt(j++) - \\'a\\']--;\\n            }\\n        }\\n        for(i = 0; i < 26; i++){\\n            result += Math.abs(count[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988385,
                "title": "simple-counting-exactly-as-per-hints-c-java-and-python",
                "content": "**C++**\\n```\\nclass Solution {\\nprivate:\\n    int* getFreq(string s){\\n        int* count = new int[26];\\n        int i;\\n        \\n        for(char &ch : s){\\n            count[ch - \\'a\\']++;\\n        }\\n        \\n        return count;\\n    }\\n\\t\\npublic:\\n    int minSteps(string s, string t) {\\n        int* c1 = getFreq(s);\\n        int* c2 = getFreq(t);\\n        \\n        int total = 0;\\n        for(int i = 0; i < 26; i++){\\n            total += abs(c1[i] - c2[i]);\\n        }\\n        \\n        return total;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] c1 = getFreq(s);\\n        int[] c2 = getFreq(t);\\n        int total = 0;\\n        for(int i = 0; i < 26; i++){\\n            total += Math.abs(c1[i] - c2[i]);\\n        }\\n        \\n        return total;\\n    }\\n    \\n    private int[] getFreq(String s){\\n        int i, length = s.length();\\n        int[] count = new int[26];\\n        \\n        for(i = 0; i < length; i++){\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def getFreq(self, word):\\n        count = [0]*26\\n        \\n        for character in word:\\n            count[ord(character) - ord(\\'a\\')] += 1\\n        \\n        return count\\n    \\n    def minSteps(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n        c1 = self.getFreq(s)\\n        c2 = self.getFreq(t)\\n        total = 0\\n        \\n        for i in range(26):\\n            total += abs(c1[i] - c2[i])\\n    \\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int* getFreq(string s){\\n        int* count = new int[26];\\n        int i;\\n        \\n        for(char &ch : s){\\n            count[ch - \\'a\\']++;\\n        }\\n        \\n        return count;\\n    }\\n\\t\\npublic:\\n    int minSteps(string s, string t) {\\n        int* c1 = getFreq(s);\\n        int* c2 = getFreq(t);\\n        \\n        int total = 0;\\n        for(int i = 0; i < 26; i++){\\n            total += abs(c1[i] - c2[i]);\\n        }\\n        \\n        return total;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] c1 = getFreq(s);\\n        int[] c2 = getFreq(t);\\n        int total = 0;\\n        for(int i = 0; i < 26; i++){\\n            total += Math.abs(c1[i] - c2[i]);\\n        }\\n        \\n        return total;\\n    }\\n    \\n    private int[] getFreq(String s){\\n        int i, length = s.length();\\n        int[] count = new int[26];\\n        \\n        for(i = 0; i < length; i++){\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def getFreq(self, word):\\n        count = [0]*26\\n        \\n        for character in word:\\n            count[ord(character) - ord(\\'a\\')] += 1\\n        \\n        return count\\n    \\n    def minSteps(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n        c1 = self.getFreq(s)\\n        c2 = self.getFreq(t)\\n        total = 0\\n        \\n        for i in range(26):\\n            total += abs(c1[i] - c2[i])\\n    \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968719,
                "title": "java-frequency-method-easy-90-beat",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] freqCount = new int[26];\\n        int answer = 0;\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter-\\'a\\']++;\\n        }\\n        for(char letter: t.toCharArray()) {\\n            freqCount[letter-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(freqCount[i] != 0) {\\n                answer += Math.abs(freqCount[i]);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] freqCount = new int[26];\\n        int answer = 0;\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter-\\'a\\']++;\\n        }\\n        for(char letter: t.toCharArray()) {\\n            freqCount[letter-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(freqCount[i] != 0) {\\n                answer += Math.abs(freqCount[i]);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841302,
                "title": "python-very-easy-solution-using-counter",
                "content": "# if you like the solution, Please upvote!!\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\tcommon = Counter(s) & Counter(t)\\n\\t\\t\\tcount = sum(common.values())\\n\\n\\t\\t\\treturn (len(s) - count) + (len(t) - count) \\n\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# if you like the solution, Please upvote!!\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\tcommon = Counter(s) & Counter(t)\\n\\t\\t\\tcount = sum(common.values())\\n\\n\\t\\t\\treturn (len(s) - count) + (len(t) - count) \\n\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1836256,
                "title": "best-easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v(26,0);\\n        for(char i: s) \\n            v[i-\\'a\\']++;\\n        for(char i: t) \\n            v[i-\\'a\\']--;\\n        \\n        int count=0;\\n        for(int i=0; i<26; i++)\\n            count+=abs(v[i]);\\n        return count;\\n    }\\n};\\n\\n//pls upvote if u find the solution helpful....!! Thanks..!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v(26,0);\\n        for(char i: s) \\n            v[i-\\'a\\']++;\\n        for(char i: t) \\n            v[i-\\'a\\']--;\\n        \\n        int count=0;\\n        for(int i=0; i<26; i++)\\n            count+=abs(v[i]);\\n        return count;\\n    }\\n};\\n\\n//pls upvote if u find the solution helpful....!! Thanks..!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819613,
                "title": "c-frequency-array-easy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count=0;\\n        vector<int> sf(26,0);\\n        vector<int> tf(26,0);\\n        for(auto it:s)\\n            sf[it-\\'a\\']++; // count the freq of characters in s.\\n        for(auto it:t)\\n            tf[it-\\'a\\']++; // count the freq of characters in s.\\n        for(int i=0;i<26;i++){\\n            count+=abs(sf[i]-tf[i]); \\n            \\n            /* minimum count will be the total difference of frequency present in either of string\\n            eg in \"arjun\" & \"aryan\" or the same elements will cancel out each other and rest all will\\n            be returned.\\n            */\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count=0;\\n        vector<int> sf(26,0);\\n        vector<int> tf(26,0);\\n        for(auto it:s)\\n            sf[it-\\'a\\']++; // count the freq of characters in s.\\n        for(auto it:t)\\n            tf[it-\\'a\\']++; // count the freq of characters in s.\\n        for(int i=0;i<26;i++){\\n            count+=abs(sf[i]-tf[i]); \\n            \\n            /* minimum count will be the total difference of frequency present in either of string\\n            eg in \"arjun\" & \"aryan\" or the same elements will cancel out each other and rest all will\\n            be returned.\\n            */\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816932,
                "title": "c-easiest-implementation",
                "content": "```\\nint minSteps(string s, string t) \\n    {\\n        unordered_map<int, int> mp;\\n        for(auto ch:s)\\n            mp[ch]++;\\n        for(auto ch:t)\\n            mp[ch]--;\\n        int res=0;\\n        for(auto it:mp)\\n            res+=abs(it.second);\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minSteps(string s, string t) \\n    {\\n        unordered_map<int, int> mp;\\n        for(auto ch:s)\\n            mp[ch]++;\\n        for(auto ch:t)\\n            mp[ch]--;\\n        int res=0;\\n        for(auto it:mp)\\n            res+=abs(it.second);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816817,
                "title": "c-hashmap-solution-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        \\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            v1[s[i]-\\'a\\']++;\\n            \\n        }\\n        \\n        for(int i=0;i<t.size();i++){\\n            v2[t[i]-\\'a\\']++;\\n            \\n        }\\n        \\n        \\n        \\n        int count_1 =0 ;\\n        int count_2 = 0;\\n        \\n        \\n        unordered_map<char,int> m1;\\n        \\n        for(int i=0;i<t.size();i++){\\n           \\n            if(m1[t[i]]==0){\\n               \\n               int diff = (v2[t[i]-\\'a\\'] - v1[t[i]-\\'a\\']); \\n               if(diff<0) continue; \\n               count_1 += diff;\\n                \\n              \\n               v1[t[i]-\\'a\\'] += diff; \\n              \\n               \\n               m1[t[i]]++; \\n            }\\n            \\n        }\\n        \\n        \\n       \\n        unordered_map<char,int> m2;\\n        for(int i=0;i<s.size();i++){\\n            if(m2[s[i]]==0){\\n                count_2 += (v1[s[i]-\\'a\\'] - v2[s[i]-\\'a\\']);\\n                m2[s[i]]++;\\n            }\\n            \\n        }\\n        \\n\\n           \\n\\n        \\n        return count_1 + count_2;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        \\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            v1[s[i]-\\'a\\']++;\\n            \\n        }\\n        \\n        for(int i=0;i<t.size();i++){\\n            v2[t[i]-\\'a\\']++;\\n            \\n        }\\n        \\n        \\n        \\n        int count_1 =0 ;\\n        int count_2 = 0;\\n        \\n        \\n        unordered_map<char,int> m1;\\n        \\n        for(int i=0;i<t.size();i++){\\n           \\n            if(m1[t[i]]==0){\\n               \\n               int diff = (v2[t[i]-\\'a\\'] - v1[t[i]-\\'a\\']); \\n               if(diff<0) continue; \\n               count_1 += diff;\\n                \\n              \\n               v1[t[i]-\\'a\\'] += diff; \\n              \\n               \\n               m1[t[i]]++; \\n            }\\n            \\n        }\\n        \\n        \\n       \\n        unordered_map<char,int> m2;\\n        for(int i=0;i<s.size();i++){\\n            if(m2[s[i]]==0){\\n                count_2 += (v1[s[i]-\\'a\\'] - v2[s[i]-\\'a\\']);\\n                m2[s[i]]++;\\n            }\\n            \\n        }\\n        \\n\\n           \\n\\n        \\n        return count_1 + count_2;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816320,
                "title": "c-hashmap",
                "content": "```\\nint minSteps(string s, string t) {\\n        vector<int>hash1(26, 0), hash2(26,0);\\n        for(int i=0; i<s.size(); i++){\\n            hash1[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.size(); i++){\\n            hash2[t[i]-\\'a\\']++;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(hash1[i]-hash2[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        vector<int>hash1(26, 0), hash2(26,0);\\n        for(int i=0; i<s.size(); i++){\\n            hash1[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.size(); i++){\\n            hash2[t[i]-\\'a\\']++;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(hash1[i]-hash2[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814340,
                "title": "javascript-easy-to-understand-detailed-explanation-and-optimization",
                "content": "## CORE STRATEGY\\n\\nFirst, according to the description of the problem, an anagram could be in any order. This is a key point, which means we just need to care about the frequency of char.\\n\\nThen, let\\'s have these variables:\\n- let the same part between `s` and `t` be `same`\\n- let the special chars of `s` be `diffS`\\n- let the special chars of `t` be `diffT`\\n- let the final shortest anagram be `target`\\n\\nSo, we could have:\\n- `s = diffS + same`\\n- `t = diffT + same`\\n- `target = same + diffS + diffT`\\n\\nFinally, for what we need `(target - s) + (target - t)`, it\\'s `((same + diffS + diffT) - (diffS + same)) + ((same + diffS + diffT) - (diffT + same)) = diffT + diffS = (t - same) + (s - same) = t + s - 2 * same`, which means we only need to find the length of same chars in `s` and `t`.\\n\\nAbout how to do the counting of char frequency, try hashtable. You can do it! :P\\n\\n## SOLUTION\\n\\nHere\\'s a sample code from me (244ms):\\n\\n```js\\nconst minSteps = (s, t) => {\\n  const freq = {};\\n  let bothHave = 0;\\n\\n  for (const c of s) {\\n    freq[c] = (freq[c] || 0) + 1;\\n  }\\n  for (const c of t) {\\n    if (!freq[c]) continue;\\n    --freq[c];\\n    ++bothHave;\\n  }\\n\\n  return s.length + t.length - bothHave * 2;\\n};\\n```\\n\\n## OPTIMIZATION\\n\\nHere could be an optimization. Since what we need to deal with are only lowercase English letters, so we don\\'t really need a real hashtable, we could use a fixed-length uint array to make it faster.\\n\\nHere\\'s a sample code from me (84ms):\\n\\n```js\\nconst minSteps = (s, t) => {\\n  const freq = new Uint16Array(26);\\n  const BASE_CODE = 97;\\n  let bothHave = 0;\\n\\n  for (let i = 0; i < s.length; ++i) {\\n    ++freq[s.charCodeAt(i) - BASE_CODE];\\n  }\\n  for (let i = 0; i < t.length; ++i) {\\n    const code = t.charCodeAt(i) - BASE_CODE;\\n    freq[code] && ++bothHave && --freq[code];\\n  }\\n\\n  return s.length + t.length - (bothHave << 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst minSteps = (s, t) => {\\n  const freq = {};\\n  let bothHave = 0;\\n\\n  for (const c of s) {\\n    freq[c] = (freq[c] || 0) + 1;\\n  }\\n  for (const c of t) {\\n    if (!freq[c]) continue;\\n    --freq[c];\\n    ++bothHave;\\n  }\\n\\n  return s.length + t.length - bothHave * 2;\\n};\\n```\n```js\\nconst minSteps = (s, t) => {\\n  const freq = new Uint16Array(26);\\n  const BASE_CODE = 97;\\n  let bothHave = 0;\\n\\n  for (let i = 0; i < s.length; ++i) {\\n    ++freq[s.charCodeAt(i) - BASE_CODE];\\n  }\\n  for (let i = 0; i < t.length; ++i) {\\n    const code = t.charCodeAt(i) - BASE_CODE;\\n    freq[code] && ++bothHave && --freq[code];\\n  }\\n\\n  return s.length + t.length - (bothHave << 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809756,
                "title": "hashmap-optimised-solution-clean-and-easy-to-understand",
                "content": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n        s_dict = {}\\n        t_dict = {}\\n\\n        for i in s:\\n            if i not in s_dict:\\n                s_dict[i] = 0\\n            s_dict[i] += 1\\n\\n        for i in t:\\n            if i not in t_dict:\\n                t_dict[i] = 0\\n            t_dict[i] += 1\\n\\n        common = 0\\n        for i in s_dict:\\n            if i in t_dict:\\n                common += min(s_dict[i], t_dict[i])\\n\\n        return len(s)+len(t) - 2 * common\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n        s_dict = {}\\n        t_dict = {}\\n\\n        for i in s:\\n            if i not in s_dict:\\n                s_dict[i] = 0\\n            s_dict[i] += 1\\n\\n        for i in t:\\n            if i not in t_dict:\\n                t_dict[i] = 0\\n            t_dict[i] += 1\\n\\n        common = 0\\n        for i in s_dict:\\n            if i in t_dict:\\n                common += min(s_dict[i], t_dict[i])\\n\\n        return len(s)+len(t) - 2 * common\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1809502,
                "title": "simple-c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char , int>mp;\\n        \\n        for(int i = 0 ; i < s.size() ; i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        for(int i = 0 ; i < t.size() ; i++){\\n            mp[t[i]]--;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto value : mp){\\n            if(value.second != 0){\\n                ans += abs(value.second);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char , int>mp;\\n        \\n        for(int i = 0 ; i < s.size() ; i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        for(int i = 0 ; i < t.size() ; i++){\\n            mp[t[i]]--;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto value : mp){\\n            if(value.second != 0){\\n                ans += abs(value.second);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806664,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n     int freq[26]={0};\\n        for(char &c:s)\\n            freq[c-\\'a\\']++;\\n        for(char &d:t)\\n            freq[d-\\'a\\']--;\\n        int ans=0;\\n        for(int i:freq)\\n            ans+=abs(i);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n     int freq[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1804941,
                "title": "java-using-frequency-array-counter-o-length-s-o-length-t",
                "content": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int freq[] = new int[26];\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            freq[ch - \\'a\\']++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            char ch = t.charAt(i);\\n            freq[ch - \\'a\\']--;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++) {\\n            count += Math.abs(freq[i]);\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int freq[] = new int[26];\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            freq[ch - \\'a\\']++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            char ch = t.charAt(i);\\n            freq[ch - \\'a\\']--;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++) {\\n            count += Math.abs(freq[i]);\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804933,
                "title": "python-easy-solution-hashmap-o-n",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        hashS = {}\\n        hashT = {}\\n        count = 0\\n        \\n        for i in s:\\n            if i in hashS:\\n                hashS[i] += 1\\n            else:\\n                hashS[i] = 1\\n            \\n        for i in t:\\n            if i in hashT:\\n                hashT[i] += 1\\n            else:\\n                hashT[i] = 1\\n        \\n        for ind, val in hashT.items():\\n            if ind in hashS:\\n                if val == hashS[ind]:\\n                    hashS[ind] = 0\\n                    continue\\n                else:\\n                    count += abs(val-hashS[ind])\\n                    hashS[ind] = 0   \\n            else:\\n                count += val\\n        \\n        \\n        for val in hashS.values():\\n            count += val\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        hashS = {}\\n        hashT = {}\\n        count = 0\\n        \\n        for i in s:\\n            if i in hashS:\\n                hashS[i] += 1\\n            else:\\n                hashS[i] = 1\\n            \\n        for i in t:\\n            if i in hashT:\\n                hashT[i] += 1\\n            else:\\n                hashT[i] = 1\\n        \\n        for ind, val in hashT.items():\\n            if ind in hashS:\\n                if val == hashS[ind]:\\n                    hashS[ind] = 0\\n                    continue\\n                else:\\n                    count += abs(val-hashS[ind])\\n                    hashS[ind] = 0   \\n            else:\\n                count += val\\n        \\n        \\n        for val in hashS.values():\\n            count += val\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804915,
                "title": "c-easy-understanding-o-n",
                "content": "**class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int freq[26]={0};\\n        \\n        for(auto it : s)// add the count of characters of s in freq\\n            freq[it-\\'a\\']++;\\n        \\n        for(auto it: t)// delete the count of characters of t in freq\\n            freq[it-\\'a\\']--;\\n        \\n        int c=0;\\n        // now count the remaining characters in freq which is needed \\n        // to make both strings anagram\\n        for(int i=0; i<26; i++)\\n            c+= abs(freq[i]);\\n        \\n        return c;\\n    }\\n};**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int freq[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1804610,
                "title": "c-o-n-100-faster-solution",
                "content": "class Solution {\\npublic:\\n\\n    int minSteps(string s, string t) {\\n        int sa[26]={0};\\n        int ta[26]={0};\\n      \\n        for(int i=0;i<s.length();i++)\\n            sa[s[i]-\\'a\\']++;\\n        for(int i=0;i<t.length();i++)\\n            ta[t[i]-\\'a\\']++;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++){\\n            count+=abs(sa[i]-ta[i]);\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int minSteps(string s, string t) {\\n        int sa[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1804377,
                "title": "using-hashmap-java-solution-o-n-tc",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n     int l1=s.length();\\n        int l2=t.length();\\n        int c1=0;\\n        int c2=0;\\n    Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        for(int i=0;i<s.length();i++){   //storing the characters\\n            map1.put(s.charAt(i),map1.getOrDefault(s.charAt(i),0)+1);\\n        }\\n         for(int i=0;i<t.length();i++){\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        \\n        for(int i=0;i<t.length();i++){\\n            if(map1.containsKey(t.charAt(i)) && map1.get(t.charAt(i))>0){\\n                map1.put(t.charAt(i),map1.get(t.charAt(i))-1);  //checking if exists then reducing the count by 1\\n                c1++;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(map2.containsKey(s.charAt(i)) && map2.get(s.charAt(i))>0){\\n                map2.put(s.charAt(i),map2.get(s.charAt(i))-1);\\n            c2++;\\n            }\\n        }\\n        \\n        return s.length()+t.length()-c1-c2; \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n     int l1=s.length();\\n        int l2=t.length();\\n        int c1=0;\\n        int c2=0;\\n    Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        for(int i=0;i<s.length();i++){   //storing the characters\\n            map1.put(s.charAt(i),map1.getOrDefault(s.charAt(i),0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1804026,
                "title": "easy-to-understand-using-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n\\t\\t// increase the frequency of character in s string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n\\t\\t// decrease the frequency of character in t string\\n        for(int j=0;j<t.size();j++)\\n        {\\n            mp[t[j]]--;\\n        }\\n\\t\\t// now if the frequency of a particular element in map is zero then it need no appending \\n\\t\\t// if it is not equal to zero then we will just add abs of that frequency\\n        int res = 0;\\n        for(auto x:mp)\\n        {\\n            if(x.second != 0) res+=abs(x.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n\\t\\t// increase the frequency of character in s string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n\\t\\t// decrease the frequency of character in t string\\n        for(int j=0;j<t.size();j++)\\n        {\\n            mp[t[j]]--;\\n        }\\n\\t\\t// now if the frequency of a particular element in map is zero then it need no appending \\n\\t\\t// if it is not equal to zero then we will just add abs of that frequency\\n        int res = 0;\\n        for(auto x:mp)\\n        {\\n            if(x.second != 0) res+=abs(x.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803967,
                "title": "c-frequency-array-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        int n1,n2,i,j,ans=0;\\n        n1=s.size();\\n        n2=t.size();\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for(i=0;i<n1;i++) //making a frequency array for string s\\n        {\\n            v1[s[i]-\\'a\\']++;\\n        }\\n        for(i=0;i<n2;i++)//making a frequency array for string t\\n        {\\n            v2[t[i]-\\'a\\']++;\\n        }\\n        for(i=0;i<26;i++)//checking the difference between the two frequency arrays\\n        {\\n            ans=ans+abs(v1[i]-v2[i]); //keeping check of the total of absolute difference\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        int n1,n2,i,j,ans=0;\\n        n1=s.size();\\n        n2=t.size();\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for(i=0;i<n1;i++) //making a frequency array for string s\\n        {\\n            v1[s[i]-\\'a\\']++;\\n        }\\n        for(i=0;i<n2;i++)//making a frequency array for string t\\n        {\\n            v2[t[i]-\\'a\\']++;\\n        }\\n        for(i=0;i<26;i++)//checking the difference between the two frequency arrays\\n        {\\n            ans=ans+abs(v1[i]-v2[i]); //keeping check of the total of absolute difference\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803825,
                "title": "c-easy-4-lines-solution-o-n",
                "content": "by counting each letter in the first word, and decreasing the letter in the other words\\nwe can get the difference in letters characters,\\nwe sum the absolute differences and return it\\n```\\npublic int MinSteps(string s, string t) {\\n\\t    var letters = new int[26];\\n        foreach (var letter in s) letters[letter - \\'a\\']++;\\n        foreach (var letter in t) letters[letter - \\'a\\']--;\\n        return letters.Sum(x => Math.Abs(x));\\n}\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(26)  = O(1)",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\npublic int MinSteps(string s, string t) {\\n\\t    var letters = new int[26];\\n        foreach (var letter in s) letters[letter - \\'a\\']++;\\n        foreach (var letter in t) letters[letter - \\'a\\']--;\\n        return letters.Sum(x => Math.Abs(x));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803623,
                "title": "python-easy-and-fast-solution-using-counter",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1 = Counter(s)\\n        c2 = Counter(t)\\n        a, b = c1-c2,  c2-c1\\n        ans = 0\\n        for i in (a+b):\\n            ans += (a+b)[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1 = Counter(s)\\n        c2 = Counter(t)\\n        a, b = c1-c2,  c2-c1\\n        ans = 0\\n        for i in (a+b):\\n            ans += (a+b)[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803441,
                "title": "c-maintain-character-frequency-array-easy-to-implement",
                "content": "Idea: - The Idea is to maintain a Character Frequency array to store the frequency of each character\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count = 0;\\n        \\n        vector<int>c_count(26,0); //to store the count of each cahracter\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            c_count[s[i] - \\'a\\']++; // store the character frequency of first string\\n        }\\n        \\n        for(int i=0; i<t.size(); i++) //iterate through the second string,update char_count\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// if character is not found in char_count then increase\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//count\\n        {\\n            c_count[t[i] - \\'a\\']--; \\n        }\\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(c_count[i] != 0)\\n\\t\\t\\tcount += abs(c_count[i]); // take count of all values other than zero, if negative \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//take absolute of it\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count = 0;\\n        \\n        vector<int>c_count(26,0); //to store the count of each cahracter\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            c_count[s[i] - \\'a\\']++; // store the character frequency of first string\\n        }\\n        \\n        for(int i=0; i<t.size(); i++) //iterate through the second string,update char_count\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// if character is not found in char_count then increase\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//count\\n        {\\n            c_count[t[i] - \\'a\\']--; \\n        }\\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(c_count[i] != 0)\\n\\t\\t\\tcount += abs(c_count[i]); // take count of all values other than zero, if negative \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//take absolute of it\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803410,
                "title": "kotlin-simple-solution-explained",
                "content": "Solution pops up really quickly, when you refrase the challenge description. Basically, we need `s` and `t` to have same frequencies of all letters. And that is it. How do we do that? We just count all characters that are in `s` but not int `t` (so we need to add them to `t`) and all characters that are int `t` but not in `s` (so we need to add them to `s`), summing these counts we have the solution. As simple as that.\\n\\n```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun minSteps(s: String, t: String): Int {\\n\\t\\n\\t\\t// Counting letters frequencies\\n\\t\\t// If after the loop freq[i] < 0, that means that this letter is in t but not in s, if freqs[i] > 0 that means that the letter is in s but not in t.\\n\\t\\t// And the absolute value value of freqs[i] indicates how much letters we need to add to another string.\\n        val freqs = IntArray(26)\\n        for (i in 0 until maxOf(s.length, t.length)) {\\n            if (i < s.length) freqs[s[i] - \\'a\\']++\\n            if (i < t.length) freqs[t[i] - \\'a\\']--\\n        }\\n        \\n        var count = 0\\n        for (freq in freqs) count += abs(freq)\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun minSteps(s: String, t: String): Int {\\n\\t\\n\\t\\t// Counting letters frequencies\\n\\t\\t// If after the loop freq[i] < 0, that means that this letter is in t but not in s, if freqs[i] > 0 that means that the letter is in s but not in t.\\n\\t\\t// And the absolute value value of freqs[i] indicates how much letters we need to add to another string.\\n        val freqs = IntArray(26)\\n        for (i in 0 until maxOf(s.length, t.length)) {\\n            if (i < s.length) freqs[s[i] - \\'a\\']++\\n            if (i < t.length) freqs[t[i] - \\'a\\']--\\n        }\\n        \\n        var count = 0\\n        for (freq in freqs) count += abs(freq)\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803231,
                "title": "intuitive-non-hash-map-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int res=0;\\n        vector<int> smap(26,0);\\n        vector<int> tmap(26,0);\\n        for(auto el:s){\\n            smap[el-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.size(); i++){\\n            if(smap[t[i]-\\'a\\']){\\n                smap[t[i]-\\'a\\']--;\\n            }\\n            else{\\n                tmap[t[i]-\\'a\\']++;\\n            }\\n        }\\n        for(auto el:tmap){\\n            res+=el;\\n        }\\n        for(auto el:smap){\\n            res+=el;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int res=0;\\n        vector<int> smap(26,0);\\n        vector<int> tmap(26,0);\\n        for(auto el:s){\\n            smap[el-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.size(); i++){\\n            if(smap[t[i]-\\'a\\']){\\n                smap[t[i]-\\'a\\']--;\\n            }\\n            else{\\n                tmap[t[i]-\\'a\\']++;\\n            }\\n        }\\n        for(auto el:tmap){\\n            res+=el;\\n        }\\n        for(auto el:smap){\\n            res+=el;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803188,
                "title": "two-pointer-c",
                "content": "\\n\\tint minSteps(string s, string t) \\n\\t{\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        int m=s.length();\\n        int n=t.length();\\n        int i=0, j=0, count=0;  //count to keep track of common letters\\n        while(i<m and j<n)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else if(s[i]<t[j])\\n                i++;\\n            else \\n                j++;\\n        }\\n        return (m-count)+(n-count);\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n\\tint minSteps(string s, string t) \\n\\t{\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        int m=s.length();\\n        int n=t.length();\\n        int i=0, j=0, count=0;  //count to keep track of common letters\\n        while(i<m and j<n)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else if(s[i]<t[j])\\n                i++;\\n            else \\n                j++;\\n        }\\n        return (m-count)+(n-count);\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1803106,
                "title": "rust-counting-frequencies",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl1/lc2186)\\n\\n<b>Problem List</b>\\n#LinearScan-String - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/string/by_technique/n_pointers/linear_scan.txt)\\n#FreqArray - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/string/by_technique/freqs_array.txt)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n/// Time Complexity:    O(max(`_len_s`, `_len_t`))\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn min_steps(s: String, t: String) -> i32 {\\n        let freqs_s: Vec<u32> = {\\n            let mut freqs: Vec<u32> = vec![0; 26];\\n            for ch in s.chars(){\\n                freqs[ch as usize - \\'a\\' as usize] += 1;\\n            }\\n            freqs\\n        };\\n        let freqs_t: Vec<u32> = {\\n            let mut freqs: Vec<u32> = vec![0; 26];\\n            for ch in t.chars(){\\n                freqs[ch as usize - \\'a\\' as usize] += 1;\\n            }\\n            freqs\\n        };\\n        let mut cnt: i32 = 0;\\n        for idx in 0..26{\\n            cnt += (freqs_s[idx] as i32 - freqs_t[idx] as i32).abs();\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n/// Time Complexity:    O(max(`_len_s`, `_len_t`))\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn min_steps(s: String, t: String) -> i32 {\\n        let freqs_s: Vec<u32> = {\\n            let mut freqs: Vec<u32> = vec![0; 26];\\n            for ch in s.chars(){\\n                freqs[ch as usize - \\'a\\' as usize] += 1;\\n            }\\n            freqs\\n        };\\n        let freqs_t: Vec<u32> = {\\n            let mut freqs: Vec<u32> = vec![0; 26];\\n            for ch in t.chars(){\\n                freqs[ch as usize - \\'a\\' as usize] += 1;\\n            }\\n            freqs\\n        };\\n        let mut cnt: i32 = 0;\\n        for idx in 0..26{\\n            cnt += (freqs_s[idx] as i32 - freqs_t[idx] as i32).abs();\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803082,
                "title": "python-python3-2-liner-easy-fast-simple",
                "content": "* return the sum of difference of count of indivisual element in both string\\n1.  prepare hashmap( or dict ) using Counter (prebuild function from collection module)  , key as unique element and value as count of that element in string\\n2.  return total sum of diff of count\\n\\n\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        s,c=Counter(s),Counter(t)\\n        return sum(abs(s[chr(i)]-c[chr(i)]) for i in range(97,97+26))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        s,c=Counter(s),Counter(t)\\n        return sum(abs(s[chr(i)]-c[chr(i)]) for i in range(97,97+26))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803061,
                "title": "c-o-n-hashmap",
                "content": "**The approach according to me is :-\\n1) First convert the first  and second given string into hashmap of (Char , Freq) by iterating through them\\n2) Now we will search keys of map2 in   map 1 , if key doesnt exists than  insert the key in ,map1 with frequency 1 . If key exists than we need to check if the frequency is <= or > than the freq with respect to map 2.\\n3) If freq is <= we need to to increase the count as count +(difference of the key frequency in map1 and map2)\\n4) if key is > that means we dont need to do anything .\\n5) Repeat the step from 2->3 by substituting map 1 with map 2.\\n6) Finaly we will return the count **\\nHere is the code:\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> first;\\n        unordered_map<char,int> second;\\n        int count=0;\\n        int temp=0;\\n    \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(first.find(s[i])==first.end()) first.insert({s[i],1});\\n            else first[s[i]]++;\\n            \\n        }\\n         for(int i=0;i<t.length();i++)\\n        {\\n            if(second.find(t[i])==second.end()) second.insert({t[i],1});\\n            else second[t[i]]++;\\n        }\\n        for(auto  itr=second.begin();itr!=second.end();itr++)\\n        {\\n            auto it=first.find(itr->first);\\n            if(it==first.end()) count=count+(itr->second);\\n            else\\n            {\\n                if(first[itr->first]<second[itr->first])\\n                count= count +abs(first[itr->first]-second[itr->first]);\\n            }\\n        }\\n        for(auto  itr=first.begin();itr!=first.end();itr++)\\n        {\\n            auto it=second.find(itr->first);\\n            if(it==second.end()) count=count+(itr->second);\\n            else \\n            {\\n                if(second[itr->first]<first[itr->first])\\n                count= count +abs(first[itr->first]-second[itr->first]);\\n            }\\n        }\\n        return count ; \\n    }\\n};\\n```\\n\\n**Time complexity= inserting the (char, freq) in map 1 and 2 +Traversing the map 1 and map 2 for searching pupose= ~0(n)**\\n**Space complexity= 0(2n)~ 0(n)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> first;\\n        unordered_map<char,int> second;\\n        int count=0;\\n        int temp=0;\\n    \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(first.find(s[i])==first.end()) first.insert({s[i],1});\\n            else first[s[i]]++;\\n            \\n        }\\n         for(int i=0;i<t.length();i++)\\n        {\\n            if(second.find(t[i])==second.end()) second.insert({t[i],1});\\n            else second[t[i]]++;\\n        }\\n        for(auto  itr=second.begin();itr!=second.end();itr++)\\n        {\\n            auto it=first.find(itr->first);\\n            if(it==first.end()) count=count+(itr->second);\\n            else\\n            {\\n                if(first[itr->first]<second[itr->first])\\n                count= count +abs(first[itr->first]-second[itr->first]);\\n            }\\n        }\\n        for(auto  itr=first.begin();itr!=first.end();itr++)\\n        {\\n            auto it=second.find(itr->first);\\n            if(it==second.end()) count=count+(itr->second);\\n            else \\n            {\\n                if(second[itr->first]<first[itr->first])\\n                count= count +abs(first[itr->first]-second[itr->first]);\\n            }\\n        }\\n        return count ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803001,
                "title": "c-o-n-hashmap-frequency-array",
                "content": "Hi , everybody . This is a fairly easy question . It is a good practice for beginner level understanding of frequency arrays/hashmaps/maps. \\n\\nSo, let\\'s get started. \\n**QUESTION EXPLANATION :**\\nThe question says that we are provided with 2 strings ***s and t***. \\nWe can perform the following operation on either of them any number of times : \\n**\"Add(append) any character in the string\"**.\\nThe goal is to make the strings **anagrams of each other.**\\n\\n**WHAT ARE ANAGRAMS ?**\\nAnagram of a string is another string which has ***the same frequency of each character*** as in the given string. \\nEXAMPLE :  \"aabcde\" and \"bcaade\" are anagrams of each other , as all the characters in both the strings have same frequency. \\n\\n## SOLUTION : \\nNow , we have to make these 2 strings anagrams and the only operation allowed is that we can add any character that we want to either of the strings.\\n\\n**SO HOW DO WE DO THIS??**\\nThe first step that I see is to **store the frequency of each character in both the strings in separate hashmaps.** \\n\\nNow, what will be the minimum number of steps needed to make the strings anagrams of each other ?? \\nWe can compare the frequency of each character in both the strings. \\nIf the frequency of a character differs , then we can **add the same character abs(freq1[i] - freq2[i]) times to the string that is low on the count**. This way the frequency of this character will now be equal in both the strings. \\n\\nFor example : In a particular case : \\n**STRING_1 contains 6 \\'a\\' and STRING_2 contains 2 \\'a\\'.**\\nNow we can **add (6-2) \\'a\\' to the STRING_2 (string with low count)** . Now the frequency of \\'a\\' in both strings is 6.\\n\\n\\n### APPROACH : \\n* Store the frequency of each character in both the strings on individual hashmaps ( or frequency arrays ) .\\n* Add the absolute difference of the frequencies of each character from the hashmaps to the ***ans variable.*** ( freq1[\\'a\\'] -freq2[\\'a\\'] ).\\n* Return **ans variable**\\n\\n**TC : O(N)**\\n**SC : O(N)**\\n\\nWe can improve this approach on the SPACE COMPLEXITY. \\nThis is because we don\\'t exactly need 2 hashmaps to generate the answer. \\nWHY ?? \\n*Because if , we notice we are adding the frequency of a character from STRING1 and substracting the frequency of the same character from STRING2. \\nThen why should we store it in 2 different hashmaps ?? Well, we can increase the frequency of a character whenever it is encountered in the STRING1 and we can decrease the frequency of a character whenever it is encountered in the STRING2.*\\n\\n#### CODE : \\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int freq[26]={0};\\n        for(char &c:s)\\n            freq[c-\\'a\\']++;\\n        for(char &d:t)\\n            freq[d-\\'a\\']--;\\n        int ans=0;\\n        for(int i:freq)\\n            ans+=abs(i);\\n        return ans;\\n        \\n    }\\n};\\n```\\n***If you found this post helpful , please upvote and comment below.***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int freq[26]={0};\\n        for(char &c:s)\\n            freq[c-\\'a\\']++;\\n        for(char &d:t)\\n            freq[d-\\'a\\']--;\\n        int ans=0;\\n        for(int i:freq)\\n            ans+=abs(i);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803000,
                "title": "python-counter-with-explanation",
                "content": "3 cases:\\n1. Numbers of distinct letters in source are equal to target.\\n2. Source word has more distinct letters.\\n3. Target word has more distinct letters.\\n\\nSo I looped through the keys in source first and made comparison, then looped through target to make comparison.\\nTime complexity: O(N)\\nSpace complextiy: O(M + N) M, N are the number of distinct letters of source and target. \\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs = Counter(s)\\n        ct = Counter(t)\\n        \\n        # print(cs, ct)\\n        ans = 0\\n        for key in cs:\\n            if key in ct:\\n                ans += abs(cs[key] - ct[key])\\n            else:\\n                ans += cs[key]\\n                \\n        for key in ct:\\n            if key not in cs:\\n                ans += ct[key]\\n                \\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "3 cases:\\n1. Numbers of distinct letters in source are equal to target.\\n2. Source word has more distinct letters.\\n3. Target word has more distinct letters.\\n\\nSo I looped through the keys in source first and made comparison, then looped through target to make comparison.\\nTime complexity: O(N)\\nSpace complextiy: O(M + N) M, N are the number of distinct letters of source and target. \\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs = Counter(s)\\n        ct = Counter(t)\\n        \\n        # print(cs, ct)\\n        ans = 0\\n        for key in cs:\\n            if key in ct:\\n                ans += abs(cs[key] - ct[key])\\n            else:\\n                ans += cs[key]\\n                \\n        for key in ct:\\n            if key not in cs:\\n                ans += ct[key]\\n                \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1802968,
                "title": "java-simple-solution-with-ascii-array",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arr = new int[128];\\n        for (char c : s.toCharArray()) {\\n            arr[c]++;\\n        }\\n        for (char c : t.toCharArray()) {\\n            arr[c]--;\\n        }\\n        int step = 0;\\n        for (int i : arr) {\\n            if (i != 0) {\\n                step += Math.abs(i);\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arr = new int[128];\\n        for (char c : s.toCharArray()) {\\n            arr[c]++;\\n        }\\n        for (char c : t.toCharArray()) {\\n            arr[c]--;\\n        }\\n        int step = 0;\\n        for (int i : arr) {\\n            if (i != 0) {\\n                step += Math.abs(i);\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802921,
                "title": "easy-count-approach-time-o-26",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26);\\n        for(auto it : s) arr[it - \\'a\\']++;\\n        for(auto it : t) arr[it - \\'a\\']--;\\n        int ans = 0;\\n        for(auto it : arr) ans += abs(it);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26);\\n        for(auto it : s) arr[it - \\'a\\']++;\\n        for(auto it : t) arr[it - \\'a\\']--;\\n        int ans = 0;\\n        for(auto it : arr) ans += abs(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802920,
                "title": "c-solution-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> m1(26,0);\\n        for(char c:s) m1[c-\\'a\\']++;\\n        for(char c:t) m1[c-\\'a\\']--;\\n        int ans=0;\\n        for(auto i:m1){\\n            ans=ans+abs(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> m1(26,0);\\n        for(char c:s) m1[c-\\'a\\']++;\\n        for(char c:t) m1[c-\\'a\\']--;\\n        int ans=0;\\n        for(auto i:m1){\\n            ans=ans+abs(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802894,
                "title": "4-line-code-very-easy-solution-hashmap-c-with-explnation",
                "content": "Ist we  count the frequecy of charachters in s and  then \\nsecond step we reduce the freq and \\n c variable store the positive value .\\n\\n```\\nclass Solution {\\npublic:\\n     int minSteps(string s, string t) { \\n         int c=0;\\n        unordered_map<char,int>map;\\n            for(auto i:s) map[i] ++;\\n         for(auto p:t) map[p]--;\\n        for(auto it:map)\\n        {    c+= abs(it.second); }\\n     return c;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n     int minSteps(string s, string t) { \\n         int c=0;\\n        unordered_map<char,int>map;\\n            for(auto i:s) map[i] ++;\\n         for(auto p:t) map[p]--;\\n        for(auto it:map)\\n        {    c+= abs(it.second); }",
                "codeTag": "Java"
            },
            {
                "id": 1802862,
                "title": "easy-simple-java-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n   public int minSteps(String s, String t) {\\n        int[] cArray = new int[\\'z\\'-\\'a\\'+1];\\n        int count=0;\\n        for(char c: s.toCharArray() ) cArray[c-\\'a\\']++;\\n        for(char c: t.toCharArray() ) cArray[c-\\'a\\']--;\\n        for(int c: cArray) count+=Math.abs(c);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n   public int minSteps(String s, String t) {\\n        int[] cArray = new int[\\'z\\'-\\'a\\'+1];\\n        int count=0;\\n        for(char c: s.toCharArray() ) cArray[c-\\'a\\']++;\\n        for(char c: t.toCharArray() ) cArray[c-\\'a\\']--;\\n        for(int c: cArray) count+=Math.abs(c);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802783,
                "title": "c-o-n-o-1-simple-easy-counting-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minSteps(string s, string t) {\\n\\t\\tvector<int>freq(26, 0);\\n\\t\\tfor (auto c : s) freq[c - \\'a\\']++;\\n\\t\\tfor (auto c : t) freq[c - \\'a\\']--;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) ans += abs(freq[i]);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n**Time Complexity : O(max(n,m))** where `n = s.size()` & `m = t.size()`\\n**Space Complexity : O(1)** as we use constatnt size `freq` array\\n\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minSteps(string s, string t) {\\n\\t\\tvector<int>freq(26, 0);\\n\\t\\tfor (auto c : s) freq[c - \\'a\\']++;\\n\\t\\tfor (auto c : t) freq[c - \\'a\\']--;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) ans += abs(freq[i]);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802726,
                "title": "c-short-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n          vector<int> fre1(26,0), fre2(26,0);\\n          for(char ch : s){\\n              fre1[ch - \\'a\\']++;\\n          }\\n         for(char ch : t){\\n              fre2[ch - \\'a\\']++;\\n          }\\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(fre1[i] - fre2[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n          vector<int> fre1(26,0), fre2(26,0);\\n          for(char ch : s){\\n              fre1[ch - \\'a\\']++;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1802697,
                "title": "c-count-array-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26,0);\\n        \\n        for(int i=0; i<s.length(); i++)\\n            arr[s[i] - \\'a\\']++;\\n        for(int i=0; i<t.length(); i++)\\n            arr[t[i] - \\'a\\']--;\\n        \\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(arr[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26,0);\\n        \\n        for(int i=0; i<s.length(); i++)\\n            arr[s[i] - \\'a\\']++;\\n        for(int i=0; i<t.length(); i++)\\n            arr[t[i] - \\'a\\']--;\\n        \\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(arr[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802688,
                "title": "c-simple-hashmap-solution",
                "content": "```\\n int ans = 0;\\n        unordered_map<char,int>mp;\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n         for(auto it:t){\\n            mp[it]--;\\n        }\\n         for(auto it:mp){\\n           ans+=abs(it.second);\\n        }\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n int ans = 0;\\n        unordered_map<char,int>mp;\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n         for(auto it:t){\\n            mp[it]--;\\n        }\\n         for(auto it:mp){\\n           ans+=abs(it.second);\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802649,
                "title": "java-easy-frequency-difference",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] f1 = new int[26];\\n        int[] f2 = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n            f1[s.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<t.length();i++){\\n            f2[t.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            ans += Math.abs(f1[i]-f2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] f1 = new int[26];\\n        int[] f2 = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n            f1[s.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<t.length();i++){\\n            f2[t.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            ans += Math.abs(f1[i]-f2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802619,
                "title": "python",
                "content": "\\t\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\ta1=[0 for i in range(26)]\\n\\t\\t\\ta2=[0 for i in range(26)]\\n        \\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\ta1[ord(s[i])-ord(\\'a\\')]+=1\\n        \\n\\t\\t\\tfor i in range(len(t)):\\n\\t\\t\\t\\ta2[ord(t[i])-ord(\\'a\\')]+=1\\n        \\n\\t\\t\\tt=0\\n\\t\\t\\tfor i in range(26):\\n\\t\\t\\t\\tt+=abs(a1[i]-a2[i])\\n\\t\\t\\treturn t\\n",
                "solutionTags": [],
                "code": "\\t\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\ta1=[0 for i in range(26)]\\n\\t\\t\\ta2=[0 for i in range(26)]\\n        \\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\ta1[ord(s[i])-ord(\\'a\\')]+=1\\n        \\n\\t\\t\\tfor i in range(len(t)):\\n\\t\\t\\t\\ta2[ord(t[i])-ord(\\'a\\')]+=1\\n        \\n\\t\\t\\tt=0\\n\\t\\t\\tfor i in range(26):\\n\\t\\t\\t\\tt+=abs(a1[i]-a2[i])\\n\\t\\t\\treturn t\\n",
                "codeTag": "Java"
            },
            {
                "id": 1802604,
                "title": "c-count-frequency-easy-to-understand-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> freqs(26,0);\\n        vector<int> freqt(26,0);\\n        int n=s.size(),m=t.size();\\n        for(int i=0;i<n;i++){\\n            freqs[s[i]-\\'a\\']++;//count frequency of string s\\n        }\\n        for(int i=0;i<m;i++){\\n            freqt[t[i]-\\'a\\']++;//count frequency of string t\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            if(freqs[i]!=0 and freqt[i]!=0){\\n            if(freqs[i]==freqt[i])cnt+=freqs[i];\\n            else {\\n                if(freqs[i]>freqt[i])cnt+=freqt[i];\\n                else cnt+=freqs[i];\\n            }\\n            }\\n        }\\n        return n+m-2*cnt;//excluding the common strings from total length of string s + string t\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> freqs(26,0);\\n        vector<int> freqt(26,0);\\n        int n=s.size(),m=t.size();\\n        for(int i=0;i<n;i++){\\n            freqs[s[i]-\\'a\\']++;//count frequency of string s\\n        }\\n        for(int i=0;i<m;i++){\\n            freqt[t[i]-\\'a\\']++;//count frequency of string t\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            if(freqs[i]!=0 and freqt[i]!=0){\\n            if(freqs[i]==freqt[i])cnt+=freqs[i];\\n            else {\\n                if(freqs[i]>freqt[i])cnt+=freqt[i];\\n                else cnt+=freqs[i];\\n            }\\n            }\\n        }\\n        return n+m-2*cnt;//excluding the common strings from total length of string s + string t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802598,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] str1 = new int[26];\\n        int[] str2 = new int[26];\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            str1[s.charAt(i) - \\'a\\'] += 1; \\n        }\\n        \\n        \\n        for (int i = 0; i < t.length(); i++) {\\n            str2[t.charAt(i) - \\'a\\'] += 1; \\n        }\\n        \\n        boolean isAnagram = true;\\n        for (int i = 0; i < 26; i++) {\\n            if (str1[i] != str2[i]) isAnagram = false;\\n        }\\n        \\n        if (isAnagram) return 0;\\n        int count = 0;\\n        for (int i = 0; i < 26; ) {\\n            if (str1[i] == str2[i]) {\\n                i++;\\n                continue;\\n            }\\n            \\n            if (str1[i] > str2[i]) {\\n                str2[i] += 1;\\n                count++;\\n            } else if (str1[i] < str2[i]) {\\n                str1[i] += 1;\\n                count++;\\n            }\\n            \\n             if (str1[i] == str2[i]) {\\n                i++;\\n                continue;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] str1 = new int[26];\\n        int[] str2 = new int[26];\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            str1[s.charAt(i) - \\'a\\'] += 1; \\n        }\\n        \\n        \\n        for (int i = 0; i < t.length(); i++) {\\n            str2[t.charAt(i) - \\'a\\'] += 1; \\n        }\\n        \\n        boolean isAnagram = true;\\n        for (int i = 0; i < 26; i++) {\\n            if (str1[i] != str2[i]) isAnagram = false;\\n        }\\n        \\n        if (isAnagram) return 0;\\n        int count = 0;\\n        for (int i = 0; i < 26; ) {\\n            if (str1[i] == str2[i]) {\\n                i++;\\n                continue;\\n            }\\n            \\n            if (str1[i] > str2[i]) {\\n                str2[i] += 1;\\n                count++;\\n            } else if (str1[i] < str2[i]) {\\n                str1[i] += 1;\\n                count++;\\n            }\\n            \\n             if (str1[i] == str2[i]) {\\n                i++;\\n                continue;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802590,
                "title": "c-store-frequencies",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> a(26, 0);\\n        vector<int> b(26, 0);\\n        for (int i = 0; i < s.size(); i++) a[s[i] - \\'a\\']++;\\n        for (int i = 0; i < t.size(); i++) b[t[i] - \\'a\\']++;\\n        int res = 0;\\n        for (int i = 0; i < 26; i++) res += abs(a[i] - b[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> a(26, 0);\\n        vector<int> b(26, 0);\\n        for (int i = 0; i < s.size(); i++) a[s[i] - \\'a\\']++;\\n        for (int i = 0; i < t.size(); i++) b[t[i] - \\'a\\']++;\\n        int res = 0;\\n        for (int i = 0; i < 26; i++) res += abs(a[i] - b[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802589,
                "title": "c-easy-solution-using-map",
                "content": "**C++ easy solution using unoredered map**\\n\\n\\n\\tint minSteps(string s, string t) {*\\n\\t\\t\\tunordered_map<char,int>sp;\\n        unordered_map<char,int>tp;\\n        int count=0;\\n        int res=0;\\n        for(auto i:s){\\n            sp[i]++;\\n        }\\n        for(auto i:t){\\n            tp[i]++;\\n        }\\n        for(auto i:sp){\\n            count=sp[i.first]-tp[i.first];\\n            if(count<0)count=0;\\n            res+=count;\\n           \\n        }\\n        for(auto i:tp){\\n            count=tp[i.first]-sp[i.first];\\n            if(count<0)count=0;\\n            res+=count;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**C++ easy solution using unoredered map**\\n\\n\\n\\tint minSteps(string s, string t) {*\\n\\t\\t\\tunordered_map<char,int>sp;\\n        unordered_map<char,int>tp;\\n        int count=0;\\n        int res=0;\\n        for(auto i:s){\\n            sp[i]++;\\n        }\\n        for(auto i:t){\\n            tp[i]++;\\n        }\\n        for(auto i:sp){\\n            count=sp[i.first]-tp[i.first];\\n            if(count<0)count=0;\\n            res+=count;\\n           \\n        }\\n        for(auto i:tp){\\n            count=tp[i.first]-sp[i.first];\\n            if(count<0)count=0;\\n            res+=count;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1802581,
                "title": "anagram",
                "content": "any king of suggestions and improvements are most welcomded\\n\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int sv[26]={0};\\n        int tv[26]={0};\\n        for(int i=0; i<s.length(); i++){\\n            sv[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            tv[t[i]-\\'a\\']++;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<26; i++){\\n            ans+=abs(sv[i]-tv[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int sv[26]={0};\\n        int tv[26]={0};\\n        for(int i=0; i<s.length(); i++){\\n            sv[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            tv[t[i]-\\'a\\']++;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<26; i++){\\n            ans+=abs(sv[i]-tv[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802553,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       int n = s.size();\\n       int m = t.size();\\n       unordered_map<char, int> mp;\\n       int count = 0;\\n       for(char c : s){\\n               mp[c]++;\\n       }\\n       for(char c : t){\\n               if(mp.find(c) != mp.end()){\\n                  count++; \\n                  mp[c]--;\\n               }\\n               if(mp[c] == 0) mp.erase(c);\\n       }\\n        return n + m - 2*count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       int n = s.size();\\n       int m = t.size();\\n       unordered_map<char, int> mp;\\n       int count = 0;\\n       for(char c : s){\\n               mp[c]++;\\n       }\\n       for(char c : t){\\n               if(mp.find(c) != mp.end()){\\n                  count++; \\n                  mp[c]--;\\n               }\\n               if(mp[c] == 0) mp.erase(c);\\n       }\\n        return n + m - 2*count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802546,
                "title": "java-simple-map",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] map1 = new int[26];\\n        int[] map2 = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            map1[s.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            map2[t.charAt(i) - \\'a\\']++;\\n        }\\n        int answer = 0;\\n\\t\\t//  convert one map to another\\n        for (int i = 0; i < 26; i++) {\\n            int v1 = map1[i];\\n            int v2 = map2[i];\\n            answer += Math.abs(v2 - v1);\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n        int[] map1 = new int[26];\\n        int[] map2 = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            map1[s.charAt(i) - \\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1802530,
                "title": "c-sorting-two-pointer-approach-with-comments",
                "content": "Please Upvote if you like the solution.\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        \\n        // If words are anagram, then sorting both of them would make the strings equal i.e s == t.\\n        if (s == t)\\n            return 0;\\n        \\n        // If the are not equal then we take two pointer approach:\\n        \\n        int i = 0,j = 0,mini = 0;\\n        int n = s.length(), m = t.length();\\n        while (i < n && j < m){\\n            int check1 = s[i]-\\'a\\';\\n            int check2 = t[j]-\\'a\\';\\n            \\n            // If \\'i\\'th and \\'j\\'th letter in both the words are same we won\\'t require any steps,\\n            // so we just continue, incrementing \\'i\\'th and \\'j\\'th pointers;\\n            \\n            if (check1 == check2){\\n                i++;\\n                j++;\\n            }\\n            \\n            // If \\'i\\'th letter of string s is less than \\'j\\'th letter of string t,\\n            // then we need to add \\'i\\'th letter of string s to string t in order to make them anagram.\\n            else if (check1 < check2){\\n                i++;\\n                mini++;\\n            }\\n            \\n            // If \\'i\\'th letter of string s is greater than \\'j\\'th letter of string t,\\n            // then we need to add \\'j\\'th letter of string t to string s in order to make them anagram.\\n            else{\\n                j++;\\n                mini++;\\n            }      \\n        }\\n        \\n        // Since length of both the strings may not be same,\\n        // we may end up ending the loop and still we may have either letters in string s or t to be processed.\\n        // So we apply this condition:\\n        if (i < n){\\n            mini += (n - i);\\n        }\\n        if (j < m){\\n            mini += (m - j);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        \\n        // If words are anagram, then sorting both of them would make the strings equal i.e s == t.\\n        if (s == t)\\n            return 0;\\n        \\n        // If the are not equal then we take two pointer approach:\\n        \\n        int i = 0,j = 0,mini = 0;\\n        int n = s.length(), m = t.length();\\n        while (i < n && j < m){\\n            int check1 = s[i]-\\'a\\';\\n            int check2 = t[j]-\\'a\\';\\n            \\n            // If \\'i\\'th and \\'j\\'th letter in both the words are same we won\\'t require any steps,\\n            // so we just continue, incrementing \\'i\\'th and \\'j\\'th pointers;\\n            \\n            if (check1 == check2){\\n                i++;\\n                j++;\\n            }\\n            \\n            // If \\'i\\'th letter of string s is less than \\'j\\'th letter of string t,\\n            // then we need to add \\'i\\'th letter of string s to string t in order to make them anagram.\\n            else if (check1 < check2){\\n                i++;\\n                mini++;\\n            }\\n            \\n            // If \\'i\\'th letter of string s is greater than \\'j\\'th letter of string t,\\n            // then we need to add \\'j\\'th letter of string t to string s in order to make them anagram.\\n            else{\\n                j++;\\n                mini++;\\n            }      \\n        }\\n        \\n        // Since length of both the strings may not be same,\\n        // we may end up ending the loop and still we may have either letters in string s or t to be processed.\\n        // So we apply this condition:\\n        if (i < n){\\n            mini += (n - i);\\n        }\\n        if (j < m){\\n            mini += (m - j);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802524,
                "title": "without-hashmap-0-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] firstCharacter = new int[26];\\n        int[] secondCharacter = new int[26];\\n        int steps = 0;\\n        for(int i = 0 ;i < s.length() ; i++){\\n            firstCharacter[s.charAt(i) - \\'a\\'] += 1;\\n        }\\n        for(int i = 0 ;i < t.length() ; i++){\\n            secondCharacter[t.charAt(i) - \\'a\\'] += 1;\\n        }\\n        for(int i = 0 ;i < firstCharacter.length ; i++){\\n            if(firstCharacter[i]  != secondCharacter[i]){\\n                steps += Math.abs(firstCharacter[i] - secondCharacter[i]);\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] firstCharacter = new int[26];\\n        int[] secondCharacter = new int[26];\\n        int steps = 0;\\n        for(int i = 0 ;i < s.length() ; i++){\\n            firstCharacter[s.charAt(i) - \\'a\\'] += 1;\\n        }\\n        for(int i = 0 ;i < t.length() ; i++){\\n            secondCharacter[t.charAt(i) - \\'a\\'] += 1;\\n        }\\n        for(int i = 0 ;i < firstCharacter.length ; i++){\\n            if(firstCharacter[i]  != secondCharacter[i]){\\n                steps += Math.abs(firstCharacter[i] - secondCharacter[i]);\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802492,
                "title": "c-with-explanation",
                "content": "**Explanation:-**\\n1. answer will be the sum of extra characters in ```s``` that are not in ```t``` and vice-versa.\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>a1(26,0),a2(26,0);\\n        int ans=0;\\n        for(auto & i:s)  a1[i-\\'a\\']++;\\n        for(auto & i:t)  a2[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            ans+=a1[i]-min(a1[i],a2[i]);\\n            ans+=a2[i]-min(a1[i],a2[i]);\\n        }\\n        return ans;\\n        }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```s```\n```t```\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>a1(26,0),a2(26,0);\\n        int ans=0;\\n        for(auto & i:s)  a1[i-\\'a\\']++;\\n        for(auto & i:t)  a2[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            ans+=a1[i]-min(a1[i],a2[i]);\\n            ans+=a2[i]-min(a1[i],a2[i]);\\n        }\\n        return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802481,
                "title": "python-solution-3-lines",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        hmap_s = collections.Counter(s)\\n        hmap_t = collections.Counter(t)\\n        return sum((hmap_s-hmap_t).values()) + sum((hmap_t-hmap_s).values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        hmap_s = collections.Counter(s)\\n        hmap_t = collections.Counter(t)\\n        return sum((hmap_s-hmap_t).values()) + sum((hmap_t-hmap_s).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802457,
                "title": "python-java-hashmap",
                "content": "\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\tcntS = collections.Counter(s)\\n\\t\\t\\tcntT = collections.Counter(t)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor k in cntS:\\n\\t\\t\\t\\tif k in cntT:\\n\\t\\t\\t\\t\\ttoRmove = min(cntS[k], cntT[k])\\n\\t\\t\\t\\t\\tcntS[k] -= toRmove\\n\\t\\t\\t\\t\\tcntT[k] -= toRmove\\n\\t\\t\\tfor v in cntS.values():\\n\\t\\t\\t\\tres += v\\n\\t\\t\\tfor v in cntT.values():\\n\\t\\t\\t\\tres += v\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int minSteps(String s, String t) {\\n\\t\\t\\tMap<Character, Integer> cntS = new HashMap<>();\\n\\t\\t\\tMap<Character, Integer> cntT = new HashMap<>();\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (char c: s.toCharArray()) {\\n\\t\\t\\t\\tcntS.put(c, cntS.getOrDefault(c, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (char c: t.toCharArray()) {\\n\\t\\t\\t\\tcntT.put(c, cntT.getOrDefault(c, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (char c: cntS.keySet()) {\\n\\t\\t\\t\\tif (cntT.containsKey(c)) {\\n\\t\\t\\t\\t\\tint toRemove = Math.min(cntS.get(c), cntT.get(c));\\n\\t\\t\\t\\t\\tcntS.put(c, cntS.get(c) - toRemove);\\n\\t\\t\\t\\t\\tcntT.put(c, cntT.get(c) - toRemove);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (char c: cntS.keySet()) {\\n\\t\\t\\t\\tres += cntS.get(c);\\n\\t\\t\\t}\\n\\t\\t\\tfor (char c: cntT.keySet()) {\\n\\t\\t\\t\\tres += cntT.get(c);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\tcntS = collections.Counter(s)\\n\\t\\t\\tcntT = collections.Counter(t)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor k in cntS:\\n\\t\\t\\t\\tif k in cntT:\\n\\t\\t\\t\\t\\ttoRmove = min(cntS[k], cntT[k])\\n\\t\\t\\t\\t\\tcntS[k] -= toRmove\\n\\t\\t\\t\\t\\tcntT[k] -= toRmove\\n\\t\\t\\tfor v in cntS.values():\\n\\t\\t\\t\\tres += v\\n\\t\\t\\tfor v in cntT.values():\\n\\t\\t\\t\\tres += v\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int minSteps(String s, String t) {\\n\\t\\t\\tMap<Character, Integer> cntS = new HashMap<>();\\n\\t\\t\\tMap<Character, Integer> cntT = new HashMap<>();\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (char c: s.toCharArray()) {\\n\\t\\t\\t\\tcntS.put(c, cntS.getOrDefault(c, 0) + 1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1802430,
                "title": "python-simple-concise-solution",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs = Counter(s)\\n        ct = Counter(t)\\n        \\n        ans = 0\\n        for c in set(s + t):\\n            ans += abs(cs.get(c,0) - ct.get(c,0))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs = Counter(s)\\n        ct = Counter(t)\\n        \\n        ans = 0\\n        for c in set(s + t):\\n            ans += abs(cs.get(c,0) - ct.get(c,0))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070618,
                "title": "easy-way-to-solve-this-using-c-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFreq1[s[i]-\\'a\\']++;: For each character in s, this line increments the corresponding element in the Freq array. It does this by subtracting the ASCII value of \\'a\\' from the character s[i], which gives the index of the character in the array Freq. This step effectively increases the frequency count of the character in s.\\n\\nFreq2[t[i]-\\'a\\']++;: Similarly, for each character in t, this line increments the corresponding element in the Freq array. It subtracts the ASCII value of \\'a\\' from the character t[i] to get the index in the Freq array. This step effectively increases the frequency count of the character in t.\\n\\nWe check, for each frequency values of alphabets on both strings, which has greater value. if freq1 has greater value than freq2 for saome index position, it means string s has more number of that specific alphabet than t, so we add the difference in frequency values to counter t_counter. Similarly, do the same for opposite condition.\\n\\nWe add both counters and return that value (result).\\n\\n**DO UPVOTE IF YOU LIKED THE SOLUTION AND IT HELPED!**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minSteps(char * s, char * t){\\n    int n=strlen(s);\\n    int m=strlen(t);\\n    int freq1[26]={0};\\n    int freq2[26]={0};\\n\\n    for(int i=0;i<n;i++)\\n    {\\n        freq1[s[i]-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<m;i++)\\n    {\\n        freq2[t[i]-\\'a\\']++;\\n    }\\n\\n    int s_count=0;\\n    int t_count=0;\\n\\n    for(int j=0;j<26;j++)\\n    {\\n        if(freq1[j]==freq2[j]);\\n        else if(freq1[j]>freq2[j])\\n        {\\n        t_count=t_count+(freq1[j]-freq2[j]);\\n        }\\n        else\\n        {\\n        s_count=s_count+(freq2[j]-freq1[j]);\\n        }\\n    }\\n    int result=s_count+t_count;\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minSteps(char * s, char * t){\\n    int n=strlen(s);\\n    int m=strlen(t);\\n    int freq1[26]={0};\\n    int freq2[26]={0};\\n\\n    for(int i=0;i<n;i++)\\n    {\\n        freq1[s[i]-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<m;i++)\\n    {\\n        freq2[t[i]-\\'a\\']++;\\n    }\\n\\n    int s_count=0;\\n    int t_count=0;\\n\\n    for(int j=0;j<26;j++)\\n    {\\n        if(freq1[j]==freq2[j]);\\n        else if(freq1[j]>freq2[j])\\n        {\\n        t_count=t_count+(freq1[j]-freq2[j]);\\n        }\\n        else\\n        {\\n        s_count=s_count+(freq2[j]-freq1[j]);\\n        }\\n    }\\n    int result=s_count+t_count;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058446,
                "title": "c-using-hashmap-4-lines-of-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        vector<int> hash(26, 0);\\n        int ans = 0;\\n\\n        for(auto x: s) ++hash[x-\\'a\\'];\\n        for(auto x: t) --hash[x-\\'a\\'];\\n\\n        for(int i=0; i<26; i++)\\n            ans += abs(hash[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        vector<int> hash(26, 0);\\n        int ans = 0;\\n\\n        for(auto x: s) ++hash[x-\\'a\\'];\\n        for(auto x: t) --hash[x-\\'a\\'];\\n\\n        for(int i=0; i<26; i++)\\n            ans += abs(hash[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045992,
                "title": "working-java-hashmap-approach-any-feedback-is-appreciated",
                "content": "# Intuition\\nMy approach was to calculate the sum of all the letters which appear in each string but not the other\\n# Approach\\nTo do this, I used a hashmap to add the letters in the first string as the key and increment the value by 1 for every repeat letter.\\nThen I used the same hashmap to loop through each letter of the second string but instead of increasing I decrease the value because this letter is now common in both strings, for new letters I start with -1 as I am subtracting so repeat letters will continue to decrement accordingly, I will take the absolute value at the end.\\n\\nAfter both strings are looped I take the sum of the absolute values in the hashmap. This will be the steps needed and final answer. Default 0 if hashmap has no values.\\n\\nCan someone think of making this approach more efficient? \\n# Complexity\\n- Time complexity:\\nO(3n) -> so basically O(n)\\nLooping fully through string s, fully through string t, and fully through hashmap to get sum.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int steps = 0;\\n        Map<Character,Integer> hMap = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++){\\n            if (hMap.containsKey(s.charAt(i))){\\n                hMap.put(s.charAt(i), hMap.get(s.charAt(i)) + 1);\\n            }\\n            else {\\n                hMap.put(s.charAt(i), 1);\\n            }\\n        }\\n        for (int i = 0; i < t.length(); i++){\\n            if (hMap.containsKey(t.charAt(i))){\\n                hMap.put(t.charAt(i), hMap.get(t.charAt(i)) - 1);\\n            }\\n            else {\\n                hMap.put(t.charAt(i), -1);\\n            }\\n        }\\n        steps = hMap.values().stream().map(Math::abs).reduce(Integer::sum).orElse(0);\\n        return steps;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int steps = 0;\\n        Map<Character,Integer> hMap = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++){\\n            if (hMap.containsKey(s.charAt(i))){\\n                hMap.put(s.charAt(i), hMap.get(s.charAt(i)) + 1);\\n            }\\n            else {\\n                hMap.put(s.charAt(i), 1);\\n            }\\n        }\\n        for (int i = 0; i < t.length(); i++){\\n            if (hMap.containsKey(t.charAt(i))){\\n                hMap.put(t.charAt(i), hMap.get(t.charAt(i)) - 1);\\n            }\\n            else {\\n                hMap.put(t.charAt(i), -1);\\n            }\\n        }\\n        steps = hMap.values().stream().map(Math::abs).reduce(Integer::sum).orElse(0);\\n        return steps;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042056,
                "title": "simple-hashmap-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n      HashMap<Character,Integer> hs = new HashMap<>();\\n      for(Character ch : s.toCharArray()){\\n          hs.put(ch,hs.getOrDefault(ch,0)+1);\\n      }\\n      int count=0;\\n      for(Character ch : t.toCharArray()){\\n          if(hs.containsKey(ch)){\\n              int val=hs.get(ch);\\n              if(val != 0 ){\\n                  val--;\\n                  hs.put(ch,val);\\n              }else{\\n                  count++;\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      for(int value: hs.values()){\\n          if(value !=0){\\n              count= count+value;\\n          }\\n      }     \\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n      HashMap<Character,Integer> hs = new HashMap<>();\\n      for(Character ch : s.toCharArray()){\\n          hs.put(ch,hs.getOrDefault(ch,0)+1);\\n      }\\n      int count=0;\\n      for(Character ch : t.toCharArray()){\\n          if(hs.containsKey(ch)){\\n              int val=hs.get(ch);\\n              if(val != 0 ){\\n                  val--;\\n                  hs.put(ch,val);\\n              }else{\\n                  count++;\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      for(int value: hs.values()){\\n          if(value !=0){\\n              count= count+value;\\n          }\\n      }     \\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030775,
                "title": "simple-solution-beats-100",
                "content": "\\n```\\nimport string\\n\\nclass Solution(object):\\n    def minSteps(self, s, t):\\n        diff = 0\\n        for char in list(string.ascii_lowercase):\\n            diff += abs(s.count(char)-t.count(char))\\n        return diff\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport string\\n\\nclass Solution(object):\\n    def minSteps(self, s, t):\\n        diff = 0\\n        for char in list(string.ascii_lowercase):\\n            diff += abs(s.count(char)-t.count(char))\\n        return diff\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009537,
                "title": "12ms-98-java-map-and-no-map",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n#  Map - 115ms\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character , Integer> mp = new HashMap<>();\\n\\n        for(char c : s.toCharArray()){\\n            if(mp.containsKey(c)) mp.put( c , mp.get(c)+1);\\n            else mp.put(c,1);\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            if(mp.containsKey(c)) mp.put( c , mp.get(c)-1);\\n            else mp.put(c,-1);\\n        }\\n        \\n        int count = 0;\\n\\n        for(var e : mp.values()){\\n            count += Math.abs(e);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\n# No Map - 12ms\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int [] arr = new int[26];\\n\\n        for(char c : s.toCharArray()){\\n            arr[c - \\'a\\'] ++;\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            arr[c - \\'a\\'] --;\\n        }\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<26; i++){\\n            count += Math.abs(arr[i]);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character , Integer> mp = new HashMap<>();\\n\\n        for(char c : s.toCharArray()){\\n            if(mp.containsKey(c)) mp.put( c , mp.get(c)+1);\\n            else mp.put(c,1);\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            if(mp.containsKey(c)) mp.put( c , mp.get(c)-1);\\n            else mp.put(c,-1);\\n        }\\n        \\n        int count = 0;\\n\\n        for(var e : mp.values()){\\n            count += Math.abs(e);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int [] arr = new int[26];\\n\\n        for(char c : s.toCharArray()){\\n            arr[c - \\'a\\'] ++;\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            arr[c - \\'a\\'] --;\\n        }\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<26; i++){\\n            count += Math.abs(arr[i]);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967200,
                "title": "c-linq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSteps(string s, string t) {\\n        return t.Aggregate(\\n                s.Aggregate(\\n                    new int[26],\\n                    (a, b) =>\\n                    {\\n                        a[b - \\'a\\']++;\\n                        return a;\\n                    }\\n                )\\n            ,\\n            (a, b) =>\\n            {\\n                a[b- \\'a\\']--;\\n                return a;\\n            }\\n            ).Select(x=>Math.Abs(x)).Sum();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSteps(string s, string t) {\\n        return t.Aggregate(\\n                s.Aggregate(\\n                    new int[26],\\n                    (a, b) =>\\n                    {\\n                        a[b - \\'a\\']++;\\n                        return a;\\n                    }\\n                )\\n            ,\\n            (a, b) =>\\n            {\\n                a[b- \\'a\\']--;\\n                return a;\\n            }\\n            ).Select(x=>Math.Abs(x)).Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952942,
                "title": "easy-solution-using-strings-and-hash-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n       for(auto i:s)\\n       {\\n           mp[i]++;\\n       } \\n       int count=0;\\n       for(auto i:t)\\n       {\\n           if(mp[i]>0)\\n           {\\n               mp[i]--;\\n           }\\n           else{\\n               count++;\\n           }\\n       }\\n       for(auto i:mp)\\n       {\\n           count+=i.second;\\n       }\\n       return count;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n       for(auto i:s)\\n       {\\n           mp[i]++;\\n       } \\n       int count=0;\\n       for(auto i:t)\\n       {\\n           if(mp[i]>0)\\n           {\\n               mp[i]--;\\n           }\\n           else{\\n               count++;\\n           }\\n       }\\n       for(auto i:mp)\\n       {\\n           count+=i.second;\\n       }\\n       return count;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922544,
                "title": "beginner-friendly-easy-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, int>mp;\\n\\n        for(auto x : s){\\n            mp[x]++;\\n        }\\n\\n        for(auto x : t){\\n            mp[x]--;\\n            if(mp[x]==0){\\n                mp.erase(x);\\n            }\\n        }\\n        int ans  = 0;\\n        for(auto x: mp){\\n            ans += abs(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, int>mp;\\n\\n        for(auto x : s){\\n            mp[x]++;\\n        }\\n\\n        for(auto x : t){\\n            mp[x]--;\\n            if(mp[x]==0){\\n                mp.erase(x);\\n            }\\n        }\\n        int ans  = 0;\\n        for(auto x: mp){\\n            ans += abs(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897586,
                "title": "using-tree-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> l=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(l.containsKey(s.charAt(i))){\\n                int g=l.get(s.charAt(i));\\n                g=g+1;\\n                l.put(s.charAt(i),g);\\n            }\\n            else{\\n                l.put(s.charAt(i),1);\\n            }\\n        }\\n    HashMap<Character,Integer>fl=new HashMap<>();\\n        for(int j=0;j<t.length();j++){\\n            if(fl.containsKey(t.charAt(j))){\\n                int g1=fl.get(t.charAt(j));\\n                g1=g1+1;\\n                fl.put(t.charAt(j),g1);\\n            }\\n            else{\\n                fl.put(t.charAt(j),1);\\n            }\\n        }\\n        System.out.println(l);\\n        System.out.println(fl);\\n        if(l.equals(fl)){\\n            return 0;\\n        }\\n        int e=0;\\n for (Map.Entry<Character, Integer> entry : l.entrySet()) {\\n            char key = entry.getKey();\\n            if(fl.containsKey(key)){\\n                if(fl.get(key)>=l.get(key)){\\n                    e=e+(fl.get(key)-l.get(key));\\n                    l.put(key,fl.get(key));\\n                    \\n                }\\n                else{\\n                    e=e+(l.get(key)-fl.get(key));\\n                    fl.put(key,l.get(key));\\n                }\\n            }\\n            else{\\n                   e=e+l.get(key);\\n                    fl.put(key,l.get(key));\\n            }\\n        }\\n        for(Map.Entry<Character,Integer> g:fl.entrySet()){\\n            char key1=g.getKey();\\n            if(l.containsKey(key1)){\\n                if(l.get(key1)>=fl.get(key1)){\\n                    e=e+(l.get(key1)-fl.get(key1));\\n                    fl.put(key1,l.get(key1));\\n                }\\n                else{\\n                    e=e+(fl.get(key1)-l.get(key1));\\n                    l.put(key1,fl.get(key1));\\n                }\\n            }\\n            else{\\n                e=e+fl.get(key1);\\n                l.put(key1,fl.get(key1));\\n            }\\n        }\\n        System.out.println(l);\\n        System.out.println(fl);\\n\\n\\n\\n        return e;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> l=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(l.containsKey(s.charAt(i))){\\n                int g=l.get(s.charAt(i));\\n                g=g+1;\\n                l.put(s.charAt(i),g);\\n            }\\n            else{\\n                l.put(s.charAt(i),1);\\n            }\\n        }\\n    HashMap<Character,Integer>fl=new HashMap<>();\\n        for(int j=0;j<t.length();j++){\\n            if(fl.containsKey(t.charAt(j))){\\n                int g1=fl.get(t.charAt(j));\\n                g1=g1+1;\\n                fl.put(t.charAt(j),g1);\\n            }\\n            else{\\n                fl.put(t.charAt(j),1);\\n            }\\n        }\\n        System.out.println(l);\\n        System.out.println(fl);\\n        if(l.equals(fl)){\\n            return 0;\\n        }\\n        int e=0;\\n for (Map.Entry<Character, Integer> entry : l.entrySet()) {\\n            char key = entry.getKey();\\n            if(fl.containsKey(key)){\\n                if(fl.get(key)>=l.get(key)){\\n                    e=e+(fl.get(key)-l.get(key));\\n                    l.put(key,fl.get(key));\\n                    \\n                }\\n                else{\\n                    e=e+(l.get(key)-fl.get(key));\\n                    fl.put(key,l.get(key));\\n                }\\n            }\\n            else{\\n                   e=e+l.get(key);\\n                    fl.put(key,l.get(key));\\n            }\\n        }\\n        for(Map.Entry<Character,Integer> g:fl.entrySet()){\\n            char key1=g.getKey();\\n            if(l.containsKey(key1)){\\n                if(l.get(key1)>=fl.get(key1)){\\n                    e=e+(l.get(key1)-fl.get(key1));\\n                    fl.put(key1,l.get(key1));\\n                }\\n                else{\\n                    e=e+(fl.get(key1)-l.get(key1));\\n                    l.put(key1,fl.get(key1));\\n                }\\n            }\\n            else{\\n                e=e+fl.get(key1);\\n                l.put(key1,fl.get(key1));\\n            }\\n        }\\n        System.out.println(l);\\n        System.out.println(fl);\\n\\n\\n\\n        return e;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895654,
                "title": "faster-than-97-65-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst static auto fast = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26);\\n        vector<int> arr1(26);\\n        for (auto i: s){\\n            arr[i - 97]++;\\n        }\\n        for (auto j: t){\\n            arr1[j - 97]++;\\n        }\\n        int ans = 0;\\n        for (auto i: s){\\n            arr1[i - 97]--;\\n        }\\n        for (auto i: arr1){\\n            if (i > 0){\\n                ans += i;             \\n            }\\n        }\\n        for (auto i: t){\\n            arr[i - 97]--;\\n        }\\n        for (auto i: arr){\\n            if (i > 0){\\n                ans += i;             \\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst static auto fast = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26);\\n        vector<int> arr1(26);\\n        for (auto i: s){\\n            arr[i - 97]++;\\n        }\\n        for (auto j: t){\\n            arr1[j - 97]++;\\n        }\\n        int ans = 0;\\n        for (auto i: s){\\n            arr1[i - 97]--;\\n        }\\n        for (auto i: arr1){\\n            if (i > 0){\\n                ans += i;             \\n            }\\n        }\\n        for (auto i: t){\\n            arr[i - 97]--;\\n        }\\n        for (auto i: arr){\\n            if (i > 0){\\n                ans += i;             \\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3895196,
                "title": "basic-c-approach",
                "content": "# Intuition\\nBring out the common characters count from the two strings\\n\\n# Approach\\nTo solve this problem, the basic idea is to calculate the count of characters that are common to both the strings, For this you can use a data structure such as map.\\nNote: We are only concerned with the numbers of the common characters and not the characters itself.\\nFirst iterate through the first string and store it in data structure\\nNext, iterate through the second string and check if it was present in data structure, if present increment the count\\nAfter the loops end the result can be calculated by difference of the string length and common characters.\\n\\n# Complexity\\n- Time complexity:\\n$O(N)$\\n\\n- Space complexity:\\n$O(N)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        int common=0;\\n        for(auto& it:s)\\n        mp[it]++;\\n        for(auto& it:t)\\n        {\\n            if(mp[it])\\n            {\\n                mp[it]--;\\n                common++;\\n            }\\n        }\\n        return s.size()+t.size()-2*common;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        int common=0;\\n        for(auto& it:s)\\n        mp[it]++;\\n        for(auto& it:t)\\n        {\\n            if(mp[it])\\n            {\\n                mp[it]--;\\n                common++;\\n            }\\n        }\\n        return s.size()+t.size()-2*common;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886833,
                "title": "minimum-number-of-steps-to-make-two-strings-anagram-ii-very-simple-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        map<char,int>mpp;\\n\\n        for(auto it:s)\\n        {\\n            mpp[it]++;\\n        }\\n\\n        for(auto it:t)\\n        {\\n            mpp[it]--;\\n        }\\n\\n        int ans=0;\\n        for(auto it:mpp)\\n        {\\n            ans+=abs(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        map<char,int>mpp;\\n\\n        for(auto it:s)\\n        {\\n            mpp[it]++;\\n        }\\n\\n        for(auto it:t)\\n        {\\n            mpp[it]--;\\n        }\\n\\n        int ans=0;\\n        for(auto it:mpp)\\n        {\\n            ans+=abs(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882237,
                "title": "very-easy-short-c-solution-unordered-map",
                "content": "# Intuition\\nThe sum of absolute difference between the occurences of all char in both the strings is our answer\\n\\n# Approach\\nJust Traverse both the strings and store the frequency of each character in the map. The sum of the difference in frequency is our answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, pair<int, int>> mp;\\n        int ans = 0;\\n\\n        for(char c : s){\\n            mp[c].first++;\\n        }\\n        for(char c : t){\\n            mp[c].second++;\\n        }\\n        for(auto it : mp){\\n            ans += abs(it.second.second - it.second.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, pair<int, int>> mp;\\n        int ans = 0;\\n\\n        for(char c : s){\\n            mp[c].first++;\\n        }\\n        for(char c : t){\\n            mp[c].second++;\\n        }\\n        for(auto it : mp){\\n            ans += abs(it.second.second - it.second.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874312,
                "title": "c-time-o-m-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Have an array to store the count of each character from s\\n- Iterate each character in t and decrement from the array\\n- Sum up all the absolute numer from the array to get the answer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m + n), where m is length of s and n is length of t\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSteps(string s, string t) {\\n        int[] arr = new int[26];\\n\\n        foreach(char c in s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n\\n        foreach(char c in t)\\n        {\\n            arr[c - \\'a\\']--;\\n        }\\n\\n        return arr.Select(num => Math.Abs(num)).Sum();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSteps(string s, string t) {\\n        int[] arr = new int[26];\\n\\n        foreach(char c in s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n\\n        foreach(char c in t)\\n        {\\n            arr[c - \\'a\\']--;\\n        }\\n\\n        return arr.Select(num => Math.Abs(num)).Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873528,
                "title": "2186-minimum-number-of-steps-to-make-two-strings-anagram-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n\\n\\n        HashMap<Character,Integer> s1 = new HashMap<>();\\n\\n         for(char c : s.toCharArray()){\\n             s1.put(c,s1.getOrDefault(c,0)+1);\\n         }\\n         \\n         for(char c : t.toCharArray()){\\n             s1.put(c,s1.getOrDefault(c,0)-1);\\n         }\\n         int step = 0;\\n\\n         for(int count : s1.values()){\\n             step += Math.abs(count);\\n         }\\n         return step;\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n\\n\\n        HashMap<Character,Integer> s1 = new HashMap<>();\\n\\n         for(char c : s.toCharArray()){\\n             s1.put(c,s1.getOrDefault(c,0)+1);\\n         }\\n         \\n         for(char c : t.toCharArray()){\\n             s1.put(c,s1.getOrDefault(c,0)-1);\\n         }\\n         int step = 0;\\n\\n         for(int count : s1.values()){\\n             step += Math.abs(count);\\n         }\\n         return step;\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870790,
                "title": "slightly-improve-the-code-from-1347-minimum-number-of-steps-to-make-two-strings-anagram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust slightly improve the code from 1347, but check in two ways now.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        s_count = Counter(s)\\n        t_count = Counter(t)\\n        result = 0\\n        print(s_count)\\n        print(t_count)\\n\\n        for key, count in s_count.items():\\n            if key not in t_count:\\n                result += count\\n            elif count > t_count[key]:\\n                result += (count - t_count[key])\\n\\n        for key, count in t_count.items():\\n            if key not in s_count:\\n                result += count\\n            elif count > s_count[key]:\\n                result += (count - s_count[key])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        s_count = Counter(s)\\n        t_count = Counter(t)\\n        result = 0\\n        print(s_count)\\n        print(t_count)\\n\\n        for key, count in s_count.items():\\n            if key not in t_count:\\n                result += count\\n            elif count > t_count[key]:\\n                result += (count - t_count[key])\\n\\n        for key, count in t_count.items():\\n            if key not in s_count:\\n                result += count\\n            elif count > s_count[key]:\\n                result += (count - s_count[key])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866623,
                "title": "the-famous-hashmap-boi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution aims to find the minimum number of steps required to make two strings, \\'s\\' and \\'t\\', anagrams of each other. It achieves this by calculating the count of characters in both strings and then identifying the characters that are exclusive to each string. By comparing these exclusive characters\\' frequencies, the solution determines how many characters need to be added or removed in each string to make them anagrams. Finally, the sum of the required changes for both strings gives the minimum steps needed to achieve an anagram.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution employs two unordered maps to store character frequencies for both strings. By subtracting the corresponding character frequencies between the two maps, it computes the count of characters exclusive to each string. The max function is used to ensure that only positive differences are considered, representing the characters that need to be added to one string to match the other. By summing up the changes needed for both strings, the solution provides the minimum steps necessary to make \\'s\\' and \\'t\\' anagrams.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        // char x freq for s and t\\n        unordered_map<char,int> s_chars;\\n        for(char c : s){\\n            s_chars[c]++;\\n        }\\n        unordered_map<char,int> t_chars;\\n        for(char c : t){\\n            t_chars[c]++;\\n        }      \\n\\n\\n        // count the number of characters exclusive in s\\n        int s_exclusive_count = 0;\\n        for(auto it = s_chars.begin(); it != s_chars.end(); ++it){\\n            int curr = it->second - t_chars[it->first];\\n            s_exclusive_count += max(0 , curr);\\n        }\\n        // count eh number of charactes exclusive in t  \\n        int t_exclusive_count = 0;\\n        for(auto it = t_chars.begin(); it != t_chars.end(); ++it){\\n            int curr = it->second - s_chars[it->first];\\n            t_exclusive_count += max(0 , curr);\\n        }      \\n\\n        return s_exclusive_count + t_exclusive_count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        // char x freq for s and t\\n        unordered_map<char,int> s_chars;\\n        for(char c : s){\\n            s_chars[c]++;\\n        }\\n        unordered_map<char,int> t_chars;\\n        for(char c : t){\\n            t_chars[c]++;\\n        }      \\n\\n\\n        // count the number of characters exclusive in s\\n        int s_exclusive_count = 0;\\n        for(auto it = s_chars.begin(); it != s_chars.end(); ++it){\\n            int curr = it->second - t_chars[it->first];\\n            s_exclusive_count += max(0 , curr);\\n        }\\n        // count eh number of charactes exclusive in t  \\n        int t_exclusive_count = 0;\\n        for(auto it = t_chars.begin(); it != t_chars.end(); ++it){\\n            int curr = it->second - s_chars[it->first];\\n            t_exclusive_count += max(0 , curr);\\n        }      \\n\\n        return s_exclusive_count + t_exclusive_count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862448,
                "title": "very-optimal-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s , string t){\\n        vector<int>v(26,0),u(26,0);\\n        int sum=0;\\n        for(auto i:s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto i:t){\\n            u[i-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++){\\n            sum+=(abs(v[i]-u[i]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s , string t){\\n        vector<int>v(26,0),u(26,0);\\n        int sum=0;\\n        for(auto i:s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto i:t){\\n            u[i-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++){\\n            sum+=(abs(v[i]-u[i]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825253,
                "title": "share-my-solution",
                "content": "# Intuition\\n\\nAgain. Focus on fundamentals. It should be obvious that operations, where the characters are added and everything doens\\'t matter. For two strings to be anagrams of each other, they need to contain the same characters. Okay great. But how do we contain the same characters? Just count what characters occur in each string, and get the diff and then sum all the diff up. \\n\\nOne handy trick is to subtract the elements and keep the absolute difference. \\n\\n\\n# Approach\\n\\n1. Count characters in both the strings.\\n2. Sum the absolute difference. That is the result.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n- \\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n\\n        for (char ch: s.toCharArray())\\n            a[ch - \\'a\\']++;\\n\\n        for (char ch: t.toCharArray())\\n            b[ch - \\'a\\']++;   \\n\\n        int cnt = 0;\\n        for (int i=0; i<26; i++) {\\n            cnt+=Math.abs(a[i]-b[i]);\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n\\n        for (char ch: s.toCharArray())\\n            a[ch - \\'a\\']++;\\n\\n        for (char ch: t.toCharArray())\\n            b[ch - \\'a\\']++;   \\n\\n        int cnt = 0;\\n        for (int i=0; i<26; i++) {\\n            cnt+=Math.abs(a[i]-b[i]);\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822209,
                "title": "simple-java-solution-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n+m) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int freq_s[]=new int[26];\\n        int freq_t[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            freq_s[c-\\'a\\']+=1;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            char c=t.charAt(i);\\n            freq_t[c-\\'a\\']+=1;\\n        }\\n        int count=0;\\n        for(int i=0;i<freq_s.length;i++){\\n            if(freq_s[i]>freq_t[i]){\\n                count+=(freq_s[i]-freq_t[i]);\\n            }\\n            if(freq_t[i]>freq_s[i]){\\n                count+=(freq_t[i]-freq_s[i]);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int freq_s[]=new int[26];\\n        int freq_t[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            freq_s[c-\\'a\\']+=1;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            char c=t.charAt(i);\\n            freq_t[c-\\'a\\']+=1;\\n        }\\n        int count=0;\\n        for(int i=0;i<freq_s.length;i++){\\n            if(freq_s[i]>freq_t[i]){\\n                count+=(freq_s[i]-freq_t[i]);\\n            }\\n            if(freq_t[i]>freq_s[i]){\\n                count+=(freq_t[i]-freq_s[i]);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805286,
                "title": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count = 0;\\n        HashMap<Character,Integer> hs = new HashMap<Character,Integer>();\\n        HashMap<Character,Integer> hp = new HashMap<Character,Integer>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            hs.put(s.charAt(i),hs.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            hp.put(t.charAt(i),hp.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> e:hs.entrySet())\\n        {\\n            if(hp.containsKey(e.getKey())==false)\\n            count=count+e.getValue();\\n            else if(e.getValue()!=hp.get(e.getKey()))\\n            count = count+Math.abs(e.getValue()-hp.get(e.getKey()));\\n        }\\n        for(Map.Entry<Character,Integer> e:hp.entrySet())\\n        {\\n            if(hs.containsKey(e.getKey())==false)\\n            count=count+e.getValue();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count = 0;\\n        HashMap<Character,Integer> hs = new HashMap<Character,Integer>();\\n        HashMap<Character,Integer> hp = new HashMap<Character,Integer>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            hs.put(s.charAt(i),hs.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            hp.put(t.charAt(i),hp.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> e:hs.entrySet())\\n        {\\n            if(hp.containsKey(e.getKey())==false)\\n            count=count+e.getValue();\\n            else if(e.getValue()!=hp.get(e.getKey()))\\n            count = count+Math.abs(e.getValue()-hp.get(e.getKey()));\\n        }\\n        for(Map.Entry<Character,Integer> e:hp.entrySet())\\n        {\\n            if(hs.containsKey(e.getKey())==false)\\n            count=count+e.getValue();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1819493,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            },
            {
                "id": 1746067,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            },
            {
                "id": 1708778,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            },
            {
                "id": 1967553,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            },
            {
                "id": 1873949,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Time to Complete Trips",
        "question_content": "<p>You are given an array <code>time</code> where <code>time[i]</code> denotes the time taken by the <code>i<sup>th</sup></code> bus to complete <strong>one trip</strong>.</p>\n\n<p>Each bus can make multiple trips <strong>successively</strong>; that is, the next trip can start <strong>immediately after</strong> completing the current trip. Also, each bus operates <strong>independently</strong>; that is, the trips of one bus do not influence the trips of any other bus.</p>\n\n<p>You are also given an integer <code>totalTrips</code>, which denotes the number of trips all buses should make <strong>in total</strong>. Return <em>the <strong>minimum time</strong> required for all buses to complete <strong>at least</strong> </em><code>totalTrips</code><em> trips</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> time = [1,2,3], totalTrips = 5\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> time = [2], totalTrips = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= time.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= time[i], totalTrips &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1802416,
                "title": "c-answer-on-binary-search-list-of-related-problems",
                "content": "In this type of questions (where question want some minimum/ maximum / at least ) we use concept of Binary search more formally this is a technique which generally called as **\"Answer on Binary Search\"** (some people also say  Binary Search on Answer) .\\n\\n**Brute Force** -\\n\\nWe will check whether the minimum time can be 1 , then 2  , then 3 .......... untill we found an answer.\\n\\n**BInary Search**\\n\\nCan we do something better ? , why we have to check linearly ? instead we can try Binary search , but how ?\\n\\nLet me take a simple scenario -\\n\\nsuppose I take minimum time as 10 and this can not be the minimum time , then 9 also cannot be minimum time , 8 can\\'t in general less than 10 cannot be answer , so instead of check every value we will check using Binary search if we find some valid condition we will move our left and right pointer accordingly.\\n\\n```\\nPSUDO CODE-\\n-------------\\nint check(a,mid)\\n{\\n\\t// find answer using this mid\\n}\\nwhile(l<r)\\n{\\n\\tm = (l+r)/2;\\n\\tif(check(arr,m)>=givenK)\\n\\t//\\tmove left or right accordingly\\n\\telse\\n\\t//\\tmove left or right accordingly\\n}\\nreturn ans;\\n```\\n\\nIn this question , we have to find minimum time \\n- let\\'s take the **lowestTime can be 1** and **highestTime can be as large as 1e14** (10^14) , \\n- now we will find for given **mid** what will be the answer (which is to count totalTrips at time = mid) \\n- if we get **number of trips >= requiredTrips** , then we have to **decrease** the time , that is why I moved my right pointer which is **highestTime** ,\\n- if we get number of **trips < requiredTrips** , then we have to **increase** the time , that is why I moved my left pointer which is **lowestTime**\\n- finally **return lowestTime**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\t// this function will count totalTrips for the given time\\n\\t// a = [1,2,3] , and at time 3 how many trips we can take? \\n\\t// 3/1 + 3/2 + 3/3 => 3 + 1 + 1 = 5 Trips\\n    long long int numberOfTripsForGivenTime(vector<int>&a , long long int givenTime)\\n    {\\n        long long int totalTrips = 0;\\n        for(auto x : a)\\n        {\\n            // convert it to long long int \\n            long long int val = x;\\n\\t\\t\\t\\n            totalTrips += (givenTime / val);\\n        }\\n        return totalTrips;\\n    }\\n    long long minimumTime(vector<int>& arr ,  int totalTrips) {\\n        long long int lowestTime = 1;\\n        long long int highestTime = 1e14;\\n        while(lowestTime<highestTime)\\n        {\\n            long long int mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(arr , mid) >= totalTrips)\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }\\n};\\n```\\n**Time Complexity is - O(NlogD) , where D is 1e14\\nSpace Complexity is - O(1)**\\n\\nAlso If you want to practice more such **\"Answer on Binary Search\"** then you can **check below questions** , also if you find such more add it to comments will update.\\n\\n**Easy**\\nhttps://leetcode.com/problems/arranging-coins/\\n\\n**Medium**\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\nhttps://leetcode.com/problems/find-the-duplicate-number/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/\\nhttps://leetcode.com/problems/koko-eating-bananas/   [google]\\nhttps://leetcode.com/problems/path-with-minimum-effort/\\nhttps://leetcode.com/problems/most-beautiful-item-for-each-query/\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nhttps://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\nhttps://leetcode.com/problems/heaters/\\nhttps://leetcode.com/problems/minimum-absolute-sum-difference/\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n\\n**Hard**\\nhttps://leetcode.com/problems/swim-in-rising-water/\\nhttps://leetcode.com/problems/split-array-largest-sum/ [ good question can be done using DP but BS is amazing][Google]\\nhttps://leetcode.com/problems/kth-smallest-number-in-multiplication-table/\\nhttps://leetcode.com/problems/nth-magical-number/\\nhttps://leetcode.com/problems/find-k-th-smallest-pair-distance/\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/\\n\\nIf you like this , please upvote \\u2B06\\uFE0F.\\nGood Luck , keep coding \\u2764\\uFE0F.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nPSUDO CODE-\\n-------------\\nint check(a,mid)\\n{\\n\\t// find answer using this mid\\n}\\nwhile(l<r)\\n{\\n\\tm = (l+r)/2;\\n\\tif(check(arr,m)>=givenK)\\n\\t//\\tmove left or right accordingly\\n\\telse\\n\\t//\\tmove left or right accordingly\\n}\\nreturn ans;\\n```\n```\\nclass Solution {\\npublic:\\n\\t// this function will count totalTrips for the given time\\n\\t// a = [1,2,3] , and at time 3 how many trips we can take? \\n\\t// 3/1 + 3/2 + 3/3 => 3 + 1 + 1 = 5 Trips\\n    long long int numberOfTripsForGivenTime(vector<int>&a , long long int givenTime)\\n    {\\n        long long int totalTrips = 0;\\n        for(auto x : a)\\n        {\\n            // convert it to long long int \\n            long long int val = x;\\n\\t\\t\\t\\n            totalTrips += (givenTime / val);\\n        }\\n        return totalTrips;\\n    }\\n    long long minimumTime(vector<int>& arr ,  int totalTrips) {\\n        long long int lowestTime = 1;\\n        long long int highestTime = 1e14;\\n        while(lowestTime<highestTime)\\n        {\\n            long long int mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(arr , mid) >= totalTrips)\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266855,
                "title": "all-binary-search-problems",
                "content": "**Good Binary Search Problems**\\n* [1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/)\\n* [1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/)\\n* [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n* [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n* [1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n* [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/)\\n* [1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/)\\n* [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n* [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n* [1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)\\n* [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\\n* [441. Arranging Coins](https://leetcode.com/problems/arranging-coins/)\\n* [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\\n* [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\n* [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)\\n* [1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/)\\n* [1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/)\\n* [2070. Most Beautiful Item for Each Query](https://leetcode.com/problems/most-beautiful-item-for-each-query/)\\n* [475. Heaters](https://leetcode.com/problems/heaters/)\\n* [1818. Minimum Absolute Sum Difference](https://leetcode.com/problems/minimum-absolute-sum-difference/)\\n* [1838. Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)\\n* [778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)\\n* [668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n* [878. Nth Magical Number](https://leetcode.com/problems/nth-magical-number/)\\n* [719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n* [2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\\n* [1287. Element Appearing More Than 25% In Sorted Array](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/)\\n* [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\\n* [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n* [1150. Check If a Number Is Majority Element in a Sorted Array](https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/)\\n* [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [981. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)\\n* [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/)\\n* [704. Binary Search](https://leetcode.com/problems/binary-search/)\\n* [69. Sqrt(x)](https://leetcode.com/problems/sqrtx/)\\n* [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/)\\n* [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)\\n* https://leetcode.com/discuss/interview-question/777057/the-painters-partition-problem \\n* https://www.codechef.com/problems/PREZ \\n* For more problems you can refer to this page :- https://leetcode.com/problemset/all/?topicSlugs=binary-search&page=1 \\n\\n![image](https://assets.leetcode.com/users/images/87bab3dd-fabf-4b71-9ac5-984d9015438e_1678160362.0612018.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "**Good Binary Search Problems**\\n* [1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/)\\n* [1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/)\\n* [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n* [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n* [1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n* [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/)\\n* [1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/)\\n* [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n* [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n* [1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)\\n* [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\\n* [441. Arranging Coins](https://leetcode.com/problems/arranging-coins/)\\n* [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\\n* [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\n* [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)\\n* [1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/)\\n* [1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/)\\n* [2070. Most Beautiful Item for Each Query](https://leetcode.com/problems/most-beautiful-item-for-each-query/)\\n* [475. Heaters](https://leetcode.com/problems/heaters/)\\n* [1818. Minimum Absolute Sum Difference](https://leetcode.com/problems/minimum-absolute-sum-difference/)\\n* [1838. Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)\\n* [778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)\\n* [668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n* [878. Nth Magical Number](https://leetcode.com/problems/nth-magical-number/)\\n* [719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n* [2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\\n* [1287. Element Appearing More Than 25% In Sorted Array](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/)\\n* [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\\n* [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n* [1150. Check If a Number Is Majority Element in a Sorted Array](https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/)\\n* [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [981. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)\\n* [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/)\\n* [704. Binary Search](https://leetcode.com/problems/binary-search/)\\n* [69. Sqrt(x)](https://leetcode.com/problems/sqrtx/)\\n* [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/)\\n* [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)\\n* https://leetcode.com/discuss/interview-question/777057/the-painters-partition-problem \\n* https://www.codechef.com/problems/PREZ \\n* For more problems you can refer to this page :- https://leetcode.com/problemset/all/?topicSlugs=binary-search&page=1 \\n\\n![image](https://assets.leetcode.com/users/images/87bab3dd-fabf-4b71-9ac5-984d9015438e_1678160362.0612018.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802415,
                "title": "python3-java-c-binary-search-1-liner",
                "content": "* For any time `x`, we can have total trips = `\\u03A3(x / time[i]) where i in [0, time.size())` \\n* We need to minimize the above mentioned function total trips such that it is greater than or equal to the given variable `totalTrips`.\\n* We can use binary search.\\n* During the contest I got away with keeping `lo = 1` and `hi = 10 ^ 15`\\n* On further inspection of the problem we can deduce that max value of `x` can be `min(times) * totalTrips` . So that can be used as `hi`\\n<iframe src=\"https://leetcode.com/playground/RaXFHThN/shared\" frameBorder=\"0\" width=\"700\" height=\"300\"></iframe>\\n\\nTime Complexity: `O(nlog(min(time) * totalTrips))`\\n\\n**1 liner**:\\n```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\treturn bisect_left(range(1, 10**14), totalTrips, key= lambda x: sum(x // t for t in time)) + 1\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\treturn bisect_left(range(1, 10**14), totalTrips, key= lambda x: sum(x // t for t in time)) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3266586,
                "title": "java-easy-binary-search-on-answers",
                "content": "**This is what we call Binary Search on Answers. First we need to see that what can be the range of time. The range of time will be lowest value of the time array and highest value will be minimum value in the time array multiplied by totalTrips because at worst case the bus with min time will do all trips which will be minimum time taken to do all trips or you can take maximum value in time array multiplied by totalTrips if you are thinking in this way that at worstcase the bus with highest time will do all the trips. As the question is asking for minimum time so first one makes more sense than later one. But both are correct because obviously it will be eliminating right half if it gets totalTrips done with that particular time. Then we just traverse through the ranges and using Binary Search we check if the totalTrips is possible to do in that time or not. If possible then it\\'s a possible answer and we are not sure that it\\'s our minimum time so we do high=mid and if it\\'s not possible then we move low to mid+1 because obviously we can\\'t perform our task within that time. Atlast we just return the low that points to the minimum time that will take to complete the totalTrips.**\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=Long.MAX_VALUE;\\n        long high=0;\\n        long min=Long.MAX_VALUE;\\n        for(int it:time){\\n            low=Math.min(low,it);\\n            min=Math.min(min,it);\\n        }\\n        high=totalTrips*min;\\n        while(low<high){\\n            long mid=low+(high-low)/2;\\n            if(blackbox(mid,totalTrips,time)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long isvalidtime,int totalTrips,int[] time){\\n        long trips=0;\\n        for(int it:time){\\n            trips+=isvalidtime/it;\\n        }\\n        if(trips>=totalTrips)\\n            return true;\\n        return false;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/548ec5b7-8b53-4a1d-b750-e0c3569edfd7_1678152826.456712.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=Long.MAX_VALUE;\\n        long high=0;\\n        long min=Long.MAX_VALUE;\\n        for(int it:time){\\n            low=Math.min(low,it);\\n            min=Math.min(min,it);\\n        }\\n        high=totalTrips*min;\\n        while(low<high){\\n            long mid=low+(high-low)/2;\\n            if(blackbox(mid,totalTrips,time)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long isvalidtime,int totalTrips,int[] time){\\n        long trips=0;\\n        for(int it:time){\\n            trips+=isvalidtime/it;\\n        }\\n        if(trips>=totalTrips)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266714,
                "title": "clean-codes-full-explanation-binary-search-c-java-python3",
                "content": "# Intuition :\\n- Here we have to find the minimum time by all buses to complete at least `totalTrips` trips.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Detail Explanation to Approach :\\n- Initialize `l` to 1, and `r` to the minimum time required to complete any task multiplied by `totalTrips`. This is because the minimum time required to complete all tasks must be greater than or equal to the minimum time required to complete any single task multiplied by the number of tasks to be completed.\\n```\\n// Initialize the search range for minimum completion time\\nlong l = 1;\\nlong r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n```\\n- Now enter a binary search loop, where calculate the midpoint `m` between `l` and `r`. Then calculate the number of tasks that can be completed in `m` time using the numTrips function. \\n- If the number of completed tasks is greater than or equal to `totalTrips`, set `r` to `m`, since the minimum time required to complete all tasks must be less than or equal to `m`. Otherwise, set `l` to `m+1`, since the minimum time required to complete all tasks must be greater than `m`.\\n```\\nwhile (l < r) {\\n      // Calculate the midpoint of the search range\\n      final long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n```\\n- Once the loop exits, return `l`, which is the minimum time required to complete all tasks.\\n```\\n// Return the minimum completion time\\n    return l;\\n```\\n# numTrips Function :\\n- The `numTrips` function is used to calculate the number of tasks that can be completed within a given time limit `m`. \\n- It takes an array of task completion times `time` and a time limit `m` as input, and returns the number of tasks that can be completed within that time limit.\\n# Working of numTrips Function :\\n- The function first converts the time array to a `LongStream` using the `asLongStream()` method of the Arrays class. This allows us to perform arithmetic operations on the elements of the array as long values, which avoids potential overflow issues when multiplying or dividing large integers.\\n- The function then uses the `reduce()` method of the `LongStream class` to calculate the sum of the floor division of m by each task completion time. The `reduce()` method takes an initial value of 0, which is the starting value for the reduction, and a lambda function that takes two arguments: a `subtotal`, which is the accumulated result of the reduction so far, and an `element of the stream`, which is the next value to be processed.\\n- The lambda function calculates the floor division of `m` by the task completion time, and adds the result to the `subtotal`. The `reduce()` method then returns the final result of the reduction, which is the total number of tasks that can be completed within the time limit `m`.\\n```\\nprivate long numTrips(int[] time, long m) \\n  {\\n    // Convert the time array to a LongStream to avoid overflow issues\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    // Calculate the sum of the floor division of m by each task completion time\\n  }\\n```\\n- In summary, the `numTrips` function calculates the number of tasks that can be completed within a given time limit by iterating through the task completion times and summing the floor division of the time limit by each completion time.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(nlog(min(time)\\u22C5totalTrips))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n***Let\\'s Code it Up .\\nThere may be minor syntax difference in C++ and Python***\\n# Codes [C++ |Java |Python3] : With Comments\\n```Java []\\nclass Solution \\n{\\n  public long minimumTime(int[] time, int totalTrips) \\n  {\\n    // Initialize the search range for minimum completion time\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    // Binary search for minimum completion time\\n    while (l < r) {\\n      // Calculate the midpoint of the search range\\n      final long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n\\n    // Return the minimum completion time\\n    return l;\\n  }\\n\\n  // Helper function to count the number of tasks that can be completed within a given time\\n  private long numTrips(int[] time, long m) \\n  {\\n    // Convert the time array to a LongStream to avoid overflow issues\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    // Calculate the sum of the floor division of m by each task completion time\\n  }\\n}\\n```\\n```C++ []\\nclass Solution {\\n public:\\n  long long minimumTime(vector<int>& time, int totalTrips) {\\n    // Initialize the search range for minimum completion time\\n    long long l = 1;\\n    long long r = *min_element(begin(time), end(time)) * static_cast<long>(totalTrips);\\n\\n    // Binary search for minimum completion time\\n    while (l < r) {\\n      // Calculate the midpoint of the search range\\n      const long long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n\\n    // Return the minimum completion time\\n    return l;\\n  }\\n\\n  // Helper function to count the number of tasks that can be completed within a given time\\n  long numTrips(const vector<int>& times, long m) {\\n    // Calculate the sum of the floor division of m by each task completion time\\n    return accumulate(begin(times), end(times), 0L,\\n                      [&](long subtotal, int t) { return subtotal + m / t; });\\n  }\\n};\\n```\\n```Python []\\nclass Solution:\\n  def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n    # Initialize the search range for minimum completion time\\n    l = 1\\n    r = min(time) * totalTrips\\n\\n    # Binary search for minimum completion time\\n    while l < r:\\n      # Calculate the midpoint of the search range\\n      m = (l + r) // 2\\n      # Count the number of tasks that can be completed within m time\\n      if sum(m // t for t in time) >= totalTrips:\\n        # If enough tasks can be completed within m time, search for smaller time\\n        r = m\\n      else:\\n        # If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1\\n\\n    # Return the minimum completion time\\n    return l\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/0750b919-9f6e-457f-9308-aa10888d887f_1678158066.3233209.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n// Initialize the search range for minimum completion time\\nlong l = 1;\\nlong r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n```\n```\\nwhile (l < r) {\\n      // Calculate the midpoint of the search range\\n      final long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n```\n```\\n// Return the minimum completion time\\n    return l;\\n```\n```\\nprivate long numTrips(int[] time, long m) \\n  {\\n    // Convert the time array to a LongStream to avoid overflow issues\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    // Calculate the sum of the floor division of m by each task completion time\\n  }\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```Java []\\nclass Solution \\n{\\n  public long minimumTime(int[] time, int totalTrips) \\n  {\\n    // Initialize the search range for minimum completion time\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    // Binary search for minimum completion time\\n    while (l < r) {\\n      // Calculate the midpoint of the search range\\n      final long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n\\n    // Return the minimum completion time\\n    return l;\\n  }\\n\\n  // Helper function to count the number of tasks that can be completed within a given time\\n  private long numTrips(int[] time, long m) \\n  {\\n    // Convert the time array to a LongStream to avoid overflow issues\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    // Calculate the sum of the floor division of m by each task completion time\\n  }\\n}\\n```\n```C++ []\\nclass Solution {\\n public:\\n  long long minimumTime(vector<int>& time, int totalTrips) {\\n    // Initialize the search range for minimum completion time\\n    long long l = 1;\\n    long long r = *min_element(begin(time), end(time)) * static_cast<long>(totalTrips);\\n\\n    // Binary search for minimum completion time\\n    while (l < r) {\\n      // Calculate the midpoint of the search range\\n      const long long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n\\n    // Return the minimum completion time\\n    return l;\\n  }\\n\\n  // Helper function to count the number of tasks that can be completed within a given time\\n  long numTrips(const vector<int>& times, long m) {\\n    // Calculate the sum of the floor division of m by each task completion time\\n    return accumulate(begin(times), end(times), 0L,\\n                      [&](long subtotal, int t) { return subtotal + m / t; });\\n  }\\n};\\n```\n```Python []\\nclass Solution:\\n  def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n    # Initialize the search range for minimum completion time\\n    l = 1\\n    r = min(time) * totalTrips\\n\\n    # Binary search for minimum completion time\\n    while l < r:\\n      # Calculate the midpoint of the search range\\n      m = (l + r) // 2\\n      # Count the number of tasks that can be completed within m time\\n      if sum(m // t for t in time) >= totalTrips:\\n        # If enough tasks can be completed within m time, search for smaller time\\n        r = m\\n      else:\\n        # If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1\\n\\n    # Return the minimum completion time\\n    return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802443,
                "title": "java-python-3-binary-search-w-similar-problems",
                "content": "Similar to:\\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446313/)\\n[1287. Element Appearing More Than 25% In Sorted Array](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/discuss/451290/JavaPython-3-O(n)-and-O(logn)-codes-w-brief-explanation-and-analysis.)\\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/discuss/1224657/JavaPython-3-Binary-Search-w-comment-and-brief-analysis.)\\n\\n\\nHere are more similar binary search problem list:\\n\\n[34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n[1011. Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n[1150. Check If a Number Is Majority Element in a Sorted Array: Premium](https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array)\\n[1231. Divide Chocolate: Premium](https://leetcode.com/problems/divide-chocolate/)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets)\\n[1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)\\n\\n---\\n\\nUse binary search to locate the minimum time, which cost `O(nlog(range))`, where `n = time.length, range = upper bound - lower bound`.\\n1. Specify search space range:\\na) lower bound is `0`;\\nb) upper bound:\\n\\nWe need to find worst case in order to get upper bound. \\n\\nAccording to the ranges in the problem, `1 <= time.length <= 10^5;\\n1 <= time[i], totalTrips <= 10^7`.\\n\\nThe less the number of  buses, the greater value of `time` and `totalTrips` are, the more time are needed. We can use the extreme of each, `1`, `10 ^ 7` and `10 ^ 7` to locate the worst case.\\n\\nTherefore, the longest time, the upper bound of the binary search space, `10 ^ 7 * 10 ^ 7`, which corresponds to the worst case that only `1` bus is available and it need to finish `10 ^ 7` trips.\\n\\n2. For each search iteration, try the middle value of the current search space; If in `need` time all buses can NOT finish the `totalTrips`, set lower bound to middle value + 1; otherwise, set upper bound to middle value;\\n3. repeat 2 till lower bound and upper bound are same, and that is our solution.\\n\\n```java\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lo = 0, hi = 100_000_000_000_000L;\\n        while (lo < hi) {\\n            long need = lo + (hi - lo) / 2;\\n            long trips = 0;\\n            for (int t : time) {\\n                trips += need / t;\\n            }\\n            if (trips < totalTrips) {\\n                lo = need + 1;\\n            }else {\\n                hi = need;\\n            }\\n        }\\n        return lo;\\n    }\\n```\\n\\n```python\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        lo, hi = 0, 10 ** 14\\n        while lo < hi:\\n            need = lo + (hi - lo) // 2\\n            trips = sum(need // t for t in time)\\n            if trips < totalTrips:\\n                lo = need + 1\\n            else:\\n                hi = need\\n        return lo\\n```\\n\\nSince Python 3.10, we can simplify the above as:\\n```python\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect.bisect_left(range(10 ** 14), totalTrips, key=lambda i: sum(i // t for t in time))\\n```\\nHere `key` specifies a key function of one argument that is used to extract a comparison key from each element in the array. To support searching complex records, the key function is not applied to the `i` value.\\n\\nFor more details of the new feature, please refer to [python 3 doc](https://docs.python.org/3/library/bisect.html).\\n\\n**Analysis**\\n\\nTime: `O(nlog(range))`, space: `O(1)`, where `n = time.length, range = upper bound - lower bound`.\\n\\n----\\n\\n**Q & A**\\nQ1: Why  in the code you use `hi = need;` not `hi = need - 1;`?\\nA1: This is a boundary condition question.\\n` if (trips < totalTrips)`, the speed, `need`, is definitely less than the solution, and hence we can safely set lower bound as `lo = need + 1;`\\nIn the other `if` conditional branch, `else` statement, `trips >= totalTrips` implies that it is possible `trips == totalTrips` and `need` is solution accordingly, hence we must set upper bound `hi = need` instead of `hi = need - 1`, which could miss the correct solution.\\n\\nQ2: Why in the following code using `Long.MAX_VALUE` as upper bound of the binary search space will cause `long` overflow?\\n```java\\npublic long minimumTime(int[] time, int totalTrips) {\\n\\n    long tmax = Long.MAX_VALUE;\\n    \\n    long tmin = 0;\\n    \\n    while(tmin<=tmax){\\n        \\n        long mid = tmin + (tmax-tmin)/2;\\n        \\n        long t=0;\\n        \\n        for(int i:time){\\n            t = t+mid/i;\\n        }\\n        \\n        if(t<totalTrips){\\n            tmin = mid+1;\\n        }else{\\n            tmax = mid-1;\\n        }\\n        \\n    }\\n   \\n    return tmin;\\n```\\nA2: the summation of the time during the for loop is the culprit:\\n```\\n        for(int i:time){\\n            t = t+mid/i;\\n        }\\n```\\n\\nQ3: How the expressions below are different:\\n`100_000_000_000_000L`, `100000000000000` and `(long) 1e14` ?\\nA3: `100000000000000` is invalid in Java, and the other two are OK.\\n\\n\\n**End of Q & A**\\n\\n----\\n\\nFeel free to ask in case you have any questions. Please **upvote** if the post is helpful.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lo = 0, hi = 100_000_000_000_000L;\\n        while (lo < hi) {\\n            long need = lo + (hi - lo) / 2;\\n            long trips = 0;\\n            for (int t : time) {\\n                trips += need / t;\\n            }\\n            if (trips < totalTrips) {\\n                lo = need + 1;\\n            }else {\\n                hi = need;\\n            }\\n        }\\n        return lo;\\n    }\\n```\n```python\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        lo, hi = 0, 10 ** 14\\n        while lo < hi:\\n            need = lo + (hi - lo) // 2\\n            trips = sum(need // t for t in time)\\n            if trips < totalTrips:\\n                lo = need + 1\\n            else:\\n                hi = need\\n        return lo\\n```\n```python\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect.bisect_left(range(10 ** 14), totalTrips, key=lambda i: sum(i // t for t in time))\\n```\n```java\\npublic long minimumTime(int[] time, int totalTrips) {\\n\\n    long tmax = Long.MAX_VALUE;\\n    \\n    long tmin = 0;\\n    \\n    while(tmin<=tmax){\\n        \\n        long mid = tmin + (tmax-tmin)/2;\\n        \\n        long t=0;\\n        \\n        for(int i:time){\\n            t = t+mid/i;\\n        }\\n        \\n        if(t<totalTrips){\\n            tmin = mid+1;\\n        }else{\\n            tmax = mid-1;\\n        }\\n        \\n    }\\n   \\n    return tmin;\\n```\n```\\n        for(int i:time){\\n            t = t+mid/i;\\n        }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802431,
                "title": "java-c-python-detailed-explanation-with-intuition-o-nlog-k-binary-search-clean-concise",
                "content": "Maximum possible time = ~10^14     (from worst case constraints)\\n\\nDue to this we cannot iterate on time. It will give TLE.\\n\\n**Intution:** If we know total time of journey, then we can get how many trips each bus made.\\n\\nLets me illustrate this with an example:\\n\\nEg:  trip_time= 15,  time=[1, 2, 5]\\nNo. of trips made by bus 0: 15/1 = 15\\nNo. of trips made by bus 1: 15/2 = 7  (not 7.5 complete trips are 7)\\nNo. of trips made by bus 2: 15/5 = 3\\n\\nAnd we can add them all to get total no of trips made by all buses = 15+7+ 3 = 25\\n\\nTotal time of trip lies between 1 and 10^14     (acc to worst case constraints)\\n**Explanation:** \\nassume there is just one bus\\nwhen time[i]=1 & totalTrips=1 : time_of_trip= **1**\\nwhen time[i]= 10^7 & totalTrips=10^7 : time_of_trip= 10^7 * 10^7 = **10^14**\\n\\nTime of trip lies in this range. And as time increases, no of trips increases. \\nSo there will be a time where the no of trips will become just >= totalTrips.\\nWe just need to binary search that time.\\n\\n**C++:** \\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long anstillnow=-1;\\n        \\n        long long left=1, right= 100000000000001;          //can also write this as 1+1e14\\n\\t\\t\\n        while(left<=right){\\n            long long mid= left+ (right-left)/2;   // find mid point like this to avoid overflow\\n            long long curr_trips=0;\\n            for(int t: time){\\n                curr_trips+= mid/t;\\n            }\\n            \\n            if(curr_trips>=totalTrips){ \\n                anstillnow=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return anstillnow;\\n    }\\n};\\n```\\n\\n\\n**Java:**  \\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long anstillnow=-1;\\n        \\n        long left=1, right= 100000000000001L;\\n        \\n        while(left<=right){\\n            long mid= left+ (right-left)/2;  //find mid point like this to avoid overflow\\n            long curr_trips=0;\\n            for(int t: time){\\n                curr_trips+= mid/t;\\n            }\\n            \\n            if(curr_trips>=totalTrips){\\n                anstillnow=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return anstillnow;        \\n    }\\n}\\n```\\n\\n**Python:** \\n```\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        anstillnow=-1;\\n        left=1;\\n        right= 100000000000001;\\n        \\n        while(left<=right):\\n            mid= left+ (right-left)/2      #find mid point like this to avoid overflow\\n            \\n            curr_trips=0;\\n            \\n            for t in time:\\n                curr_trips+= mid/t\\n            \\n            if(curr_trips>=totalTrips):\\n                anstillnow=mid\\n                right=mid-1\\n            \\n            else:\\n                left=mid+1\\n\\n        return anstillnow\\n ```       \\n\\n\\n**Time Complexity Analysis:**\\nTime: O(N log (K))  :     where N is no of buses & K is 10^14 (range of binary search)\\nSpace: O(1) :                No extra space used. \\n\\n\\n\\n\\n**Please upvote if you liked it.**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long anstillnow=-1;\\n        \\n        long long left=1, right= 100000000000001;          //can also write this as 1+1e14\\n\\t\\t\\n        while(left<=right){\\n            long long mid= left+ (right-left)/2;   // find mid point like this to avoid overflow\\n            long long curr_trips=0;\\n            for(int t: time){\\n                curr_trips+= mid/t;\\n            }\\n            \\n            if(curr_trips>=totalTrips){ \\n                anstillnow=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return anstillnow;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long anstillnow=-1;\\n        \\n        long left=1, right= 100000000000001L;\\n        \\n        while(left<=right){\\n            long mid= left+ (right-left)/2;  //find mid point like this to avoid overflow\\n            long curr_trips=0;\\n            for(int t: time){\\n                curr_trips+= mid/t;\\n            }\\n            \\n            if(curr_trips>=totalTrips){\\n                anstillnow=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return anstillnow;        \\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        anstillnow=-1;\\n        left=1;\\n        right= 100000000000001;\\n        \\n        while(left<=right):\\n            mid= left+ (right-left)/2      #find mid point like this to avoid overflow\\n            \\n            curr_trips=0;\\n            \\n            for t in time:\\n                curr_trips+= mid/t\\n            \\n            if(curr_trips>=totalTrips):\\n                anstillnow=mid\\n                right=mid-1\\n            \\n            else:\\n                left=mid+1\\n\\n        return anstillnow\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1802781,
                "title": "binary-search",
                "content": "For a given time `m`, we can calculate how many trips we can complete. So, we can binary-search for the minimum `m`.\\n\\nFor this problem, the tricky part is to find the maximum bound for the search. Took me a few WA to get it right.\\n\\n**C++**\\n```cpp\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n    long long l = 0, r = LLONG_MAX / time.size();\\n    while (l < r) {\\n        long long m = (l + r) / 2, trips = 0;\\n        for (int t : time)\\n            trips += m / t;\\n        if (trips < totalTrips)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n    long long l = 0, r = LLONG_MAX / time.size();\\n    while (l < r) {\\n        long long m = (l + r) / 2, trips = 0;\\n        for (int t : time)\\n            trips += m / t;\\n        if (trips < totalTrips)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802433,
                "title": "python-solution-detailed-article-on-binary-search-on-answer",
                "content": "Upvote this artice if you find this helpful\\u2B06\\uFE0F.\\n### Code: \\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        r = min(time) * totalTrips + 1 # This is the worst case answer possible for any case. Could use big values like 10^15 as well but they might slow the time down for smaller cases.\\n        l = 0\\n        ans = 0\\n\\n        def check_status(expected_time: int) -> int:\\n            nonlocal ans\\n            count = 0\\n            for i in time:\\n                count += expected_time // i # Total trips with time expected_time should be integer part of expected_time // i\\n            if count < totalTrips:\\n                return 1 # Since number of trips are less then required, left moves to mid\\n            elif count >= totalTrips:\\n                ans = expected_time # stores the latest result. This is guaranteed to be the minimum possible answer.\\n                return -1 # Since number of trips are greater/equal to required, right moves to mid\\n\\n        while l < r-1: # Till Binary Search can continue. \\n            mid = (l + r) // 2 # mid is the current expected time.\\n            status = check_status(mid) # The return values 1/-1 in check_status function determines which pointer to move.\\n            if status == 1:\\n                l = mid\\n            else:\\n                r = mid\\n                \\n        return ans\\n```\\n\\n### Concept of Binary Search on Answer:\\nThe best way to explain Binary Search the Answer is that we use binary search to guess the answer to the problem. **By guessing we mean that we will get several \\u201CYES\\u201D or \\u201CNO\\u201D feedback or maybe \\u201Ctoo high\\u201D, \\u201Ctoo low\\u201D, or \\u201Cexactly\\u201D responses.** Since we need the minimum answer Binary Search tries to converge on the smallest possible answer till the possibility exists. \\n\\n**Binary Search on Answer has 3 basic requirements:**\\n1. The problem must have multiple possible answers. ***[Range of possible solutions]***\\n2. The problem must be an optimization problem. ***[Minimizing the possible answer]***\\n3. The problem must have a function/criterion to determine when to update `left` and `right` pointers. ***[Criterion to update pointers]***\\n\\n**NOTE: *Here answers do not mean the minimum possible value (actual answer) but the values that satisfy the totalTrips condition.***\\n**NOTE: *The // operation in python returns the integer value of a division. 8/3 = 2.66 whereas 8//2 = 2. I have used this notation in this article***\\n\\n***Our problem fulfills all the requirements.*** \\n\\n**Requirement 1:** For example if `time = [1,2,3] & totalTrips = 5` then the answer is 3. Now one can easily say that if 3 satisfies the 5 totalTrips condition then 4, 5, 6, 7, ... (basically numbers greater than 3) can easily satisfy the 5 totalTrips condition. Hence their are multiple possible answers.\\n\\n**Requirement 2:** As we saw that for `time = [1,2,3] & totalTrips = 5` then the possible answers could be 3, 4, 5, 6, ... But since the problem asks the smallest time hence the correct answer is 3. Thus we also want to select the minimium possible answer as our final answer.\\n\\n**Requirement 3:** This is the most important part of the problem. For this problem this one is quite straight forward. Take a value, say 8. Traverse over `time` list. `for i = 1` the total number of trips in time 8 is 8//1 = 8 || `for i = 2` total number of trips in time 8 is 8//2 = 4 || `for i = 3` total number of trips in time 8 is 8//3 = 2. The following function is our criterion:\\n```\\ndef check_status(expected_time: int) -> int:\\n    count = 0\\n    for i in time:\\n        count += expected_time // i\\n        if count < totalTrips:\\n            return 1  # Since count is less than the totalTrips, we are searching too low\\n\\t\\t\\t# Update left pointer to mid(expected_time).\\n        elif count >= totalTrips:\\n            return -1  # Since count is greater than / equal to the totalTrips, we are searching too high or perfectly.\\n\\t\\t\\t# Update right pointer to mid(expected_time).\\n```\\nThe updation part is taken care of by the return value of the function 1 for left and -1 for right pointer.\\n\\n**Now look at the code on top of this article.** \\u2B06\\uFE0F\\n\\n### List of problems that also uses Binary Search on Answer:\\n- [https://www.codechef.com/problems/PREZ/](https://www.codechef.com/problems/PREZ)\\n- [https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/)\\n- [https://leetcode.com/problems/arranging-coins/](https://leetcode.com/problems/arranging-coins/)\\n- [https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n- [https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\\n- [https://leetcode.com/problems/find-the-duplicate-number/](https://leetcode.com/problems/find-the-duplicate-number/)\\n- [https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/)\\n- [https://leetcode.com/problems/path-with-minimum-effort/](https://leetcode.com/problems/path-with-minimum-effort/)\\n- [https://leetcode.com/problems/most-beautiful-item-for-each-query/](https://leetcode.com/problems/most-beautiful-item-for-each-query/)\\n- [https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n- [https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/)\\n- [https://leetcode.com/problems/heaters/](https://leetcode.com/problems/heaters/)\\n- [https://leetcode.com/problems/minimum-absolute-sum-difference/](https://leetcode.com/problems/minimum-absolute-sum-difference/)\\n- [https://leetcode.com/problems/frequency-of-the-most-frequent-element/](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)\\n- [https://leetcode.com/problems/swim-in-rising-water/](https://leetcode.com/problems/swim-in-rising-water/)\\n- [https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n- [https://leetcode.com/problems/nth-magical-number/](https://leetcode.com/problems/nth-magical-number/)\\n- [https://leetcode.com/problems/find-k-th-smallest-pair-distance/](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n- [https://leetcode.com/problems/maximum-running-time-of-n-computers/](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        r = min(time) * totalTrips + 1 # This is the worst case answer possible for any case. Could use big values like 10^15 as well but they might slow the time down for smaller cases.\\n        l = 0\\n        ans = 0\\n\\n        def check_status(expected_time: int) -> int:\\n            nonlocal ans\\n            count = 0\\n            for i in time:\\n                count += expected_time // i # Total trips with time expected_time should be integer part of expected_time // i\\n            if count < totalTrips:\\n                return 1 # Since number of trips are less then required, left moves to mid\\n            elif count >= totalTrips:\\n                ans = expected_time # stores the latest result. This is guaranteed to be the minimum possible answer.\\n                return -1 # Since number of trips are greater/equal to required, right moves to mid\\n\\n        while l < r-1: # Till Binary Search can continue. \\n            mid = (l + r) // 2 # mid is the current expected time.\\n            status = check_status(mid) # The return values 1/-1 in check_status function determines which pointer to move.\\n            if status == 1:\\n                l = mid\\n            else:\\n                r = mid\\n                \\n        return ans\\n```\n```\\ndef check_status(expected_time: int) -> int:\\n    count = 0\\n    for i in time:\\n        count += expected_time // i\\n        if count < totalTrips:\\n            return 1  # Since count is less than the totalTrips, we are searching too low\\n\\t\\t\\t# Update left pointer to mid(expected_time).\\n        elif count >= totalTrips:\\n            return -1  # Since count is greater than / equal to the totalTrips, we are searching too high or perfectly.\\n\\t\\t\\t# Update right pointer to mid(expected_time).\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267566,
                "title": "simple-bruteforce-to-crazy-binary-search-code-like-a-pro",
                "content": "# Similar Problems:\\nA very good similar problem is this one:\\n- [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/) You can follow my solution [\\uD83D\\uDC12 KOKO finds Hints then tries Binary Search || \\uD83D\\uDC12\\uD83D\\uDE80 Java C++\\n](https://leetcode.com/problems/koko-eating-bananas/solutions/3273872/koko-finds-hints-then-tries-binary-search-java-c/) The solution is pretty much the same.\\n\\n# Intuition\\nThe very first thing is coding how your mind thinks it should be done. Gradually increasing the time value and incrementing the trips done by each bus.\\n\\nThe bruteforce code:\\n\\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int[] trips = new int[time.length];\\n        int tripsDone = 0;\\n        int t = 0;\\n        while(tripsDone < totalTrips){\\n            t++;\\n            for(int i=0; i<time.length; i++){\\n                trips[i] = (trips[i]+1)%time[i];\\n                if(trips[i]==0){\\n                    tripsDone++;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```\\nThis will result in TLE.\\nSee the problem statement. It clearly says that:\\n![image.png](https://assets.leetcode.com/users/images/05fc1f3f-ed20-43ee-bbb3-e9826e357a49_1678172112.3413932.png)\\n\\nSo, we cannot directly go with the iterative approach.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nThis is an application of binary search. We should try to include binary search. \\n**But how?**\\n**What will be the low and high variables?**\\n\\nThe value of time is very high. So, we better think of this as the high and low value. Then for current time value, we can iterate the loop to calculate the trips completed by each bus.\\n\\nIf the current time is **t** and a bus requires **bt** time to complete a trip, then by t time the bus will complete $$\\\\frac{t}{bt}$$ trips.\\nFor example let\\'s say t = 5. and bus trip completion time is $$bt = 2$$.\\nThen, by time $$t = 5$$, the bus will be able to complete $$5/2 = 2$$ trips.\\n\\n# Binary Search:\\n\\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long maxTime = 100000000000000L;\\n        while(lowestTime < maxTime){\\n            long mid = lowestTime + (maxTime-lowestTime)/2;\\n            if(tripsCompleted(time, mid) >= totalTrips){\\n                maxTime = mid;\\n            }\\n            else{\\n                lowestTime = mid+1;\\n            }\\n        }\\n        return lowestTime;\\n    }\\n\\n    private long tripsCompleted(int[] time, long currentTime){\\n        long totalTrips = 0;\\n        for(int t : time){\\n            long tmp = (long) t;\\n            totalTrips += (currentTime/tmp);\\n        }\\n        return totalTrips;\\n    }\\n}\\n\\n```\\n\\nThis problem has a flaw. This will be less efficient. A more efficient solution is:\\n\\n# Efficient Binary Search - [Beats 94%]\\n\\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long maxTime = 100000000000000L;\\n        while(lowestTime < maxTime){\\n            long mid = lowestTime + (maxTime-lowestTime)/2;\\n            long tripsDone = tripsCompleted(time, mid, totalTrips);\\n            if(tripsDone >= totalTrips){\\n                maxTime = mid;\\n            }\\n            else{\\n                lowestTime = mid+1;\\n            }\\n        }\\n        return lowestTime;\\n    }\\n\\n    private long tripsCompleted(int[] time, long currentTime, int totalTrips){\\n        long tripsDone = 0;\\n        for(int t : time){\\n            long tmp = (long) t;\\n            tripsDone += (currentTime/tmp);\\n            // instead of iterating the loop any further, break the loop.\\n            if(tripsDone >= totalTrips ){\\n                break;\\n            }\\n        }\\n        return tripsDone;\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/f3cd7f8b-9553-4665-9191-d9e536538fa9_1678172716.6669576.png)\\n\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/9e0340e0-c08e-4a47-af6e-a350027c72ee_1678190433.0235791.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int[] trips = new int[time.length];\\n        int tripsDone = 0;\\n        int t = 0;\\n        while(tripsDone < totalTrips){\\n            t++;\\n            for(int i=0; i<time.length; i++){\\n                trips[i] = (trips[i]+1)%time[i];\\n                if(trips[i]==0){\\n                    tripsDone++;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long maxTime = 100000000000000L;\\n        while(lowestTime < maxTime){\\n            long mid = lowestTime + (maxTime-lowestTime)/2;\\n            if(tripsCompleted(time, mid) >= totalTrips){\\n                maxTime = mid;\\n            }\\n            else{\\n                lowestTime = mid+1;\\n            }\\n        }\\n        return lowestTime;\\n    }\\n\\n    private long tripsCompleted(int[] time, long currentTime){\\n        long totalTrips = 0;\\n        for(int t : time){\\n            long tmp = (long) t;\\n            totalTrips += (currentTime/tmp);\\n        }\\n        return totalTrips;\\n    }\\n}\\n\\n```\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long maxTime = 100000000000000L;\\n        while(lowestTime < maxTime){\\n            long mid = lowestTime + (maxTime-lowestTime)/2;\\n            long tripsDone = tripsCompleted(time, mid, totalTrips);\\n            if(tripsDone >= totalTrips){\\n                maxTime = mid;\\n            }\\n            else{\\n                lowestTime = mid+1;\\n            }\\n        }\\n        return lowestTime;\\n    }\\n\\n    private long tripsCompleted(int[] time, long currentTime, int totalTrips){\\n        long tripsDone = 0;\\n        for(int t : time){\\n            long tmp = (long) t;\\n            tripsDone += (currentTime/tmp);\\n            // instead of iterating the loop any further, break the loop.\\n            if(tripsDone >= totalTrips ){\\n                break;\\n            }\\n        }\\n        return tripsDone;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266509,
                "title": "binary-search-optimized-approach-easy-to-understand-detailed-explanation",
                "content": "\\n# Approach\\n1. minimum time can be 1, less than 1 can not possible.\\n2. maximum time can be (minimum element of given time array * total trips).\\n3. we use binary search to chose optimally minimum time that can be required to complete total trips\\n4. when number of trips completed by \\'mid\\' time >= total trips, then our ans can be \\'mid\\' time, but less than \\'mid\\' time can be possible, so we reduce our search space.\\n5. when number of trips completed by \\'mid\\' time < total trips, then our ans can not be \\'mid\\' time, but greater than \\'mid\\' time can be possible, so we increase our start to increase mid.\\n# Complexity\\n- Time complexity:$$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long func(vector<int>&time, long long k)\\n    {\\n        long long ans=0;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            ans+= k/time[i];\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) \\n    {\\n        long long s=1,e,ans=LONG_MAX;\\n        e = 1LL*(*min_element(time.begin(),time.end())) * totalTrips;\\n        while(s<=e)\\n        {\\n            long long mid = s + (e-s)/2;\\n            long long x = func(time,mid);\\n            if(x>=totalTrips)\\n            {\\n                ans = min(ans,mid);\\n                e = mid-1;\\n            }\\n            else\\n            {\\n                s = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you feel this helpful then plz like and upvote this solution \\uD83D\\uDE0A\\nKEEP LEETCODING.............**\\n![upvote.png](https://assets.leetcode.com/users/images/01c55ef2-d34a-413f-b2cd-cc638dfc6117_1678151467.055072.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long func(vector<int>&time, long long k)\\n    {\\n        long long ans=0;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            ans+= k/time[i];\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) \\n    {\\n        long long s=1,e,ans=LONG_MAX;\\n        e = 1LL*(*min_element(time.begin(),time.end())) * totalTrips;\\n        while(s<=e)\\n        {\\n            long long mid = s + (e-s)/2;\\n            long long x = func(time,mid);\\n            if(x>=totalTrips)\\n            {\\n                ans = min(ans,mid);\\n                e = mid-1;\\n            }\\n            else\\n            {\\n                s = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266915,
                "title": "white-board-solution-easiest-binary-search-video-solution",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=NsXc-YNqnfE\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/73825ad0-f66c-4f7e-a372-c12538816db5_1678162987.0952618.png)\\n![image.png](https://assets.leetcode.com/users/images/edc9d287-1793-4912-bc9d-71e51c86107f_1678163002.0131874.png)\\n![image.png](https://assets.leetcode.com/users/images/bd7fe1b1-6594-40b7-93bc-f55fb5fe3c61_1678163020.4106433.png)\\n![image.png](https://assets.leetcode.com/users/images/c6612f6b-22cf-45e6-96a5-c87bbf249033_1678163032.5668771.png)\\n![image.png](https://assets.leetcode.com/users/images/27acffb8-af92-4113-9881-5a7cebb7c61a_1678163050.3291006.png)\\n![image.png](https://assets.leetcode.com/users/images/5a20110f-873b-4961-8f51-47ebe7fdb057_1678163064.138637.png)\\n![image.png](https://assets.leetcode.com/users/images/2ab6d9d8-507d-46cb-925c-d6fd4baf3981_1678163071.8577886.png)\\n![image.png](https://assets.leetcode.com/users/images/87fc699d-0ff2-4b56-83ff-3e7edf30fdbc_1678163085.2459826.png)\\n\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    bool is_possible(ll max_time, vector<int>& time, int totalTrips){\\n        ll number_of_trips_completed = 0;\\n        for(auto t : time){\\n            number_of_trips_completed += max_time/t;\\n        }\\n        return (number_of_trips_completed >= totalTrips);\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l=1, r=(1e14);\\n        while(l < r){\\n            ll mid = (l+r)/2;\\n            if(is_possible(mid, time, totalTrips)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    bool is_possible(ll max_time, vector<int>& time, int totalTrips){\\n        ll number_of_trips_completed = 0;\\n        for(auto t : time){\\n            number_of_trips_completed += max_time/t;\\n        }\\n        return (number_of_trips_completed >= totalTrips);\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l=1, r=(1e14);\\n        while(l < r){\\n            ll mid = (l+r)/2;\\n            if(is_possible(mid, time, totalTrips)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266718,
                "title": "leetcode-the-hard-way-binary-search",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\nThis is a classic problem of finding the smallest integer given a bound under a monotonic function.\\n\\nWe can perform binary search on the time needed to finish the trips, and we check that if we are able to complete totalTrips within the given amount of time. There are two components to this solution:\\n\\n- Binary Searching the smallest amount of time\\n- Checking if totalTrips can be completed given a time\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 0;\\n        long long r = 1LL * time[0] * totalTrips;\\n        while (l < r) {\\n            long long m = l + (r - l) / 2, trips = 0;\\n            for (auto x : time) trips += (m / x);\\n            if (trips < totalTrips) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        l, r = 0, time[0] * totalTrips\\n        while l < r:\\n            m = (l + r) // 2\\n            if sum(m // t for t in time) < totalTrips:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 0;\\n        long long r = 1LL * time[0] * totalTrips;\\n        while (l < r) {\\n            long long m = l + (r - l) / 2, trips = 0;\\n            for (auto x : time) trips += (m / x);\\n            if (trips < totalTrips) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        l, r = 0, time[0] * totalTrips\\n        while l < r:\\n            m = (l + r) // 2\\n            if sum(m // t for t in time) < totalTrips:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802813,
                "title": "c-binary-search-are-you-getting-tle-for-hidden-testcase-try-this",
                "content": "**Use long long and upper bound for end = 1e16.\\nmaximum bound = min(time) * totalTrips\\nIn worst case, we only use the fastest bus to complete all trips.\\nCredits - [tbne1905](https://leetcode.com/tbne1905/)\\nExplanation ->**\\nThis problem follows the same patterns a Koko eating bananas or Cutting Ropes or Shipping Packages problems.\\n\\nWhen we identify a range of possibilties and we are asked to minimize or maximize, think binary search. Here, the maximum possibleTime we can take is just getting the sum of all times and multiplying them with total trips. Minimum possible time is the minimum time in the list of times given.\\n\\nNow that we have our range, we apply bianry search on it. Cumpute the midTime. With this as our totalTime, see if it is possible to make the totalTrips. Since our goal is to MINIMIZE, we have 2 options:\\n\\n1.Reduce the range by moving the right ptr towards mid if we CAN make totalTrips.\\n2.Increase the range of values by moving left towards mid if we CAN\\'T make totalTrips\\n\\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n\\n\\tlong long start = 0 , end = 1e16;\\n\\n\\tlong long c = 1e16;\\n\\n\\twhile(start <= end)\\n\\t{\\n\\t\\tlong long mid = start + ((end-start)/2);\\n\\n\\t\\tlong long trip = 0;\\n\\t\\tfor(auto &val : time)\\n\\t\\t{\\n\\t\\t\\tlong long b = val;\\n\\t\\t\\ttrip += (mid/b);\\n\\t\\t\\tif(trip > totalTrips)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(trip >= totalTrips) \\n\\t\\t{\\n\\t\\t\\tc = min(c,mid);\\n\\t\\t\\tend = mid-1;\\n\\t\\t}\\n\\t\\telse start = mid+1;\\n\\n        }\\n        \\n        return c;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "**Use long long and upper bound for end = 1e16.\\nmaximum bound = min(time) * totalTrips\\nIn worst case, we only use the fastest bus to complete all trips.\\nCredits - [tbne1905](https://leetcode.com/tbne1905/)\\nExplanation ->**\\nThis problem follows the same patterns a Koko eating bananas or Cutting Ropes or Shipping Packages problems.\\n\\nWhen we identify a range of possibilties and we are asked to minimize or maximize, think binary search. Here, the maximum possibleTime we can take is just getting the sum of all times and multiplying them with total trips. Minimum possible time is the minimum time in the list of times given.\\n\\nNow that we have our range, we apply bianry search on it. Cumpute the midTime. With this as our totalTime, see if it is possible to make the totalTrips. Since our goal is to MINIMIZE, we have 2 options:\\n\\n1.Reduce the range by moving the right ptr towards mid if we CAN make totalTrips.\\n2.Increase the range of values by moving left towards mid if we CAN\\'T make totalTrips\\n\\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n\\n\\tlong long start = 0 , end = 1e16;\\n\\n\\tlong long c = 1e16;\\n\\n\\twhile(start <= end)\\n\\t{\\n\\t\\tlong long mid = start + ((end-start)/2);\\n\\n\\t\\tlong long trip = 0;\\n\\t\\tfor(auto &val : time)\\n\\t\\t{\\n\\t\\t\\tlong long b = val;\\n\\t\\t\\ttrip += (mid/b);\\n\\t\\t\\tif(trip > totalTrips)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(trip >= totalTrips) \\n\\t\\t{\\n\\t\\t\\tc = min(c,mid);\\n\\t\\t\\tend = mid-1;\\n\\t\\t}\\n\\t\\telse start = mid+1;\\n\\n        }\\n        \\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1802710,
                "title": "python-easy-binary-search",
                "content": "```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\tif len(time) == 1:\\n\\t\\treturn totalTrips * time[0]\\n\\n\\tl, r = 0, 10**15\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\n\\t\\tres = 0\\n\\t\\tfor t in time:\\n\\t\\t\\tres += mid // t\\n\\n\\t\\tif res >= totalTrips:\\n\\t\\t\\tr = mid\\n\\t\\telse:\\n\\n\\t\\t\\tl = mid + 1\\n\\n\\treturn l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\tif len(time) == 1:\\n\\t\\treturn totalTrips * time[0]\\n\\n\\tl, r = 0, 10**15\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\n\\t\\tres = 0\\n\\t\\tfor t in time:\\n\\t\\t\\tres += mid // t\\n\\n\\t\\tif res >= totalTrips:\\n\\t\\t\\tr = mid\\n\\t\\telse:\\n\\n\\t\\t\\tl = mid + 1\\n\\n\\treturn l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802463,
                "title": "c-easy-to-understand-binary-seach-o-nlogn",
                "content": "Goal: find the minimum time required to complete atleast totalTrips.\\nApproach: \\n```\\nwe can find the maximum number of trips for a given amount of time.\\n          let\\'s t be the time then \\n                maximum trips = (time[0]/t)+(time[1]/t)+...+(time[n-1]/t)\\n                                          where n is the size of time\\n          if the maximum trips are greater and equal to totalTrips then \\n                    assign the ans to t and search in the left of t\\n          else search in the right of t\\n```\\n\\ncode: \\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        // sort the time in non-decreasing order\\n        sort(time.begin(),time.end());\\n        \\n        long long l=0,h=(long long)time.back()*totalTrips;\\n        long long ans;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long cnt=0;\\n            // for a given amount of time (i.e. mid) caluculate the maximum number of trips\\n            for(int i=0;i<time.size();i++)\\n            {\\n                if(time[i]>mid)\\n                    break;\\n                cnt+=(mid/time[i]);\\n            }\\n            // if count is greater than the trips then assume that to be answer\\n            // and search in the range [l,mid-1]\\n            if(cnt>=totalTrips)\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            // else search in the range [mid+1,h]\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\ntime complexity:  O(nlogn)\\nspace complexity: O(1)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nwe can find the maximum number of trips for a given amount of time.\\n          let\\'s t be the time then \\n                maximum trips = (time[0]/t)+(time[1]/t)+...+(time[n-1]/t)\\n                                          where n is the size of time\\n          if the maximum trips are greater and equal to totalTrips then \\n                    assign the ans to t and search in the left of t\\n          else search in the right of t\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        // sort the time in non-decreasing order\\n        sort(time.begin(),time.end());\\n        \\n        long long l=0,h=(long long)time.back()*totalTrips;\\n        long long ans;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long cnt=0;\\n            // for a given amount of time (i.e. mid) caluculate the maximum number of trips\\n            for(int i=0;i<time.size();i++)\\n            {\\n                if(time[i]>mid)\\n                    break;\\n                cnt+=(mid/time[i]);\\n            }\\n            // if count is greater than the trips then assume that to be answer\\n            // and search in the range [l,mid-1]\\n            if(cnt>=totalTrips)\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            // else search in the range [mid+1,h]\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802526,
                "title": "simple-binary-search-with-explanation-c",
                "content": "We find the minimum element in the given vector, So this is the minimum time taken by a single bus to complete one trip.\\n\\nNow, if we consider we are only using that single bus, the time taken to complete all the trips would be ( (time taken by the bus) * (total no. of trips) ). So the answer could be the this value or below it.\\nNow, we can binary search over the time range to get minimum time.\\n\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& time, long long trips, long long t){\\n        int n = time.size();\\n        long long cnt = 0;\\n        for(int i=0;i<n;i++){ // for present t, evaluating how many trips are possible.\\n            cnt += (t/time[i]);\\n        }\\n        if(cnt>=trips) return true; // if the cnt is greater than or equal to required trips, then return true, else false.\\n        return false;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int trips) {\\n        int minm = INT_MAX;\\n        for(int i=0;i<time.size();i++){ // finding minm element\\n            minm = min(minm,time[i]);\\n        }\\n        long long l=0, r=((long long)minm)*trips; // lower bound and upper bound for ans.\\n        long long ans = 0;\\n        while(l<=r){ // binary search over the time range\\n            long long mid = l + (r-l)/2;\\n            if(solve(time,trips,mid)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote if it helps**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& time, long long trips, long long t){\\n        int n = time.size();\\n        long long cnt = 0;\\n        for(int i=0;i<n;i++){ // for present t, evaluating how many trips are possible.\\n            cnt += (t/time[i]);\\n        }\\n        if(cnt>=trips) return true; // if the cnt is greater than or equal to required trips, then return true, else false.\\n        return false;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int trips) {\\n        int minm = INT_MAX;\\n        for(int i=0;i<time.size();i++){ // finding minm element\\n            minm = min(minm,time[i]);\\n        }\\n        long long l=0, r=((long long)minm)*trips; // lower bound and upper bound for ans.\\n        long long ans = 0;\\n        while(l<=r){ // binary search over the time range\\n            long long mid = l + (r-l)/2;\\n            if(solve(time,trips,mid)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802440,
                "title": "simple-java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        Arrays.sort(time);\\n        long low = 1, high = Long.MAX_VALUE;\\n        long minTime = Long.MAX_VALUE;\\n        while(low<=high){\\n            long mid = low + (high-low)/2;\\n            long numTrips = 0;\\n            for(int t: time){\\n                // if repeated summation of large mid values(comparable to Long.MAX_VALUE) and small trip time \\'t\\' causes overflow - identify, bring upper bound down and break the loop\\n                numTrips += mid/t;\\n                if(numTrips<0)\\n                {\\n                    high = mid-1;\\n                    break;\\n                }\\n            }\\n            if(numTrips<0)\\n                continue;\\n\\n            if( numTrips >= totalTrips){\\n                high = mid-1;\\n                minTime = Math.min(mid, minTime);\\n            }else if(numTrips < totalTrips){\\n                low = mid+1;\\n            }\\n        }\\n        return minTime;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        Arrays.sort(time);\\n        long low = 1, high = Long.MAX_VALUE;\\n        long minTime = Long.MAX_VALUE;\\n        while(low<=high){\\n            long mid = low + (high-low)/2;\\n            long numTrips = 0;\\n            for(int t: time){\\n                // if repeated summation of large mid values(comparable to Long.MAX_VALUE) and small trip time \\'t\\' causes overflow - identify, bring upper bound down and break the loop\\n                numTrips += mid/t;\\n                if(numTrips<0)\\n                {\\n                    high = mid-1;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3269256,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        #define ll long long\\n        ll start = 1;\\n        ll end = 1e14;\\n        while(start <= end){\\n            ll trip = 0;\\n            ll mid = start + (end - start)/2;\\n            for(int i=0;i<time.size();i++)\\n                trip += mid / time[i];\\n            if(trip < totalTrips){\\n                start = mid + 1;\\n            }\\n            else \\n                end = mid - 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        #define ll long long\\n        ll start = 1;\\n        ll end = 1e14;\\n        while(start <= end){\\n            ll trip = 0;\\n            ll mid = start + (end - start)/2;\\n            for(int i=0;i<time.size();i++)\\n                trip += mid / time[i];\\n            if(trip < totalTrips){\\n                start = mid + 1;\\n            }\\n            else \\n                end = mid - 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267547,
                "title": "binary-search-and-brute-force-solution-approach-explained",
                "content": "# Intuition\\nThe brute force approach would be to start from time t=1 and increase it to check whether we can achieve the required number of trips in time t. This approach would cause TLE because of the constraints given.\\n\\n\\n# Approach\\nNow from the brute force approach we can work towards a better solution. In the brute force approach we are using all values of time between t=1 to the maximum time needed. The maximum time needed would be totalTrips*(maximum time taken by a bus to complete one trip).\\n\\nNow, instead of exploring all the values in the range, we can use binary search to find the minimum value.\\n1. The minimum time would be 1 second. So, **low=1**. The maximum time would be **high=totalTrips * (maximum value in time array)** .\\n2. Until low<high we will do the following:\\n    - Find the mid value: **mid=(low+high)/2**.\\n    - Now, we would check whether it is enough to complete the totalTrips in mid time. Each bus would do **mid/time[i]** trips. We can iterate the array time to calculate the total trips. \\n    - If the mid value is more than enough to take  totalTrips number of trips. Then our range would become low to mid (we are including mid as it can be the lowest value too).\\n    But if it\\'s not enough the range would be mid+1 to high.\\n    \\n\\n# Code\\n### 1. Brute force \\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        long long trips=0;  // trips would store the trips completed until t time\\n        int t=1; \\n        while(trips<totalTrips){ // if trips==totalTrips, we can break out of the loop \\n            for(int i=0;i<time.size();++i){ \\n                if(t%time[i]==0) trips++; // if t is divisble by time[i] that means bus i has completed one more trip in time t.\\n            }\\n            t++;\\n        }\\n        return t-1;\\n}\\n    \\n```\\n### 2. Binary Search\\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n    long long maxtime=*max_element(time.begin(),time.end()); // maximum time taken by a bus to complete one trip\\n    long long l=1, r=totalTrips*maxtime; // time range in which minimum time lies\\n    while(l<r){\\n        long long mid=(l+r)/2, actualTrips=0; // actualTrips would store the trips completed in time 0 to mid.\\n        for(int i=0;i<time.size();i++){\\n            actualTrips+=mid/time[i]; \\n        }\\n        if(actualTrips<totalTrips) l=mid+1; // if the time mid is not enough, then the range would become  mid+1 to r.\\n        else r=mid; // if the time mid is enough than the minimum lies in the range l to mid.\\n    }\\n    return l;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        long long trips=0;  // trips would store the trips completed until t time\\n        int t=1; \\n        while(trips<totalTrips){ // if trips==totalTrips, we can break out of the loop \\n            for(int i=0;i<time.size();++i){ \\n                if(t%time[i]==0) trips++; // if t is divisble by time[i] that means bus i has completed one more trip in time t.\\n            }\\n            t++;\\n        }\\n        return t-1;\\n}\\n    \\n```\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n    long long maxtime=*max_element(time.begin(),time.end()); // maximum time taken by a bus to complete one trip\\n    long long l=1, r=totalTrips*maxtime; // time range in which minimum time lies\\n    while(l<r){\\n        long long mid=(l+r)/2, actualTrips=0; // actualTrips would store the trips completed in time 0 to mid.\\n        for(int i=0;i<time.size();i++){\\n            actualTrips+=mid/time[i]; \\n        }\\n        if(actualTrips<totalTrips) l=mid+1; // if the time mid is not enough, then the range would become  mid+1 to r.\\n        else r=mid; // if the time mid is enough than the minimum lies in the range l to mid.\\n    }\\n    return l;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266483,
                "title": "simple-solution-based-on-similar-problems-binary-search",
                "content": "# Intuition\\nIt doesn\\'t get apparent at first how Binary Search can be applied here but you have to notice that the answer lies between a range. It is either:\\n-Minimum value of $$time[i]$$ (when totalTrips=1)\\n-Maximum value of $$time[i]*totalTrips$$ (when time has only 1 element)\\nThis pattern will repeat for every test case. The first one is the most intuitive, if we only had to make one round. \\n\\n# Approach\\nHow exactly do we fit Binary Search into this? We need to find the $$left$$ and $$right$$ pointers. \\nI just assumed $$left$$ to be 1, as in any imaginable testcase, the best answer will be 1.\\nFor $$right$$, there are a couple of techniques but the simplest is to find the maximum value of any $$time[i]*totalTrips$$. Think about the case when all elements in the array have the same value. \\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long l=1; \\n        long max=0;\\n        for(int x:time) max=Math.max(max,x);\\n        long h=max*totalTrips; //compute upper limit\\n\\n        while(l<h){\\n            long mid=l+(h-l)/2;\\n            if(compute(time,mid,totalTrips)){\\n                h=mid; \\n            //if mid is a valid answer, it can be the answer\\n            } \\n            else l=mid+1;\\n        }\\n        return h;\\n    }\\n    public boolean compute(int[] time,long key,int totalTrips){\\n//This part of the code has been used in problems like \\n// Leetcode 1011\\n        long trips=0;\\n        for(int x:time){\\n            trips+= key/x; \\n        //number of trips made by a bus is total time/time it takes \\n        //the bus to complete one trip\\n\\n            if(trips>=totalTrips) break;\\n        //early return when we already satisfy our trips condition\\n        }\\n        if(trips>=totalTrips) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long l=1; \\n        long max=0;\\n        for(int x:time) max=Math.max(max,x);\\n        long h=max*totalTrips; //compute upper limit\\n\\n        while(l<h){\\n            long mid=l+(h-l)/2;\\n            if(compute(time,mid,totalTrips)){\\n                h=mid; \\n            //if mid is a valid answer, it can be the answer\\n            } \\n            else l=mid+1;\\n        }\\n        return h;\\n    }\\n    public boolean compute(int[] time,long key,int totalTrips){\\n//This part of the code has been used in problems like \\n// Leetcode 1011\\n        long trips=0;\\n        for(int x:time){\\n            trips+= key/x; \\n        //number of trips made by a bus is total time/time it takes \\n        //the bus to complete one trip\\n\\n            if(trips>=totalTrips) break;\\n        //early return when we already satisfy our trips condition\\n        }\\n        if(trips>=totalTrips) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266465,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using binary search by setting the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips. We can then use a helper function to calculate the total number of trips completed for each bus at any given time, and based on that, determine whether the current minimum time is too high or too low. We can continue updating the search space until we find the minimum time required to complete totalTrips trips.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips. The minimum time required for each bus to complete totalTrips trips is the minimum time taken by any bus multiplied by totalTrips, and the maximum time required is the sum of times taken by all buses multiplied by totalTrips.\\n2. Use binary search to find the minimum time required to complete totalTrips trips. For each mid-point time value, calculate the total number of trips completed for each bus using a helper function.\\n3. If the total number of trips completed is greater than or equal to totalTrips, the current mid-point time is a valid candidate for the minimum time required. Therefore, update the search space to the lower half of the current range.\\n4. If the total number of trips completed is less than totalTrips, the current mid-point time is too high, and we need to increase the minimum time required. Therefore, update the search space to the upper half of the current range.\\n5. Continue updating the search space until the minimum time required to complete totalTrips trips is found.\\n\\n\\n# Complexity\\n- Time complexity: The time complexity of the binary search algorithm used in the solution is $$O(log n)$$, where n is the range of possible minimum times required for all buses to complete at least totalTrips trips. For each mid-point time value, the helper function calculates the total number of trips completed by all buses, which takes $$O(n)$$ time. Therefore, the overall time complexity of the solution is $$O(n log n)$$, where n is the length of the input array time.\\n\\n- Space complexity: The space complexity of the solution is $$O(1)$$, as we are only using constant space to store the input array and a few variables.\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```Java []\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    while (l < r) {\\n      final long m = (l + r) / 2;\\n      if (numTrips(time, m) >= totalTrips)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return l;\\n  }\\n\\n  private long numTrips(int[] time, long m) {\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n  }\\n}\\n\\n```\\n```Python []\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        l = 1\\n        r = min(time) * totalTrips\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            if self.numTrips(time, m) >= totalTrips:\\n                r = m\\n            else:\\n                l = m + 1\\n\\n        return l\\n\\n    def numTrips(self, time, m):\\n        return sum(m // t for t in time)\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1;\\n        long long r = *min_element(time.begin(), time.end()) * (long long) totalTrips;\\n\\n        while (l < r) {\\n            long long m = (l + r) / 2;\\n            if (numTrips(time, m) >= totalTrips)\\n                r = m;\\n            else\\n                l = m + 1;\\n        }\\n\\n        return l;\\n    }\\n\\n    long long numTrips(vector<int>& time, long long m) {\\n        long long num = 0;\\n        for (int t : time) {\\n            num += m / t;\\n        }\\n        return num;\\n    }\\n};\\n\\n```\\n```\\n# Commented  version of Java code for better understanding \\n\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        // Initialize the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips.\\n        // The minimum time required for each bus to complete totalTrips trips is the minimum time taken by any bus multiplied by totalTrips, and the maximum time required is the sum of times taken by all buses multiplied by totalTrips.\\n        long l = 1;\\n        long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n        \\n        // Use binary search to find the minimum time required to complete totalTrips trips.\\n        while (l < r) {\\n            // Calculate the mid-point time value.\\n            final long m = (l + r) / 2;\\n            \\n            // Calculate the total number of trips completed for all buses at the mid-point time value.\\n            long numTrips = numTrips(time, m);\\n            \\n            // If the total number of trips completed is greater than or equal to totalTrips, the current mid-point time is a valid candidate for the minimum time required.\\n            // Therefore, update the search space to the lower half of the current range.\\n            if (numTrips >= totalTrips)\\n                r = m;\\n            // If the total number of trips completed is less than totalTrips, the current mid-point time is too high, and we need to increase the minimum time required.\\n            // Therefore, update the search space to the upper half of the current range.\\n            else\\n                l = m + 1;\\n        }\\n        \\n        // Return the minimum time required to complete totalTrips trips.\\n        return l;\\n    }\\n    \\n    // Helper function to calculate the total number of trips completed by all buses at any given time.\\n    private long numTrips(int[] time, long m) {\\n        // Calculate the total number of trips completed for each bus at the mid-point time value.\\n        // The total number of trips completed for a bus is the floor division of m by the time taken by the bus.\\n        // We then sum up the total number of trips completed for all buses.\\n        return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    }\\n}\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```Java []\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    while (l < r) {\\n      final long m = (l + r) / 2;\\n      if (numTrips(time, m) >= totalTrips)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return l;\\n  }\\n\\n  private long numTrips(int[] time, long m) {\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n  }\\n}\\n\\n```\n```Python []\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        l = 1\\n        r = min(time) * totalTrips\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            if self.numTrips(time, m) >= totalTrips:\\n                r = m\\n            else:\\n                l = m + 1\\n\\n        return l\\n\\n    def numTrips(self, time, m):\\n        return sum(m // t for t in time)\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1;\\n        long long r = *min_element(time.begin(), time.end()) * (long long) totalTrips;\\n\\n        while (l < r) {\\n            long long m = (l + r) / 2;\\n            if (numTrips(time, m) >= totalTrips)\\n                r = m;\\n            else\\n                l = m + 1;\\n        }\\n\\n        return l;\\n    }\\n\\n    long long numTrips(vector<int>& time, long long m) {\\n        long long num = 0;\\n        for (int t : time) {\\n            num += m / t;\\n        }\\n        return num;\\n    }\\n};\\n\\n```\n```\\n# Commented  version of Java code for better understanding \\n\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        // Initialize the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips.\\n        // The minimum time required for each bus to complete totalTrips trips is the minimum time taken by any bus multiplied by totalTrips, and the maximum time required is the sum of times taken by all buses multiplied by totalTrips.\\n        long l = 1;\\n        long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n        \\n        // Use binary search to find the minimum time required to complete totalTrips trips.\\n        while (l < r) {\\n            // Calculate the mid-point time value.\\n            final long m = (l + r) / 2;\\n            \\n            // Calculate the total number of trips completed for all buses at the mid-point time value.\\n            long numTrips = numTrips(time, m);\\n            \\n            // If the total number of trips completed is greater than or equal to totalTrips, the current mid-point time is a valid candidate for the minimum time required.\\n            // Therefore, update the search space to the lower half of the current range.\\n            if (numTrips >= totalTrips)\\n                r = m;\\n            // If the total number of trips completed is less than totalTrips, the current mid-point time is too high, and we need to increase the minimum time required.\\n            // Therefore, update the search space to the upper half of the current range.\\n            else\\n                l = m + 1;\\n        }\\n        \\n        // Return the minimum time required to complete totalTrips trips.\\n        return l;\\n    }\\n    \\n    // Helper function to calculate the total number of trips completed by all buses at any given time.\\n    private long numTrips(int[] time, long m) {\\n        // Calculate the total number of trips completed for each bus at the mid-point time value.\\n        // The total number of trips completed for a bus is the floor division of m by the time taken by the bus.\\n        // We then sum up the total number of trips completed for all buses.\\n        return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    }\\n}\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802834,
                "title": "javascript-100-faster-easy-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/35d4495c-5c3a-4fd4-a1ab-3fee1c822970_1645936250.7609615.png)\\n\\n```\\nvar minimumTime = function(time, totalTrips) {\\n    let low = 1;\\n    let high = Number.MAX_SAFE_INTEGER;\\n    let ans = 0;\\n    \\n    while(low <= high) {\\n        let mid = Math.floor(low + (high - low) / 2); // to prevent overflow\\n        \\n        if(isPossible(time, mid, totalTrips)) {\\n            ans = mid\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\nfunction isPossible(arr, mid, totalTrips) {\\n    let trips = 0;\\n    for (let i = 0; i < arr.length; i++) {\\n      trips += Math.floor(mid / arr[i]);\\n    }\\n    return trips >= totalTrips;\\n}\\n```\\n\\nhard luck today : / , just after the contest My solution got accepted, happens...",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar minimumTime = function(time, totalTrips) {\\n    let low = 1;\\n    let high = Number.MAX_SAFE_INTEGER;\\n    let ans = 0;\\n    \\n    while(low <= high) {\\n        let mid = Math.floor(low + (high - low) / 2); // to prevent overflow\\n        \\n        if(isPossible(time, mid, totalTrips)) {\\n            ans = mid\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\nfunction isPossible(arr, mid, totalTrips) {\\n    let trips = 0;\\n    for (let i = 0; i < arr.length; i++) {\\n      trips += Math.floor(mid / arr[i]);\\n    }\\n    return trips >= totalTrips;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802621,
                "title": "c-binary-search",
                "content": "```\\n// I have implemented this by Binary Search\\n\\n\\nclass Solution {\\npublic:\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long left =0, right=1e14,mid;\\n        \\n        while(left <= right){\\n            \\n            mid=(left +right)/2; // calculating the mid value\\n            long long ans=0;     //store the number of days\\n            \\n            for(int i=0;i<time.size();i++)  //find the sum of time taken by buses till the \"mid\" index of array\\n                ans+= mid/time[i];\\n            \\n            if(ans < totalTrips) left =mid+1;   //if ans < totalTrips, then we have to go to right block\\n            \\n            else right=mid-1;       // go to the left block\\n            \\n        }\\n            \\n        return left;    \\n            \\n        \\n    }\\n};\\n```\\nPlease **Upvote**, if you liked my solution.\\nDont forget to visit my repo: https://github.com/tarunsahnan/LeetCode-Solutions\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// I have implemented this by Binary Search\\n\\n\\nclass Solution {\\npublic:\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long left =0, right=1e14,mid;\\n        \\n        while(left <= right){\\n            \\n            mid=(left +right)/2; // calculating the mid value\\n            long long ans=0;     //store the number of days\\n            \\n            for(int i=0;i<time.size();i++)  //find the sum of time taken by buses till the \"mid\" index of array\\n                ans+= mid/time[i];\\n            \\n            if(ans < totalTrips) left =mid+1;   //if ans < totalTrips, then we have to go to right block\\n            \\n            else right=mid-1;       // go to the left block\\n            \\n        }\\n            \\n        return left;    \\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802466,
                "title": "java-binary-search-with-explanation",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        //The idea is given value mid, can we finish totalTrips within mid time. \\n        //We have left and right bound, we want to find mid in the boundary.\\n        \\n        //Key point: We CANNOT directly set right to Long.MAX_VALUE\\n        //Reason: \\n        //We will get very large  (right - left) / 2 + left, and it will cause overflow if our elements in time array is small\\n        //Therefore, we set right bound to maximum time we need which is (the min value in time array * totalTrips)\\n        \\n        long left = 1;\\n        //find min value in time array\\n        long min = time[0];\\n        for(int t : time){\\n            min = Math.min(min, t);\\n        }\\n        long right = totalTrips * min;\\n        \\n        while(left < right){\\n            long mid = (right - left) / 2 + left;\\n            \\n            //How many trip we can do\\n            long total = 0;\\n            for(int t : time){\\n                total += mid / t;\\n            }\\n            \\n            //We cannot reach totalTrips, means mid is too small\\n            if(total < totalTrips){\\n                left = mid + 1;\\n            }else{\\n                //We can reach totalTrips, but we want right to be as small as possible \\n                //Therefore, we don\\'t need to + 1\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```\\nNote (idea from [@rizbanul08](https://leetcode.com/rizbanul08)):\\nYou can use Long.MAX_VALUE if you change the total\\'s \"long\" type to \"double\" type.\\nHowever,  total is always integer, and it might cause some problems using double in other question.\\nYou can store larger numbers in a double, but you will lose precision.\\nExample:\\n```\\nclass Solution\\n{\\n\\n    public static void main(String[] args)\\n    {\\n        long   long1 = Long.MAX_VALUE - 100L;\\n        double dbl1  = long1;\\n        long   long2 = long1+1;\\n        double dbl2  = dbl1+1;\\n\\n        System.out.printf(\"%d %d\\\\n%f %f\", long1, long2, dbl1, dbl2);\\n    }\\n\\n}\\n```\\nThis outputs:\\n9223372036854775707 9223372036854775708\\n9223372036854776000.000000 9223372036854776000.000000",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        //The idea is given value mid, can we finish totalTrips within mid time. \\n        //We have left and right bound, we want to find mid in the boundary.\\n        \\n        //Key point: We CANNOT directly set right to Long.MAX_VALUE\\n        //Reason: \\n        //We will get very large  (right - left) / 2 + left, and it will cause overflow if our elements in time array is small\\n        //Therefore, we set right bound to maximum time we need which is (the min value in time array * totalTrips)\\n        \\n        long left = 1;\\n        //find min value in time array\\n        long min = time[0];\\n        for(int t : time){\\n            min = Math.min(min, t);\\n        }\\n        long right = totalTrips * min;\\n        \\n        while(left < right){\\n            long mid = (right - left) / 2 + left;\\n            \\n            //How many trip we can do\\n            long total = 0;\\n            for(int t : time){\\n                total += mid / t;\\n            }\\n            \\n            //We cannot reach totalTrips, means mid is too small\\n            if(total < totalTrips){\\n                left = mid + 1;\\n            }else{\\n                //We can reach totalTrips, but we want right to be as small as possible \\n                //Therefore, we don\\'t need to + 1\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\n    public static void main(String[] args)\\n    {\\n        long   long1 = Long.MAX_VALUE - 100L;\\n        double dbl1  = long1;\\n        long   long2 = long1+1;\\n        double dbl2  = dbl1+1;\\n\\n        System.out.printf(\"%d %d\\\\n%f %f\", long1, long2, dbl1, dbl2);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271339,
                "title": "simplest-solution-binary-search-well-explained-c-easy-to-understand",
                "content": "**Approach: Binary Search**\\n\\n**Intuition**\\n\\nTo efficiently find the minimum valid time to finish total trips, we can use binary search instead of a brute force approach. This is because trying every time from the smallest is likely to exceed the time limit, given the constraints in the question.\\n\\nTo use binary search, we can observe that there is a pattern in the time taken for each bus to complete total trips. By combining this pattern with the fact that we know the maximum time taken by one trip, we can determine whether a given time is long enough to finish all trips or not.\\n\\nTo implement binary search, we first initialize the search space with the left boundary set to 1 and the right boundary set to totalTrips times the maximum time taken by one trip. This ensures that the minimum time is included in the search space.\\n\\nWe then check if the middle time is long enough. If it is not, we cut the half of the search space containing smaller times. Otherwise, we cut the half containing larger times. We repeat this process until there is only one time left, which is the minimum valid time.\\n\\nTo check if a given time is sufficient, we iterate over the input and use the formula introduced above (each bus can complete mid / time[i] trips). This allows us to efficiently find the minimum valid time to finish total trips without exceeding the time limit.\\n\\n**C++ Code:**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool check(vector<int>& time,long long n,long long totalTrips){\\n\\t\\t\\tlong long sum=0;\\n\\t\\t\\tfor(int i=0;i<time.size();i++){\\n\\t\\t\\t\\tsum+=(n/time[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn sum>=totalTrips;\\n\\t\\t}\\n\\n\\t\\tlong long minimumTime(vector<int>& time, int totalTrips) {\\n\\t\\t\\tlong long l=-1,r=1e14,mid;\\n\\t\\t\\twhile(r-l>1){\\n\\t\\t\\t\\tmid=(l+r)/2;\\n\\t\\t\\t\\tif(check(time,mid,totalTrips)){\\n\\t\\t\\t\\t\\tr=mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tl=mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool check(vector<int>& time,long long n,long long totalTrips){\\n\\t\\t\\tlong long sum=0;\\n\\t\\t\\tfor(int i=0;i<time.size();i++){\\n\\t\\t\\t\\tsum+=(n/time[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3269955,
                "title": "c-easy-sol-beats-100-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can see from the constraints that our solution must be in $$O(nlogn)$$ format so I decided to formulate a set of time in which our answer is also present and using binary search to find the minimum time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - **How guess Time complexity required for question using contraints :-**\\nConstraints were :- Array of max 10^5 length \\nNow imgaine you were fomulating a solution of $$O(n^2)$$ so total time unit taken would be 10^10 and for $$O(nlogn)$$ around 10^6. One thing that you need to know is that in general 10^8 operations take 1 second time and it is usually the time limit of the questions if not given. So for the given question time complexity must be $$O(nlogn)$$ or lower.\\n - **How to make the set** \\n We can see that max length and trip is 10^7 so in my solution i took max time to be 10^14 because it won\\'t reach beyond that. Minimum time taken cannot be lower than 1.\\n - **Check function**\\n It calculate the trips that can be made in particular time and than check if the trips are more or less than required and if conditions are met returns true else false;\\n - **Dividing Condition**\\n if particular selected time i.e $$mid$$ trips can be made than we store that in answer and search for another answer in lesser time (lower half) as we need to find it in minimum possible time. We we cannot make the trips in that time than we need to search in upper half. \\n# Complexity\\n- Time complexity: $$O(NlogK)$$\\nwhere N is the length of the array and K is 10^14\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int totalTrips,vector<int>&time,long long trips)\\n    {\\n        long long count=0;\\n        for(auto i:time)\\n        {\\n            count+=trips/i;\\n            if(count>=totalTrips)return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l=1,h=10e14;\\n        long long ans;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            if(check(totalTrips,time,mid))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int totalTrips,vector<int>&time,long long trips)\\n    {\\n        long long count=0;\\n        for(auto i:time)\\n        {\\n            count+=trips/i;\\n            if(count>=totalTrips)return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l=1,h=10e14;\\n        long long ans;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            if(check(totalTrips,time,mid))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268560,
                "title": "c-binary-search-easiest-approach-100-faster",
                "content": "# Intuition\\nSince it was a minimise the maximum kind of problem a very classic problem usually solved by binary search \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo we should use $$binary\\\\ search$$ as well \\nHere we will assume an aswer and try to verify that our assumed answer is possible or not. Our answer may lie between 1 sec to the time taken if all the trip was made by the maximum time taking bus. \\nFinding maximum will be adding another O(N) to our solution, avoiding that in our case, so according to the constraints the maximum possible answer will be LONG_MAX so we set our high limit as the same. Then we will use binary search to search our answer in the range if answer exists then we will find another better answer that is minimum then the previous.\\nFor determining whether the probable answer is possible or not we can iterate over the array and count how many trips would be completed by each bus in the probable time(mid).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(LLONG\\\\_MAX))$$ where in n is the size of the array time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ as no extra space used \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& time, int totalTrips, long long mid){\\n        long long count = 0;\\n        for(int i = 0; i < time.size(); i++){\\n            count += mid / time[i];\\n            if(count >= totalTrips) return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low = 1;\\n        long long high = LLONG_MAX;\\n        long long ans;\\n        while(low <= high){\\n            long long mid = low + (high - low) / 2;\\n            if(isPossible(time, totalTrips, mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            } else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please Upvote my Solution\\n<img align=\"centre\" src = \"https://assets.leetcode.com/users/images/1e169185-d032-4861-8f46-bd971f57ad4f_1678191359.4894545.png\" \\nstyle=\"display: block; margin-right: auto; margin-left: auto;\" width= \"300\" height=\"300\">",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& time, int totalTrips, long long mid){\\n        long long count = 0;\\n        for(int i = 0; i < time.size(); i++){\\n            count += mid / time[i];\\n            if(count >= totalTrips) return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low = 1;\\n        long long high = LLONG_MAX;\\n        long long ans;\\n        while(low <= high){\\n            long long mid = low + (high - low) / 2;\\n            if(isPossible(time, totalTrips, mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            } else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266954,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minimumTime(vector<int>& v, int t) {\\n        long long i=1,j=1LL*(v[v.size()-1])*t;\\n        long long ans=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll tot=0;\\n            for(int k=0;k<v.size();k++)tot+=m/v[k];\\n            if(tot>=t){\\n                ans=m;\\n                j=m-1;\\n            }\\n            else i=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/65b6449b-6f58-45e6-80d7-7852dab98c19_1678163677.5049846.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minimumTime(vector<int>& v, int t) {\\n        long long i=1,j=1LL*(v[v.size()-1])*t;\\n        long long ans=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll tot=0;\\n            for(int k=0;k<v.size();k++)tot+=m/v[k];\\n            if(tot>=t){\\n                ans=m;\\n                j=m-1;\\n            }\\n            else i=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266933,
                "title": "detailed-solution-with-approach",
                "content": "- Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\\n- Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\\n- In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\\n- Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\\n- If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\\n- Otherwise, update the lower bound lo to the mid value plus one.\\n- Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\\n- Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array.\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n    long lo = 1;\\n    long hi = Long.MAX_VALUE;\\n\\n    while (lo < hi) {\\n        long mid = lo + (hi - lo) / 2;\\n        long completedTrips=0;\\n        for (int t : time) {\\n            completedTrips += mid / t;\\n            if (completedTrips >= totalTrips) break;\\n        }\\n        if (completedTrips>=totalTrips) {\\n            hi = mid;\\n        } else {\\n            lo = mid + 1;\\n        }\\n    }\\n    return lo;\\n    }\\n}\\n```\\n# UPVOTE if you liked the approach",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n    long lo = 1;\\n    long hi = Long.MAX_VALUE;\\n\\n    while (lo < hi) {\\n        long mid = lo + (hi - lo) / 2;\\n        long completedTrips=0;\\n        for (int t : time) {\\n            completedTrips += mid / t;\\n            if (completedTrips >= totalTrips) break;\\n        }\\n        if (completedTrips>=totalTrips) {\\n            hi = mid;\\n        } else {\\n            lo = mid + 1;\\n        }\\n    }\\n    return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266795,
                "title": "minimum-time-to-complete-trips-solving-the-leetcode-challenge-march-7-2023-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/d5bd5c46-5f44-4fa7-820f-dd165a96fb91_1677816522.0925934.png)\\n\\n# Full explaination at : [Solution](https://yoichiisagi.hashnode.dev/minimum-time-to-complete-trips-solving-the-leetcode-challenge-march-7-2023)\\n\\n![image.png](https://assets.leetcode.com/users/images/6907ce4f-a766-4668-bd51-1cedade65e46_1677816533.0083919.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int n = time.length;\\n        double tripsPerUnitTime = 0.0;\\n        int minimumTime = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++) {\\n            tripsPerUnitTime += (double)1/time[i];\\n            if(minimumTime>time[i]) {\\n                minimumTime = time[i];\\n            }\\n        }\\n\\n        long timeForTrips = (int)Math.ceil((double)totalTrips/tripsPerUnitTime);\\n        // find the number of trips in timeForTrips and find remaining time for partial trips\\n        long minTime = timeForTrips;\\n        long maxTime = Integer.MAX_VALUE;\\n        long trips = 0;\\n        for(int i=0;i<n;i++) {\\n            trips += timeForTrips/time[i];\\n        }\\n        if(trips>=totalTrips) {\\n            return timeForTrips;\\n        }\\n\\n        minTime = timeForTrips;\\n        maxTime = timeForTrips+(totalTrips-trips)*minimumTime;\\n        do {\\n            timeForTrips = (minTime+maxTime)/2;\\n            trips=0;\\n            minimumTime = Integer.MAX_VALUE;\\n            for(int i=0;i<n;i++) {\\n                trips += timeForTrips/time[i];\\n            }\\n            if(trips < totalTrips) {\\n                minTime = timeForTrips;\\n            } else {\\n                maxTime = timeForTrips;\\n            }\\n        } while(maxTime - minTime>1);\\n        \\n        return maxTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int n = time.length;\\n        double tripsPerUnitTime = 0.0;\\n        int minimumTime = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++) {\\n            tripsPerUnitTime += (double)1/time[i];\\n            if(minimumTime>time[i]) {\\n                minimumTime = time[i];\\n            }\\n        }\\n\\n        long timeForTrips = (int)Math.ceil((double)totalTrips/tripsPerUnitTime);\\n        // find the number of trips in timeForTrips and find remaining time for partial trips\\n        long minTime = timeForTrips;\\n        long maxTime = Integer.MAX_VALUE;\\n        long trips = 0;\\n        for(int i=0;i<n;i++) {\\n            trips += timeForTrips/time[i];\\n        }\\n        if(trips>=totalTrips) {\\n            return timeForTrips;\\n        }\\n\\n        minTime = timeForTrips;\\n        maxTime = timeForTrips+(totalTrips-trips)*minimumTime;\\n        do {\\n            timeForTrips = (minTime+maxTime)/2;\\n            trips=0;\\n            minimumTime = Integer.MAX_VALUE;\\n            for(int i=0;i<n;i++) {\\n                trips += timeForTrips/time[i];\\n            }\\n            if(trips < totalTrips) {\\n                minTime = timeForTrips;\\n            } else {\\n                maxTime = timeForTrips;\\n            }\\n        } while(maxTime - minTime>1);\\n        \\n        return maxTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266733,
                "title": "java-binary-search-easiest-solution",
                "content": "```\\n\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=Long.MAX_VALUE;\\n        long high=0;\\n        long min=Long.MAX_VALUE;\\n        for(int it:time){\\n            low=Math.min(low,it);\\n            min=Math.min(min,it);\\n        }\\n        high=totalTrips*min;\\n        while(low<high){\\n            long mid=low+(high-low)/2;\\n            if(blackbox(mid,totalTrips,time)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long isvalidtime,int totalTrips,int[] time){\\n        long trips=0;\\n        for(int it:time){\\n            trips+=isvalidtime/it;\\n        }\\n        if(trips>=totalTrips)\\n            return true;\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=Long.MAX_VALUE;\\n        long high=0;\\n        long min=Long.MAX_VALUE;\\n        for(int it:time){\\n            low=Math.min(low,it);\\n            min=Math.min(min,it);\\n        }\\n        high=totalTrips*min;\\n        while(low<high){\\n            long mid=low+(high-low)/2;\\n            if(blackbox(mid,totalTrips,time)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long isvalidtime,int totalTrips,int[] time){\\n        long trips=0;\\n        for(int it:time){\\n            trips+=isvalidtime/it;\\n        }\\n        if(trips>=totalTrips)\\n            return true;\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266698,
                "title": "javascript-rust-easy-to-understand-solution",
                "content": "## JavaScript Solution\\n```javascript\\n/**\\n * @param {number[]} time\\n * @param {number} totalTrips\\n * @return {number}\\n */\\nvar minimumTime = function (time, totalTrips) {\\n  let maxTime = Math.min.apply(null, time) * totalTrips;\\n  let minTime = 1;\\n\\n  while (minTime < maxTime) {\\n    const midTime = Math.floor((minTime + maxTime) / 2);\\n    let trips = 0;\\n    for (const tripTime of time) {\\n      trips += Math.floor(midTime / tripTime);\\n    }\\n\\n    trips < totalTrips ? (minTime = midTime + 1) : (maxTime = midTime);\\n  }\\n\\n  return minTime;\\n};\\n\\n```\\n\\n## Rust Solution\\n\\n```rust\\nimpl Solution {\\n    pub fn minimum_time(time: Vec<i32>, total_trips: i32) -> i64 {\\n        let total_trips = total_trips as i64;\\n        let mut max_time = time.iter().min().unwrap().clone() as i64 * total_trips;\\n        let mut min_time = 1 as i64;\\n\\n        while min_time < max_time {\\n            let mid_time = (min_time + max_time) / 2;\\n            let trips = time.iter().fold(0, |subtotal, trip_time| {\\n                subtotal + mid_time / trip_time.clone() as i64\\n            });\\n\\n            if trips < total_trips {\\n                min_time = mid_time + 1;\\n            } else {\\n                max_time = mid_time;\\n            }\\n        }\\n\\n        min_time\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Rust",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} time\\n * @param {number} totalTrips\\n * @return {number}\\n */\\nvar minimumTime = function (time, totalTrips) {\\n  let maxTime = Math.min.apply(null, time) * totalTrips;\\n  let minTime = 1;\\n\\n  while (minTime < maxTime) {\\n    const midTime = Math.floor((minTime + maxTime) / 2);\\n    let trips = 0;\\n    for (const tripTime of time) {\\n      trips += Math.floor(midTime / tripTime);\\n    }\\n\\n    trips < totalTrips ? (minTime = midTime + 1) : (maxTime = midTime);\\n  }\\n\\n  return minTime;\\n};\\n\\n```\n```rust\\nimpl Solution {\\n    pub fn minimum_time(time: Vec<i32>, total_trips: i32) -> i64 {\\n        let total_trips = total_trips as i64;\\n        let mut max_time = time.iter().min().unwrap().clone() as i64 * total_trips;\\n        let mut min_time = 1 as i64;\\n\\n        while min_time < max_time {\\n            let mid_time = (min_time + max_time) / 2;\\n            let trips = time.iter().fold(0, |subtotal, trip_time| {\\n                subtotal + mid_time / trip_time.clone() as i64\\n            });\\n\\n            if trips < total_trips {\\n                min_time = mid_time + 1;\\n            } else {\\n                max_time = mid_time;\\n            }\\n        }\\n\\n        min_time\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266423,
                "title": "daily-leetcoding-challenge-march-day-7",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-time-to-complete-trips/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-time-to-complete-trips/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1811056,
                "title": "swift-binary-search",
                "content": "By asking **Minimum Time to do something**, it sounds very likely that we can use Binary Search. The tricky part is to identify the upper bound which costed me 4 failed attempts in a row (I indeed need to improve my carefullness :(( ).\\n\\nLet\\'s say the longest bus takes `longestTime` to complete a trip, in the worst scenario we\\'ll need `longestTime * totalTrips` time to fulfill the requirement (I guess there could be a better formula, please enlighten me :pray:).\\n\\nOnce we\\'ve identified the upper bound, binary search will just kick in. So if a bus takes `busTime` to complete a trip, given a period time of `t`, the bus will be able to finish `t / busTime` trips. If the number of completed trips of all buses is greater or equal to `totalTrips`, `t` is a valid candidate. Otherwise, we\\'ll need more time.\\n\\n**Swift**\\n```swift\\nclass Solution {\\n  func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n    func isValid(_ t: Int) -> Bool {\\n      var numberOfTrips = 0\\n      for busTime in time {\\n        numberOfTrips += (t / busTime)\\n\\t\\t\\n\\t\\t// as soon as we\\'ve completed at least `totalTrips`, t is valid candidate\\n\\t\\tif numberOfTrips >= totalTrips {\\n\\t\\t   return true\\n\\t\\t}\\n      }\\n      \\n      return false\\n    }\\n    \\n    let longestTime = time.max() ?? 0    \\n    var res = 0\\n    var (low, high) = (1, longestTime * totalTrips)\\n    while low <= high {\\n      let mid = low + (high - low) / 2\\n      if isValid(mid) {\\n        res = mid\\n        high = mid - 1 \\n      } else {\\n        low = mid + 1\\n      }\\n    }\\n    \\n    return res\\n  }\\n}\\n\\n// Time complextiy: O(nlogk) where n is time.count and k = 10^7 * 10^7 = 10^14\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Tree"
                ],
                "code": "```swift\\nclass Solution {\\n  func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n    func isValid(_ t: Int) -> Bool {\\n      var numberOfTrips = 0\\n      for busTime in time {\\n        numberOfTrips += (t / busTime)\\n\\t\\t\\n\\t\\t// as soon as we\\'ve completed at least `totalTrips`, t is valid candidate\\n\\t\\tif numberOfTrips >= totalTrips {\\n\\t\\t   return true\\n\\t\\t}\\n      }\\n      \\n      return false\\n    }\\n    \\n    let longestTime = time.max() ?? 0    \\n    var res = 0\\n    var (low, high) = (1, longestTime * totalTrips)\\n    while low <= high {\\n      let mid = low + (high - low) / 2\\n      if isValid(mid) {\\n        res = mid\\n        high = mid - 1 \\n      } else {\\n        low = mid + 1\\n      }\\n    }\\n    \\n    return res\\n  }\\n}\\n\\n// Time complextiy: O(nlogk) where n is time.count and k = 10^7 * 10^7 = 10^14\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803205,
                "title": "binary-search-based-implementation-c",
                "content": "As we need to find the minimum time to complete, so we can observe that if the time is more than the answer than it will anyways satisfy one possible answer, so it follows binary search, \\nlike: if possible at 50 than possible at 100 also:\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n=time.size();  \\n        unsigned long long int left=1; \\n        unsigned long long int right= 1e18;  \\n        unsigned long long ans; \\n        while(left<=right){\\n            unsigned  long long int mid=left+(right-left)/2; \\n            unsigned  long long temp=0; \\n            for(int i=0;i<n;i++){\\n                temp+=(mid/time[i]); \\n            }\\n            if(temp>=totalTrips){\\n                ans=mid; \\n                right=mid-1; \\n            }\\n            else {\\n                left=mid+1; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n=time.size();  \\n        unsigned long long int left=1; \\n        unsigned long long int right= 1e18;  \\n        unsigned long long ans; \\n        while(left<=right){\\n            unsigned  long long int mid=left+(right-left)/2; \\n            unsigned  long long temp=0; \\n            for(int i=0;i<n;i++){\\n                temp+=(mid/time[i]); \\n            }\\n            if(temp>=totalTrips){\\n                ans=mid; \\n                right=mid-1; \\n            }\\n            else {\\n                left=mid+1; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802899,
                "title": "python-heap-no-binary-search-o-n-log-n",
                "content": "Idea, estimate a lower bound, and then refine.\\n\\n**Step 1:**\\nHow do we estimate the time needed?\\n\\nFor each truck `t` in `time`, we know that in every minute, `1/t` trip is completed.\\n\\nTherefore, `sum(1/t)` trips are completed per minute.\\n\\nAs a rough estimate, we will need `T = totalTrips/sum(1/t)` minutes to finish `totalTrips`.\\n\\n**Step 2:**\\nThe estimate in step 1 is only a lower bound. The reason is, we need complete trips.\\n\\nTherefore, assuming that partial trips are count, we will complete `totalTrips` trips in `T` minute.\\n\\nHowever, we need to round down evey trip, so there are only\\n`sum( floor(T/t) )` trips completed.\\n\\nAfter taking floor, for each truck, at most 1 trip is discarded, so the `N` trucks will waste at most `N` trips.\\n\\n**Step 3:**\\nFind a systematic way to fill up the underestimated `totalTrips - sum( floor(T/t) ) <= N` trips.\\n\\nI will do this by heap.\\n\\nAt time `est`, For each truck `t`, we will compute the next time for `t` to finish its next trip (implemented in the function `ceiling(est, t)` below).\\n\\nThen, we push the tuple `(ceiling(est, t), t)` to the heap.\\n\\nThen, for each pop in the heap, we know there is another trip completed, so we increment the trip count by 1 and push the next trip completion time to the heap.\\n\\n**Complexity analysis:**\\nEvery thing up to step 2 is O(N).\\n\\nFrom the analysis in step 2, we know that in the worst case we need to emulate N trips.\\n\\nConstructing the heap is O(N log N)\\n\\nPoping and pushing in the loop is O(log N). Multiply by N, the worst case, the loop takes at most O(N log N).\\n\\nSo the overall algorithm is O(N log N).\\n\\n2076 ms, beats 90%.\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        # Return the smallest multiple of b strictly greater than a.\\n        def ceiling(a, b):\\n            return a // b * b + b\\n        \\n\\t\\t# Step 1: Find est, an initial lower bound\\n        speed = sum(1/t for t in time)\\n        est = int(totalTrips/speed)\\n        \\n\\t\\t# Step 2: Construct the heap\\n        trips = 0\\n        hp = []\\n        for t in time:\\n\\t\\t    # ceiling(est, t) is the next returning time for the truck t\\n            heappush(hp, (ceiling(est, t), t))\\n\\t\\t\\t# Compute trips, the number of trips actually finished at time est\\n            trips += est // t\\n            \\n\\t    # Step 3: Heap update\\n        answer = est\\n        while trips < totalTrips:\\n\\t\\t    # Update the returning time as answer for every incoming trip\\n            answer, t = heappop(hp)\\n\\t\\t\\t# Push back the next returning time for the same truck which just returned.\\n            heappush(hp, (ceiling(answer, t), t))\\n            trips += 1\\n            \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        # Return the smallest multiple of b strictly greater than a.\\n        def ceiling(a, b):\\n            return a // b * b + b\\n        \\n\\t\\t# Step 1: Find est, an initial lower bound\\n        speed = sum(1/t for t in time)\\n        est = int(totalTrips/speed)\\n        \\n\\t\\t# Step 2: Construct the heap\\n        trips = 0\\n        hp = []\\n        for t in time:\\n\\t\\t    # ceiling(est, t) is the next returning time for the truck t\\n            heappush(hp, (ceiling(est, t), t))\\n\\t\\t\\t# Compute trips, the number of trips actually finished at time est\\n            trips += est // t\\n            \\n\\t    # Step 3: Heap update\\n        answer = est\\n        while trips < totalTrips:\\n\\t\\t    # Update the returning time as answer for every incoming trip\\n            answer, t = heappop(hp)\\n\\t\\t\\t# Push back the next returning time for the same truck which just returned.\\n            heappush(hp, (ceiling(answer, t), t))\\n            trips += 1\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270314,
                "title": "java-binary-search-10-lines-beats-99",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(1e14))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1, r = (long) 1e14;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var trips = 0L;\\n\\n      for (var i=0; i < time.length && trips < totalTrips; i++)\\n        trips += m / time[i];\\n      \\n      if (trips < totalTrips) l = m+1;\\n      else r = m;\\n    }\\n    return l;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1, r = (long) 1e14;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var trips = 0L;\\n\\n      for (var i=0; i < time.length && trips < totalTrips; i++)\\n        trips += m / time[i];\\n      \\n      if (trips < totalTrips) l = m+1;\\n      else r = m;\\n    }\\n    return l;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267813,
                "title": "solution-with-clear-explanation-and-example-with-a-plot",
                "content": "# Intuition\\n--> Since number of trips possible for a given number of days with respect to time array is monotonic, we can use Binary search on the ouput limit.\\n\\n--> Output is monotonic because when output increases trips you can make is non decresing with respect to time array.\\n\\n--> Example to understand it is monotonic, if time = [5,10,10] ,totalTrips = 9 .\\n\\nTrips Vs Days is non decreasing or monotonic.\\n\\n![Image 3-7-23 at 4.25 AM.jpeg](https://assets.leetcode.com/users/images/281a8410-b1e8-40c1-8fbe-0617976f6f67_1678181163.4239738.jpeg)\\n\\n\\n\\n\\n# Approach\\n--> Trip counter function is calculating number of trips you can make when you are given some number of days\\n--> Since answer remains between 1 and totalTrips*min(time) we can use binary search.\\n--> lets say you have time = [5,10,10] ,totalTrips = 9 , then your output limits are 1 and 9 multpipied by 5.\\n\\n\\n# Complexity\\n- Time complexity:\\n--> Worst case complexity is O(Nlogk)\\n--> N is number of elememts in time\\n--> k is 10**14 in worst case\\n\\n- Space complexity:\\n--> O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\n        def trip_counter(num):\\n\\n            i = 0\\n\\n            trips = 0\\n\\n            while i < len(time):\\n\\n                trips += num // time[i]\\n                i+=1\\n                if trips > totalTrips:\\n                    break\\n\\n            return trips\\n        \\n        start = 1\\n        end = totalTrips*min(time) \\n\\n        while start <= end:\\n\\n            mid = (start+end)//2\\n\\n            trips = trip_counter(mid)\\n\\n            if trips >= totalTrips:\\n                end = mid-1\\n            \\n            else:\\n                start = mid+1\\n        \\n\\n        return start\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\n        def trip_counter(num):\\n\\n            i = 0\\n\\n            trips = 0\\n\\n            while i < len(time):\\n\\n                trips += num // time[i]\\n                i+=1\\n                if trips > totalTrips:\\n                    break\\n\\n            return trips\\n        \\n        start = 1\\n        end = totalTrips*min(time) \\n\\n        while start <= end:\\n\\n            mid = (start+end)//2\\n\\n            trips = trip_counter(mid)\\n\\n            if trips >= totalTrips:\\n                end = mid-1\\n            \\n            else:\\n                start = mid+1\\n        \\n\\n        return start\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374139,
                "title": "c-easy-and-simple-c-code-82-time-o-nlogn",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int Trips(long long mid, vector<int>& time, int totalTrips)\\n    {\\n        long long n = time.size(), ans = 0;\\n        for(int &num : time)\\n            ans += mid/num;\\n        if(ans >= totalTrips)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int m = time.size();\\n        long long i = 1, ans = 0;\\n        long long j = (long long)time[0]*totalTrips;\\n        while(i <= j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            if(Trips(mid, time, totalTrips))\\n            {\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            else\\n            {\\n                i = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int Trips(long long mid, vector<int>& time, int totalTrips)\\n    {\\n        long long n = time.size(), ans = 0;\\n        for(int &num : time)\\n            ans += mid/num;\\n        if(ans >= totalTrips)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int m = time.size();\\n        long long i = 1, ans = 0;\\n        long long j = (long long)time[0]*totalTrips;\\n        while(i <= j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            if(Trips(mid, time, totalTrips))\\n            {\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            else\\n            {\\n                i = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802789,
                "title": "javascript-binary-search-916ms",
                "content": "```\\nlet a, tot;\\nconst minimumTime = (time, totalTrips) => {\\n    a = time,\\n    tot = totalTrips;\\n    let min = Math.min(...a);\\n    if (tot == 1) return min;\\n    return BinarySearch(0, 1e14);\\n};\\n\\nconst BinarySearch = (low, high) => {\\n    while (low <= high) {\\n        let mid = parseInt((low + high) / 2);\\n        if (possible(mid)) { // if current sum < tot, we need make low increasing, otherwise high decreasing\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    return low;\\n};\\n\\nconst possible = (t) => { // accumlate sum of trips of current t\\n    let sum = 0;\\n    for (const x of a) sum += parseInt(t / x);\\n    return sum < tot;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nlet a, tot;\\nconst minimumTime = (time, totalTrips) => {\\n    a = time,\\n    tot = totalTrips;\\n    let min = Math.min(...a);\\n    if (tot == 1) return min;\\n    return BinarySearch(0, 1e14);\\n};\\n\\nconst BinarySearch = (low, high) => {\\n    while (low <= high) {\\n        let mid = parseInt((low + high) / 2);\\n        if (possible(mid)) { // if current sum < tot, we need make low increasing, otherwise high decreasing\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    return low;\\n};\\n\\nconst possible = (t) => { // accumlate sum of trips of current t\\n    let sum = 0;\\n    for (const x of a) sum += parseInt(t / x);\\n    return sum < tot;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802733,
                "title": "c-binary-search-approach-easy-to-understand",
                "content": "``` \\nbool check(vector<int>& arr,long long int trip,long long int m){\\n        long res = 0;\\n        for(int i : arr){\\n            res += (m/i);\\n            \\n            if(res>=trip){\\n                return true;\\n            }\\n        }\\n        return res>=trip;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long int s = 0;\\n        long long int e = 1e18;\\n        \\n        while(e-s>1){\\n            long m = (s+e)/2;\\n            \\n            if(check(time,totalTrips,m)){\\n                e = m;\\n            }else{\\n                s = m+1;\\n            }\\n        }\\n        \\n        if(check(time,totalTrips,s)) return s;\\n        return e;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "``` \\nbool check(vector<int>& arr,long long int trip,long long int m){\\n        long res = 0;\\n        for(int i : arr){\\n            res += (m/i);\\n            \\n            if(res>=trip){\\n                return true;\\n            }\\n        }\\n        return res>=trip;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long int s = 0;\\n        long long int e = 1e18;\\n        \\n        while(e-s>1){\\n            long m = (s+e)/2;\\n            \\n            if(check(time,totalTrips,m)){\\n                e = m;\\n            }else{\\n                s = m+1;\\n            }\\n        }\\n        \\n        if(check(time,totalTrips,s)) return s;\\n        return e;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802667,
                "title": "python3-binary-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6f8a2c98f0feab59d2e0ec35f928e3ee1d3e4456) for solutions of weekly 282. \\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        lo, hi = 0, max(time) * totalTrips\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if sum(mid//x for x in time) < totalTrips: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        lo, hi = 0, max(time) * totalTrips\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if sum(mid//x for x in time) < totalTrips: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802647,
                "title": "very-easy-binary-search",
                "content": "```\\nclass Solution {\\n    bool valid(vector<int>& time , long long mid , long long totalTrips){\\n        int n = time.size();\\n        long long sum = 0;\\n        for(int i = 0 ; i  < n; i++){\\n            sum += (mid/time[i]);\\n\\n        }\\n        return sum >= totalTrips;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n = time.size();\\n        long long l = 0 , r = 100000000000002;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l + r)/2;\\n            if(valid(time , mid , totalTrips)){\\n                ans = mid ;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool valid(vector<int>& time , long long mid , long long totalTrips){\\n        int n = time.size();\\n        long long sum = 0;\\n        for(int i = 0 ; i  < n; i++){\\n            sum += (mid/time[i]);\\n\\n        }\\n        return sum >= totalTrips;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n = time.size();\\n        long long l = 0 , r = 100000000000002;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l + r)/2;\\n            if(valid(time , mid , totalTrips)){\\n                ans = mid ;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802537,
                "title": "with-logic-and-intuition-o-1-space",
                "content": "**using binary search** \\nIntuition : **if (we can do toatalTrips in x second):**\\n                  then the **minimum time** required must be **in range [start,x]**\\n             **else:**\\n                  the **minimum time** required must be **in range [x+1,end]**\\n**where start = 1, end = LLONG_MAX**\\n```\\nclass Solution {\\npublic:\\n    bool doit(vector<int>& time, long long avail, long long todo) {\\n        long long total(0);\\n        for (auto& t : time) {\\n            if (t > avail)   break;\\n            total += (avail/t);\\n            if (total >= todo)  return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int total) {\\n        \\n        sort(begin(time), end(time));\\n        long long start=1, end=LLONG_MAX; \\n        while (start < end) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0long long mid = start + (end - start) / 2;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (doit(time, mid, total))  end = mid;\\n            else    start = mid+1;\\n        }\\n        return end;\\n    }\\n};\\n```\\n**Upvote it if it helps :)**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doit(vector<int>& time, long long avail, long long todo) {\\n        long long total(0);\\n        for (auto& t : time) {\\n            if (t > avail)   break;\\n            total += (avail/t);\\n            if (total >= todo)  return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int total) {\\n        \\n        sort(begin(time), end(time));\\n        long long start=1, end=LLONG_MAX; \\n        while (start < end) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0long long mid = start + (end - start) / 2;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (doit(time, mid, total))  end = mid;\\n            else    start = mid+1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276740,
                "title": "solution-in-java-2187-minimum-time-to-complete-trips",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    while (l < r) {\\n      final long m = (l + r) / 2;\\n      if (numTrips(time, m) >= totalTrips)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return l;\\n  }\\n\\n  private long numTrips(int[] time, long m) {\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    while (l < r) {\\n      final long m = (l + r) / 2;\\n      if (numTrips(time, m) >= totalTrips)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return l;\\n  }\\n\\n  private long numTrips(int[] time, long m) {\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269907,
                "title": "c-solution-easy-and-simple-explanation-binary-search-o-n-long-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the Binary Search concept is used.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Apply the binary search on the maximum possible time which is 10^14 deduced from the constraints given. \\n2. Every time find the total number of trips that are possible, which are calculated by the dividing the particular time by time taken by ith bus.\\n\\n# Complexity\\n- Time complexity: O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int tt) {\\n        long long i = 1, j = 1e14, mid;\\n        while(i < j){\\n            mid = i+(j-i)/2;\\n            long long ans = 0;\\n            for (auto i : time){\\n                ans+= mid/i;\\n            }\\n            if (ans >= tt){\\n                j = mid;\\n            }\\n            else i = mid+1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int tt) {\\n        long long i = 1, j = 1e14, mid;\\n        while(i < j){\\n            mid = i+(j-i)/2;\\n            long long ans = 0;\\n            for (auto i : time){\\n                ans+= mid/i;\\n            }\\n            if (ans >= tt){\\n                j = mid;\\n            }\\n            else i = mid+1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269432,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 1e14;\\n        while(l <= r) {\\n            ll trip = 0, mid = (l + r) / 2;\\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\\n            if(trip < totalTrips) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 1e14;\\n        while(l <= r) {\\n            ll trip = 0, mid = (l + r) / 2;\\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\\n            if(trip < totalTrips) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269370,
                "title": "c-detailed-image-explanation-binary-search-easy-to-understand",
                "content": "**general observation :-**\\n\\t\\t1.here we use concept of binary search . our main motive is to find minimum time required for all buses to complete at least totalTrips trips.\\n\\t\\t2.whenever there is **uncertenty in selecting any number** then we use **binary search** . we have to use number line for binary search and given Time array is used for validating whether assumed value(mid ) leads to answer or not . if it leads to answer then ok , in this question totalTrips is target with the help of time array . if we have multiple mid then return minimum all among them .\\n\\n**STEPS :-**\\n1.define **left=0 , right=1e14 or totalTrips x (long long)time[0**] . this is beacuse total time may be 10 to the power 14 (see constriants below)\\n2.calculate **mid** as we do in **binary search.**\\n3.when we have mid treat this mid , as time to complete TotalTrips.\\nwe have to minimise it since in question it is said to calculate least time to complete TotalTrips trips .\\n4.see if using that time **we exceed or equal to TotalTrips or not** . if yes then there may be less time which can complete given trips .so make **right =mid** and do same for left subpart .\\n5.otherwise select right subpart and make **left=mid+1.**\\n6.repeat it untill **left<right.**\\n\\n![image](https://assets.leetcode.com/users/images/f8a8aff3-155b-4a82-9353-e89774d45f16_1678206231.6091678.png)\\n\\n```\\nPLEASE upvote if you like my solution . it motivates me lot \\n```\\n![image](https://assets.leetcode.com/users/images/b70153ab-a3a1-4219-ad40-1b77728c79ba_1678206758.7823985.png)\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<int> reqTime, int totalTrips) {\\n        long long start = 0;\\n        long long end = 1e14;\\n        long long ans = 0;\\n        \\n        while(start <= end) {\\n            \\n            long long mid = start +(end-start) / 2;\\n            long long trips = 0;\\n            \\n            // Considering mid as required time. If we get desired count of totalTrips by using time == mid.\\n            // it will store that ans, else if(required trips < totalTrips), start = mid + 1.\\n            for(auto reqTimee : reqTime) {\\n                trips += mid / reqTimee;\\n            }\\n            \\n            if(trips >= totalTrips) {\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        return solve(time, totalTrips);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nPLEASE upvote if you like my solution . it motivates me lot \\n```\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<int> reqTime, int totalTrips) {\\n        long long start = 0;\\n        long long end = 1e14;\\n        long long ans = 0;\\n        \\n        while(start <= end) {\\n            \\n            long long mid = start +(end-start) / 2;\\n            long long trips = 0;\\n            \\n            // Considering mid as required time. If we get desired count of totalTrips by using time == mid.\\n            // it will store that ans, else if(required trips < totalTrips), start = mid + 1.\\n            for(auto reqTimee : reqTime) {\\n                trips += mid / reqTimee;\\n            }\\n            \\n            if(trips >= totalTrips) {\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        return solve(time, totalTrips);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269178,
                "title": "wow-very-easy-dart-binary-search-solution-100-beats-o-n-logn-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minimumTime(List<int> time, int totalTrips) {\\n      int maxTime = time.reduce(min) * totalTrips;\\n      int minTime = 0;\\n\\n      while (minTime <= maxTime) {\\n          int middle = (maxTime + minTime) ~/ 2;\\n\\n          //count trips(middle)\\n          int trips = 0;\\n          for (int busTime in time) {\\n              trips += middle ~/ busTime;\\n          }\\n\\n          if (trips >= totalTrips) {\\n              maxTime = middle - 1;\\n          }\\n          else {\\n              minTime = middle + 1;\\n          }\\n      }\\n\\n      return minTime;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minimumTime(List<int> time, int totalTrips) {\\n      int maxTime = time.reduce(min) * totalTrips;\\n      int minTime = 0;\\n\\n      while (minTime <= maxTime) {\\n          int middle = (maxTime + minTime) ~/ 2;\\n\\n          //count trips(middle)\\n          int trips = 0;\\n          for (int busTime in time) {\\n              trips += middle ~/ busTime;\\n          }\\n\\n          if (trips >= totalTrips) {\\n              maxTime = middle - 1;\\n          }\\n          else {\\n              minTime = middle + 1;\\n          }\\n      }\\n\\n      return minTime;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269047,
                "title": "python3-1737-ms-faster-than-97-75-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/dd9c3714-4bca-483d-8fc6-8411cb7a43e4_1678200467.7560015.png)\\n```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(t):\\n            res = 0\\n            for e in time:\\n                res += t//e\\n            return res >= totalTrips\\n        maxt = max(time)\\n        left, right = 1, (totalTrips//sum([maxt//e for e in time]) + 1)*maxt\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n```\\nhere\\'s a step-by-step explanation of the code:\\n\\n1. Define a function check(t) that takes an integer t and returns True if the number of trips that can be completed in t time is greater than or equal to the total number of trips needed (totalTrips), otherwise returns False.\\n1. Initialize a variable maxt to the maximum value in the time list.\\n1. Initialize left to 1 and right to a value that guarantees that there will be enough time to complete all the trips. This value is calculated as follows:\\n\\t1. For each element e in the time list, calculate the number of trips that can be completed in maxt time (i.e., maxt//e).\\n\\t1. Add up all these values to get the total number of trips that can be completed in maxt time.\\n\\t1. Divide totalTrips by this total number of trips to get an estimate of the minimum amount of time needed to complete all the trips.\\n\\t1. Multiply this estimate by maxt to get an upper bound on the time needed to complete all the trips.\\n1. While left is less than right, do the following:\\n\\t1. Calculate the midpoint m between left and right.\\n\\t1. If check(m) returns True, set right to m.\\n\\t1. Otherwise, set left to m + 1.\\n1. When the while loop terminates, return left, which represents the minimum amount of time needed to complete all the trips.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(t):\\n            res = 0\\n            for e in time:\\n                res += t//e\\n            return res >= totalTrips\\n        maxt = max(time)\\n        left, right = 1, (totalTrips//sum([maxt//e for e in time]) + 1)*maxt\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3268958,
                "title": "python-solution-faster-than-96-of-other-solutions",
                "content": "Please Upvote if you like it.\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        a, b = 1, totalTrips * min(time)\\n\\n        def f(x):\\n            return sum(x // t for t in time) >= totalTrips\\n    \\n        while a < b:\\n            m = (a + b) // 2\\n            if not f(m): a = m + 1\\n            else: b = m\\n        return a",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "Please Upvote if you like it.\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        a, b = 1, totalTrips * min(time)\\n\\n        def f(x):\\n            return sum(x // t for t in time) >= totalTrips\\n    \\n        while a < b:\\n            m = (a + b) // 2\\n            if not f(m): a = m + 1\\n            else: b = m\\n        return a",
                "codeTag": "Java"
            },
            {
                "id": 3268852,
                "title": "java-easy-binary-search-with-explain-t-c-o-nlogn-s-c-o-1",
                "content": "```\\n    class Solution {\\n\\t// TC : O(nlogn)\\n\\t// SC: O(1)\\n\\tpublic long minimumTime(int[] time, int totalTrips) {\\n\\n\\n\\t\\tlong left = 1;\\n\\t\\tlong min = time[0];\\n\\t\\tfor(int t : time){\\n\\t\\t\\tmin = Math.min(min, t);\\n\\t\\t}\\n\\t\\tlong right = totalTrips * min;\\n\\n\\t\\twhile(left < right){\\n\\t\\t\\tlong mid = (right - left) / 2 + left;\\n\\n\\t\\t\\t//How many trip we can do\\n\\t\\t\\tlong total = totalTripInGivenTime(time, mid);\\n\\t\\t\\t//We cannot reach totalTrips, means mid is too small\\n\\t\\t\\tif(total < totalTrips){\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t//We can reach totalTrips, but we want right to be as small as possible\\n\\t\\t\\t\\t//Therefore, we don\\'t need to + 1\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn left;\\n\\t}\\n\\n\\tprivate long totalTripInGivenTime(int[] time, long givenTime){\\n\\t\\tlong totalTrips = 0l;\\n\\t\\tfor(int tripTime : time){\\n\\t\\t\\ttotalTrips += ((long)givenTime) / tripTime;\\n\\t\\t}\\n\\t\\treturn totalTrips;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Solution {\\n\\t// TC : O(nlogn)\\n\\t// SC: O(1)\\n\\tpublic long minimumTime(int[] time, int totalTrips) {\\n\\n\\n\\t\\tlong left = 1;\\n\\t\\tlong min = time[0];\\n\\t\\tfor(int t : time){\\n\\t\\t\\tmin = Math.min(min, t);\\n\\t\\t}\\n\\t\\tlong right = totalTrips * min;\\n\\n\\t\\twhile(left < right){\\n\\t\\t\\tlong mid = (right - left) / 2 + left;\\n\\n\\t\\t\\t//How many trip we can do\\n\\t\\t\\tlong total = totalTripInGivenTime(time, mid);\\n\\t\\t\\t//We cannot reach totalTrips, means mid is too small\\n\\t\\t\\tif(total < totalTrips){\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t//We can reach totalTrips, but we want right to be as small as possible\\n\\t\\t\\t\\t//Therefore, we don\\'t need to + 1\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn left;\\n\\t}\\n\\n\\tprivate long totalTripInGivenTime(int[] time, long givenTime){\\n\\t\\tlong totalTrips = 0l;\\n\\t\\tfor(int tripTime : time){\\n\\t\\t\\ttotalTrips += ((long)givenTime) / tripTime;\\n\\t\\t}\\n\\t\\treturn totalTrips;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268548,
                "title": "c-java-solution-using-binary-search-minimum-time-to-complete-trips",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(x))$$ $$where$$ $$x=100000000000000$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool numberOfTripsForGivenTime(vector<int>&a, long long int givenTime, int totalTrips)\\n    {\\n        long long int currTotalTrips = 0;\\n        for(auto x : a)\\n            currTotalTrips += (givenTime /(long long int) x);\\n\\n        return currTotalTrips >= totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long int lowestTime = 1;\\n        long long int highestTime = 1e14;\\n        while(lowestTime<highestTime)\\n        {\\n            long long int mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(time , mid, totalTrips))\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    private boolean numberOfTripsForGivenTime(int [] a, long givenTime, int totalTrips)\\n    {\\n        long currTotalTrips = 0;\\n        for(int x : a)\\n            currTotalTrips += (givenTime / (long)x);\\n\\n        return currTotalTrips >= totalTrips;\\n    }\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long highestTime = 100000000000000L;\\n        while(lowestTime<highestTime)\\n        {\\n            long mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(time , mid, totalTrips))\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool numberOfTripsForGivenTime(vector<int>&a, long long int givenTime, int totalTrips)\\n    {\\n        long long int currTotalTrips = 0;\\n        for(auto x : a)\\n            currTotalTrips += (givenTime /(long long int) x);\\n\\n        return currTotalTrips >= totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long int lowestTime = 1;\\n        long long int highestTime = 1e14;\\n        while(lowestTime<highestTime)\\n        {\\n            long long int mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(time , mid, totalTrips))\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    private boolean numberOfTripsForGivenTime(int [] a, long givenTime, int totalTrips)\\n    {\\n        long currTotalTrips = 0;\\n        for(int x : a)\\n            currTotalTrips += (givenTime / (long)x);\\n\\n        return currTotalTrips >= totalTrips;\\n    }\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long highestTime = 100000000000000L;\\n        while(lowestTime<highestTime)\\n        {\\n            long mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(time , mid, totalTrips))\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268137,
                "title": "minimum-time-to-complete-trips-easy-to-understand-optimal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. firstly we can think for the maximum and minimum ans can be possible. so, we can get that the minimum ans can 1 and maximum ans can be 1e14.\\n2. so we got the range where we can run our binary search approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. now we run will binary search from 0 to 1e14\\n2. where every time mid represents how much time had already happend\\n3. if we divide mid by the given time vector. so, we will get how much trips can be completed by all the buses in that time.\\n4. finally we can sum up to get total trips \\n5. And then follow the two conditions of binary search to increase start or reduce end.\\n6. finally, as the loop ends will will get our ans.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long start=1,end=1e14,ans;\\n        while(start<=end){\\n            long long mid=start+(end-start)/2,sum=0;\\n            for(auto it:time){\\n                sum+=mid/it;\\n            }\\n            if(sum<totalTrips){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long start=1,end=1e14,ans;\\n        while(start<=end){\\n            long long mid=start+(end-start)/2,sum=0;\\n            for(auto it:time){\\n                sum+=mid/it;\\n            }\\n            if(sum<totalTrips){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267852,
                "title": "beats-100-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267530,
                "title": "easy-c-solution",
                "content": "# Intuition\\nSo we need to find the min time to complete the totaltrips.We already know the time for each bus to complete one trip.From it we can find the range of time to complete the totalTrips;\\n# Approach\\nFirst we will find the range of possible time,\\nmintime=min value in time * totalTrips;\\n(form constraints it is clear that both time[i]and totalTrips has a min value of 1.Therefore mintime=1 always);\\nmaxtime=max value in time * totalTrips;\\n(this we will find by extracting max value in vector time)\\n\\nNow we have our time range(start=mintime and end=maxtime) now we will apply binary search  and check if this mid (time) can complete totalTrips.\\nif YES than store it in ans and do maxtime=mid-1;\\nelse mintime=mid+1;\\n\\nTo check if time is feasible we will create a function \"isSafe\" which find the value of total trip which can be completed in time(value of mid); \\n\\n# Complexity\\n- Time complexity:O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int>& time, long long possible_time,int totalTrips){\\n        long long possible_trips=0;\\n        for(auto value:time){\\n            possible_trips+=possible_time/value;\\n           \\n        }\\n         if(possible_trips>=totalTrips)\\n            return true;\\n            return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxArray=INT_MIN;\\n        for(auto i:time){\\n            if(i>maxArray)\\n            maxArray=i;\\n        }\\n        long long ans=1;\\n        long long minTime=1,maxTime=totalTrips*maxArray;\\n        while(minTime<=maxTime){\\n            long long mid=minTime+(maxTime-minTime)/2;\\n            if(isSafe(time, mid,totalTrips)){\\n                ans=mid;\\n                maxTime=mid-1;\\n            }\\n            else{\\n                minTime=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int>& time, long long possible_time,int totalTrips){\\n        long long possible_trips=0;\\n        for(auto value:time){\\n            possible_trips+=possible_time/value;\\n           \\n        }\\n         if(possible_trips>=totalTrips)\\n            return true;\\n            return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxArray=INT_MIN;\\n        for(auto i:time){\\n            if(i>maxArray)\\n            maxArray=i;\\n        }\\n        long long ans=1;\\n        long long minTime=1,maxTime=totalTrips*maxArray;\\n        while(minTime<=maxTime){\\n            long long mid=minTime+(maxTime-minTime)/2;\\n            if(isSafe(time, mid,totalTrips)){\\n                ans=mid;\\n                maxTime=mid-1;\\n            }\\n            else{\\n                minTime=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267309,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips)\\n     {\\n        long long left=0,right=totalTrips*(long long)time[0],ans=right;\\n        while(left<right)\\n        {\\n            long long mid=(left+right)/2;\\n            long long count=0;\\n            for(int i=0;i<time.size();++i)\\n            {\\n                count+=mid/time[i];     \\n            } \\n            if(count>=totalTrips)\\n            {\\n                ans=min(ans,mid);\\n                right=mid;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips)\\n     {\\n        long long left=0,right=totalTrips*(long long)time[0],ans=right;\\n        while(left<right)\\n        {\\n            long long mid=(left+right)/2;\\n            long long count=0;\\n            for(int i=0;i<time.size();++i)\\n            {\\n                count+=mid/time[i];     \\n            } \\n            if(count>=totalTrips)\\n            {\\n                ans=min(ans,mid);\\n                right=mid;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267249,
                "title": "java-brute-force-approach",
                "content": "```\\n// Approach: Brute Force - TLE\\n\\n// Time complexity: O(n * t)\\n// Space complexity: O(n)\\n\\npublic long minimumTime(int[] time, int totalTrips) {\\n\\tint currTime = 1;\\n\\n\\twhile (true) {\\n\\t\\tint trips = 0;\\n\\n\\t\\tfor (int t : time) \\n\\t\\t\\ttrips += currTime / t;\\n\\n\\t\\tif (trips >= totalTrips)\\n\\t\\t\\tbreak;\\n\\n\\t\\tcurrTime++;\\n\\t}\\n\\n\\treturn currTime;\\n}\\n```\\n\\n**Note:** This solution gives TLE. It\\'s provided just for understanding purpose.\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Approach: Brute Force - TLE\\n\\n// Time complexity: O(n * t)\\n// Space complexity: O(n)\\n\\npublic long minimumTime(int[] time, int totalTrips) {\\n\\tint currTime = 1;\\n\\n\\twhile (true) {\\n\\t\\tint trips = 0;\\n\\n\\t\\tfor (int t : time) \\n\\t\\t\\ttrips += currTime / t;\\n\\n\\t\\tif (trips >= totalTrips)\\n\\t\\t\\tbreak;\\n\\n\\t\\tcurrTime++;\\n\\t}\\n\\n\\treturn currTime;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267150,
                "title": "java-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n      long low=1;\\n      long end=0;\\n     for(int i:time)end=Math.max(end,i);\\n       end=end*totalTrips;\\n      while(low<end)\\n      {\\n          long mid=(low+end)/2;\\n          long r=0;\\n          for(int i: time)\\n          {\\n             if(i<=mid){\\n                r+=mid/i;   \\n             }\\n             if(r>totalTrips)break;\\n          }\\n          if(r<totalTrips)low=mid+1;\\n          else end=mid; \\n      }\\n      return low;\\n\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n      long low=1;\\n      long end=0;\\n     for(int i:time)end=Math.max(end,i);\\n       end=end*totalTrips;\\n      while(low<end)\\n      {\\n          long mid=(low+end)/2;\\n          long r=0;\\n          for(int i: time)\\n          {\\n             if(i<=mid){\\n                r+=mid/i;   \\n             }\\n             if(r>totalTrips)break;\\n          }\\n          if(r<totalTrips)low=mid+1;\\n          else end=mid; \\n      }\\n      return low;\\n\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267098,
                "title": "python-one-liner-two-liner",
                "content": "# Approach\\nBinary search (or rather, bisect) the minimum time required to fulfill all trips.\\n\\n# Code\\n\\n### Two liner\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        check = lambda t: sum(t // bus for bus in time) >= totalTrips\\n        return bisect_left(range(time[0] * totalTrips), True, key=check)\\n\\n```\\n\\n### One liner\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect_left(range(time[0] * totalTrips), True, key=lambda t: sum(t // bus for bus in time) >= totalTrips)\\n\\n```\\n\\n### Without bisect library\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        check = lambda t: sum(t // bus for bus in time) >= totalTrips\\n\\n        lo, hi = 1, time[0] * totalTrips\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if check(mid):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        \\n        return lo\\n\\n\\n```\\n\\nBy the way, this is the article that solved binary search for me once and for all: http://coldattic.info/post/95/",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        check = lambda t: sum(t // bus for bus in time) >= totalTrips\\n        return bisect_left(range(time[0] * totalTrips), True, key=check)\\n\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect_left(range(time[0] * totalTrips), True, key=lambda t: sum(t // bus for bus in time) >= totalTrips)\\n\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        check = lambda t: sum(t // bus for bus in time) >= totalTrips\\n\\n        lo, hi = 1, time[0] * totalTrips\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if check(mid):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        \\n        return lo\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267035,
                "title": "c-easy-solution-binary-search-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFBinary Search Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n```\\nclass Solution {\\npublic:\\n    long long isSafe(vector<int>&time,long long val){\\n        long long a=0;\\n        for(int i=0;i<time.size();i++){\\n            a+=val/time[i];\\n        }\\n        return a;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        //we will use Binary Search to find optimal ans\\n        //we will initialize the low to 1 and high to 1e14 \\n        //beacause we can have constraints 1e7*1e7\\n        long long low=1,high=1e14;\\n        \\n        //basic synatax of binary search\\n        while(low<high){\\n            //finding mid with tackling the overflow\\n            long long mid=low+(high-low)/2;\\n            \\n            //checking the trips possible with mid time the totalTrips \\n            if(isSafe(time,mid)>=totalTrips){\\n                //if safe the make high= mid\\n                high=mid;\\n            }\\n            else{\\n                //else make low to mid+1 as not found on mid\\n                low=mid+1;\\n            }\\n        }\\n        //return the mid\\n        return low;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long isSafe(vector<int>&time,long long val){\\n        long long a=0;\\n        for(int i=0;i<time.size();i++){\\n            a+=val/time[i];\\n        }\\n        return a;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        //we will use Binary Search to find optimal ans\\n        //we will initialize the low to 1 and high to 1e14 \\n        //beacause we can have constraints 1e7*1e7\\n        long long low=1,high=1e14;\\n        \\n        //basic synatax of binary search\\n        while(low<high){\\n            //finding mid with tackling the overflow\\n            long long mid=low+(high-low)/2;\\n            \\n            //checking the trips possible with mid time the totalTrips \\n            if(isSafe(time,mid)>=totalTrips){\\n                //if safe the make high= mid\\n                high=mid;\\n            }\\n            else{\\n                //else make low to mid+1 as not found on mid\\n                low=mid+1;\\n            }\\n        }\\n        //return the mid\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266953,
                "title": "java-beats-98-6-easy-to-understand-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=1;\\n        long high=Long.MAX_VALUE-100000;\\n        long ans=high;\\n        while(low<=high)\\n        {\\n            long mid=(low+high)/2;\\n            if(valid(time,mid,totalTrips))\\n            {\\n                ans=Math.min(ans,mid);\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n\\n    }\\n    public boolean valid(int[]time,long t,long totalTrips)\\n    {\\n        long temp=0;\\n      for(int x:time)\\n      {\\n          temp+=(t/x);\\n          if(temp>=totalTrips)\\n          return true;\\n      }\\n      return temp>=totalTrips;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=1;\\n        long high=Long.MAX_VALUE-100000;\\n        long ans=high;\\n        while(low<=high)\\n        {\\n            long mid=(low+high)/2;\\n            if(valid(time,mid,totalTrips))\\n            {\\n                ans=Math.min(ans,mid);\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n\\n    }\\n    public boolean valid(int[]time,long t,long totalTrips)\\n    {\\n        long temp=0;\\n      for(int x:time)\\n      {\\n          temp+=(t/x);\\n          if(temp>=totalTrips)\\n          return true;\\n      }\\n      return temp>=totalTrips;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266895,
                "title": "binary-search-solution-nlog-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long r=*min(time.begin(),time.end())*(long long)totalTrips,l=0,ans=r;\\n        while(l<r)\\n        {\\n            long long cnt=0;\\n            long long mid=(l+r)/2;\\n            for(int i=0;i<time.size();i++)\\n            {\\n                cnt+=(mid/time[i]);\\n            }\\n            if(cnt>=totalTrips)\\n            {\\n                ans=min(ans,mid);\\n                r=mid;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long r=*min(time.begin(),time.end())*(long long)totalTrips,l=0,ans=r;\\n        while(l<r)\\n        {\\n            long long cnt=0;\\n            long long mid=(l+r)/2;\\n            for(int i=0;i<time.size();i++)\\n            {\\n                cnt+=(mid/time[i]);\\n            }\\n            if(cnt>=totalTrips)\\n            {\\n                ans=min(ans,mid);\\n                r=mid;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266735,
                "title": "v-v-v-v-easy-solutions-in-c-do-upvote-it",
                "content": "# Intuition\\nThe problem can be solved using binary search by setting the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips. We can then use a helper function to calculate the total number of trips completed for each bus at any given time, and based on that, determine whether the current minimum time is too high or too low. We can continue updating the search space until we find the minimum time required to complete totalTrips trips.\\n\\n# Approach\\nInitialize the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips. The minimum time required for each bus to complete totalTrips trips is the minimum time taken by any bus multiplied by totalTrips, and the maximum time required is the sum of times taken by all buses multiplied by totalTrips.\\nUse binary search to find the minimum time required to complete totalTrips trips. For each mid-point time value, calculate the total number of trips completed for each bus using a helper function.\\nIf the total number of trips completed is greater than or equal to totalTrips, the current mid-point time is a valid candidate for the minimum time required. Therefore, update the search space to the lower half of the current range.\\nIf the total number of trips completed is less than totalTrips, the current mid-point time is too high, and we need to increase the minimum time required. Therefore, update the search space to the upper half of the current range.\\nContinue updating the search space until the minimum time required to complete totalTrips trips is found.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity: The time complexity of the binary search algorithm used in the solution is O(logn)O(log n)O(logn), where n is the range of possible minimum times required for all buses to complete at least totalTrips trips. For each mid-point time value, the helper function calculates the total number of trips completed by all buses, which takes O(n)O(n)O(n) time. Therefore, the overall time complexity of the solution is O(nlogn)O(n log n)O(nlogn), where n is the length of the input array time.\\n\\n- Space complexity:\\nSpace complexity: The space complexity of the solution is O(1)O(1)O(1), as we are only using constant space to store the input array and a few variables.\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll start = 1;\\n        ll end = 1e14;\\n        while(start <= end){\\n            ll trip = 0;\\n            ll mid = start + (end - start)/2;\\n            for(int i=0;i<time.size();i++)\\n                trip += mid / time[i];\\n            if(trip < totalTrips){\\n                start = mid + 1;\\n            }\\n            else \\n                end = mid - 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll start = 1;\\n        ll end = 1e14;\\n        while(start <= end){\\n            ll trip = 0;\\n            ll mid = start + (end - start)/2;\\n            for(int i=0;i<time.size();i++)\\n                trip += mid / time[i];\\n            if(trip < totalTrips){\\n                start = mid + 1;\\n            }\\n            else \\n                end = mid - 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218376,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int x) {\\n        long long int mx = LONG_LONG_MAX/time.size(), mn = 1,mid,ans,k;\\n        // for(auto &i: time){\\n        //     mx += i;\\n        //     mn = min(mn,(long long int)i);\\n        // }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: time){\\n                k += (mid/i);\\n            }\\n            if(k>=x){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int x) {\\n        long long int mx = LONG_LONG_MAX/time.size(), mn = 1,mid,ans,k;\\n        // for(auto &i: time){\\n        //     mx += i;\\n        //     mn = min(mn,(long long int)i);\\n        // }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: time){\\n                k += (mid/i);\\n            }\\n            if(k>=x){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218359,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int x) {\\n        long long int mx = LONG_LONG_MAX/time.size(), mn = 1,mid,ans,k;\\n        // for(auto &i: time){\\n        //     mx += i;\\n        //     mn = min(mn,(long long int)i);\\n        // }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: time){\\n                k += (mid/i);\\n            }\\n            if(k>=x){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int x) {\\n        long long int mx = LONG_LONG_MAX/time.size(), mn = 1,mid,ans,k;\\n        // for(auto &i: time){\\n        //     mx += i;\\n        //     mn = min(mn,(long long int)i);\\n        // }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: time){\\n                k += (mid/i);\\n            }\\n            if(k>=x){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877745,
                "title": "easy-understand-80-faster-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n    long long l = 0, r = LONG_MAX/time.size(),m,trips;\\n    while (l < r) {\\n        m = ((r-l)>>1)+l, trips = 0;\\n        for (int t : time)\\n            trips += m / t;\\n        if (trips < totalTrips)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n    long long l = 0, r = LONG_MAX/time.size(),m,trips;\\n    while (l < r) {\\n        m = ((r-l)>>1)+l, trips = 0;\\n        for (int t : time)\\n            trips += m / t;\\n        if (trips < totalTrips)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2552192,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Binary Search***\\n\\n* ***Time Complexity :- O(Nlog(high - low))***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>& time, long long mid, int totalTrips)\\n    {\\n        int n = time.size();\\n        \\n        // find total_trips possible\\n        \\n        long long trips = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            trips += (mid / time[i]);\\n        }\\n        \\n        return trips >= totalTrips;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        int n = time.size();\\n        \\n        // apply binary search\\n        \\n        // and check for every mid is it possible to make atleast totalTrips\\n        \\n        // if possible then store in ans and move high to mid - 1\\n        \\n        // otherwise move low to mid + 1\\n        \\n        long long low = 1;\\n        \\n        long long high = 1e14;\\n        \\n        long long ans = 1;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = low + (high - low) / 2;\\n            \\n            if(is_possible(time, mid, totalTrips))\\n            {\\n                ans = mid;\\n                \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>& time, long long mid, int totalTrips)\\n    {\\n        int n = time.size();\\n        \\n        // find total_trips possible\\n        \\n        long long trips = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            trips += (mid / time[i]);\\n        }\\n        \\n        return trips >= totalTrips;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        int n = time.size();\\n        \\n        // apply binary search\\n        \\n        // and check for every mid is it possible to make atleast totalTrips\\n        \\n        // if possible then store in ans and move high to mid - 1\\n        \\n        // otherwise move low to mid + 1\\n        \\n        long long low = 1;\\n        \\n        long long high = 1e14;\\n        \\n        long long ans = 1;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = low + (high - low) / 2;\\n            \\n            if(is_possible(time, mid, totalTrips))\\n            {\\n                ans = mid;\\n                \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507143,
                "title": "java-faster-97-82-binary-search",
                "content": "```\\nclass Solution {\\n    // binary search!\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long result = 0;\\n        // low starts from 1 since min of both time[i] and totalTrips is 1.\\n        long low = 1;\\n        // high ends with 10^14 since the Max value for time[i] and totalTrips are 10^7.\\n        // so the worst case is when a bus takes 10^7 seconds for a trip, and need to finish 10^7 trips.\\n        // Thus, it\\'s 10^7 * 10^7 = 10^14\\n        long high = 100000000000000L;\\n        \\n        // if low = high it means that there is only one number in our range, so found\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            boolean pass = isValid(time, mid, totalTrips);\\n            \\n            if (pass) {\\n                // can finish, so store for possible better solution    \\n                result = mid;\\n                high = mid - 1;\\n            } else {\\n                // no enough time, so go up for a valid solution\\n                low = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isValid(int[] time, long mid, int totalTrips){\\n        long finish = 0;\\n        for (int each : time) {\\n            finish += mid / each;\\n            if (finish >= totalTrips) { return true; }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // binary search!\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long result = 0;\\n        // low starts from 1 since min of both time[i] and totalTrips is 1.\\n        long low = 1;\\n        // high ends with 10^14 since the Max value for time[i] and totalTrips are 10^7.\\n        // so the worst case is when a bus takes 10^7 seconds for a trip, and need to finish 10^7 trips.\\n        // Thus, it\\'s 10^7 * 10^7 = 10^14\\n        long high = 100000000000000L;\\n        \\n        // if low = high it means that there is only one number in our range, so found\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            boolean pass = isValid(time, mid, totalTrips);\\n            \\n            if (pass) {\\n                // can finish, so store for possible better solution    \\n                result = mid;\\n                high = mid - 1;\\n            } else {\\n                // no enough time, so go up for a valid solution\\n                low = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isValid(int[] time, long mid, int totalTrips){\\n        long finish = 0;\\n        for (int each : time) {\\n            finish += mid / each;\\n            if (finish >= totalTrips) { return true; }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834177,
                "title": "98-faster-92-space-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long l = 1;\\n        long r = Long.MAX_VALUE-100000;\\n        long ans = r;\\n        while(l<=r){\\n            long mid = (l+r)/2;\\n            boolean result = possible(time , mid , totalTrips);\\n            if(result){\\n                ans = Math.min(ans , mid);\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean possible(int a[] , long time , long total){\\n        long now = 0;\\n        for(int i : a){\\n            now += (time/i);\\n            if(now >= total)\\n                return true;\\n        }\\n        return now >= total;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long l = 1;\\n        long r = Long.MAX_VALUE-100000;\\n        long ans = r;\\n        while(l<=r){\\n            long mid = (l+r)/2;\\n            boolean result = possible(time , mid , totalTrips);\\n            if(result){\\n                ans = Math.min(ans , mid);\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean possible(int a[] , long time , long total){\\n        long now = 0;\\n        for(int i : a){\\n            now += (time/i);\\n            if(now >= total)\\n                return true;\\n        }\\n        return now >= total;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817102,
                "title": "c-binary-search",
                "content": "```\\n\\tpublic long MinimumTime(int[] time, int totalTrips) {\\n        long left = 1;\\n        long right = long.MaxValue;\\n        while (left < right) {\\n            var middle = left + (right-left)/2;\\n            if (TripsCount(time, middle, totalTrips) < totalTrips)\\n                left = middle+1;\\n            else\\n                right = middle;\\n        }\\n        return left;\\n    }\\n    \\n    long TripsCount(int[] busTime, long totalTime, long target) {\\n        long sum = 0;\\n        var i = 0;\\n        while (i < busTime.Length && sum <= target) {\\n            sum += totalTime/busTime[i++];\\n        }   \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n\\tpublic long MinimumTime(int[] time, int totalTrips) {\\n        long left = 1;\\n        long right = long.MaxValue;\\n        while (left < right) {\\n            var middle = left + (right-left)/2;\\n            if (TripsCount(time, middle, totalTrips) < totalTrips)\\n                left = middle+1;\\n            else\\n                right = middle;\\n        }\\n        return left;\\n    }\\n    \\n    long TripsCount(int[] busTime, long totalTime, long target) {\\n        long sum = 0;\\n        var i = 0;\\n        while (i < busTime.Length && sum <= target) {\\n            sum += totalTime/busTime[i++];\\n        }   \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805032,
                "title": "binary-search-c-nlog-n-commented",
                "content": "**class Solution {\\npublic:\\n    \\n    //func to calculate trips covered in given time frame \\n    long long tripsTaken(vector<int>& time, long long mid){\\n        \\n        long long cnt=0;\\n        for(auto it: time)\\n        {\\n            cnt+= mid/it;\\n        }\\n        return cnt;\\n    }\\n    \\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long low=0, high=1e14;\\n        //here maximum high time= time*totaltrips= 1e7*1e7(look the constraints)\\n        long long res= high;\\n        \\n        while(low<=high)\\n        {\\n            //because right shift (>>) operator works faster than \\'/\\'\\n            //both will work fine\\n            long long mid= (low+high) >> 1;\\n            //long long mid= (low+high) / 2;\\n            \\n            if(tripsTaken(time, mid) >= totalTrips)\\n            {\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low= mid+1;  \\n            } \\n        }\\n        return res;\\n    }\\n};**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //func to calculate trips covered in given time frame \\n    long long tripsTaken(vector<int>& time, long long mid){\\n        \\n        long long cnt=0;\\n        for(auto it: time)\\n        {\\n            cnt+= mid/it;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1803475,
                "title": "c-binary-search-approach",
                "content": "```\\nclass Solution {\\n    using lli = unsigned long long;\\npublic:\\n    bool check(vector<int>& time,lli mid ,int totalTrips){\\n        lli cnt = 0;\\n        for(int i=0;i<time.size();i++){\\n            cnt += (mid/(1ll * time[i]));\\n        }\\n        return cnt >= 1ll * totalTrips;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        lli lo = 0, hi = 1e18 , ans = 0;\\n        while(lo <= hi){\\n            lli mid = lo + (hi -lo)/2;\\n            if(check(time,mid,totalTrips)){\\n                ans = mid;\\n                hi = mid - 1;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nanother good article explaining binary search : https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1796568/java-binary-search-sliding-window-approach-explained",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    using lli = unsigned long long;\\npublic:\\n    bool check(vector<int>& time,lli mid ,int totalTrips){\\n        lli cnt = 0;\\n        for(int i=0;i<time.size();i++){\\n            cnt += (mid/(1ll * time[i]));\\n        }\\n        return cnt >= 1ll * totalTrips;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        lli lo = 0, hi = 1e18 , ans = 0;\\n        while(lo <= hi){\\n            lli mid = lo + (hi -lo)/2;\\n            if(check(time,mid,totalTrips)){\\n                ans = mid;\\n                hi = mid - 1;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803155,
                "title": "c-binary-search-o-nlogm-why-binary-search",
                "content": "This is a good question . Lots of people are discussing on how to use binary search in this question. I want to share ***why are we using binary search ??***\\n\\nThe question says that we are provided with an array containing time taken by each bus to complete one trip. If any/all buses are allowed to travel simultaneously , then we have to return the **minimum time** in which all the buses can complete ***total_trips*** all together. \\nWhich means we have to find the minimum time such that , \\n\\t\\t*****(minimum_time/ time[0] ) + (minimum_time/ time[1] ) + ..... (minimum_time / time[n-1] ) >=totaltrips*****   \\n\\t\\tWe have to make sure that **minimum_time** is as small as possible. \\n\\nHow do we solve this question ?? \\n \\nWell , the first thing that comes to my mind is , that : \\n1. Keep a time variable , start it from 1 (time=1) .\\n2. Check if we can make total_trips within ***time*** or not. \\n3. If **yes, then this is our answer** , as we started from the lower end , and we have  recieved our first possible value ( which will be minimum of all further possible values ). \\n4. If , **no** , then **increment the time variable** and follow from STEP 2. \\n\\nThis is not a good approach as , if our answer is close to the upper end , then this approach will take a hell lot of time. \\n\\n***So , how do we move ahead ??***\\nThere is another way . We can move from the other end , ie , the right end and the last value that we encounter which will satisfy our condition , will be our answer. \\n\\n***If we observe the 2 approaches we can come to the following conclusions :***\\n1. The time variable has a range of values for which the condition will be satisfied. \\n2. If  for a particular value of time , the condition is satisfied , it will be satisfied for all values > time. \\n3. If for a particular value of time , the condition is not satisfied , it will not be satisfied for all values < time.\\n4. Time variable will have a sorted set of values. ( 1,2,3,4,5.....) \\n\\n***Using the above observations we can think that we can use BINARY SEARCH based on the DIVIDE AND CONQUER ALGORITHM***. \\n* We will check set the lower and upper bounds of the range. \\n* We will check if the mid_value satisfies the condition ,if it does , then we will update our answer and reduce our upper_bound to mid_value -1. ( WITH THE INTENTION TO SEARCH FOR EVEN SMALLER POSSIBLE ANSWER ) .\\n* If mid_value doesn\\'t satisfy the condition , we will increase our lower_bound to mid_value +1 ( AS ANY VALUE LOWER THAN THE CURRENT MID WON\\'T BE ANSWER ).\\n\\n### CODE : \\n```\\nclass Solution {\\npublic:\\n    bool tripsPossible(vector<int> &time , int totalTrips, long long int minTime)\\n    {\\n        long long int trips=0;\\n        for(int i:time)\\n        {   \\n            trips+=(minTime/i);\\n            if(trips>=totalTrips)\\n                return true;\\n        }\\n         return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long ans=-1,low=1,high,mid;\\n        high=(long long)totalTrips*(*min_element(time.begin(),time.end()));\\n        \\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(tripsPossible(time,totalTrips,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n                       \\n    }\\n};\\n```\\n\\n***If you found this post helpful , do upvote and comment below.***\\n\\n\\n\\n\\n \\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool tripsPossible(vector<int> &time , int totalTrips, long long int minTime)\\n    {\\n        long long int trips=0;\\n        for(int i:time)\\n        {   \\n            trips+=(minTime/i);\\n            if(trips>=totalTrips)\\n                return true;\\n        }\\n         return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long ans=-1,low=1,high,mid;\\n        high=(long long)totalTrips*(*min_element(time.begin(),time.end()));\\n        \\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(tripsPossible(time,totalTrips,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n                       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803087,
                "title": "clearly-explained-python3-faster-than-100-numpy-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/4abdaa11-50d2-403f-80b6-3c048fc7969a_1645939023.0960097.png)\\n\\nI will divide this post into two sections. First, I will show my accepted code, then, I will explain my thought process. \\n\\n__Code__\\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        \\n        from collections import Counter\\n        import numpy as np\\n        \\n        dic = Counter(time)\\n        k_arr, v_arr = np.array(list(dic.keys())), np.array(list(dic.values()))\\n        \\n\\t\\t# deal with edge cases, eg. time = [1, 1, 1, 1, 1], totalTrip = 5\\n        if np.size(k_arr) == 1 and k_arr[0] == 1: \\n            if totalTrips % v_arr[0] == 0: return totalTrips // v_arr[0]\\n            else: return totalTrips // v_arr[0] + 1\\n        \\n\\t\\t# binary search\\n        l, r = min(k_arr), min(k_arr) * totalTrips\\n        idx = (l + r) // 2   # mid\\n        \\n        while l + 1 < r:\\n            temp = np.sum((idx * np.ones_like(k_arr) // k_arr) * v_arr)\\n            if temp >= totalTrips:\\n                r = idx\\n                idx = (r + l) // 2\\n            else:\\n                l = idx\\n                idx = (r + l) // 2\\n            \\n        return r\\n\\t\\t\\n```\\n\\n\\n__Thought Process__\\n\\nTake the first test case, **time = [1, 2, 3], totalTrip = 5** as an example:\\nMy initial idea was, we can loop from t = 1, and increment t by 1 at each step, until we find a time that will produce a result >= totalTrip. \\n\\nt = 1, reminder of t over time is [0, 1, 1], total trips we can complete *by adding 1 to t* is sum(time[0, 1, 1]) = 1\\nt = 2, reminder of t over time is [0, 0, 1], total trips we can complete *by adding 1 to t* is sum(time[0, 0, 1]) = 2 \\nt = 3, reminder of t over time is [0, 1, 0], total trips we can complete *by adding 1 to t* is sum(time[0, 1, 0]) = 2\\n\\nI found that while looping, we don\\'t need to find how many trips a specific truck can complete. Instead, since we are incrementing t by 1, we just need to find how many trucks completed a new trip at time t + 1. Namely, we just need to find the reminder of t over time[i]. If the reminder == 0, our current total trip increment by 1. \\n\\nAnd since we are doing vector/array operations in python, numpy, in most cases, is our best friend. \\n\\n**CODE BELOW WILL LEAD TO TLE**\\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        \\n        from collections import Counter\\n        import numpy as np\\n        \\n        dic = Counter(time)\\n        \\n        k_arr, v_arr = np.array(list(dic.keys())), np.array(list(dic.values()))\\n        \\n        idx, res = 1, 0\\n        \\n        while 1:\\n            temp = idx * np.ones_like(k_arr)\\n            left = np.remainder(temp, k_arr)\\n            res += sum(v_arr[left == 0])\\n            if res >= totalTrips: return idx\\n            idx += 1\\n```\\n\\nApparently, this will lead to TLE. So instead of iterating from 1 to infinity, I decided to do binary search to find the tight bound. While if we want to do binary search, the incrementing by 1 and finding the reminder trick will never work. Hence, I have to choose the regular track: true divide my current t vector over the time vector, and get the sum of (result of true division * number of each type of truck).\\n\\nIn my code:\\n\\n```\\ntemp = np.sum((idx * np.ones_like(k_arr) // k_arr) * v_arr)\\n```\\n\\nIn details:\\n\\n```\\n# idx -> mid of binary search\\ncurr_time = idx * np.ones_like(k_arr)\\ncurr_weight = curr_time // k_arr\\ncurr_sum = np.sum(curr_weight * v_arr)\\n```\\n\\n__Open Discussion__\\n\\nPlease help!\\n\\nI added the first chunk of ugly code:\\n\\n```\\n# deal with edge cases, eg. time = [1, 1, 1, 1, 1], totalTrip = 5\\nif np.size(k_arr) == 1 and k_arr[0] == 1: \\n\\tif totalTrips % v_arr[0] == 0: return totalTrips // v_arr[0]\\n\\telse: return totalTrips // v_arr[0] + 1\\n```\\n\\nonly to pass the test case **time = [1, 1, 1, 1, 1], totalTrip = 5**.\\n\\nIf you have any better ideas for dealing with edge cases based on this approach, please let me know in the comment section. Thank you!\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        \\n        from collections import Counter\\n        import numpy as np\\n        \\n        dic = Counter(time)\\n        k_arr, v_arr = np.array(list(dic.keys())), np.array(list(dic.values()))\\n        \\n\\t\\t# deal with edge cases, eg. time = [1, 1, 1, 1, 1], totalTrip = 5\\n        if np.size(k_arr) == 1 and k_arr[0] == 1: \\n            if totalTrips % v_arr[0] == 0: return totalTrips // v_arr[0]\\n            else: return totalTrips // v_arr[0] + 1\\n        \\n\\t\\t# binary search\\n        l, r = min(k_arr), min(k_arr) * totalTrips\\n        idx = (l + r) // 2   # mid\\n        \\n        while l + 1 < r:\\n            temp = np.sum((idx * np.ones_like(k_arr) // k_arr) * v_arr)\\n            if temp >= totalTrips:\\n                r = idx\\n                idx = (r + l) // 2\\n            else:\\n                l = idx\\n                idx = (r + l) // 2\\n            \\n        return r\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        \\n        from collections import Counter\\n        import numpy as np\\n        \\n        dic = Counter(time)\\n        \\n        k_arr, v_arr = np.array(list(dic.keys())), np.array(list(dic.values()))\\n        \\n        idx, res = 1, 0\\n        \\n        while 1:\\n            temp = idx * np.ones_like(k_arr)\\n            left = np.remainder(temp, k_arr)\\n            res += sum(v_arr[left == 0])\\n            if res >= totalTrips: return idx\\n            idx += 1\\n```\n```\\ntemp = np.sum((idx * np.ones_like(k_arr) // k_arr) * v_arr)\\n```\n```\\n# idx -> mid of binary search\\ncurr_time = idx * np.ones_like(k_arr)\\ncurr_weight = curr_time // k_arr\\ncurr_sum = np.sum(curr_weight * v_arr)\\n```\n```\\n# deal with edge cases, eg. time = [1, 1, 1, 1, 1], totalTrip = 5\\nif np.size(k_arr) == 1 and k_arr[0] == 1: \\n\\tif totalTrips % v_arr[0] == 0: return totalTrips // v_arr[0]\\n\\telse: return totalTrips // v_arr[0] + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802985,
                "title": "c-binary-search",
                "content": "**Minimum Time to Complete Trips**\\n\\nUse binary search here, as total trip and time[i] can go upto 10^7 so, trip time can vary in between 1 and 10^14. Here I took start=1 and end=10^17 and go for binary search, each time assume the trip time to be mid and calculate the number of trips we can have, if it greater than totaltrips than this mid can be asnwer and will go in left part for smaller value else go in right part.\\n\\n```\\n #define ll long long \\n    long long minimumTime(vector<int>& time, int to) {\\n        \\n        ll s=1,e=1e17,ans=0;\\n        while(s<=e)\\n        {\\n            ll mid=(s+e)/2;\\n            ll cnt=0;\\n            \\n            for(auto t:time)\\n            {\\n                cnt+=(mid/t);\\n                if(cnt>=to)\\n                    break;\\n            }\\n            \\n            if(cnt>=to)\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n #define ll long long \\n    long long minimumTime(vector<int>& time, int to) {\\n        \\n        ll s=1,e=1e17,ans=0;\\n        while(s<=e)\\n        {\\n            ll mid=(s+e)/2;\\n            ll cnt=0;\\n            \\n            for(auto t:time)\\n            {\\n                cnt+=(mid/t);\\n                if(cnt>=to)\\n                    break;\\n            }\\n            \\n            if(cnt>=to)\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802957,
                "title": "python3-100-faster-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/4081b7f5-14ba-4541-8cec-183c1c90514d_1645938325.1900375.png)\\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        l, h = 0, min(time) * totalTrips\\n        while l < h:\\n            mid = (l + h) // 2\\n            if sum([mid // i for i in time]) < totalTrips: l = mid + 1\\n            else: h = mid\\n        return l\\n```\\n\\n**Please upvote if you find it helpful and interesting!!!\\nThank you.**",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        l, h = 0, min(time) * totalTrips\\n        while l < h:\\n            mid = (l + h) // 2\\n            if sum([mid // i for i in time]) < totalTrips: l = mid + 1\\n            else: h = mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802886,
                "title": "c-binary-search-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int to) {\\n        long long l=0,h=LLONG_MAX,ans;\\n        while(l<=h)\\n        {\\n            long long mid=h-(h-l)/2;\\n            long long cnt=0;\\n            for(int i=0;i<time.size();i++)\\n            {\\n                cnt+=1ll*mid/time[i];\\n                if(cnt>INT_MAX)\\n                    break;\\n            }\\n            //cout<<mid<<\" \"<<cnt<<endl;\\n            if(cnt>=to)\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int to) {\\n        long long l=0,h=LLONG_MAX,ans;\\n        while(l<=h)\\n        {\\n            long long mid=h-(h-l)/2;\\n            long long cnt=0;\\n            for(int i=0;i<time.size();i++)\\n            {\\n                cnt+=1ll*mid/time[i];\\n                if(cnt>INT_MAX)\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1802848,
                "title": "c-easy-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1, r = 1e16, ans = -1;\\n        int n = time.size();\\n        auto ok = [&](long long x) {\\n            long long tot = 0;\\n           for (int i = 0; i < n; ++i) {\\n               tot += x / time[i];\\n               if (tot >= totalTrips) return true;\\n           } \\n            return tot >= totalTrips;\\n        };  \\n        while (l <= r) {\\n            long long mid = (l + r) >> 1;\\n            if (ok(mid)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1, r = 1e16, ans = -1;\\n        int n = time.size();\\n        auto ok = [&](long long x) {\\n            long long tot = 0;\\n           for (int i = 0; i < n; ++i) {\\n               tot += x / time[i];\\n               if (tot >= totalTrips) return true;\\n           } \\n            return tot >= totalTrips;\\n        };  \\n        while (l <= r) {\\n            long long mid = (l + r) >> 1;\\n            if (ok(mid)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802822,
                "title": "cpp-solution-binary-search",
                "content": "**APPROACH**\\n* Just a binary search question,as the constraints are high.\\n* Find the possible predicate function.\\n* Varieties of such question are there on leetcode.\\n\\n```\\nlong long minimumTime(vector<int>& time, int t) {\\n        sort(begin(time),end(time));\\n        long long l=1,h=1e18;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            (bin_search(mid,time,t))?h=mid-1:l=mid+1;\\n        }\\n        return l;\\n    }\\n    bool bin_search(long long mid,vector<int> &time,int &t){\\n        long long trip=0;\\n        for(auto i:time){\\n            trip+=(mid/i);\\n            if(trip>=t) return 1;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nlong long minimumTime(vector<int>& time, int t) {\\n        sort(begin(time),end(time));\\n        long long l=1,h=1e18;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            (bin_search(mid,time,t))?h=mid-1:l=mid+1;\\n        }\\n        return l;\\n    }\\n    bool bin_search(long long mid,vector<int> &time,int &t){\\n        long long trip=0;\\n        for(auto i:time){\\n            trip+=(mid/i);\\n            if(trip>=t) return 1;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802767,
                "title": "c-binary-search",
                "content": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        unsigned long long sum = 0;\\n        long long beg = 1, end = LLONG_MAX, mid;\\n        \\n        while(beg < end) {\\n            mid = beg + (end - beg) / 2;\\n            sum = 0;\\n            for(int idx = 0; idx < time.size(); idx++) {\\n                sum += mid / time[idx];\\n                if(sum >= totalTrips) {\\n                    end = mid;\\n                    break;\\n                }\\n            }\\n            \\n            if(sum >= totalTrips) {\\n                end = mid;\\n            } else {\\n                beg = mid + 1;\\n            }\\n        }\\n        \\n        return beg;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        unsigned long long sum = 0;\\n        long long beg = 1, end = LLONG_MAX, mid;\\n        \\n        while(beg < end) {\\n            mid = beg + (end - beg) / 2;\\n            sum = 0;\\n            for(int idx = 0; idx < time.size(); idx++) {\\n                sum += mid / time[idx];\\n                if(sum >= totalTrips) {\\n                    end = mid;\\n                    break;\\n                }\\n            }\\n            \\n            if(sum >= totalTrips) {\\n                end = mid;\\n            } else {\\n                beg = mid + 1;\\n            }\\n        }\\n        \\n        return beg;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802709,
                "title": "c-binary-search-predicate-function-algorithm-sortings",
                "content": "Algorithm ->\\n1) first we will have to think of what is the minimum and maximum time we reuired to\\n    make trips!\\n2) than we take the mid value and check that using this time (mid value) we can make totalTrip or not\\n3) if we can make totalTrip than it is sure that with all the values greater than this, we can also make toatlTrip so we will check for smaller values keeping this(mid) as our candidate answer and try to find more optimal value than this(mid)!\\n4) similarly if we cant make totalTrip with mid value than it is sure that with all values smaller than mid, we cant make toatlTrip so we will increase the mid value\\n5) and at the end we will return the answer\\n\\n```\\nclass Solution {\\npublic:\\n   // predicate function which will check if we can make totalTrips in time = mid\\n    bool isPossible(long long mid, vector<int>& time, int totalTrips){\\n             long long trips = 0;\\n             for(int ti : time){\\n                  trips = trips + (long long) mid / ti;\\n                  if(trips >= totalTrips) return true;\\n             }\\n          return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n                int n = time.size();\\n                if( n == 1){\\n                    long long ans =(long long) time[0] * totalTrips;\\n                    return ans;\\n                }\\n                sort(time.begin(), time.end());\\n                long long lo = 1;  // lowest value for our convineance\\n                long long hi = 1e13; // highest value for our convineance\\n                 long long ans; \\n\\t\\t\\t\\t // typical binary search algorithm\\n                while(lo <= hi){\\n                    long long mid = lo + (hi - lo) / 2;\\n                    if(isPossible(mid,time,totalTrips)){   // if we can make trip than we look for smaller value\\n                        ans = mid;\\n                        hi = mid - 1;\\n                    }\\n                    else lo = mid + 1;  // if we can not make trip than we look for higher value\\n                }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n   // predicate function which will check if we can make totalTrips in time = mid\\n    bool isPossible(long long mid, vector<int>& time, int totalTrips){\\n             long long trips = 0;\\n             for(int ti : time){\\n                  trips = trips + (long long) mid / ti;\\n                  if(trips >= totalTrips) return true;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1802703,
                "title": "java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n\\t// sort the array for binary-search\\n        Arrays.sort(time);\\n\\t\\t// convert to long type\\n        long newTotalTrips = totalTrips;\\n        long l = 0L, r = newTotalTrips*time[0];\\n        while(l < r){\\n            long mid = l + (r-l)/2;\\n            if(check(mid, time) >= totalTrips){\\n                r = mid;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    // To get the number of trips based on the time\\n    private static long check(long minTime, int[] time){\\n        long tripNum = 0;\\n        for(int t : time)\\n            tripNum += minTime/t;\\n        return tripNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n\\t// sort the array for binary-search\\n        Arrays.sort(time);\\n\\t\\t// convert to long type\\n        long newTotalTrips = totalTrips;\\n        long l = 0L, r = newTotalTrips*time[0];\\n        while(l < r){\\n            long mid = l + (r-l)/2;\\n            if(check(mid, time) >= totalTrips){\\n                r = mid;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    // To get the number of trips based on the time\\n    private static long check(long minTime, int[] time){\\n        long tripNum = 0;\\n        for(int t : time)\\n            tripNum += minTime/t;\\n        return tripNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802687,
                "title": "binary-search-detailed-explanation-from-brute-force-to-optimized-solution",
                "content": "***Please upvote or comment if you find this explanation helpful :)***\\n\\nThe problem is looking for the minimum seconds taken to achive the `totalTrips`. Therefore, to calculate number of trips that can be completed each second, the formula will be:\\n\\n**Number of Trips = sum(second // time[i])**\\n\\nFor example: \\n```\\ntime = [1,2,3], totalTrips = 5\\nAt time t = 2, the number of trips completed is (2 + 1 + 0) = 3\\n```\\n\\nTherefore, we can simply start with a **brute force solution**: loop from `t = 1` until trips completed in time `t` is greater or equal to `totalTrips`.\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        n = len(time)\\n        t = 0\\n        while True:\\n            trip = 0\\n\\t\\t\\t# compute the trips completed in time t\\n            for i in range(n):\\n                trip += (t // time[i])\\n\\t\\t\\t# if the trips completed is greater to or equal to total trips needed\\n\\t\\t\\t# mission completed\\n            if trip >= totalTrips:\\n                return t\\n\\t\\t\\t# else, we have to add 1 to t and continue looping\\n            t += 1\\n```\\nUnfortunately, the time complexity is O(tN), where n is the length of the array and t is the time needed to complete the trip. This solution ends up with TLE, which is not acceptable. However, it is always nice to start with a brute-force soluton since it at least means that you understand the problem.\\n\\nBefore starting with the optimized solution, we can start with a easier quesiton: \\n\\n**What is the maximum time needed to satisfy the problem?**\\n\\nIt would definitly be finding out the single bus that cost the most time to complete a single trip. With the same example:\\n\\n```\\ntime = [1,2,3], totalTrips = 5\\nmaximum time needed = max(time) * totalTrips\\n=> 3 * 5 = 15 (having only the third bus running)\\n```\\n\\nTherefore, back to the brute-force solution:\\nWe are simply looping through` t = 1` unitl `t = max(time) * totalTrips`.\\nTo **find a solution in a sorted array [1, max(time) * totalTrips], it\\'s nothing but Binary Search**!\\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], total: int) -> int:\\n        # Finding the maximum time in the array\\n\\t\\t# in order to define the upper bound of the time needed\\n        maxtime = max(time)\\n        return self.binarySearch(time, len(time), total, maxtime * total)\\n    \\n    def findTrip(self, arr, n, second):\\n        trips = 0\\n        for i in range(n):\\n            trips += second // arr[i]\\n        return trips\\n    \\n    def binarySearch(self, arr, n, total, high):\\n        low = 1\\n        while low < high:\\n            mid = (low + high) >> 1\\n            trips = self.findTrip(arr, n, mid)\\n            if trips < total: low = mid + 1\\n            else: high = mid\\n        return high\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ntime = [1,2,3], totalTrips = 5\\nAt time t = 2, the number of trips completed is (2 + 1 + 0) = 3\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        n = len(time)\\n        t = 0\\n        while True:\\n            trip = 0\\n\\t\\t\\t# compute the trips completed in time t\\n            for i in range(n):\\n                trip += (t // time[i])\\n\\t\\t\\t# if the trips completed is greater to or equal to total trips needed\\n\\t\\t\\t# mission completed\\n            if trip >= totalTrips:\\n                return t\\n\\t\\t\\t# else, we have to add 1 to t and continue looping\\n            t += 1\\n```\n```\\ntime = [1,2,3], totalTrips = 5\\nmaximum time needed = max(time) * totalTrips\\n=> 3 * 5 = 15 (having only the third bus running)\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], total: int) -> int:\\n        # Finding the maximum time in the array\\n\\t\\t# in order to define the upper bound of the time needed\\n        maxtime = max(time)\\n        return self.binarySearch(time, len(time), total, maxtime * total)\\n    \\n    def findTrip(self, arr, n, second):\\n        trips = 0\\n        for i in range(n):\\n            trips += second // arr[i]\\n        return trips\\n    \\n    def binarySearch(self, arr, n, total, high):\\n        low = 1\\n        while low < high:\\n            mid = (low + high) >> 1\\n            trips = self.findTrip(arr, n, mid)\\n            if trips < total: low = mid + 1\\n            else: high = mid\\n        return high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802684,
                "title": "easy-binary-search-cpp-solution",
                "content": "\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long ans=0;\\n        // if(time.size()==1)\\n        // {\\n        //     return time[0]*totalTrips;\\n        // }\\n        sort(time.begin(),time.end());\\n        long long sum=0;\\n        for(auto i:time) sum+=i;\\n        long long low=1; long long high = 1e14;\\n        vector<long long> res;\\n        while(low<high)\\n        {\\n            long long mid= low + (high-low)/2;;\\n            long long check=0;\\n            // cout<<mid<<\"a\"<<endl;\\n            for(auto i:time)\\n            {\\n                long long temp= mid/i;\\n                check+=temp;\\n            }\\n           // cout<<check<<\"b\"<<endl;\\n             if(check >= totalTrips)\\n            {\\n                res.push_back(mid);\\n                high = mid;\\n            }\\n            else\\n            {\\n                low= mid+1;\\n            }\\n        }\\n       \\n        return low;\\n    }\\n};\\n///",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long ans=0;\\n        // if(time.size()==1)\\n        // {\\n        //     return time[0]*totalTrips;\\n        // }",
                "codeTag": "Java"
            },
            {
                "id": 1802679,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    long long minimumTime(vector<int>& time, int t) {\\n        \\n        ll mn = INT_MAX;\\n        for(auto &tm : time) mn =min(mn,(ll)tm);\\n        \\n        \\n        auto check = [&](ll xt){\\n          ll cnt = 0;\\n            for(auto &tm : time){\\n                cnt += (xt/tm);\\n            }\\n            \\n            return cnt >= t;\\n        };\\n        \\n       ll l=-1,r=mn*t+1;    \\n\\t   // min time = 0\\n\\t   // max time  = smallest  time taken by bus * no of round\\n        \\n       while(r-l > 1) {\\n           ll mid = l+(r-l)/2;\\n           if(check(mid))\\n               r = mid;\\n           else\\n               l = mid;\\n       }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    long long minimumTime(vector<int>& time, int t) {\\n        \\n        ll mn = INT_MAX;\\n        for(auto &tm : time) mn =min(mn,(ll)tm);\\n        \\n        \\n        auto check = [&](ll xt){\\n          ll cnt = 0;\\n            for(auto &tm : time){\\n                cnt += (xt/tm);\\n            }\\n            \\n            return cnt >= t;\\n        };\\n        \\n       ll l=-1,r=mn*t+1;    \\n\\t   // min time = 0\\n\\t   // max time  = smallest  time taken by bus * no of round\\n        \\n       while(r-l > 1) {\\n           ll mid = l+(r-l)/2;\\n           if(check(mid))\\n               r = mid;\\n           else\\n               l = mid;\\n       }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802661,
                "title": "easy-understanding-binary-search",
                "content": "```\\nbool isvalid(vector<int>&time,long long k, long long mid){\\n      long long cnt=0;\\n        for(long long i=0; i<time.size(); i++){\\n            cnt+=mid/time[i];\\n        }\\n        return cnt>=k;\\n    }\\n    long long minimumTime(vector<int>& time, int k) {\\n        long long  l=*min_element(time.begin(),time.end());\\n        long long  h=1e14 + 1;\\n        long long  ans=h;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            if(isvalid(time,k,mid)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nbool isvalid(vector<int>&time,long long k, long long mid){\\n      long long cnt=0;\\n        for(long long i=0; i<time.size(); i++){\\n            cnt+=mid/time[i];\\n        }\\n        return cnt>=k;\\n    }\\n    long long minimumTime(vector<int>& time, int k) {\\n        long long  l=*min_element(time.begin(),time.end());\\n        long long  h=1e14 + 1;\\n        long long  ans=h;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            if(isvalid(time,k,mid)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1802488,
                "title": "c-binary-search-on-answer-on-time-search-space",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& time, long long currTime,int totalTrips){\\n        long long curr = 0;\\n        for(int i=0; i<time.size(); i++){\\n            curr += currTime/time[i];\\n        }\\n        return (curr >= totalTrips);\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n = time.size();\\n        \\n        long long start = 1;\\n        long long mini = (long long) *min_element(time.begin(),time.end());\\n        long long tot = (long long) totalTrips;\\n        long long end = mini * tot;\\n        long long ans = -1;\\n        \\n        while(start <= end){\\n            long long mid = start + (end - start)/2;\\n            if(isValid(time,mid,totalTrips)){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& time, long long currTime,int totalTrips){\\n        long long curr = 0;\\n        for(int i=0; i<time.size(); i++){\\n            curr += currTime/time[i];\\n        }\\n        return (curr >= totalTrips);\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n = time.size();\\n        \\n        long long start = 1;\\n        long long mini = (long long) *min_element(time.begin(),time.end());\\n        long long tot = (long long) totalTrips;\\n        long long end = mini * tot;\\n        long long ans = -1;\\n        \\n        while(start <= end){\\n            long long mid = start + (end - start)/2;\\n            if(isValid(time,mid,totalTrips)){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802422,
                "title": "simple-c-solution",
                "content": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        long long sum = 0, low = 0, high, mid;\\n        int n = time.size();\\n\\t\\thigh = 1;\\n        while(sum < totalTrips){\\n            low = high;\\n            sum = 0;\\n            for(auto i: time)\\n                sum += high/i;\\n            high <<= 1;\\n        }\\n        high = low;\\n        low >>= 1;\\n        while((high - low) > 1000){\\n            sum = 0;\\n            mid = low + (high - low)/2;   \\n            for(auto i: time)\\n                sum += mid/i;\\n            if(sum > totalTrips)\\n                high = mid;\\n            else if(sum < totalTrips)\\n                low = mid;\\n            else\\n                break;\\n          }\\n        for(; low <= high; low++)\\n        {\\n            sum = 0;\\n            for(auto i: time)\\n                sum += low/i;\\n            if(sum >= totalTrips)\\n            {\\n                return low;\\n            }      \\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        long long sum = 0, low = 0, high, mid;\\n        int n = time.size();\\n\\t\\thigh = 1;\\n        while(sum < totalTrips){\\n            low = high;\\n            sum = 0;\\n            for(auto i: time)\\n                sum += high/i;\\n            high <<= 1;\\n        }\\n        high = low;\\n        low >>= 1;\\n        while((high - low) > 1000){\\n            sum = 0;\\n            mid = low + (high - low)/2;   \\n            for(auto i: time)\\n                sum += mid/i;\\n            if(sum > totalTrips)\\n                high = mid;\\n            else if(sum < totalTrips)\\n                low = mid;\\n            else\\n                break;\\n          }\\n        for(; low <= high; low++)\\n        {\\n            sum = 0;\\n            for(auto i: time)\\n                sum += low/i;\\n            if(sum >= totalTrips)\\n            {\\n                return low;\\n            }      \\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876115,
                "title": "c-binary-search-based-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&arr , long long int  time ,long long int number){\\n       \\n        int n = arr.size();\\n        long long int result = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            result += (time/(long long int)arr[i]);\\n        }\\n        return result>=number;\\n    }\\n    long long minimumTime(vector<int>& arr, int trip) {\\n         sort(arr.begin() , arr.end());\\n         long long int low = 0 , high = (long long int)arr[0]*(long long int)trip ;\\n         long long int result = 0;\\n         while(low <= high){\\n             long long int mid = low + (high - low)/2;\\n             if(isValid(arr , mid , (long long int)trip)){\\n                   result = mid;\\n                   high = mid - 1;\\n             }else{\\n                 low = mid + 1;\\n             }\\n         }\\n         return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&arr , long long int  time ,long long int number){\\n       \\n        int n = arr.size();\\n        long long int result = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            result += (time/(long long int)arr[i]);\\n        }\\n        return result>=number;\\n    }\\n    long long minimumTime(vector<int>& arr, int trip) {\\n         sort(arr.begin() , arr.end());\\n         long long int low = 0 , high = (long long int)arr[0]*(long long int)trip ;\\n         long long int result = 0;\\n         while(low <= high){\\n             long long int mid = low + (high - low)/2;\\n             if(isValid(arr , mid , (long long int)trip)){\\n                   result = mid;\\n                   high = mid - 1;\\n             }else{\\n                 low = mid + 1;\\n             }\\n         }\\n         return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358703,
                "title": "binary-search-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(long long tm, vector<int>& time, int totalTrips){\\n        long long curr=0;\\n        for (auto vl: time){\\n            curr+= (tm/vl);\\n        }\\n        if (curr>= (long long)(totalTrips))return true;\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low=0;\\n        long long high= (*min_element(time.begin(),time.end()))*(1LL)*(totalTrips);\\n        sort(time.begin(),time.end());\\n        long long ans=1;\\n        while (low<=high){\\n            long long mid= low+ (high-low)/2;\\n            if (isPossible(mid,time,totalTrips)){\\n                ans= mid;\\n                high= mid-1;\\n            }\\n            else{\\n                low= mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(long long tm, vector<int>& time, int totalTrips){\\n        long long curr=0;\\n        for (auto vl: time){\\n            curr+= (tm/vl);\\n        }\\n        if (curr>= (long long)(totalTrips))return true;\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low=0;\\n        long long high= (*min_element(time.begin(),time.end()))*(1LL)*(totalTrips);\\n        sort(time.begin(),time.end());\\n        long long ans=1;\\n        while (low<=high){\\n            long long mid= low+ (high-low)/2;\\n            if (isPossible(mid,time,totalTrips)){\\n                ans= mid;\\n                high= mid-1;\\n            }\\n            else{\\n                low= mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270137,
                "title": "java-simplest-solution-beats-99-o-log-10-7-k-n",
                "content": "# Approach\\nBest approach is to play around with brute force solution and find out how can I tell how many trips can all busses take in time t. \\nFrom this I can consider my t somewhere between 1 and 10^7 * totalTrips (worst case scenario). From this I can tell at index i if my time t lies before or after it, \\nbecause if I can do totalTrips in time t, it means I can do totalTrips in every number after t. \\nSame applies to case when I can\\'t do totalTrips in t, then I can\\'t do it before t.\\n\\nThis means I can find it in log(10^7*k) * n - because it costs n in worst case to determine max number of trips at time t.\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(10^7*k)*n)$$ - it is better to scale up maximum to prevent large array iteration, because it costs only a few operation to cut it out in binary search.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low = 1;\\n        long high = 10000000L * totalTrips;\\n\\n        while (low < high) {\\n            long mid = (low+high)/2;\\n\\n            if (!canComplete(mid, time, totalTrips)) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    private boolean canComplete (long t, int[] time, int totalTrips) {\\n        long sum = 0;\\n        for (int item: time) {\\n            sum += t / item;\\n            if (sum >= totalTrips) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low = 1;\\n        long high = 10000000L * totalTrips;\\n\\n        while (low < high) {\\n            long mid = (low+high)/2;\\n\\n            if (!canComplete(mid, time, totalTrips)) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    private boolean canComplete (long t, int[] time, int totalTrips) {\\n        long sum = 0;\\n        for (int item: time) {\\n            sum += t / item;\\n            if (sum >= totalTrips) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270051,
                "title": "c-solution-beats-100-in-performance-binary-search-with-some-extra-optimization",
                "content": "# Intuition\\nAt a given time, the number of trips are the sum of the trips that the buses have done. The $$i$$th bus have done $$givenTime / time[i]$$ integer division trips at a given time, we don\\'t care about the remainder (modulus) as only the full trips count. We need to find the smallest time where this sum is greater than the given totalTrips value.\\n\\n# Approach\\nIf we have a look at the sums, we can find that it is an *equal or increasing* sequence, as with the extra next day the sum can\\'t be less than the previous one (it can be equal on some days for relatively larger time[i] values). This would indicate that if we find a value range that we can identify for the sums, we can do a more optimal binary search algorithm.\\n\\nAs totalTrips cannot be 0, the minimum value for the days count could be 1. In the worst case, to get totalTrips we should do maximum $$min * totalTrips$$ days where min is the minimum value of the time array: if we would have only that bus and it would go for $$min * totalTrips$$ with a $$min$$ total cost of a roundtrip, that would mean it alone did the preferred $$totalTrip$$ count of trips. So these values would be the lower and upper boundaries of the binary search.\\n\\nSo first we will need to find minimum value with a simple min search. Next we will have to do a binary search with the range of 1 to min * totalTrip to check which is the first sum that is actualy greater then totalTrips. Here comes another trick: we don\\'t have to calculate the actual sum values in all cases, we just\\nhave to say if a give day is less than the totalTrips value or not. That means that while iterating through the time collection and calculating the sum value from the integer divisions, if we find that the current sum is already greater than totalTrips, we can short circuit the result and don\\'t have to iterate through the rest of the times for that given day.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(totalTrips * min)$$ where n is the number of buses, and min is the minimum amount of the times array\\n    -   minimum search with $$O(n)$$\\n    -   the binary search for finding the smallest number that is greater or equal to the totalnumber in range of [1.. totalTrips * min] is log(totalTrips * min)\\n    - and for each item we need to sum all the n times as a worst case (for sums greater than totalTrips we don\\'t have to iterate on all, but for smaller ones we do have to)\\n\\n- Space complexity:\\n$$O(1)$$ constant time as only a couple of longs and ints are used for storing min value, left and right pointers, and temp counts\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimumTime(int[] time, int totalTrips) {\\n        int min = time[0];\\n        for(int i = 1; i < time.Length; i++)\\n        {\\n            if (min > time[i])\\n            {\\n                min = time[i];\\n            }\\n        }\\n\\n        long left = 1;\\n        long right = (long)totalTrips * min;\\n        while (left < right)\\n        {\\n            long mid = left + (right - left) / 2;\\n            if (IsLess(time, mid, totalTrips))\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private bool IsLess(int[] time, long current, int totalTrips)\\n    {\\n        long total = 0;\\n        for(int j = 0; j < time.Length; j++)\\n        {\\n            total += current / time[j];\\n            if (total >= totalTrips)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimumTime(int[] time, int totalTrips) {\\n        int min = time[0];\\n        for(int i = 1; i < time.Length; i++)\\n        {\\n            if (min > time[i])\\n            {\\n                min = time[i];\\n            }\\n        }\\n\\n        long left = 1;\\n        long right = (long)totalTrips * min;\\n        while (left < right)\\n        {\\n            long mid = left + (right - left) / 2;\\n            if (IsLess(time, mid, totalTrips))\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private bool IsLess(int[] time, long current, int totalTrips)\\n    {\\n        long total = 0;\\n        for(int j = 0; j < time.Length; j++)\\n        {\\n            total += current / time[j];\\n            if (total >= totalTrips)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269891,
                "title": "java-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low = 1;\\n        long min = Integer.MAX_VALUE;\\n        for(int t:time){\\n            min = Math.min(min,t);\\n        }\\n        long high = min*totalTrips;\\n        \\n        while(low<high){\\n            long samay = (low+high)/2;\\n            \\n            if(validSamay(time,totalTrips,samay)){\\n                high = samay;\\n            }else{\\n                low = samay+1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    public boolean validSamay(int[]time,int totalTrips,long samay){\\n        long trips = 0;\\n        for(int t:time){\\n            trips += samay/t;\\n        }\\n        return trips >= totalTrips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low = 1;\\n        long min = Integer.MAX_VALUE;\\n        for(int t:time){\\n            min = Math.min(min,t);\\n        }\\n        long high = min*totalTrips;\\n        \\n        while(low<high){\\n            long samay = (low+high)/2;\\n            \\n            if(validSamay(time,totalTrips,samay)){\\n                high = samay;\\n            }else{\\n                low = samay+1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    public boolean validSamay(int[]time,int totalTrips,long samay){\\n        long trips = 0;\\n        for(int t:time){\\n            trips += samay/t;\\n        }\\n        return trips >= totalTrips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269780,
                "title": "c-easy-as-possible-binary-search",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long isPos(vector<int> &v, long long mid){\\n        long long time=0;\\n        for(auto  x:v) time+=mid/x;\\n        return time;\\n    }\\n    long long m(vector<int> &v){\\n        int j=INT_MAX;\\n        for(auto x:v){\\n            j= min(x,j);\\n        }\\n        return j;\\n    }\\n    long long minimumTime(vector<int>& v, int k) {\\n        long long ans=0,i=0,j=m(v)*k;\\n        while(i<=j){\\n            long long mid=(i+j)/2;\\n            if(isPos(v,mid)>=k){\\n                ans=mid;\\n                j=mid-1;\\n            }else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long isPos(vector<int> &v, long long mid){\\n        long long time=0;\\n        for(auto  x:v) time+=mid/x;\\n        return time;\\n    }\\n    long long m(vector<int> &v){\\n        int j=INT_MAX;\\n        for(auto x:v){\\n            j= min(x,j);\\n        }\\n        return j;\\n    }\\n    long long minimumTime(vector<int>& v, int k) {\\n        long long ans=0,i=0,j=m(v)*k;\\n        while(i<=j){\\n            long long mid=(i+j)/2;\\n            if(isPos(v,mid)>=k){\\n                ans=mid;\\n                j=mid-1;\\n            }else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269723,
                "title": "simple-optimsed-solution-using-binary-search-no-need-to-linearly-iterate-over-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        vector<long long>tr(time.size(),0);\\n        // long long tr[time.size()+1]\\n        //tr[i]-number of trips the ith buses has done\\n        long long total=0;\\n        long long low=1;\\n        long long high=1e14;\\n        long long t;\\n        long long best=0;\\n        while(low<=high){\\n            t=(low+high)/2;\\n            fill(tr.begin(),tr.end(),0);\\n            total=0;\\n            \\n            //we will manually try to break this loops\\n            for(int i=0;i<time.size();i++){\\n                \\n                    tr[i]=floor(t/time[i]);\\n                    total+=tr[i];\\n                \\n            }\\n            if(total>=totalTrips){\\n                best=t;\\n                high=t-1;\\n            }else{\\n                low=t+1;\\n            }\\n            \\n        }\\n        return best;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        vector<long long>tr(time.size(),0);\\n        // long long tr[time.size()+1]\\n        //tr[i]-number of trips the ith buses has done\\n        long long total=0;\\n        long long low=1;\\n        long long high=1e14;\\n        long long t;\\n        long long best=0;\\n        while(low<=high){\\n            t=(low+high)/2;\\n            fill(tr.begin(),tr.end(),0);\\n            total=0;\\n            \\n            //we will manually try to break this loops\\n            for(int i=0;i<time.size();i++){\\n                \\n                    tr[i]=floor(t/time[i]);\\n                    total+=tr[i];\\n                \\n            }\\n            if(total>=totalTrips){\\n                best=t;\\n                high=t-1;\\n            }else{\\n                low=t+1;\\n            }\\n            \\n        }\\n        return best;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269689,
                "title": "ordered-binary-search",
                "content": "```\\nlong long check(long long mid,vector<int>&v,long long t){\\n       long long c=0;\\n        for(int i=0;i<v.size();i++){\\n            c+=mid/v[i];\\n        }\\n        return c;\\n    }\\n    long long minimumTime(vector<int>& time, long long t) {\\n       sort(time.begin(),time.end());\\n       long long l = 1, h = time[0]*t;\\n        while(l<h){\\n            long long mid=l+(h-l)/2;\\n            if(check(mid,time,t)>=t)\\n                h=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long check(long long mid,vector<int>&v,long long t){\\n       long long c=0;\\n        for(int i=0;i<v.size();i++){\\n            c+=mid/v[i];\\n        }\\n        return c;\\n    }\\n    long long minimumTime(vector<int>& time, long long t) {\\n       sort(time.begin(),time.end());\\n       long long l = 1, h = time[0]*t;\\n        while(l<h){\\n            long long mid=l+(h-l)/2;\\n            if(check(mid,time,t)>=t)\\n                h=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269669,
                "title": "binarysearch-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogm), where n = time, m=totalTrips.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} time\\n * @param {number} totalTrips\\n * @return {number}\\n */\\nvar minimumTime = function(time, totalTrips) {\\n    let min = 10**9;\\n    for(let t of time) {\\n        min = Math.min(t, min);\\n    }\\n    let left = 1;\\n    let right = min * totalTrips;\\n    function canComplete(possibleTime) {\\n        let curTrip = 0;\\n        for(let busTime of time) {\\n            curTrip += Math.floor(possibleTime/busTime);\\n            if(curTrip >= totalTrips) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    while(left < right) {\\n        let midTime = left + Math.floor((right - left)/2);\\n        let possible = canComplete(midTime);\\n        if(possible) {\\n            right = midTime;\\n        } else {\\n            left = midTime + 1;\\n        }\\n    }\\n    return right;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} time\\n * @param {number} totalTrips\\n * @return {number}\\n */\\nvar minimumTime = function(time, totalTrips) {\\n    let min = 10**9;\\n    for(let t of time) {\\n        min = Math.min(t, min);\\n    }\\n    let left = 1;\\n    let right = min * totalTrips;\\n    function canComplete(possibleTime) {\\n        let curTrip = 0;\\n        for(let busTime of time) {\\n            curTrip += Math.floor(possibleTime/busTime);\\n            if(curTrip >= totalTrips) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    while(left < right) {\\n        let midTime = left + Math.floor((right - left)/2);\\n        let possible = canComplete(midTime);\\n        if(possible) {\\n            right = midTime;\\n        } else {\\n            left = midTime + 1;\\n        }\\n    }\\n    return right;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269666,
                "title": "simple-solution-using-range-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long trip(vector<int>& time,long mid){\\n        long total=0;\\n        for(long c:time){\\n            total+=mid/c;\\n        }\\n        return total;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long x=0;\\n        if(time.size()==1){\\n            x=time[0];\\n            long long y=totalTrips;\\n            return x*y;\\n        }\\n        sort(time.begin(),time.end());\\n        long l=1;\\n        long j=time[0];\\n        long r=j*totalTrips;\\n        \\n        while(l<r){\\n            long mid=(r-l)/2 +l;\\n            long total = trip(time,mid);\\n\\n            if(total<totalTrips){\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }\\n\\n        return l;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long trip(vector<int>& time,long mid){\\n        long total=0;\\n        for(long c:time){\\n            total+=mid/c;\\n        }\\n        return total;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long x=0;\\n        if(time.size()==1){\\n            x=time[0];\\n            long long y=totalTrips;\\n            return x*y;\\n        }\\n        sort(time.begin(),time.end());\\n        long l=1;\\n        long j=time[0];\\n        long r=j*totalTrips;\\n        \\n        while(l<r){\\n            long mid=(r-l)/2 +l;\\n            long total = trip(time,mid);\\n\\n            if(total<totalTrips){\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }\\n\\n        return l;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269595,
                "title": "2187-minimum-time-to-complete-trips-java",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int n=time.length;\\n        long sta=0,end=totalTrips;\\n        end*=time[n-1];\\n        long ans=Long.MAX_VALUE;\\n        while(sta<=end)\\n        {\\n            long mid=sta+(end-sta)/2;\\n            long cnt=0;\\n            for(int sum:time)\\n                cnt+=(mid/sum);\\n            if(cnt>=totalTrips)\\n            {\\n               ans=Math.min(ans,mid);\\n                end=mid-1;\\n            }  \\n            else\\n                sta=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int n=time.length;\\n        long sta=0,end=totalTrips;\\n        end*=time[n-1];\\n        long ans=Long.MAX_VALUE;\\n        while(sta<=end)\\n        {\\n            long mid=sta+(end-sta)/2;\\n            long cnt=0;\\n            for(int sum:time)\\n                cnt+=(mid/sum);\\n            if(cnt>=totalTrips)\\n            {\\n               ans=Math.min(ans,mid);\\n                end=mid-1;\\n            }  \\n            else\\n                sta=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269586,
                "title": "clean-code-python",
                "content": "**Please upvote if u liked the solution**\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect_left(range(time[0] * totalTrips + 1), True, key=lambda t: sum(t // bus for bus in time) >= totalTrips)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect_left(range(time[0] * totalTrips + 1), True, key=lambda t: sum(t // bus for bus in time) >= totalTrips)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269482,
                "title": "c-solution-binary-search-on-answer-explained-solution",
                "content": "# Intuition\\nWe need to minimize the time so we can think of applying binary search on answer concept and create a minimum and maximum limit on time possible and try to minimize the time by applying binary search on that interval.\\n\\n# Approach\\nWe create a lower limit (l) on time which will be the lowest time in the array and an upper limit (h) on time which will be ( lowest time in the array * totaltrips ), because the least maximum time in which totaltrips can be completed will be the lowest time in the array mutiplied by totaltrips. Now we have an interval on time. We calculate the middle value and check whether it can be our possible answer or not. If it is a valid answer then we store it and we move h = mid-1 and we check for a better answer in the left interval. If it cannot be a valid answer then we check for an answer in the right interval(a larger time can become an answer). In the end we return our answer.  \\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) where N is length of times array\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(), time.end());\\n        long long l = time[0];\\n        long long h = (long long)((long long)time[0]*(long long)totalTrips);\\n        long long mid = l+(h-l)/2;\\n        long long ans = LONG_LONG_MAX;\\n        while(l <= h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(check(mid, time, totalTrips))\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool check(long long time, vector<int>& times, int totaltrips)\\n    {\\n        bool valid = false;\\n        int currenttrips = 0;\\n        for(int i = 0;i < times.size(); i++)\\n        {\\n            if(times[i] > time)\\n            {\\n                break;\\n            }\\n            currenttrips += (time/times[i]);\\n            if(currenttrips >= totaltrips)\\n            {\\n                valid = true;\\n                break;\\n            }\\n        }\\n        return valid;\\n    }\\n};\\n```\\n\\n**Please upvote if you found it helpful ! \\uD83D\\uDE00\\uD83D\\uDE00**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(), time.end());\\n        long long l = time[0];\\n        long long h = (long long)((long long)time[0]*(long long)totalTrips);\\n        long long mid = l+(h-l)/2;\\n        long long ans = LONG_LONG_MAX;\\n        while(l <= h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(check(mid, time, totalTrips))\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool check(long long time, vector<int>& times, int totaltrips)\\n    {\\n        bool valid = false;\\n        int currenttrips = 0;\\n        for(int i = 0;i < times.size(); i++)\\n        {\\n            if(times[i] > time)\\n            {\\n                break;\\n            }\\n            currenttrips += (time/times[i]);\\n            if(currenttrips >= totaltrips)\\n            {\\n                valid = true;\\n                break;\\n            }\\n        }\\n        return valid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269444,
                "title": "python3-simple-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can reduce half the search space for time, in eac iteration of binary search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinay search\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet n be the length of time, m be the upper limit of totalTrips and k be the maximum time taken by one trip.\\nO(n.log(m.k))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        #binary search\\n        def checkIfTotalTripsCanHappen(timee):\\n            trips=0\\n            for i in time:\\n                trips+=(timee//i)\\n            return trips>=totalTrips\\n        #print(checkIfTotalTripsCanHappen(3))\\n        #print(checkIfTotalTripsCanHappen(2))\\n        #print(checkIfTotalTripsCanHappen(4))\\n\\n        left=1\\n        right=max(time)*totalTrips\\n        while(left<right):\\n            mid=left+(right-left)//2\\n            if(checkIfTotalTripsCanHappen(mid)):\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        #binary search\\n        def checkIfTotalTripsCanHappen(timee):\\n            trips=0\\n            for i in time:\\n                trips+=(timee//i)\\n            return trips>=totalTrips\\n        #print(checkIfTotalTripsCanHappen(3))\\n        #print(checkIfTotalTripsCanHappen(2))\\n        #print(checkIfTotalTripsCanHappen(4))\\n\\n        left=1\\n        right=max(time)*totalTrips\\n        while(left<right):\\n            mid=left+(right-left)//2\\n            if(checkIfTotalTripsCanHappen(mid)):\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269435,
                "title": "c-solution-easy-and-full-explanation-binary-search",
                "content": "\\n# Approach\\nTo solve this problem, we can use binary search. We can assume a range of possible values for the minimum time required for all buses to complete at least totalTrips trips. We can start with the range [0, max(time) * totalTrips], where max(time) is the maximum time taken by any bus for one trip.\\n\\nWe can then perform binary search on this range to find the minimum time required. For each mid value in the range, we can calculate the total number of trips that can be completed in that time by all the buses. If the total number of trips is less than totalTrips, then we can search for a higher value of mid. Otherwise, we can search for a lower value of mid.\\n\\n# Complexity\\n- Time complexity:\\nO(n log m)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long left = 0;\\n        long long right = *max_element(time.begin(), time.end()) * (long long)totalTrips;\\n        \\n        while (left < right) {\\n            long long mid = (left + right) / 2;\\n            long long trips = 0;\\n            \\n            for (int t : time) {\\n                trips += mid / t;\\n            }\\n            \\n            if (trips < totalTrips) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long left = 0;\\n        long long right = *max_element(time.begin(), time.end()) * (long long)totalTrips;\\n        \\n        while (left < right) {\\n            long long mid = (left + right) / 2;\\n            long long trips = 0;\\n            \\n            for (int t : time) {\\n                trips += mid / t;\\n            }\\n            \\n            if (trips < totalTrips) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269374,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n        let minimumTime = time.min()!\\n\\n        var l = minimumTime\\n        var r = minimumTime * totalTrips\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            let trips = time.reduce(0, { $0 + mid / $1 })\\n            if trips < totalTrips {\\n                l = mid + 1\\n            } else {\\n                r = mid - 1\\n            }\\n        }\\n\\n        return l\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n        let minimumTime = time.min()!\\n\\n        var l = minimumTime\\n        var r = minimumTime * totalTrips\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            let trips = time.reduce(0, { $0 + mid / $1 })\\n            if trips < totalTrips {\\n                l = mid + 1\\n            } else {\\n                r = mid - 1\\n            }\\n        }\\n\\n        return l\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269314,
                "title": "c-using-binary-saerch-explained-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can find whether the totalTrips can be completed in given time in O(n) complexity. We just need the appropriate time. If we have minTime and maxTime then we can easily find the appropriate time in O(logn) complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First sort the time array. time[0] will be the smallest element and time[n-1] will be the greatest element.\\n2. The maxTime to complete all trips will be -> time[n-1] * totalTrips.\\n3. The minTime will be 1 day.\\n4. int mid = (minTime + maxTime) / 2; If totalTrips are completed within mid time then maxTime = mid. Else we require more time. Then minTime = mid + 1.\\n5. This process will be repeated until minTime < maxTime. Once the condition fails we will return minTime. The complexity of this process will be O(logn).\\n6. To check if the totalTrips are completed within mid time, we will iterate through loop and check if summation of mid/ time[i] is greater than mid time. If it is grater the totalTrips can\\'t be completed in mid time and we will return false. If the summation sis less than mid time then we will return true. The complexity of this process will be O(n).\\n7. The total complexity of the solution will be O(nlogn).\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mo = 1e9+7;\\n    bool f(long long x,vector<int>&time,int totalTrips){\\n        long long int ans = 0;\\n        for(int i = 0;i < time.size();i++){\\n            ans += (long long)(x / time[i]);\\n        }\\n        if(ans >= totalTrips)return true;\\n        return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(),time.end());\\n        int n = time.size();\\n        long long  minTime = 1;\\n        long long  maxTime = ((long long)(time[n-1]) * (long long)(totalTrips));\\n        while(minTime < maxTime){\\n            long long  mid = (minTime + maxTime) / 2;\\n            // cout << minTime << \" \" << maxTime << endl;\\n            if(f(mid,time,totalTrips)){\\n                maxTime = mid;\\n            }\\n            else{\\n                minTime = mid + 1;\\n            }\\n        }\\n        return minTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mo = 1e9+7;\\n    bool f(long long x,vector<int>&time,int totalTrips){\\n        long long int ans = 0;\\n        for(int i = 0;i < time.size();i++){\\n            ans += (long long)(x / time[i]);\\n        }\\n        if(ans >= totalTrips)return true;\\n        return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(),time.end());\\n        int n = time.size();\\n        long long  minTime = 1;\\n        long long  maxTime = ((long long)(time[n-1]) * (long long)(totalTrips));\\n        while(minTime < maxTime){\\n            long long  mid = (minTime + maxTime) / 2;\\n            // cout << minTime << \" \" << maxTime << endl;\\n            if(f(mid,time,totalTrips)){\\n                maxTime = mid;\\n            }\\n            else{\\n                minTime = mid + 1;\\n            }\\n        }\\n        return minTime;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3269244,
                "title": "easy-to-remember-binary-search-approach",
                "content": "# Approach\\nGuess the minimum value using binary search\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogm)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    long long getTrips(vector<int>& time, long long val) {\\n        long long count = 0;\\n        for(auto itr:time) {\\n            count += val/itr;\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long high = 100000000000000LL, low = 1;\\n        long long ans = high;\\n\\n        while(low <= high) {\\n            long long mid = (low + high)/2;\\n            if(totalTrips<= getTrips(time, mid)) {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you like the approach",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    long long getTrips(vector<int>& time, long long val) {\\n        long long count = 0;\\n        for(auto itr:time) {\\n            count += val/itr;\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long high = 100000000000000LL, low = 1;\\n        long long ans = high;\\n\\n        while(low <= high) {\\n            long long mid = (low + high)/2;\\n            if(totalTrips<= getTrips(time, mid)) {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268986,
                "title": "o-n-log-k-solution-1378-ms-in-python3-beats-100",
                "content": "Here is a solution which is more efficient that the solutions using only the minimum of `time` for computing the upper bound.\\n\\nEDIT: I added an improvement whose worst-case complexity only depends on $$n$$: no matter `totalTrips` and the values in `time`, it runs in at most $$O(n \\\\log(n))$$, and it can be faster depending on the values in `time`.\\n\\n# Intuition\\n- Provide improved bounds on the time required before starting the binary search.\\n\\n# Approach\\n\\nThis assumes that you understood properly the simple solution.\\n\\n## Computation of the bounds\\nLet $$x_1, ..., x_n$$ be the values in the array `time`, let $$p$$ be `totalTrips`, let $$T_0$$ be the result and let $$S = \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\displaystyle \\\\frac{1}{x_i}$$.\\n\\nFor a given time $$t$$, the maximal number of trips is $$f(t) = \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\left \\\\lfloor \\\\displaystyle \\\\frac{t}{x_i} \\\\right \\\\rfloor$$.\\n\\n**Lower bound** \\n$$T_0 \\\\geqslant \\\\left \\\\lceil \\\\displaystyle \\\\frac{p}{S} \\\\right \\\\rceil$$\\n\\n**Proof of the lower bound**\\nOn the one hand, $$f(T_0) = \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\left \\\\lfloor \\\\displaystyle \\\\frac{T_0}{x_i} \\\\right \\\\rfloor \\\\leqslant \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\displaystyle \\\\frac{T_0}{x_i} = T_0 S$$. \\nOn the other hand, $$f(T_0) \\\\geqslant p$$ by definition of $$T_0$$.\\nTherefore, $$T_0 \\\\geqslant \\\\displaystyle \\\\frac{p}{S}$$.\\n\\n\\n**Upper bound**\\n$$T_0 \\\\leqslant 1 + \\\\left \\\\lfloor \\\\displaystyle \\\\frac{p + n - 1}{S}\\\\right \\\\rfloor$$\\n**Proof of the upper bound**\\nFirst, $$f(T_0 - 1) = \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\left \\\\lfloor \\\\displaystyle \\\\frac{T_0 - 1}{x_i} \\\\right \\\\rfloor > \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\left( \\\\displaystyle \\\\frac{T_0 - 1}{x_i} - 1 \\\\right) = (T_0 - 1) S - n$$.\\nBesides, $$f(T_0 - 1) \\\\leqslant p - 1$$ by definition of $$T_0$$.\\nThen $$T_0 < 1 + \\\\displaystyle \\\\frac{p + n - 1}{S}$$.\\n\\n## Floating point caveat\\nComputing the sum of the inverses of the elements of `time` is subject to rounding errors because it uses float. This is why in the code I use `fsum` instead of `sum` for a more accurate computation as well as `float_safety = 1e-3` so if that the result is really close to an integer I actually move pass that integer.\\n\\n## EDIT: An improvement with an even better complexity\\nNote: this is slower in practice unless the integers in `time` are quite big.\\n\\n**Observation:** $$T_0$$ is necessarily a multiple of some $$x_i$$ (consequence of the minimality of $$T_0$$).\\n\\nWhat makes the binary search slow down when the $$x_i$$\\'s get really big in comparision to $$n$$ is that we might do little steps whereas the multiples are sparse.\\n\\nHere is an example (not realistic, just to convey the idea):\\n- We are looking for a multiple of $$2^{1000}$$\\n- $$left = 5 \\\\times 2^{1000} - 42$$ and $$right = 6 \\\\times 2^{1000} - 42$$\\n    - Simple binary search would need 1000 iterations.\\n    - Jumping to multiples would require 2 iterations.\\n\\n**Algorithm: Modified binary search**\\nInstead of updating `right` or `left` with the middle value, we use the following updating rule.\\n\\n- If we want to update `right` to `mid`, run through the array to find to largest multiple not greater than `mid` and use this value for the update.\\n- If we want to update `left` to `mid + 1`, run through the array to find to smallest multiple greater than `mid` and use this value for the update.\\n\\nEach update runs in $$O(n)$$ so the complexity of each iteration of the binary search is still the same.\\n\\n# Complexity\\nLet $$n$$ be the length of time, $$k$$ be the maximum time taken by one trip, and $$l$$ be the maximum time taken by one trip.\\n- Time complexity: $$O(n \\\\log(\\\\min(k, nl))$$ (actually $$O(n \\\\log\\\\frac{n}{S})$$)\\n    - $$S \\\\geqslant \\\\displaystyle \\\\frac{n}{k}$$ and $$S \\\\geqslant \\\\displaystyle \\\\frac{1}{l}$$.\\n    - For the binary search, the size of the search space is less than $$ 1 + \\\\displaystyle \\\\frac{n}{S} \\\\leqslant 1 + \\\\min(k, nl)$$ so it requires $$O(\\\\log(\\\\min(k, nl)))$$ iterations.\\n    - Each binary search iteration runs in $$O(n)$$.\\n    - Computation of the bounds is done in $$O(n)$$.\\n- EDIT: Time complexity of the improved version: $$O(n \\\\log(n \\\\min(1, S^{-1})))$$\\n    - The number of iteration of the modified binary search depends on the number of multiples of $$x_i$$\\'s in the search interval which is less than $$length\\\\_of\\\\_interval \\\\times S + n$$, that is $$O(n)$$.\\n\\n\\n# Code\\nNote: this code is a simplified version of my submission for users who are not very familiar with python. My actual submission uses a python specific trick to have a faster running code although with the same complexity (see below).\\n\\n```python []\\nfrom math import ceil, floor, fsum\\n\\n\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        n = len(time)\\n        # use fsum instead of sum for improved float accuracy\\n        sum_inv = fsum(1 / t for t in time)\\n        # add an extra margin because of rounding errors\\n        float_safety = 1e-3\\n        left = ceil(totalTrips / sum_inv - float_safety)\\n        right = floor((totalTrips + n - 1) / sum_inv + float_safety)\\n\\n        while left != right:\\n            mid = (left + right) // 2\\n            if sum((mid // t for t in time)) >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n```\\n\\nMy actual code uses the map builtin with a dunder method twice because it is faster than a handwritten generator.\\n\\n```python []\\nfsum(map((1).__truediv__, time))\\n# instead of\\nfsum(1 / t for t in time)\\n\\n# and\\n\\nsum(map(mid.__floordiv__, time))\\n# instead of\\nsum((mid // t for t in time))\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nfrom math import ceil, floor, fsum\\n\\n\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        n = len(time)\\n        # use fsum instead of sum for improved float accuracy\\n        sum_inv = fsum(1 / t for t in time)\\n        # add an extra margin because of rounding errors\\n        float_safety = 1e-3\\n        left = ceil(totalTrips / sum_inv - float_safety)\\n        right = floor((totalTrips + n - 1) / sum_inv + float_safety)\\n\\n        while left != right:\\n            mid = (left + right) // 2\\n            if sum((mid // t for t in time)) >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n```\n```python []\\nfsum(map((1).__truediv__, time))\\n# instead of\\nfsum(1 / t for t in time)\\n\\n# and\\n\\nsum(map(mid.__floordiv__, time))\\n# instead of\\nsum((mid // t for t in time))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268735,
                "title": "simple-binary-search-c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n       long long n =time.size();\\n       sort(time.begin(), time.end()); \\n       long long low = 0 ,high = totalTrips*(long long)time[0];\\n       while(low < high){\\n           long long mid = low + (high - low) / 2;\\n           long long completed = 0;\\n           for(auto x:time){\\n              completed += mid/x;\\n           }\\n           if(completed < totalTrips)\\n               low = mid + 1;\\n           else \\n              high = mid;\\n       }\\n       return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n       long long n =time.size();\\n       sort(time.begin(), time.end()); \\n       long long low = 0 ,high = totalTrips*(long long)time[0];\\n       while(low < high){\\n           long long mid = low + (high - low) / 2;\\n           long long completed = 0;\\n           for(auto x:time){\\n              completed += mid/x;\\n           }\\n           if(completed < totalTrips)\\n               low = mid + 1;\\n           else \\n              high = mid;\\n       }\\n       return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268725,
                "title": "whole-trips",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * log(totalTrips * minTripTime))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canMakeTrips(vector<int>& time, int totalTrips, long long Ttime) {\\n        long long trips = 0;\\n        for(int t: time)\\n            trips += Ttime / t;\\n        return trips >= totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long mint = *min_element(time.begin(), time.end());\\n        long long mid, l = mint, r = totalTrips * mint;\\n        while(l <= r) {\\n            mid = l + (r - l) / 2;\\n            if(canMakeTrips(time, totalTrips, mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canMakeTrips(vector<int>& time, int totalTrips, long long Ttime) {\\n        long long trips = 0;\\n        for(int t: time)\\n            trips += Ttime / t;\\n        return trips >= totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long mint = *min_element(time.begin(), time.end());\\n        long long mid, l = mint, r = totalTrips * mint;\\n        while(l <= r) {\\n            mid = l + (r - l) / 2;\\n            if(canMakeTrips(time, totalTrips, mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268706,
                "title": "python3-solution-beats-84-75",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(n):\\n            s = 0\\n            for i in time:\\n                s += n // i\\n            return s >= totalTrips\\n\\n        l = -1\\n        r = totalTrips * min(time)\\n        while l + 1 < r:\\n            mid = (l + r) >> 1\\n            if check(mid):\\n                r = mid\\n            else:\\n                l = mid\\n        return r\\n```\\n\\n# Complexity\\n- Time complexity: O(len(time) * log(totalTrips * min(time))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(n):\\n            s = 0\\n            for i in time:\\n                s += n // i\\n            return s >= totalTrips\\n\\n        l = -1\\n        r = totalTrips * min(time)\\n        while l + 1 < r:\\n            mid = (l + r) >> 1\\n            if check(mid):\\n                r = mid\\n            else:\\n                l = mid\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268566,
                "title": "get-the-range-and-do-binary-search",
                "content": "tle:\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& a, int tt) {\\n        \\n        int n = a.size();\\n        vector<int> mp(n);\\n        \\n        mp = a;\\n        long long int t = 0, res=0;\\n        \\n        while(1)\\n        {\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                mp[i]--;\\n                \\n                if(mp[i] == 0)\\n                {\\n                    res++;\\n                    mp[i] = a[i];\\n                }\\n                \\n            }\\n            \\n            t++;\\n            \\n            if(res>=tt)\\n                break;\\n        }\\n        \\n        return t;\\n            \\n        \\n    }\\n};\\n```\\n\\naccepted:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& a, int tt,long long int val)\\n    {\\n        long long int cnt=0;\\n        for(auto i: a)\\n        {\\n            cnt+=(val/i);\\n        }\\n        \\n        return cnt>=tt;\\n    }\\n    long long minimumTime(vector<int>& a, int tt) {\\n        \\n        int n = a.size();\\n        long long int l,r,ans;\\n        l = INT_MAX;\\n        r = INT_MIN;\\n        \\n        for(long long int i: a)\\n        {\\n            l = min(i,l);\\n            r = max(i,r); \\n        }\\n        \\n        r*=tt;\\n        \\n        while(l<=r)\\n        {\\n            long long int mid = l+(r-l)/2;\\n            if(check(a,tt,mid))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& a, int tt) {\\n        \\n        int n = a.size();\\n        vector<int> mp(n);\\n        \\n        mp = a;\\n        long long int t = 0, res=0;\\n        \\n        while(1)\\n        {\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                mp[i]--;\\n                \\n                if(mp[i] == 0)\\n                {\\n                    res++;\\n                    mp[i] = a[i];\\n                }\\n                \\n            }\\n            \\n            t++;\\n            \\n            if(res>=tt)\\n                break;\\n        }\\n        \\n        return t;\\n            \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& a, int tt,long long int val)\\n    {\\n        long long int cnt=0;\\n        for(auto i: a)\\n        {\\n            cnt+=(val/i);\\n        }\\n        \\n        return cnt>=tt;\\n    }\\n    long long minimumTime(vector<int>& a, int tt) {\\n        \\n        int n = a.size();\\n        long long int l,r,ans;\\n        l = INT_MAX;\\n        r = INT_MIN;\\n        \\n        for(long long int i: a)\\n        {\\n            l = min(i,l);\\n            r = max(i,r); \\n        }\\n        \\n        r*=tt;\\n        \\n        while(l<=r)\\n        {\\n            long long int mid = l+(r-l)/2;\\n            if(check(a,tt,mid))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268529,
                "title": "java-binary-search-on-answer",
                "content": "```\\nclass Solution {\\n    \\n    public long possibleTrips(long mid,int[] time){\\n        long trips = 0;\\n        for(int t : time){\\n            trips+=(mid/t);\\n        }\\n        return trips;\\n    }\\n    \\n    long ans = Long.MAX_VALUE;\\n    \\n    public void solve(long i, long j, int[] time, int totalTrips){\\n        while(i<=j){\\n            long mid = i+ ( (j-i)/2 );\\n            long tripsPossible = possibleTrips(mid,time);\\n            if(tripsPossible >= totalTrips){\\n                ans = Math.min(mid,ans);\\n                j = mid - 1;\\n            }else\\n                i = mid + 1;\\n        }\\n    }\\n    \\n    public long minimumTime(int[] time, int totalTrips) {\\n        long i = 0, j = totalTrips;\\n        int n = time.length;\\n        j*=time[n-1];\\n        solve(i,j,time,totalTrips);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long possibleTrips(long mid,int[] time){\\n        long trips = 0;\\n        for(int t : time){\\n            trips+=(mid/t);\\n        }\\n        return trips;\\n    }\\n    \\n    long ans = Long.MAX_VALUE;\\n    \\n    public void solve(long i, long j, int[] time, int totalTrips){\\n        while(i<=j){\\n            long mid = i+ ( (j-i)/2 );\\n            long tripsPossible = possibleTrips(mid,time);\\n            if(tripsPossible >= totalTrips){\\n                ans = Math.min(mid,ans);\\n                j = mid - 1;\\n            }else\\n                i = mid + 1;\\n        }\\n    }\\n    \\n    public long minimumTime(int[] time, int totalTrips) {\\n        long i = 0, j = totalTrips;\\n        int n = time.length;\\n        j*=time[n-1];\\n        solve(i,j,time,totalTrips);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268525,
                "title": "swift-with-image",
                "content": "# Intuition\\nMake init range from **min** value to **max * totalTrips**. Our answer in this range. (In the example below 1...15)\\n\\nUse binary search for getting full time and count all bus tours for each busses.\\n\\n**Input: time = [1,2,3], totalTrips = 5**\\n![Screenshot 2023-03-07 at 16.02.04.png](https://assets.leetcode.com/users/images/f632753f-721b-427c-a895-3acdf9c01070_1678190558.5573187.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n        var left = time.min()!\\n        var right = time.max()! * totalTrips\\n\\n        func timeEnough(_ int: Int) -> Bool {\\n            var tripsCount = 0\\n\\n            for t in time {\\n                tripsCount += (int / t)\\n            }\\n\\n            return tripsCount >= totalTrips\\n        }\\n\\n        while left < right {\\n            let mid = (left + right) / 2\\n\\n            if timeEnough(mid) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n        var left = time.min()!\\n        var right = time.max()! * totalTrips\\n\\n        func timeEnough(_ int: Int) -> Bool {\\n            var tripsCount = 0\\n\\n            for t in time {\\n                tripsCount += (int / t)\\n            }\\n\\n            return tripsCount >= totalTrips\\n        }\\n\\n        while left < right {\\n            let mid = (left + right) / 2\\n\\n            if timeEnough(mid) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268521,
                "title": "brute-force-to-optimal-c-binary-search",
                "content": "\\n# Brute Force (TLE)\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        long long CurrentTime = 0;\\n\\n\\n        while(1)\\n        {\\n            CurrentTime++;\\n\\n            for(int i = 0; i<time.size(); i++)\\n            {\\n                if(CurrentTime%time[i]==0)\\n                {\\n                    totalTrips--;\\n                }\\n\\n                if(totalTrips<=0) break;\\n            }\\n\\n            if(totalTrips<=0) break;\\n        }\\n\\n\\n        return CurrentTime;\\n        \\n    }\\n};\\n```\\n\\n# Binary Search (Accepted)\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&time, long long currentTime, int totalTrips)\\n    {\\n        long long maximumTrip = 0;\\n\\n\\n        for(auto &it : time)\\n        {\\n            maximumTrip+= currentTime/it;\\n        }\\n\\n        return maximumTrip>=totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        int n = time.size();\\n\\n\\n        long long start = 1;\\n\\n        long long last = (long long) *min_element(begin(time), end(time)) * totalTrips;\\n\\n        // Apply Binary Search in this range\\n\\n\\n        while(start<last)\\n        {\\n            long long mid = start + (last-start)/2;\\n\\n            if(isPossible(time,mid,totalTrips))\\n            {\\n                // if it is true then no need to search in the part which is grater than mid; so reduce the search space and check for left side if there any minimum number is possible.\\n\\n                last = mid;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n\\n\\n        return start;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        long long CurrentTime = 0;\\n\\n\\n        while(1)\\n        {\\n            CurrentTime++;\\n\\n            for(int i = 0; i<time.size(); i++)\\n            {\\n                if(CurrentTime%time[i]==0)\\n                {\\n                    totalTrips--;\\n                }\\n\\n                if(totalTrips<=0) break;\\n            }\\n\\n            if(totalTrips<=0) break;\\n        }\\n\\n\\n        return CurrentTime;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&time, long long currentTime, int totalTrips)\\n    {\\n        long long maximumTrip = 0;\\n\\n\\n        for(auto &it : time)\\n        {\\n            maximumTrip+= currentTime/it;\\n        }\\n\\n        return maximumTrip>=totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        int n = time.size();\\n\\n\\n        long long start = 1;\\n\\n        long long last = (long long) *min_element(begin(time), end(time)) * totalTrips;\\n\\n        // Apply Binary Search in this range\\n\\n\\n        while(start<last)\\n        {\\n            long long mid = start + (last-start)/2;\\n\\n            if(isPossible(time,mid,totalTrips))\\n            {\\n                // if it is true then no need to search in the part which is grater than mid; so reduce the search space and check for left side if there any minimum number is possible.\\n\\n                last = mid;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n\\n\\n        return start;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268475,
                "title": "minimum-time-to-complete-trips-using-binary-search",
                "content": "# Solution Roadmap\\n- The problem statement asks us to find the minimum time required for all buses to complete at least totalTrips trips. Since each bus can make multiple trips successively, we can assume that the trips of one bus do not influence the trips of any other bus. Therefore, we can focus on finding the minimum time required for a single bus to complete at least totalTrips trips, and then multiply that time by the number of buses we have.\\n- One way to find the minimum time required for a single bus to complete at least totalTrips trips is to use binary search. We can start by sorting the time array in increasing order, and then use binary search to search for the minimum time.\\n- In each iteration of the binary search, we calculate the mid time and count the number of trips that can be completed in mid time. We do this by dividing the mid time by the time taken by each bus, and summing up the results. If the number of trips is greater than or equal to totalTrips, we adjust the search range to the left; otherwise, we adjust the search range to the right.\\n- Once we find the minimum time required for a single bus to complete at least totalTrips trips, we can multiply that time by the number of buses we have to get the minimum time required for all buses to complete at least totalTrips trips.\\n- The time complexity of the solution is O(n log T), where n is the length of the time array and T is the maximum time taken by a bus to complete one trip. The space complexity of the solution is O(1), as we only use a constant amount of extra space to store the variables.\\n- Finally, we can implement the solution in Python by defining a Solution class with a minimumTime method that takes an array of times and the total number of trips as input, and returns the minimum time required for all buses to complete at least totalTrips trips. We can then create an instance of the Solution class and call its minimumTime method with the input parameters.\\n\\n# Code (Python Program)\\n```\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        \"\"\"\\n        :type time: List[int]\\n        :type totalTrips: int\\n        :rtype: int\\n        \"\"\"\\n        # Sort the time array in increasing order\\n        time.sort()\\n        \\n        # Initialize the variables\\n        n = len(time)\\n        l = 0\\n        r = time[n-1] * totalTrips\\n        \\n        # Binary search for the minimum time\\n        while l < r:\\n            mid = (l + r) // 2\\n            trips = 0\\n            \\n            # Count the number of trips that can be completed in mid time\\n            for i in range(n):\\n                trips += (mid // time[i])\\n                if trips >= totalTrips:\\n                    break\\n            \\n            # Adjust the search range\\n            if trips >= totalTrips:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        # Return the minimum time\\n        return l\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        \"\"\"\\n        :type time: List[int]\\n        :type totalTrips: int\\n        :rtype: int\\n        \"\"\"\\n        # Sort the time array in increasing order\\n        time.sort()\\n        \\n        # Initialize the variables\\n        n = len(time)\\n        l = 0\\n        r = time[n-1] * totalTrips\\n        \\n        # Binary search for the minimum time\\n        while l < r:\\n            mid = (l + r) // 2\\n            trips = 0\\n            \\n            # Count the number of trips that can be completed in mid time\\n            for i in range(n):\\n                trips += (mid // time[i])\\n                if trips >= totalTrips:\\n                    break\\n            \\n            # Adjust the search range\\n            if trips >= totalTrips:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        # Return the minimum time\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268194,
                "title": "explanation-of-each-line-of-code-in-binary-search-best-and-easy-solution-using-c",
                "content": "# Intuition\\nchecking possible time to complete totaltrips in binary search function:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& t, int ttl) {\\n        if(t.size() == 1){\\n            return (long long)t[0] * ttl; //result will total time to complete totaltrip by bus 0\\n        }\\n        sort(t.begin(),t.end());\\n        long long s = 0;\\n        int n = t.size();\\n        long long e = (long long)t[n-1]*ttl;  // max time taken will be the bus with maximum time \\n        long long res  = e;\\n        while(s<=e){\\n            long long mid = s+(e-s)/2;\\n            long long ans = 0;\\n            for(int i  = 0;i<t.size();i++){\\n                ans += (long long)(mid/t[i]); //checking each bus that how much trips does i^th bus take in mid time\\n            }\\n            if(ans>=ttl){\\n                res = mid;\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n        }        \\n        return res;\\n    }\\n};\\n\\n\\n```\\n\\n\\n![025a6e75-7e39-4bdd-8ecd-ea9c6023729a_1672712882.8563874.png](https://assets.leetcode.com/users/images/1a527f43-ae41-4ef2-b067-db7c8c564f33_1678184344.4992063.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& t, int ttl) {\\n        if(t.size() == 1){\\n            return (long long)t[0] * ttl; //result will total time to complete totaltrip by bus 0\\n        }\\n        sort(t.begin(),t.end());\\n        long long s = 0;\\n        int n = t.size();\\n        long long e = (long long)t[n-1]*ttl;  // max time taken will be the bus with maximum time \\n        long long res  = e;\\n        while(s<=e){\\n            long long mid = s+(e-s)/2;\\n            long long ans = 0;\\n            for(int i  = 0;i<t.size();i++){\\n                ans += (long long)(mid/t[i]); //checking each bus that how much trips does i^th bus take in mid time\\n            }\\n            if(ans>=ttl){\\n                res = mid;\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n        }        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268189,
                "title": "golang-binarysearch",
                "content": "# Code\\n```\\nfunc minimumTime(time []int, totalTrips int) int64 {\\n    maxTime := 0\\n    for i := 0; i < len(time); i++ {\\n        if time[i] > maxTime {\\n            maxTime = time[i]\\n        }\\n    }\\n\\n    left, right := 1, maxTime * totalTrips\\n    for left < right {\\n        mid := (left+right)/2\\n        if isTimeEnough(time, mid, totalTrips) {\\n            right = mid\\n        } else {\\n            left = mid+1\\n        }\\n    }\\n\\n    return int64(left)\\n}\\n\\nfunc isTimeEnough(time []int, pivot, totalTrips int) bool {\\n    count := 0\\n    for i := 0; i < len(time); i++ {\\n        count += pivot / time[i]\\n    }\\n    \\n    return count >= totalTrips\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumTime(time []int, totalTrips int) int64 {\\n    maxTime := 0\\n    for i := 0; i < len(time); i++ {\\n        if time[i] > maxTime {\\n            maxTime = time[i]\\n        }\\n    }\\n\\n    left, right := 1, maxTime * totalTrips\\n    for left < right {\\n        mid := (left+right)/2\\n        if isTimeEnough(time, mid, totalTrips) {\\n            right = mid\\n        } else {\\n            left = mid+1\\n        }\\n    }\\n\\n    return int64(left)\\n}\\n\\nfunc isTimeEnough(time []int, pivot, totalTrips int) bool {\\n    count := 0\\n    for i := 0; i < len(time); i++ {\\n        count += pivot / time[i]\\n    }\\n    \\n    return count >= totalTrips\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3268053,
                "title": "c-binary-search",
                "content": "# Approach\\nUse binary search to find lowest number of trips.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public long MinimumTime(int[] time, int totalTrips)\\n    {\\n        var left = 1L;\\n        var right = long.MaxValue;\\n\\n        while (left < right)\\n        {\\n            var mid = left + (right - left) / 2;\\n\\n            var trips = 0L;\\n            \\n            foreach (var t in time)\\n            {\\n                trips += mid / t;\\n                if (trips >= totalTrips)\\n                {\\n                    // To avoid sum overflow\\n                    break;\\n                }\\n            }\\n\\n            if (trips >= totalTrips)\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MinimumTime(int[] time, int totalTrips)\\n    {\\n        var left = 1L;\\n        var right = long.MaxValue;\\n\\n        while (left < right)\\n        {\\n            var mid = left + (right - left) / 2;\\n\\n            var trips = 0L;\\n            \\n            foreach (var t in time)\\n            {\\n                trips += mid / t;\\n                if (trips >= totalTrips)\\n                {\\n                    // To avoid sum overflow\\n                    break;\\n                }\\n            }\\n\\n            if (trips >= totalTrips)\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268011,
                "title": "range-bs-very-easy-to-understand-must-see",
                "content": "# Code\\n```\\n//for fast input and output\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\n//code begins here\\nclass Solution \\n{\\npublic:\\n    long long minimumTime(vector<int>& arr, int totalTrips) \\n    {\\n         long long int minele = *min_element(arr.begin(),arr.end());\\n\\n         long long int left = 0;\\n         long long int right = 1LL*minele * totalTrips;\\n          \\n         long long int ans = LONG_MAX;\\n         while(left <= right)\\n         {\\n             long long int Tmid = (1LL*left) + ((right - left)/2); \\n             \\n             //checking how many trips can be completed at time = Tmid\\n             long long int trip_count = fun(arr,Tmid);\\n\\n             if(trip_count < totalTrips)\\n             {\\n                 left = Tmid+1;\\n             }\\n             else if(trip_count > totalTrips)\\n             {\\n                if(Tmid < ans) ans = Tmid;\\n                right = Tmid-1;\\n             }\\n             else if(trip_count == totalTrips)\\n             {\\n                if(Tmid < ans) ans = Tmid;\\n                right = Tmid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n    long long int fun(vector<int>&arr,long long int time)\\n    {\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (time/arr[i]);\\n            count = count + temp;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n//for fast input and output\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\n//code begins here\\nclass Solution \\n{\\npublic:\\n    long long minimumTime(vector<int>& arr, int totalTrips) \\n    {\\n         long long int minele = *min_element(arr.begin(),arr.end());\\n\\n         long long int left = 0;\\n         long long int right = 1LL*minele * totalTrips;\\n          \\n         long long int ans = LONG_MAX;\\n         while(left <= right)\\n         {\\n             long long int Tmid = (1LL*left) + ((right - left)/2); \\n             \\n             //checking how many trips can be completed at time = Tmid\\n             long long int trip_count = fun(arr,Tmid);\\n\\n             if(trip_count < totalTrips)\\n             {\\n                 left = Tmid+1;\\n             }\\n             else if(trip_count > totalTrips)\\n             {\\n                if(Tmid < ans) ans = Tmid;\\n                right = Tmid-1;\\n             }\\n             else if(trip_count == totalTrips)\\n             {\\n                if(Tmid < ans) ans = Tmid;\\n                right = Tmid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n    long long int fun(vector<int>&arr,long long int time)\\n    {\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (time/arr[i]);\\n            count = count + temp;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3267984,
                "title": "c-code-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nc++ easy way to solve\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nc++\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n(o1)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(),time.end());\\n        long long l=0,r=1e14,ans=1e14;\\n        while(l<r){\\n          long long  mid=l+(r-l)/2;\\n           long long cnt=0;\\n           for(int i=0;i<time.size();i++){\\n               cnt+=(mid/time[i]);\\n           } \\n           if(cnt>=totalTrips){\\n               ans=mid;\\n               r=mid;\\n           }\\n           else\\n           l=mid+1;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(),time.end());\\n        long long l=0,r=1e14,ans=1e14;\\n        while(l<r){\\n          long long  mid=l+(r-l)/2;\\n           long long cnt=0;\\n           for(int i=0;i<time.size();i++){\\n               cnt+=(mid/time[i]);\\n           } \\n           if(cnt>=totalTrips){\\n               ans=mid;\\n               r=mid;\\n           }\\n           else\\n           l=mid+1;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267933,
                "title": "simple-c-solution-binary-search-upvote-if-helpful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    bool check(vector<int>& time,ll mid,ll t){\\n        ll trips=0;\\n        for(auto &i:time){\\n            trips+=(mid/i);\\n            if(trips>=t) return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int t) {\\n        int n=time.size();\\n        sort(time.begin(),time.end());\\n        ll r=(ll)time[0];\\n        ll h=(ll)time[n-1]*(ll)t;\\n        while(r<h){\\n            ll mid=r+(h-r)/2;\\n            if(check(time,mid,t)){\\n                h=mid;\\n            }else r=mid+1;\\n        }\\n        return r;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    bool check(vector<int>& time,ll mid,ll t){\\n        ll trips=0;\\n        for(auto &i:time){\\n            trips+=(mid/i);\\n            if(trips>=t) return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int t) {\\n        int n=time.size();\\n        sort(time.begin(),time.end());\\n        ll r=(ll)time[0];\\n        ll h=(ll)time[n-1]*(ll)t;\\n        while(r<h){\\n            ll mid=r+(h-r)/2;\\n            if(check(time,mid,t)){\\n                h=mid;\\n            }else r=mid+1;\\n        }\\n        return r;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267865,
                "title": "video-explanation-how-to-approch-this-type-of-problem-binary-search-c",
                "content": "If you don\\'t know hind skip video and read the solution article below , Hindi Video Explanation :- https://youtu.be/YLPtZiFaVKU\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever we get any problem , we should find all the useful hints/ details from the problem . \\nHere looking at constraints we can find than **O(n log n)** is the **worst allowed time complexity** .\\n\\nWe can use **binary_search** to get O(n log n) solution . We need to get more strong details to used binary_search , can we bound \\'time_taken\\' ?\\nYes **minimun time** possible = 1, and **max_time_taken** = (max_value* tot_trips)  in worst case **max_vaue = 10^7** and **tot_trips = 10^7** ,\\nso **max_time_taken = 10^14** for all the test cases .\\n\\n\\nNow we can confirm that **Binary search** can be implemented.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe implemetn binary serach in range [1,10^14] ,\\nand for each **mid** value we will find the tot_trips_possible ,\\nif (tot_trips_possible >= tot_trips),\\nthen we reduce the range from [start,end] -- > [start,mid-1]\\nelse if not possible then we change from [start,end] -- > [mid+1,end]\\ncomputer the **mid = (start+end)/2**  again and continue.\\nUntil our binary seearch continue and update the answer too.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Why I was not able to understand this is binary search\\n    \\n    long long minimumTime(vector<int>& A, int tot_trip) {\\n        long long ans = 1e18;\\n        \\n        //upper bound in worst case is max_value*tot_trip , tot_trip can be upto 10^7 and max_value = 10^7 \\n        //so 10^14 in worst case .  \\n         \\n        \\n        long long start = 1,end = 1e14,mid = (start+end)/2;\\n         \\n        \\n        while(start<=end){\\n            \\n            long long current_trip = 0;\\n\\n            for(auto&x:A){\\n                current_trip +=(mid/x);\\n                \\n                //if current number of trips in time \\'mid\\' is greater\\n                //than equal to required total_trip we go out of loop as we have achieved total trip\\n                if(current_trip >= tot_trip){\\n                    break;\\n                }\\n            }\\n            if(current_trip >= tot_trip){\\n                end = mid-1;\\n                ans = min(ans,mid);\\n                mid = (start+end)/2;\\n            }\\n            else{\\n                start = mid+1;\\n                mid = (start+end)/2;\\n            }\\n        }\\n        return ans;\\n    }\\n} ;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Why I was not able to understand this is binary search\\n    \\n    long long minimumTime(vector<int>& A, int tot_trip) {\\n        long long ans = 1e18;\\n        \\n        //upper bound in worst case is max_value*tot_trip , tot_trip can be upto 10^7 and max_value = 10^7 \\n        //so 10^14 in worst case .  \\n         \\n        \\n        long long start = 1,end = 1e14,mid = (start+end)/2;\\n         \\n        \\n        while(start<=end){\\n            \\n            long long current_trip = 0;\\n\\n            for(auto&x:A){\\n                current_trip +=(mid/x);\\n                \\n                //if current number of trips in time \\'mid\\' is greater\\n                //than equal to required total_trip we go out of loop as we have achieved total trip\\n                if(current_trip >= tot_trip){\\n                    break;\\n                }\\n            }\\n            if(current_trip >= tot_trip){\\n                end = mid-1;\\n                ans = min(ans,mid);\\n                mid = (start+end)/2;\\n            }\\n            else{\\n                start = mid+1;\\n                mid = (start+end)/2;\\n            }\\n        }\\n        return ans;\\n    }\\n} ;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267770,
                "title": "c-simplest-solution-binary-search-beats-90",
                "content": "# Intuition\\n**Binary Search from min value of time to min value of time * totalTrips**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Binary Search**\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, long long totalTrips) {\\n        long long low = *min_element(begin(time), end(time));\\n        long long high = low * totalTrips;\\n        long long mid, currTrips;\\n        while (low <= high) {\\n            mid = (low + high) >> 1;\\n            currTrips = 0;\\n            for (auto &it: time) currTrips += (mid / it);\\n            if (currTrips == totalTrips) high = mid-1;\\n\\n            if (currTrips > totalTrips) high = mid - 1;\\n\\n            if (currTrips < totalTrips) low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, long long totalTrips) {\\n        long long low = *min_element(begin(time), end(time));\\n        long long high = low * totalTrips;\\n        long long mid, currTrips;\\n        while (low <= high) {\\n            mid = (low + high) >> 1;\\n            currTrips = 0;\\n            for (auto &it: time) currTrips += (mid / it);\\n            if (currTrips == totalTrips) high = mid-1;\\n\\n            if (currTrips > totalTrips) high = mid - 1;\\n\\n            if (currTrips < totalTrips) low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267703,
                "title": "binary-search-c-easy",
                "content": "```\\nclass Solution {\\n    bool canComplete(vector<int>& time, int totalTrips, long long days) {\\n        long long n = size(time), trips = 0;\\n        for(int i = 0; i < n; i++) {\\n            \\n            trips += days/(time[i]*1LL);\\n        }\\n        \\n        return trips >= totalTrips;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long low = 1, high = 1LL * (*min_element(begin(time), end(time))) *  totalTrips, mid;\\n        \\n        while(low < high) {\\n            mid = low + (high - low) / 2LL;\\n            \\n            if(canComplete(time,totalTrips,mid))high = mid;\\n            else low = mid+1;\\n        }\\n        \\n        return low;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool canComplete(vector<int>& time, int totalTrips, long long days) {\\n        long long n = size(time), trips = 0;\\n        for(int i = 0; i < n; i++) {\\n            \\n            trips += days/(time[i]*1LL);\\n        }\\n        \\n        return trips >= totalTrips;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long low = 1, high = 1LL * (*min_element(begin(time), end(time))) *  totalTrips, mid;\\n        \\n        while(low < high) {\\n            mid = low + (high - low) / 2LL;\\n            \\n            if(canComplete(time,totalTrips,mid))high = mid;\\n            else low = mid+1;\\n        }\\n        \\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267685,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left = 1\\n        right = max(time) * totalTrips\\n\\n        while right > left:\\n            mid = (left + right)//2\\n            sums = sum([mid//t for t in time])\\n            if sums >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left = 1\\n        right = max(time) * totalTrips\\n\\n        while right > left:\\n            mid = (left + right)//2\\n            sums = sum([mid//t for t in time])\\n            if sums >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267572,
                "title": "binary-search-small-and-clear-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search on answer (time).bin\\n\\n# Complexity\\n- Time complexity: O(N log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&time, int trips, long long timeAvl){\\n        unsigned long long count=0;\\n        for(int i=0;i<time.size();i++){\\n            count+= (timeAvl/time[i]);\\n        }\\n        if(count>=trips) return true;\\n        else return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low=1;\\n        long long high=*max_element(time.begin(),time.end())*1LL*totalTrips;\\n\\n        while(low<=high){\\n            long long mid= low+(high-low)/2;\\n            if(check(time,totalTrips,mid)) high=mid-1;\\n            else low=mid+1;\\n        }\\n        return low;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&time, int trips, long long timeAvl){\\n        unsigned long long count=0;\\n        for(int i=0;i<time.size();i++){\\n            count+= (timeAvl/time[i]);\\n        }\\n        if(count>=trips) return true;\\n        else return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low=1;\\n        long long high=*max_element(time.begin(),time.end())*1LL*totalTrips;\\n\\n        while(low<=high){\\n            long long mid= low+(high-low)/2;\\n            if(check(time,totalTrips,mid)) high=mid-1;\\n            else low=mid+1;\\n        }\\n        return low;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267496,
                "title": "simple-python-solution-47-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        if totalTrips <= 0:\\n            return 0\\n        left, right = min(time), max(time) * totalTrips\\n        ans = right\\n        while left < right:\\n            mid = (left + right) //2\\n            trips = 0\\n            for t in time:\\n                trips += mid // t\\n            if trips >= totalTrips:\\n                ans = min(ans, mid)\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left                  \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        if totalTrips <= 0:\\n            return 0\\n        left, right = min(time), max(time) * totalTrips\\n        ans = right\\n        while left < right:\\n            mid = (left + right) //2\\n            trips = 0\\n            for t in time:\\n                trips += mid // t\\n            if trips >= totalTrips:\\n                ans = min(ans, mid)\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left                  \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267486,
                "title": "kotlin-binary-search",
                "content": "#### Join me on telergam\\nhttps://t.me/leetcode_daily_unstoppable/140\\n#### Intuition\\nNaive approach is just to simulate the `time` running, but given the problem range it is not possible.\\nHowever, observing the `time` simulation results, we can notice, that by each `given time` there is a certain `number of trips`. And `number of trips` growths continuously with the growth of the `time`. This is a perfect condition to do a binary search in a space of the `given time`. \\nWith `given time` we can calculate number of trips in a $$O(n)$$ complexity.\\n\\n#### Approach\\nDo a binary search. For the `hi` value, we can peak a $$10^7$$ or just compute all the time it takes for every bus to trip.\\nFor a more robust binary search:\\n* use inclusive `lo` and `hi`\\n* use inclusive check for the last case `lo == hi`\\n* compute the result on every step instead of computing it after the search\\n* always move the borders `mid + 1`, `mid - 1`\\n\\n#### Complexity\\n- Time complexity:\\n$$O(nlog_2(m))$$, $$m$$ - is a time range\\n- Space complexity:\\n$$O(1)$$\\n#### Code\\n```\\n    fun minimumTime(time: IntArray, totalTrips: Int): Long {\\n        fun tripCount(timeGiven: Long): Long {\\n            var count = 0L\\n            for (t in time) count += timeGiven / t.toLong()\\n            return count\\n        }\\n        var lo = 0L\\n        var hi = time.asSequence().map { it.toLong() * totalTrips }.max()!!\\n        var minTime = hi\\n        while (lo <= hi) {\\n            val timeGiven = lo + (hi - lo) / 2\\n            val trips = tripCount(timeGiven)\\n            if (trips >= totalTrips) {\\n                minTime = minOf(minTime, timeGiven)\\n                hi = timeGiven - 1\\n            } else {\\n                lo = timeGiven + 1\\n            }\\n        }\\n        return minTime\\n    }\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\n    fun minimumTime(time: IntArray, totalTrips: Int): Long {\\n        fun tripCount(timeGiven: Long): Long {\\n            var count = 0L\\n            for (t in time) count += timeGiven / t.toLong()\\n            return count\\n        }\\n        var lo = 0L\\n        var hi = time.asSequence().map { it.toLong() * totalTrips }.max()!!\\n        var minTime = hi\\n        while (lo <= hi) {\\n            val timeGiven = lo + (hi - lo) / 2\\n            val trips = tripCount(timeGiven)\\n            if (trips >= totalTrips) {\\n                minTime = minOf(minTime, timeGiven)\\n                hi = timeGiven - 1\\n            } else {\\n                lo = timeGiven + 1\\n            }\\n        }\\n        return minTime\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267361,
                "title": "simple-and-optimised-javascript-solution-beats-100",
                "content": "# Approach\\nTo solve this problem, we use binary search on the minimum time needed to complete all trips. We start by calculating a minimum value of 1 and a maximum value of 1e18, then loop until the minimum time is less than or equal to the maximum time. At each iteration, we calculate the mid-point of the search range and check how many trips can be completed by all buses in that time. If the number of completed trips is greater than or equal to the total number of trips, we search left; otherwise, we search right. We continue this process until both numbers are equal. The time complexity is O(n log t), where n is the number of buses and t is their maximum times; and space complexity is O(1).\\n\\n# Code\\n```\\nfunction minimumTime(time, totalTrips) {\\n  let left = 1; // minimum time needed to complete all trips\\n  let right = 1e18; // maximum time (for practical purposes)\\n  while (left < right) {\\n    const mid = Math.floor((left + right) / 2); // mid-point of the search range\\n    let tripsCompleted = 0;\\n    for (let i = 0; i < time.length && tripsCompleted < totalTrips; i++) {\\n      tripsCompleted += Math.floor(mid / time[i]); // number of trips completed by this bus in mid time\\n    }\\n    if (tripsCompleted >= totalTrips) {\\n      right = mid; // search the left half of the range\\n    } else {\\n      left = mid + 1; // search the right half of the range\\n    }\\n  }\\n  return left;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nfunction minimumTime(time, totalTrips) {\\n  let left = 1; // minimum time needed to complete all trips\\n  let right = 1e18; // maximum time (for practical purposes)\\n  while (left < right) {\\n    const mid = Math.floor((left + right) / 2); // mid-point of the search range\\n    let tripsCompleted = 0;\\n    for (let i = 0; i < time.length && tripsCompleted < totalTrips; i++) {\\n      tripsCompleted += Math.floor(mid / time[i]); // number of trips completed by this bus in mid time\\n    }\\n    if (tripsCompleted >= totalTrips) {\\n      right = mid; // search the left half of the range\\n    } else {\\n      left = mid + 1; // search the right half of the range\\n    }\\n  }\\n  return left;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267325,
                "title": "c-solution-commented-fully-binary-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long h=INT_MAX, l=0; // h = end(high) time limit and l= start(low) time limit\\n        for(int i=0;i<time.size();i++)\\n        {\\n            if(time[i]<h){\\n                h=time[i];  // give the time of the fastest bus or the min. time\\n            }\\n        }\\n        h=totalTrips*h; // time taken by the fastest bus to complete all the trips individually\\n        while(l<=h){\\n            // cout<<l<<\" \"<<h<<endl;\\n            long long midTime=l+(h-l)/2;  //min time that may be possbile\\n            long long curTrips=0;  // no. of total trips that could be done by all the buses cumulative within the midTime \\n            for(int j=0;j<time.size();j++)\\n            {\\n                curTrips+=(midTime/time[j]);  \\n            }\\n            if(curTrips>=totalTrips){  // if total trip within midTime > totaltrips => midTime is more than the actual time so decreasing the end-time limit\\n                h=midTime-1;\\n            }else {\\n                l=midTime+1; //else increasing the start-time limit\\n            }\\n        }\\n        return l;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long h=INT_MAX, l=0; // h = end(high) time limit and l= start(low) time limit\\n        for(int i=0;i<time.size();i++)\\n        {\\n            if(time[i]<h){\\n                h=time[i];  // give the time of the fastest bus or the min. time\\n            }\\n        }\\n        h=totalTrips*h; // time taken by the fastest bus to complete all the trips individually\\n        while(l<=h){\\n            // cout<<l<<\" \"<<h<<endl;\\n            long long midTime=l+(h-l)/2;  //min time that may be possbile\\n            long long curTrips=0;  // no. of total trips that could be done by all the buses cumulative within the midTime \\n            for(int j=0;j<time.size();j++)\\n            {\\n                curTrips+=(midTime/time[j]);  \\n            }\\n            if(curTrips>=totalTrips){  // if total trip within midTime > totaltrips => midTime is more than the actual time so decreasing the end-time limit\\n                h=midTime-1;\\n            }else {\\n                l=midTime+1; //else increasing the start-time limit\\n            }\\n        }\\n        return l;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3267274,
                "title": "simple-binary-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n         long ans=-1;\\n          long left=1, right= 1+1e14;          \\n\\t\\t\\n        while(left<=right){\\n             long mid= left+ (right-left)/2;  \\n            long long trips=0;\\n            for(int i=0;i<time.size();i++){\\n                trips+= mid/time[i];\\n            }\\n            \\n            if(trips>=totalTrips){ \\n                ans=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n         long ans=-1;\\n          long left=1, right= 1+1e14;          \\n\\t\\t\\n        while(left<=right){\\n             long mid= left+ (right-left)/2;  \\n            long long trips=0;\\n            for(int i=0;i<time.size();i++){\\n                trips+= mid/time[i];\\n            }\\n            \\n            if(trips>=totalTrips){ \\n                ans=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267245,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lo = 0, hi = 100_000_000_000_000L;\\n        while (lo < hi) {\\n            long need = lo + (hi - lo) / 2;\\n            long trips = 0;\\n            for (int t : time) {\\n                trips += need / t;\\n            }\\n            if (trips < totalTrips) {\\n                lo = need + 1;\\n            }else {\\n                hi = need;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lo = 0, hi = 100_000_000_000_000L;\\n        while (lo < hi) {\\n            long need = lo + (hi - lo) / 2;\\n            long trips = 0;\\n            for (int t : time) {\\n                trips += need / t;\\n            }\\n            if (trips < totalTrips) {\\n                lo = need + 1;\\n            }else {\\n                hi = need;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267243,
                "title": "python3-binary-search-o-nlogn-time-complexity",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        low = 1\\n        high = min(time) * totalTrips\\n        def helper(curr):\\n            trips = 0 \\n            for t in time:\\n                trips += (curr // t)\\n                if trips >= totalTrips:\\n                    return True\\n            return False\\n        \\n        ans = high\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if helper(mid):\\n                ans = mid \\n                high = mid - 1 \\n            else:\\n                low = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        low = 1\\n        high = min(time) * totalTrips\\n        def helper(curr):\\n            trips = 0 \\n            for t in time:\\n                trips += (curr // t)\\n                if trips >= totalTrips:\\n                    return True\\n            return False\\n        \\n        ans = high\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if helper(mid):\\n                ans = mid \\n                high = mid - 1 \\n            else:\\n                low = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267027,
                "title": "typescript-binary-search",
                "content": "```\\nfunction minimumTime(time: number[], totalTrips: number): number {\\n  // t is in [1, 10 ** 14]\\n  let left = 1;\\n  let right = 10 ** 14;\\n\\n  while (left <= right) {\\n    // using binary search to guess a t\\n    let mid = left + Math.floor((right - left) / 2);\\n    // how many trips we could finish\\n    let total = 0;\\n    for (var t of time) {\\n      total += Math.floor(mid / t);\\n    }\\n    // not enough, guess a larger t in next round\\n    if (total < totalTrips) {\\n      left = mid + 1;\\n    } else {\\n      // to find the smallest t\\n      right = mid -1;\\n    }\\n  }\\n\\n  return left;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumTime(time: number[], totalTrips: number): number {\\n  // t is in [1, 10 ** 14]\\n  let left = 1;\\n  let right = 10 ** 14;\\n\\n  while (left <= right) {\\n    // using binary search to guess a t\\n    let mid = left + Math.floor((right - left) / 2);\\n    // how many trips we could finish\\n    let total = 0;\\n    for (var t of time) {\\n      total += Math.floor(mid / t);\\n    }\\n    // not enough, guess a larger t in next round\\n    if (total < totalTrips) {\\n      left = mid + 1;\\n    } else {\\n      // to find the smallest t\\n      right = mid -1;\\n    }\\n  }\\n\\n  return left;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267005,
                "title": "c-binary-search-explained-c-code-easy-to-understand",
                "content": "### I Kept code very consise and very clean with proper comment. Once read the Code You will understand the logic. \\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n=time.size();\\n        sort(time.begin(),time.end()); // Just did for my end variable \\n        long long st=1;  // start_time\\n        long long end=(long long)totalTrips*(long long)time[0];  //end_time\\n        long long mini=end;  // i will store here the minimum time\\n     \\n        //BINARY SEARCH\\n        while(st<=end){\\n             long long mid= st + (end-st)/2;\\n             long long trips_took=0;          // AT mid time, How much trips has been travelled \\n            for( long long i=0;i<n;i++){\\n                trips_took+=(mid/time[i]);\\n            }\\n            // if it is less then we should increase time so Start is shifted to mid + 1\\n            if(trips_took<totalTrips){         \\n                st=mid+1;\\n            }\\n            //ELse end is shifted to mid -1 to get minimum time\\n            else{\\n                if(mini>=mid){\\n                    mini=mid;\\n                }\\n                end=mid-1; \\n            }\\n            \\n        }\\n        return mini;\\n        return 0;\\n        \\n        \\n    }\\n};\\n\\n```\\n\\n### If it helped do upvote.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n=time.size();\\n        sort(time.begin(),time.end()); // Just did for my end variable \\n        long long st=1;  // start_time\\n        long long end=(long long)totalTrips*(long long)time[0];  //end_time\\n        long long mini=end;  // i will store here the minimum time\\n     \\n        //BINARY SEARCH\\n        while(st<=end){\\n             long long mid= st + (end-st)/2;\\n             long long trips_took=0;          // AT mid time, How much trips has been travelled \\n            for( long long i=0;i<n;i++){\\n                trips_took+=(mid/time[i]);\\n            }\\n            // if it is less then we should increase time so Start is shifted to mid + 1\\n            if(trips_took<totalTrips){         \\n                st=mid+1;\\n            }\\n            //ELse end is shifted to mid -1 to get minimum time\\n            else{\\n                if(mini>=mid){\\n                    mini=mid;\\n                }\\n                end=mid-1; \\n            }\\n            \\n        }\\n        return mini;\\n        return 0;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267004,
                "title": "ruby-binary-search-solution",
                "content": "```\\ndef minimum_time(time, total_trips)\\n  left, right = 0, total_trips*time[0]\\n  while left < right\\n    mid = (left + right) / 2\\n    trips = time.sum{|t| mid/t}\\n    if trips >= total_trips\\n      right = mid\\n    else\\n      left = mid + 1\\n    end\\n  end\\n  left\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_time(time, total_trips)\\n  left, right = 0, total_trips*time[0]\\n  while left < right\\n    mid = (left + right) / 2\\n    trips = time.sum{|t| mid/t}\\n    if trips >= total_trips\\n      right = mid\\n    else\\n      left = mid + 1\\n    end\\n  end\\n  left\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3266998,
                "title": "java-simple-binary-search",
                "content": "Min Time will be 1 sec and Max will be 10^7 * totalTrips.\\nWhy 10^7? Because according to constarints max of time[] can be 10^7.\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n       int n = time.length;\\n  //     Arrays.sort(time);\\n       long low = 1,  high = (long)Math.pow(10,7)*totalTrips;\\n       System.out.println(high);\\n       long ans = 0;\\n       while(low <= high){\\n           long mid = low + (high - low)/2;\\n           if(isPossible(time, totalTrips,mid)){\\n               ans = mid;\\n               high = mid - 1;\\n           }\\n           else{\\n               low = mid+1;\\n           }\\n       }\\n       return ans;\\n    }\\n    private boolean isPossible(int[] arr, int trips, long mid){\\n        long poss = 0;\\n        for(int x : arr){\\n           poss += mid/x;\\n        }\\n        if(poss >= trips) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n       int n = time.length;\\n  //     Arrays.sort(time);\\n       long low = 1,  high = (long)Math.pow(10,7)*totalTrips;\\n       System.out.println(high);\\n       long ans = 0;\\n       while(low <= high){\\n           long mid = low + (high - low)/2;\\n           if(isPossible(time, totalTrips,mid)){\\n               ans = mid;\\n               high = mid - 1;\\n           }\\n           else{\\n               low = mid+1;\\n           }\\n       }\\n       return ans;\\n    }\\n    private boolean isPossible(int[] arr, int trips, long mid){\\n        long poss = 0;\\n        for(int x : arr){\\n           poss += mid/x;\\n        }\\n        if(poss >= trips) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266978,
                "title": "python-short-and-clean-binary-search",
                "content": "# Approach\\nNotice that the time needed can never be greater than `min(time) * total_trips`.\\nLeveraging this, binary search for `min_time` in the range `[0, min(time) * total_trips]`\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n * k))$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere,\\n`n is length of time`,\\n`k is total_trips`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minimumTime(self, time: list[int], total_trips: int) -> int:\\n        l, r = 0, min(time) * total_trips\\n        while l <= r:\\n            m = (l + r) // 2\\n            trips = sum(m // t for t in time)\\n            l, r = (l, m - 1) if trips >= total_trips else (m + 1, r)\\n        return l\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumTime(self, time: list[int], total_trips: int) -> int:\\n        l, r = 0, min(time) * total_trips\\n        while l <= r:\\n            m = (l + r) // 2\\n            trips = sum(m // t for t in time)\\n            l, r = (l, m - 1) if trips >= total_trips else (m + 1, r)\\n        return l\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266945,
                "title": "java-with-beginner-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        //range based binary search\\n        //the start we will make the minimum value possible\\n        long s = 1;\\n        //end we will make the max time possible \\n        //which will be the time required by minimum speed bus to complete n no. of trips   \\n        long min = time[0];\\n        for(int i = 0;i < time.length;i++){\\n            min = Math.min(min, time[i]);\\n        }\\n        long e = min * totalTrips;\\n        //so we know that our answer will lye btw the start s and end e\\n        while(s < e){\\n            long m = s + (e - s) / 2;\\n            //now check how many trips can be completed in this m amount of time\\n            long trips = 0;\\n            for(int i = 0;i < time.length;i++){\\n                trips += m / time[i];\\n            }\\n            if(trips < totalTrips){\\n                //we have to move the start pointer\\n                //since our trips is not enough\\n                s = m + 1;\\n            }else{\\n                //we have to move our end point\\n                e = m;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        //range based binary search\\n        //the start we will make the minimum value possible\\n        long s = 1;\\n        //end we will make the max time possible \\n        //which will be the time required by minimum speed bus to complete n no. of trips   \\n        long min = time[0];\\n        for(int i = 0;i < time.length;i++){\\n            min = Math.min(min, time[i]);\\n        }\\n        long e = min * totalTrips;\\n        //so we know that our answer will lye btw the start s and end e\\n        while(s < e){\\n            long m = s + (e - s) / 2;\\n            //now check how many trips can be completed in this m amount of time\\n            long trips = 0;\\n            for(int i = 0;i < time.length;i++){\\n                trips += m / time[i];\\n            }\\n            if(trips < totalTrips){\\n                //we have to move the start pointer\\n                //since our trips is not enough\\n                s = m + 1;\\n            }else{\\n                //we have to move our end point\\n                e = m;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266870,
                "title": "java-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n      long lo = 0, hi = 100000000000000L;\\n      while(lo<hi){\\n         long req=(lo+hi)/2;\\n         long trips = 0;\\n         for (int t : time) {\\n            trips += req / t;\\n            }\\n          if (trips < totalTrips) {\\n                lo = req + 1;\\n            }else {\\n                hi = req;\\n            }\\n        }\\n        return lo;\\n      }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n      long lo = 0, hi = 100000000000000L;\\n      while(lo<hi){\\n         long req=(lo+hi)/2;\\n         long trips = 0;\\n         for (int t : time) {\\n            trips += req / t;\\n            }\\n          if (trips < totalTrips) {\\n                lo = req + 1;\\n            }else {\\n                hi = req;\\n            }\\n        }\\n        return lo;\\n      }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266858,
                "title": "straight-forward-binary-search-solution-in-c-predicate-function-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to minimize the time to complete totalTrips, this gives an intutition that binary search can be applied. The problem will be having a predicate function with respect to time taken like this\\n\\nF F F F ... F F T T T ... T T\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all find the range in which the time can vary. So, the total time required will have a minimum value equal to the minimum value in the array and we can take a safe maximum value equal to the sum of the elements of the array multiply by the totalTrips.\\n\\n# Complexity\\n- Time complexity: O(log(sum*totalTrips))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canComplete(long long t, int totalTrips, vector<int> &time){\\n\\n        long long trips = 0;\\n        for(long long i = 0;i<time.size();i++){\\n            trips += (t/time[i]);\\n            if(trips >= totalTrips){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        long long sum = 0;\\n        for(auto v : time){\\n            sum += v;\\n        }\\n\\n        long long lo =  *min_element(time.begin(), time.end());\\n        long long hi = sum * totalTrips;\\n        long long mid;\\n\\n        while(lo < hi){\\n            mid = lo + (hi-lo)/2;\\n            if(canComplete(mid,totalTrips,time)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canComplete(long long t, int totalTrips, vector<int> &time){\\n\\n        long long trips = 0;\\n        for(long long i = 0;i<time.size();i++){\\n            trips += (t/time[i]);\\n            if(trips >= totalTrips){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        long long sum = 0;\\n        for(auto v : time){\\n            sum += v;\\n        }\\n\\n        long long lo =  *min_element(time.begin(), time.end());\\n        long long hi = sum * totalTrips;\\n        long long mid;\\n\\n        while(lo < hi){\\n            mid = lo + (hi-lo)/2;\\n            if(canComplete(mid,totalTrips,time)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266846,
                "title": "c-binary-search-clean-code-easy-to-understandbi",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$ \\n<!-- Add your time complexity here, e.g. $$O(nlogn)$$ -->\\n\\n- Space complexity:$$O(1)$$ \\n<!-- Add your space complexity here, e.g. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long int mid, vector<int>&a, int k){\\n        long long int total = 0;\\n        for(int i=0;i<a.size();i++){\\n            total+=(mid/a[i]);\\n        }\\n        return total>=k;\\n    }\\n    long long minimumTime(vector<int>& time, int k) {\\n        int n = time.size();\\n        if(n==1){\\n            return (long long int)k*time[0];\\n        }\\n        long long int low = 0;\\n        long long int high = 1e12;\\n        while(low<high){\\n            long long int mid = low + (high - low)/2;\\n            if(check(mid,time,k)){\\n                high = mid;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long int mid, vector<int>&a, int k){\\n        long long int total = 0;\\n        for(int i=0;i<a.size();i++){\\n            total+=(mid/a[i]);\\n        }\\n        return total>=k;\\n    }\\n    long long minimumTime(vector<int>& time, int k) {\\n        int n = time.size();\\n        if(n==1){\\n            return (long long int)k*time[0];\\n        }\\n        long long int low = 0;\\n        long long int high = 1e12;\\n        while(low<high){\\n            long long int mid = low + (high - low)/2;\\n            if(check(mid,time,k)){\\n                high = mid;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266792,
                "title": "c-binary-search-o-n-log-n-short-code",
                "content": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 100000000000000;\\n        ll ans = r;\\n        while (l <= r) {\\n            ll m = (l+r)/2;\\n            \\n            ll trips = 0;\\n            for (int n : time)\\n                trips += m / n;\\n            if (trips >= totalTrips)\\n                ans = m, r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 100000000000000;\\n        ll ans = r;\\n        while (l <= r) {\\n            ll m = (l+r)/2;\\n            \\n            ll trips = 0;\\n            for (int n : time)\\n                trips += m / n;\\n            if (trips >= totalTrips)\\n                ans = m, r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266638,
                "title": "minimum-time-to-complete-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBeing brute force setting the time line from 1 we can go through but as we donnot know the end it does not work hence the array is sorted and check the minimum time to complete we will go for Binary Search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a classical binary search problem the lower time is 0 and the higher limit is 10**14 now we will find the mid value and check is it possible to make the trips if it is possible then we try to decrement the higher time and continue till the binary search algorithm works and note down the answer to be minimum...\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        low=0\\n        high=10**14\\n        ans=high\\n        while low<high:\\n            mid=(low+high)//2\\n            c=0\\n            #Checking how many trips are possible for this mid time,..\\n            for i in time:\\n                c+=(mid//i)\\n            if(c>=totalTrips):\\n                ans=min(ans,mid)\\n                high=mid\\n            else:\\n                low=mid+1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        low=0\\n        high=10**14\\n        ans=high\\n        while low<high:\\n            mid=(low+high)//2\\n            c=0\\n            #Checking how many trips are possible for this mid time,..\\n            for i in time:\\n                c+=(mid//i)\\n            if(c>=totalTrips):\\n                ans=min(ans,mid)\\n                high=mid\\n            else:\\n                low=mid+1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266554,
                "title": "python-brute-force-bs",
                "content": "**Brute force:**\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        for t in range(0, totalTrips * min(time) + 1):\\n            trips = sum((t // trip_time for trip_time in time))\\n            if trips == totalTrips:\\n                return t\\n ```\\n**Optimized with BS:**\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left = 0\\n        right = totalTrips * min(time)\\n        while left < right:\\n            mid = (left + right) // 2\\n            trips = sum((mid // trip_time for trip_time in time))\\n            if trips >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        for t in range(0, totalTrips * min(time) + 1):\\n            trips = sum((t // trip_time for trip_time in time))\\n            if trips == totalTrips:\\n                return t\\n ```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left = 0\\n        right = totalTrips * min(time)\\n        while left < right:\\n            mid = (left + right) // 2\\n            trips = sum((mid // trip_time for trip_time in time))\\n            if trips >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266546,
                "title": "go-binary-search",
                "content": "# Code\\n```\\nfunc minimumTime(time []int, totalTrips int) int64 {\\n\\tleft, right := 0, math.MaxInt\\n\\tfor left < right {\\n\\t\\tmid := (left + right) >> 1\\n\\t\\tif check(time, totalTrips, mid) {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn int64(left)\\n}\\n\\nfunc check(time []int, totalTrips, mid int) bool {\\n\\tcnt := 0\\n\\tfor _, t := range time {\\n\\t\\tcnt += mid / t\\n\\t\\tif cnt >= totalTrips {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc minimumTime(time []int, totalTrips int) int64 {\\n\\tleft, right := 0, math.MaxInt\\n\\tfor left < right {\\n\\t\\tmid := (left + right) >> 1\\n\\t\\tif check(time, totalTrips, mid) {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn int64(left)\\n}\\n\\nfunc check(time []int, totalTrips, mid int) bool {\\n\\tcnt := 0\\n\\tfor _, t := range time {\\n\\t\\tcnt += mid / t\\n\\t\\tif cnt >= totalTrips {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266496,
                "title": "easy-solution",
                "content": "# Approach\\nBinary search\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1;\\n        long long r = *min_element(time.begin(), time.end()) * (long long)totalTrips;\\n        while (l < r) {\\n            long long mid = (l + r) / 2;\\n            long long res = 0;\\n            for (int t : time) res += mid / t;\\n            if (res >= totalTrips) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n- Space complexity: $$O(1)$$",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1;\\n        long long r = *min_element(time.begin(), time.end()) * (long long)totalTrips;\\n        while (l < r) {\\n            long long mid = (l + r) / 2;\\n            long long res = 0;\\n            for (int t : time) res += mid / t;\\n            if (res >= totalTrips) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263349,
                "title": "java-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse binary search over the time space. left=1 , right=min(time) * totalTrips. Given a fixed time (mid), we can easily check to see how many trips the buses can make. If this is >= totalTrips, we store ans and try to minimise the time more. Otherwise we set left = mid + 1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n       // Arrays.sort(time);\\n        long min = Long.MAX_VALUE;\\n        for(int i: time){\\n            min = Math.min(i,min);\\n        }\\n        long low = 1, high = min*totalTrips; \\n        long ans=0;\\n        while(low<=high){\\n            long mid = (low+high)/2;\\n            long trips = 0;\\n            for(int i: time)\\n                trips+=(mid/i);\\n            if(trips<totalTrips)\\n                low = mid+1;\\n            else{\\n                ans = mid;\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n       // Arrays.sort(time);\\n        long min = Long.MAX_VALUE;\\n        for(int i: time){\\n            min = Math.min(i,min);\\n        }\\n        long low = 1, high = min*totalTrips; \\n        long ans=0;\\n        while(low<=high){\\n            long mid = (low+high)/2;\\n            long trips = 0;\\n            for(int i: time)\\n                trips+=(mid/i);\\n            if(trips<totalTrips)\\n                low = mid+1;\\n            else{\\n                ans = mid;\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1824736,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824593,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1631784,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824678,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824577,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824927,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824770,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1688252,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824656,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1570806,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824736,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824593,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1631784,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824678,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824577,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824927,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824770,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1688252,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824656,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1570806,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1825380,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824842,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824609,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824620,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1825108,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824889,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824790,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1576470,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1825456,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1825196,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1825088,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1825085,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1815796,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1825022,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 2044683,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 2010065,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1987685,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1973176,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1965239,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1887372,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1884010,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1833815,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1827293,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1826064,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825625,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825595,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825558,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825553,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825460,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825458,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825452,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825382,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825374,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825372,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825304,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825293,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825275,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825274,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825253,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825195,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825102,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1825091,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1825048,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824989,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824987,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824866,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824861,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824799,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824776,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824767,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Time to Finish the Race",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code>tires</code> where <code>tires[i] = [f<sub>i</sub>, r<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> tire can finish its <code>x<sup>th</sup></code> successive lap in <code>f<sub>i</sub> * r<sub>i</sub><sup>(x-1)</sup></code> seconds.</p>\n\n<ul>\n\t<li>For example, if <code>f<sub>i</sub> = 3</code> and <code>r<sub>i</sub> = 2</code>, then the tire would finish its <code>1<sup>st</sup></code> lap in <code>3</code> seconds, its <code>2<sup>nd</sup></code> lap in <code>3 * 2 = 6</code> seconds, its <code>3<sup>rd</sup></code> lap in <code>3 * 2<sup>2</sup> = 12</code> seconds, etc.</li>\n</ul>\n\n<p>You are also given an integer <code>changeTime</code> and an integer <code>numLaps</code>.</p>\n\n<p>The race consists of <code>numLaps</code> laps and you may start the race with <strong>any</strong> tire. You have an <strong>unlimited</strong> supply of each tire and after every lap, you may <strong>change</strong> to any given tire (including the current tire type) if you wait <code>changeTime</code> seconds.</p>\n\n<p>Return<em> the <strong>minimum</strong> time to finish the race.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4\n<strong>Output:</strong> 21\n<strong>Explanation:</strong> \nLap 1: Start with tire 0 and finish the lap in 2 seconds.\nLap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.\nLap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.\nTotal time = 2 + 6 + 5 + 2 + 6 = 21 seconds.\nThe minimum time to complete the race is 21 seconds.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5\n<strong>Output:</strong> 25\n<strong>Explanation:</strong> \nLap 1: Start with tire 1 and finish the lap in 2 seconds.\nLap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\nLap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\nLap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second.\nTotal time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds.\nThe minimum time to complete the race is 25 seconds. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tires.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>tires[i].length == 2</code></li>\n\t<li><code>1 &lt;= f<sub>i</sub>, changeTime &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= numLaps &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1802444,
                "title": "c-linear-time-dp-with-explanation",
                "content": "This problem seems very hard at first glance, but would be way easier with just one observation.\\n\\n# Observation\\n- Given `changeTime <= 10^5`, it won\\'t be optimal if we use any tire consecutively without change for larger than `18` laps.\\n- Let\\'s consider the extreme case, when `f_i == 1` and `r_i == 2`\\n\\n| consecutive laps  | 1  | 2  |  3 | 4  | 5  | 6  |  7 | 8  | 9  | 10\\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\\n|  time on the last lap |  1 | 2  | 4  | 8  | 16| 32| 64|128|256| 512\\n\\n| consecutive laps  | 11 | 12  | 13|14|15|16|17|18|\\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\\n|  time on the last lap |1024|2048|4096|8192|16384|32768|65536|**131072**|\\n\\n- it is obvious that at the `18-th` consecutive lap, it is alway better to change a tire (even when `f_i` and `r_i` are given their smallest possible values).\\n- this observation leads to two lemmas\\n##### Lemma 1.\\n- If `numLaps >= 18`, we must change tire in some point of time in any optimal way.\\n##### Lemma 2.\\n- After changing a tire, an optimal way won\\'t have the tire running for more than `18` consecutive laps.\\n\\n### Algorithm\\n- from the above discussion, we can form a dp like:\\n\\t- `dp[x] :=` the minimum time to finish `x` laps\\n\\t- base case: `dp[1]` = `min(f_i)` among all tires\\n\\t- transition: `dp[x] = min(dp[j] + changeTime + dp[x-j])` among all *possible `j`s*\\n\\t\\t- meaning: the minimum time to finish `x` laps is the minimum time to finish `j` laps first **and change a tire at the end of `j`-th lap**, plus the minimum time to finish the last `x-j` laps.\\n\\t\\t- which `j`s are *possible* ?\\n\\t\\t\\t- from **Lemma 2.** we know `j >= x-18` must hold.\\n\\t\\t\\t- It leads to a constant time transition.\\n\\t- note that if `x < 18`, it\\'s possible that an optimal solution never changes a tire.\\n- code\\n```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        int n = tires.size();\\n        // to handle the cases where numLaps is small\\n\\t\\t// without_change[i][j]: the total time to run j laps consecutively with tire i\\n        vector<vector<int>> without_change(n, vector<int>(20, 2e9));\\n        for (int i = 0; i < n; i++) {\\n            without_change[i][1] = tires[i][0];\\n            for (int j = 2; j < 20; j++) {\\n                if ((long long)without_change[i][j-1] * tires[i][1] >= 2e9)\\n                    break;\\n                without_change[i][j] = without_change[i][j-1] * tires[i][1];\\n            }\\n            // since we define it as the total time, rather than just the time for the j-th lap\\n\\t\\t\\t// we have to make it prefix sum\\n            for (int j = 2; j < 20; j++) {\\n                if ((long long)without_change[i][j-1] + without_change[i][j] >= 2e9)\\n                    break;\\n                without_change[i][j] += without_change[i][j-1];\\n            }\\n        }\\n        \\n\\t\\t// dp[x]: the minimum time to finish x laps\\n        vector<int> dp(numLaps+1, 2e9);\\n        for (int i = 0; i < n; i++) {\\n            dp[1] = min(dp[1], tires[i][0]);\\n        }\\n        for (int x = 1; x <= numLaps; x++) {\\n            if (x < 20) {\\n\\t\\t\\t\\t// x is small enough, so an optimal solution might never changes tires!\\n                for (int i = 0; i < n; i++) {\\n                    dp[x] = min(dp[x], without_change[i][x]);\\n                }\\n            }\\n            for (int j = x-1; j > 0 && j >= x-18; j--) {\\n                dp[x] = min(dp[x], dp[j] + changeTime + dp[x-j]);\\n            }\\n        }\\n        \\n        return dp[numLaps];\\n    }\\n};\\n```\\n- Time Complexity: (let `n := tires.size()`)\\n\\t- preprocess `without_change`: **O(n)**\\n\\t- `dp`: **O(18 * numLaps + 20 * n)** -> **O(numLaps + n)**\\n- Space Complexity:\\n\\t- `without_change`: **O(n)**\\n\\t- `dp`: **O(numLaps)**\\n\\n### Another Observation\\n- if `f_i <= f_j` and `r_i <= r_j`, it is always \"not worse\" to pick tire `i` over tire `j`. So we can do some preprocess to remove all such tires.\\n- won\\'t be better in time complexity (since we now have to sort `tires`), but might improve the runtime (and space allocated)\\n- code\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> preprocess(vector<vector<int>>& tires) {\\n        sort(tires.begin(), tires.end());\\n        vector<vector<int>> new_tires;\\n        for (auto& t : tires) {\\n            if (new_tires.empty() || new_tires.back()[1] > t[1]) {\\n                new_tires.push_back(t);\\n            }\\n        }\\n        return new_tires;\\n    }\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        // remove those will never be used\\n        tires = preprocess(tires);\\n        int n = tires.size();\\n\\t\\t\\n\\t\\t// ... (rest are the same)\\n\\t\\t\\n\\t\\treturn dp[numLaps];\\n\\t}\\n}\\n```\\n# Similar Problems\\n- it reminds me of the following problems\\n\\t- [LC 1105 - Filling Bookcase Shelves](https://leetcode.com/problems/filling-bookcase-shelves/) (challenge: solve this in **O(n lg n)** time.)\\n\\t- [LC 1687 - Delivering Boxes from Storage to Ports](https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        int n = tires.size();\\n        // to handle the cases where numLaps is small\\n\\t\\t// without_change[i][j]: the total time to run j laps consecutively with tire i\\n        vector<vector<int>> without_change(n, vector<int>(20, 2e9));\\n        for (int i = 0; i < n; i++) {\\n            without_change[i][1] = tires[i][0];\\n            for (int j = 2; j < 20; j++) {\\n                if ((long long)without_change[i][j-1] * tires[i][1] >= 2e9)\\n                    break;\\n                without_change[i][j] = without_change[i][j-1] * tires[i][1];\\n            }\\n            // since we define it as the total time, rather than just the time for the j-th lap\\n\\t\\t\\t// we have to make it prefix sum\\n            for (int j = 2; j < 20; j++) {\\n                if ((long long)without_change[i][j-1] + without_change[i][j] >= 2e9)\\n                    break;\\n                without_change[i][j] += without_change[i][j-1];\\n            }\\n        }\\n        \\n\\t\\t// dp[x]: the minimum time to finish x laps\\n        vector<int> dp(numLaps+1, 2e9);\\n        for (int i = 0; i < n; i++) {\\n            dp[1] = min(dp[1], tires[i][0]);\\n        }\\n        for (int x = 1; x <= numLaps; x++) {\\n            if (x < 20) {\\n\\t\\t\\t\\t// x is small enough, so an optimal solution might never changes tires!\\n                for (int i = 0; i < n; i++) {\\n                    dp[x] = min(dp[x], without_change[i][x]);\\n                }\\n            }\\n            for (int j = x-1; j > 0 && j >= x-18; j--) {\\n                dp[x] = min(dp[x], dp[j] + changeTime + dp[x-j]);\\n            }\\n        }\\n        \\n        return dp[numLaps];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> preprocess(vector<vector<int>>& tires) {\\n        sort(tires.begin(), tires.end());\\n        vector<vector<int>> new_tires;\\n        for (auto& t : tires) {\\n            if (new_tires.empty() || new_tires.back()[1] > t[1]) {\\n                new_tires.push_back(t);\\n            }\\n        }\\n        return new_tires;\\n    }\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        // remove those will never be used\\n        tires = preprocess(tires);\\n        int n = tires.size();\\n\\t\\t\\n\\t\\t// ... (rest are the same)\\n\\t\\t\\n\\t\\treturn dp[numLaps];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802498,
                "title": "pretreatment-dp",
                "content": "**Intuition:** We have a lot of tires, but the number of laps is limited to 1,000.\\n    \\nWe first compute how long it takes to finish `n` laps with each tire without changing it.\\n \\n> Optimization: it only makes sense to use a tire while the lap time is less than `fi + changeTime`.\\n \\nWe track the best time to complete `i` laps, across all tires, in the `best` array.\\n \\nAfter that, we run DFS, memoising it by the number of laps to race (`dp`): \\n- For remaining `laps`, we find the best time by trying to race `i` laps, change a tire, and recurse on `laps - i` remaining laps.\\n- For `i` laps, we pick the `best` time to finish those laps. \\n\\n#### Approach 1: Top-Down DP\\n**C++**\\n```cpp\\nint dp[1001] = {}, best[1001] = {}, max_laps = 0;\\nint dfs(int laps, int changeTime) {\\n    if (laps == 0)\\n        return -changeTime;\\n    if (!dp[laps]) {\\n        dp[laps] = INT_MAX;\\n        for (int i = 1; i <= min(laps, max_laps); ++i)\\n            dp[laps] = min(dp[laps], best[i] + changeTime + dfs(laps - i, changeTime));\\n    }\\n    return dp[laps];\\n}\\nint minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n    for (auto &t : tires) {\\n        long long lap_time = t[0], time = t[0];\\n        for (int lap = 1; lap <= numLaps && lap_time < t[0] + changeTime; ++lap) {\\n            max_laps = max(max_laps, lap);\\n            if (best[lap] == 0 || best[lap] > time)\\n                best[lap] = time;\\n            lap_time *= t[1];\\n            time += lap_time;\\n        }\\n    }\\n    return dfs(numLaps, changeTime);\\n}\\n```\\n#### Approach 2: Bottom-Up DP\\nIf we notice that `ri >= 2`, we can realize that we cannot use a tire for more than 18 laps. Otherwise, the lap time will exceed the change time (100000).\\n\\nThis fact allows us to save on memory for both storing the `best` lap times, and for the tabulation (as we only need to go up to 19 steps back).\\n\\n**C++**\\nA bit compressed - just for fun.\\n```cpp\\nint minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n    int constexpr sz = 19;\\n    long long best[sz] = {[0 ... sz - 1] = INT_MAX}, dp[sz] = {};\\n    for (auto &t : tires)\\n        for (long long i = 1, lap = t[0], tot = 0; lap < t[0] + changeTime; ++i) {\\n            tot += lap;\\n            best[i] = min(best[i], tot);\\n            lap *= t[1];\\n        }\\n    for (int i = 1; i <= numLaps; ++i) {\\n        dp[i % sz] = INT_MAX;\\n        for (int j = 1; j <= min(i, sz - 1); ++j)\\n            dp[i % sz] = min(dp[i % sz], best[j] + dp[(i - j) % sz] + changeTime);\\n    }\\n    return dp[numLaps % sz] - changeTime;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[1001] = {}, best[1001] = {}, max_laps = 0;\\nint dfs(int laps, int changeTime) {\\n    if (laps == 0)\\n        return -changeTime;\\n    if (!dp[laps]) {\\n        dp[laps] = INT_MAX;\\n        for (int i = 1; i <= min(laps, max_laps); ++i)\\n            dp[laps] = min(dp[laps], best[i] + changeTime + dfs(laps - i, changeTime));\\n    }\\n    return dp[laps];\\n}\\nint minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n    for (auto &t : tires) {\\n        long long lap_time = t[0], time = t[0];\\n        for (int lap = 1; lap <= numLaps && lap_time < t[0] + changeTime; ++lap) {\\n            max_laps = max(max_laps, lap);\\n            if (best[lap] == 0 || best[lap] > time)\\n                best[lap] = time;\\n            lap_time *= t[1];\\n            time += lap_time;\\n        }\\n    }\\n    return dfs(numLaps, changeTime);\\n}\\n```\n```cpp\\nint minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n    int constexpr sz = 19;\\n    long long best[sz] = {[0 ... sz - 1] = INT_MAX}, dp[sz] = {};\\n    for (auto &t : tires)\\n        for (long long i = 1, lap = t[0], tot = 0; lap < t[0] + changeTime; ++i) {\\n            tot += lap;\\n            best[i] = min(best[i], tot);\\n            lap *= t[1];\\n        }\\n    for (int i = 1; i <= numLaps; ++i) {\\n        dp[i % sz] = INT_MAX;\\n        for (int j = 1; j <= min(i, sz - 1); ++j)\\n            dp[i % sz] = min(dp[i % sz], best[j] + dp[(i - j) % sz] + changeTime);\\n    }\\n    return dp[numLaps % sz] - changeTime;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1804216,
                "title": "easy-to-understand-clean-c-code-dp-greedy",
                "content": "## When we will change tyre?\\n\\nWe will change tyre when current Time for a Lap is >= f + change time.\\n\\nBecause by changing tyre we are using the same or less time than the time required for a consecutive lap without change, and also it will benefit the future laps too.\\n\\nEx: f = 2, r = 3, changeTime = 10\\nLap1 : Cost = 2, Total = 2\\nLap2 : Cost = Cost of Last Lap * r = 6, Total = 8\\nLap3 : Cost 6*3 = 18 , Now 18>change TIme+f\\nHence we will change tyre\\n\\n## Approach:\\n\\ndp[i] denotes the min time to travel i laps.\\n\\nWe first fill the dp without changing tyres and then modify and fill the remaining states of dp by recurrence relation:\\n\\n<b>dp[i] = min(dp[i] ,changeTime + dp[j] + dp[i-j])\\n\\nBasically we are breaking i laps into parts j and (i-j) laps (i>=j).\\nAnd we have already calculated dp[j] and dp[i-j].\\n\\n## Code:\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n\\n    void fillDPWithoutChange(vector<ll>& dp, int changeTime, vector<vector<int>>& tires)\\n    {\\n        for (vector<int>& currTyre : tires)\\n        {\\n            ll f = currTyre[0];\\n            ll r = currTyre[1];\\n            dp[1] = min(dp[1], f);\\n            ll lastLapTime = f;\\n            ll totalTime = f;\\n            ll lapCount = 2;\\n            while (lastLapTime * r < f + changeTime && lapCount < dp.size())\\n\\t\\t\\t//we can prove that this loop will not run many times because we are\\n\\t\\t\\t//moving in powers of r and even a small r like 2 will terminate this\\n\\t\\t\\t//loop under 20 iterations.\\n            {\\n                ll currLapTime = lastLapTime * r;\\n                totalTime += currLapTime;\\n                dp[lapCount] = min(dp[lapCount], totalTime);\\n                lastLapTime = currLapTime;\\n                lapCount++;\\n            }\\n        }\\n    }\\n\\n    void modifyDPforChange(vector<ll>& dp, int changeTime, vector<vector<int>>& tires)\\n    {\\n        for (ll i = 1; i < dp.size(); ++i)\\n        {\\n            for (ll j = 1; j <= i; ++j)\\n            {\\n                dp[i] = min(dp[i], changeTime + dp[j] + dp[i - j]);\\n            }\\n        }\\n    }\\n\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<ll> dp(numLaps + 1, LLONG_MAX);\\n        dp[0] = 0;\\n        fillDPWithoutChange(dp, changeTime, tires);\\n        modifyDPforChange(dp, changeTime, tires);\\n        return dp[numLaps];\\n    }\\n};\\n```\\n\\nTime Complexity : O(max(numLaps^2,number of tyres))\\nSpace: O(numLaps)\\n\\nYou can ask your doubts in comment section.\\nUpvote if you found this helpful.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n\\n    void fillDPWithoutChange(vector<ll>& dp, int changeTime, vector<vector<int>>& tires)\\n    {\\n        for (vector<int>& currTyre : tires)\\n        {\\n            ll f = currTyre[0];\\n            ll r = currTyre[1];\\n            dp[1] = min(dp[1], f);\\n            ll lastLapTime = f;\\n            ll totalTime = f;\\n            ll lapCount = 2;\\n            while (lastLapTime * r < f + changeTime && lapCount < dp.size())\\n\\t\\t\\t//we can prove that this loop will not run many times because we are\\n\\t\\t\\t//moving in powers of r and even a small r like 2 will terminate this\\n\\t\\t\\t//loop under 20 iterations.\\n            {\\n                ll currLapTime = lastLapTime * r;\\n                totalTime += currLapTime;\\n                dp[lapCount] = min(dp[lapCount], totalTime);\\n                lastLapTime = currLapTime;\\n                lapCount++;\\n            }\\n        }\\n    }\\n\\n    void modifyDPforChange(vector<ll>& dp, int changeTime, vector<vector<int>>& tires)\\n    {\\n        for (ll i = 1; i < dp.size(); ++i)\\n        {\\n            for (ll j = 1; j <= i; ++j)\\n            {\\n                dp[i] = min(dp[i], changeTime + dp[j] + dp[i - j]);\\n            }\\n        }\\n    }\\n\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<ll> dp(numLaps + 1, LLONG_MAX);\\n        dp[0] = 0;\\n        fillDPWithoutChange(dp, changeTime, tires);\\n        modifyDPforChange(dp, changeTime, tires);\\n        return dp[numLaps];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802539,
                "title": "c-dp",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. DP\\n\\nThe `best[i]` is the least time we need to finish `i+1` laps **using a single tire**.  For each tire, we try to use it to update the `best` values.\\n\\nThe `dp` part is doing knapsack using the `best` values to get total `numLaps` laps.\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-time-to-finish-the-race/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numLaps)\\n// Space: O(numLaps)\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& A, int change, int numLaps) {\\n        int N = A.size(), len = 0;\\n        vector<long> best(numLaps, LONG_MAX), dp(numLaps + 1, INT_MAX);\\n        for (int i = 0; i < N; ++i) {\\n            long f = A[i][0], r = A[i][1], sum = change, p = 1; // We assume we also need `change` time to use the first tire so that we don\\'t need to treat the first tire as a special case\\n            for (int j = 0; j < numLaps; ++j) {\\n                sum += f * p;\\n                if (f * p >= f + change) break; // If using the same tire takes no less time than changing the tire, stop further using the current tire\\n                best[j] = min(best[j], sum);\\n                len = max(len, j + 1);\\n                p *= r;\\n            }\\n        }\\n        dp[0] = 0; // dp[i + 1] is the minimum time to finish `numLaps` laps\\n        for (int i = 0; i < numLaps; ++i) {\\n            for (int j = 0; j < len && i - j >= 0; ++j) { // try using the same tire in the last `j+1` laps\\n                dp[i + 1] = min(dp[i + 1], dp[i - j] + best[j]);\\n            }\\n        }\\n        return dp[numLaps] - change; // minus the `change` we added to the first tire\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-time-to-finish-the-race/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numLaps)\\n// Space: O(numLaps)\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& A, int change, int numLaps) {\\n        int N = A.size(), len = 0;\\n        vector<long> best(numLaps, LONG_MAX), dp(numLaps + 1, INT_MAX);\\n        for (int i = 0; i < N; ++i) {\\n            long f = A[i][0], r = A[i][1], sum = change, p = 1; // We assume we also need `change` time to use the first tire so that we don\\'t need to treat the first tire as a special case\\n            for (int j = 0; j < numLaps; ++j) {\\n                sum += f * p;\\n                if (f * p >= f + change) break; // If using the same tire takes no less time than changing the tire, stop further using the current tire\\n                best[j] = min(best[j], sum);\\n                len = max(len, j + 1);\\n                p *= r;\\n            }\\n        }\\n        dp[0] = 0; // dp[i + 1] is the minimum time to finish `numLaps` laps\\n        for (int i = 0; i < numLaps; ++i) {\\n            for (int j = 0; j < len && i - j >= 0; ++j) { // try using the same tire in the last `j+1` laps\\n                dp[i + 1] = min(dp[i + 1], dp[i - j] + best[j]);\\n            }\\n        }\\n        return dp[numLaps] - change; // minus the `change` we added to the first tire\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802706,
                "title": "python-dp",
                "content": "Intuition - since the minimum value of r is 2, this means that we can optimally use a tire for atmost 16 laps (2^15 will be greater than the max changeTime after that)\\n\\nWe can calculate the min cost for first 16 laps if we use only one tire and then use this info to calculate the minimum time taken for each lap considering the switches.\\n\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\n        optimal = [math.inf]*(numLaps+1)\\n        for a,b in tires:\\n            curCost = a\\n            curTire = 1\\n            totalCost = a\\n            while curTire<=16 and curTire<(numLaps+1):\\n                optimal[curTire] = min(optimal[curTire], totalCost)\\n                curCost = curCost * b\\n                totalCost = curCost+totalCost\\n                curTire+=1\\n\\n        for i in range(1,numLaps+1):\\n            for j in range(i-1):\\n                #if we switch tire at jth point \\n                optimal[i] = min(optimal[i],changeTime + optimal[j+1] + optimal[i-(j+1)])\\n                \\n\\n        return optimal[-1]\\n\\t\\t```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\n        optimal = [math.inf]*(numLaps+1)\\n        for a,b in tires:\\n            curCost = a\\n            curTire = 1\\n            totalCost = a\\n            while curTire<=16 and curTire<(numLaps+1):\\n                optimal[curTire] = min(optimal[curTire], totalCost)\\n                curCost = curCost * b\\n                totalCost = curCost+totalCost\\n                curTire+=1\\n\\n        for i in range(1,numLaps+1):\\n            for j in range(i-1):\\n                #if we switch tire at jth point \\n                optimal[i] = min(optimal[i],changeTime + optimal[j+1] + optimal[i-(j+1)])\\n                \\n\\n        return optimal[-1]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1817794,
                "title": "python-c-classic-dp-problem-pre-processing-o-n-2",
                "content": "**Explanation**\\n* Precompute a table, `f[i]`, the minimum time to complete `i` laps *without* and change.\\n* Now the problem becomes: ***when do we change tires to minimise the total time?***\\n\\t* This is similar to the classic [Rod Cutting Problem](https://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture12.pdf) from the CLRS textbook.\\n\\t* We just need to choose how many laps we do before the first change, `j`, and solve the remaining subproblem `dp[i - j]`\\n\\n```\\ndp[i] = min(\\n  f[i], # no tire change\\n  min(f[j] + change_time + dp[i - j], for j < i) # change after the j first laps\\n)\\n```\\n**Python**\\n```python\\nclass Solution:\\n    def minimumFinishTime(self, T, c, k):\\n        f = [ 10**9 for _ in range(k + 1) ]\\n        for t in T:\\n            lap_time = t[0]\\n            tot_time = t[0]\\n            for i in range(1, k + 1):\\n                f[i] = min(f[i], tot_time)\\n                lap_time *= t[1]\\n                tot_time += lap_time\\n                if tot_time > 10**9:\\n                    break\\n        for i in range(2, k + 1):\\n            for j in range(1, i):\\n                f[i] = min(f[i], f[j] + c + f[i - j])\\n        return f[k]\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& T, int c, int k) {\\n        vector<int> f(k + 1, 1e9);\\n        for (auto &t : T) {\\n            long long lap_time = t[0];\\n            long long tot_time = t[0];\\n            for (int i = 1; i <= k; i++) {\\n                f[i] = min(f[i], (int) tot_time);\\n                if ((tot_time += (lap_time *= t[1])) > 1e9) {\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= k; i++) {\\n            for (int j = 1; j < i; j++) {\\n                f[i] = min(f[i], f[j] + c + f[i - j]);\\n            }\\n        }\\n        return f[k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i] = min(\\n  f[i], # no tire change\\n  min(f[j] + change_time + dp[i - j], for j < i) # change after the j first laps\\n)\\n```\n```python\\nclass Solution:\\n    def minimumFinishTime(self, T, c, k):\\n        f = [ 10**9 for _ in range(k + 1) ]\\n        for t in T:\\n            lap_time = t[0]\\n            tot_time = t[0]\\n            for i in range(1, k + 1):\\n                f[i] = min(f[i], tot_time)\\n                lap_time *= t[1]\\n                tot_time += lap_time\\n                if tot_time > 10**9:\\n                    break\\n        for i in range(2, k + 1):\\n            for j in range(1, i):\\n                f[i] = min(f[i], f[j] + c + f[i - j])\\n        return f[k]\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& T, int c, int k) {\\n        vector<int> f(k + 1, 1e9);\\n        for (auto &t : T) {\\n            long long lap_time = t[0];\\n            long long tot_time = t[0];\\n            for (int i = 1; i <= k; i++) {\\n                f[i] = min(f[i], (int) tot_time);\\n                if ((tot_time += (lap_time *= t[1])) > 1e9) {\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= k; i++) {\\n            for (int j = 1; j < i; j++) {\\n                f[i] = min(f[i], f[j] + c + f[i - j]);\\n            }\\n        }\\n        return f[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802439,
                "title": "c-dynamic-programming-with-detailed-explanation",
                "content": "A intuition is that a tire will never be used for too many laps.  Since r >= 2,  2^30 is already a very large number. So let\\'s say, a tire will be used for 30 laps at most.\\n\\nLet best[i] = the minimal cost to run i laps.\\nWe can initialize f[i] by using only a single tire. \\nFor example, \\nuse tire 0 for 1 laps: update best[1] with f0\\nuse tire 0 for 2 laps, update best[2] with f0 * r0\\n...\\nuse tire 1 for 1 laps, update best[1] with f1\\nuse tire 2 for 2 laps, update best[2] with f1 * r1\\n...\\n\\nNow, the goal is to calculate all best[x]  from 1 to numberLaps.\\n\\nSince the last tire can be used for 1 ~30 laps, we can iterate all the possibilities of best[x]:\\nThe last tire run 1 lap: update best[x] with best[1] + best[x-1] + change\\nThe last tire run 2 laps: update best[x] with best[2] + best[x-2] + change\\n...\\n\\ncode:\\n\\n```\\nclass Solution {\\npublic:\\n    long long M = pow(10, 6);\\n    int minimumFinishTime(vector<vector<int>>& tires, int change, int laps) {\\n        vector<long long> best = vector<long long> (2000, pow(10, 10));\\n        best[0] = 0;\\n        for (auto t: tires) {\\n            long long cur = t[0];\\n            long long last = 0;\\n            for (int d = 1; d <= 30; d++ ) {\\n                best[d] = min(best[d], last + cur);\\n                last = last + cur;\\n                cur *= t[1];\\n                if (cur > M) break;\\n            }    \\n        }\\n        for (long long d = 1; d <= laps; d++) {\\n            for (long long l = min(d, (long long)30); l >= 1; l --) {\\n                best[d] = min(best[d], best[l] + best[d - l] + change);\\n            }\\n        }\\n        return best[laps];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long M = pow(10, 6);\\n    int minimumFinishTime(vector<vector<int>>& tires, int change, int laps) {\\n        vector<long long> best = vector<long long> (2000, pow(10, 10));\\n        best[0] = 0;\\n        for (auto t: tires) {\\n            long long cur = t[0];\\n            long long last = 0;\\n            for (int d = 1; d <= 30; d++ ) {\\n                best[d] = min(best[d], last + cur);\\n                last = last + cur;\\n                cur *= t[1];\\n                if (cur > M) break;\\n            }    \\n        }\\n        for (long long d = 1; d <= laps; d++) {\\n            for (long long l = min(d, (long long)30); l >= 1; l --) {\\n                best[d] = min(best[d], best[l] + best[d - l] + change);\\n            }\\n        }\\n        return best[laps];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802719,
                "title": "java-dp-greedy-initiate-minimal-time-for-each-tire-before-change",
                "content": "```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int[] minTime = new int[numLaps + 1];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        for (int[] tire : tires) {\\n            checkMinTime(tire, minTime, changeTime, numLaps);\\n        }\\n        for (int i = 2; i <= numLaps; i++) {\\n            for (int j = 1; j < i; j++) {\\n                int remain = i % j;\\n                int currMin;\\n\\t\\t\\t\\t// Greedy, in order to get the minimal runtime, we should repeat the same loop as much as possible.\\n                if (remain != 0) {\\n                    currMin = (i / j) * (minTime[j] + changeTime) + minTime[remain];\\n                } else {\\n\\t\\t\\t\\t\\t// The last changeTime is not required if remain is 0\\n                    currMin = (i / j) * (minTime[j] + changeTime) - changeTime; \\n                }\\n                minTime[i] = Math.min(minTime[i], currMin);\\n            }\\n        }\\n\\n        return minTime[numLaps];\\n    }\\n    \\n    private void checkMinTime(int[] tire, int[] minTime, int changeTime, int numLaps) {\\n        int base = tire[0];\\n        int lap = 1;\\n        int curr = base;\\n        minTime[lap] = Math.min(minTime[lap], curr);\\n        int sum = base;\\n\\t\\t// Greedy, if changeTime + base is smaller, the minimal runtime for the next lap\\n\\t\\t// will not be better than minTime[lap - 1] + changeTime + minTime[1] \\n        while (curr * tire[1] - base <= changeTime && lap++ < numLaps) {\\n            curr *= tire[1];\\n            sum += curr;\\n            minTime[lap] = Math.min(minTime[lap], sum);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int[] minTime = new int[numLaps + 1];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        for (int[] tire : tires) {\\n            checkMinTime(tire, minTime, changeTime, numLaps);\\n        }\\n        for (int i = 2; i <= numLaps; i++) {\\n            for (int j = 1; j < i; j++) {\\n                int remain = i % j;\\n                int currMin;\\n\\t\\t\\t\\t// Greedy, in order to get the minimal runtime, we should repeat the same loop as much as possible.\\n                if (remain != 0) {\\n                    currMin = (i / j) * (minTime[j] + changeTime) + minTime[remain];\\n                } else {\\n\\t\\t\\t\\t\\t// The last changeTime is not required if remain is 0\\n                    currMin = (i / j) * (minTime[j] + changeTime) - changeTime; \\n                }\\n                minTime[i] = Math.min(minTime[i], currMin);\\n            }\\n        }\\n\\n        return minTime[numLaps];\\n    }\\n    \\n    private void checkMinTime(int[] tire, int[] minTime, int changeTime, int numLaps) {\\n        int base = tire[0];\\n        int lap = 1;\\n        int curr = base;\\n        minTime[lap] = Math.min(minTime[lap], curr);\\n        int sum = base;\\n\\t\\t// Greedy, if changeTime + base is smaller, the minimal runtime for the next lap\\n\\t\\t// will not be better than minTime[lap - 1] + changeTime + minTime[1] \\n        while (curr * tire[1] - base <= changeTime && lap++ < numLaps) {\\n            curr *= tire[1];\\n            sum += curr;\\n            minTime[lap] = Math.min(minTime[lap], sum);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802700,
                "title": "python-dp-solution-in-o-n-time",
                "content": "\\n\\n- `dp[i]` represents for the minimum time to complete `i + 1` laps.\\n- `minimum[i]` represents for the minimum time to complete `i + 1` laps without changing a tire.\\n- `dp[i] = min(dp[i - j - 1] + changeTime + minimum[j] for j in range(len(minimum)))`\\n- don\\u2019t forget about the edge case when `i - j == 0`, which means there is no previous tire. we should discard changeTime and compare `dp[i]` with `minimum[j]` directly.\\n\\n```python\\ndef minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n    minimum = [] # minimum[i] represents for the min time to complete i + 1 laps without changing a tire\\n    total = [0] * len(tires)\\n    # the worst case is: fi = 1, ri = 2, changeTime = 10 ** 5\\n    # this while loop will be computed for at most math.ceil(math.log2(10 ** 5 + 1)) = 17 times\\n    while True:\\n        for t in range(len(tires)):\\n            total[t] += tires[t][0]\\n            tires[t][0] *= tires[t][1]\\n        minimum.append(min(total))\\n        # if the minimum cost is greater than changing a new tire, we stop looping\\n        if minimum[-1] > changeTime + minimum[0]: break\\n\\n    # dp\\n    dp = [float(\\'inf\\')] * numLaps\\n    for l in range(numLaps):\\n        for pre in range(len(minimum)):\\n            if l - pre - 1 < 0:\\n                dp[l] = min(dp[l], minimum[pre])\\n                break\\n            dp[l] = min(dp[l], minimum[pre] + dp[l - pre - 1] + changeTime)\\n    return dp[-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndef minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n    minimum = [] # minimum[i] represents for the min time to complete i + 1 laps without changing a tire\\n    total = [0] * len(tires)\\n    # the worst case is: fi = 1, ri = 2, changeTime = 10 ** 5\\n    # this while loop will be computed for at most math.ceil(math.log2(10 ** 5 + 1)) = 17 times\\n    while True:\\n        for t in range(len(tires)):\\n            total[t] += tires[t][0]\\n            tires[t][0] *= tires[t][1]\\n        minimum.append(min(total))\\n        # if the minimum cost is greater than changing a new tire, we stop looping\\n        if minimum[-1] > changeTime + minimum[0]: break\\n\\n    # dp\\n    dp = [float(\\'inf\\')] * numLaps\\n    for l in range(numLaps):\\n        for pre in range(len(minimum)):\\n            if l - pre - 1 < 0:\\n                dp[l] = min(dp[l], minimum[pre])\\n                break\\n            dp[l] = min(dp[l], minimum[pre] + dp[l - pre - 1] + changeTime)\\n    return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2853283,
                "title": "a-solution-for-those-who-suck-at-dp-like-me",
                "content": "# TL;DR\\nThe final code is [here](#the-final-code). It is a top-down linear solution with memoization, that I think is more intuitive than most of the solutions posted here. It beats 95% of the solutions time-wise. The post elaborates on my way of thinking when working on this.\\n\\n# Introduction\\nI suck at DP. When approaching a DP problem I always start with a top-down brute force recursive solution and then improve it by adding memoization. I don\\'t even bother with the bottom-up approach. We\\'ll do the same here. I found most of the solutions here to require some brilliant insight, and I don\\'t appreciate that. I\\'ll try to show you how I landed a solution with just using common sense.\\n\\n# Start with brute force\\nThe algorithm needs to optimally make the following two decisions again and again until there are no more laps left in the race:\\n- Which tire to select?\\n- For how many laps do we keep the selected tire?\\n\\nSee below the code that implements this in a brute force manner:\\n```cpp\\nint MinFinishTime(const vector<vector<int>>& tires, int laps, int change_time,\\n                  bool is_first_lap = true) {\\n  if (laps == 0) {\\n    return 0;\\n  }\\n  int result = numeric_limits<int>::max();\\n  // When we start the race the first tire is \"free\" to put on.\\n  int c = is_first_lap ? 0 : change_time;\\n  for (auto& t : tires) {\\n    // Try a tire.\\n    int time_with_tire = 0;\\n    for (int lap_time = t[0], remaining_laps = laps; remaining_laps > 0;\\n         lap_time *= t[1], --remaining_laps) {\\n      // Keep tire for consecutive laps, then change tire by a recursive call\\n      // after each lap.\\n      time_with_tire += lap_time;\\n      result = min(c + time_with_tire + MinFinishTime(tires, remaining_laps - 1,\\n                                                      change_time, false),\\n                   result);\\n    }\\n  }\\n  return result;\\n}\\n```\\nOnce we selected our tire (outer foreach loop), we try to keep it for the remaining laps (inner for loop). After each lap with the same tire we try to change to a new one, and continue the race for the remaining laps (recursive call). We\\'ll bubble up the minimum from each recursive call. The minimum of minimums will be the answer.\\n\\nThis code is obviously going to TLE, but even before that it will produce some integer overflows, so let\\'s get rid of that first.\\n\\nThe `lap_time` variable will grow exponentially as we keep taking laps with the same tire. It can quickly get out of the 32 bit integer range if `t[1]` is large. For a moment let\\'s assume we have a single tire type available. It doesn\\'t make sense to keep the tire when `lap_time` is greater or equal `change_time + t[0]` (or $$f*r^0 = f*1$$ as per the problem statement). It\\'s not hard to see that this also applies if we have multiple tires, so let\\'s add this to our loop condition:\\n\\n```cpp\\nfor (int lap_time = t[0], remaining_laps = laps;\\n         remaining_laps > 0 && lap_time < change_time + t[0];\\n         lap_time *= t[1], --remaining_laps) { /* ... */ }\\n```\\nStill, this algorithm is of exponential time complexity, and will TLE even for early test cases. We\\'ll work on improving on this in the following sections.\\n\\n# Add memoization\\nNotice that `laps` is the only parameter of `MinFinishTime` that changes throughout the recursive calls (`is_first_lap` doesn\\'t matter as it\\'s always `false` except for the topmost call). This makes the function a good candidate for 1-dimensional memoization. In general, when you do top-down DP you should be aiming for minimizing the variables in the parameter set of your recursive function, because that\\'s what fundamentally defines how effective your memoization will be.\\n\\nThe code below adds memoization to the brute force recursive solution. We save the results from previous calls in a `vector<int>` that is of size `laps` initialized to all `-1`\\'s.\\n\\n```cpp\\nint MinFinishTime(const vector<vector<int>>& tires, int laps, int change_time,\\n                  vector<int>& memo, bool is_first_lap = true) {\\n  if (laps == 0) {\\n    return 0;\\n  }\\n  if (memo[laps - 1] != -1) {\\n    // We have already computed the optimal solution for racing this number\\n    // of laps.\\n    return memo[laps - 1];\\n  }\\n  int result = numeric_limits<int>::max();\\n  // When we start the race the first tire is \"free\" to put on.\\n  int c = is_first_lap ? 0 : change_time;\\n  for (auto& t : tires) {\\n    // Try a tire.\\n    int time_with_tire = 0;\\n    for (int lap_time = t[0], remaining_laps = laps;\\n         remaining_laps > 0 && lap_time < change_time + t[0];\\n         lap_time *= t[1], --remaining_laps) {\\n      // Keep tire for consecutive laps, then change tire by a recursive call\\n      // after each lap.\\n      time_with_tire += lap_time;\\n      result = min(c + time_with_tire + MinFinishTime(tires, remaining_laps - 1,\\n                                                      change_time, memo, false),\\n                   result);\\n    }\\n  }\\n  return memo[laps - 1] = result;\\n}\\n```\\nI was very disappointed when this code TLE\\'d on the late test cases. Let\\'s examine the time complexity here:\\n- The `MinFinishTime` function will run `laps` times in total thanks to the memoization.\\n- Within the function we\\'ll loop over `tires`.\\n- Within the loop on `tires` we try to take consecutive laps with the same tire.\\n\\nIt\\'s worth thinking about the maximum number of consecutive laps with the same tire. As per the problem definition the following conditions hold:\\n\\n- `t[0] >= 1`\\n- `t[1] >= 2`\\n- `change_time <= 100000`\\n\\nIf we consider the extreme case when `t[0]` and `t[1]` is minimal and `change_time` is maximal, we see that we can run at most 16 laps with the same tire because we anyways change tires when `lap_time >= change_time + t[0]`. Since $$log_2 (10^5+1) = 16.6$$ we\\'ll never take more than 16 laps with the same tire. This leaves with us $$O(L*T*16)=O(L*T)$$ time complexity (where $$L$$ is the number of laps and $$T$$ is the number of tires). It seems though it is not good enough, so we have to work a bit more. The 1-dimensional search space here hints us that we can somehow land a linear algorithm. \\n\\n# Go linear\\n\\nWe can use our intuition to see that we can\\'t save ourselves from trying all the `laps` so we\\'ll have to get rid of the loop on `tires` somehow to reduce time complexity. Let\\'s examine the loop:\\n\\n```cpp\\nfor (auto& t : tires) {\\n  int time_with_tire = 0;\\n  for (int lap_time = t[0], remaining_laps = laps;\\n       remaining_laps > 0 && lap_time < change_time + t[0];\\n       lap_time *= t[1], --remaining_laps) {\\n    // Keep tire for consecutive laps, then change tire by a recursive call\\n    // after each lap.\\n    time_with_tire += lap_time;\\n    result = min(c + time_with_tire + MinFinishTime(tires, remaining_laps - 1,\\n                                                    change_time, memo, false),\\n                 result);\\n  }\\n}\\n```\\nNotice that the inner loop is nothing more than a rolling sum on `lap_time`. The `laps` parameter only determines the number of iterations, it doesn\\'t affect the sum itself (i.e., `time_with_tire`) in any way. We could precompute this rolling sum for all tires and store it in a 2-dimensional array `precomputed_time_with_tire`:\\n```cpp\\nfor (int i = 0; i < tires.size(); ++i) {\\n  int attempts = min((int)precomputed_time_with_tire[i].size(), laps);\\n  for (int j = 0; j < attempts; ++j) {\\n    int remaining_laps = laps - j;\\n    int time_with_tire = precomputed_time_with_tire[i][j];\\n    result = min(c + time_with_tire +\\n                     MinFinishTime(tires, remaining_laps - 1, change_time,\\n                                   precomputed_time_with_tire, memo, false),\\n                 result);\\n  }\\n}\\n```\\nNote that the time complexity remains the same. However we can make a key observation: `c + MinFinishTime(...)` doesn\\'t depend on `i` (the current tire) at all, it only depends on `remaining_laps` AKA `laps - j`. To minimize `time_with_tire + c + MinFinishTime(...)` it\\'s enough to consider the minimum `i` for `precomputed_time_with_tire[i][j]` for all `j`\\'s. We don\\'t care about the `i`\\'s for a particular `j` when `precomputed_time_with_tire[i][j]` is not minimal. Following this logic you can reduce the dimensionality of the precomputed rolling sum to 1 and get rid of the outer loop:\\n```cpp\\nfor (int i = 0; i < min((int)min_time_with_tire.size(), laps); ++i) {\\n  result = min(c + min_time_with_tire[i] +\\n                   MinFinishTime(tires, laps - i - 1, change_time,\\n                                 min_time_with_tire, memo, false),\\n               result);\\n}\\n```\\n\\nHere `min_time_with_tire` is a 1-dimensional array that holds the precomputed minimum value for each `j` from `precomputed_time_with_tire[i][j]`.\\n\\nIntuitively, you can think about `precomputed_time_with_tire[i][j]` as a plot of functions $$g_i(j) = f_i * r_i^j$$. However `min_time_with_tire[j]` only stores the minimum $$g_i(j)$$ for each $$j$$.\\n\\nAfter these amendments the code is of $$O(L*16)=O(L)$$ time complexity, and passes all the test cases. The space complexity is $$O(L+16)=O(L)$$. We beat 95% of the solutions time-wise.\\n\\n# The final code\\n\\n```\\nint MinFinishTime(const vector<vector<int>>& tires, int laps, int change_time,\\n                  const vector<int>& min_time_with_tire, vector<int>& memo,\\n                  bool is_first_lap = true) {\\n  if (laps == 0) {\\n    return 0;\\n  }\\n  if (memo[laps - 1] != -1) {\\n    return memo[laps - 1];\\n  }\\n  int result = numeric_limits<int>::max();\\n  int c = is_first_lap ? 0 : change_time;\\n  for (int i = 0; i < min((int)min_time_with_tire.size(), laps); ++i) {\\n    result = min(c + min_time_with_tire[i] +\\n                     MinFinishTime(tires, laps - i - 1, change_time,\\n                                   min_time_with_tire, memo, false),\\n                 result);\\n  }\\n  return memo[laps - 1] = result;\\n}\\n\\nclass Solution {\\n public:\\n  int minimumFinishTime(vector<vector<int>>& tires, int change_time, int laps) {\\n    vector<int> min_time_with_tire;\\n    for (auto& t : tires) {\\n      int lap_time = t[0];\\n      int time_with_tire = 0;\\n      for (int lap = 0; lap < laps; ++lap) {\\n        time_with_tire += lap_time;\\n        if (lap == min_time_with_tire.size()) {\\n          min_time_with_tire.push_back(time_with_tire);\\n        } else {\\n          min_time_with_tire[lap] =\\n              min(time_with_tire, min_time_with_tire[lap]);\\n        }\\n        if (lap_time > (t[0] + change_time) / t[1]) {\\n          break;\\n        }\\n        lap_time *= t[1];\\n      }\\n    }\\n    vector<int> memo(laps, -1);\\n    return MinFinishTime(tires, laps, change_time, min_time_with_tire, memo);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cpp\\nint MinFinishTime(const vector<vector<int>>& tires, int laps, int change_time,\\n                  bool is_first_lap = true) {\\n  if (laps == 0) {\\n    return 0;\\n  }\\n  int result = numeric_limits<int>::max();\\n  // When we start the race the first tire is \"free\" to put on.\\n  int c = is_first_lap ? 0 : change_time;\\n  for (auto& t : tires) {\\n    // Try a tire.\\n    int time_with_tire = 0;\\n    for (int lap_time = t[0], remaining_laps = laps; remaining_laps > 0;\\n         lap_time *= t[1], --remaining_laps) {\\n      // Keep tire for consecutive laps, then change tire by a recursive call\\n      // after each lap.\\n      time_with_tire += lap_time;\\n      result = min(c + time_with_tire + MinFinishTime(tires, remaining_laps - 1,\\n                                                      change_time, false),\\n                   result);\\n    }\\n  }\\n  return result;\\n}\\n```\n```cpp\\nfor (int lap_time = t[0], remaining_laps = laps;\\n         remaining_laps > 0 && lap_time < change_time + t[0];\\n         lap_time *= t[1], --remaining_laps) { /* ... */ }\\n```\n```cpp\\nint MinFinishTime(const vector<vector<int>>& tires, int laps, int change_time,\\n                  vector<int>& memo, bool is_first_lap = true) {\\n  if (laps == 0) {\\n    return 0;\\n  }\\n  if (memo[laps - 1] != -1) {\\n    // We have already computed the optimal solution for racing this number\\n    // of laps.\\n    return memo[laps - 1];\\n  }\\n  int result = numeric_limits<int>::max();\\n  // When we start the race the first tire is \"free\" to put on.\\n  int c = is_first_lap ? 0 : change_time;\\n  for (auto& t : tires) {\\n    // Try a tire.\\n    int time_with_tire = 0;\\n    for (int lap_time = t[0], remaining_laps = laps;\\n         remaining_laps > 0 && lap_time < change_time + t[0];\\n         lap_time *= t[1], --remaining_laps) {\\n      // Keep tire for consecutive laps, then change tire by a recursive call\\n      // after each lap.\\n      time_with_tire += lap_time;\\n      result = min(c + time_with_tire + MinFinishTime(tires, remaining_laps - 1,\\n                                                      change_time, memo, false),\\n                   result);\\n    }\\n  }\\n  return memo[laps - 1] = result;\\n}\\n```\n```cpp\\nfor (auto& t : tires) {\\n  int time_with_tire = 0;\\n  for (int lap_time = t[0], remaining_laps = laps;\\n       remaining_laps > 0 && lap_time < change_time + t[0];\\n       lap_time *= t[1], --remaining_laps) {\\n    // Keep tire for consecutive laps, then change tire by a recursive call\\n    // after each lap.\\n    time_with_tire += lap_time;\\n    result = min(c + time_with_tire + MinFinishTime(tires, remaining_laps - 1,\\n                                                    change_time, memo, false),\\n                 result);\\n  }\\n}\\n```\n```cpp\\nfor (int i = 0; i < tires.size(); ++i) {\\n  int attempts = min((int)precomputed_time_with_tire[i].size(), laps);\\n  for (int j = 0; j < attempts; ++j) {\\n    int remaining_laps = laps - j;\\n    int time_with_tire = precomputed_time_with_tire[i][j];\\n    result = min(c + time_with_tire +\\n                     MinFinishTime(tires, remaining_laps - 1, change_time,\\n                                   precomputed_time_with_tire, memo, false),\\n                 result);\\n  }\\n}\\n```\n```cpp\\nfor (int i = 0; i < min((int)min_time_with_tire.size(), laps); ++i) {\\n  result = min(c + min_time_with_tire[i] +\\n                   MinFinishTime(tires, laps - i - 1, change_time,\\n                                 min_time_with_tire, memo, false),\\n               result);\\n}\\n```\n```\\nint MinFinishTime(const vector<vector<int>>& tires, int laps, int change_time,\\n                  const vector<int>& min_time_with_tire, vector<int>& memo,\\n                  bool is_first_lap = true) {\\n  if (laps == 0) {\\n    return 0;\\n  }\\n  if (memo[laps - 1] != -1) {\\n    return memo[laps - 1];\\n  }\\n  int result = numeric_limits<int>::max();\\n  int c = is_first_lap ? 0 : change_time;\\n  for (int i = 0; i < min((int)min_time_with_tire.size(), laps); ++i) {\\n    result = min(c + min_time_with_tire[i] +\\n                     MinFinishTime(tires, laps - i - 1, change_time,\\n                                   min_time_with_tire, memo, false),\\n                 result);\\n  }\\n  return memo[laps - 1] = result;\\n}\\n\\nclass Solution {\\n public:\\n  int minimumFinishTime(vector<vector<int>>& tires, int change_time, int laps) {\\n    vector<int> min_time_with_tire;\\n    for (auto& t : tires) {\\n      int lap_time = t[0];\\n      int time_with_tire = 0;\\n      for (int lap = 0; lap < laps; ++lap) {\\n        time_with_tire += lap_time;\\n        if (lap == min_time_with_tire.size()) {\\n          min_time_with_tire.push_back(time_with_tire);\\n        } else {\\n          min_time_with_tire[lap] =\\n              min(time_with_tire, min_time_with_tire[lap]);\\n        }\\n        if (lap_time > (t[0] + change_time) / t[1]) {\\n          break;\\n        }\\n        lap_time *= t[1];\\n      }\\n    }\\n    vector<int> memo(laps, -1);\\n    return MinFinishTime(tires, laps, change_time, min_time_with_tire, memo);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389898,
                "title": "java-dp-easy-to-understand-solution-with-comments",
                "content": "Bottom up dp - for each lap i, see if we get optimal time by changing tires in lap j before it ie dp[i] = Math.min (dp[i], dp[j] + changeTime + dp[i - j]) \\n\\n```\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        \\n        //Min time to finish all laps without changing tires, compared across all tires\\n        int[] minTimes = new int[numLaps +1];\\n        Arrays.fill(minTimes, Integer.MAX_VALUE);\\n        for(int[] tire: tires ){\\n            populateMinTime(minTimes, tire , changeTime, numLaps);\\n        }\\n        \\n\\t\\t//For every lap i , see if you get better time by changing tires on all laps before i ie 1 to i using j loop\\n\\t\\t//eg : for lap 10, check if you get better time by changing tire at all laps before 10 ie 1.2.3....9\\n        for(int i=1; i<=numLaps; i++){\\n            for(int j=1; j<i; j++){\\n                minTimes[i] = Math.min( minTimes[i],  minTimes[j] + changeTime + minTimes[i-j]);\\n            }            \\n        }\\n        return minTimes[numLaps];\\n    }\\n    \\n    void populateMinTime(int[] minTimes, int[] tire, int changeTime, int numLaps){\\n        \\n        int baseTime = tire[0];\\n        int expTime = tire[1];\\n        \\n        //To keep track of a lap time & entire race time using this tire\\n        int lapTime = baseTime;\\n        int totalTime = lapTime;\\n        \\n        //lap 1 will only have base time, calculate from lap 2\\n        minTimes[1] = Math.min(baseTime, minTimes[1]);\\n        for(int lap=2; lap<=numLaps; lap++){\\n           \\n            lapTime*=expTime; //time for current lap = prevLapTime*expTime instead of recalcuating entire value\\n                \\n            //***IMP change time is better, no point calculating further\\n            if(lapTime> changeTime+baseTime) break; \\n                \\n            totalTime+=lapTime;\\n            \\n            minTimes[lap] = Math.min(minTimes[lap], totalTime);\\n        }      \\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Bottom up dp - for each lap i, see if we get optimal time by changing tires in lap j before it ie dp[i] = Math.min (dp[i], dp[j] + changeTime + dp[i - j]) \\n\\n```\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        \\n        //Min time to finish all laps without changing tires, compared across all tires\\n        int[] minTimes = new int[numLaps +1];\\n        Arrays.fill(minTimes, Integer.MAX_VALUE);\\n        for(int[] tire: tires ){\\n            populateMinTime(minTimes, tire , changeTime, numLaps);\\n        }\\n        \\n\\t\\t//For every lap i , see if you get better time by changing tires on all laps before i ie 1 to i using j loop\\n\\t\\t//eg : for lap 10, check if you get better time by changing tire at all laps before 10 ie 1.2.3....9\\n        for(int i=1; i<=numLaps; i++){\\n            for(int j=1; j<i; j++){\\n                minTimes[i] = Math.min( minTimes[i],  minTimes[j] + changeTime + minTimes[i-j]);\\n            }            \\n        }\\n        return minTimes[numLaps];\\n    }\\n    \\n    void populateMinTime(int[] minTimes, int[] tire, int changeTime, int numLaps){\\n        \\n        int baseTime = tire[0];\\n        int expTime = tire[1];\\n        \\n        //To keep track of a lap time & entire race time using this tire\\n        int lapTime = baseTime;\\n        int totalTime = lapTime;\\n        \\n        //lap 1 will only have base time, calculate from lap 2\\n        minTimes[1] = Math.min(baseTime, minTimes[1]);\\n        for(int lap=2; lap<=numLaps; lap++){\\n           \\n            lapTime*=expTime; //time for current lap = prevLapTime*expTime instead of recalcuating entire value\\n                \\n            //***IMP change time is better, no point calculating further\\n            if(lapTime> changeTime+baseTime) break; \\n                \\n            totalTime+=lapTime;\\n            \\n            minTimes[lap] = Math.min(minTimes[lap], totalTime);\\n        }      \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1805075,
                "title": "dp-without-the-18-lap-magic-number",
                "content": "The idea: calculate the max number it makes sense to use the same tire. In other posts, posters use the number 18 because `2^18` > the constraint `2^18 > changeTime <= 10^5`. Here we calculate the actual best number.\\n\\nImagine a tire [2, 3] and changeTime 30\\nIf we use the same tire\\nAt lap 1: cost is 2\\nLap 2: cost is 2 * 3^1 = 6\\nLap 3: cost is 2 * 3^2 = 18\\nLap 4: cost is 2 * 3^3 = 54 -> here it would not make sense to use the same tire  because we can just change the tire here for cost of 30 and then use the new tire for cost of 2, so we figure out the max consecutive laps we can use this tire for is 3\\n\\nIn the code below, we figure out how many times we can use the same tire for ANY tire, by calculating it based on the smallest tire in the tire list.\\n\\n`sameTire` is a DP array tracking what is the min cost to complete lap `i` if we use one single tire (any tire)\\n\\n```\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {  \\n    const n = tires.length\\n    const smallestTire = Math.min(...tires.map(t => t[1]))\\n    const maxSameTire = Math.floor(Math.log(changeTime) / Math.log(smallestTire)) + 1\\n    const sameTireLast = Array(n).fill(0)\\n\\t\\n\\t// DP array tracking what is the min cost to complete lap i using same tire\\n    const sameTire = Array(maxSameTire + 1).fill(Infinity)\\n    for (let lap = 1; lap <= maxSameTire; lap++) {\\n        tires.forEach((tire, i) => {\\n            sameTireLast[i] += tire[0] * tire[1] ** (lap - 1)\\n            sameTire[lap] = Math.min(sameTire[lap], sameTireLast[i])\\n        })\\n    }\\n    \\n    const dp = Array(numLaps + 1).fill(Infinity)\\n    for (let i = 1; i < numLaps + 1; i++) {\\n        if (i <= maxSameTire) dp[i] = sameTire[i]\\n\\t\\t// at each lap, we can either use the same tire up to this lap (sameTire[i])\\n\\t\\t// or a combination of 2 different best times, \\n\\t\\t// eg lap 6: use best time from lap 3 + lap 3\\n\\t\\t// or from lap 4 + lap 2\\n\\t\\t// or lap 5 + lap 1\\n        for (let j = 1; j < i / 2 + 1; j++) {\\n            dp[i] = Math.min(dp[i], dp[i-j] + changeTime + dp[j])\\n        }\\n    }\\n    return dp[numLaps]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {  \\n    const n = tires.length\\n    const smallestTire = Math.min(...tires.map(t => t[1]))\\n    const maxSameTire = Math.floor(Math.log(changeTime) / Math.log(smallestTire)) + 1\\n    const sameTireLast = Array(n).fill(0)\\n\\t\\n\\t// DP array tracking what is the min cost to complete lap i using same tire\\n    const sameTire = Array(maxSameTire + 1).fill(Infinity)\\n    for (let lap = 1; lap <= maxSameTire; lap++) {\\n        tires.forEach((tire, i) => {\\n            sameTireLast[i] += tire[0] * tire[1] ** (lap - 1)\\n            sameTire[lap] = Math.min(sameTire[lap], sameTireLast[i])\\n        })\\n    }\\n    \\n    const dp = Array(numLaps + 1).fill(Infinity)\\n    for (let i = 1; i < numLaps + 1; i++) {\\n        if (i <= maxSameTire) dp[i] = sameTire[i]\\n\\t\\t// at each lap, we can either use the same tire up to this lap (sameTire[i])\\n\\t\\t// or a combination of 2 different best times, \\n\\t\\t// eg lap 6: use best time from lap 3 + lap 3\\n\\t\\t// or from lap 4 + lap 2\\n\\t\\t// or lap 5 + lap 1\\n        for (let j = 1; j < i / 2 + 1; j++) {\\n            dp[i] = Math.min(dp[i], dp[i-j] + changeTime + dp[j])\\n        }\\n    }\\n    return dp[numLaps]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068023,
                "title": "top-down-dp-with-memoization-and-pre-processing-explanation-with-graphs",
                "content": "# Intuition\\n\\nI will try to show here a visual representation of how to get to an acceptable solution. I will start from the usual DP sotuion that fails due to TLE and try to give tips that you should keep an eye for that may help in similar questions.\\n\\nI will apologize in advance for the long text, but I want to be thorough. If you ever read my text again hopefully you will feel confortable on skipping most parts of it.\\n\\nFirst of all let me comment some things that are specific to this problem but you need to keep in mind:\\n- We already know a trivial path from the start to the end: changing at every lap the tires for the one with smallest `tires[0]`, so any path that takes more time than that can be discarded.\\n  - This will be useful to discard continuous usages of the tire, resulting on a limited number of edges between vertices (otherwise a lap would need to check paths to all future laps)\\n\\nNow allow me to present the graph of the tipical DP solution that has e memo of 3 dimensions and runs in `O(laps * tires^2)`\\n\\nThis graph is for a small case of 4 laps and 3 tires. Please keep in mins that I start my count at 0.\\n\\n![image.png](https://assets.leetcode.com/users/images/639f4dcd-8570-4d2c-bb5d-02bf604bfecd_1674037797.2125778.png)\\n\\nPlease notice that from the drawing you can see that the memoization only really helps us on few nodes (in orange), because they are the only ones queried multiple times\\n\\n![image.png](https://assets.leetcode.com/users/images/c4205914-4d4b-45dd-890a-44b7dcae8ed3_1674037913.1672432.png)\\n\\nAnd as the information we are interested/requesting is the minimum between them EVERY time, we could store that in the memoization, represented as the new vertice purple\\n\\n![image.png](https://assets.leetcode.com/users/images/042d2363-6ba4-4f87-9ac6-f20703bd97f2_1674038038.293783.png)\\n\\nNow we have two types of vertices:\\n- The ones that have multiple entries. We will implement memoization on them.\\n- The others with only one entry. Representing them this way is useful to keep the graph clean, organize our code and avoid repeated work. But nothing prevents us from duplicating the vertices and creating single output vertices.\\n\\nThe transformation in single output vertices I mention is similar to the picture below. I wont represent the whole graph like this because it is really big (one of the reasons we gourp them)\\n\\n![image.png](https://assets.leetcode.com/users/images/276fe8b3-a555-423d-9ef7-9d82578148d0_1674038635.4769423.png)\\n\\nAlso nothing prevents us from grouping sequectial vertices into only one.\\n\\n![image.png](https://assets.leetcode.com/users/images/c21c386c-a1c4-43ec-a422-3fa9e36b5dc2_1674038779.7843218.png)\\n\\nLets apply this two concepts in the graph we had.\\nNote: we dont need to change tires at the start, but every other time we need to sum the changeTime to the lap times.\\n\\n![image.png](https://assets.leetcode.com/users/images/86538d50-5270-43bc-88f4-5af9279dc175_1674039321.911614.png)\\n\\n\\nAs we are searching for the smallest path, different edges between the same vertices can also be grouped\\n\\n![image.png](https://assets.leetcode.com/users/images/849c1934-799f-4b74-9ea1-92604a738f72_1674039424.6347744.png)\\n\\nOnce we get to this drawing (and also the previous one), you will notice that many paths have the same vertices. One graphs like this we can apply pre-precessing to avoid calcuating multiple times the same information.\\n\\nOn the code you will see the first part pre-processing the black vertices (only until they are below the trivial path mentioned at the befining of the text). The second part is the top-down dynamic programming with memoization for the purple vertices.\\n\\n# Approach\\n- Top-down dynamic programming with memoization\\n- Pre-processing\\n\\n# Complexity\\n- Time complexity:\\n$$O(tires+laps)$$\\n\\n- Space complexity:\\n$$O(laps)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/f7180f24-6fa6-4696-964f-06bed980aef7_1674049251.0458388.png)\\n\\n```java\\nclass Solution {\\n    int[] best, memo;\\n    int numLaps, changeTime, maxLaps=0;\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        this.memo=new int[numLaps];\\n        this.best=new int[numLaps];\\n        this.numLaps=numLaps;\\n        this.changeTime=changeTime;\\n        int minChangeTime=Integer.MAX_VALUE;\\n        for(int[] t: tires) if(t[0]<minChangeTime) minChangeTime=t[0];\\n        minChangeTime+=changeTime;\\n        // Pre-process black vertices\\n        Arrays.fill(best, Integer.MAX_VALUE/2);\\n        for (int i = 0; i < tires.length; i++) {\\n            int lapTime=tires[i][0], totalTime=lapTime;\\n            for (int contLaps=0; contLaps<numLaps && lapTime<(contLaps+1)*minChangeTime; contLaps++) {\\n                if(totalTime<best[contLaps]) best[contLaps]=totalTime;\\n                if(contLaps>maxLaps) maxLaps=contLaps;\\n                lapTime*=tires[i][1];\\n                totalTime+=lapTime;\\n            }\\n        }\\n        // Top-down DP with memoization on orange cells\\n        // Removing one change time as we can start the race with\\n        // the tire we want without needing to change it\\n        return helper(0)-changeTime;\\n    }\\n\\n    private int helper(int lap) {\\n        if(lap==numLaps) return 0;\\n        if (memo[lap]>0) return memo[lap];\\n        int min = Integer.MAX_VALUE/2;\\n        for (int i=0; i<=maxLaps && i+lap<=numLaps-1; i++) {\\n            min = Math.min(min,best[i]+helper(i+lap+1));\\n        }\\n        min+=changeTime;\\n        return memo[lap] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    int[] best, memo;\\n    int numLaps, changeTime, maxLaps=0;\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        this.memo=new int[numLaps];\\n        this.best=new int[numLaps];\\n        this.numLaps=numLaps;\\n        this.changeTime=changeTime;\\n        int minChangeTime=Integer.MAX_VALUE;\\n        for(int[] t: tires) if(t[0]<minChangeTime) minChangeTime=t[0];\\n        minChangeTime+=changeTime;\\n        // Pre-process black vertices\\n        Arrays.fill(best, Integer.MAX_VALUE/2);\\n        for (int i = 0; i < tires.length; i++) {\\n            int lapTime=tires[i][0], totalTime=lapTime;\\n            for (int contLaps=0; contLaps<numLaps && lapTime<(contLaps+1)*minChangeTime; contLaps++) {\\n                if(totalTime<best[contLaps]) best[contLaps]=totalTime;\\n                if(contLaps>maxLaps) maxLaps=contLaps;\\n                lapTime*=tires[i][1];\\n                totalTime+=lapTime;\\n            }\\n        }\\n        // Top-down DP with memoization on orange cells\\n        // Removing one change time as we can start the race with\\n        // the tire we want without needing to change it\\n        return helper(0)-changeTime;\\n    }\\n\\n    private int helper(int lap) {\\n        if(lap==numLaps) return 0;\\n        if (memo[lap]>0) return memo[lap];\\n        int min = Integer.MAX_VALUE/2;\\n        for (int i=0; i<=maxLaps && i+lap<=numLaps-1; i++) {\\n            min = Math.min(min,best[i]+helper(i+lap+1));\\n        }\\n        min+=changeTime;\\n        return memo[lap] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803356,
                "title": "java-dp-solution",
                "content": "```\\n\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int[] straight = new int[19];\\n        Arrays.fill(straight, Integer.MAX_VALUE);\\n        for (int[] tire: tires) {\\n            int f = tire[0];\\n            int r = tire[1];\\n            int timeSum = 0;\\n            for (int i = 1; i <= numLaps; i++) {\\n                int t =  f * (int) Math.pow(r, i - 1); \\n                timeSum += t;\\n                if (timeSum > Math.pow(2, 18)) {\\n                    break; //more than required time, impossible to reach by going straight\\n                }\\n                straight[i] = Math.min(straight[i], timeSum);\\n            }\\n        }\\n        int[] dp = new int[numLaps + 1];\\n        for (int i = 1; i <= numLaps; i++) {\\n            dp[i] = i < 19? straight[i] : Integer.MAX_VALUE;\\n            for (int j = 1; j < Math.min(19, i/2 + 1); j++) {\\n                dp[i] = Math.min(dp[i], dp[j] + changeTime + dp[i - j]);\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int[] straight = new int[19];\\n        Arrays.fill(straight, Integer.MAX_VALUE);\\n        for (int[] tire: tires) {\\n            int f = tire[0];\\n            int r = tire[1];\\n            int timeSum = 0;\\n            for (int i = 1; i <= numLaps; i++) {\\n                int t =  f * (int) Math.pow(r, i - 1); \\n                timeSum += t;\\n                if (timeSum > Math.pow(2, 18)) {\\n                    break; //more than required time, impossible to reach by going straight\\n                }\\n                straight[i] = Math.min(straight[i], timeSum);\\n            }\\n        }\\n        int[] dp = new int[numLaps + 1];\\n        for (int i = 1; i <= numLaps; i++) {\\n            dp[i] = i < 19? straight[i] : Integer.MAX_VALUE;\\n            for (int j = 1; j < Math.min(19, i/2 + 1); j++) {\\n                dp[i] = Math.min(dp[i], dp[j] + changeTime + dp[i - j]);\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803014,
                "title": "python-dp-with-pre-treatment-to-reduce-time-complexity",
                "content": "Let t[n] denotes the minimum time to run n laps, the DP equation is thus:\\nt[n] = min {r = 1 ~ min(maxt,n)} t[r] + changeTime + t[n-r]\\n\\nNow we add some pre-treatment:\\n1) The default value of t[n] for any n can be set as changeTime * (n-1) + min(f) * n, i.e., change tire after every lap. \\n2) We don\\'t need to consider all tires. If tire1 and tire2 satisfies f1<=f2 and r1<=r2, then tire1 dominates tire2. Therefore, suppose (in a sorted list of tires) the last tire we consider is tire1, we only consider tire2 if f2>f1 and r2<r1. \\n3) maxt is the largest possible number of laps to run without changing tires. Therefore, maxt can be quite small compared to numLaps. To get maxt, for every tire we consider in 2, try running it without changing tires until the time for running the next lap is greater than changeTime + f (and thus it\\'s better to change tire). Or simply use maxt = 17 as 2^17 = 131072>10^5. \\n\\nThe current time complexity stands at O(T log T + (T+N) log C), where T = number of tires, N = numLaps and C = changeTime. O(T log T) from sorting the tires, O(T log C) to derive maxt (note that maxt < log2(changeTime)), and finally soving the DP for O(N log C). \\n\\nAlthough ignoring pre-treatment 2 and considering all tires would eliminate the O(T log T) part, it will actually make the (hidden) constant larger for the O(T log C) part later, and the runtime comparison is 2600+ ms w/ pre-treatment 2 compared to 8000+ ms w/o, suggesting that in the testcases many tires are dominated. \\n\\nMeanwhile, pre-treatment 3 is a huge improvement in terms of time complexity from O(N^2) of the usual DP to O(N log C). The runtime comparison is 2600+ ms w/ compared to 7500+ ms w/o. \\n\\nHere\\'s my code. On second thought the newTires list is not necessary but I am lazy so I will just leave it be. \\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        tires.sort()\\n        newTires = []\\n        minTime = [changeTime*(i-1) + tires[0][0]*i for i in range(numLaps+1)]\\n        minTime[0] = 0\\n        maxi = 0\\n        for f,r in tires:\\n            if not newTires or f>newTires[-1][0] and r<newTires[-1][1]:\\n                newTires.append([f,r])\\n                t = f\\n                i = 1\\n                while i<numLaps and t*(r-1)<changeTime:\\n                    t = t*r + f\\n                    i += 1\\n                    if minTime[i]>t:\\n                        minTime[i]=t\\n                        maxi = max(i,maxi)\\n        for lap in range(numLaps+1):\\n            for run in range(min(lap,maxi+1)):\\n                minTime[lap] = min(minTime[lap],minTime[lap-run]+changeTime+minTime[run])\\n        return minTime[numLaps]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        tires.sort()\\n        newTires = []\\n        minTime = [changeTime*(i-1) + tires[0][0]*i for i in range(numLaps+1)]\\n        minTime[0] = 0\\n        maxi = 0\\n        for f,r in tires:\\n            if not newTires or f>newTires[-1][0] and r<newTires[-1][1]:\\n                newTires.append([f,r])\\n                t = f\\n                i = 1\\n                while i<numLaps and t*(r-1)<changeTime:\\n                    t = t*r + f\\n                    i += 1\\n                    if minTime[i]>t:\\n                        minTime[i]=t\\n                        maxi = max(i,maxi)\\n        for lap in range(numLaps+1):\\n            for run in range(min(lap,maxi+1)):\\n                minTime[lap] = min(minTime[lap],minTime[lap-run]+changeTime+minTime[run])\\n        return minTime[numLaps]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802599,
                "title": "python-dp-top-down-with-comments",
                "content": "\\nThe idea is pre-calculate (required time, lap time) for each tire continuously. Use 2D array to store this (memo[tires][lap]).\\n\\ndp(x) is the solution of the best time we can get at lap x, which is min(change at some time, no change). Say we change at sometime t, and we ran a laps before t and b laps after t. (actually the order of a and b is not important) Go through all the a, b where a >= b and a+b == x\\n\\nWe don\\'t care about which tire we\\'re using previously.\\n\\nFor these nasty test cases of tires, (which is including a lot of duplicates and \\'worse\\' tires) at first I thought we can also trim those tires by only keep better tires (min r for all seen f, and min f for all seen r). But it won\\'t improve much compared with simply convert to set.\\n\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        # by observation, we can try to find out the optimal usage within certain numLaps\\n        # use DP\\n        # the optimal usage of this lap = min(change tire , no change)\\n        # dp(laps) = min( dp(laps-1)+dp(1) + dp(laps-2)+dp(2) + ...)\\n        \\n        # we don\\'t want to use tires too many laps, which will create unrealistic single lap time\\n\\t\\t# we can evaluate single lap time by using changeTime <= 100000 and r >= 2\\n\\t\\t# x = minimal continously laps\\n\\t\\t# single lap time = 1*2^x <= 100000 -> x can\\'t go more than 19\\n\\t\\tlimit = 19\\n        tires = list(set([(t1, t2) for t1, t2 in tires]))\\n        memo = [[(-1,-1) for _ in range(min(limit,numLaps)+1)] for _ in range(len(tires))]\\n        \\n        for i in range(len(tires)):\\n            for j in range(1, min(limit,numLaps)+1):                   # lap 1 to numLaps\\n                if j == 1:\\n                    memo[i][j] = (tires[i][0], tires[i][0])            # total time, lap time\\n                else:\\n                    # print(\\'i, j\\', i, j)\\n                    tmp = memo[i][j-1][1]*tires[i][1]                  # cost of continuously use tire this lap\\n                    memo[i][j] = (memo[i][j-1][0]+tmp, tmp)\\n        \\n        @cache\\n        def dp(laps):\\n            if laps == 1:\\n                return min(memo[i][1][0] for i in range(len(tires)))\\n            \\n            # no change:\\n            best_time = min(memo[i][laps][0] for i in range(len(tires))) if laps <= limit else float(\\'inf\\')\\n            \\n            # change tire:\\n\\t\\t\\t# e.g. change tire at this lap and see if it\\'ll be faster -> dp(laps-1) + changeTime + dp(1)\\n            # check all previous laps: dp(a) + changeTime + dp(b) until a < b\\n            for j in range(1, laps):\\n                a, b = laps-j, j\\n                if a >= b:\\n                    ta = dp(a)\\n                    tb = dp(b)\\n                    if ta+tb+changeTime < best_time:\\n                        best_time = ta+tb+changeTime\\n            return best_time\\n                \\n        return dp(numLaps)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        # by observation, we can try to find out the optimal usage within certain numLaps\\n        # use DP\\n        # the optimal usage of this lap = min(change tire , no change)\\n        # dp(laps) = min( dp(laps-1)+dp(1) + dp(laps-2)+dp(2) + ...)\\n        \\n        # we don\\'t want to use tires too many laps, which will create unrealistic single lap time\\n\\t\\t# we can evaluate single lap time by using changeTime <= 100000 and r >= 2\\n\\t\\t# x = minimal continously laps\\n\\t\\t# single lap time = 1*2^x <= 100000 -> x can\\'t go more than 19\\n\\t\\tlimit = 19\\n        tires = list(set([(t1, t2) for t1, t2 in tires]))\\n        memo = [[(-1,-1) for _ in range(min(limit,numLaps)+1)] for _ in range(len(tires))]\\n        \\n        for i in range(len(tires)):\\n            for j in range(1, min(limit,numLaps)+1):                   # lap 1 to numLaps\\n                if j == 1:\\n                    memo[i][j] = (tires[i][0], tires[i][0])            # total time, lap time\\n                else:\\n                    # print(\\'i, j\\', i, j)\\n                    tmp = memo[i][j-1][1]*tires[i][1]                  # cost of continuously use tire this lap\\n                    memo[i][j] = (memo[i][j-1][0]+tmp, tmp)\\n        \\n        @cache\\n        def dp(laps):\\n            if laps == 1:\\n                return min(memo[i][1][0] for i in range(len(tires)))\\n            \\n            # no change:\\n            best_time = min(memo[i][laps][0] for i in range(len(tires))) if laps <= limit else float(\\'inf\\')\\n            \\n            # change tire:\\n\\t\\t\\t# e.g. change tire at this lap and see if it\\'ll be faster -> dp(laps-1) + changeTime + dp(1)\\n            # check all previous laps: dp(a) + changeTime + dp(b) until a < b\\n            for j in range(1, laps):\\n                a, b = laps-j, j\\n                if a >= b:\\n                    ta = dp(a)\\n                    tb = dp(b)\\n                    if ta+tb+changeTime < best_time:\\n                        best_time = ta+tb+changeTime\\n            return best_time\\n                \\n        return dp(numLaps)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429935,
                "title": "c-recursive-approach-greedy-can-t-solve-this",
                "content": "This question seems so hard if you keep on thinking in a Greedy way, but it is so easy as soon as you go recursive.\\n\\n**Why not GREEDY?**\\nWell, we can not choose the best answer at current stage just coz it is minimum. There could be a certain case where we could get a better answer with another choice. \\n```\\nSimplest example :\\n\\t\\t\\t\\t\\t\\t\\t\\t t1    t2\\n  \\t\\t\\t\\t\\ttires[] : [[2,10],[3,3]]\\n\\t\\t\\tNow, for 1st lap, \\n\\t\\t\\t\\t\\tt1 will take 2 seconds, and t2 will finish in 3\\n\\t\\t\\tSo, greedy says, \"lets pick up t1!\", \\n\\t\\t\\tthen for 2nd lap, \\n\\t\\t\\t\\t\\tt1 takes 2*10 = 20 seconds, and t2 takes 3*3 = 9 seconds\\n\\t\\t\\tWell, here we see that cumulative time taken by t1 for 2 laps is 2+20 = 22 seconds\\n\\t\\t\\twhile for t2, it is 3+9 = 12 seconds\\n```\\nThe above example illustrates why greedy fails at this question.\\n\\n**What to do then?**\\nWell, as the saying goes for us programmers, *\"Where greedy fails, DP works\"*. \\nSo, its simple recursion + memoization. We make a choice of whether to switch to a new tire at this lap, or continue with what we have.\\nIf we switch to a new tire at current lap, our answer will be computed as *bestTimeTillNow + switchingTime + BestAnswerFor(remaining laps)*\\n\\n**How do we achieve that?**\\nTo achieve our strategic goal, we precompute the time one particular tire will take to complete laps without changing it. This will help us as if the time this tire takes becomes greater than the time it take to switch to a new tire, then there is no meaning of continuing with the tire. So, we find the best time to complete a particular lap with any tire. When we have that, we use that best time in our recurrance relation. \\n\\n```\\nclass Solution {\\npublic:\\n    int maxLaps = 0; // So that we dont have to iterate for all n laps but for those which can be \\n                     // travelled without changing tire\\n    int minimumFinishTime(vector<vector<int>>& tires, int t, int n) {\\n        vector <long long> best(n+1,INT_MAX);\\n        for(int i = 0; i<tires.size(); i++){\\n            long long time = tires[i][0], sum = tires[i][0];\\n            // loop for laps\\n            for(int j = 1; j<=n and time<t+tires[i][0]; j++){\\n                best[j] = min(best[j],sum);\\n                time *= tires[i][1];\\n                sum += time;\\n                maxLaps = max(maxLaps, j);\\n            }\\n        }\\n        vector <long long> dp(n+1,-1);\\n        return (int)fun(n,t,dp,best);\\n    }\\nprotected:\\n    long long fun(int n, int t, vector<long long>&dp,vector<long long>&best){\\n        if(n==0) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        long long ans = best[n];\\n\\t\\t// i<=maxLaps, coz beyond that, we will have to switch to a new tire, or else our time will increase for no good reason\\n        for(int i = 1; i<=n and i<=maxLaps; i++)\\n            ans = min(ans,best[i]+t+fun(n-i,t,dp,best));\\n        return dp[n] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nSimplest example :\\n\\t\\t\\t\\t\\t\\t\\t\\t t1    t2\\n  \\t\\t\\t\\t\\ttires[] : [[2,10],[3,3]]\\n\\t\\t\\tNow, for 1st lap, \\n\\t\\t\\t\\t\\tt1 will take 2 seconds, and t2 will finish in 3\\n\\t\\t\\tSo, greedy says, \"lets pick up t1!\", \\n\\t\\t\\tthen for 2nd lap, \\n\\t\\t\\t\\t\\tt1 takes 2*10 = 20 seconds, and t2 takes 3*3 = 9 seconds\\n\\t\\t\\tWell, here we see that cumulative time taken by t1 for 2 laps is 2+20 = 22 seconds\\n\\t\\t\\twhile for t2, it is 3+9 = 12 seconds\\n```\n```\\nclass Solution {\\npublic:\\n    int maxLaps = 0; // So that we dont have to iterate for all n laps but for those which can be \\n                     // travelled without changing tire\\n    int minimumFinishTime(vector<vector<int>>& tires, int t, int n) {\\n        vector <long long> best(n+1,INT_MAX);\\n        for(int i = 0; i<tires.size(); i++){\\n            long long time = tires[i][0], sum = tires[i][0];\\n            // loop for laps\\n            for(int j = 1; j<=n and time<t+tires[i][0]; j++){\\n                best[j] = min(best[j],sum);\\n                time *= tires[i][1];\\n                sum += time;\\n                maxLaps = max(maxLaps, j);\\n            }\\n        }\\n        vector <long long> dp(n+1,-1);\\n        return (int)fun(n,t,dp,best);\\n    }\\nprotected:\\n    long long fun(int n, int t, vector<long long>&dp,vector<long long>&best){\\n        if(n==0) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        long long ans = best[n];\\n\\t\\t// i<=maxLaps, coz beyond that, we will have to switch to a new tire, or else our time will increase for no good reason\\n        for(int i = 1; i<=n and i<=maxLaps; i++)\\n            ans = min(ans,best[i]+t+fun(n-i,t,dp,best));\\n        return dp[n] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811110,
                "title": "dp-with-preprocessing",
                "content": "### Intuition\\nRun solve(laps) recursively. But since the number of tires is large, we will get LTE. We can solve the issue by filtering out bad tires before dp. Bad tires are those tires have big f and r at the same time.\\n\\n### Steps\\n1. Remove bad tires by sorting and a for loop. For example, [(1,5), ~~(2, 6)~~, (2, 3)]\\n2. Run brute force DP.\\n\\n### Time complexity\\nO(mn) where m is num of loops and n is number if tires\\n\\n```\\nimport functools\\n\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n\\n        tires.sort()\\n        cur_min_r = float(\\'inf\\')\\n\\n        f_tires = []\\n        for f, r in tires:\\n            if r < cur_min_r:\\n                f_tires.append((f, r))\\n                cur_min_r = r\\n        tires = f_tires\\n\\n        @functools.cache\\n        def solve(laps):\\n            ans = float(\\'inf\\')\\n            for f, r in tires:\\n                cost = 0\\n                for x in range(1, 16):\\n                    if x > laps:\\n                        break\\n                    cost += f * r ** (x - 1)\\n                    if laps == x:\\n                        ans = min(ans, cost)\\n                    else:\\n                        ans = min(ans, cost + changeTime + solve(laps - x))\\n            return ans\\n\\n        return solve(numLaps)\\n```\\n                \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nimport functools\\n\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n\\n        tires.sort()\\n        cur_min_r = float(\\'inf\\')\\n\\n        f_tires = []\\n        for f, r in tires:\\n            if r < cur_min_r:\\n                f_tires.append((f, r))\\n                cur_min_r = r\\n        tires = f_tires\\n\\n        @functools.cache\\n        def solve(laps):\\n            ans = float(\\'inf\\')\\n            for f, r in tires:\\n                cost = 0\\n                for x in range(1, 16):\\n                    if x > laps:\\n                        break\\n                    cost += f * r ** (x - 1)\\n                    if laps == x:\\n                        ans = min(ans, cost)\\n                    else:\\n                        ans = min(ans, cost + changeTime + solve(laps - x))\\n            return ans\\n\\n        return solve(numLaps)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802997,
                "title": "c-n-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<int>dp(numLaps, INT_MAX);\\n        int mx = 0;\\n        for (int i = 0; i < tires.size(); i++) {\\n            int curr = 0, p = 0;\\n            while (curr < changeTime && p < dp.size()) {\\n                curr += tires[i][0] * pow(tires[i][1], p);\\n                dp[p] = min(dp[p], curr + changeTime);\\n                p++;\\n            }\\n            mx = max(mx, p);\\n        }\\n        for (int i = 1; i < dp.size(); i++)\\n            for (int j = 0; j < min(mx, i); j++)\\n                dp[i] = min(dp[i], dp[j] + dp[i - j - 1]);\\n        return dp.back() - changeTime;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<int>dp(numLaps, INT_MAX);\\n        int mx = 0;\\n        for (int i = 0; i < tires.size(); i++) {\\n            int curr = 0, p = 0;\\n            while (curr < changeTime && p < dp.size()) {\\n                curr += tires[i][0] * pow(tires[i][1], p);\\n                dp[p] = min(dp[p], curr + changeTime);\\n                p++;\\n            }\\n            mx = max(mx, p);\\n        }\\n        for (int i = 1; i < dp.size(); i++)\\n            for (int j = 0; j < min(mx, i); j++)\\n                dp[i] = min(dp[i], dp[j] + dp[i - j - 1]);\\n        return dp.back() - changeTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802937,
                "title": "javascript-dp-440ms",
                "content": "```\\nconst MAX = Number.MAX_SAFE_INTEGER;\\nconst minimumFinishTime = (tires, changeTime, numLaps) => {\\n    let min = Array(20).fill(MAX), dp = Array(numLaps + 1).fill(MAX);\\n    min[0] = 0;\\n    for (const [f, r] of tires) {\\n        let sum = 0;\\n        for (let i = 1; i < 20; i++) {\\n            sum += f * r ** (i - 1);\\n            min[i] = Math.min(min[i], sum);\\n            if (sum > 1e6) break;\\n        }\\n    }\\n    dp[0] = 0;\\n    for (let i = 1; i <= numLaps; i++) {\\n        for (let j = 1; j < 20; j++) {\\n            if (i >= j) dp[i] = Math.min(dp[i], dp[i - j] + min[j] + changeTime);\\n        }\\n    }\\n    return dp[numLaps] - changeTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst MAX = Number.MAX_SAFE_INTEGER;\\nconst minimumFinishTime = (tires, changeTime, numLaps) => {\\n    let min = Array(20).fill(MAX), dp = Array(numLaps + 1).fill(MAX);\\n    min[0] = 0;\\n    for (const [f, r] of tires) {\\n        let sum = 0;\\n        for (let i = 1; i < 20; i++) {\\n            sum += f * r ** (i - 1);\\n            min[i] = Math.min(min[i], sum);\\n            if (sum > 1e6) break;\\n        }\\n    }\\n    dp[0] = 0;\\n    for (let i = 1; i <= numLaps; i++) {\\n        for (let j = 1; j < 20; j++) {\\n            if (i >= j) dp[i] = Math.min(dp[i], dp[i - j] + min[j] + changeTime);\\n        }\\n    }\\n    return dp[numLaps] - changeTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802738,
                "title": "easy-conversion-to-dp",
                "content": "Here we have simplfied the given inputs so that we can code faster .\\n\\nfor simplicity number of laps is  = nl ,\\nchange time is = ct.\\nand time till particular lap i is = adj[i].\\nand instead of writing total everytime we have changed it to sum for recursion.\\n\\n``` \\nclass Solution {\\npublic:\\n    int adj[1001];   // minimum  time to complete i laps is adj[i] \\n    long long dp[1001][1001];\\n    int minimumFinishTime(vector<vector<int>>& tires, int ct, int nl) {\\n        int n=tires.size();\\n        memset(dp,-1,sizeof(dp));\\n        adj[0]=0;\\n        for(int i=1;i<=nl;i++){\\n            adj[i]=INT_MAX;\\n        }\\n   \\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int  totalTime=ct, time=tires[i][0];\\n            while(j<nl&&(time)<(ct+tires[i][0])){\\n                 totalTime+=time;\\n                j++;\\n                adj[j]=min(adj[j],totalTime);\\n                time = time*(long long)tires[i][1];\\n            }\\n        }\\n        \\n        return rec(nl,nl)-ct;\\n    }\\n    \\n     long long rec(int i,int sum){        // sum means totalTime from here\\n         if(sum==0) return 0;\\n         if(i<=0||sum<0) return INT_MAX; \\n         if(dp[i][sum]!=-1) return dp[i][sum];\\n         if(adj[i]==INT_MAX) return dp[i][sum]=rec(i-1,sum);\\n         long long ans=INT_MAX;\\n         ans=min(ans,adj[i]+rec(i-1,sum-i));\\n          ans=min(ans,adj[i]+rec(i,sum-i));\\n          ans=min(ans,rec(i-1,sum));\\n         return dp[i][sum]=ans;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int adj[1001];   // minimum  time to complete i laps is adj[i] \\n    long long dp[1001][1001];\\n    int minimumFinishTime(vector<vector<int>>& tires, int ct, int nl) {\\n        int n=tires.size();\\n        memset(dp,-1,sizeof(dp));\\n        adj[0]=0;\\n        for(int i=1;i<=nl;i++){\\n            adj[i]=INT_MAX;\\n        }\\n   \\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int  totalTime=ct, time=tires[i][0];\\n            while(j<nl&&(time)<(ct+tires[i][0])){\\n                 totalTime+=time;\\n                j++;\\n                adj[j]=min(adj[j],totalTime);\\n                time = time*(long long)tires[i][1];\\n            }\\n        }\\n        \\n        return rec(nl,nl)-ct;\\n    }\\n    \\n     long long rec(int i,int sum){        // sum means totalTime from here\\n         if(sum==0) return 0;\\n         if(i<=0||sum<0) return INT_MAX; \\n         if(dp[i][sum]!=-1) return dp[i][sum];\\n         if(adj[i]==INT_MAX) return dp[i][sum]=rec(i-1,sum);\\n         long long ans=INT_MAX;\\n         ans=min(ans,adj[i]+rec(i-1,sum-i));\\n          ans=min(ans,adj[i]+rec(i,sum-i));\\n          ans=min(ans,rec(i-1,sum));\\n         return dp[i][sum]=ans;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869921,
                "title": "java-after-2-days-simplest-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        \\n        int n = tires.length; \\n        if(numLaps==0) return 0; \\n        int min[] = new int[numLaps+1]; \\n\\n        Arrays.fill(min, Integer.MAX_VALUE); \\n\\n        for(int i=0;i<n;i++){\\n            int base = tires[i][0];\\n            int curr = tires[i][0];\\n            int factor = tires[i][1];\\n            int lap = 1; \\n            int sum = curr; \\n            while(curr<changeTime + base && lap<=numLaps)\\n                {\\n                min[lap] = Math.min(min[lap], sum);\\n                curr = curr*factor;\\n                sum+=curr;\\n                lap++;\\n                }\\n        }\\n        //System.out.println(Arrays.toString(min));\\n        for(int lap = 1; lap<=numLaps;lap++){\\n            int curr = min[lap]; \\n\\n            for(int j=lap-1;j>=1;j--){\\n                curr = Math.min(curr, min[j] + min[lap-j] + changeTime); \\n            }\\n            min[lap] = Math.min(min[lap], curr);\\n        }\\n        //System.out.println(Arrays.toString(min));\\n        return min[numLaps];\\n    }\\n\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        \\n        int n = tires.length; \\n        if(numLaps==0) return 0; \\n        int min[] = new int[numLaps+1]; \\n\\n        Arrays.fill(min, Integer.MAX_VALUE); \\n\\n        for(int i=0;i<n;i++){\\n            int base = tires[i][0];\\n            int curr = tires[i][0];\\n            int factor = tires[i][1];\\n            int lap = 1; \\n            int sum = curr; \\n            while(curr<changeTime + base && lap<=numLaps)\\n                {\\n                min[lap] = Math.min(min[lap], sum);\\n                curr = curr*factor;\\n                sum+=curr;\\n                lap++;\\n                }\\n        }\\n        //System.out.println(Arrays.toString(min));\\n        for(int lap = 1; lap<=numLaps;lap++){\\n            int curr = min[lap]; \\n\\n            for(int j=lap-1;j>=1;j--){\\n                curr = Math.min(curr, min[j] + min[lap-j] + changeTime); \\n            }\\n            min[lap] = Math.min(min[lap], curr);\\n        }\\n        //System.out.println(Arrays.toString(min));\\n        return min[numLaps];\\n    }\\n\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503626,
                "title": "c-explained-fully-with-comments-dp-precomputation-clean-code",
                "content": "```\\n#define ll long long \\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> we have to fill  the dp array , pre calculations\\n    \\n    // we having dp array of size NumLaps\\n    \\n    // we can take any of the tires any no of times , but  taking changetime\\n    \\n    // we change to a new tyre.\\n    \\n    // Now startingly in say we are at 4th lap , dp[4] will store the minimum \\n    \\n    // time to cover 4 laps \\n    \\n    // we will precompute to the do the consecutive k - laps of each types of tyres\\n    \\n    // it will help in finding , if some tyres working very good i.e taking \\n    \\n    // very less time till k - consecutive laps (k can be 2 to atmost 19)\\n    \\n    // as 2^19 is greater than 10^6 which is greater than max value of change time.\\n    \\n    int minimumFinishTime(vector<vector<int>>& tires, int changetime, int numlaps) {\\n        \\n        vector<vector<ll>> precompute(tires.size()+1 , vector<ll>(20 , 1e9));\\n        \\n        for(int i=0;i<tires.size();i++)\\n        {\\n            precompute[i][0]=tires[i][0];\\n            \\n            for(int j=1;j<=19;j++)\\n            {\\n                ll val=precompute[i][j-1]*tires[i][1];\\n                \\n                if(val>1e9)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    precompute[i][j]=val;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=19;i++)\\n        {\\n             for(int j=0;j<tires.size();j++)\\n             {\\n                 precompute[j][i]+=precompute[j][i-1];\\n                 \\n                 // this is  the value of time = precompute[i][j] -> ith tasks having \\n                 \\n                 // consecutive (j+1)th no. of times \\n             }\\n        }\\n        \\n        vector<ll> dp( numlaps+1 , INT_MAX);\\n        \\n        dp[0]=0;\\n        \\n        for(int i=1;i<=numlaps;i++)\\n        {\\n            if(i<20)\\n            {   // check with the i- consecutive laps with the jth tyre.\\n                for(int j=0;j<tires.size();j++)\\n                dp[i]=min(dp[i] , precompute[j][i-1]);\\n                // ( we had stored ith consecutive laps value in precompute[j][i-1])\\n            }\\n            \\n            // we suppose we are at 8th lap , \\n            \\n            // Possibilty is we had drive till 7th lap , 1 lap by new one.\\n            \\n            //   drive till 6th lap , changed , 2 lap with new tire\\n            \\n            // drive till 5th lap , 3 lap with new tire \\n            \\n            // drive till 4th lap , 4 lap with new one \\n            \\n            // drivw till 3rd lap , 5 lap with new one ( now here things are started\\n            \\n            // to reapaet  so we will be having till lap 4 ).\\n            \\n            for(int j=i-1 ; j>=(i/2) ; j--)\\n            {\\n                dp[i]=min(dp[i] , dp[j] + dp[i-j] + changetime);\\n            }\\n        }\\n        \\n        return dp[numlaps];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long \\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> we have to fill  the dp array , pre calculations\\n    \\n    // we having dp array of size NumLaps\\n    \\n    // we can take any of the tires any no of times , but  taking changetime\\n    \\n    // we change to a new tyre.\\n    \\n    // Now startingly in say we are at 4th lap , dp[4] will store the minimum \\n    \\n    // time to cover 4 laps \\n    \\n    // we will precompute to the do the consecutive k - laps of each types of tyres\\n    \\n    // it will help in finding , if some tyres working very good i.e taking \\n    \\n    // very less time till k - consecutive laps (k can be 2 to atmost 19)\\n    \\n    // as 2^19 is greater than 10^6 which is greater than max value of change time.\\n    \\n    int minimumFinishTime(vector<vector<int>>& tires, int changetime, int numlaps) {\\n        \\n        vector<vector<ll>> precompute(tires.size()+1 , vector<ll>(20 , 1e9));\\n        \\n        for(int i=0;i<tires.size();i++)\\n        {\\n            precompute[i][0]=tires[i][0];\\n            \\n            for(int j=1;j<=19;j++)\\n            {\\n                ll val=precompute[i][j-1]*tires[i][1];\\n                \\n                if(val>1e9)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    precompute[i][j]=val;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=19;i++)\\n        {\\n             for(int j=0;j<tires.size();j++)\\n             {\\n                 precompute[j][i]+=precompute[j][i-1];\\n                 \\n                 // this is  the value of time = precompute[i][j] -> ith tasks having \\n                 \\n                 // consecutive (j+1)th no. of times \\n             }\\n        }\\n        \\n        vector<ll> dp( numlaps+1 , INT_MAX);\\n        \\n        dp[0]=0;\\n        \\n        for(int i=1;i<=numlaps;i++)\\n        {\\n            if(i<20)\\n            {   // check with the i- consecutive laps with the jth tyre.\\n                for(int j=0;j<tires.size();j++)\\n                dp[i]=min(dp[i] , precompute[j][i-1]);\\n                // ( we had stored ith consecutive laps value in precompute[j][i-1])\\n            }\\n            \\n            // we suppose we are at 8th lap , \\n            \\n            // Possibilty is we had drive till 7th lap , 1 lap by new one.\\n            \\n            //   drive till 6th lap , changed , 2 lap with new tire\\n            \\n            // drive till 5th lap , 3 lap with new tire \\n            \\n            // drive till 4th lap , 4 lap with new one \\n            \\n            // drivw till 3rd lap , 5 lap with new one ( now here things are started\\n            \\n            // to reapaet  so we will be having till lap 4 ).\\n            \\n            for(int j=i-1 ; j>=(i/2) ; j--)\\n            {\\n                dp[i]=min(dp[i] , dp[j] + dp[i-j] + changetime);\\n            }\\n        }\\n        \\n        return dp[numlaps];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465179,
                "title": "python-memoize-don-t-consider-tires-that-have-both-f-and-r-greater-than-another-tire",
                "content": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\n        # Only minimal tires (such that there is no other tire having *both* lesser f and r) matter\\n               \\n        tires.sort(key=lambda z: (z[0], -z[1]))\\n        x = []\\n        min_r = inf\\n        for t in tires:\\n            if t[1] < min_r:\\n                x.append(t)\\n                min_r = t[1]\\n         \\n        tires = x\\n        \\n \\n        @cache\\n        def one_tire_run(tire, nlaps):          \\n            f, r = tires[tire]\\n            if nlaps == 1:\\n                return f\\n            return f + r*one_tire_run(tire, nlaps-1)\\n\\n        \\n        @cache\\n        def min_time(ntires, nlaps):\\n            mt = inf\\n\\n            if ntires > 1:\\n                mt = min(mt, min_time(ntires - 1, nlaps))\\n            \\n            for i in range(1, nlaps):\\n                x = one_tire_run(ntires-1, i) + changeTime\\n                if mt <= x:\\n                    break\\n                mt = min(mt, x + min_time(ntires, nlaps - i))\\n            \\n            mt = min(mt, one_tire_run(ntires-1, nlaps))\\n                    \\n            return mt\\n\\n        return min_time(len(tires), numLaps)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\n        # Only minimal tires (such that there is no other tire having *both* lesser f and r) matter\\n               \\n        tires.sort(key=lambda z: (z[0], -z[1]))\\n        x = []\\n        min_r = inf\\n        for t in tires:\\n            if t[1] < min_r:\\n                x.append(t)\\n                min_r = t[1]\\n         \\n        tires = x\\n        \\n \\n        @cache\\n        def one_tire_run(tire, nlaps):          \\n            f, r = tires[tire]\\n            if nlaps == 1:\\n                return f\\n            return f + r*one_tire_run(tire, nlaps-1)\\n\\n        \\n        @cache\\n        def min_time(ntires, nlaps):\\n            mt = inf\\n\\n            if ntires > 1:\\n                mt = min(mt, min_time(ntires - 1, nlaps))\\n            \\n            for i in range(1, nlaps):\\n                x = one_tire_run(ntires-1, i) + changeTime\\n                if mt <= x:\\n                    break\\n                mt = min(mt, x + min_time(ntires, nlaps - i))\\n            \\n            mt = min(mt, one_tire_run(ntires-1, nlaps))\\n                    \\n            return mt\\n\\n        return min_time(len(tires), numLaps)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437646,
                "title": "c-well-commented-easy-to-understand-dp",
                "content": "Upon seeing the question, we know that it is DP but it takes quit some time to figure out how to define our dp and what to store in it and things like that. The idea i got is, in dp[i] we store the answer for i laps, then to find dp[i], since we already know all the values below i, suppose we change our tires after 1 lap, then the candidate value for answer is dp[1]+changeTime+dp[i-1], if we do it after 2, then dp[2]+changeTime+dp[i-2], and more generally if we change it after j<i laps, then dp[j]+changeTime+dp[i-j]. But there\\'s another thing, what if we don\\'t change it at all? huh? interesting right!! then we need to know the minimum time for a single tyre to make i laps straightly without pit stop. But if we try to find it for every i, then it will lead to TLE because laps are 1000 and tires are 1e5 => total = 1e8 which is big. \\n\\t\\t\\n\\tSo what we do is we precompute everything before hand. \\n        \\nin a map of {int, set} we store for every x, what is the minimum time required to make x laps with each tyre. So to find this, we traverse the tyres first and for each tyre, we will find how many laps it can do and for some xth lap, what is the minimum time, then we store that time in the set by inserting in mp[x]. We limit our lap count x here by seeing the constraints given in the question. ideally there should be no limit, but here when I meant some limit, I mean, if we go more laps than that, if won\\'t contribute to the solution. \\n\\nBecause the worst case solution for any i laps is 1e8( max(fi)*numLaps) secs (from the constraints). So I will stop my while loop whenever I figure out that if I do this lap, then I exceed that threshold time, then It is as good as not doing it. \\n        \\nThe while loop is fast because it will only take logarithmic time to figure out that x. \\n\\n\\n```\\nlong long int power(long long int x, long long int y)\\n{\\n    if(y==0) return 1;\\n    if(y%2==0)\\n    {\\n        long long int val = power(x, y/2);\\n        return val*val;\\n    }\\n    else\\n    {\\n        long long int val = power(x, (y-1)/2);\\n        return val*val*x;\\n    }\\n}\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        \\n        long long int n = tires.size();\\n        unordered_map<long long int,set<long long int>>mp;\\n        for(long long int i=0;i<n;i++)\\n        {\\n            long long int fi = tires[i][0];\\n            long long int ri = tires[i][1];\\n            long long int x =1;\\n            while(1)\\n            {\\n                long long int val = (fi*(power(ri,x)-1))/(ri-1);\\n                if(val>1e10) break;\\n                mp[x].insert(val);\\n                x++;\\n            }\\n        }\\n        vector<long long int>dp(numLaps+1);\\n        for(long long int i=1;i<=numLaps;i++)\\n        {\\n            long long int mini = LLONG_MAX;\\n            for(long long int j=1;j<i;j++)\\n            {\\n                mini = min({mini, dp[j]+changeTime+dp[i-j]});\\n            }\\n            // if we don\\'t stop even once also\\n            if(mp.find(i)!=mp.end())\\n            {\\n                long long int val = *mp[i].begin();\\n                mini = min(mini, val);\\n            }\\n            dp[i]=mini;\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n```\\n\\n**Please Upvote if you found it helpful**",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\nlong long int power(long long int x, long long int y)\\n{\\n    if(y==0) return 1;\\n    if(y%2==0)\\n    {\\n        long long int val = power(x, y/2);\\n        return val*val;\\n    }\\n    else\\n    {\\n        long long int val = power(x, (y-1)/2);\\n        return val*val*x;\\n    }\\n}\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        \\n        long long int n = tires.size();\\n        unordered_map<long long int,set<long long int>>mp;\\n        for(long long int i=0;i<n;i++)\\n        {\\n            long long int fi = tires[i][0];\\n            long long int ri = tires[i][1];\\n            long long int x =1;\\n            while(1)\\n            {\\n                long long int val = (fi*(power(ri,x)-1))/(ri-1);\\n                if(val>1e10) break;\\n                mp[x].insert(val);\\n                x++;\\n            }\\n        }\\n        vector<long long int>dp(numLaps+1);\\n        for(long long int i=1;i<=numLaps;i++)\\n        {\\n            long long int mini = LLONG_MAX;\\n            for(long long int j=1;j<i;j++)\\n            {\\n                mini = min({mini, dp[j]+changeTime+dp[i-j]});\\n            }\\n            // if we don\\'t stop even once also\\n            if(mp.find(i)!=mp.end())\\n            {\\n                long long int val = *mp[i].begin();\\n                mini = min(mini, val);\\n            }\\n            dp[i]=mini;\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365344,
                "title": "java-very-easy-to-understand-no-more-trick-like-or-manually-set-power",
                "content": "The dp transition function is simple dp[i] = Math.min (dp[i], dp[j] + changeTime + dp[i - j]) 0 < j < i; The key problem is when we calcualte the minTime with single tire, it will overflow if not stopped. So we set boundary curTime < base + changeTime\\n```\\nclass Solution {\\n    int changeTime;\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        this.changeTime = changeTime;\\n        int[] minTime = new int[numLaps + 1];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        \\n        for (int[] tire :  tires){\\n            populateMinTime(tire, minTime);\\n        }\\n        \\n        int[] dp = new int[numLaps + 1];\\n        for (int i = 1; i <= numLaps; i++){\\n            dp[i] = minTime[i]; // maxValue for dp[i] is Integer.MAX_VALUE, no need to worry about overflow\\n            for (int j = 1; j < i; j++){\\n                dp[i] = Math.min(dp[i], dp[j] + changeTime + dp[i - j]);  // it will never overflow, since dp[j] are far less than Integer.MAX_VALUE\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n    \\n    private void populateMinTime(int[] tire, int[] minTime){\\n        int sum = 0;\\n        int base = tire[0];\\n        int ex = tire[1];\\n        int spent = 1;\\n        for (int i = 1; i < minTime.length; i++){\\n            spent = (i == 1) ? base : spent * ex;\\n            if (spent > changeTime + base){break;} // set boundary\\n            sum += spent;\\n            minTime[i] = Math.min(minTime[i], sum);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int changeTime;\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        this.changeTime = changeTime;\\n        int[] minTime = new int[numLaps + 1];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        \\n        for (int[] tire :  tires){\\n            populateMinTime(tire, minTime);\\n        }\\n        \\n        int[] dp = new int[numLaps + 1];\\n        for (int i = 1; i <= numLaps; i++){\\n            dp[i] = minTime[i]; // maxValue for dp[i] is Integer.MAX_VALUE, no need to worry about overflow\\n            for (int j = 1; j < i; j++){\\n                dp[i] = Math.min(dp[i], dp[j] + changeTime + dp[i - j]);  // it will never overflow, since dp[j] are far less than Integer.MAX_VALUE\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n    \\n    private void populateMinTime(int[] tire, int[] minTime){\\n        int sum = 0;\\n        int base = tire[0];\\n        int ex = tire[1];\\n        int spent = 1;\\n        for (int i = 1; i < minTime.length; i++){\\n            spent = (i == 1) ? base : spent * ex;\\n            if (spent > changeTime + base){break;} // set boundary\\n            sum += spent;\\n            minTime[i] = Math.min(minTime[i], sum);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270232,
                "title": "java-dp-2-codes-o-1-space",
                "content": "we have to precompute some info and then it is DP\\n\\nFirst of all, it is never optimal for a tire to be used for more than 20 laps, so we precompute the best time for the `i` consecutive laps.\\nOnce we have that info, we can solve it either with a `dp[n]` or `dp[20]`. Here I am presenting both.\\n\\nI came up with the `dp[20]` way first because it is a bit more intuitive, but `dp[n]` is a bit easier to code. Both have the same time complexity and get AC in 20ms. \\n\\n#### Solution 1: Space O(n)\\nFor each index `i`, consider from index `i-1 ... i-20` as the starting point, and we change tires at `i`. \\nThen we have `dp[i] = min(dp[i], cost[j]+dp[i-j-1]+changeTime)`\\nWe will always include `changeTime` one extra time at the end, so subtract it.\\n```Java\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int[] cost = new int[20];\\n        int INF = (int)1e9;\\n        Arrays.fill(cost, INF);\\n        for (int[] t : tires){\\n            for (int i = 0,sum=t[0],cur=t[0]; i < 20; i++,cur*=t[1],sum+=cur){\\n                cost[i] = Math.min(cost[i], sum);\\n                if (sum+1L*cur*t[1]>= 1e6){\\n                    break;\\n                }\\n            }\\n        }\\n        int[] dp = new int[numLaps];\\n        Arrays.fill(dp, INF);\\n        for (int i = 0; i < numLaps; i++){\\n            for (int j = 0; j <= Math.min(i,19); j++){\\n                dp[i]=Math.min(dp[i], (j==i?0:dp[i-j-1])+cost[j]+changeTime);\\n            }\\n        }\\n        return dp[numLaps-1]-changeTime;\\n    }\\n}\\n```\\n#### Solution 2: Space O(1)\\nLet `dp[i]` be the number of consecutive `i` laps thus far. \\nThen we have: `next[i] = dp[i-1] - cost[i-1] + cost[i]` and `next[0] = min(next[0], dp[j]+changeTime+cost[0])`.\\nNo need to compensate for the extra changeTime like solution 1, but we will have to loop through all the consesctive laps (max at 20) and return the min of it.\\n```Java\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int[] cost = new int[20];\\n        int INF = (int)1e9;\\n        Arrays.fill(cost, INF);\\n        for (int[] t : tires){\\n            for (int i = 0,sum=t[0],cur=t[0]; i < 20; i++,cur*=t[1],sum+=cur){\\n                cost[i] = Math.min(cost[i], sum);\\n                if (sum+1L*cur*t[1]>= 1e6){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int[] dp = new int[20];\\n        Arrays.fill(dp, INF);\\n        dp[0]=cost[0];\\n        for (int i = 1 ; i < numLaps; i++){\\n            int tmp = dp[0];\\n            dp[0]=INF;\\n            for (int j = 19; j >= 0; j--){\\n                dp[0]=Math.min((j==0?tmp:dp[j])+changeTime+cost[0], dp[0]);\\n                // next[0]=Math.min(dp[j]+changeTime+cost[0], next[0]);\\n                if (j>0){\\n                    dp[j]=(j==1?tmp:dp[j-1])-cost[j-1]+cost[j];\\n                    // next[j]=dp[j-1]-cost[j-1]+cost[j];\\n                }\\n            }\\n            // dp=next;\\n        }\\n        return Arrays.stream(dp).min().getAsInt();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int[] cost = new int[20];\\n        int INF = (int)1e9;\\n        Arrays.fill(cost, INF);\\n        for (int[] t : tires){\\n            for (int i = 0,sum=t[0],cur=t[0]; i < 20; i++,cur*=t[1],sum+=cur){\\n                cost[i] = Math.min(cost[i], sum);\\n                if (sum+1L*cur*t[1]>= 1e6){\\n                    break;\\n                }\\n            }\\n        }\\n        int[] dp = new int[numLaps];\\n        Arrays.fill(dp, INF);\\n        for (int i = 0; i < numLaps; i++){\\n            for (int j = 0; j <= Math.min(i,19); j++){\\n                dp[i]=Math.min(dp[i], (j==i?0:dp[i-j-1])+cost[j]+changeTime);\\n            }\\n        }\\n        return dp[numLaps-1]-changeTime;\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int[] cost = new int[20];\\n        int INF = (int)1e9;\\n        Arrays.fill(cost, INF);\\n        for (int[] t : tires){\\n            for (int i = 0,sum=t[0],cur=t[0]; i < 20; i++,cur*=t[1],sum+=cur){\\n                cost[i] = Math.min(cost[i], sum);\\n                if (sum+1L*cur*t[1]>= 1e6){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int[] dp = new int[20];\\n        Arrays.fill(dp, INF);\\n        dp[0]=cost[0];\\n        for (int i = 1 ; i < numLaps; i++){\\n            int tmp = dp[0];\\n            dp[0]=INF;\\n            for (int j = 19; j >= 0; j--){\\n                dp[0]=Math.min((j==0?tmp:dp[j])+changeTime+cost[0], dp[0]);\\n                // next[0]=Math.min(dp[j]+changeTime+cost[0], next[0]);\\n                if (j>0){\\n                    dp[j]=(j==1?tmp:dp[j-1])-cost[j-1]+cost[j];\\n                    // next[j]=dp[j-1]-cost[j-1]+cost[j];\\n                }\\n            }\\n            // dp=next;\\n        }\\n        return Arrays.stream(dp).min().getAsInt();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826654,
                "title": "c-solution-using-provided-hint",
                "content": "```\\nclass Solution {\\npublic:\\n  int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n    int minF = -1;\\n    for (int i = 0; i < tires.size(); ++i) {\\n      if (minF == -1) {\\n        minF = tires[i][0];\\n      } else {\\n        minF = min(minF, tires[i][0]);\\n      }\\n    }\\n    \\n    // If the time taken by the tire is more than ub, don\\'t use it any further\\n    int ub = minF + changeTime;\\n    \\n    // The minimum time to complete laps without tire change\\n    vector<int> minTimeNoChange(numLaps + 1, -1);\\n    // Has to be minF for laps = 1\\n    minTimeNoChange[1] = minF;\\n    for (int i = 0; i < tires.size(); ++i) {\\n      // Find the number of laps after which time for lap is >= ub\\n      int f = tires[i][0], r= tires[i][1];\\n      int maxLaps = 1.0 + (double)(log((double)ub / f) / log(r));\\n      if (maxLaps <= 1) continue;\\n      \\n      // Populate minTimeNoChange for these many laps\\n      for (int laps = 1; laps <= min(maxLaps, numLaps); ++laps) {\\n        int timeWithTire = (f * (double)(pow(r, laps) - 1)) / (r - 1);\\n        if (minTimeNoChange[laps] == -1) {\\n          minTimeNoChange[laps] = timeWithTire;\\n        }\\n        minTimeNoChange[laps] = min(timeWithTire, minTimeNoChange[laps]);\\n      }\\n    }\\n    \\n    vector<int> minTime(numLaps + 1, -1);\\n    for (int laps = 1; laps <= numLaps; ++laps) {\\n      if (minTimeNoChange[laps] != -1) {\\n        minTime[laps] = minTimeNoChange[laps];\\n      }\\n      for (int l = 1; l < laps; ++l) {\\n        if (minTimeNoChange[l] != -1) {\\n          if (minTime[laps] == -1) {\\n            minTime[laps] = minTimeNoChange[l] + changeTime + minTime[laps - l];\\n          } else {\\n            minTime[laps] = min(minTime[laps],\\n                                minTimeNoChange[l] + changeTime + minTime[laps - l]);\\n          }\\n        }\\n      }\\n    }\\n    return minTime[numLaps];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n    int minF = -1;\\n    for (int i = 0; i < tires.size(); ++i) {\\n      if (minF == -1) {\\n        minF = tires[i][0];\\n      } else {\\n        minF = min(minF, tires[i][0]);\\n      }\\n    }\\n    \\n    // If the time taken by the tire is more than ub, don\\'t use it any further\\n    int ub = minF + changeTime;\\n    \\n    // The minimum time to complete laps without tire change\\n    vector<int> minTimeNoChange(numLaps + 1, -1);\\n    // Has to be minF for laps = 1\\n    minTimeNoChange[1] = minF;\\n    for (int i = 0; i < tires.size(); ++i) {\\n      // Find the number of laps after which time for lap is >= ub\\n      int f = tires[i][0], r= tires[i][1];\\n      int maxLaps = 1.0 + (double)(log((double)ub / f) / log(r));\\n      if (maxLaps <= 1) continue;\\n      \\n      // Populate minTimeNoChange for these many laps\\n      for (int laps = 1; laps <= min(maxLaps, numLaps); ++laps) {\\n        int timeWithTire = (f * (double)(pow(r, laps) - 1)) / (r - 1);\\n        if (minTimeNoChange[laps] == -1) {\\n          minTimeNoChange[laps] = timeWithTire;\\n        }\\n        minTimeNoChange[laps] = min(timeWithTire, minTimeNoChange[laps]);\\n      }\\n    }\\n    \\n    vector<int> minTime(numLaps + 1, -1);\\n    for (int laps = 1; laps <= numLaps; ++laps) {\\n      if (minTimeNoChange[laps] != -1) {\\n        minTime[laps] = minTimeNoChange[laps];\\n      }\\n      for (int l = 1; l < laps; ++l) {\\n        if (minTimeNoChange[l] != -1) {\\n          if (minTime[laps] == -1) {\\n            minTime[laps] = minTimeNoChange[l] + changeTime + minTime[laps - l];\\n          } else {\\n            minTime[laps] = min(minTime[laps],\\n                                minTimeNoChange[l] + changeTime + minTime[laps - l]);\\n          }\\n        }\\n      }\\n    }\\n    return minTime[numLaps];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812967,
                "title": "c-dp-solution-89-29-90-36",
                "content": "class Solution {\\npublic:\\n\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<long long> fast(numLaps+1); // fast[i] = fastest time to finish i laps\\n        for(int i=1;i<=numLaps;i+=1) // init\\n        {\\n            fast[i]=2147483647;\\n        }\\n        for(int i=0;i<tires.size();i+=1)\\n        {\\n            long long now=tires[i][0];\\n            long long cal=now;\\n            for(int j=1;j<=numLaps;j++)\\n            {\\n                fast[j]=min(fast[j],cal);\\n                now*=tires[i][1];\\n                cal+=now;\\n                if(cal>2147483647) break;\\n            }\\n        }\\n        long long ans=2147483647;\\n        for(int i=1;i<=numLaps;i+=1)\\n        {\\n            for(int j=1;j<=i/2;j+=1)\\n            {\\n                fast[i]=min(fast[i],fast[i-j]+fast[j]+changeTime);\\n            }\\n        }\\n        return fast[numLaps];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<long long> fast(numLaps+1); // fast[i] = fastest time to finish i laps\\n        for(int i=1;i<=numLaps;i+=1) // init\\n        {\\n            fast[i]=2147483647;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1806169,
                "title": "c-easy-to-understand-solution-dynamic-programming",
                "content": "The main intuition behind this question is that the maximum laps that you can take without changing the tire can be 18 (with tire [1,2] ). So firstly I stored the time taken for 18 laps with each tire without changing. Then I found the minimum time from them for all 18 laps, stored them in minn_without_changing. \\n\\nFor Dp part \\n  dp[i]= min(dp[i],dp[j]+change+dp[i-j])\\n    where j goes from 1 to i-1;\\ndp[i] is minimum time required for completing i laps.\\n\\nIntuition for applying dp comes from repeated recursive nature of the question.\\n\\nA little tricky part of the question is the integer overflow constraint which you have to consider carefully. But this is a really nice question to understand them if you are new to them.\\n\\n\\n```\\n#define ll long long int\\nconst int N=1000000000;\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        int n=tires.size();\\n        vector<vector<int>>without_change(n,vector<int>(19,0));\\n        for(int i=0;i<n;i++)\\n        {\\n           for(int j=1;j<=18;j++)\\n           {\\n               if(j==1)\\n               {\\n                   without_change[i][j]=tires[i][0];\\n               }\\n               else\\n               {\\n                   if((ll)without_change[i][j-1]*tires[i][1]<=N)\\n                   {\\n                       without_change[i][j]=without_change[i][j-1]*tires[i][1];\\n                   }\\n                   else\\n                   {\\n                       without_change[i][j]=INT_MAX;\\n                   }\\n               }\\n           }\\n        }\\n        for(int i=0;i<n;i++)     //accumulating \\n        {\\n            for(int j=1;j<19;j++)\\n            {\\n                if((ll)without_change[i][j]+without_change[i][j-1]<=N)\\n                   without_change[i][j]+=without_change[i][j-1];\\n                else\\n                    without_change[i][j]=INT_MAX;\\n            }\\n        }\\n        vector<int>minn_without_change(19,INT_MAX);\\n        for(int j=1;j<=18;j++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n            minn_without_change[j]=min(minn_without_change[j],without_change[i][j]);\\n            }\\n        }\\n        vector<int>dp(numLaps+1,INT_MAX);\\n        dp[1]=minn_without_change[1];\\n        for(int i=2;i<=numLaps;i++)\\n        {\\n            for(int j=1;j<i;j++)\\n            {\\n                dp[i]=min(dp[j]+changeTime+dp[i-j],dp[i]);\\n                \\n            }\\n            if(i<=18)\\n            {\\n                dp[i]=min(dp[i],minn_without_change[i]);\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        int n=tires.size();\\n        vector<vector<int>>without_change(n,vector<int>(19,0));\\n        for(int i=0;i<n;i++)\\n        {\\n           for(int j=1;j<=18;j++)\\n           {\\n               if(j==1)\\n               {\\n                   without_change[i][j]=tires[i][0];\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1805820,
                "title": "c-dp-clean-and-concise",
                "content": "```\\nclass Solution {\\n    int best[1001];\\nprivate:\\n    int recur(int n,int changeTime,int maxLaps,vector<int>&dp)\\n    {\\n        if(n==0)\\n            return -changeTime;\\n        \\n        if(dp[n]!=-1)\\n            return dp[n];\\n        long long int mini=INT_MAX;\\n        for(int laps=1;laps<=min(n,maxLaps);laps++)\\n        {\\n           long long  time=best[laps]+changeTime+recur(n-laps,changeTime,maxLaps,dp);\\n            mini=min(mini,time);\\n        }\\n        return dp[n]= mini;\\n    }\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        \\n        int i,j;\\n        for(i=0;i<=1000;i++)\\n            best[i]=INT_MAX;\\n        vector<int>dp(numLaps+100,-1);\\n        \\n        int maxLaps=0;\\n        for(auto i:tires)\\n        {\\n            int fi=i[0];\\n            int ri=i[1];\\n            int time=fi;\\n            long long int currLapTime=time;\\n           \\n            for(int lap=1;lap<=numLaps and currLapTime<changeTime+fi;lap++)\\n            {\\n                if(time<best[lap])\\n                    best[lap]=time;\\n                currLapTime*=ri;\\n                \\n                time+=currLapTime;\\n                \\n                maxLaps=max(maxLaps,lap);\\n                \\n            }\\n           \\n            \\n        }\\n        // for(j=1;j<=2;j++)\\n        //     cout<<best[j]<<\" \";\\n        \\n        return recur(numLaps,changeTime,maxLaps,dp);\\n        \\n        \\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int best[1001];\\nprivate:\\n    int recur(int n,int changeTime,int maxLaps,vector<int>&dp)\\n    {\\n        if(n==0)\\n            return -changeTime;\\n        \\n        if(dp[n]!=-1)\\n            return dp[n];\\n        long long int mini=INT_MAX;\\n        for(int laps=1;laps<=min(n,maxLaps);laps++)\\n        {\\n           long long  time=best[laps]+changeTime+recur(n-laps,changeTime,maxLaps,dp);\\n            mini=min(mini,time);\\n        }\\n        return dp[n]= mini;\\n    }\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        \\n        int i,j;\\n        for(i=0;i<=1000;i++)\\n            best[i]=INT_MAX;\\n        vector<int>dp(numLaps+100,-1);\\n        \\n        int maxLaps=0;\\n        for(auto i:tires)\\n        {\\n            int fi=i[0];\\n            int ri=i[1];\\n            int time=fi;\\n            long long int currLapTime=time;\\n           \\n            for(int lap=1;lap<=numLaps and currLapTime<changeTime+fi;lap++)\\n            {\\n                if(time<best[lap])\\n                    best[lap]=time;\\n                currLapTime*=ri;\\n                \\n                time+=currLapTime;\\n                \\n                maxLaps=max(maxLaps,lap);\\n                \\n            }\\n           \\n            \\n        }\\n        // for(j=1;j<=2;j++)\\n        //     cout<<best[j]<<\" \";\\n        \\n        return recur(numLaps,changeTime,maxLaps,dp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1804359,
                "title": "what-s-wrong-with-my-recursive-solution",
                "content": "I typically try to approach DP problems by deriving a recursive solution, writing the top-down DP approach, then moving to bottom-up DP. I am trying to figure out what\\'s wrong with my recursive approach, however. Appreciate the help!\\n\\n```python\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        def helper(laps_finished, tire_idx, x):\\n            if laps_finished == numLaps:\\n                return 0\\n            \\n            f, r = tires[tire_idx]\\n            cur_time = f * r ** (x - 1)\\n            \\n            min_time = helper(laps_finished + 1, tire_idx, x + 1)\\n            for idx in range(len(tires)):\\n                min_time = min(min_time, changeTime + helper(laps_finished + 1, tire_idx, 1))\\n            return cur_time + min_time\\n        \\n        res = float(inf)\\n        \\n        for idx in range(len(tires)):\\n            res = min(res, helper(0, idx, 1))\\n            \\n        return res\\n```\\n\\nEDIT: Thanks @tanayk for the help, there was a small bug in the for loop (using tire_idx instead of idx). Corrected code is below:\\n\\n```python\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        def helper(laps_finished, tire_idx, x):\\n            if laps_finished == numLaps:\\n                return 0\\n            \\n            f, r = tires[tire_idx]\\n            cur_time = f * r ** (x - 1)\\n            \\n            min_time = helper(laps_finished + 1, tire_idx, x + 1)\\n            for idx in range(len(tires)):\\n                min_time = min(min_time, changeTime + helper(laps_finished + 1, idx, 1)) # bug was here, used tire_idx instead of idx\\n            return cur_time + min_time\\n        \\n        res = float(inf)\\n        \\n        for idx in range(len(tires)):\\n            res = min(res, helper(0, idx, 1))\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        def helper(laps_finished, tire_idx, x):\\n            if laps_finished == numLaps:\\n                return 0\\n            \\n            f, r = tires[tire_idx]\\n            cur_time = f * r ** (x - 1)\\n            \\n            min_time = helper(laps_finished + 1, tire_idx, x + 1)\\n            for idx in range(len(tires)):\\n                min_time = min(min_time, changeTime + helper(laps_finished + 1, tire_idx, 1))\\n            return cur_time + min_time\\n        \\n        res = float(inf)\\n        \\n        for idx in range(len(tires)):\\n            res = min(res, helper(0, idx, 1))\\n            \\n        return res\\n```\n```python\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        def helper(laps_finished, tire_idx, x):\\n            if laps_finished == numLaps:\\n                return 0\\n            \\n            f, r = tires[tire_idx]\\n            cur_time = f * r ** (x - 1)\\n            \\n            min_time = helper(laps_finished + 1, tire_idx, x + 1)\\n            for idx in range(len(tires)):\\n                min_time = min(min_time, changeTime + helper(laps_finished + 1, idx, 1)) # bug was here, used tire_idx instead of idx\\n            return cur_time + min_time\\n        \\n        res = float(inf)\\n        \\n        for idx in range(len(tires)):\\n            res = min(res, helper(0, idx, 1))\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803033,
                "title": "dynamic-programming-the-laps-you-can-do-it-step-by-step",
                "content": "It is a difficuit problem but may be the easiest to understand in recent contests. \\nBefore any brain work, we can translate the description of the problem as follows:\\n```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int ct, int l) {\\n\\t\\t// states: current tire - id,\\n\\t\\t//         laps on this tire - idl, \\n\\t\\t//         tire param - idp;\\n        // repeat for each lap: \\n        //     change tire:  time = time + ct + tiretime(id_new,0,idp_new);\\n        //     don\\'t change: time = time + tiretime(id,idl+1,idp);\\n\\t\\t//\\n\\t\\t//            dp table filling order\\n\\t\\t//       dp          lap1  lap2  lap3  lap4  ...\\n\\t\\t// no tire switch      \\u2198 \\t \\u2198 \\t   \\u2198 \\t \\u2198\\n\\t\\t//  tire switch1       \\u2198 \\t \\u2198 \\t   \\u2198 \\t \\u2198\\n\\t\\t//  tire switch2       \\u2198 \\t \\u2198 \\t   \\u2198 \\t \\u2198\\n\\t\\t//       ...\\n\\t\\t}\\n```\\nLook at the option of change tire and don\\'t change tire, it matches the dynamic programming pattern. We can go through from lap 0 to lap N, adding the time at each lap and keeps the minimum time at each lap. (Are these patterns remind you of some other problems?) If we have limited tire switching, this method could work. However, if we switch tires at each lap, It takes as many as `tiresize * numLaps` for all tire combinations. Following the description is the easiest way to implement but always fails in medium/hard problem. \\n\\nLuckily, The time taken on the same tire is very predictable if we know the laps, and we do not need to calculate for each lap. We now can change or options as follow:\\n```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int ct, int l) {\\n\\t\\t// states: current tire - id,\\n\\t\\t//         laps on this tire - idl, \\n\\t\\t//         tire param - idp;\\n        // start with l laps, repeat until there is no laps:\\n\\t\\t//    take k laps: \\n        //        use the same tire for k laps: time = time +  tiretime(id,k,idp) + ct;\\n\\t\\t//        where tiretime(id,k,idp) = sumofk(id*idp^(k-1));\\n\\t\\t}\\n```\\n\\nOur choice now is for how many laps we use the same tire. The dynamic programming pattern has changed. Now with a single parameter lap l, our dp[l] represents the minimum cost regardless of how many tires switched. Well it is still dynamic programming because we can use data from dp[1..l-1] to derive dp[l]. This updating rule becomes:\\n\\n```\\ntime = INT_MAX\\nfor k in [1,l-1]:\\n\\ttime = min(time, dp[k] + ct + dp[l-k])\\n// for no tire switching\\ntime = min(time, min_time_noswitch(tire,l));\\n```\\n\\nWith the help of dynamic programming, we have stripped the problem down to a `min_time_noswitch` function. Therefore, the last step is to calculate the minimum timecost when there is no tire switching. \\nThis is a calculation process done before the dynamic programming loop. Note we only need to calculate untill the `ct + tire[i][0]` because the tire timecost increases exponentially, and it becomes necessary to switch tires beyond certain cost level. \\n\\nThe overall code is shown below:\\n```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tire, int ct, int l) {\\n        long long dp[1001] = {0};\\n        // no tire switching\\n        map<int,long long> mp; // pair: numLaps, min time cost to complete lap without tire switching\\n        for(int j = 1; j <= l; j++) mp[j] = LLONG_MAX;\\n        for(int i = 0; i < tire.size(); i++) { // only count up to (ct + tire[i][0])\\n            long long tm = tire[i][0];\\n            long long totm = 0;\\n            int param = tire[i][1];\\n            for(int j = 1; j <= l; j++) {\\n                if(tm <= ct + tire[i][0]) {\\n                    totm += tm;\\n                    mp[j] = min(mp[j], totm);\\n                    tm = tm * param;\\n                }\\n                else break;\\n            }\\n        }\\n\\n        long long time = checktime(ct, l, dp, mp);\\n\\n        return time;\\n    }\\n    \\n    long long checktime(int ct, int k, long long dp[1001], map<int,long long> & mp) {\\n        if(dp[k] != 0) return dp[k];\\n        long long mt = LLONG_MAX;\\n        for(int i = 1; i <= k/2; i++) {\\n            mt = min(mt, checktime(ct, i, dp, mp) + checktime(ct, k-i, dp, mp) + ct);\\n        }\\n        if(mp.find(k) != mp.end()) mt = min(mt, mp[k]);\\n        \\n        dp[k] = mt;\\n        return mt;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int ct, int l) {\\n\\t\\t// states: current tire - id,\\n\\t\\t//         laps on this tire - idl, \\n\\t\\t//         tire param - idp;\\n        // repeat for each lap: \\n        //     change tire:  time = time + ct + tiretime(id_new,0,idp_new);\\n        //     don\\'t change: time = time + tiretime(id,idl+1,idp);\\n\\t\\t//\\n\\t\\t//            dp table filling order\\n\\t\\t//       dp          lap1  lap2  lap3  lap4  ...\\n\\t\\t// no tire switch      \\u2198 \\t \\u2198 \\t   \\u2198 \\t \\u2198\\n\\t\\t//  tire switch1       \\u2198 \\t \\u2198 \\t   \\u2198 \\t \\u2198\\n\\t\\t//  tire switch2       \\u2198 \\t \\u2198 \\t   \\u2198 \\t \\u2198\\n\\t\\t//       ...\\n\\t\\t}\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int ct, int l) {\\n\\t\\t// states: current tire - id,\\n\\t\\t//         laps on this tire - idl, \\n\\t\\t//         tire param - idp;\\n        // start with l laps, repeat until there is no laps:\\n\\t\\t//    take k laps: \\n        //        use the same tire for k laps: time = time +  tiretime(id,k,idp) + ct;\\n\\t\\t//        where tiretime(id,k,idp) = sumofk(id*idp^(k-1));\\n\\t\\t}\\n```\n```\\ntime = INT_MAX\\nfor k in [1,l-1]:\\n\\ttime = min(time, dp[k] + ct + dp[l-k])\\n// for no tire switching\\ntime = min(time, min_time_noswitch(tire,l));\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tire, int ct, int l) {\\n        long long dp[1001] = {0};\\n        // no tire switching\\n        map<int,long long> mp; // pair: numLaps, min time cost to complete lap without tire switching\\n        for(int j = 1; j <= l; j++) mp[j] = LLONG_MAX;\\n        for(int i = 0; i < tire.size(); i++) { // only count up to (ct + tire[i][0])\\n            long long tm = tire[i][0];\\n            long long totm = 0;\\n            int param = tire[i][1];\\n            for(int j = 1; j <= l; j++) {\\n                if(tm <= ct + tire[i][0]) {\\n                    totm += tm;\\n                    mp[j] = min(mp[j], totm);\\n                    tm = tm * param;\\n                }\\n                else break;\\n            }\\n        }\\n\\n        long long time = checktime(ct, l, dp, mp);\\n\\n        return time;\\n    }\\n    \\n    long long checktime(int ct, int k, long long dp[1001], map<int,long long> & mp) {\\n        if(dp[k] != 0) return dp[k];\\n        long long mt = LLONG_MAX;\\n        for(int i = 1; i <= k/2; i++) {\\n            mt = min(mt, checktime(ct, i, dp, mp) + checktime(ct, k-i, dp, mp) + ct);\\n        }\\n        if(mp.find(k) != mp.end()) mt = min(mt, mp[k]);\\n        \\n        dp[k] = mt;\\n        return mt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802815,
                "title": "java-dp-calculate-min-time-per-laps",
                "content": "First, we calculate the miniumum time of consecutive laps.\\nLike, for 1 lap, the min time is? For 2 consecutive laps, the min time is? On and on...\\n\\nIn my code, countPerLaps is the total time for consecutive i laps.\\nFor example, countPerLaps.get(5) is the min time of 1st + 2nd + 3rd + 4th + 5th lap time.\\n\\nThen, this becomes a not hard dp problem. \\n dp[i] = Math.min(dp[i], dp[i - j] + changeTime + countPerLaps.get(j));\\n \\nTotal i laps min time  =  min(self,  total i-j laps time   +   chanegTime   +    j laps min time)\\n\\nWhy is max laps is 17?\\nI\\'m thinking about total laps time > changeTime, so 2^n > 10^5, n = 17.\\nI\\'m not sure or clear about this... \\n\\n```java\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        List<Integer> countPerLaps = new ArrayList<>();\\n        countPerLaps.add(Integer.MAX_VALUE);\\n        for (int[] tire : tires) {\\n            long f = tire[0];\\n            long cur = 0;\\n            for (int i = 1; i < 17; i++) {\\n                cur += f;\\n                if (cur > Integer.MAX_VALUE) {\\n                    break;\\n                }\\n                if (countPerLaps.size() <= i) {\\n                    countPerLaps.add((int) cur);\\n                } else if (countPerLaps.get(i) > cur) {\\n                    countPerLaps.set(i, (int) cur);\\n                }\\n                f *= tire[1];\\n            }\\n        }\\n        int[] dp = new int[numLaps + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        int size = countPerLaps.size();\\n        for (int i = 1; i < numLaps + 1; i++) {\\n            for (int j = 1; j <= i && j < size; j++) {\\n                dp[i] = Math.min(dp[i], dp[i - j] + changeTime + countPerLaps.get(j));\\n            }\\n        }\\n        return dp[numLaps] - changeTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        List<Integer> countPerLaps = new ArrayList<>();\\n        countPerLaps.add(Integer.MAX_VALUE);\\n        for (int[] tire : tires) {\\n            long f = tire[0];\\n            long cur = 0;\\n            for (int i = 1; i < 17; i++) {\\n                cur += f;\\n                if (cur > Integer.MAX_VALUE) {\\n                    break;\\n                }\\n                if (countPerLaps.size() <= i) {\\n                    countPerLaps.add((int) cur);\\n                } else if (countPerLaps.get(i) > cur) {\\n                    countPerLaps.set(i, (int) cur);\\n                }\\n                f *= tire[1];\\n            }\\n        }\\n        int[] dp = new int[numLaps + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        int size = countPerLaps.size();\\n        for (int i = 1; i < numLaps + 1; i++) {\\n            for (int j = 1; j <= i && j < size; j++) {\\n                dp[i] = Math.min(dp[i], dp[i - j] + changeTime + countPerLaps.get(j));\\n            }\\n        }\\n        return dp[numLaps] - changeTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802676,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6f8a2c98f0feab59d2e0ec35f928e3ee1d3e4456) for solutions of weekly 282. \\n\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        init = [inf] * 20\\n        for f, r in tires: \\n            prefix = term = f\\n            for i in range(20): \\n                init[i] = min(init[i], prefix)\\n                term *= r\\n                if term >= f+changeTime: break \\n                prefix += term\\n        \\n        @cache\\n        def fn(n): \\n            \"\"\"Return min time to finish n laps.\"\"\"\\n            ans = init[n-1] if n <= 20 else inf\\n            for nn in range(1, min(20, n//2)+1): \\n                ans = min(ans, fn(nn) + fn(n-nn) + changeTime)\\n            return ans \\n        \\n        return fn(numLaps)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        init = [inf] * 20\\n        for f, r in tires: \\n            prefix = term = f\\n            for i in range(20): \\n                init[i] = min(init[i], prefix)\\n                term *= r\\n                if term >= f+changeTime: break \\n                prefix += term\\n        \\n        @cache\\n        def fn(n): \\n            \"\"\"Return min time to finish n laps.\"\"\"\\n            ans = init[n-1] if n <= 20 else inf\\n            for nn in range(1, min(20, n//2)+1): \\n                ans = min(ans, fn(nn) + fn(n-nn) + changeTime)\\n            return ans \\n        \\n        return fn(numLaps)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802544,
                "title": "python-what-s-wrong-with-my-min-heap-solution",
                "content": "```\\nclass Solution(object):\\n    def minimumFinishTime(self, tires, changeTime, numLaps):\\n        \"\"\"\\n        :type tires: List[List[int]]\\n        :type changeTime: int\\n        :type numLaps: int\\n        :rtype: int\\n        \"\"\"\\n        counter=0\\n        import heapq\\n        data=[]\\n        for i in range(len(tires)):\\n            data.append([tires[i][0],i,0])\\n        laps=0\\n        heapq.heapify(data)\\n        while laps<=numLaps-1:\\n            laps+=1\\n            count,index,lapNumber=heapq.heappop(data)\\n            counter+=count\\n            heapq.heappush(data,[tires[index][0]*pow(tires[index][1],lapNumber+1),index,lapNumber+1])\\n            if laps==numLaps-1: return counter\\n            counter+=changeTime\\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumFinishTime(self, tires, changeTime, numLaps):\\n        \"\"\"\\n        :type tires: List[List[int]]\\n        :type changeTime: int\\n        :type numLaps: int\\n        :rtype: int\\n        \"\"\"\\n        counter=0\\n        import heapq\\n        data=[]\\n        for i in range(len(tires)):\\n            data.append([tires[i][0],i,0])\\n        laps=0\\n        heapq.heapify(data)\\n        while laps<=numLaps-1:\\n            laps+=1\\n            count,index,lapNumber=heapq.heappop(data)\\n            counter+=count\\n            heapq.heappush(data,[tires[index][0]*pow(tires[index][1],lapNumber+1),index,lapNumber+1])\\n            if laps==numLaps-1: return counter\\n            counter+=changeTime\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802442,
                "title": "java-solution-using-bottom-up-dp-with-expalnation-comments-o-m-n",
                "content": "```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        // There can be multiple entries for same tire and without removing the duplicates, it will throw TLE\\n        List<int[]> uniqtires = uniqTires(tires);\\n        \\n        int len = uniqtires.size();\\n        // To keep track of time taken by any given tire for any given lap.\\n        // If we know the time taken in prev lap, we can calcualte the time take in current lap \"x\" by adding fi * Pow(ri, (x-1)) to it\\n        double[] prev = new double[len];\\n        \\n        int[] dp = new int[numLaps];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < numLaps; i++) {\\n            int min = Integer.MAX_VALUE;\\n            \\n            // Get the minimum from the previously calculated laps after paying the extra to change tire.\\n            // eg: for lap 4, you can use time of lap[1] + lap[3] after paying the extra time to change tire\\n            // Or, you can use the time of lap[2] + lap[2] after paying the extra time to change tire\\n            for(int j = i - 1; j >= 0; j--) {\\n                min = Math.min(min, dp[j] + dp[i - j - 1] + changeTime);\\n            }\\n            \\n            // Get the minimum if we use a single tire for all the laps.\\n            double[] curr = new double[len];\\n            for(int j = 0; j < len; j++) {\\n                double time = prev[j] + uniqtires.get(j)[0] * Math.pow(uniqtires.get(j)[1], i);\\n                curr[j] = time;\\n\\n                min = Math.min(min, (int)time);\\n            }\\n            prev = curr;\\n            \\n            dp[i] = min;\\n        }\\n        \\n        return dp[numLaps - 1];\\n    }\\n    \\n    private List<int[]> uniqTires(int[][] tires) {\\n        Arrays.sort(tires, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] != b[0]) {\\n                    return Integer.compare(a[0], b[0]);\\n                }\\n                \\n                return Integer.compare(a[1], b[1]);\\n            }\\n        });\\n        \\n        List<int[]> uniqtires = new ArrayList<>();\\n\\n        for(int i = 0; i < tires.length; ) {\\n            int a = tires[i][0];\\n            int b = tires[i][1];\\n            uniqtires.add(tires[i]);\\n            \\n            while(i < tires.length && a == tires[i][0] && b == tires[i][1]) {\\n                i++;\\n            }\\n        }\\n        \\n        return uniqtires;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        // There can be multiple entries for same tire and without removing the duplicates, it will throw TLE\\n        List<int[]> uniqtires = uniqTires(tires);\\n        \\n        int len = uniqtires.size();\\n        // To keep track of time taken by any given tire for any given lap.\\n        // If we know the time taken in prev lap, we can calcualte the time take in current lap \"x\" by adding fi * Pow(ri, (x-1)) to it\\n        double[] prev = new double[len];\\n        \\n        int[] dp = new int[numLaps];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < numLaps; i++) {\\n            int min = Integer.MAX_VALUE;\\n            \\n            // Get the minimum from the previously calculated laps after paying the extra to change tire.\\n            // eg: for lap 4, you can use time of lap[1] + lap[3] after paying the extra time to change tire\\n            // Or, you can use the time of lap[2] + lap[2] after paying the extra time to change tire\\n            for(int j = i - 1; j >= 0; j--) {\\n                min = Math.min(min, dp[j] + dp[i - j - 1] + changeTime);\\n            }\\n            \\n            // Get the minimum if we use a single tire for all the laps.\\n            double[] curr = new double[len];\\n            for(int j = 0; j < len; j++) {\\n                double time = prev[j] + uniqtires.get(j)[0] * Math.pow(uniqtires.get(j)[1], i);\\n                curr[j] = time;\\n\\n                min = Math.min(min, (int)time);\\n            }\\n            prev = curr;\\n            \\n            dp[i] = min;\\n        }\\n        \\n        return dp[numLaps - 1];\\n    }\\n    \\n    private List<int[]> uniqTires(int[][] tires) {\\n        Arrays.sort(tires, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] != b[0]) {\\n                    return Integer.compare(a[0], b[0]);\\n                }\\n                \\n                return Integer.compare(a[1], b[1]);\\n            }\\n        });\\n        \\n        List<int[]> uniqtires = new ArrayList<>();\\n\\n        for(int i = 0; i < tires.length; ) {\\n            int a = tires[i][0];\\n            int b = tires[i][1];\\n            uniqtires.add(tires[i]);\\n            \\n            while(i < tires.length && a == tires[i][0] && b == tires[i][1]) {\\n                i++;\\n            }\\n        }\\n        \\n        return uniqtires;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020170,
                "title": "beat-100-submissions",
                "content": "# Intuition\\nProprocessing for reduce the computation, and then do a simple DP. \\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        def filter_tires():\\n            min_r, out = float(\\'inf\\'), []\\n            for f, r in sorted(tires):\\n                if r >= min_r:\\n                    continue\\n                out.append([f, r])\\n                min_r = r\\n            return out\\n\\n        tires = filter_tires()\\n        m = len(tires)\\n        done = [False] * m\\n        sum_times = [0] * m\\n        prev_times = [1] * m\\n        round_min_times = {}\\n        for i in range(1, numLaps + 1):\\n            round_min_time = float(\\'inf\\')\\n            for j in range(m):\\n                if done[j]:\\n                    continue\\n                add_time = tires[j][0] * prev_times[j]\\n                if i > 1 and add_time >= round_min_times[1] + changeTime:\\n                    done[j] = True\\n                else:\\n                    sum_times[j] += add_time\\n                    prev_times[j] *= tires[j][1]\\n                    round_min_time = min(round_min_time, sum_times[j])\\n            if round_min_time < float(\\'inf\\'):\\n                round_min_times[i] = round_min_time\\n        dp = [float(\\'inf\\')] * (numLaps + 1)\\n        dp[0] = 0\\n        for i in range(1, numLaps + 1):\\n            for r, t in round_min_times.items():\\n                if r <= i:\\n                    dp[i] = min(dp[i - r] + t + changeTime, dp[i])\\n        return dp[-1] - changeTime\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        def filter_tires():\\n            min_r, out = float(\\'inf\\'), []\\n            for f, r in sorted(tires):\\n                if r >= min_r:\\n                    continue\\n                out.append([f, r])\\n                min_r = r\\n            return out\\n\\n        tires = filter_tires()\\n        m = len(tires)\\n        done = [False] * m\\n        sum_times = [0] * m\\n        prev_times = [1] * m\\n        round_min_times = {}\\n        for i in range(1, numLaps + 1):\\n            round_min_time = float(\\'inf\\')\\n            for j in range(m):\\n                if done[j]:\\n                    continue\\n                add_time = tires[j][0] * prev_times[j]\\n                if i > 1 and add_time >= round_min_times[1] + changeTime:\\n                    done[j] = True\\n                else:\\n                    sum_times[j] += add_time\\n                    prev_times[j] *= tires[j][1]\\n                    round_min_time = min(round_min_time, sum_times[j])\\n            if round_min_time < float(\\'inf\\'):\\n                round_min_times[i] = round_min_time\\n        dp = [float(\\'inf\\')] * (numLaps + 1)\\n        dp[0] = 0\\n        for i in range(1, numLaps + 1):\\n            for r, t in round_min_times.items():\\n                if r <= i:\\n                    dp[i] = min(dp[i - r] + t + changeTime, dp[i])\\n        return dp[-1] - changeTime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914937,
                "title": "js-a-detailed-explanation-for-a-great-problem-o-nlogn",
                "content": "# Intuition\\nAt my first glance, this problem involves **exponentiation** (<code>fi * ri<sup>(x-1)</sup></code>), moreover, the minimum value for `ri` is `2`, which means the result may grow dramatically fast *(fact #1)*. However, there is no **\"modulo <code>10<sup>9</sup> + 7</code>\"** in the description, which suggests the result may not outgrow max safe integers for most programming language *(fact 2)*.\\nEven though this observation can easily be proved formally, isn\\'t it a great step to move forward? As now we have **2 clues for the price of one**, we can take advantage of these facts.\\n\\n# Approach\\nLet\\'s define an array `dp`, in which `dp[i]` represents the minimum time to finish `i+1` laps *(the `+1` is to save 4 bytes of memory, what have I done to myself ;-; )*.\\n\\n## Step 1: Find a heuristic upper bound for all dp[i]\\nLet\\'s completely ignore the \"combo boost\" when using the same tire in multiple lap. Suppose we change tire every single lap, then of course, we would **always** choose the tire with the **least f[i]**. Therefore, our upper bound would simply be: $$dp[i] = min(f[*]) * (i+1) + changeTime * i$$, or in the code:\\n```js\\n  const dp = Array(numLaps).fill(0);\\n  \\n  dp[0] = 1e9;\\n  for (let i = 0; i < n; i++) dp[0] = Math.min(dp[0], tires[i][0])\\n\\n  let minInc = dp[0] + changeTime;\\n  for (let i = 1; i < numLaps; i++) dp[i] = dp[i - 1] + minInc;\\n```\\nIt\\'s a bit different for optimization purpose, but the overall ideas remain.\\nAfter this step, we have also proved that the answer would not exceed $$10^9$$ as there always exists at least one solution that is lower than that threshold.\\nAnother nice observation is by this strategy, the min addition time it takes to finish 1 more lap is `minInc = min(f[*]) + changeTime`\\n\\n## Step 2: Try optimizing dp by using the same tire in multiple successive lap\\nTry using each tire multiple times.\\nWe only interested in the additional time for every one new lap, which is, given in the description, <code>fi * ri<sup>(x-1)</sup></code>.\\nNotice that this additional time would keep increasing everytime a new lap is added. When it **surpasses the `minInc`**, there is no point to continue adding more laps as we can just change tire to get better result. \\nHow long for an additional time to surpass `minInc`, in average? It\\'s simply $$log_r(minInc / f)$$. We only have to keep in mind that this step only requires logarithmic time for each tire.\\nThe code:\\n```jsx\\n  for (let i = 0; i < n; i++) {\\n    let inc = tires[i][0];\\n    let sum = inc;\\n    \\n    for (let k = 1; k < numLaps; k++) {\\n      inc *= tires[i][1];\\n      if (inc >= minInc) break;\\n\\n      sum += inc;  \\n      if (sum < dp[k]) {\\n        dp[k] = sum;\\n        maxK = Math.max(maxK, k);\\n      }\\n    }\\n  }\\n```\\nNow, we introduced a new variable `maxK` to indicate the longest successive lap can be optimally done using a single tire.\\n\\n## Step 3: Finding optimal DP\\nIn the step 2, we have only handled the case in which we are only using 1 tire. We will now allow changing tires!\\nTo evaluate `dp[i]`, assuming every `dp[j]` with $$0 <= j < i$$ is **optimal**, if we try changing tire after finishing `j+1` laps, the optimal time for this strategy would be $$dp[j] + dp[i-j-1] + changeTime$$.\\nNote that we don\\'t have to iterate `j`\\'s that are below `i - maxK - 1`. As the maximum number of successive laps is `maxK`, if `j < i - maxK - 1`, then there exists `x > j`, so that we can try changing tire at `x` and still get the optimal result.\\nThe code:\\n```jsx\\n  for (let i = 1; i < numLaps; i++) {\\n    for (let j = Math.max(0, i - maxK - 1); j < i; j++) {\\n      dp[i] = Math.min(dp[i], dp[j] + dp[i - j - 1] + changeTime)\\n    }\\n  }\\n```\\n\\n# Complexity\\n- let `m = min(f[i])`\\n- Time complexity: $$O(n*log(changeTime + m))$$\\n- Space complexity: $$O(numLaps)$$\\n\\n# Code\\n```jsx\\n/**\\n * @param {number[][]} tires\\n * @param {number} changeTime\\n * @param {number} numLaps\\n * @return {number}\\n */\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {\\n  const n = tires.length;\\n  const dp = Array(numLaps).fill(0);\\n  \\n  dp[0] = 1e9;\\n  for (let i = 0; i < n; i++) dp[0] = Math.min(dp[0], tires[i][0])\\n\\n  let minInc = dp[0] + changeTime;\\n  for (let i = 1; i < numLaps; i++) dp[i] = dp[i - 1] + minInc;\\n  let maxK = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    let inc = tires[i][0];\\n    let sum = inc;\\n    \\n    for (let k = 1; k < numLaps; k++) {\\n      inc *= tires[i][1];\\n      if (inc >= minInc) break;\\n\\n      sum += inc;  \\n      if (sum < dp[k]) {\\n        dp[k] = sum;\\n        maxK = Math.max(maxK, k);\\n      }\\n    }\\n  }\\n\\n  for (let i = 1; i < numLaps; i++) {\\n    for (let j = Math.max(0, i - maxK - 1); j < i; j++) {\\n      dp[i] = Math.min(dp[i], dp[j] + dp[i - j - 1] + changeTime)\\n    }\\n  }\\n\\n  return dp[numLaps - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Number Theory"
                ],
                "code": "```js\\n  const dp = Array(numLaps).fill(0);\\n  \\n  dp[0] = 1e9;\\n  for (let i = 0; i < n; i++) dp[0] = Math.min(dp[0], tires[i][0])\\n\\n  let minInc = dp[0] + changeTime;\\n  for (let i = 1; i < numLaps; i++) dp[i] = dp[i - 1] + minInc;\\n```\n```jsx\\n  for (let i = 0; i < n; i++) {\\n    let inc = tires[i][0];\\n    let sum = inc;\\n    \\n    for (let k = 1; k < numLaps; k++) {\\n      inc *= tires[i][1];\\n      if (inc >= minInc) break;\\n\\n      sum += inc;  \\n      if (sum < dp[k]) {\\n        dp[k] = sum;\\n        maxK = Math.max(maxK, k);\\n      }\\n    }\\n  }\\n```\n```jsx\\n  for (let i = 1; i < numLaps; i++) {\\n    for (let j = Math.max(0, i - maxK - 1); j < i; j++) {\\n      dp[i] = Math.min(dp[i], dp[j] + dp[i - j - 1] + changeTime)\\n    }\\n  }\\n```\n```jsx\\n/**\\n * @param {number[][]} tires\\n * @param {number} changeTime\\n * @param {number} numLaps\\n * @return {number}\\n */\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {\\n  const n = tires.length;\\n  const dp = Array(numLaps).fill(0);\\n  \\n  dp[0] = 1e9;\\n  for (let i = 0; i < n; i++) dp[0] = Math.min(dp[0], tires[i][0])\\n\\n  let minInc = dp[0] + changeTime;\\n  for (let i = 1; i < numLaps; i++) dp[i] = dp[i - 1] + minInc;\\n  let maxK = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    let inc = tires[i][0];\\n    let sum = inc;\\n    \\n    for (let k = 1; k < numLaps; k++) {\\n      inc *= tires[i][1];\\n      if (inc >= minInc) break;\\n\\n      sum += inc;  \\n      if (sum < dp[k]) {\\n        dp[k] = sum;\\n        maxK = Math.max(maxK, k);\\n      }\\n    }\\n  }\\n\\n  for (let i = 1; i < numLaps; i++) {\\n    for (let j = Math.max(0, i - maxK - 1); j < i; j++) {\\n      dp[i] = Math.min(dp[i], dp[j] + dp[i - j - 1] + changeTime)\\n    }\\n  }\\n\\n  return dp[numLaps - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891069,
                "title": "100-faster-java-solution",
                "content": "Here we need to understand only one thing is :- \\nfor xth term time needed a = f*r^(x-1) and for (x+1)th term time needed b = f*r^x. It is not at all useful to go for (x+1)th term if (a-b) > changeTime. So that the thing can be use to make it limited to 20 laps only because least value of x is 2 and 2^20 will integer value. So make a array reach which will store least time to reach x laps by any of the time which can be clearly understood in code then use dfs to traverse for every tire and to reduce time complexity use dp \\n```\\nclass Solution {\\n    int dp[] = new int[1001],reach[] = new int[20],max = 0;\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        for(int row[]:tires){\\n            int a = row[0], b = row[0];\\n            for(int i=1;i<=numLaps && b < row[0]+changeTime; i++) {//least time to reach xth laps\\n                if(reach[i] == 0 || reach[i]>a) reach[i] = a;\\n                max = Math.max(max,i);\\n                b *= row[1];\\n                a = a+b; \\n            }\\n        }\\n        return find(changeTime,numLaps)-changeTime; // simple dfs to calucate least time for numLaps\\n    }\\n    public int find(int time,int laps){\\n        if(laps==0) return 0;\\n        if(dp[laps] != 0) return dp[laps];\\n        int ret = Integer.MAX_VALUE;\\n        for(int i=1;i<=Math.min(laps,max);i++)\\n            ret = Math.min(ret,time + reach[i]+find(time,laps-i));\\n        return dp[laps] = ret;\\n    }\\n}\\n//this code can be optimise futher by giving direct output if numLaps is less than max form reach array\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[] = new int[1001],reach[] = new int[20],max = 0;\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        for(int row[]:tires){\\n            int a = row[0], b = row[0];\\n            for(int i=1;i<=numLaps && b < row[0]+changeTime; i++) {//least time to reach xth laps\\n                if(reach[i] == 0 || reach[i]>a) reach[i] = a;\\n                max = Math.max(max,i);\\n                b *= row[1];\\n                a = a+b; \\n            }\\n        }\\n        return find(changeTime,numLaps)-changeTime; // simple dfs to calucate least time for numLaps\\n    }\\n    public int find(int time,int laps){\\n        if(laps==0) return 0;\\n        if(dp[laps] != 0) return dp[laps];\\n        int ret = Integer.MAX_VALUE;\\n        for(int i=1;i<=Math.min(laps,max);i++)\\n            ret = Math.min(ret,time + reach[i]+find(time,laps-i));\\n        return dp[laps] = ret;\\n    }\\n}\\n//this code can be optimise futher by giving direct output if numLaps is less than max form reach array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701022,
                "title": "beats-97-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires, changeTime, numLaps):\\n        ans = [float(\"inf\")]*20\\n\\n        for f,r in tires:\\n            prefix = val = f\\n            for i in range(20):\\n                ans[i] = min(ans[i],prefix)\\n                val = val*r\\n                if val >= f + changeTime: break\\n                prefix += val\\n\\n        @lru_cache(None)\\n        def dfs(n):\\n            min_val = ans[n-1] if n <= 20 else float(\"inf\")\\n\\n            for j in range(1,min(20,n//2)+1):\\n                min_val = min(min_val,dfs(j) + dfs(n-j) + changeTime)\\n\\n            return min_val \\n\\n        return dfs(numLaps)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires, changeTime, numLaps):\\n        ans = [float(\"inf\")]*20\\n\\n        for f,r in tires:\\n            prefix = val = f\\n            for i in range(20):\\n                ans[i] = min(ans[i],prefix)\\n                val = val*r\\n                if val >= f + changeTime: break\\n                prefix += val\\n\\n        @lru_cache(None)\\n        def dfs(n):\\n            min_val = ans[n-1] if n <= 20 else float(\"inf\")\\n\\n            for j in range(1,min(20,n//2)+1):\\n                min_val = min(min_val,dfs(j) + dfs(n-j) + changeTime)\\n\\n            return min_val \\n\\n        return dfs(numLaps)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627034,
                "title": "dp-with-explanation-rust-runtime-beats-100",
                "content": "# Approach\\nFor a given number of laps `m`, the required time can be found as the minimum of either:\\n- The time needed using only the best available tire for that number of laps\\n- The minimum sum of time required for the two lap numbers `a` and `b` with `a + b == m`, plus one `change_time` \\n\\nWith this approach, iterative dynamic programming can be easily implemented.\\n\\nSpecial care must be taken when calculating the time needed using only one tire. As the exponentially growing time can lead to integer overflow, the exponentiation must be stopped early enough. It can be stopped as soon as the average time of that tire per lap surpasses the upper bound for what the worst possible tire can achieve when changed after every lap ($10^5 \\\\text{ s per lap} + 10^5 \\\\text{ s change time}$).\\n\\n# Complexity\\n- Time complexity:\\n  - $O(\\\\text{tires.len()} * \\\\text{num\\\\_laps} + \\\\text{num\\\\_laps}^2)$ (worst case with many `r_i == 1`)\\n  - $O(\\\\text{tires.len()} + \\\\text{num\\\\_laps}^2)$ (average case, most `r_i > 1`)\\n\\n- Space complexity:\\n$O(\\\\text{num\\\\_laps})$ additional space\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_finish_time(tires: Vec<Vec<i32>>, change_time: i32, num_laps: i32) -> i32 {\\n        let num_laps = num_laps as usize;\\n\\n        let mut dp = vec![1000000000; num_laps + 1]; //dp[i] = fastest time to complete i laps\\n        dp[0] = 0;\\n\\n        for tire in tires.iter() {\\n            //for each tire, calculate the time to finish [0, num_laps] laps without changing tires\\n            //and find the best value for every number of laps\\n            let mut time: i64 = 0;\\n            let mut r: i64 = 1;\\n            for lap in 1..(num_laps + 1) {\\n                time += tire[0] as i64 * r;\\n                if time > 200000 * (1 + lap as i64) {\\n                    //changing tires is faster in any case\\n                    break;\\n                }\\n                dp[lap] = std::cmp::min(dp[lap], time as i32);\\n                r *= tire[1] as i64;\\n            }\\n        }\\n        \\n        for laps in 2..(num_laps + 1) {\\n            let mut best_time = dp[laps];\\n            for x in 1..(laps) {\\n                //change tire after x laps\\n                best_time = std::cmp::min(best_time, dp[x] + dp[laps - x] + change_time);\\n            }\\n            dp[laps] = best_time;\\n        }\\n\\n        dp[num_laps]\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_finish_time(tires: Vec<Vec<i32>>, change_time: i32, num_laps: i32) -> i32 {\\n        let num_laps = num_laps as usize;\\n\\n        let mut dp = vec![1000000000; num_laps + 1]; //dp[i] = fastest time to complete i laps\\n        dp[0] = 0;\\n\\n        for tire in tires.iter() {\\n            //for each tire, calculate the time to finish [0, num_laps] laps without changing tires\\n            //and find the best value for every number of laps\\n            let mut time: i64 = 0;\\n            let mut r: i64 = 1;\\n            for lap in 1..(num_laps + 1) {\\n                time += tire[0] as i64 * r;\\n                if time > 200000 * (1 + lap as i64) {\\n                    //changing tires is faster in any case\\n                    break;\\n                }\\n                dp[lap] = std::cmp::min(dp[lap], time as i32);\\n                r *= tire[1] as i64;\\n            }\\n        }\\n        \\n        for laps in 2..(num_laps + 1) {\\n            let mut best_time = dp[laps];\\n            for x in 1..(laps) {\\n                //change tire after x laps\\n                best_time = std::cmp::min(best_time, dp[x] + dp[laps - x] + change_time);\\n            }\\n            dp[laps] = best_time;\\n        }\\n\\n        dp[num_laps]\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448918,
                "title": "my-solution",
                "content": "```\\n/**\\n * the dp solution is employed.\\n * dp[n] stands for the mimimum time to finish `n` laps,\\n *                  where `n` is from 0 to `numLaps`\\n *\\n * initial:\\n * dp[0] = 0\\n *\\n * induction:\\n * observation 1\\n * assume the min_f is equal to minimum `f` among all tires,\\n * for the `i`\\'th tire, when it\\'s used to finish the `x`\\'th lap,\\n * if f * (r ^ (x - 1)) >= min_f + changeTime,\\n * it\\'s better to change it to finish the `x`\\'th lap.\\n * so for the `x`\\'th lap, if `i`\\'th tire is used,\\n * the following condition should be met\\n * f * (r ^ (x - 1)) < min_f + changeTime\\n * the maximum value of `x`, that is the maximum laps to use a specific tire,\\n * should be ceil(log2((min_f + changeTime) / f) / log2(r))\\n * let max_laps = maximum value of `x`\\n *\\n * observation 2\\n * assume that the `j`\\'s tire is used to finish the `i`\\'th lap,\\n *             and the `j`\\'s tire has been used for `k` laps,\\n *             where `k` is in the range [1, min(max_laps, i)], both inclusive\\n * dp[i] = min(dp[i - k] + mimimum time to finish `k` lap by using a right tire),\\n *         for all `k`\\n *\\n * target:\\n * dp[numLaps]\\n *\\n * Time Complexity: O(max_laps * (n_tires + numLaps))\\n * Space Complexity: O(max_laps + numLaps)\\n * where `n_tires` is the length of the vector `tires`\\n *       `max_laps` is max(ceil(log2((min(f) + changeTime) / f) / log2(r))) for all tires\\n */\\nclass Solution {\\n public:\\n  int minimumFinishTime(const vector<vector<int>> &tires,\\n                        const int changeTime,\\n                        const int numLaps) {\\n    int min_f = numeric_limits<int>::max();\\n    for (const vector<int> &tire : tires) {\\n      min_f = min(min_f, tire.front());\\n    }\\n    int max_laps = 0;\\n    for (const vector<int> &tire : tires) {\\n      const int f = tire.front();\\n      const int r = tire.back();\\n      max_laps = max(max_laps,\\n                     static_cast<int>(ceil((log2((min_f + changeTime) / static_cast<double>(f))) / log2(r))));\\n    }\\n    \\n    const int n_tires = static_cast<int>(tires.size());\\n    long long min_times[max_laps];\\n    fill(min_times, min_times + max_laps, numeric_limits<int>::max());\\n    for (const vector<int> &tire : tires) {\\n      const int f = tire.front();\\n      const int r = tire.back();\\n      long long lap_delta = f;\\n      long long lap_time = f;\\n      for (int lap = 0; lap_delta < min_f + changeTime; ++lap) {\\n        min_times[lap] = min(min_times[lap], lap_time);\\n        lap_delta *= r;\\n        lap_time += lap_delta;\\n      }\\n    }\\n    \\n    long long dp[numLaps + 1];\\n    fill(dp, dp + numLaps + 1, numeric_limits<long long>::max());\\n    dp[0] = -changeTime;\\n    for (int lap = 1; lap < numLaps + 1; ++lap) {\\n      for (int back_lap = 1; back_lap <= min(lap, max_laps); ++back_lap) {\\n        dp[lap] = min(dp[lap], dp[lap - back_lap] + changeTime + min_times[back_lap - 1]);\\n      }\\n    }\\n    return static_cast<int>(dp[numLaps]);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * the dp solution is employed.\\n * dp[n] stands for the mimimum time to finish `n` laps,\\n *                  where `n` is from 0 to `numLaps`\\n *\\n * initial:\\n * dp[0] = 0\\n *\\n * induction:\\n * observation 1\\n * assume the min_f is equal to minimum `f` among all tires,\\n * for the `i`\\'th tire, when it\\'s used to finish the `x`\\'th lap,\\n * if f * (r ^ (x - 1)) >= min_f + changeTime,\\n * it\\'s better to change it to finish the `x`\\'th lap.\\n * so for the `x`\\'th lap, if `i`\\'th tire is used,\\n * the following condition should be met\\n * f * (r ^ (x - 1)) < min_f + changeTime\\n * the maximum value of `x`, that is the maximum laps to use a specific tire,\\n * should be ceil(log2((min_f + changeTime) / f) / log2(r))\\n * let max_laps = maximum value of `x`\\n *\\n * observation 2\\n * assume that the `j`\\'s tire is used to finish the `i`\\'th lap,\\n *             and the `j`\\'s tire has been used for `k` laps,\\n *             where `k` is in the range [1, min(max_laps, i)], both inclusive\\n * dp[i] = min(dp[i - k] + mimimum time to finish `k` lap by using a right tire),\\n *         for all `k`\\n *\\n * target:\\n * dp[numLaps]\\n *\\n * Time Complexity: O(max_laps * (n_tires + numLaps))\\n * Space Complexity: O(max_laps + numLaps)\\n * where `n_tires` is the length of the vector `tires`\\n *       `max_laps` is max(ceil(log2((min(f) + changeTime) / f) / log2(r))) for all tires\\n */\\nclass Solution {\\n public:\\n  int minimumFinishTime(const vector<vector<int>> &tires,\\n                        const int changeTime,\\n                        const int numLaps) {\\n    int min_f = numeric_limits<int>::max();\\n    for (const vector<int> &tire : tires) {\\n      min_f = min(min_f, tire.front());\\n    }\\n    int max_laps = 0;\\n    for (const vector<int> &tire : tires) {\\n      const int f = tire.front();\\n      const int r = tire.back();\\n      max_laps = max(max_laps,\\n                     static_cast<int>(ceil((log2((min_f + changeTime) / static_cast<double>(f))) / log2(r))));\\n    }\\n    \\n    const int n_tires = static_cast<int>(tires.size());\\n    long long min_times[max_laps];\\n    fill(min_times, min_times + max_laps, numeric_limits<int>::max());\\n    for (const vector<int> &tire : tires) {\\n      const int f = tire.front();\\n      const int r = tire.back();\\n      long long lap_delta = f;\\n      long long lap_time = f;\\n      for (int lap = 0; lap_delta < min_f + changeTime; ++lap) {\\n        min_times[lap] = min(min_times[lap], lap_time);\\n        lap_delta *= r;\\n        lap_time += lap_delta;\\n      }\\n    }\\n    \\n    long long dp[numLaps + 1];\\n    fill(dp, dp + numLaps + 1, numeric_limits<long long>::max());\\n    dp[0] = -changeTime;\\n    for (int lap = 1; lap < numLaps + 1; ++lap) {\\n      for (int back_lap = 1; back_lap <= min(lap, max_laps); ++back_lap) {\\n        dp[lap] = min(dp[lap], dp[lap - back_lap] + changeTime + min_times[back_lap - 1]);\\n      }\\n    }\\n    return static_cast<int>(dp[numLaps]);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307274,
                "title": "dp-easy-shit-no-fancy-shit-fk-that",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], ct: int, nl: int) -> int:\\n        cn=[]\\n        dis=[float(\"inf\")]*(nl+1)\\n        for x,y in tires:\\n            cnt=-1\\n            res=0\\n            while x*(pow(y,cnt+1))<ct+x:\\n                cnt+=1\\n                res+=x*(pow(y,cnt))\\n                if cnt+1<=nl:\\n                    dis[cnt+1]=min(dis[cnt+1],res)\\n            cn.append((x,cnt+1,res))\\n        ans=float(\"inf\")\\n        res=[]\\n        dp=[float(\"inf\")]*(nl+1)\\n        dp[0]=0\\n        for i in range(1,nl+1):\\n            if dis[i]!=float(\"inf\"):\\n                res.append((i,dis[i]))\\n                dp[i]=dis[i]\\n        for i in range(nl+1):\\n            for vl,cs in res:\\n                if i+vl<=nl:\\n                    dp[i+vl]=min(dp[i+vl],dp[i]+ct+cs)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], ct: int, nl: int) -> int:\\n        cn=[]\\n        dis=[float(\"inf\")]*(nl+1)\\n        for x,y in tires:\\n            cnt=-1\\n            res=0\\n            while x*(pow(y,cnt+1))<ct+x:\\n                cnt+=1\\n                res+=x*(pow(y,cnt))\\n                if cnt+1<=nl:\\n                    dis[cnt+1]=min(dis[cnt+1],res)\\n            cn.append((x,cnt+1,res))\\n        ans=float(\"inf\")\\n        res=[]\\n        dp=[float(\"inf\")]*(nl+1)\\n        dp[0]=0\\n        for i in range(1,nl+1):\\n            if dis[i]!=float(\"inf\"):\\n                res.append((i,dis[i]))\\n                dp[i]=dis[i]\\n        for i in range(nl+1):\\n            for vl,cs in res:\\n                if i+vl<=nl:\\n                    dp[i+vl]=min(dp[i+vl],dp[i]+ct+cs)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278066,
                "title": "java-with-pre-processing-based-on-input-using-dp-speed-98-31-85-space",
                "content": "Spent more than 3 days understanding the solutions and watching videos on youtube.\\n\\nTakeway: How to break down a complex problem provided some hints are given.\\n\\n\\n# Intuition\\nCentral idea is when to change the tire.\\nWhat data is needed:\\nMax number of laps a tire can be used before the change time + tire[0] is better than the lap time using the same tire.\\nAlso while running the DP what is the max we need to look back in best[] -- optimization\\n\\n# Approach\\npreprocess the best times to run 18 laps for all tires.\\nRun DP and calculate min time for ith lap.\\nCode is commented for thought process and revision in future.\\n\\n# Complexity\\nO(num laps * O(18)) -- for DP\\nO (size of tires * O(18)) for preprocess.\\n\\n- Space complexity:\\nO(18), O(num laps)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n\\n        \\n        int[] best = new int[18];\\n        Arrays.fill(best, Integer.MAX_VALUE);\\n        int maxLapsTireCanBeUsed = 0;\\n\\n        // preprocess\\n        // using each tire fill/update the best times for 18 laps.\\n        for (int[] tire : tires){\\n            int totalTime = tire[0], lapTime = tire[0];\\n            //using a tire update best as far as the time to use the tire is a good option\\n            // than changing the tire by taking change time penality\\n            // we do this only for 18 laps as after 18 laps the changetime penality even for \\n            // a max value of 10^5 + F MAX of 10^5 will be smaller than the lap time if\\n            // the same tire is used\\n            for (int j = 1; j < 18; j++){\\n                best[j] = Math.min(best[j], totalTime);\\n                //update laptime and total time for this lap.\\n                lapTime *= tire[1];\\n                totalTime += lapTime;\\n\\n                maxLapsTireCanBeUsed = Math.max(maxLapsTireCanBeUsed, j);\\n                // if laptime is more than the time to change time + tire[0] .. break.\\n                if (lapTime > changeTime + tire[0])\\n                    break;\\n                \\n            }\\n        }\\n\\n        int[] dp = new int[numLaps+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i <= numLaps; i++){\\n            for (int j = i - 1; j >= 0 && i - j <= maxLapsTireCanBeUsed; j--){\\n                // if (i - j > maxLapsTireCanBeUsed){\\n                //     break;\\n                // }\\n                dp[i] = Math.min(dp[i], dp[j] + changeTime + best[i - j]);\\n            }\\n        }\\n        return dp[numLaps] - changeTime;\\n    }\\n}\\n/*\\nnumber of laps  <= 1000\\nfi  and changetime max can be between 1 .. 10^5\\nri can be between 2 .. 10^5\\nfi+ri*2^(lap# - 1)\\noptions min (changetime + tire[i][0], tire[i][0] + tire[i][1]*2^lap# - 1)\\n\\nfor each tire\\n    for each lap update the best we can get without changing the tire\\n    ex 2-3 , ct - 5\\n    lap 1 - 2 * 3^0, -- 2\\n    lap 2 - min (2 * 3^1, 2+5) -- (6,7) -- 6\\n    lap 3 - 2 * 3^2, 2+5 -- (11, 7) -- 7\\n\\n    ex 3-4 , ct - 5\\n    lap1 - 3 *4^0 = 3 -- 3\\n    lap2 - 3 *4^1 , 3+5 -- (12, 8) -- 8\\n\\n    at the end\\n    best_time for each lap - 2, 6, 7\\n\\n    since changetime max is 100000 and fmax is 100000 -- total cost to change a tire\\n    would be 200000\\n\\n    consider 1 as the min tire[0] and 2 as min for tire[1] to get max laps for a tire\\n    max laps a tire can be used so that change the tire cost/duration is a better option\\n\\n    changetime max + f max < fi * ri^(laps - 1)\\n    2*10^5 < min value of fi can be 1, min value of ri can be 2 hence 1*2^(laps - 1)\\n    log 2 (2000000) ~~ 18\\n\\n    hence after 18 laps it is better to change the tire \\n*/ \\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n\\n        \\n        int[] best = new int[18];\\n        Arrays.fill(best, Integer.MAX_VALUE);\\n        int maxLapsTireCanBeUsed = 0;\\n\\n        // preprocess\\n        // using each tire fill/update the best times for 18 laps.\\n        for (int[] tire : tires){\\n            int totalTime = tire[0], lapTime = tire[0];\\n            //using a tire update best as far as the time to use the tire is a good option\\n            // than changing the tire by taking change time penality\\n            // we do this only for 18 laps as after 18 laps the changetime penality even for \\n            // a max value of 10^5 + F MAX of 10^5 will be smaller than the lap time if\\n            // the same tire is used\\n            for (int j = 1; j < 18; j++){\\n                best[j] = Math.min(best[j], totalTime);\\n                //update laptime and total time for this lap.\\n                lapTime *= tire[1];\\n                totalTime += lapTime;\\n\\n                maxLapsTireCanBeUsed = Math.max(maxLapsTireCanBeUsed, j);\\n                // if laptime is more than the time to change time + tire[0] .. break.\\n                if (lapTime > changeTime + tire[0])\\n                    break;\\n                \\n            }\\n        }\\n\\n        int[] dp = new int[numLaps+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i <= numLaps; i++){\\n            for (int j = i - 1; j >= 0 && i - j <= maxLapsTireCanBeUsed; j--){\\n                // if (i - j > maxLapsTireCanBeUsed){\\n                //     break;\\n                // }\\n                dp[i] = Math.min(dp[i], dp[j] + changeTime + best[i - j]);\\n            }\\n        }\\n        return dp[numLaps] - changeTime;\\n    }\\n}\\n/*\\nnumber of laps  <= 1000\\nfi  and changetime max can be between 1 .. 10^5\\nri can be between 2 .. 10^5\\nfi+ri*2^(lap# - 1)\\noptions min (changetime + tire[i][0], tire[i][0] + tire[i][1]*2^lap# - 1)\\n\\nfor each tire\\n    for each lap update the best we can get without changing the tire\\n    ex 2-3 , ct - 5\\n    lap 1 - 2 * 3^0, -- 2\\n    lap 2 - min (2 * 3^1, 2+5) -- (6,7) -- 6\\n    lap 3 - 2 * 3^2, 2+5 -- (11, 7) -- 7\\n\\n    ex 3-4 , ct - 5\\n    lap1 - 3 *4^0 = 3 -- 3\\n    lap2 - 3 *4^1 , 3+5 -- (12, 8) -- 8\\n\\n    at the end\\n    best_time for each lap - 2, 6, 7\\n\\n    since changetime max is 100000 and fmax is 100000 -- total cost to change a tire\\n    would be 200000\\n\\n    consider 1 as the min tire[0] and 2 as min for tire[1] to get max laps for a tire\\n    max laps a tire can be used so that change the tire cost/duration is a better option\\n\\n    changetime max + f max < fi * ri^(laps - 1)\\n    2*10^5 < min value of fi can be 1, min value of ri can be 2 hence 1*2^(laps - 1)\\n    log 2 (2000000) ~~ 18\\n\\n    hence after 18 laps it is better to change the tire \\n*/ \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266580,
                "title": "minimum-time-to-finish-the-race",
                "content": "# Intuition\\nWe have a lot of tires, but the number of laps is limited to 1,000.\\n\\nWe first compute how long it takes to finish n laps with each tire without changing it.\\n\\nOptimization: it only makes sense to use a tire while the lap time is less than fi + changeTime.\\n\\nWe track the best time to complete i laps, across all tires, in the best array.\\n\\nAfter that, we run DFS, memoising it by the number of laps to race (dp):\\n\\nFor remaining laps, we find the best time by trying to race i laps, change a tire, and recurse on laps - i remaining laps.\\nFor i laps, we pick the best time to finish those laps.\\n\\n# Approach\\nIf we notice that ri >= 2, we can realize that we cannot use a tire for more than 18 laps. Otherwise, the lap time will exceed the change time (100000).\\n\\nThis fact allows us to save on memory for both storing the best lap times, and for the tabulation (as we only need to go up to 19 steps back).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[1001] = {}, best[1001] = {}, max_laps = 0;\\nint dfs(int laps, int changeTime) {\\n    if (laps == 0)\\n        return -changeTime;\\n    if (!dp[laps]) {\\n        dp[laps] = INT_MAX;\\n        for (int i = 1; i <= min(laps, max_laps); ++i)\\n            dp[laps] = min(dp[laps], best[i] + changeTime + dfs(laps - i, changeTime));\\n    }\\n    return dp[laps];\\n}\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        for (auto &t : tires) {\\n        long long lap_time = t[0], time = t[0];\\n        for (int lap = 1; lap <= numLaps && lap_time < t[0] + changeTime; ++lap) {\\n            max_laps = max(max_laps, lap);\\n            if (best[lap] == 0 || best[lap] > time)\\n                best[lap] = time;\\n            lap_time *= t[1];\\n            time += lap_time;\\n        }\\n    }\\n    return dfs(numLaps, changeTime);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[1001] = {}, best[1001] = {}, max_laps = 0;\\nint dfs(int laps, int changeTime) {\\n    if (laps == 0)\\n        return -changeTime;\\n    if (!dp[laps]) {\\n        dp[laps] = INT_MAX;\\n        for (int i = 1; i <= min(laps, max_laps); ++i)\\n            dp[laps] = min(dp[laps], best[i] + changeTime + dfs(laps - i, changeTime));\\n    }\\n    return dp[laps];\\n}\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        for (auto &t : tires) {\\n        long long lap_time = t[0], time = t[0];\\n        for (int lap = 1; lap <= numLaps && lap_time < t[0] + changeTime; ++lap) {\\n            max_laps = max(max_laps, lap);\\n            if (best[lap] == 0 || best[lap] > time)\\n                best[lap] = time;\\n            lap_time *= t[1];\\n            time += lap_time;\\n        }\\n    }\\n    return dfs(numLaps, changeTime);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266543,
                "title": "dp-java-easy-solution-no-any-recursion-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/64b70496-cfc4-4569-8bbf-5b089451fad7_1678152456.31066.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] best, memo;\\n    int numLaps, changeTime, maxLaps=0;\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        this.memo=new int[numLaps];\\n        this.best=new int[numLaps];\\n        this.numLaps=numLaps;\\n        this.changeTime=changeTime;\\n        int minChangeTime=Integer.MAX_VALUE;\\n        for(int[] t: tires) if(t[0]<minChangeTime) minChangeTime=t[0];\\n        minChangeTime+=changeTime;\\n        // Pre-process black vertices\\n        Arrays.fill(best, Integer.MAX_VALUE/2);\\n        for (int i = 0; i < tires.length; i++) {\\n            int lapTime=tires[i][0], totalTime=lapTime;\\n            for (int contLaps=0; contLaps<numLaps && lapTime<(contLaps+1)*minChangeTime; contLaps++) {\\n                if(totalTime<best[contLaps]) best[contLaps]=totalTime;\\n                if(contLaps>maxLaps) maxLaps=contLaps;\\n                lapTime*=tires[i][1];\\n                totalTime+=lapTime;\\n            }\\n        }\\n        \\n        return helper(0)-changeTime;\\n    }\\n\\n    private int helper(int lap) {\\n        if(lap==numLaps) return 0;\\n        if (memo[lap]>0) return memo[lap];\\n        int min = Integer.MAX_VALUE/2;\\n        for (int i=0; i<=maxLaps && i+lap<=numLaps-1; i++) {\\n            min = Math.min(min,best[i]+helper(i+lap+1));\\n        }\\n        min+=changeTime;\\n        return memo[lap] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] best, memo;\\n    int numLaps, changeTime, maxLaps=0;\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        this.memo=new int[numLaps];\\n        this.best=new int[numLaps];\\n        this.numLaps=numLaps;\\n        this.changeTime=changeTime;\\n        int minChangeTime=Integer.MAX_VALUE;\\n        for(int[] t: tires) if(t[0]<minChangeTime) minChangeTime=t[0];\\n        minChangeTime+=changeTime;\\n        // Pre-process black vertices\\n        Arrays.fill(best, Integer.MAX_VALUE/2);\\n        for (int i = 0; i < tires.length; i++) {\\n            int lapTime=tires[i][0], totalTime=lapTime;\\n            for (int contLaps=0; contLaps<numLaps && lapTime<(contLaps+1)*minChangeTime; contLaps++) {\\n                if(totalTime<best[contLaps]) best[contLaps]=totalTime;\\n                if(contLaps>maxLaps) maxLaps=contLaps;\\n                lapTime*=tires[i][1];\\n                totalTime+=lapTime;\\n            }\\n        }\\n        \\n        return helper(0)-changeTime;\\n    }\\n\\n    private int helper(int lap) {\\n        if(lap==numLaps) return 0;\\n        if (memo[lap]>0) return memo[lap];\\n        int min = Integer.MAX_VALUE/2;\\n        for (int i=0; i<=maxLaps && i+lap<=numLaps-1; i++) {\\n            min = Math.min(min,best[i]+helper(i+lap+1));\\n        }\\n        min+=changeTime;\\n        return memo[lap] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247277,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires, changeTime, numLaps):\\n        ans = [float(\"inf\")]*20\\n\\n        for f,r in tires:\\n            prefix = val = f\\n            for i in range(20):\\n                ans[i] = min(ans[i],prefix)\\n                val = val*r\\n                if val >= f + changeTime: break\\n                prefix += val\\n\\n        @lru_cache(None)\\n        def dfs(n):\\n            min_val = ans[n-1] if n <= 20 else float(\"inf\")\\n\\n            for j in range(1,min(20,n//2)+1):\\n                min_val = min(min_val,dfs(j) + dfs(n-j) + changeTime)\\n\\n            return min_val \\n\\n        return dfs(numLaps)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires, changeTime, numLaps):\\n        ans = [float(\"inf\")]*20\\n\\n        for f,r in tires:\\n            prefix = val = f\\n            for i in range(20):\\n                ans[i] = min(ans[i],prefix)\\n                val = val*r\\n                if val >= f + changeTime: break\\n                prefix += val\\n\\n        @lru_cache(None)\\n        def dfs(n):\\n            min_val = ans[n-1] if n <= 20 else float(\"inf\")\\n\\n            for j in range(1,min(20,n//2)+1):\\n                min_val = min(min_val,dfs(j) + dfs(n-j) + changeTime)\\n\\n            return min_val \\n\\n        return dfs(numLaps)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057271,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& T, int c, int n) {\\n        long long dp[1001]{[1 ... 1000]=INT_MAX};\\n        for(auto& e : T) {\\n            for(long long i = 1, cur = e[0], total = cur; c + e[0] > cur; i++) {\\n                if(dp[i] > total) dp[i] = total;\\n                cur *= e[1];\\n                total += cur;\\n            }\\n        }\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j < i; j++) {\\n                dp[i] = min(dp[i], dp[j]+c+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& T, int c, int n) {\\n        long long dp[1001]{[1 ... 1000]=INT_MAX};\\n        for(auto& e : T) {\\n            for(long long i = 1, cur = e[0], total = cur; c + e[0] > cur; i++) {\\n                if(dp[i] > total) dp[i] = total;\\n                cur *= e[1];\\n                total += cur;\\n            }\\n        }\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j < i; j++) {\\n                dp[i] = min(dp[i], dp[j]+c+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047600,
                "title": "easy-python-solution-for-beginners-with-comments",
                "content": "# Intuition\\n\\nSimilar idea to other solutions but I think this version is easier to understand for beginners. \\n\\nFirst, we use Dynamic Programming. Below is the recurrent equation.\\n\\n- `dp[i]` is optimal solution of `numLaps=i+1`\\n- `dp[0] = best time to complete 1 lap without changing tires`\\n- `dp[i] = min(b0, b1, b2, ..., bj)` where `j < i` and `bj = dp[j] + changeTime + best time to complete remaining i-j laps without changing tires`\\n\\nNow we see that we need *\"best time to complete some laps without changing tires*\". This can be easily pre-computed.\\n\\nFurther optimization is explained in-line, but this optimization doesn\\'t change the time complexity.\\n\\n# Complexity\\n- Time complexity\\n max($$O(n^2)$$, $$O(nt)$$) where n is numLaps and t is number of tires\\n\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n\\n        best = [math.inf] * numLaps # best time to complete i+1 lap without changing tires\\n        for f, r in tires:\\n            total_time = 0\\n            lap_time = f\\n            for i in range(numLaps):\\n                if lap_time > f + changeTime:\\n                    break # optimization - if lap_time is longer than changeTime + f, no point to continue with the current tire\\n                total_time += lap_time\\n                best[i] = min(best[i], total_time)\\n                lap_time *= r\\n\\n        dp = [best[0]] # dp[i] = optimal solution of i + 1 th lap\\n        for i in range(1, numLaps):\\n            dpi = best[i]\\n            for j in range(i-1,-1,-1):\\n                if best[i-j-1] == math.inf:\\n                    break\\n                dpi = min(dpi, dp[j] + changeTime + best[i-j-1])\\n            dp.append(dpi)\\n\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n\\n        best = [math.inf] * numLaps # best time to complete i+1 lap without changing tires\\n        for f, r in tires:\\n            total_time = 0\\n            lap_time = f\\n            for i in range(numLaps):\\n                if lap_time > f + changeTime:\\n                    break # optimization - if lap_time is longer than changeTime + f, no point to continue with the current tire\\n                total_time += lap_time\\n                best[i] = min(best[i], total_time)\\n                lap_time *= r\\n\\n        dp = [best[0]] # dp[i] = optimal solution of i + 1 th lap\\n        for i in range(1, numLaps):\\n            dpi = best[i]\\n            for j in range(i-1,-1,-1):\\n                if best[i-j-1] == math.inf:\\n                    break\\n                dpi = min(dpi, dp[j] + changeTime + best[i-j-1])\\n            dp.append(dpi)\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004142,
                "title": "python-comments-easy-dp-to-improved-dp",
                "content": "Solution: find all possible combinations, use DP\\n- state: dp[i] the number of seconds after finish lap i, after changing tire, it is a new start.\\n- policy: dp[i, new_tire] = min(dp[i - j, old_tire] + cost of time from change tire at i-j lap to i lap)\\n- actions: 1. change to tire j after lap i - 1, 0<= j < n; 2. continue with the current tire\\n\\nBrutal Force DP:\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\n        # initialize the dp.\\n        n_tires = len(tires)\\n        dp = [0 for i in range(numLaps+1)]\\n        \\n        # save accumulate tire time: num_tires x laps (can be improved)\\n        tire_time = [[0] * (numLaps + 1) for _ in range(n_tires)]\\n        for t2 in range(n_tires):\\n            f = tires[t2][0]\\n            r = tires[t2][1]\\n            for lap in range(1, numLaps + 1):\\n                tire_time[t2][lap] = tire_time[t2][lap - 1] + f * r ** (lap - 1)\\n        \\n        for i in range(1, numLaps + 1):\\n            dp[i] = float(\\'inf\\')\\n            for j in range(i):\\n                for t2 in range(n_tires):\\n                    time = dp[j] + tire_time[t2][i-j]\\n                    if j > 0:\\n                        time += changeTime\\n                    dp[i] = min(dp[i], time)\\n\\n        return dp[-1]\\n```\\n\\nImprove the algorithm\\n\\nOnly need to consider \\n1. use current tire lap time < changeTiretime, \\n2. max number of laps is 16: 2^16 = 65536 > 10^5 (from problem constraints)\\n\\nnew DP:\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        # initialize the dp. dp[0] = 0\\n        n_tires = len(tires)\\n        dp = [0 for i in range(numLaps+1)]\\n        \\n        # save accumulate tire time: num_tires x laps\\n        min_tire_time = [float(\\'inf\\')] * (numLaps + 1)\\n        \\n        max_lap = min(16, numLaps)\\n        cur_lap = [0] * n_tires\\n        for f, r in tires:\\n            total_lap_time = 0\\n            lap = 1\\n\\t\\t\\t# only consider current tire lap time < changeTiretime\\n            while total_lap_time <= changeTime and lap <= max_lap:\\n                total_lap_time += f * r ** (lap - 1)\\n                # find the best tire\\n                min_tire_time[lap] = min(min_tire_time[lap], total_lap_time)\\n                lap += 1\\n                \\n        for i in range(1, numLaps + 1):\\n            dp[i] = float(\\'inf\\')\\n            for j in range(i-max_lap,i):\\n                time = dp[j] + min_tire_time[i-j]\\n                if j > 0:\\n                    time += changeTime\\n                dp[i] = min(dp[i], time)\\n\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\n        # initialize the dp.\\n        n_tires = len(tires)\\n        dp = [0 for i in range(numLaps+1)]\\n        \\n        # save accumulate tire time: num_tires x laps (can be improved)\\n        tire_time = [[0] * (numLaps + 1) for _ in range(n_tires)]\\n        for t2 in range(n_tires):\\n            f = tires[t2][0]\\n            r = tires[t2][1]\\n            for lap in range(1, numLaps + 1):\\n                tire_time[t2][lap] = tire_time[t2][lap - 1] + f * r ** (lap - 1)\\n        \\n        for i in range(1, numLaps + 1):\\n            dp[i] = float(\\'inf\\')\\n            for j in range(i):\\n                for t2 in range(n_tires):\\n                    time = dp[j] + tire_time[t2][i-j]\\n                    if j > 0:\\n                        time += changeTime\\n                    dp[i] = min(dp[i], time)\\n\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        # initialize the dp. dp[0] = 0\\n        n_tires = len(tires)\\n        dp = [0 for i in range(numLaps+1)]\\n        \\n        # save accumulate tire time: num_tires x laps\\n        min_tire_time = [float(\\'inf\\')] * (numLaps + 1)\\n        \\n        max_lap = min(16, numLaps)\\n        cur_lap = [0] * n_tires\\n        for f, r in tires:\\n            total_lap_time = 0\\n            lap = 1\\n\\t\\t\\t# only consider current tire lap time < changeTiretime\\n            while total_lap_time <= changeTime and lap <= max_lap:\\n                total_lap_time += f * r ** (lap - 1)\\n                # find the best tire\\n                min_tire_time[lap] = min(min_tire_time[lap], total_lap_time)\\n                lap += 1\\n                \\n        for i in range(1, numLaps + 1):\\n            dp[i] = float(\\'inf\\')\\n            for j in range(i-max_lap,i):\\n                time = dp[j] + min_tire_time[i-j]\\n                if j > 0:\\n                    time += changeTime\\n                dp[i] = min(dp[i], time)\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000228,
                "title": "swift-solution-with-comments",
                "content": "```\\nclass Solution {\\n    func minimumFinishTime(_ tires: [[Int]], _ changeTime: Int, _ numLaps: Int) -> Int {\\n        // We will update memo with best minimum time to finish lap corresponding to index known so far. Ultimiately in the end it will be the minimum time.\\n        var memo = Array(repeating: Int.max, count: numLaps + 1)\\n        memo[0] = 0\\n        var maxTireRuntime = 0\\n        // First figure out minimum times we can do for initial laps using same tire (without changing tires)\\n        for tire in tires {\\n            var timeForLap = 0\\n            var multiplier = 1\\n            for lap in 1...numLaps {\\n                let addingTime = tire[0] &* multiplier\\n                if addingTime > tire[0] &+ changeTime {\\n                    break\\n                } \\n                timeForLap &+= addingTime\\n                multiplier &*= tire[1]\\n                if timeForLap < memo[lap] {\\n                    memo[lap] = timeForLap\\n                    maxTireRuntime = max(maxTireRuntime, lap)\\n                }\\n            }\\n        }\\n        /* \\n            Now that we know best times to do certain initial laps without needing to change tires, \\n            rest of the laps can be done by combining these known initial lap times plus the tire\\n            change time. An optimization that is required to beat TLE (at least for Swift) is that for\\n            a given lap we don\\'t have to look at all of previous laps to figure best lap to change the tire,\\n            but we can look back at most maxTireRuntime laps as that\\'s the longest numbers of laps we could choose\\n            to run on a single tire. \\n        */\\n        for lap in 1...numLaps {\\n            for x in max(1, lap &- maxTireRuntime)...lap {\\n                let candidate = memo[x] &+ memo[lap &- x] &+ changeTime\\n                memo[lap] = min(candidate, memo[lap])\\n            }\\n        }\\n        return memo[numLaps]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumFinishTime(_ tires: [[Int]], _ changeTime: Int, _ numLaps: Int) -> Int {\\n        // We will update memo with best minimum time to finish lap corresponding to index known so far. Ultimiately in the end it will be the minimum time.\\n        var memo = Array(repeating: Int.max, count: numLaps + 1)\\n        memo[0] = 0\\n        var maxTireRuntime = 0\\n        // First figure out minimum times we can do for initial laps using same tire (without changing tires)\\n        for tire in tires {\\n            var timeForLap = 0\\n            var multiplier = 1\\n            for lap in 1...numLaps {\\n                let addingTime = tire[0] &* multiplier\\n                if addingTime > tire[0] &+ changeTime {\\n                    break\\n                } \\n                timeForLap &+= addingTime\\n                multiplier &*= tire[1]\\n                if timeForLap < memo[lap] {\\n                    memo[lap] = timeForLap\\n                    maxTireRuntime = max(maxTireRuntime, lap)\\n                }\\n            }\\n        }\\n        /* \\n            Now that we know best times to do certain initial laps without needing to change tires, \\n            rest of the laps can be done by combining these known initial lap times plus the tire\\n            change time. An optimization that is required to beat TLE (at least for Swift) is that for\\n            a given lap we don\\'t have to look at all of previous laps to figure best lap to change the tire,\\n            but we can look back at most maxTireRuntime laps as that\\'s the longest numbers of laps we could choose\\n            to run on a single tire. \\n        */\\n        for lap in 1...numLaps {\\n            for x in max(1, lap &- maxTireRuntime)...lap {\\n                let candidate = memo[x] &+ memo[lap &- x] &+ changeTime\\n                memo[lap] = min(candidate, memo[lap])\\n            }\\n        }\\n        return memo[numLaps]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997078,
                "title": "c-dp-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        // dp[i] = min time to complete i laps \\n        // dp[i] = min(dp[i], dp[j] + changeTime + dp[i - j]) //  0 <= j < i\\n        \\n        // using fi = 1, ri = 2 in 18 laps without change time taken >= 1e5\\n        // hence after 18 continous min, its better to change the tire to minimize time \\n        int numTires = tires.size();\\n        \\n        int64 withoutChange[25][numTires]; \\n        for(int i = 0; i < 25; i++) {\\n            for(int j = 0; j < numTires; j++) {\\n                withoutChange[i][j] = INT_MAX;\\n            }\\n        }\\n        for(int j = 0; j < numTires; j++) { // j = tire using which laps to cover\\n            for(int i = 0; i <= min(numLaps,  20); i++) { // i = no of continuous laps to cover\\n                if(i == 0) {\\n                    withoutChange[i][j] = 0;\\n                } else {\\n                    if(tires[j][0] * pow(tires[j][1], i - 1) >= INT_MAX || withoutChange[i- 1][j] + tires[j][0] * (int64)pow(tires[j][1], i - 1) >= INT_MAX) {\\n                        break;\\n                    }\\n                    withoutChange[i][j] = withoutChange[i - 1][j] + tires[j][0] * (int64)pow(tires[j][1], i - 1);\\n                }\\n            }\\n        }\\n        int64 dp[numLaps + 1];\\n        for(int i = 0; i <= numLaps; i++) {\\n            dp[i] = INT_MAX;\\n        }\\n        dp[0] = 0;\\n        for(int i = 1; i <= numLaps; i++) { // i = currentLap to cover\\n            if(i <= 20) {\\n                for(int k = 0; k < numTires; k++) { // k = tire using which continous laps was done\\n                    dp[i] = min(dp[i], withoutChange[i][k]);\\n                }\\n            }\\n            for(int j = i - 1; j >= max(0, i - 20); j--) { // j = max continuous laps done using a tire\\n                dp[i] = min(dp[i], dp[j] + changeTime + dp[i - j]);\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n\\n\\n\\n\\n----------------------------------------------------------------------\\n\\n// INITIAL THOUGHT PROCESS :\\n\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        // dp[0] = 0\\n        // dp[i] min time to finish i laps\\n        // dp[i] = dp[i - 1] + min time to cover current lapse\\n        // min time to cover current lapse depends on\\n        // tire to be used now, for how long tire already in use\\n        // if new tire then add change time else use formula fi * ri^(x-1)\\n        // states : [i lapse to complete][tire to use for current lapse][how long already in use continuously]\\n        int n = tires.size();\\n        //vector<vector<vector<int>>> dp(numLaps + 1, vector<vector<<int>>>(n, vector<int> (numLaps + 1, INT_MAX)));\\n        long long dp[numLaps + 1][n][numLaps + 1];\\n        for(int i = 0; i <= numLaps; i++) {\\n            for(int j = 0; j < n; j++) {\\n                for(int k = 0; k <= numLaps; k++) {\\n                    dp[i][j][k] = INT_MAX;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            dp[1][i][1] = tires[i][0]; \\n        }\\n\\n        for(int i = 2; i <= numLaps; i++) { // covering each lap one by one, trying to cover ith lap\\n            for(int j = 0; j < n; j++) { // trying each tire for current ith lap\\n                for(int k = 0; k < i; k++) { // tire j is already used for k consecutive laps\\n                    if(k == 0) { // ie new j tire is being used now\\n                        for(int pj = 0; pj < n; pj++) { // tire used in previous lap\\n                            for(int pk = 0; pk < i; pk++) { // consecutive laps usage of prev tire\\n                                if(dp[i - 1][pj][pk] > INT_MAX) continue;\\n                                dp[i][j][1] = min(dp[i][j][1], dp[i - 1][pj][pk] + changeTime + tires[j][0]);\\n                            }\\n                        } \\n                    } else {\\n                        if(dp[i - 1][j][k] > INT_MAX || (tires[j][0] * pow(tires[j][1], k) > INT_MAX)) {\\n                            break;\\n                        }\\n                        dp[i][j][k + 1] = min(dp[i][j][k + 1], dp[i - 1][j][k] + tires[j][0] * (long long)pow(tires[j][1], k));\\n                    }\\n                }\\n            }\\n        }\\n\\n        // for(int i = 1; i <= numLaps; i++) {\\n        //     for(int j = 0; j < n; j++) {\\n        //         for(int k = 0; k <= numLaps; k++) {\\n        //             cout << dp[i][j][k] << \" \";\\n        //         }  \\n        //     }\\n        //     cout << endl;\\n        // }\\n\\n        long long ans = INT_MAX;\\n        for(int j = 0; j < n; j++) {\\n            for(int k = 0; k <= numLaps; k++) {\\n                ans = min(ans, dp[numLaps][j][k]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        // dp[i] = min time to complete i laps \\n        // dp[i] = min(dp[i], dp[j] + changeTime + dp[i - j]) //  0 <= j < i\\n        \\n        // using fi = 1, ri = 2 in 18 laps without change time taken >= 1e5\\n        // hence after 18 continous min, its better to change the tire to minimize time \\n        int numTires = tires.size();\\n        \\n        int64 withoutChange[25][numTires]; \\n        for(int i = 0; i < 25; i++) {\\n            for(int j = 0; j < numTires; j++) {\\n                withoutChange[i][j] = INT_MAX;\\n            }\\n        }\\n        for(int j = 0; j < numTires; j++) { // j = tire using which laps to cover\\n            for(int i = 0; i <= min(numLaps,  20); i++) { // i = no of continuous laps to cover\\n                if(i == 0) {\\n                    withoutChange[i][j] = 0;\\n                } else {\\n                    if(tires[j][0] * pow(tires[j][1], i - 1) >= INT_MAX || withoutChange[i- 1][j] + tires[j][0] * (int64)pow(tires[j][1], i - 1) >= INT_MAX) {\\n                        break;\\n                    }\\n                    withoutChange[i][j] = withoutChange[i - 1][j] + tires[j][0] * (int64)pow(tires[j][1], i - 1);\\n                }\\n            }\\n        }\\n        int64 dp[numLaps + 1];\\n        for(int i = 0; i <= numLaps; i++) {\\n            dp[i] = INT_MAX;\\n        }\\n        dp[0] = 0;\\n        for(int i = 1; i <= numLaps; i++) { // i = currentLap to cover\\n            if(i <= 20) {\\n                for(int k = 0; k < numTires; k++) { // k = tire using which continous laps was done\\n                    dp[i] = min(dp[i], withoutChange[i][k]);\\n                }\\n            }\\n            for(int j = i - 1; j >= max(0, i - 20); j--) { // j = max continuous laps done using a tire\\n                dp[i] = min(dp[i], dp[j] + changeTime + dp[i - j]);\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n\\n\\n\\n\\n----------------------------------------------------------------------\\n\\n// INITIAL THOUGHT PROCESS :\\n\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        // dp[0] = 0\\n        // dp[i] min time to finish i laps\\n        // dp[i] = dp[i - 1] + min time to cover current lapse\\n        // min time to cover current lapse depends on\\n        // tire to be used now, for how long tire already in use\\n        // if new tire then add change time else use formula fi * ri^(x-1)\\n        // states : [i lapse to complete][tire to use for current lapse][how long already in use continuously]\\n        int n = tires.size();\\n        //vector<vector<vector<int>>> dp(numLaps + 1, vector<vector<<int>>>(n, vector<int> (numLaps + 1, INT_MAX)));\\n        long long dp[numLaps + 1][n][numLaps + 1];\\n        for(int i = 0; i <= numLaps; i++) {\\n            for(int j = 0; j < n; j++) {\\n                for(int k = 0; k <= numLaps; k++) {\\n                    dp[i][j][k] = INT_MAX;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            dp[1][i][1] = tires[i][0]; \\n        }\\n\\n        for(int i = 2; i <= numLaps; i++) { // covering each lap one by one, trying to cover ith lap\\n            for(int j = 0; j < n; j++) { // trying each tire for current ith lap\\n                for(int k = 0; k < i; k++) { // tire j is already used for k consecutive laps\\n                    if(k == 0) { // ie new j tire is being used now\\n                        for(int pj = 0; pj < n; pj++) { // tire used in previous lap\\n                            for(int pk = 0; pk < i; pk++) { // consecutive laps usage of prev tire\\n                                if(dp[i - 1][pj][pk] > INT_MAX) continue;\\n                                dp[i][j][1] = min(dp[i][j][1], dp[i - 1][pj][pk] + changeTime + tires[j][0]);\\n                            }\\n                        } \\n                    } else {\\n                        if(dp[i - 1][j][k] > INT_MAX || (tires[j][0] * pow(tires[j][1], k) > INT_MAX)) {\\n                            break;\\n                        }\\n                        dp[i][j][k + 1] = min(dp[i][j][k + 1], dp[i - 1][j][k] + tires[j][0] * (long long)pow(tires[j][1], k));\\n                    }\\n                }\\n            }\\n        }\\n\\n        // for(int i = 1; i <= numLaps; i++) {\\n        //     for(int j = 0; j < n; j++) {\\n        //         for(int k = 0; k <= numLaps; k++) {\\n        //             cout << dp[i][j][k] << \" \";\\n        //         }  \\n        //     }\\n        //     cout << endl;\\n        // }\\n\\n        long long ans = INT_MAX;\\n        for(int j = 0; j < n; j++) {\\n            for(int k = 0; k <= numLaps; k++) {\\n                ans = min(ans, dp[numLaps][j][k]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2974941,
                "title": "dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$$f[i]$$ the minimum time that finish i laps\\nAssume at the j lap, we change the tire, j + 1, j + 2, ... i lap, we use the same tire.\\nIn this way, we will get the state transition.\\n$$f[i] = \\\\underset{j < i}min \\\\{f[j] + \\\\underset{k}min\\\\{cost(k, i - j)\\\\}\\\\} + changeTime$$\\n\\n$$cost(k, i - j)$$ the total time that we use the same tire for i - j laps\\nfor this term, if the duration of using this tire to run one lap is longer than using the new tire same as the old one plus change tire time, why not we change a new tire whose type is same as the old one?\\n$$f * r^{x-1} < changeTime + f$$\\nAccording to the range of input, we could approximately calculate the upper bound of x. $$x\\\\approx 18$$\\n\\nThe answer is $$f[numLaps]-changeTime$$\\nBecause we could begin the game with any tires.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O((n + numLaps)logT_{max})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n + logT_{max})$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<int> best(18, INT_MAX);  \\n        int n = tires.size();\\n        int maxdiff = 0;\\n        for (int i = 0; i < n; ++i) {\\n            long time = tires[i][0], lap = tires[i][0];\\n            for (int j = 1; lap < changeTime + tires[i][0]; ++j) {\\n                best[j] = min(best[j], static_cast<int>(time));\\n                lap *= tires[i][1];\\n                time += lap;\\n                maxdiff = max(maxdiff, j);\\n            }\\n        }\\n\\n        vector<int> f(numLaps + 1, INT_MAX);\\n        f[0] = 0;\\n        for (int i = 1; i <= numLaps; ++i) {\\n            for (int j = i - 1; j >= 0 && i - j <= maxdiff; --j) {\\n                f[i] = min(f[i], f[j] + changeTime + best[i - j]);\\n            }\\n        } \\n        return f[numLaps] - changeTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<int> best(18, INT_MAX);  \\n        int n = tires.size();\\n        int maxdiff = 0;\\n        for (int i = 0; i < n; ++i) {\\n            long time = tires[i][0], lap = tires[i][0];\\n            for (int j = 1; lap < changeTime + tires[i][0]; ++j) {\\n                best[j] = min(best[j], static_cast<int>(time));\\n                lap *= tires[i][1];\\n                time += lap;\\n                maxdiff = max(maxdiff, j);\\n            }\\n        }\\n\\n        vector<int> f(numLaps + 1, INT_MAX);\\n        f[0] = 0;\\n        for (int i = 1; i <= numLaps; ++i) {\\n            for (int j = i - 1; j >= 0 && i - j <= maxdiff; --j) {\\n                f[i] = min(f[i], f[j] + changeTime + best[i - j]);\\n            }\\n        } \\n        return f[numLaps] - changeTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908991,
                "title": "dp-transit-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    transit function:\\n        f(i) = min(f(k) + changeTime + f(i - k)) when k = [1,i)) \\n                 reduce the range of k for the symmetric of k and i-k\\n        f(i) = min(f(i), sum(f * power(r, j) for j in (0, i - 1)) when k == 0 \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(numLap * numLap * numTires)$$ for successivecost calculation\\n$$O(numLap * numLap)$$ for dp\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\'\\'\\'\\n        dp[i] stands for the minimum cost to finishish the number of i laps\\n        f(i) = min(f(k) + changeTime + f(i - k)) when k = [1,i)) \\n        f(i) = min(f(i), sum(f * power(r, j) for j in [0, i - 1]) when k == 0 \\n        \\'\\'\\'\\n\\n        dp = [math.inf] * (numLaps + 1)\\n        n = len(tires)\\n        successivecost = [tires[i][0] for i in range(n)]\\n        for i in range(1, min(numLaps + 1, 20)): #LTE if not constraint with 20\\n            dp[i] = min(successivecost)\\n            for j in range(n):\\n                successivecost[j] = tires[j][0]*((pow(tires[j][1], i + 1) - 1)//(tires[j][1] - 1))\\n\\n\\n        for i in range(2, numLaps + 1):\\n            for k in range(1, min(i , i//2 + 1)):\\n                dp[i] = min(dp[i], dp[k] + changeTime + dp[i-k])\\n        return dp[numLaps]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\'\\'\\'\\n        dp[i] stands for the minimum cost to finishish the number of i laps\\n        f(i) = min(f(k) + changeTime + f(i - k)) when k = [1,i)) \\n        f(i) = min(f(i), sum(f * power(r, j) for j in [0, i - 1]) when k == 0 \\n        \\'\\'\\'\\n\\n        dp = [math.inf] * (numLaps + 1)\\n        n = len(tires)\\n        successivecost = [tires[i][0] for i in range(n)]\\n        for i in range(1, min(numLaps + 1, 20)): #LTE if not constraint with 20\\n            dp[i] = min(successivecost)\\n            for j in range(n):\\n                successivecost[j] = tires[j][0]*((pow(tires[j][1], i + 1) - 1)//(tires[j][1] - 1))\\n\\n\\n        for i in range(2, numLaps + 1):\\n            for k in range(1, min(i , i//2 + 1)):\\n                dp[i] = min(dp[i], dp[k] + changeTime + dp[i-k])\\n        return dp[numLaps]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789269,
                "title": "o-nooflaps-space-o-min-nooflaps-nooftires-time-complexity",
                "content": "# Intuition\\nGet a min minutes for laps using lap times less than(changeTime + min(f)) \\nBecause if fr^n> changeTime+ min_f we can ignore them.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nuse dp for calculating min time for lap n dp[n] = dp[k]+ dp[n-k] \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(min(noOfLaps,noOFtires))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(noOFLaps) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int min  = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>(); \\n        map.put(0,0);\\n        for(int[] i : tires)min = Math.min(min,i[0]);\\n        for(int[] i : tires){\\n            int v = i[0];\\n            int id = 1;\\n            int r = i[1];\\n            int prev =0;\\n            while(v<min+changeTime){\\n                map.put(id,Math.min(map.getOrDefault(id,Integer.MAX_VALUE),v+prev));\\n                id++;\\n                prev +=v;\\n                v=v*r;\\n            }\\n        }\\n        map.put(0,0);\\n        int k = map.size()-1;\\n        int [] dp = new int[numLaps+1];\\n        Arrays.fill(dp,Integer.MAX_VALUE);\\n        for(int i =1;i<dp.length;i++){\\n            if(map.containsKey(i)) dp[i] = map.get(i);\\n            for(int j =i-1;j>0 && j>=i-k;j--){\\n                dp[i] = Math.min(dp[i],changeTime+dp[j]+map.get(i-j));\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int min  = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>(); \\n        map.put(0,0);\\n        for(int[] i : tires)min = Math.min(min,i[0]);\\n        for(int[] i : tires){\\n            int v = i[0];\\n            int id = 1;\\n            int r = i[1];\\n            int prev =0;\\n            while(v<min+changeTime){\\n                map.put(id,Math.min(map.getOrDefault(id,Integer.MAX_VALUE),v+prev));\\n                id++;\\n                prev +=v;\\n                v=v*r;\\n            }\\n        }\\n        map.put(0,0);\\n        int k = map.size()-1;\\n        int [] dp = new int[numLaps+1];\\n        Arrays.fill(dp,Integer.MAX_VALUE);\\n        for(int i =1;i<dp.length;i++){\\n            if(map.containsKey(i)) dp[i] = map.get(i);\\n            for(int j =i-1;j>0 && j>=i-k;j--){\\n                dp[i] = Math.min(dp[i],changeTime+dp[j]+map.get(i-j));\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773099,
                "title": "c-top-down-dp-with-explanation",
                "content": "# Intuition\\nInspired by https://leetcode.com/problems/minimum-time-to-finish-the-race/solutions/1802498/pretreatment-dp/\\n\\nThe intutiton is that every lap your car takes with the same tires, the slower it gets. That means new tires result in best performance, however changing tires takes time. We have to stick with the same tires until it makes sense to switch. We have, however, different sets of tires, which makes our decision process more complex.\\n\\n# Approach\\n\\nWe have to find the best combination of tire re-use and tire replacement that will give us the best finish time. Using DFS with memoization (top-down dynamic programming) we can look at the topmost level what is the best performing streak of reused tires followed by subsequent tire exchanges:\\n```\\nfor(int lp = 1; lp <= Math.Min(maxLap, numLap); lp++)\\n    finLap[numLap] = Math.Min(finLap[numLap], best[lp] + changeTime + DfsFindMinTime(numLap - lp, changeTime));\\n```\\n\"best\" array is pre-computed and will contain the best performing single use tire streak for a certain amount of laps. Note that its computation has an optimization\\n```\\n currTime < fI + changeTime\\n```\\n\\nthat prevents our compuations to go all the way to numLaps if we get to a point where changing tires and starting over makes more sense than keep going with the same tires. That also explains the upper bound of the for loop of the DP method:\\n```\\nMath.Min(maxLap, numLap)\\n```\\n\\nBasically, if there\\'s no tire set that can go all the way to numLaps, we just need to try up to maxLap (the longest we can stick with a tire set and still get optimal performance).\\n\\n# Code\\n```\\npublic class Solution {\\n    private int[] finLap, best;\\n    private int maxLap = 1;\\n    public int MinimumFinishTime(int[][] tires, int changeTime, int numLaps) {    \\n        finLap = new int[numLaps+1];\\n        best = new int[numLaps+1];\\n        Array.Fill(best, Int32.MaxValue);\\n        Array.Fill(finLap, Int32.MaxValue);\\n        FindBest(tires, changeTime, numLaps);  \\n        return DfsFindMinTime(numLaps, changeTime);\\n    }\\n    private void FindBest(int[][] tires, int changeTime, int numLaps){ \\n            foreach(var t in tires){\\n                int fI = t[0], rI = t[1];\\n                int time = fI, currTime = fI;\\n                for(int lp = 1; lp<=numLaps && currTime < fI + changeTime; lp++){\\n                    best[lp] = Math.Min(time, best[lp]);\\n                    maxLap = Math.Max(maxLap, lp);\\n                    currTime *= rI;\\n                    time += currTime;\\n                }\\n            }\\n    }\\n    private int DfsFindMinTime(int numLap, int changeTime){\\n        if(numLap == 0){\\n            return -changeTime;\\n        }\\n        if(finLap[numLap] != Int32.MaxValue) return finLap[numLap];\\n        for(int lp = 1; lp <= Math.Min(maxLap, numLap); lp++)\\n          finLap[numLap] = Math.Min(finLap[numLap], best[lp] + changeTime +          DfsFindMinTime(numLap - lp, changeTime));\\n        return finLap[numLap];\\n    } \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nfor(int lp = 1; lp <= Math.Min(maxLap, numLap); lp++)\\n    finLap[numLap] = Math.Min(finLap[numLap], best[lp] + changeTime + DfsFindMinTime(numLap - lp, changeTime));\\n```\n```\\n currTime < fI + changeTime\\n```\n```\\nMath.Min(maxLap, numLap)\\n```\n```\\npublic class Solution {\\n    private int[] finLap, best;\\n    private int maxLap = 1;\\n    public int MinimumFinishTime(int[][] tires, int changeTime, int numLaps) {    \\n        finLap = new int[numLaps+1];\\n        best = new int[numLaps+1];\\n        Array.Fill(best, Int32.MaxValue);\\n        Array.Fill(finLap, Int32.MaxValue);\\n        FindBest(tires, changeTime, numLaps);  \\n        return DfsFindMinTime(numLaps, changeTime);\\n    }\\n    private void FindBest(int[][] tires, int changeTime, int numLaps){ \\n            foreach(var t in tires){\\n                int fI = t[0], rI = t[1];\\n                int time = fI, currTime = fI;\\n                for(int lp = 1; lp<=numLaps && currTime < fI + changeTime; lp++){\\n                    best[lp] = Math.Min(time, best[lp]);\\n                    maxLap = Math.Max(maxLap, lp);\\n                    currTime *= rI;\\n                    time += currTime;\\n                }\\n            }\\n    }\\n    private int DfsFindMinTime(int numLap, int changeTime){\\n        if(numLap == 0){\\n            return -changeTime;\\n        }\\n        if(finLap[numLap] != Int32.MaxValue) return finLap[numLap];\\n        for(int lp = 1; lp <= Math.Min(maxLap, numLap); lp++)\\n          finLap[numLap] = Math.Min(finLap[numLap], best[lp] + changeTime +          DfsFindMinTime(numLap - lp, changeTime));\\n        return finLap[numLap];\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686537,
                "title": "some-thought-process-of-transforming-the-question-into-dynamic-programming",
                "content": "# Thought process\\n```\\n# The whole race is just like\\n# [use_tire_x0 for y0 laps]\\n# <changeTime>\\n# [use_tire_x1 for y1 laps]\\n# <changeTime>\\n# [use_tire_x2 for y2 laps]\\n# ...\\n# <changeTime>\\n# [use_tire_xk for yk laps]\\n\\n# and the cost is\\n#   (no changeTime here for the very first time)\\n#   geometric_series_sum(tire_x0, y0 terms)\\n# + changeTime\\n# + geometric_series_sum(tire_x1, y1 terms)\\n# + changeTime\\n# + geometric_series_sum(tire_x2, y2 terms)\\n# + changeTime\\n# + ...\\n# + geometric_series_sum(tire_xk, yk terms)\\n# + changeTime\\n\\n# If we denote changeTime + geometric_series_sum(tire_xi, yi terms) = gs(xi, yi),\\n# we have gs(x0, y0) + gs(x1, y1) + gs(x2, y2) + ... + gs(xk, yk) - changeTime\\n# (we minus changeTime here as we add a changeTime in the front to form gs(x0, y0))\\n\\n# Then it could be reduced to a dynamic programming problem.\\n# If we change tire to x0 and take y0 laps now, the cost is\\n# gs(x0, y0) + dp(TOTAL_LAPS - y0).\\n\\n# Since using a tire continuous yields exponential costs (f -> fr -> fr^2 -> ...),\\n# yi is bounded. And for each yi, we calculate the min cost.\\n```\\n\\n# Code\\n```\\nimport functools\\nimport math\\n\\n// Time Complexity\\n// O(N + L) = O(N) as L <= 1000\\n// where N = len(tires) and L = numLaps.\\n\\n// Space Complexity\\n// O(N + L) = O(N) as L <= 1000\\n\\n\\nclass Solution:\\n    def minimumFinishTime(\\n        self, tires: List[List[int]], changeTime: int, numLaps: int\\n    ) -> int:        \\n\\n        # Recall that for the sum of a geometric series\\n        # f + fr + fr^2 + fr^3 + ... + fr^n-1 = (r^n - 1) / (r - 1) * f\\n        @functools.cache\\n        def cal_geometric_series(start_term: int, ratio: int, num_of_terms) -> int:\\n            return (ratio**num_of_terms - 1) // (ratio - 1) * start_term\\n\\n        @functools.cache\\n        def dp(remaining_laps: int) -> int:\\n            if remaining_laps == 0:\\n                return 0\\n\\n            if remaining_laps < 0:\\n                return float(\"inf\")\\n\\n            min_cost = float(\"inf\")\\n            for laps_to_go in range(MAX_LAPS_SINGLE_TIRE):\\n                min_cost = min(\\n                    min_cost,\\n                    change_tires_smallers[laps_to_go]\\n                    + dp(remaining_laps - laps_to_go - 1),\\n                )\\n            return min_cost\\n\\n        n = len(tires)\\n        max_laps_before_changing_tires = [0] * n\\n        for i, (fi, ri) in enumerate(tires):\\n            # f * r^x >= change + f\\n            x = math.ceil(math.log((changeTime + fi) / fi, ri))\\n            max_laps_before_changing_tires[i] = x\\n\\n        MAX_LAPS_SINGLE_TIRE = max(max_laps_before_changing_tires)\\n        change_tires_smallers = [0] * MAX_LAPS_SINGLE_TIRE\\n        for i in range(MAX_LAPS_SINGLE_TIRE):\\n            change_tires_smallers[i] = (\\n                min(cal_geometric_series(f, r, i + 1) for f, r in tires) + changeTime\\n            )\\n\\n        return dp(numLaps) - changeTime\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n# The whole race is just like\\n# [use_tire_x0 for y0 laps]\\n# <changeTime>\\n# [use_tire_x1 for y1 laps]\\n# <changeTime>\\n# [use_tire_x2 for y2 laps]\\n# ...\\n# <changeTime>\\n# [use_tire_xk for yk laps]\\n\\n# and the cost is\\n#   (no changeTime here for the very first time)\\n#   geometric_series_sum(tire_x0, y0 terms)\\n# + changeTime\\n# + geometric_series_sum(tire_x1, y1 terms)\\n# + changeTime\\n# + geometric_series_sum(tire_x2, y2 terms)\\n# + changeTime\\n# + ...\\n# + geometric_series_sum(tire_xk, yk terms)\\n# + changeTime\\n\\n# If we denote changeTime + geometric_series_sum(tire_xi, yi terms) = gs(xi, yi),\\n# we have gs(x0, y0) + gs(x1, y1) + gs(x2, y2) + ... + gs(xk, yk) - changeTime\\n# (we minus changeTime here as we add a changeTime in the front to form gs(x0, y0))\\n\\n# Then it could be reduced to a dynamic programming problem.\\n# If we change tire to x0 and take y0 laps now, the cost is\\n# gs(x0, y0) + dp(TOTAL_LAPS - y0).\\n\\n# Since using a tire continuous yields exponential costs (f -> fr -> fr^2 -> ...),\\n# yi is bounded. And for each yi, we calculate the min cost.\\n```\n```\\nimport functools\\nimport math\\n\\n// Time Complexity\\n// O(N + L) = O(N) as L <= 1000\\n// where N = len(tires) and L = numLaps.\\n\\n// Space Complexity\\n// O(N + L) = O(N) as L <= 1000\\n\\n\\nclass Solution:\\n    def minimumFinishTime(\\n        self, tires: List[List[int]], changeTime: int, numLaps: int\\n    ) -> int:        \\n\\n        # Recall that for the sum of a geometric series\\n        # f + fr + fr^2 + fr^3 + ... + fr^n-1 = (r^n - 1) / (r - 1) * f\\n        @functools.cache\\n        def cal_geometric_series(start_term: int, ratio: int, num_of_terms) -> int:\\n            return (ratio**num_of_terms - 1) // (ratio - 1) * start_term\\n\\n        @functools.cache\\n        def dp(remaining_laps: int) -> int:\\n            if remaining_laps == 0:\\n                return 0\\n\\n            if remaining_laps < 0:\\n                return float(\"inf\")\\n\\n            min_cost = float(\"inf\")\\n            for laps_to_go in range(MAX_LAPS_SINGLE_TIRE):\\n                min_cost = min(\\n                    min_cost,\\n                    change_tires_smallers[laps_to_go]\\n                    + dp(remaining_laps - laps_to_go - 1),\\n                )\\n            return min_cost\\n\\n        n = len(tires)\\n        max_laps_before_changing_tires = [0] * n\\n        for i, (fi, ri) in enumerate(tires):\\n            # f * r^x >= change + f\\n            x = math.ceil(math.log((changeTime + fi) / fi, ri))\\n            max_laps_before_changing_tires[i] = x\\n\\n        MAX_LAPS_SINGLE_TIRE = max(max_laps_before_changing_tires)\\n        change_tires_smallers = [0] * MAX_LAPS_SINGLE_TIRE\\n        for i in range(MAX_LAPS_SINGLE_TIRE):\\n            change_tires_smallers[i] = (\\n                min(cal_geometric_series(f, r, i + 1) for f, r in tires) + changeTime\\n            )\\n\\n        return dp(numLaps) - changeTime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638040,
                "title": "rust-dp-unbounded-knapsack-problem-solution",
                "content": "We can convert this problem into an unbound[ knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem). The weight is the number of laps. The value is the time required for finishing the number laps. The capacity is the total laps to finish.\\n\\n```rust\\nuse std::collections::*;\\n\\nimpl Solution {\\n\\tpub fn minimum_finish_time(tires: Vec<Vec<i32>>, change_time: i32, num_laps: i32) -> i32 {\\n\\t\\tlet mut a: BTreeMap<usize, i32> = BTreeMap::new();\\n\\t\\tfor t in &tires {\\n\\t\\t\\tlet (mut f, r, mut c, mut i) = (t[0], t[1], t[0], 0_usize);\\n\\t\\t\\twhile c < 1000000 {\\n\\t\\t\\t\\tif !a.contains_key(&i) || a[&i] > c { a.insert(i, c); }\\n\\t\\t\\t\\tf *= r; c += f; i += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlet a: Vec<_> = a.iter().map(|(_, x)| x).collect();\\n\\t\\tlet mut dp = vec![i32::MAX; num_laps as usize + 1];\\n\\t\\tdp[0] = 0;\\n\\t\\tfor i in 0..a.len() {\\n\\t\\t\\tfor j in (i + 1)..dp.len() {\\n\\t\\t\\t\\tdp[j] = dp[j].min(dp[j - i - 1] + a[i] + change_time);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[num_laps as usize] - change_time\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nuse std::collections::*;\\n\\nimpl Solution {\\n\\tpub fn minimum_finish_time(tires: Vec<Vec<i32>>, change_time: i32, num_laps: i32) -> i32 {\\n\\t\\tlet mut a: BTreeMap<usize, i32> = BTreeMap::new();\\n\\t\\tfor t in &tires {\\n\\t\\t\\tlet (mut f, r, mut c, mut i) = (t[0], t[1], t[0], 0_usize);\\n\\t\\t\\twhile c < 1000000 {\\n\\t\\t\\t\\tif !a.contains_key(&i) || a[&i] > c { a.insert(i, c); }\\n\\t\\t\\t\\tf *= r; c += f; i += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlet a: Vec<_> = a.iter().map(|(_, x)| x).collect();\\n\\t\\tlet mut dp = vec![i32::MAX; num_laps as usize + 1];\\n\\t\\tdp[0] = 0;\\n\\t\\tfor i in 0..a.len() {\\n\\t\\t\\tfor j in (i + 1)..dp.len() {\\n\\t\\t\\t\\tdp[j] = dp[j].min(dp[j - i - 1] + a[i] + change_time);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[num_laps as usize] - change_time\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2564334,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        tires.sort()\\n        r = float(\"inf\")\\n        \\n        # Remove useless tires\\n        i = 0\\n        while i < len(tires):\\n            if r <= tires[i][1] or tires[0][0] + changeTime < tires[i][0]:\\n                tires.pop(i)\\n            else:\\n                r = min(r, tires[i][1])\\n                i += 1\\n        \\n        # pre-compute fastest times for some numbers of laps without changing tire up to 17 laps\\n        # Only go to 17 because this is the most number of laps you could ever reach without wanting to change a tire\\n        # 2^17 > 10^5 = upper limit of changeTime, kind of hacky\\n        \\n        one_tire = [float(\"inf\")] * (numLaps + 1)\\n        one_tire[0] = 0\\n        \\n        for i in range(1, min(numLaps+1, 17)):\\n            minTime = float(\"inf\")\\n            for tire in tires:\\n                time = 0\\n                for j in range(1, i+1):\\n                    time += tire[0]*tire[1]**(j - 1)\\n                minTime = min(minTime, time)\\n            one_tire[i] = minTime\\n            \\n        \\n                \\n        \\n        @lru_cache(None)\\n        def dp(laps):\\n            if laps == 0:\\n                return 0\\n            best = one_tire[laps]\\n            for i in range(1, laps):\\n                best = min(best, dp(laps - i) + one_tire[i] + changeTime)\\n            return best\\n        return dp(numLaps)\\n        \\n```\\n\\nThis is one of those problems for python where even with the most optimal runtime you will sometimes achieve a successful run and other times incur a time limit exceeded result.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        tires.sort()\\n        r = float(\"inf\")\\n        \\n        # Remove useless tires\\n        i = 0\\n        while i < len(tires):\\n            if r <= tires[i][1] or tires[0][0] + changeTime < tires[i][0]:\\n                tires.pop(i)\\n            else:\\n                r = min(r, tires[i][1])\\n                i += 1\\n        \\n        # pre-compute fastest times for some numbers of laps without changing tire up to 17 laps\\n        # Only go to 17 because this is the most number of laps you could ever reach without wanting to change a tire\\n        # 2^17 > 10^5 = upper limit of changeTime, kind of hacky\\n        \\n        one_tire = [float(\"inf\")] * (numLaps + 1)\\n        one_tire[0] = 0\\n        \\n        for i in range(1, min(numLaps+1, 17)):\\n            minTime = float(\"inf\")\\n            for tire in tires:\\n                time = 0\\n                for j in range(1, i+1):\\n                    time += tire[0]*tire[1]**(j - 1)\\n                minTime = min(minTime, time)\\n            one_tire[i] = minTime\\n            \\n        \\n                \\n        \\n        @lru_cache(None)\\n        def dp(laps):\\n            if laps == 0:\\n                return 0\\n            best = one_tire[laps]\\n            for i in range(1, laps):\\n                best = min(best, dp(laps - i) + one_tire[i] + changeTime)\\n            return best\\n        return dp(numLaps)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372013,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<long long> dp(numLaps + 1,1e15);\\n        for (auto it : tires) {\\n            long long base = 1ll;\\n            long long totalTime = 0ll;\\n            for (int i = 1; i <= numLaps; i++) {\\n                long long val = base * it[0];\\n                base *= it[1];\\n                if (val > 1e12) break;\\n                totalTime += val;\\n                dp[i] = min(dp[i],totalTime);\\n            }\\n        }\\n        \\n        \\n        for (int i = 1; i <= numLaps; i++) {\\n            for (int j = 1; j < i; j++) {\\n                dp[i] = min(dp[i],dp[j] + dp[i-j] + changeTime*1ll);\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<long long> dp(numLaps + 1,1e15);\\n        for (auto it : tires) {\\n            long long base = 1ll;\\n            long long totalTime = 0ll;\\n            for (int i = 1; i <= numLaps; i++) {\\n                long long val = base * it[0];\\n                base *= it[1];\\n                if (val > 1e12) break;\\n                totalTime += val;\\n                dp[i] = min(dp[i],totalTime);\\n            }\\n        }\\n        \\n        \\n        for (int i = 1; i <= numLaps; i++) {\\n            for (int j = 1; j < i; j++) {\\n                dp[i] = min(dp[i],dp[j] + dp[i-j] + changeTime*1ll);\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356431,
                "title": "c-3d-dp-bottom-up-with-detailed-explained",
                "content": "Tips:\\n1.We create 3D int[i][j][k] dp to solve this problem\\n\\n*  i is lapID, means currentLapID, range is [0,numLaps-1].\\n*  j is tireId, int[][] tires including all tires, we will do filter on it later. \\n*  k is usedTireLaps,means how many laps this tire used.\\n\\n2.We must select all **Good** tires only to avoid TLE.\\n\\neg. for TireA and TireB, if fA<=fB and rA<=rB, then TireA is good, we will never use TireB because it will always slower than TireA.\\nHow to do it? Sort tires by fi then by ri, select only smaller ri than prev good one.\\n   \\n3.Every time a tire was used, next lap it\\'s cost time will be ri * currCost,\\n\\nBecause changeTime <= 10^5,2 <= ri <= 10^5   ,If a tire was used for continuous 20 laps, it will cost at least 2^19 >> changeTime + fi, we will better to change a new Tire. So the 3rd of dp[][][] will not very large, we can set it as 20.\\n\\n```\\n        public int MinimumFinishTime(int[][] tires, int changeTime, int numLaps)\\n        {\\n            tires = tires.OrderBy(x => x[0]).ThenBy(x => x[1]).ToArray();//sort by fi then by ri\\n            List<int[]> goodTires = new List<int[]>();//only select good tires to avoid TLE\\n            int[] prev = tires[0];\\n            goodTires.Add(tires[0]);\\n            for(int i = 1; i < tires.Length; i++)\\n            {\\n                if (tires[i][1] >= prev[1]) continue;\\n                else\\n                {\\n                    goodTires.Add(tires[i]);\\n                    prev = tires[i];\\n                }\\n            }\\n            int n = goodTires.Count;\\n            int LEN = 20;//1*2^20 >=1_000_000 , we should never use a tire continuous 20 laps\\n            int[][] timeMat = new int[n][];//create a tire cost table for future query\\n            for (int i = 0; i < n; i++)\\n            {\\n                timeMat[i] = new int[LEN];\\n                Array.Fill(timeMat[i], int.MaxValue);\\n                timeMat[i][0] = goodTires[i][0];\\n                for (int j = 1; j < LEN; j++)\\n                {\\n                    int curr = timeMat[i][j - 1] * goodTires[i][1];\\n                    if (curr >= changeTime + goodTires[i][0])//we should better replace a new tire with same tireID\\n                        break;\\n                    timeMat[i][j] = curr;\\n                }\\n            }\\n            int[][][] dp = new int[numLaps][][];\\n            for (int i = 0; i < numLaps; i++)\\n            {\\n                dp[i] = new int[n][];\\n                for (int j = 0; j <n; j++)\\n                {\\n                    dp[i][j] = new int[LEN];\\n                    Array.Fill(dp[i][j], int.MaxValue);\\n                    if (i == 0)\\n                        dp[i][j][0] = goodTires[j][0];//seed data\\n                }\\n            }\\n            for (int i = 0; i < numLaps - 1; i++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n\\t\\t\\t\\t\\t//why k<=i ? because in lap-i, every tire will be used at most i times\\n                    for (int k = 0; k <= i && k<LEN; k++)\\n                    {\\n                        if (dp[i][j][k] == int.MaxValue) continue;//many data in dp[][][] is int.MaxValue, means it no need to handle\\n                        for (int m = 0; m < n; m++)\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t//try change to a new tire with ID=m, so it\\'s dp[i + 1][m][0]\\n\\t\\t\\t\\t\\t\\t\\t//current cost is dp[i][j][k] , we should add  changeTime + timeMat[m][0]\\n                            dp[i + 1][m][0] = Math.Min(dp[i + 1][m][0], dp[i][j][k] + changeTime + timeMat[m][0]);\\n                        }\\n                        if (timeMat[j][k + 1] == int.MaxValue) continue;//no need to continue , we should better change a new tire\\n                        dp[i + 1][j][k + 1] = Math.Min(dp[i + 1][j][k + 1], dp[i][j][k] + timeMat[j][k + 1]);\\n                    }\\n                }\\n            }\\n            return dp.Last().Min(x => x.Min());\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int MinimumFinishTime(int[][] tires, int changeTime, int numLaps)\\n        {\\n            tires = tires.OrderBy(x => x[0]).ThenBy(x => x[1]).ToArray();//sort by fi then by ri\\n            List<int[]> goodTires = new List<int[]>();//only select good tires to avoid TLE\\n            int[] prev = tires[0];\\n            goodTires.Add(tires[0]);\\n            for(int i = 1; i < tires.Length; i++)\\n            {\\n                if (tires[i][1] >= prev[1]) continue;\\n                else\\n                {\\n                    goodTires.Add(tires[i]);\\n                    prev = tires[i];\\n                }\\n            }\\n            int n = goodTires.Count;\\n            int LEN = 20;//1*2^20 >=1_000_000 , we should never use a tire continuous 20 laps\\n            int[][] timeMat = new int[n][];//create a tire cost table for future query\\n            for (int i = 0; i < n; i++)\\n            {\\n                timeMat[i] = new int[LEN];\\n                Array.Fill(timeMat[i], int.MaxValue);\\n                timeMat[i][0] = goodTires[i][0];\\n                for (int j = 1; j < LEN; j++)\\n                {\\n                    int curr = timeMat[i][j - 1] * goodTires[i][1];\\n                    if (curr >= changeTime + goodTires[i][0])//we should better replace a new tire with same tireID\\n                        break;\\n                    timeMat[i][j] = curr;\\n                }\\n            }\\n            int[][][] dp = new int[numLaps][][];\\n            for (int i = 0; i < numLaps; i++)\\n            {\\n                dp[i] = new int[n][];\\n                for (int j = 0; j <n; j++)\\n                {\\n                    dp[i][j] = new int[LEN];\\n                    Array.Fill(dp[i][j], int.MaxValue);\\n                    if (i == 0)\\n                        dp[i][j][0] = goodTires[j][0];//seed data\\n                }\\n            }\\n            for (int i = 0; i < numLaps - 1; i++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n\\t\\t\\t\\t\\t//why k<=i ? because in lap-i, every tire will be used at most i times\\n                    for (int k = 0; k <= i && k<LEN; k++)\\n                    {\\n                        if (dp[i][j][k] == int.MaxValue) continue;//many data in dp[][][] is int.MaxValue, means it no need to handle\\n                        for (int m = 0; m < n; m++)\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t//try change to a new tire with ID=m, so it\\'s dp[i + 1][m][0]\\n\\t\\t\\t\\t\\t\\t\\t//current cost is dp[i][j][k] , we should add  changeTime + timeMat[m][0]\\n                            dp[i + 1][m][0] = Math.Min(dp[i + 1][m][0], dp[i][j][k] + changeTime + timeMat[m][0]);\\n                        }\\n                        if (timeMat[j][k + 1] == int.MaxValue) continue;//no need to continue , we should better change a new tire\\n                        dp[i + 1][j][k + 1] = Math.Min(dp[i + 1][j][k + 1], dp[i][j][k] + timeMat[j][k + 1]);\\n                    }\\n                }\\n            }\\n            return dp.Last().Min(x => x.Min());\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2327256,
                "title": "c-knapsack",
                "content": "```\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        using ll = long long;\\n        \\n        vector<int> bestOn1Tire;\\n\\n        for (auto &t: tires) {\\n            const int f = t[0], r=t[1];\\n            \\n            int curLap = 0;\\n            ll curLapTime = f;\\n            int totalTime = 0;\\n            \\n            do {\\n                totalTime += curLapTime;\\n                if (curLap < bestOn1Tire.size()) bestOn1Tire[curLap] = min(bestOn1Tire[curLap], totalTime);\\n                 else bestOn1Tire.push_back(totalTime);\\n                curLapTime *= r;\\n                curLap++;\\n            } while (curLapTime < changeTime+f);            \\n        }\\n        \\n        int maxLapsOn1Tire = bestOn1Tire.size();\\n        \\n        vector<int> bestTime(numLaps, INT_MAX); // it will accumulate best time to complete ith lap\\n        bestTime[0] = bestOn1Tire[0]; // we start from the best time on one tire for 1st lap\\n        \\n        for (int laps=2; laps <= numLaps; laps++) {\\n\\t\\t// core knapsack alg is here: what would be the best time if we use single tire 1 last lap.. 2 last laps ... X last laps.\\n            for (int lapsOn1Tire=1, K=min(laps,maxLapsOn1Tire); lapsOn1Tire<=K; ++lapsOn1Tire ) {  \\n                int curLapTime = lapsOn1Tire < laps ? bestTime[laps-lapsOn1Tire-1] + changeTime : 0;\\n                curLapTime += bestOn1Tire[lapsOn1Tire-1];\\n                bestTime[laps-1] = min(bestTime[laps-1], curLapTime);\\n            }\\n        }\\n        \\n        return bestTime[numLaps-1];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        using ll = long long;\\n        \\n        vector<int> bestOn1Tire;\\n\\n        for (auto &t: tires) {\\n            const int f = t[0], r=t[1];\\n            \\n            int curLap = 0;\\n            ll curLapTime = f;\\n            int totalTime = 0;\\n            \\n            do {\\n                totalTime += curLapTime;\\n                if (curLap < bestOn1Tire.size()) bestOn1Tire[curLap] = min(bestOn1Tire[curLap], totalTime);\\n                 else bestOn1Tire.push_back(totalTime);\\n                curLapTime *= r;\\n                curLap++;\\n            } while (curLapTime < changeTime+f);            \\n        }\\n        \\n        int maxLapsOn1Tire = bestOn1Tire.size();\\n        \\n        vector<int> bestTime(numLaps, INT_MAX); // it will accumulate best time to complete ith lap\\n        bestTime[0] = bestOn1Tire[0]; // we start from the best time on one tire for 1st lap\\n        \\n        for (int laps=2; laps <= numLaps; laps++) {\\n\\t\\t// core knapsack alg is here: what would be the best time if we use single tire 1 last lap.. 2 last laps ... X last laps.\\n            for (int lapsOn1Tire=1, K=min(laps,maxLapsOn1Tire); lapsOn1Tire<=K; ++lapsOn1Tire ) {  \\n                int curLapTime = lapsOn1Tire < laps ? bestTime[laps-lapsOn1Tire-1] + changeTime : 0;\\n                curLapTime += bestOn1Tire[lapsOn1Tire-1];\\n                bestTime[laps-1] = min(bestTime[laps-1], curLapTime);\\n            }\\n        }\\n        \\n        return bestTime[numLaps-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2279059,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\n    int N = 16;\\n    int cost[16]; // 2^14 = 16384 > 100000 \\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        for(int i = 1; i < 16; i++){ cost[i] = INT_MAX;}\\n        cost[0] = 0;\\n        \\n        for(auto &T:tires){\\n            int num = T[0];\\n            int accu = T[0];\\n            cost[1] = min(cost[1], accu+changeTime);\\n            for(int i = 2; i < 16; i++){\\n                if(INT_MAX / num <= T[1]){break;}  // prevent overflow\\n                num *= T[1];\\n                if(num > T[0] + changeTime){break;} // if cost time of current lap > T[0] + changeTime, then tire should be changed\\n                accu += num;\\n                cost[i] = min(cost[i], accu+changeTime);\\n            }\\n        }\\n        \\n        //cost[i] -> the smallest cost for using the same tire to finish running i laps\\n        \\n        int lrg = 0;\\n        for(int i = 0; i < 16; i++){\\n            if(cost[i] != INT_MAX){\\n                lrg = i;\\n            }\\n        }\\n        \\n        vector<int> dp(numLaps+1,200000000);\\n        dp[0] = 0;\\n        for(int i = 1; i <= lrg; i++){\\n            for(int j = i; j <= numLaps; j++){\\n                dp[j] = min(dp[j], dp[j-i] + cost[i]);\\n            }\\n        }\\n\\n        return dp[numLaps]-changeTime;  //first round doesn\\'t change tires\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int N = 16;\\n    int cost[16]; // 2^14 = 16384 > 100000 \\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        for(int i = 1; i < 16; i++){ cost[i] = INT_MAX;}\\n        cost[0] = 0;\\n        \\n        for(auto &T:tires){\\n            int num = T[0];\\n            int accu = T[0];\\n            cost[1] = min(cost[1], accu+changeTime);\\n            for(int i = 2; i < 16; i++){\\n                if(INT_MAX / num <= T[1]){break;}  // prevent overflow\\n                num *= T[1];\\n                if(num > T[0] + changeTime){break;} // if cost time of current lap > T[0] + changeTime, then tire should be changed\\n                accu += num;\\n                cost[i] = min(cost[i], accu+changeTime);\\n            }\\n        }\\n        \\n        //cost[i] -> the smallest cost for using the same tire to finish running i laps\\n        \\n        int lrg = 0;\\n        for(int i = 0; i < 16; i++){\\n            if(cost[i] != INT_MAX){\\n                lrg = i;\\n            }\\n        }\\n        \\n        vector<int> dp(numLaps+1,200000000);\\n        dp[0] = 0;\\n        for(int i = 1; i <= lrg; i++){\\n            for(int j = i; j <= numLaps; j++){\\n                dp[j] = min(dp[j], dp[j-i] + cost[i]);\\n            }\\n        }\\n\\n        return dp[numLaps]-changeTime;  //first round doesn\\'t change tires\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278570,
                "title": "c-dp-solution",
                "content": "class Solution {\\nprivate:\\n    int best[1001],maxlaps=0;\\nprivate:\\n    int f(int n,int changeTime,vector<int>& dp){\\n        if(n==0) return -changeTime;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        int mini=1e9;\\n        for(int laps=1;laps<=min(n,maxlaps);laps++){\\n            int time = best[laps] + changeTime + f(n-laps,changeTime,dp);\\n            mini = min(mini,time);\\n        }\\n        return dp[n] = mini;\\n    }\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        for(int i=0;i<=numLaps;i++){\\n            best[i]=INT_MAX;\\n        }\\n        vector<int> dp(numLaps+1,-1);\\n        \\n        for(auto it:tires){\\n            int fi=it[0];\\n            int ri=it[1];\\n            long long time=fi;\\n            long long currlaptime=fi;\\n            for(int lap=1; lap<=numLaps && currlaptime < fi + changeTime;lap++){\\n                \\n                \\n                if(time<best[lap]){\\n                    best[lap]=time;\\n                }\\n                \\n                //store the max laps taken by any tire\\n                maxlaps=max(maxlaps,lap);\\n                    \\n                //compute time for next succession\\n                currlaptime *= ri;\\n                \\n                time+=currlaptime;\\n            }\\n            \\n        }\\n        return f(numLaps,changeTime,dp);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\nprivate:\\n    int best[1001],maxlaps=0;\\nprivate:\\n    int f(int n,int changeTime,vector<int>& dp){\\n        if(n==0) return -changeTime;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        int mini=1e9;\\n        for(int laps=1;laps<=min(n,maxlaps);laps++){\\n            int time = best[laps] + changeTime + f(n-laps,changeTime,dp);\\n            mini = min(mini,time);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2092186,
                "title": "javascript-dp",
                "content": "```js\\n/**\\n * @param {number[][]} tires\\n * @param {number} changeTime\\n * @param {number} numLaps\\n * @return {number}\\n */\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {\\n    // precompute lap times without changing tires\\n    const lapTimes = Array(numLaps + 1).fill(Infinity)\\n    for (let [f,r] of tires) {\\n        let time = 0\\n        for (let i = 1; i <= numLaps; i++) {\\n            time += f * (r**(i-1))\\n            \\n\\t\\t\\t// no need to calculate rest as we\\'re going to change tires\\n\\t\\t\\t// changeTime <= 10^5  and for f:1, r:2 total time is 131072 at 18th lap.\\n\\t\\t\\t// it\\'s bigger than 10^5 so better change tires\\n            if (time > 2**17) break \\n            \\n            lapTimes[i] = Math.min(lapTimes[i], time)\\n        }\\n    }\\n    \\n    // calculate changing tires between [1 - i] => 1 --- j --- i\\n    for (let i = 1; i <= numLaps; i++) {\\n        if (i >= 18) lapTimes[i] = Infinity // force changing the tire as it\\'s faster after lap 18\\n        \\n        for (let j = 1; j < i; j++) {\\n            lapTimes[i] = Math.min(lapTimes[i], lapTimes[j] + changeTime + lapTimes[i-j])\\n        }    \\n    }\\n    \\n    return lapTimes[numLaps]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} tires\\n * @param {number} changeTime\\n * @param {number} numLaps\\n * @return {number}\\n */\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {\\n    // precompute lap times without changing tires\\n    const lapTimes = Array(numLaps + 1).fill(Infinity)\\n    for (let [f,r] of tires) {\\n        let time = 0\\n        for (let i = 1; i <= numLaps; i++) {\\n            time += f * (r**(i-1))\\n            \\n\\t\\t\\t// no need to calculate rest as we\\'re going to change tires\\n\\t\\t\\t// changeTime <= 10^5  and for f:1, r:2 total time is 131072 at 18th lap.\\n\\t\\t\\t// it\\'s bigger than 10^5 so better change tires\\n            if (time > 2**17) break \\n            \\n            lapTimes[i] = Math.min(lapTimes[i], time)\\n        }\\n    }\\n    \\n    // calculate changing tires between [1 - i] => 1 --- j --- i\\n    for (let i = 1; i <= numLaps; i++) {\\n        if (i >= 18) lapTimes[i] = Infinity // force changing the tire as it\\'s faster after lap 18\\n        \\n        for (let j = 1; j < i; j++) {\\n            lapTimes[i] = Math.min(lapTimes[i], lapTimes[j] + changeTime + lapTimes[i-j])\\n        }    \\n    }\\n    \\n    return lapTimes[numLaps]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030181,
                "title": "subroutine-prune-the-tires-by-dominance",
                "content": "if one tire type is better than the other in every way, we can prune the other tire away.\\nif tow tire types are the same, of course we just need to keep one of them.\\n\\n```\\n    struct TireType {\\n        /// `f`\\n        int firstLap;\\n        /// `r`\\n        int repeatedLapFactor;\\n\\n        TireType(int _firstLap, int _repeatedLapFactor)\\n                : firstLap(_firstLap), repeatedLapFactor(_repeatedLapFactor) {}\\n\\n        /// \\\\brief if this tire type is better than the other in every way, or the two are the same,\\n        /// return true.\\n        /// \\\\returns false if each type of tire has its own strength.\\n        bool dominatesOrEquals(const TireType& other) const {\\n            return firstLap <= other.firstLap && //\\n                    repeatedLapFactor <= other.repeatedLapFactor;\\n        }\\n    };\\n\\n    /// Prune the types of tires.\\n    /// O(n2)\\n    static vector<TireType> PruneTires(const vector<vector<int>>& tires) {\\n        if (tires.empty()) {\\n            return {};\\n        }\\n        list<TireType> dominanceTires; // list<T> is excellent for random deletion.\\n        dominanceTires.emplace_back(tires[0][0], tires[0][1]);\\n\\n        for (int i = 1; i < tires.size(); ++i) {\\n            auto newTireType = TireType(tires[i][0], tires[i][1]);\\n            // if the new tire type dominates an existing tire type `et`,\\n            // then we\\'ll erase/delete the existing `et`.\\n            // if the new tire type is dominated by `et`, then we\\'ll skip this new tire type (i.e.\\n            // we won\\'t add it to the list).\\n            bool shouldInsert = true;\\n            for (auto iter = dominanceTires.begin(); iter != dominanceTires.end();) {\\n                // if the new tire type is dominated by `et`, then we\\'ll skip this new tire type\\n                // (i.e. we won\\'t add it to the list).\\n                if (iter->dominatesOrEquals(newTireType)) {\\n                    shouldInsert = false;\\n                    break;\\n                }\\n                if (newTireType.dominatesOrEquals(*iter)) {\\n                    // new tire dominates the existing one ==> delete the existing one.\\n                    iter = dominanceTires.erase(iter);\\n                } else { // they don\\'t dominate each other -- they have their own strength.\\n                    ++iter;\\n                }\\n            }\\n            if (shouldInsert) {\\n                dominanceTires.emplace_back(newTireType);\\n            }\\n        }\\n\\n        cout << \"Pruned \" << tires.size() - dominanceTires.size() << \" tires out of \"\\n             << tires.size() << \", or \"\\n             << 100.0 * double(tires.size() - dominanceTires.size()) / tires.size() << \"%.\" << endl;\\n\\n        // sort the tires by firstLap\\n        vector<TireType> goodTires(dominanceTires.begin(), dominanceTires.end());\\n        sort(goodTires.begin(), goodTires.end(), [](const TireType& a, const TireType& b) {\\n            return a.firstLap < b.firstLap\\n                    || a.firstLap == b.firstLap && a.repeatedLapFactor < b.repeatedLapFactor;\\n        });\\n        return goodTires;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    struct TireType {\\n        /// `f`\\n        int firstLap;\\n        /// `r`\\n        int repeatedLapFactor;\\n\\n        TireType(int _firstLap, int _repeatedLapFactor)\\n                : firstLap(_firstLap), repeatedLapFactor(_repeatedLapFactor) {}\\n\\n        /// \\\\brief if this tire type is better than the other in every way, or the two are the same,\\n        /// return true.\\n        /// \\\\returns false if each type of tire has its own strength.\\n        bool dominatesOrEquals(const TireType& other) const {\\n            return firstLap <= other.firstLap && //\\n                    repeatedLapFactor <= other.repeatedLapFactor;\\n        }\\n    };\\n\\n    /// Prune the types of tires.\\n    /// O(n2)\\n    static vector<TireType> PruneTires(const vector<vector<int>>& tires) {\\n        if (tires.empty()) {\\n            return {};\\n        }\\n        list<TireType> dominanceTires; // list<T> is excellent for random deletion.\\n        dominanceTires.emplace_back(tires[0][0], tires[0][1]);\\n\\n        for (int i = 1; i < tires.size(); ++i) {\\n            auto newTireType = TireType(tires[i][0], tires[i][1]);\\n            // if the new tire type dominates an existing tire type `et`,\\n            // then we\\'ll erase/delete the existing `et`.\\n            // if the new tire type is dominated by `et`, then we\\'ll skip this new tire type (i.e.\\n            // we won\\'t add it to the list).\\n            bool shouldInsert = true;\\n            for (auto iter = dominanceTires.begin(); iter != dominanceTires.end();) {\\n                // if the new tire type is dominated by `et`, then we\\'ll skip this new tire type\\n                // (i.e. we won\\'t add it to the list).\\n                if (iter->dominatesOrEquals(newTireType)) {\\n                    shouldInsert = false;\\n                    break;\\n                }\\n                if (newTireType.dominatesOrEquals(*iter)) {\\n                    // new tire dominates the existing one ==> delete the existing one.\\n                    iter = dominanceTires.erase(iter);\\n                } else { // they don\\'t dominate each other -- they have their own strength.\\n                    ++iter;\\n                }\\n            }\\n            if (shouldInsert) {\\n                dominanceTires.emplace_back(newTireType);\\n            }\\n        }\\n\\n        cout << \"Pruned \" << tires.size() - dominanceTires.size() << \" tires out of \"\\n             << tires.size() << \", or \"\\n             << 100.0 * double(tires.size() - dominanceTires.size()) / tires.size() << \"%.\" << endl;\\n\\n        // sort the tires by firstLap\\n        vector<TireType> goodTires(dominanceTires.begin(), dominanceTires.end());\\n        sort(goodTires.begin(), goodTires.end(), [](const TireType& a, const TireType& b) {\\n            return a.firstLap < b.firstLap\\n                    || a.firstLap == b.firstLap && a.repeatedLapFactor < b.repeatedLapFactor;\\n        });\\n        return goodTires;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1860658,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const long long INF = 1e10 + 7;\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        int n = tires.size();\\n        vector<long long> laps(33, INF);\\n        for (int i = 0; i < n; i++) {\\n            long long gp = tires[i][0];\\n            long long add = gp;\\n            laps[1] = min(laps[1], gp);\\n            for (int times = 2; times < 33; times++) {\\n                gp *= tires[i][1];\\n                add += gp;\\n                if (add >= INF) break;\\n                laps[times] = min(laps[times], add);\\n            }\\n        }\\n        vector<long long> dp(numLaps + 1, INF);\\n        dp[0] = 0;\\n        for (int i = 1; i <= min(numLaps, 32); i++) {\\n            dp[i] = laps[i];\\n        }\\n        for (int i = 1; i <= numLaps; i++) {\\n            for (int start = 1; start < 33; start++) {\\n                int nxt = i + start;\\n                if (nxt > numLaps) break;\\n                dp[nxt] = min(dp[nxt], dp[i] + changeTime + laps[start]);\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long INF = 1e10 + 7;\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        int n = tires.size();\\n        vector<long long> laps(33, INF);\\n        for (int i = 0; i < n; i++) {\\n            long long gp = tires[i][0];\\n            long long add = gp;\\n            laps[1] = min(laps[1], gp);\\n            for (int times = 2; times < 33; times++) {\\n                gp *= tires[i][1];\\n                add += gp;\\n                if (add >= INF) break;\\n                laps[times] = min(laps[times], add);\\n            }\\n        }\\n        vector<long long> dp(numLaps + 1, INF);\\n        dp[0] = 0;\\n        for (int i = 1; i <= min(numLaps, 32); i++) {\\n            dp[i] = laps[i];\\n        }\\n        for (int i = 1; i <= numLaps; i++) {\\n            for (int start = 1; start < 33; start++) {\\n                int nxt = i + start;\\n                if (nxt > numLaps) break;\\n                dp[nxt] = min(dp[nxt], dp[i] + changeTime + laps[start]);\\n            }\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849378,
                "title": "recursive-code-not-working-someone-plis-help",
                "content": "```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        return helper(tires, changeTime, numLaps, 1, Integer.MIN_VALUE, 0);\\n    }\\n    int time = 0;\\n    int maxtime = 0;\\n    private int helper(int[][] tires, int changeTime, int numLaps, int start, int tireno, int tirelaps){\\n        int time1= Integer.MAX_VALUE;\\n        int time2= Integer.MAX_VALUE;\\n        if(start == numLaps+1){\\n            return 0;\\n        }\\n        \\n        for(int i = 0; i < tires.length; i++){\\n            if(i == tireno){\\n                time2 = Math.min(\\n                    (timeCalc(tires[i], tirelaps) + helper(tires, changeTime, numLaps, start+1, i, tirelaps+1)),\\n                    ((timeCalc(tires[i], 1) + changeTime) + helper(tires, changeTime, numLaps, start+1, i, 2))\\n                );\\n            }else{\\n                time = timeCalc(tires[i], 1) + changeTime;\\n                time1 = (time + helper(tires, changeTime, numLaps, start+1, i, 2));\\n            }\\n            maxtime = Math.min(time1,time2);\\n        }\\n        return maxtime;\\n    }\\n    \\n    private int timeCalc(int[] tire, int x){\\n        int time = tire[0]*(int)Math.pow(tire[1], x-1);\\n        return time;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        return helper(tires, changeTime, numLaps, 1, Integer.MIN_VALUE, 0);\\n    }\\n    int time = 0;\\n    int maxtime = 0;\\n    private int helper(int[][] tires, int changeTime, int numLaps, int start, int tireno, int tirelaps){\\n        int time1= Integer.MAX_VALUE;\\n        int time2= Integer.MAX_VALUE;\\n        if(start == numLaps+1){\\n            return 0;\\n        }\\n        \\n        for(int i = 0; i < tires.length; i++){\\n            if(i == tireno){\\n                time2 = Math.min(\\n                    (timeCalc(tires[i], tirelaps) + helper(tires, changeTime, numLaps, start+1, i, tirelaps+1)),\\n                    ((timeCalc(tires[i], 1) + changeTime) + helper(tires, changeTime, numLaps, start+1, i, 2))\\n                );\\n            }else{\\n                time = timeCalc(tires[i], 1) + changeTime;\\n                time1 = (time + helper(tires, changeTime, numLaps, start+1, i, 2));\\n            }\\n            maxtime = Math.min(time1,time2);\\n        }\\n        return maxtime;\\n    }\\n    \\n    private int timeCalc(int[] tire, int x){\\n        int time = tire[0]*(int)Math.pow(tire[1], x-1);\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832660,
                "title": "why-this-solution-giving-tle-even-after-passing-all-58-test-cases",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n   \\n    \\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<vector<long long> >precompute(tires.size(),vector<long long>(19,200000000));\\n        for(int i=0;i<tires.size();i++){\\n            \\n\\n            precompute[i][0]=tires[i][0];\\n            \\n            for(int j=1;j<19;j++){\\n                long long check=precompute[i][j-1]*tires[i][1];\\n                if(check>=200000000){\\n                    break;\\n                }\\n                else{\\n                    precompute[i][j]=check;\\n                }\\n            }\\n            \\n            \\n\\n            for(int j=1;j<19;j++){\\n                precompute[i][j]+=precompute[i][j-1];\\n                \\n                if(precompute[i][j]>=200000000){\\n                    precompute[i][j]=200000000;\\n                    break;\\n                }\\n            }\\n        \\n        }\\n        \\n        \\n        \\n        \\n        vector<long long>dp(numLaps+1,INT_MAX);\\n        \\n        \\n        \\n        for(int i=1;i<=numLaps;i++){\\n            if(i<20){\\n                \\n                for(int j=0;j<tires.size();j++){\\n                    dp[i]=min(dp[i],precompute[j][i-1]);\\n                }\\n                \\n            }\\n             for(int j=i/2;j<i;j++){\\n                    dp[i]=min(dp[i],dp[i-j]+dp[j]+changeTime);\\n                }\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n   \\n    \\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<vector<long long> >precompute(tires.size(),vector<long long>(19,200000000));\\n        for(int i=0;i<tires.size();i++){\\n            \\n\\n            precompute[i][0]=tires[i][0];\\n            \\n            for(int j=1;j<19;j++){\\n                long long check=precompute[i][j-1]*tires[i][1];\\n                if(check>=200000000){\\n                    break;\\n                }\\n                else{\\n                    precompute[i][j]=check;\\n                }\\n            }\\n            \\n            \\n\\n            for(int j=1;j<19;j++){\\n                precompute[i][j]+=precompute[i][j-1];\\n                \\n                if(precompute[i][j]>=200000000){\\n                    precompute[i][j]=200000000;\\n                    break;\\n                }\\n            }\\n        \\n        }\\n        \\n        \\n        \\n        \\n        vector<long long>dp(numLaps+1,INT_MAX);\\n        \\n        \\n        \\n        for(int i=1;i<=numLaps;i++){\\n            if(i<20){\\n                \\n                for(int j=0;j<tires.size();j++){\\n                    dp[i]=min(dp[i],precompute[j][i-1]);\\n                }\\n                \\n            }\\n             for(int j=i/2;j<i;j++){\\n                    dp[i]=min(dp[i],dp[i-j]+dp[j]+changeTime);\\n                }\\n        }\\n        return dp[numLaps];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832566,
                "title": "swift-pure-dp-o-numlaps-no-18-20-or-anything",
                "content": "\\nIt\\'s very similar to text-justification DP but a little bit of a twist.\\n\\n```\\n    func minimumFinishTime(_ tires: [[Int]], _ changeTime: Int, _ numLaps: Int) -> Int {\\n        // for the edge case\\n        if numLaps == 1 {\\n            return tires.sorted { $0[0] < $1[0] }.first![0]\\n        }\\n        // dp array when you go with just one tire\\n        // dpNoChange[n] : the minimum time to go n laps when you don\\'t change the tire\\n        var dpNoChange = [Int](repeating: Int.max, count: numLaps + 1)\\n        dpNoChange[0] = 0\\n        for tire in tires {\\n            var sum = tire[0]\\n            var now = tire[0]\\n            dpNoChange[1] = min(dpNoChange[1], sum)   \\n            for n in 2...numLaps {\\n                now *= tire[1]\\n                // due to this guard statement, the real value array will be small enough to be a constant.\\n                // according to the parameter space, it will be under 20\\n                guard now < tire[0] + changeTime else { break }\\n                sum += now\\n                dpNoChange[n] = min(dpNoChange[n], sum)\\n            }\\n        }\\n        // the real dp\\n        // dp[n] = the minimum time to go n laps wheather we go with one tire or multiple tires.\\n        var dp = [Int](repeating: Int.max, count: numLaps + 1)\\n        dp[0] = 0\\n        dp[1] = dpNoChange[1]\\n        // text justification DP\\n        // dp[n] = min(dp[n - 1] + changeTime + dpNoChange[1], dp[n - 2] + changeTime + dpNoChange[2], ...)\\n        for n in 2...numLaps {\\n\\t\\t\\t// start with just one tire lap time or Int.max, which indicates the tire MUST be changed.\\n            dp[n] = dpNoChange[n]\\n            for i in 1..<n {\\n                // prevent useless calculation & make it constant\\n                guard dpNoChange[i] != Int.max else { break }\\n                dp[n] = min(dp[n], dpNoChange[i] + changeTime + dp[n - i])\\n            }\\n        }\\n        return dp[numLaps]\\n    }\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    func minimumFinishTime(_ tires: [[Int]], _ changeTime: Int, _ numLaps: Int) -> Int {\\n        // for the edge case\\n        if numLaps == 1 {\\n            return tires.sorted { $0[0] < $1[0] }.first![0]\\n        }\\n        // dp array when you go with just one tire\\n        // dpNoChange[n] : the minimum time to go n laps when you don\\'t change the tire\\n        var dpNoChange = [Int](repeating: Int.max, count: numLaps + 1)\\n        dpNoChange[0] = 0\\n        for tire in tires {\\n            var sum = tire[0]\\n            var now = tire[0]\\n            dpNoChange[1] = min(dpNoChange[1], sum)   \\n            for n in 2...numLaps {\\n                now *= tire[1]\\n                // due to this guard statement, the real value array will be small enough to be a constant.\\n                // according to the parameter space, it will be under 20\\n                guard now < tire[0] + changeTime else { break }\\n                sum += now\\n                dpNoChange[n] = min(dpNoChange[n], sum)\\n            }\\n        }\\n        // the real dp\\n        // dp[n] = the minimum time to go n laps wheather we go with one tire or multiple tires.\\n        var dp = [Int](repeating: Int.max, count: numLaps + 1)\\n        dp[0] = 0\\n        dp[1] = dpNoChange[1]\\n        // text justification DP\\n        // dp[n] = min(dp[n - 1] + changeTime + dpNoChange[1], dp[n - 2] + changeTime + dpNoChange[2], ...)\\n        for n in 2...numLaps {\\n\\t\\t\\t// start with just one tire lap time or Int.max, which indicates the tire MUST be changed.\\n            dp[n] = dpNoChange[n]\\n            for i in 1..<n {\\n                // prevent useless calculation & make it constant\\n                guard dpNoChange[i] != Int.max else { break }\\n                dp[n] = min(dp[n], dpNoChange[i] + changeTime + dp[n - i])\\n            }\\n        }\\n        return dp[numLaps]\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1817795,
                "title": "javascript",
                "content": "Thanks to [@rupakk](https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1804216/Easy-to-Understand-oror-Clean-C%2B%2B-Code-oror-DP-%2B-Greedy)\\n```\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {\\n\\t// Step 1: Fill the DP without change tire\\n\\t// DP[i]: Min cost to complete lap i using same tire\\n\\tlet dp = new Array(numLaps + 1).fill(Infinity);\\n\\tfor (let [f, r] of tires) {\\n\\t\\tdp[1] = Math.min(dp[1], f);\\n\\t\\tlet currentLapTime = f;\\n\\t\\tlet totalLapTime = f;\\n\\t\\tlet lapCnt = 2;\\n\\t\\twhile (currentLapTime < changeTime + f) {\\n\\t\\t\\tcurrentLapTime *= r;\\n\\t\\t\\ttotalLapTime += currentLapTime;\\n\\t\\t\\tdp[lapCnt] = Math.min(dp[lapCnt], totalLapTime);\\n\\t\\t\\tlapCnt++;\\n\\t\\t}\\n\\t}\\n\\n    // Step 2: in each j-th lap, we can either continue useing same tire or change a new tire\\n    // |---------|----------|\\n    // 1---------j----------i\\n    //  dp[j]    |  dp[i-j]\\n\\t//           |\\n\\t//         change\\n\\tfor (let i = 1; i <= numLaps; i++) {\\n\\t\\tfor (let j = 1; j < i; j++) {\\n\\t\\t\\tdp[i] = Math.min(dp[i], dp[j] + changeTime + dp[i - j]);\\n\\t\\t}\\n\\t}\\n\\treturn dp[numLaps];    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {\\n\\t// Step 1: Fill the DP without change tire\\n\\t// DP[i]: Min cost to complete lap i using same tire\\n\\tlet dp = new Array(numLaps + 1).fill(Infinity);\\n\\tfor (let [f, r] of tires) {\\n\\t\\tdp[1] = Math.min(dp[1], f);\\n\\t\\tlet currentLapTime = f;\\n\\t\\tlet totalLapTime = f;\\n\\t\\tlet lapCnt = 2;\\n\\t\\twhile (currentLapTime < changeTime + f) {\\n\\t\\t\\tcurrentLapTime *= r;\\n\\t\\t\\ttotalLapTime += currentLapTime;\\n\\t\\t\\tdp[lapCnt] = Math.min(dp[lapCnt], totalLapTime);\\n\\t\\t\\tlapCnt++;\\n\\t\\t}\\n\\t}\\n\\n    // Step 2: in each j-th lap, we can either continue useing same tire or change a new tire\\n    // |---------|----------|\\n    // 1---------j----------i\\n    //  dp[j]    |  dp[i-j]\\n\\t//           |\\n\\t//         change\\n\\tfor (let i = 1; i <= numLaps; i++) {\\n\\t\\tfor (let j = 1; j < i; j++) {\\n\\t\\t\\tdp[i] = Math.min(dp[i], dp[j] + changeTime + dp[i - j]);\\n\\t\\t}\\n\\t}\\n\\treturn dp[numLaps];    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1817510,
                "title": "python-dp-with-explanation",
                "content": "For n laps, we could \\n1. change tire after i laps, 1<=i<=n-1\\n2. don\\'t change lap through the whole race\\n\\nThus, we have:\\n* \\t**dp[n] = min{ dp[i] + dp[n-i] + changeTime  for 1<=i<=n-1, noChangeTime(n)}**\\n\\nIf we compute no-change-time for all n laps, it will cause Time Limit Exceeded. ( see the code that has been commented)\\n\\n**Actually, if for *n* laps, changing tires is better than never changing, then for *n+1* laps,  changing is better too.**\\n\\nCheck the code\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        # noChangeMin = [0] + [min([t[0] * (1-t[1]**i) // (1-t[1]) for t in tires]) for i in range(1, numLaps+1)]\\n        dp = [0, min([t[0] for t in tires])]\\n        noChangeWorks = True\\n        for n in range(2, numLaps + 1):\\n            curMin = min([dp[i] + dp[n-i] + changeTime for i in range(1, n//2 + 1)])\\n            if noChangeWorks:\\n                noChangeMin = min([t[0] * (1-t[1]**n) // (1-t[1]) for t in tires])\\n                if noChangeMin > curMin:\\n                    noChangeWorks = False\\n                else:\\n                    curMin = noChangeMin\\n            dp.append(curMin)\\n        return dp[-1]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        # noChangeMin = [0] + [min([t[0] * (1-t[1]**i) // (1-t[1]) for t in tires]) for i in range(1, numLaps+1)]\\n        dp = [0, min([t[0] for t in tires])]\\n        noChangeWorks = True\\n        for n in range(2, numLaps + 1):\\n            curMin = min([dp[i] + dp[n-i] + changeTime for i in range(1, n//2 + 1)])\\n            if noChangeWorks:\\n                noChangeMin = min([t[0] * (1-t[1]**n) // (1-t[1]) for t in tires])\\n                if noChangeMin > curMin:\\n                    noChangeWorks = False\\n                else:\\n                    curMin = noChangeMin\\n            dp.append(curMin)\\n        return dp[-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817506,
                "title": "javascript-solutions-tle",
                "content": "Brute-force consider all possibilities for total `T` laps: we can start with any `i`<sup>th</sup> tire from 0..N-1.  Then for each `lap` from 0..T-1 we have 2 choices:\\n\\n1. \\uD83D\\uDEAB exclude tire change\\n2. \\u2705 include tire change (with penalty `K`)\\n\\t* note: we consider all `i`<sup>th</sup> tires from 0..N-1 as candidates `cand`\\n\\nThe optimal solution is formulated and returned as the `best` accumulated `cost` as the recursive stack unwinds.\\n\\n---\\n\\n*Top-down (TLE)*\\n\\n```\\nlet minimumFinishTime = (A, K, T, best = Infinity) => {\\n    let N = A.length;\\n    let cost = (f, r, x) => f * Math.pow(r, x - 1);\\n    let go = (i, lap = 0, x = 1) => {\\n        if (lap == T)\\n            return 0;\\n        let best = go(i, lap + 1, x + 1);     // \\uD83D\\uDEAB exclude tire change\\n        for (let i = 0; i < N; ++i) {\\n            let cand = K + go(i, lap + 1, 1); // \\u2705 include tire change\\n            best = Math.min(best, cand);\\n        }\\n        let [f, r] = A[i];\\n        return best + cost(f, r, x);\\n    };\\n    for (let i = 0; i < N; ++i)\\n        best = Math.min(best, go(i));\\n    return best;\\n};\\n```\\n\\n*Top-down with Memo (TLE)*\\n```\\nlet minimumFinishTime = (A, K, T, best = Infinity, m = new Map()) => {\\n    let N = A.length;\\n    let cost = (f, r, x) => f * Math.pow(r, x - 1);\\n    let go = (i, lap = 0, x = 1) => {\\n        if (lap == T)\\n            return 0;\\n        let k = `${i},${lap},${x}`;\\n        if (!m.has(k)) {\\n            let best = go(i, lap + 1, x + 1);     // \\uD83D\\uDEAB exclude tire change\\n            for (let i = 0; i < N; ++i) {\\n                let cand = K + go(i, lap + 1, 1); // \\u2705 include tire change\\n                best = Math.min(best, cand);\\n            }\\n            let [f, r] = A[i];\\n            m.set(k, best + cost(f, r, x));\\n        }\\n        return m.get(k);\\n    };\\n    for (let i = 0; i < N; ++i)\\n        best = Math.min(best, go(i));\\n    return best;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet minimumFinishTime = (A, K, T, best = Infinity) => {\\n    let N = A.length;\\n    let cost = (f, r, x) => f * Math.pow(r, x - 1);\\n    let go = (i, lap = 0, x = 1) => {\\n        if (lap == T)\\n            return 0;\\n        let best = go(i, lap + 1, x + 1);     // \\uD83D\\uDEAB exclude tire change\\n        for (let i = 0; i < N; ++i) {\\n            let cand = K + go(i, lap + 1, 1); // \\u2705 include tire change\\n            best = Math.min(best, cand);\\n        }\\n        let [f, r] = A[i];\\n        return best + cost(f, r, x);\\n    };\\n    for (let i = 0; i < N; ++i)\\n        best = Math.min(best, go(i));\\n    return best;\\n};\\n```\n```\\nlet minimumFinishTime = (A, K, T, best = Infinity, m = new Map()) => {\\n    let N = A.length;\\n    let cost = (f, r, x) => f * Math.pow(r, x - 1);\\n    let go = (i, lap = 0, x = 1) => {\\n        if (lap == T)\\n            return 0;\\n        let k = `${i},${lap},${x}`;\\n        if (!m.has(k)) {\\n            let best = go(i, lap + 1, x + 1);     // \\uD83D\\uDEAB exclude tire change\\n            for (let i = 0; i < N; ++i) {\\n                let cand = K + go(i, lap + 1, 1); // \\u2705 include tire change\\n                best = Math.min(best, cand);\\n            }\\n            let [f, r] = A[i];\\n            m.set(k, best + cost(f, r, x));\\n        }\\n        return m.get(k);\\n    };\\n    for (let i = 0; i < N; ++i)\\n        best = Math.min(best, go(i));\\n    return best;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808496,
                "title": "python-3-greedy-preprocessing-dp-97-time",
                "content": "![image](https://assets.leetcode.com/users/images/47517fea-3a4c-4889-a132-33f5145b015f_1646110422.8115597.png)\\n\\n\\nFor each type of tire, if we assume that it is the only type we have, there is an optimal lap after which switching on a new one of the same type will save time. The lap number, x, is given by ` f * r ^ x >= f + changeTime`, and `f * r ^ (x - 1) < changeTime + f`. Note that `ri >= 2`. `x` is 1-indexed in my implementation.\\n\\nIn case `f * r ^ x == changeTime`, we should change after `x - 1` laps. For instance, `f = 2, r = 2, changeTime = 6`, `f * r ^ 3 == changeTime + f`. If finish lap 3 in 8 seconds, change tire and continue, it will take totally 6 + 2 seconds for lap 4; however, if we change after lap 2, it takes the same 8 seconds to complete lap 3, but lap 4 can be taken in 6 seconds. x is calculated as `ceil(log(1 + changeTime / f, r))`.\\n\\nNext, for a tire with an optimal lap number `x`, we dont need to keep driving with it for `x` laps. In fact, we can choose to stick with it for [1, 2, ... x inclusively] laps, and the total time to use it for `y` laps is given as `f * (1 - r ^ y) / (1 - r)`. \\n\\nNow we consider having mutliple types of tires. For each tire, calculate its optimal lap number `x`, and then for `y in [1, 2, ... x inclusively]`, calculate its total lap time. For each `y`, sort the total lap time from all candidate tires ascendingly, and the smallest one is the best candidate tire to run with continously for `y` loops.\\n\\nThe next part is DP, pretty similar to coin change. Only note that if a tire used to finish the last lap, there is no changeTime because we finish the race.\\n\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        dc_laps = defaultdict(list)\\n        for f, r in tires:\\n            x = ceil(log(1 + changeTime / f, r))\\n            dt = f\\n            t = 0\\n            for y in range(1, x + 1):\\n                if y > 1:\\n                    dt *= r\\n                t += dt\\n                dc_laps[y].append(t)\\n        laps = list(dc_laps.keys())\\n        laps.sort()\\n        for lap_con in laps:\\n            # 0th is the best total time for successive lap_con laps\\n            dc_laps[lap_con].sort()\\n        \\n        # coin change\\n        dp = [inf] * (numLaps + 1)\\n        dp[0] = 0\\n        for lap_con in laps:\\n            lap_time = dc_laps[lap_con][0]\\n            for i in range(numLaps + 1):\\n                if dp[i] < inf:\\n                    j = i + lap_con # finish lap_con laps then change tire\\n                    if j < numLaps:\\n                        dp[j] = min(dp[j], dp[i] + lap_time + changeTime)\\n                    elif j == numLaps:\\n                        dp[j] = min(dp[j], dp[i] + lap_time)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t    break\\n        return dp[-1]\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        dc_laps = defaultdict(list)\\n        for f, r in tires:\\n            x = ceil(log(1 + changeTime / f, r))\\n            dt = f\\n            t = 0\\n            for y in range(1, x + 1):\\n                if y > 1:\\n                    dt *= r\\n                t += dt\\n                dc_laps[y].append(t)\\n        laps = list(dc_laps.keys())\\n        laps.sort()\\n        for lap_con in laps:\\n            # 0th is the best total time for successive lap_con laps\\n            dc_laps[lap_con].sort()\\n        \\n        # coin change\\n        dp = [inf] * (numLaps + 1)\\n        dp[0] = 0\\n        for lap_con in laps:\\n            lap_time = dc_laps[lap_con][0]\\n            for i in range(numLaps + 1):\\n                if dp[i] < inf:\\n                    j = i + lap_con # finish lap_con laps then change tire\\n                    if j < numLaps:\\n                        dp[j] = min(dp[j], dp[i] + lap_time + changeTime)\\n                    elif j == numLaps:\\n                        dp[j] = min(dp[j], dp[i] + lap_time)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t    break\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807406,
                "title": "o-nlogn-time-o-n-space-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int n) {\\n        vector<long long > dp(n+1,1e9);\\n        \\n        for(int i=0;i<tires.size();i++){\\n            long long sum=0;\\n            long long a=tires[i][0],b=tires[i][1];\\n            for(int j=1;j<=n;j++){\\n                if(a<1e9){\\n                    sum+=a;\\n                    dp[j]=min(dp[j],sum);\\n                    a*=b;\\n                }\\n                else break;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<i;j++){\\n                dp[i]=min(dp[i],dp[j]+changeTime+dp[i-j]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int n) {\\n        vector<long long > dp(n+1,1e9);\\n        \\n        for(int i=0;i<tires.size();i++){\\n            long long sum=0;\\n            long long a=tires[i][0],b=tires[i][1];\\n            for(int j=1;j<=n;j++){\\n                if(a<1e9){\\n                    sum+=a;\\n                    dp[j]=min(dp[j],sum);\\n                    a*=b;\\n                }\\n                else break;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<i;j++){\\n                dp[i]=min(dp[i],dp[j]+changeTime+dp[i-j]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806159,
                "title": "precompute-best-lap-times-and-dp-c-top-down-and-bottom-up-approach-with-comments",
                "content": "**Top Down approach**\\n\\n```\\nclass Solution {\\nprivate:\\n    int f(int n, int changeTime, vector <int> &dp, vector <int> &best, int maxLaps){\\n        \\n        if(n == 0) return -changeTime;\\n        \\n        int mini = 1e9;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        // taking the best laptime for every lap and checking all the combinations and storing the minimum value\\n        \\n        for(int laps = 1; laps <= min(maxLaps, n); laps++){\\n            int time = best[laps] + changeTime + f(n - laps, changeTime, dp, best, maxLaps);\\n            mini = min(mini, time);\\n        }\\n        \\n        return dp[n] = mini;\\n    }\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<int> best(numLaps + 1, 1e9);\\n        int maxLaps = 0;\\n        \\n        //calculate the best lap time for every lap\\n        for(auto tire : tires){\\n            int f = tire[0];\\n            int r = tire[1];\\n            \\n            \\n            long long  currLapTime = f;\\n            long long time = f;\\n            \\n            //getting the lap time for the current tire\\n            for(int laps = 1; laps <= numLaps and currLapTime < changeTime + f; laps++ ){\\n                \\n                // if the current time is less than the best lap time for the current lap\\n                if(time < best[laps]){\\n                    best[laps] = time;\\n                }\\n                \\n                // storing the maxLaps\\n                maxLaps = max(maxLaps, laps);\\n                \\n                //incrementing the currentLapTime and time\\n                currLapTime *= r;\\n                time += currLapTime;\\n                \\n            }\\n        }\\n        \\n         vector <int> dp(numLaps + 1, -1);\\n        \\n        return f(numLaps, changeTime, dp, best, maxLaps);\\n    }\\n};\\n```\\n\\n**Bottom UP approach**\\n\\n```\\nclass Solution {\\n\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<int> best(numLaps + 1, 1e9);\\n        int maxLaps = 0;\\n        \\n        //calculate the best lap time for every lap\\n        for(auto tire : tires){\\n            int f = tire[0];\\n            int r = tire[1];\\n            \\n            \\n            long long  currLapTime = f;\\n            long long time = f;\\n            \\n            //getting the lap time for the current tire\\n            for(int laps = 1; laps <= numLaps and currLapTime < changeTime + f; laps++ ){\\n                \\n                // if the current time is less than the best lap time for the current lap\\n                if(time < best[laps]){\\n                    best[laps] = time;\\n                }\\n                \\n                // storing the maxLaps\\n                maxLaps = max(maxLaps, laps);\\n                \\n                //incrementing the currentLapTime and time\\n                currLapTime *= r;\\n                time += currLapTime;\\n                \\n            }\\n        }\\n        \\n        vector <int> dp(numLaps + 1, 0);\\n        \\n        dp[0] = -changeTime;\\n        \\n        for(int i = 1; i <= numLaps; i++){\\n            int mini = 1e9;\\n              // taking the best laptime for every lap and checking all the combinations and storing the minimum value\\n            for(int j = 1; j <= min(i, maxLaps); j++){\\n                int time = best[j] + changeTime + dp[i - j];\\n                mini = min(mini, time);\\n            }\\n            \\n            dp[i] = mini;\\n        }\\n        \\n        \\n        \\n        return dp[numLaps];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int f(int n, int changeTime, vector <int> &dp, vector <int> &best, int maxLaps){\\n        \\n        if(n == 0) return -changeTime;\\n        \\n        int mini = 1e9;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        // taking the best laptime for every lap and checking all the combinations and storing the minimum value\\n        \\n        for(int laps = 1; laps <= min(maxLaps, n); laps++){\\n            int time = best[laps] + changeTime + f(n - laps, changeTime, dp, best, maxLaps);\\n            mini = min(mini, time);\\n        }\\n        \\n        return dp[n] = mini;\\n    }\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<int> best(numLaps + 1, 1e9);\\n        int maxLaps = 0;\\n        \\n        //calculate the best lap time for every lap\\n        for(auto tire : tires){\\n            int f = tire[0];\\n            int r = tire[1];\\n            \\n            \\n            long long  currLapTime = f;\\n            long long time = f;\\n            \\n            //getting the lap time for the current tire\\n            for(int laps = 1; laps <= numLaps and currLapTime < changeTime + f; laps++ ){\\n                \\n                // if the current time is less than the best lap time for the current lap\\n                if(time < best[laps]){\\n                    best[laps] = time;\\n                }\\n                \\n                // storing the maxLaps\\n                maxLaps = max(maxLaps, laps);\\n                \\n                //incrementing the currentLapTime and time\\n                currLapTime *= r;\\n                time += currLapTime;\\n                \\n            }\\n        }\\n        \\n         vector <int> dp(numLaps + 1, -1);\\n        \\n        return f(numLaps, changeTime, dp, best, maxLaps);\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<int> best(numLaps + 1, 1e9);\\n        int maxLaps = 0;\\n        \\n        //calculate the best lap time for every lap\\n        for(auto tire : tires){\\n            int f = tire[0];\\n            int r = tire[1];\\n            \\n            \\n            long long  currLapTime = f;\\n            long long time = f;\\n            \\n            //getting the lap time for the current tire\\n            for(int laps = 1; laps <= numLaps and currLapTime < changeTime + f; laps++ ){\\n                \\n                // if the current time is less than the best lap time for the current lap\\n                if(time < best[laps]){\\n                    best[laps] = time;\\n                }\\n                \\n                // storing the maxLaps\\n                maxLaps = max(maxLaps, laps);\\n                \\n                //incrementing the currentLapTime and time\\n                currLapTime *= r;\\n                time += currLapTime;\\n                \\n            }\\n        }\\n        \\n        vector <int> dp(numLaps + 1, 0);\\n        \\n        dp[0] = -changeTime;\\n        \\n        for(int i = 1; i <= numLaps; i++){\\n            int mini = 1e9;\\n              // taking the best laptime for every lap and checking all the combinations and storing the minimum value\\n            for(int j = 1; j <= min(i, maxLaps); j++){\\n                int time = best[j] + changeTime + dp[i - j];\\n                mini = min(mini, time);\\n            }\\n            \\n            dp[i] = mini;\\n        }\\n        \\n        \\n        \\n        return dp[numLaps];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805808,
                "title": "c-pre-computation-mcm-variation-dp",
                "content": "Pre - compute the best time for consecutive laps and then apply DP using MCM variation\\n```\\nclass Solution {\\n    vector<int> bestTime;\\n    vector<int> dp;\\n    int getMinTime(int numLaps, int changeTime) {\\n        if(dp[numLaps - 1] != -1) return dp[numLaps - 1];\\n        int minTime = 1e9;\\n        if(bestTime[numLaps - 1] != 1e9) minTime = bestTime[numLaps - 1];\\n        // MCM variation\\n        for(int k = 1; k <= numLaps / 2; k++) {\\n            minTime = min(minTime, getMinTime(k, changeTime) + getMinTime(numLaps - k, changeTime) + changeTime);\\n        }\\n        return dp[numLaps - 1] = minTime;\\n    }\\n  public:\\n    int minimumFinishTime(vector<vector<int>> &tires, int changeTime, int numLaps) {\\n        bestTime.resize(numLaps, 1e9);\\n        // Compute best time for consecutive laps\\n        for(auto &tire: tires) {\\n            int fi = tire[0], ri = 1;\\n            long long totalTime = 0;\\n            for(int lap = 0; lap < numLaps; lap++) {\\n                long long currLapTime = 1LL * fi * ri;\\n                totalTime += currLapTime;\\n                // Breaking point\\n                if(fi + changeTime < currLapTime) break;\\n                bestTime[lap] = min(1LL * bestTime[lap], totalTime);\\n                ri *= tire[1];\\n            }\\n        }\\n        dp.resize(numLaps, -1);\\n        return getMinTime(numLaps, changeTime);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> bestTime;\\n    vector<int> dp;\\n    int getMinTime(int numLaps, int changeTime) {\\n        if(dp[numLaps - 1] != -1) return dp[numLaps - 1];\\n        int minTime = 1e9;\\n        if(bestTime[numLaps - 1] != 1e9) minTime = bestTime[numLaps - 1];\\n        // MCM variation\\n        for(int k = 1; k <= numLaps / 2; k++) {\\n            minTime = min(minTime, getMinTime(k, changeTime) + getMinTime(numLaps - k, changeTime) + changeTime);\\n        }\\n        return dp[numLaps - 1] = minTime;\\n    }\\n  public:\\n    int minimumFinishTime(vector<vector<int>> &tires, int changeTime, int numLaps) {\\n        bestTime.resize(numLaps, 1e9);\\n        // Compute best time for consecutive laps\\n        for(auto &tire: tires) {\\n            int fi = tire[0], ri = 1;\\n            long long totalTime = 0;\\n            for(int lap = 0; lap < numLaps; lap++) {\\n                long long currLapTime = 1LL * fi * ri;\\n                totalTime += currLapTime;\\n                // Breaking point\\n                if(fi + changeTime < currLapTime) break;\\n                bestTime[lap] = min(1LL * bestTime[lap], totalTime);\\n                ri *= tire[1];\\n            }\\n        }\\n        dp.resize(numLaps, -1);\\n        return getMinTime(numLaps, changeTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805656,
                "title": "typescript-dp-commented-explained-with-helper-functions-for-clarity",
                "content": "```\\ntype Tire = [number, number];\\n\\nfunction minimumFinishTime(tires: Tire[], changeTime: number, numLaps: number) {\\n  // For a specific tire, calculate how long a specific lap takes. For example, the tire\\n  // [3,2] takes 12 seconds to complete the third lap.\\n  const secondsForSpecificLap = (tire: Tire, lap: number) => tire[0] * tire[1] ** (lap - 1);\\n\\n  // Figure out how long you can use a specific tire before it should be changed. At a certain\\n  // point, the tire is slow enough that it makes sense to pay the changeTime penalty to get a\\n  // fast new tire. This decreases overall running time because it avoids calculations that\\n  // involve very old tires.\\n  const maxLapsForTire = (tire: Tire) => {\\n    const getNewTire = secondsForSpecificLap(tire, 1) + changeTime;\\n    for (let laps = 2; laps <= 1000; laps++) {\\n      if (secondsForSpecificLap(tire, laps) > getNewTire) return laps - 1;\\n    }\\n    return 1000;\\n  };\\n\\n  // Figure out how long it takes to complete a certain number of laps with a particular\\n  // tire, assuming the tire is never changed. The result does not include the initial time\\n  // required to install the tire.\\n  const secondsForNLaps = (tire: Tire, laps: number) => {\\n    let lap = 1;\\n    let result = 0;\\n    while (lap <= laps) {\\n      result += secondsForSpecificLap(tire, lap);\\n      lap++;\\n    }\\n    return result;\\n  };\\n\\n  // Calculate the fastest way to travel a certain number of laps, assuming no tire changes.\\n  // This simply walks through every tire and every number of possible laps that tire can\\n  // complete (before it should be changed), and tracks the fastest/minimum seconds for that\\n  // number of laps. For example, if tire A completes 3 laps in 5 seconds, tire B completes\\n  // 3 laps in 2 seconds, and tire C completes 3 laps in 8 seconds, we\\'ll store that 3 laps can\\n  // be completed in 2 seconds, since that is the minimum of 5, 2, and 8.\\n  const minSecondsForNLaps: Map<number, number> = new Map();\\n  for (const t of tires) {\\n    for (let laps = 1; laps <= maxLapsForTire(t); laps++) {\\n      const duration = secondsForNLaps(t, laps);\\n      const fastest = minSecondsForNLaps.get(laps);\\n      if (fastest === undefined || duration < fastest) {\\n        minSecondsForNLaps.set(laps, duration);\\n      }\\n    }\\n  }\\n\\n  // Just do a DFS to figure out the fastest completion time. At each step, consider every\\n  // possible number of laps that can be completed before a tire change.\\n  const memo: Map<number, number> = new Map();\\n  const minFinishTime = (numLaps: number): number => {\\n    if (numLaps === 0) return 0;\\n    let fastest = memo.get(numLaps);\\n    if (fastest !== undefined) return fastest;\\n    fastest = Number.POSITIVE_INFINITY;\\n    for (let laps = 1; laps <= Math.min(minSecondsForNLaps.size, numLaps); laps++) {\\n      const seconds = changeTime + minSecondsForNLaps.get(laps)! + minFinishTime(numLaps - laps);\\n      fastest = Math.min(fastest, seconds);\\n    }\\n    memo.set(numLaps, fastest);\\n    return fastest;\\n  };\\n  return minFinishTime(numLaps) - changeTime;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype Tire = [number, number];\\n\\nfunction minimumFinishTime(tires: Tire[], changeTime: number, numLaps: number) {\\n  // For a specific tire, calculate how long a specific lap takes. For example, the tire\\n  // [3,2] takes 12 seconds to complete the third lap.\\n  const secondsForSpecificLap = (tire: Tire, lap: number) => tire[0] * tire[1] ** (lap - 1);\\n\\n  // Figure out how long you can use a specific tire before it should be changed. At a certain\\n  // point, the tire is slow enough that it makes sense to pay the changeTime penalty to get a\\n  // fast new tire. This decreases overall running time because it avoids calculations that\\n  // involve very old tires.\\n  const maxLapsForTire = (tire: Tire) => {\\n    const getNewTire = secondsForSpecificLap(tire, 1) + changeTime;\\n    for (let laps = 2; laps <= 1000; laps++) {\\n      if (secondsForSpecificLap(tire, laps) > getNewTire) return laps - 1;\\n    }\\n    return 1000;\\n  };\\n\\n  // Figure out how long it takes to complete a certain number of laps with a particular\\n  // tire, assuming the tire is never changed. The result does not include the initial time\\n  // required to install the tire.\\n  const secondsForNLaps = (tire: Tire, laps: number) => {\\n    let lap = 1;\\n    let result = 0;\\n    while (lap <= laps) {\\n      result += secondsForSpecificLap(tire, lap);\\n      lap++;\\n    }\\n    return result;\\n  };\\n\\n  // Calculate the fastest way to travel a certain number of laps, assuming no tire changes.\\n  // This simply walks through every tire and every number of possible laps that tire can\\n  // complete (before it should be changed), and tracks the fastest/minimum seconds for that\\n  // number of laps. For example, if tire A completes 3 laps in 5 seconds, tire B completes\\n  // 3 laps in 2 seconds, and tire C completes 3 laps in 8 seconds, we\\'ll store that 3 laps can\\n  // be completed in 2 seconds, since that is the minimum of 5, 2, and 8.\\n  const minSecondsForNLaps: Map<number, number> = new Map();\\n  for (const t of tires) {\\n    for (let laps = 1; laps <= maxLapsForTire(t); laps++) {\\n      const duration = secondsForNLaps(t, laps);\\n      const fastest = minSecondsForNLaps.get(laps);\\n      if (fastest === undefined || duration < fastest) {\\n        minSecondsForNLaps.set(laps, duration);\\n      }\\n    }\\n  }\\n\\n  // Just do a DFS to figure out the fastest completion time. At each step, consider every\\n  // possible number of laps that can be completed before a tire change.\\n  const memo: Map<number, number> = new Map();\\n  const minFinishTime = (numLaps: number): number => {\\n    if (numLaps === 0) return 0;\\n    let fastest = memo.get(numLaps);\\n    if (fastest !== undefined) return fastest;\\n    fastest = Number.POSITIVE_INFINITY;\\n    for (let laps = 1; laps <= Math.min(minSecondsForNLaps.size, numLaps); laps++) {\\n      const seconds = changeTime + minSecondsForNLaps.get(laps)! + minFinishTime(numLaps - laps);\\n      fastest = Math.min(fastest, seconds);\\n    }\\n    memo.set(numLaps, fastest);\\n    return fastest;\\n  };\\n  return minFinishTime(numLaps) - changeTime;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805310,
                "title": "java-dp-easy-to-understand",
                "content": "\\n```\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int minf = Integer.MAX_VALUE;\\n\\n        // find the minimum of f, to deal with special case and stronger constraints later. \\n        for (int[] tire: tires){\\n            minf = Math.min(minf, tire[0]); \\n        }\\n        // if min-f >= changeTime, we can return early\\n        if (minf >= changeTime){\\n            return minf * numLaps + changeTime * (numLaps - 1);\\n        }\\n        \\n        // shortest[i] record shortest time that one single tire is worth to go the i-th laps \\n        // worth to go means the i-th lap time is shorter than changeTime + f\\n\\n        int[] shortest = new int[numLaps + 1];\\n        Arrays.fill(shortest, Integer.MAX_VALUE);\\n        int len = 0; \\n\\n        // traverse all tires, and update the shortest[i]\\n        // this shortest time is available from [1, len] in the array \\n        // len is updated in the traverse        \\n        for (int[] tire: tires){\\n            int f = tire[0];\\n            int r = tire[1];\\n\\t\\t\\t// index start from 1 to be consistent with numLaps \\n            int index = 1; \\n            int t = f; \\n            int sum = t;\\n            // use changeTime + minf here, which is a strong constraints than changeTime + f\\n            while (t <= changeTime + minf && index <= numLaps){\\n                shortest[index] = Math.min(shortest[index], sum);\\n                t = t * r;\\n                sum += t;\\n                index++;\\n            }\\n            len = Math.max(len, index - 1);\\n        }\\n\\n        for (int i = 2; i <= numLaps; i++){            \\n\\t\\t    // for j > Math.min(i/2, len), it\\'s simply recombination of the values of shortest [1:len]\\n\\t\\t\\t// it\\'s ok to go furthur for the loop, just repeat the Math.min computation\\n            for (int j = 1; j <= Math.min(i/2, len); j++){\\n                shortest[i] = Math.min(shortest[i], shortest[j] + shortest[i - j] + changeTime);\\n            }\\n            \\n        }\\n        \\n        return shortest[numLaps];\\n        \\n    }\\n    \\n    \\n```",
                "solutionTags": [],
                "code": "```\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        int minf = Integer.MAX_VALUE;\\n\\n        // find the minimum of f, to deal with special case and stronger constraints later. \\n        for (int[] tire: tires){\\n            minf = Math.min(minf, tire[0]); \\n        }\\n        // if min-f >= changeTime, we can return early\\n        if (minf >= changeTime){\\n            return minf * numLaps + changeTime * (numLaps - 1);\\n        }\\n        \\n        // shortest[i] record shortest time that one single tire is worth to go the i-th laps \\n        // worth to go means the i-th lap time is shorter than changeTime + f\\n\\n        int[] shortest = new int[numLaps + 1];\\n        Arrays.fill(shortest, Integer.MAX_VALUE);\\n        int len = 0; \\n\\n        // traverse all tires, and update the shortest[i]\\n        // this shortest time is available from [1, len] in the array \\n        // len is updated in the traverse        \\n        for (int[] tire: tires){\\n            int f = tire[0];\\n            int r = tire[1];\\n\\t\\t\\t// index start from 1 to be consistent with numLaps \\n            int index = 1; \\n            int t = f; \\n            int sum = t;\\n            // use changeTime + minf here, which is a strong constraints than changeTime + f\\n            while (t <= changeTime + minf && index <= numLaps){\\n                shortest[index] = Math.min(shortest[index], sum);\\n                t = t * r;\\n                sum += t;\\n                index++;\\n            }\\n            len = Math.max(len, index - 1);\\n        }\\n\\n        for (int i = 2; i <= numLaps; i++){            \\n\\t\\t    // for j > Math.min(i/2, len), it\\'s simply recombination of the values of shortest [1:len]\\n\\t\\t\\t// it\\'s ok to go furthur for the loop, just repeat the Math.min computation\\n            for (int j = 1; j <= Math.min(i/2, len); j++){\\n                shortest[i] = Math.min(shortest[i], shortest[j] + shortest[i - j] + changeTime);\\n            }\\n            \\n        }\\n        \\n        return shortest[numLaps];\\n        \\n    }\\n    \\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805187,
                "title": "c-2188-minimum-time-to-finish-the-race",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<long> nonstop(20, INT_MAX); \\n        for (auto& tire : tires) {\\n            long prefix = tire[0], term = tire[0]; \\n            for (int i = 1; i < 20; ++i) {\\n                nonstop[i] = min(nonstop[i], prefix); \\n                term *= tire[1]; \\n                if (term >= tire[0] + changeTime) break; \\n                prefix += term; \\n            }\\n        }\\n        vector<int> dp(numLaps+1, INT_MAX); \\n        dp[1] = nonstop[1]; \\n        for (int x = 2; x <= numLaps; ++x) {\\n            if (x < 20) dp[x] = nonstop[x]; \\n            for (int xx = 1; xx < min(20, x/2+1); ++xx) \\n                dp[x] = min(dp[x], dp[xx] + dp[x-xx] + changeTime); \\n        }\\n        return dp.back(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        vector<long> nonstop(20, INT_MAX); \\n        for (auto& tire : tires) {\\n            long prefix = tire[0], term = tire[0]; \\n            for (int i = 1; i < 20; ++i) {\\n                nonstop[i] = min(nonstop[i], prefix); \\n                term *= tire[1]; \\n                if (term >= tire[0] + changeTime) break; \\n                prefix += term; \\n            }\\n        }\\n        vector<int> dp(numLaps+1, INT_MAX); \\n        dp[1] = nonstop[1]; \\n        for (int x = 2; x <= numLaps; ++x) {\\n            if (x < 20) dp[x] = nonstop[x]; \\n            for (int xx = 1; xx < min(20, x/2+1); ++xx) \\n                dp[x] = min(dp[x], dp[xx] + dp[x-xx] + changeTime); \\n        }\\n        return dp.back(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804794,
                "title": "python-sort-by-r-for-best-first-traversal-then-dynamic-programming",
                "content": "Because `cost = f*(r**lap)` , it is an exponential relation. \\n\\nIf we think `f = 1` for all the tires, then the graph of exponential lines will never overlap. With that intuition , we always want to choose the tire with lowest `r` in case all the `f` are equal. \\n\\nSo,\\n- Best first step\\n\\t-  Sort the tires with `r` first.\\n\\t-  We want to calculate the best-timing without considering the tire-change. For each tire try to `relax`(refer to dynamic programming) the best-timing and if it is not relaxed then break early.\\n\\n-  Dynamic programming step\\n\\t-  Now from the best-timing , we can calculate the best-timing considering the tire-change-time as well.\\n\\n```\\ndef minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\'\\'\\'\\n        cost = f*(r**(lp))\\n        So more the lap increases the cost increases exponentialy\\n        \\'\\'\\'\\n        tires.sort(key=itemgetter(1)) # sort based on r, to best-first traversal\\n        INF = float(\\'Inf\\')\\n        bestTimes = [(INF,INF,INF) for _ in range(numLaps)]\\n        \\n        for f,r in tires:\\n            rr = 1\\n            cost = 0\\n            lp = 0\\n            for y in range(numLaps):\\n                cost += f*rr\\n                if bestTimes[y] > (cost,rr,f):\\n                    bestTimes[y] = (cost,rr,f) # relax\\n                else:\\n                    # remember that exponential graph does not overlap, so no point of going forward\\n                    break\\n                rr *= r\\n                lp += 1\\n\\n        memo = bestTimes[:]\\n        # apply dynamic programming\\n        for currentLap in range(numLaps):\\n            # so at xth lap we can either change or not change\\n            prev_cost,prev_r,prev_f = memo[currentLap]\\n            # In case we change tire\\n            prev_cost += changeTime\\n            for nextLap in range(currentLap+1,numLaps):\\n                bcost,best_r,best_f = bestTimes[nextLap-currentLap-1]\\n                memo[nextLap] = min(memo[nextLap], (prev_cost+bcost, best_r, best_f))\\n        return memo[-1][0]\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\ndef minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        \\'\\'\\'\\n        cost = f*(r**(lp))\\n        So more the lap increases the cost increases exponentialy\\n        \\'\\'\\'\\n        tires.sort(key=itemgetter(1)) # sort based on r, to best-first traversal\\n        INF = float(\\'Inf\\')\\n        bestTimes = [(INF,INF,INF) for _ in range(numLaps)]\\n        \\n        for f,r in tires:\\n            rr = 1\\n            cost = 0\\n            lp = 0\\n            for y in range(numLaps):\\n                cost += f*rr\\n                if bestTimes[y] > (cost,rr,f):\\n                    bestTimes[y] = (cost,rr,f) # relax\\n                else:\\n                    # remember that exponential graph does not overlap, so no point of going forward\\n                    break\\n                rr *= r\\n                lp += 1\\n\\n        memo = bestTimes[:]\\n        # apply dynamic programming\\n        for currentLap in range(numLaps):\\n            # so at xth lap we can either change or not change\\n            prev_cost,prev_r,prev_f = memo[currentLap]\\n            # In case we change tire\\n            prev_cost += changeTime\\n            for nextLap in range(currentLap+1,numLaps):\\n                bcost,best_r,best_f = bestTimes[nextLap-currentLap-1]\\n                memo[nextLap] = min(memo[nextLap], (prev_cost+bcost, best_r, best_f))\\n        return memo[-1][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1804711,
                "title": "javascript-dp-solution-with-key-comments",
                "content": "```\\n/**\\n * @param {number[][]} tires\\n * @param {number} changeTime\\n * @param {number} numLaps\\n * @return {number}\\n */\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {\\n  // minOneTire[i] is min seconds run i laps with one tire\\n  const minOneTire = Array(20).fill(Infinity)\\n  for (const [f, r] of tires) {\\n    let sum = 0, seconds = f\\n    for (let i = 1; i < minOneTire.length; i += 1) {\\n      sum += seconds\\n      // Faster than f * r ** (i - 1)\\n      seconds *= r\\n      minOneTire[i] = Math.min(minOneTire[i], sum)\\n    }\\n  }\\n  \\n  // dp[i] is min seconds run i laps\\n  const dp = Array(numLaps + 1).fill(Infinity)\\n  dp[0] = 0\\n  for (let i = 1; i <= numLaps; i += 1) {\\n    for (let j = 1; j < minOneTire.length; j += 1) {\\n      if (j > i) break\\n      dp[i] = Math.min(\\n        dp[i],\\n        // Add changeTime if tire changed\\n        dp[i - j] + minOneTire[j] + (j === i ? 0 : changeTime)\\n      )\\n    }\\n  }\\n  \\n  return dp[numLaps]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} tires\\n * @param {number} changeTime\\n * @param {number} numLaps\\n * @return {number}\\n */\\nvar minimumFinishTime = function(tires, changeTime, numLaps) {\\n  // minOneTire[i] is min seconds run i laps with one tire\\n  const minOneTire = Array(20).fill(Infinity)\\n  for (const [f, r] of tires) {\\n    let sum = 0, seconds = f\\n    for (let i = 1; i < minOneTire.length; i += 1) {\\n      sum += seconds\\n      // Faster than f * r ** (i - 1)\\n      seconds *= r\\n      minOneTire[i] = Math.min(minOneTire[i], sum)\\n    }\\n  }\\n  \\n  // dp[i] is min seconds run i laps\\n  const dp = Array(numLaps + 1).fill(Infinity)\\n  dp[0] = 0\\n  for (let i = 1; i <= numLaps; i += 1) {\\n    for (let j = 1; j < minOneTire.length; j += 1) {\\n      if (j > i) break\\n      dp[i] = Math.min(\\n        dp[i],\\n        // Add changeTime if tire changed\\n        dp[i - j] + minOneTire[j] + (j === i ? 0 : changeTime)\\n      )\\n    }\\n  }\\n  \\n  return dp[numLaps]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1804202,
                "title": "python-3-geometric-progression-sum-and-dp-hint-solution-with-comments-optimization-needed",
                "content": "Run for 5300ms. Any ideas for optimization?\\n\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], ct: int, laps: int) -> int:\\n        t_nochange = defaultdict(lambda: float(\\'inf\\'))\\n        \\n        for f, r in tires:\\n            # calculate how many laps could go without changing tires\\n            # f * pow(r, p) <= f + ct\\n            p = math.ceil(math.log(1 + ct/f, r))\\n            # for each possible lap calculate cumulative sum and update the minimum time for laps\\n            # geometric progression sum = f * (pow(r, i) - 1) / (r - 1)\\n            for i in range(1, p+1):\\n                t_nochange[i] = min(t_nochange[i], f * (pow(r, i) - 1) / (r - 1))\\n            \\n        # possible max laps without changing tires\\n        max_t = max(t_nochange)   \\n        \\n        \\n        @lru_cache(None)\\n        def dp(rest_laps):\\n            if rest_laps == 0:\\n                return 0\\n            ans = float(\\'inf\\')\\n            for k in range(1, min(rest_laps, max_t) + 1):\\n                ans = min(ans, t_nochange[k] + ct + dp(rest_laps - k))\\n            \\n            return ans\\n    \\n        return int(dp(laps)) - ct # no need to change tire for first one",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "Run for 5300ms. Any ideas for optimization?\\n\\n```\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], ct: int, laps: int) -> int:\\n        t_nochange = defaultdict(lambda: float(\\'inf\\'))\\n        \\n        for f, r in tires:\\n            # calculate how many laps could go without changing tires\\n            # f * pow(r, p) <= f + ct\\n            p = math.ceil(math.log(1 + ct/f, r))\\n            # for each possible lap calculate cumulative sum and update the minimum time for laps\\n            # geometric progression sum = f * (pow(r, i) - 1) / (r - 1)\\n            for i in range(1, p+1):\\n                t_nochange[i] = min(t_nochange[i], f * (pow(r, i) - 1) / (r - 1))\\n            \\n        # possible max laps without changing tires\\n        max_t = max(t_nochange)   \\n        \\n        \\n        @lru_cache(None)\\n        def dp(rest_laps):\\n            if rest_laps == 0:\\n                return 0\\n            ans = float(\\'inf\\')\\n            for k in range(1, min(rest_laps, max_t) + 1):\\n                ans = min(ans, t_nochange[k] + ct + dp(rest_laps - k))\\n            \\n            return ans\\n    \\n        return int(dp(laps)) - ct # no need to change tire for first one",
                "codeTag": "Java"
            },
            {
                "id": 1803553,
                "title": "golang-dp-solution",
                "content": "```go\\nfunc minimumFinishTime(tires [][]int, changeTime int, numLaps int) int {\\n\\t// 2^20 > 100000, enough for this Problem\\n\\tmagicNumber := 20\\n\\tdp := make([]int, numLaps+1)\\n\\tnoChangeCost := make([]int, len(tires))\\n\\tnoChangeTotal := make([]int, len(tires))\\n\\tfor i := range noChangeCost {\\n\\t\\tnoChangeCost[i] = tires[i][0]\\n\\t\\tnoChangeTotal[i] += noChangeCost[i]\\n\\t}\\n\\tdp[0] = tires[0][0]\\n\\tfor lap := 1; lap <= numLaps; lap++ {\\n\\t\\tif lap >= magicNumber {\\n\\t\\t\\tdp[lap] = math.MaxInt64\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdp[lap] = dp[lap-1] + dp[1] + changeTime\\n\\t\\tfor idx := 0; idx < len(tires); idx++ {\\n\\t\\t\\tif noChangeCost[idx] > changeTime+dp[1] {\\n\\t\\t\\t\\t// change tire is better\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif noChangeTotal[idx] < dp[lap] {\\n\\t\\t\\t\\tdp[lap] = noChangeTotal[idx]\\n\\t\\t\\t}\\n\\t\\t\\tnoChangeCost[idx] *= tires[idx][1]\\n\\t\\t\\tnoChangeTotal[idx] += noChangeCost[idx]\\n\\t\\t}\\n\\t}\\n\\tfor lap := 2; lap <= numLaps; lap++ {\\n\\t\\tfor more := 1; more < magicNumber && more < lap; more++ {\\n\\t\\t\\tif v := dp[more]+dp[lap-more]+changeTime; v < dp[lap] {\\n\\t\\t\\t\\tdp[lap] = v\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[numLaps]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc minimumFinishTime(tires [][]int, changeTime int, numLaps int) int {\\n\\t// 2^20 > 100000, enough for this Problem\\n\\tmagicNumber := 20\\n\\tdp := make([]int, numLaps+1)\\n\\tnoChangeCost := make([]int, len(tires))\\n\\tnoChangeTotal := make([]int, len(tires))\\n\\tfor i := range noChangeCost {\\n\\t\\tnoChangeCost[i] = tires[i][0]\\n\\t\\tnoChangeTotal[i] += noChangeCost[i]\\n\\t}\\n\\tdp[0] = tires[0][0]\\n\\tfor lap := 1; lap <= numLaps; lap++ {\\n\\t\\tif lap >= magicNumber {\\n\\t\\t\\tdp[lap] = math.MaxInt64\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdp[lap] = dp[lap-1] + dp[1] + changeTime\\n\\t\\tfor idx := 0; idx < len(tires); idx++ {\\n\\t\\t\\tif noChangeCost[idx] > changeTime+dp[1] {\\n\\t\\t\\t\\t// change tire is better\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif noChangeTotal[idx] < dp[lap] {\\n\\t\\t\\t\\tdp[lap] = noChangeTotal[idx]\\n\\t\\t\\t}\\n\\t\\t\\tnoChangeCost[idx] *= tires[idx][1]\\n\\t\\t\\tnoChangeTotal[idx] += noChangeCost[idx]\\n\\t\\t}\\n\\t}\\n\\tfor lap := 2; lap <= numLaps; lap++ {\\n\\t\\tfor more := 1; more < magicNumber && more < lap; more++ {\\n\\t\\t\\tif v := dp[more]+dp[lap-more]+changeTime; v < dp[lap] {\\n\\t\\t\\t\\tdp[lap] = v\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[numLaps]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803431,
                "title": "swift-i-finally-got-it-under-the-time-memory-limit-1944-ms-25-mb",
                "content": "I couldn\\'t get it under during the contest, but I took some time to think and came back with some optimizations and finally got it. I later read that you can just pre-compute the no-tire-change times up to lap 17 and not worry about dynamically figuring out when to stop, but this is faster and anyways, I worked really hard on this, so I am posting it, even though keeping track dynamically makes it more complicated! I also included the slower, hard-coded, max depth of 17 version down below.\\n\\nEdit: rh137, my source for the hardcoding idea, pointed out that the cutoff needs to be higher than 16, my original cut-off. 17 appears to work!\\n\\n```\\nclass Solution {\\n    func minimumFinishTime(_ tires: [[Int]], _ changeTime: Int, _ numLaps: Int) -> Int {\\n        //the maxProductiveDepth will represent the max number of laps, j, over the (r_i, f_i) pairs such that, looking at the total time t(j) after lap j \\n        // t(x_{j+1}) - t(x_{j}) < f + changeTime\\n        // because at that point, you are better off changing your tires instead of doing another lap! Another way of saying the same thing is that you should stop calculating individual lap times once the lap time is greater than just changing your tires and doing a lap with fresh ones\\n        var maxProductiveDepth = 1\\n        let f_0 = tires[0][0]\\n        \\n        //array to store the best total times over all of the (r,f) pairs if you never changed tires\\n        //the length will always be equal to maxProductiveDepth\\n        var bestTotalTimesWithoutChangingTires: [Int] = [0, f_0]\\n\\n        //loop to calculate the best times over each (r_i, f_i) pair if you never changed tires\\n        for f_r in tires {\\n            let f = f_r[0]\\n            let r  = f_r[1]\\n            \\n            //once the difference between successive laps is greater than the time to do a single lap and change a tire, we will stop calculating\\n            let max = bestTotalTimesWithoutChangingTires[1] + changeTime\\n            \\n            var power = 1\\n            var totalTime = 0\\n            for i in 1...numLaps {\\n                guard f*power < max else {break}\\n                totalTime = totalTime + f*power\\n                \\n                //update the array with the best time\\n                if maxProductiveDepth < i {\\n                    bestTotalTimesWithoutChangingTires.append(totalTime)\\n                    maxProductiveDepth = i\\n                } else if totalTime < bestTotalTimesWithoutChangingTires[i] {\\n                    bestTotalTimesWithoutChangingTires[i] = totalTime\\n                }\\n                power *= r\\n            }\\n        }\\n\\n        //dynamic programming array to store the fastest possible time to complete a given number of laps\\n        var raceTime = Array(repeating: 0, count: numLaps + 1)\\n        \\n        //fill up the dynamic programming array\\n        for i in 1...numLaps {\\n            //only bother checking the time if you never switched tires in cases where that would actually be a good idea - i.e. there is an (r,f) pair where the differences in lap times is still less that r + changeTime\\n            //if you are interested in why we never need to check for non-changing times beyond 17, see rh137\\'s explanation here:\\n            //https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1802444/C%2B%2B-Linear-time-DP-with-explanation\\n            var best = (i < 17 && i <= maxProductiveDepth ? bestTotalTimesWithoutChangingTires[i] : Int.max)\\n            \\n            //pretty stardard dp here - do what you did to finish the first i laps, change tires, then do what you did for the first i-j laps\\n            for j in 1..<min(17, i/2 + 1) {\\n                let newTime = raceTime[j] + changeTime + raceTime[i - j]\\n                if newTime < best {\\n                    best = newTime\\n                }\\n            }\\n            raceTime[i] = best\\n        }\\n        \\n        //return the fastest possible time to complete numLaps\\n        return raceTime[numLaps]\\n    }\\n}\\n```\\n\\n\\nhard-coded solution: \\n```\\nclass Solution {\\n    func minimumFinishTime(_ tires: [[Int]], _ changeTime: Int, _ numLaps: Int) -> Int {\\n        //the maxProductiveDepth will represent the max number of laps, j, over the (r_i, f_i) pairs such that, looking at the total time t(j) after lap j \\n        // t(x_{j+1}) - t(x_{j}) < f + changeTime\\n        // because at that point, you are better off changing your tires instead of doing another lap! Another way of saying the same thing is that you should stop calculating individual lap times once the lap time is greater than just changing your tires and doing a lap with fresh ones\\n        //if you are interested in why we never need to check for non-changing times beyond 15, see rh137\\'s explanation here:\\n        //https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1802444/C%2B%2B-Linear-time-DP-with-explanation\\n        var maxProductiveDepth = 17\\n        let f_0 = tires[0][0]\\n        \\n        //array to store the best total times over all of the (r,f) pairs if you never changed tires\\n        //the length will be equal to maxProductiveDepth\\n        var bestTotalTimesWithoutChangingTires: [Int] = Array(repeating: Int.max, count: maxProductiveDepth)\\n        bestTotalTimesWithoutChangingTires[0] = 0\\n        bestTotalTimesWithoutChangingTires[1] = f_0\\n\\n        //loop to calculate the best times over each (r_i, f_i) pair if you never changed tires\\n        for f_r in tires {\\n            let f = f_r[0]\\n            let r  = f_r[1]\\n            \\n            //once the difference between successive laps is greater than the time to do a single lap and change a tire, we will stop calculating\\n            let max = bestTotalTimesWithoutChangingTires[1] + changeTime\\n            \\n            var power = 1\\n            var totalTime = 0\\n            for i in 1...numLaps {\\n                guard i < maxProductiveDepth else {break}\\n                guard f*power < max else {break}\\n                totalTime = totalTime + f*power\\n                \\n                //update the array with the best time\\n                if totalTime < bestTotalTimesWithoutChangingTires[i] {\\n                    bestTotalTimesWithoutChangingTires[i] = totalTime\\n                }\\n                power *= r\\n            }\\n        }\\n\\n        //dynamic programming array to store the fastest possible time to complete a given number of laps\\n        var raceTime = Array(repeating: 0, count: numLaps + 1)\\n        //fill up the dynamic programming array\\n        for i in 1...numLaps {\\n            //only bother checking the time if you never switched tires in cases where that would actually be a good idea - i.e. there is an (r,f) pair where the differences in lap times is still less that r + changeTime\\n            \\n            var best = Int.max\\n            if i < maxProductiveDepth {\\n                best = bestTotalTimesWithoutChangingTires[i]\\n            }\\n            \\n            //pretty stardard dp here - do what you did to finish the first i laps, change tires, then do what you did for the first i-j laps\\n            for j in 1..<(i/2 + 1) {\\n                let newTime = raceTime[j] + changeTime + raceTime[i - j]\\n                if newTime < best {\\n                    best = newTime\\n                }\\n            }\\n            raceTime[i] = best\\n        }\\n        \\n        //return the fastest possible time to complete numLaps\\n        return raceTime[numLaps]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func minimumFinishTime(_ tires: [[Int]], _ changeTime: Int, _ numLaps: Int) -> Int {\\n        //the maxProductiveDepth will represent the max number of laps, j, over the (r_i, f_i) pairs such that, looking at the total time t(j) after lap j \\n        // t(x_{j+1}) - t(x_{j}) < f + changeTime\\n        // because at that point, you are better off changing your tires instead of doing another lap! Another way of saying the same thing is that you should stop calculating individual lap times once the lap time is greater than just changing your tires and doing a lap with fresh ones\\n        var maxProductiveDepth = 1\\n        let f_0 = tires[0][0]\\n        \\n        //array to store the best total times over all of the (r,f) pairs if you never changed tires\\n        //the length will always be equal to maxProductiveDepth\\n        var bestTotalTimesWithoutChangingTires: [Int] = [0, f_0]\\n\\n        //loop to calculate the best times over each (r_i, f_i) pair if you never changed tires\\n        for f_r in tires {\\n            let f = f_r[0]\\n            let r  = f_r[1]\\n            \\n            //once the difference between successive laps is greater than the time to do a single lap and change a tire, we will stop calculating\\n            let max = bestTotalTimesWithoutChangingTires[1] + changeTime\\n            \\n            var power = 1\\n            var totalTime = 0\\n            for i in 1...numLaps {\\n                guard f*power < max else {break}\\n                totalTime = totalTime + f*power\\n                \\n                //update the array with the best time\\n                if maxProductiveDepth < i {\\n                    bestTotalTimesWithoutChangingTires.append(totalTime)\\n                    maxProductiveDepth = i\\n                } else if totalTime < bestTotalTimesWithoutChangingTires[i] {\\n                    bestTotalTimesWithoutChangingTires[i] = totalTime\\n                }\\n                power *= r\\n            }\\n        }\\n\\n        //dynamic programming array to store the fastest possible time to complete a given number of laps\\n        var raceTime = Array(repeating: 0, count: numLaps + 1)\\n        \\n        //fill up the dynamic programming array\\n        for i in 1...numLaps {\\n            //only bother checking the time if you never switched tires in cases where that would actually be a good idea - i.e. there is an (r,f) pair where the differences in lap times is still less that r + changeTime\\n            //if you are interested in why we never need to check for non-changing times beyond 17, see rh137\\'s explanation here:\\n            //https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1802444/C%2B%2B-Linear-time-DP-with-explanation\\n            var best = (i < 17 && i <= maxProductiveDepth ? bestTotalTimesWithoutChangingTires[i] : Int.max)\\n            \\n            //pretty stardard dp here - do what you did to finish the first i laps, change tires, then do what you did for the first i-j laps\\n            for j in 1..<min(17, i/2 + 1) {\\n                let newTime = raceTime[j] + changeTime + raceTime[i - j]\\n                if newTime < best {\\n                    best = newTime\\n                }\\n            }\\n            raceTime[i] = best\\n        }\\n        \\n        //return the fastest possible time to complete numLaps\\n        return raceTime[numLaps]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minimumFinishTime(_ tires: [[Int]], _ changeTime: Int, _ numLaps: Int) -> Int {\\n        //the maxProductiveDepth will represent the max number of laps, j, over the (r_i, f_i) pairs such that, looking at the total time t(j) after lap j \\n        // t(x_{j+1}) - t(x_{j}) < f + changeTime\\n        // because at that point, you are better off changing your tires instead of doing another lap! Another way of saying the same thing is that you should stop calculating individual lap times once the lap time is greater than just changing your tires and doing a lap with fresh ones\\n        //if you are interested in why we never need to check for non-changing times beyond 15, see rh137\\'s explanation here:\\n        //https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1802444/C%2B%2B-Linear-time-DP-with-explanation\\n        var maxProductiveDepth = 17\\n        let f_0 = tires[0][0]\\n        \\n        //array to store the best total times over all of the (r,f) pairs if you never changed tires\\n        //the length will be equal to maxProductiveDepth\\n        var bestTotalTimesWithoutChangingTires: [Int] = Array(repeating: Int.max, count: maxProductiveDepth)\\n        bestTotalTimesWithoutChangingTires[0] = 0\\n        bestTotalTimesWithoutChangingTires[1] = f_0\\n\\n        //loop to calculate the best times over each (r_i, f_i) pair if you never changed tires\\n        for f_r in tires {\\n            let f = f_r[0]\\n            let r  = f_r[1]\\n            \\n            //once the difference between successive laps is greater than the time to do a single lap and change a tire, we will stop calculating\\n            let max = bestTotalTimesWithoutChangingTires[1] + changeTime\\n            \\n            var power = 1\\n            var totalTime = 0\\n            for i in 1...numLaps {\\n                guard i < maxProductiveDepth else {break}\\n                guard f*power < max else {break}\\n                totalTime = totalTime + f*power\\n                \\n                //update the array with the best time\\n                if totalTime < bestTotalTimesWithoutChangingTires[i] {\\n                    bestTotalTimesWithoutChangingTires[i] = totalTime\\n                }\\n                power *= r\\n            }\\n        }\\n\\n        //dynamic programming array to store the fastest possible time to complete a given number of laps\\n        var raceTime = Array(repeating: 0, count: numLaps + 1)\\n        //fill up the dynamic programming array\\n        for i in 1...numLaps {\\n            //only bother checking the time if you never switched tires in cases where that would actually be a good idea - i.e. there is an (r,f) pair where the differences in lap times is still less that r + changeTime\\n            \\n            var best = Int.max\\n            if i < maxProductiveDepth {\\n                best = bestTotalTimesWithoutChangingTires[i]\\n            }\\n            \\n            //pretty stardard dp here - do what you did to finish the first i laps, change tires, then do what you did for the first i-j laps\\n            for j in 1..<(i/2 + 1) {\\n                let newTime = raceTime[j] + changeTime + raceTime[i - j]\\n                if newTime < best {\\n                    best = newTime\\n                }\\n            }\\n            raceTime[i] = best\\n        }\\n        \\n        //return the fastest possible time to complete numLaps\\n        return raceTime[numLaps]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803387,
                "title": "python-dp",
                "content": "```python\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        record={}\\n        for f,r in tires:\\n            if f not in record:\\n                record[f]=r\\n            record[f]=min(r,record[f])\\n        tires=[(k,v) for k,v in record.items()]\\n        record={}\\n        for f,r in tires:\\n            if r not in record:\\n                record[r]=f\\n            record[r]=min(f,record[r])\\n        tires=[(v,k) for k,v in record.items()]\\n        cost=[10**9]*numLaps\\n        for i in range(len(tires)):\\n            f,r=tires[i]\\n            acc=f\\n            last=f\\n            cost[0]=min(f,cost[0])\\n            for j in range(1,numLaps):\\n                acc*=r\\n                cur=last+acc\\n                cost[j]=min(cur,cost[j])\\n                last=cur\\n                if cur>=(j+1)*(f+changeTime):\\n                    break\\n        dp=cost[:]\\n        for i in range(1,numLaps):\\n            acc=0\\n            base=changeTime+dp[0]\\n            for j in range(i-1,-1,-1):\\n                acc+=base\\n                if cost[i-j-1]>=acc:\\n                    break\\n                dp[i]=min(dp[i],dp[j]+cost[i-j-1]+changeTime)\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        record={}\\n        for f,r in tires:\\n            if f not in record:\\n                record[f]=r\\n            record[f]=min(r,record[f])\\n        tires=[(k,v) for k,v in record.items()]\\n        record={}\\n        for f,r in tires:\\n            if r not in record:\\n                record[r]=f\\n            record[r]=min(f,record[r])\\n        tires=[(v,k) for k,v in record.items()]\\n        cost=[10**9]*numLaps\\n        for i in range(len(tires)):\\n            f,r=tires[i]\\n            acc=f\\n            last=f\\n            cost[0]=min(f,cost[0])\\n            for j in range(1,numLaps):\\n                acc*=r\\n                cur=last+acc\\n                cost[j]=min(cur,cost[j])\\n                last=cur\\n                if cur>=(j+1)*(f+changeTime):\\n                    break\\n        dp=cost[:]\\n        for i in range(1,numLaps):\\n            acc=0\\n            base=changeTime+dp[0]\\n            for j in range(i-1,-1,-1):\\n                acc+=base\\n                if cost[i-j-1]>=acc:\\n                    break\\n                dp[i]=min(dp[i],dp[j]+cost[i-j-1]+changeTime)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803285,
                "title": "c-dp-with-single-tire-max-time-bound",
                "content": "```\\nclass Solution {\\n    using integer = long long;\\n        \\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        const integer change_time = changeTime;\\n        const integer num_laps = numLaps;    \\n        \\n        integer min_time = INT_MAX;\\n        for (int i = 0; i < tires.size(); ++i) {\\n            min_time = std::min(change_time + tires[i][0], min_time);\\n        }\\n        const integer finish_time_upper_bound = min_time * num_laps - change_time;\\n        \\n        std::vector<integer> lap_to_min_cost(num_laps + 1, finish_time_upper_bound);\\n        int max_conti_lap = 0;\\n        for (int i = 0; i < tires.size(); ++i) {\\n            const integer f = tires[i][0], r = tires[i][1];\\n            integer pow = 1;\\n            integer sum = pow;\\n            for (int lap = 1; lap <= num_laps; ++lap) {\\n                const integer cost = f * sum;\\n                if (cost > finish_time_upper_bound) {\\n                    break;\\n                }\\n                max_conti_lap = std::max(lap, max_conti_lap);\\n                lap_to_min_cost[lap] = std::min(\\n                    cost, lap_to_min_cost[lap]\\n                );\\n                pow *= r;\\n                sum += pow;\\n            }\\n        }\\n        \\n        std::vector<integer> tbl(num_laps + 1, finish_time_upper_bound);\\n        tbl[0] = 0;\\n        for (int lap = 1; lap <= num_laps; ++lap) {\\n            integer min_cost = min_time * lap - change_time;\\n            if (lap <= max_conti_lap) {\\n                min_cost = std::min(lap_to_min_cost[lap], min_cost);\\n            }\\n            for (int suff_len = 1; suff_len <= std::min(lap, max_conti_lap); ++suff_len) {\\n                const int pref_len = lap - suff_len;\\n                min_cost = std::min(\\n                    tbl[pref_len] + change_time + lap_to_min_cost[suff_len],\\n                    min_cost\\n                );\\n            }\\n            tbl[lap] = min_cost;\\n        }\\n        return tbl.back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    using integer = long long;\\n        \\npublic:\\n    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {\\n        const integer change_time = changeTime;\\n        const integer num_laps = numLaps;    \\n        \\n        integer min_time = INT_MAX;\\n        for (int i = 0; i < tires.size(); ++i) {\\n            min_time = std::min(change_time + tires[i][0], min_time);\\n        }\\n        const integer finish_time_upper_bound = min_time * num_laps - change_time;\\n        \\n        std::vector<integer> lap_to_min_cost(num_laps + 1, finish_time_upper_bound);\\n        int max_conti_lap = 0;\\n        for (int i = 0; i < tires.size(); ++i) {\\n            const integer f = tires[i][0], r = tires[i][1];\\n            integer pow = 1;\\n            integer sum = pow;\\n            for (int lap = 1; lap <= num_laps; ++lap) {\\n                const integer cost = f * sum;\\n                if (cost > finish_time_upper_bound) {\\n                    break;\\n                }\\n                max_conti_lap = std::max(lap, max_conti_lap);\\n                lap_to_min_cost[lap] = std::min(\\n                    cost, lap_to_min_cost[lap]\\n                );\\n                pow *= r;\\n                sum += pow;\\n            }\\n        }\\n        \\n        std::vector<integer> tbl(num_laps + 1, finish_time_upper_bound);\\n        tbl[0] = 0;\\n        for (int lap = 1; lap <= num_laps; ++lap) {\\n            integer min_cost = min_time * lap - change_time;\\n            if (lap <= max_conti_lap) {\\n                min_cost = std::min(lap_to_min_cost[lap], min_cost);\\n            }\\n            for (int suff_len = 1; suff_len <= std::min(lap, max_conti_lap); ++suff_len) {\\n                const int pref_len = lap - suff_len;\\n                min_cost = std::min(\\n                    tbl[pref_len] + change_time + lap_to_min_cost[suff_len],\\n                    min_cost\\n                );\\n            }\\n            tbl[lap] = min_cost;\\n        }\\n        return tbl.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803250,
                "title": "c-dp-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int m = 0;\\n    int minimumFinishTime(vector<vector<int>>& nums, int k, int n) {\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0] = -k; \\n        for(int i = 0; i<nums.size();++i){\\n            int re = nums[i][0]; int t = re;\\n            dp[1]=min(dp[1],re);\\n            for(int j = 2; j<=n;++j){\\n                m=max(j,m);\\n                if(k+(long long)nums[i][0]<(long long)re*nums[i][1]) break;\\n                re*=nums[i][1];\\n                t+=re;\\n                dp[j] = min(dp[j],t);\\n            }\\n        }\\n        for(int i = 2; i<n+1;++i){\\n            for(int j = 0;j<min(i,m);++j){\\n                dp[i] = min(dp[i],k+dp[j]+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 0;\\n    int minimumFinishTime(vector<vector<int>>& nums, int k, int n) {\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0] = -k; \\n        for(int i = 0; i<nums.size();++i){\\n            int re = nums[i][0]; int t = re;\\n            dp[1]=min(dp[1],re);\\n            for(int j = 2; j<=n;++j){\\n                m=max(j,m);\\n                if(k+(long long)nums[i][0]<(long long)re*nums[i][1]) break;\\n                re*=nums[i][1];\\n                t+=re;\\n                dp[j] = min(dp[j],t);\\n            }\\n        }\\n        for(int i = 2; i<n+1;++i){\\n            for(int j = 0;j<min(i,m);++j){\\n                dp[i] = min(dp[i],k+dp[j]+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803152,
                "title": "java-dp-take-care-of-the-overflow",
                "content": "Tricky test case, I hope this can help you\\nThe important thing is how to handle overflow, why java don\\'t tell us that this number overflowed!!\\nAnd you can print the lap and dp to see what\\'s happen to the iteration and to check which part went wrong!\\nSome need to be calculated to the power of 20\\n\\n```\\n public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        long[] lap= new long[20];\\n        Arrays.fill(lap, Long.MAX_VALUE);\\n        lap[0]=0;\\n    \\n        for(int j=1;j<lap.length;j++) {\\n            for (int i = 0; i < tires.length; i++) {\\n                long newLap=0;\\n                long p=tires[i][0];\\n                for(int k=1;k<=j;k++){\\n                    if(k!=1)\\n                    p*=tires[i][1];\\n                    newLap+=p;\\n                    //newLap+=tires[i][0] * (long) Math.pow(tires[i][1], k-1);\\n                }\\n                if(newLap<0)\\n                    newLap= Long.MAX_VALUE;\\n                lap[j] = Math.min(lap[j], newLap);\\n            }\\n        }\\n       long[] dp= new long[numLaps+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0]=0;\\n        for(int i=1;i<numLaps+1;i++){\\n            for(int j=1;j<lap.length&&i-j>=0;j++){\\n\\t\\t\\t// Here for overflow\\n                if(lap[j]>Integer.MAX_VALUE)\\n                    continue;\\n                dp[i]=  Math.min(dp[i-j]+lap[j]+changeTime,dp[i]);\\n            }\\n        }\\n        return (int)dp[numLaps]-changeTime;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        long[] lap= new long[20];\\n        Arrays.fill(lap, Long.MAX_VALUE);\\n        lap[0]=0;\\n    \\n        for(int j=1;j<lap.length;j++) {\\n            for (int i = 0; i < tires.length; i++) {\\n                long newLap=0;\\n                long p=tires[i][0];\\n                for(int k=1;k<=j;k++){\\n                    if(k!=1)\\n                    p*=tires[i][1];\\n                    newLap+=p;\\n                    //newLap+=tires[i][0] * (long) Math.pow(tires[i][1], k-1);\\n                }\\n                if(newLap<0)\\n                    newLap= Long.MAX_VALUE;\\n                lap[j] = Math.min(lap[j], newLap);\\n            }\\n        }\\n       long[] dp= new long[numLaps+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0]=0;\\n        for(int i=1;i<numLaps+1;i++){\\n            for(int j=1;j<lap.length&&i-j>=0;j++){\\n\\t\\t\\t// Here for overflow\\n                if(lap[j]>Integer.MAX_VALUE)\\n                    continue;\\n                dp[i]=  Math.min(dp[i-j]+lap[j]+changeTime,dp[i]);\\n            }\\n        }\\n        return (int)dp[numLaps]-changeTime;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576452,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "Didn\\'t solve it during the contest so making this viz to cement my memory \\uD83D\\uDE2C\\n\\nThis algo I\\'m visualizing is based on [this answer](https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1802719/Java-DP-%2B-Greedy-initiate-minimal-time-for-each-trie-before-change) & involves in 2 phases\\n1. Populate some entries in the DP table by using just 1 tire for multiple times\\n2. Continue Populate the DP table by combining answers from 1 and introspectively the table by earlier iterations of 2\\n\\nKind of resembles the Monotonic Stack which also self-introspects?\\n\\nGIF:\\n![image](https://assets.leetcode.com/users/images/108c1c8a-0bbd-4169-ac5b-9c337ce5f633_1645961668.7176218.gif)\\n\\n\\nLive version: [https://editor.p5js.org/nitroglycerine/full/YXTIe0vUT](https://editor.p5js.org/nitroglycerine/full/YXTIe0vUT) (Caution: the Javascript file generated with EmScripten is a few MBs in size and *can cause the browser to hang briefly*. I need to avoid turning on `-Os` so that the `ccall` method doesn\\'t get optimized away)"
                    },
                    {
                        "username": "apriyadarshi00",
                        "content": "can someone please explain how minTime is 44 for this solution set ?\\n\\ntest case :\\n\\n[[52,2],[2,2]]\\n24\\n5\\n\\nresult : 44"
                    },
                    {
                        "username": "BiggiPiggi",
                        "content": "Lap 1: Start with tire 1 and finish the lap in 2 seconds.\\nLap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\\nLap 3: Continue with tire 1 and finish the lap in 2 * 4 = 8 seconds.\\nLap 4: Change tires to a new tire 1 for 24 seconds and then finish the lap in another 2 seconds.\\nLap 5: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\\nTotal time = 2 + 4 + 8 + 24 + 2 + 4 = 44 seconds.\\nThe minimum time to complete the race is 44 seconds."
                    },
                    {
                        "username": "jaisehgal11299",
                        "content": "This question reminds me of F1."
                    },
                    {
                        "username": "randhirpalsingh",
                        "content": "int solve(vector<vector<int> > &tires, int &changeTime,int &numLaps,int done,int consta){\\n\\n    if (done==numLaps){\\n        return 0;\\n    }\\n    \\n        int mini = INT_MAX;\\n        for (int i=0;i<tires.size();i++){\\n            \\n            \\n                int var1 = tires[i][0]*pow(tires[i][1],consta)+solve(tires,changeTime,numLaps,done+1,consta+1);\\n                int var2 = changeTime+(tires[i][0]*pow(tires[i][1],0))+solve(tires,changeTime,numLaps,done+1,1);\\n                mini=min(mini,var1);\\n                mini=min(mini,var2);\\n        }        \\n       \\n\\n    \\n    return mini;\\n    \\n}\\n\\ncan anyone please explain the error in this recursive approach. i know it will give tle but still want to know error"
                    }
                ]
            },
            {
                "id": 1863416,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "Didn\\'t solve it during the contest so making this viz to cement my memory \\uD83D\\uDE2C\\n\\nThis algo I\\'m visualizing is based on [this answer](https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1802719/Java-DP-%2B-Greedy-initiate-minimal-time-for-each-trie-before-change) & involves in 2 phases\\n1. Populate some entries in the DP table by using just 1 tire for multiple times\\n2. Continue Populate the DP table by combining answers from 1 and introspectively the table by earlier iterations of 2\\n\\nKind of resembles the Monotonic Stack which also self-introspects?\\n\\nGIF:\\n![image](https://assets.leetcode.com/users/images/108c1c8a-0bbd-4169-ac5b-9c337ce5f633_1645961668.7176218.gif)\\n\\n\\nLive version: [https://editor.p5js.org/nitroglycerine/full/YXTIe0vUT](https://editor.p5js.org/nitroglycerine/full/YXTIe0vUT) (Caution: the Javascript file generated with EmScripten is a few MBs in size and *can cause the browser to hang briefly*. I need to avoid turning on `-Os` so that the `ccall` method doesn\\'t get optimized away)"
                    },
                    {
                        "username": "apriyadarshi00",
                        "content": "can someone please explain how minTime is 44 for this solution set ?\\n\\ntest case :\\n\\n[[52,2],[2,2]]\\n24\\n5\\n\\nresult : 44"
                    },
                    {
                        "username": "BiggiPiggi",
                        "content": "Lap 1: Start with tire 1 and finish the lap in 2 seconds.\\nLap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\\nLap 3: Continue with tire 1 and finish the lap in 2 * 4 = 8 seconds.\\nLap 4: Change tires to a new tire 1 for 24 seconds and then finish the lap in another 2 seconds.\\nLap 5: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\\nTotal time = 2 + 4 + 8 + 24 + 2 + 4 = 44 seconds.\\nThe minimum time to complete the race is 44 seconds."
                    },
                    {
                        "username": "jaisehgal11299",
                        "content": "This question reminds me of F1."
                    },
                    {
                        "username": "randhirpalsingh",
                        "content": "int solve(vector<vector<int> > &tires, int &changeTime,int &numLaps,int done,int consta){\\n\\n    if (done==numLaps){\\n        return 0;\\n    }\\n    \\n        int mini = INT_MAX;\\n        for (int i=0;i<tires.size();i++){\\n            \\n            \\n                int var1 = tires[i][0]*pow(tires[i][1],consta)+solve(tires,changeTime,numLaps,done+1,consta+1);\\n                int var2 = changeTime+(tires[i][0]*pow(tires[i][1],0))+solve(tires,changeTime,numLaps,done+1,1);\\n                mini=min(mini,var1);\\n                mini=min(mini,var2);\\n        }        \\n       \\n\\n    \\n    return mini;\\n    \\n}\\n\\ncan anyone please explain the error in this recursive approach. i know it will give tle but still want to know error"
                    }
                ]
            },
            {
                "id": 1825363,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "Didn\\'t solve it during the contest so making this viz to cement my memory \\uD83D\\uDE2C\\n\\nThis algo I\\'m visualizing is based on [this answer](https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1802719/Java-DP-%2B-Greedy-initiate-minimal-time-for-each-trie-before-change) & involves in 2 phases\\n1. Populate some entries in the DP table by using just 1 tire for multiple times\\n2. Continue Populate the DP table by combining answers from 1 and introspectively the table by earlier iterations of 2\\n\\nKind of resembles the Monotonic Stack which also self-introspects?\\n\\nGIF:\\n![image](https://assets.leetcode.com/users/images/108c1c8a-0bbd-4169-ac5b-9c337ce5f633_1645961668.7176218.gif)\\n\\n\\nLive version: [https://editor.p5js.org/nitroglycerine/full/YXTIe0vUT](https://editor.p5js.org/nitroglycerine/full/YXTIe0vUT) (Caution: the Javascript file generated with EmScripten is a few MBs in size and *can cause the browser to hang briefly*. I need to avoid turning on `-Os` so that the `ccall` method doesn\\'t get optimized away)"
                    },
                    {
                        "username": "apriyadarshi00",
                        "content": "can someone please explain how minTime is 44 for this solution set ?\\n\\ntest case :\\n\\n[[52,2],[2,2]]\\n24\\n5\\n\\nresult : 44"
                    },
                    {
                        "username": "BiggiPiggi",
                        "content": "Lap 1: Start with tire 1 and finish the lap in 2 seconds.\\nLap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\\nLap 3: Continue with tire 1 and finish the lap in 2 * 4 = 8 seconds.\\nLap 4: Change tires to a new tire 1 for 24 seconds and then finish the lap in another 2 seconds.\\nLap 5: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\\nTotal time = 2 + 4 + 8 + 24 + 2 + 4 = 44 seconds.\\nThe minimum time to complete the race is 44 seconds."
                    },
                    {
                        "username": "jaisehgal11299",
                        "content": "This question reminds me of F1."
                    },
                    {
                        "username": "randhirpalsingh",
                        "content": "int solve(vector<vector<int> > &tires, int &changeTime,int &numLaps,int done,int consta){\\n\\n    if (done==numLaps){\\n        return 0;\\n    }\\n    \\n        int mini = INT_MAX;\\n        for (int i=0;i<tires.size();i++){\\n            \\n            \\n                int var1 = tires[i][0]*pow(tires[i][1],consta)+solve(tires,changeTime,numLaps,done+1,consta+1);\\n                int var2 = changeTime+(tires[i][0]*pow(tires[i][1],0))+solve(tires,changeTime,numLaps,done+1,1);\\n                mini=min(mini,var1);\\n                mini=min(mini,var2);\\n        }        \\n       \\n\\n    \\n    return mini;\\n    \\n}\\n\\ncan anyone please explain the error in this recursive approach. i know it will give tle but still want to know error"
                    }
                ]
            },
            {
                "id": 1724150,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "Didn\\'t solve it during the contest so making this viz to cement my memory \\uD83D\\uDE2C\\n\\nThis algo I\\'m visualizing is based on [this answer](https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1802719/Java-DP-%2B-Greedy-initiate-minimal-time-for-each-trie-before-change) & involves in 2 phases\\n1. Populate some entries in the DP table by using just 1 tire for multiple times\\n2. Continue Populate the DP table by combining answers from 1 and introspectively the table by earlier iterations of 2\\n\\nKind of resembles the Monotonic Stack which also self-introspects?\\n\\nGIF:\\n![image](https://assets.leetcode.com/users/images/108c1c8a-0bbd-4169-ac5b-9c337ce5f633_1645961668.7176218.gif)\\n\\n\\nLive version: [https://editor.p5js.org/nitroglycerine/full/YXTIe0vUT](https://editor.p5js.org/nitroglycerine/full/YXTIe0vUT) (Caution: the Javascript file generated with EmScripten is a few MBs in size and *can cause the browser to hang briefly*. I need to avoid turning on `-Os` so that the `ccall` method doesn\\'t get optimized away)"
                    },
                    {
                        "username": "apriyadarshi00",
                        "content": "can someone please explain how minTime is 44 for this solution set ?\\n\\ntest case :\\n\\n[[52,2],[2,2]]\\n24\\n5\\n\\nresult : 44"
                    },
                    {
                        "username": "BiggiPiggi",
                        "content": "Lap 1: Start with tire 1 and finish the lap in 2 seconds.\\nLap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\\nLap 3: Continue with tire 1 and finish the lap in 2 * 4 = 8 seconds.\\nLap 4: Change tires to a new tire 1 for 24 seconds and then finish the lap in another 2 seconds.\\nLap 5: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\\nTotal time = 2 + 4 + 8 + 24 + 2 + 4 = 44 seconds.\\nThe minimum time to complete the race is 44 seconds."
                    },
                    {
                        "username": "jaisehgal11299",
                        "content": "This question reminds me of F1."
                    },
                    {
                        "username": "randhirpalsingh",
                        "content": "int solve(vector<vector<int> > &tires, int &changeTime,int &numLaps,int done,int consta){\\n\\n    if (done==numLaps){\\n        return 0;\\n    }\\n    \\n        int mini = INT_MAX;\\n        for (int i=0;i<tires.size();i++){\\n            \\n            \\n                int var1 = tires[i][0]*pow(tires[i][1],consta)+solve(tires,changeTime,numLaps,done+1,consta+1);\\n                int var2 = changeTime+(tires[i][0]*pow(tires[i][1],0))+solve(tires,changeTime,numLaps,done+1,1);\\n                mini=min(mini,var1);\\n                mini=min(mini,var2);\\n        }        \\n       \\n\\n    \\n    return mini;\\n    \\n}\\n\\ncan anyone please explain the error in this recursive approach. i know it will give tle but still want to know error"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways to Build House of Cards",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Most Frequent Number Following Key In an Array",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.<strong> </strong>You are also given an integer <code>key</code>, which is present in <code>nums</code>.</p>\n\n<p>For every unique integer <code>target</code> in <code>nums</code>, <strong>count</strong> the number of times <code>target</code> immediately follows an occurrence of <code>key</code> in <code>nums</code>. In other words, count the number of indices <code>i</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt;= nums.length - 2</code>,</li>\n\t<li><code>nums[i] == key</code> and,</li>\n\t<li><code>nums[i + 1] == target</code>.</li>\n</ul>\n\n<p>Return <em>the </em><code>target</code><em> with the <strong>maximum</strong> count</em>. The test cases will be generated such that the <code>target</code> with maximum count is unique.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,100,200,1,100], key = 1\n<strong>Output:</strong> 100\n<strong>Explanation:</strong> For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.\nNo other integers follow an occurrence of key, so we return 100.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,3], key = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.\nFor target = 3, there is only one occurrence at index 4 which follows an occurrence of key.\ntarget = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>The test cases will be generated such that the answer is unique.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1822539,
                "title": "counter",
                "content": "**C++**\\n```cpp\\nint mostFrequent(vector<int>& nums, int key) {\\n    int cnt[1001] = {}, res = 0;\\n    for (int i = 1; i < nums.size(); ++i)\\n        if (nums[i - 1] == key && ++cnt[nums[i]] > cnt[res])\\n            res = nums[i];\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint mostFrequent(vector<int>& nums, int key) {\\n    int cnt[1001] = {}, res = 0;\\n    for (int i = 1; i < nums.size(); ++i)\\n        if (nums[i - 1] == key && ++cnt[nums[i]] > cnt[res])\\n            res = nums[i];\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822098,
                "title": "java-python-3-simple-code",
                "content": "**Java**\\n```java\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int mostFreq = -1;\\n        for (int i = 0, n = nums.length, max = 0; i + 1 < n; ++i) {\\n            if (nums[i] == key) {\\n                int candidate = nums[i + 1];\\n                freq.put(candidate, 1 + freq.getOrDefault(candidate, 0));\\n                if (freq.get(candidate) > max) {\\n                    max = freq.get(candidate);\\n                    mostFreq = candidate;\\n                }\\n            }\\n        }\\n        return mostFreq;\\n    }\\n```\\nOr make the above simpler as follows:\\n\\n```java\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int mostFreq = nums[0];\\n        for (int i = 0, n = nums.length; i + 1 < n; ++i) {\\n            if (nums[i] == key && \\n                        freq.merge(nums[i + 1], 1, Integer::sum) > \\n                        freq.get(mostFreq)) {\\n                mostFreq = nums[i + 1];\\n            }\\n        }\\n        return mostFreq;\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\n\\n```python\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        c = Counter()\\n        for i, n in enumerate(nums):\\n            if n == key and i + 1 < len(nums):\\n                c[nums[i + 1]] += 1\\n        return c.most_common(1)[0][0]\\n```\\n\\nOne liner for fun: - credit to **@stefan4trivia**.\\n\\n```python\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        return statistics.mode(b for a, b in itertools.pairwise(nums) if a == key)\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int mostFreq = -1;\\n        for (int i = 0, n = nums.length, max = 0; i + 1 < n; ++i) {\\n            if (nums[i] == key) {\\n                int candidate = nums[i + 1];\\n                freq.put(candidate, 1 + freq.getOrDefault(candidate, 0));\\n                if (freq.get(candidate) > max) {\\n                    max = freq.get(candidate);\\n                    mostFreq = candidate;\\n                }\\n            }\\n        }\\n        return mostFreq;\\n    }\\n```\n```java\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int mostFreq = nums[0];\\n        for (int i = 0, n = nums.length; i + 1 < n; ++i) {\\n            if (nums[i] == key && \\n                        freq.merge(nums[i + 1], 1, Integer::sum) > \\n                        freq.get(mostFreq)) {\\n                mostFreq = nums[i + 1];\\n            }\\n        }\\n        return mostFreq;\\n    }\\n```\n```python\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        c = Counter()\\n        for i, n in enumerate(nums):\\n            if n == key and i + 1 < len(nums):\\n                c[nums[i + 1]] += 1\\n        return c.most_common(1)[0][0]\\n```\n```python\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        return statistics.mode(b for a, b in itertools.pairwise(nums) if a == key)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1822644,
                "title": "100-faster-c-beginners-friendly-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> umap;\\n        int count=0;\\n        int ans=nums[0];\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                umap[nums[i+1]]++;\\n                if(umap[nums[i+1]]>count)\\n                {\\n                    count=umap[nums[i+1]];\\n                    ans=nums[i+1];\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like it? Please Upvote :-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> umap;\\n        int count=0;\\n        int ans=nums[0];\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                umap[nums[i+1]]++;\\n                if(umap[nums[i+1]]>count)\\n                {\\n                    count=umap[nums[i+1]];\\n                    ans=nums[i+1];\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924231,
                "title": "python-multiple-solutions-one-liners-clean-and-simple",
                "content": "**Solution - Count by hand**:\\n```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        counts = {}\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] not in counts: counts[nums[i]] = 1\\n                else: counts[nums[i]] += 1\\n        \\n        return max(counts, key=counts.get)\\n```\\n\\n**Solution - Counter**:\\n```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        arr = [nums[i] for i in range(1,len(nums)) if nums[i-1]==key]\\n        c = Counter(arr)\\n        return max(c, key=c.get)\\n```\\n\\n**One-Liner - Counter**:\\n```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        return max(c := Counter([nums[i] for i in range(1,len(nums)) if nums[i-1]==key]), key=c.get)\\n```\\n\\n**One-Liner - Mode**:\\n```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        return mode(nums[i] for i in range(1,len(nums)) if nums[i-1]==key)\\n```\\n\\n**One-Liner - Mode with Pairwise** (Credit: [stefan4trivia](https://leetcode.com/stefan4trivia)):\\n```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        return mode(b for a, b in pairwise(nums) if a == key)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        counts = {}\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] not in counts: counts[nums[i]] = 1\\n                else: counts[nums[i]] += 1\\n        \\n        return max(counts, key=counts.get)\\n```\n```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        arr = [nums[i] for i in range(1,len(nums)) if nums[i-1]==key]\\n        c = Counter(arr)\\n        return max(c, key=c.get)\\n```\n```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        return max(c := Counter([nums[i] for i in range(1,len(nums)) if nums[i-1]==key]), key=c.get)\\n```\n```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        return mode(nums[i] for i in range(1,len(nums)) if nums[i-1]==key)\\n```\n```\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        return mode(b for a, b in pairwise(nums) if a == key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822368,
                "title": "java-easiest-o-n-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans=-1;\\n        int max=Integer.MIN_VALUE;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i]==key){\\n                \\n                if(!map.containsKey(nums[i+1])){\\n                    map.put(nums[i+1], 1);\\n                }\\n                else{\\n                    int x = map.get(nums[i+1]);\\n                    map.put(nums[i+1], ++x);\\n                }\\n                if(map.get(nums[i+1])>max){\\n                    max=map.get(nums[i+1]);\\n                    ans=nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans=-1;\\n        int max=Integer.MIN_VALUE;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i]==key){\\n                \\n                if(!map.containsKey(nums[i+1])){\\n                    map.put(nums[i+1], 1);\\n                }\\n                else{\\n                    int x = map.get(nums[i+1]);\\n                    map.put(nums[i+1], ++x);\\n                }\\n                if(map.get(nums[i+1])>max){\\n                    max=map.get(nums[i+1]);\\n                    ans=nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821959,
                "title": "c-using-unordered-map-with-comments",
                "content": "class Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i]==key)\\n                mp[nums[i+1]]++;    //increase target frequency\\n        }\\n        \\n        int mx = INT_MIN;\\n        int target = -1;\\n        for(auto &it: mp){\\n            if(it.second > mx){         //highest target count\\n                mx = it.second;\\n                target = it.first;     //store target(element)\\n            }\\n        }\\n        \\n        return target;\\n    }\\n};\\n\\n\\n//please upvote if u like the solution:)",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i]==key)\\n                mp[nums[i+1]]++;    //increase target frequency\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1827425,
                "title": "javascript-easy-to-understand-detailed-explanation-counting-with-map-or-array",
                "content": "## Core Strategy\\n\\nIt\\'s another counting problem. What we need to do is:\\n- counting the frequency for every `target`\\n- find out the number with the max frequency\\n\\nIt\\'s easy to think about using a 2 times traversal - 1 time for counting and another time for finding the max.\\nBut, actually, we could finish it in just 1-time traversal by maintaining a variable of the max frequency.\\n\\n## Count with map\\n\\nWe just follow the strategy, use a map to save the frequency, nothing more.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst mostFrequent = (nums, key) => {\\n  const freq = {};\\n  let ret = 0;\\n  for (let i = 0, max = 0; i < nums.length - 1; ++i) {\\n    if (nums[i] !== key) continue;\\n    const target = nums[i + 1];\\n    freq[target] = (freq[target] || 0) + 1;\\n    if (freq[target] > max) {\\n      max = freq[target];\\n      ret = target;\\n    }\\n  }\\n  return ret;\\n};\\n```\\n\\n## Count with array\\n\\nWe use a fixed-length array to save the frequency, and I try to make the code shorter.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst mostFrequent = (nums, key) => {\\n  const freq = new Uint16Array(1001);\\n  let ret = 0;\\n  for (let i = 0, max = 0; i < nums.length - 1; ++i) {\\n    const target = nums[i + 1];\\n    nums[i] === key && ++freq[target] > max && ((max = freq[target]), (ret = target));\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst mostFrequent = (nums, key) => {\\n  const freq = {};\\n  let ret = 0;\\n  for (let i = 0, max = 0; i < nums.length - 1; ++i) {\\n    if (nums[i] !== key) continue;\\n    const target = nums[i + 1];\\n    freq[target] = (freq[target] || 0) + 1;\\n    if (freq[target] > max) {\\n      max = freq[target];\\n      ret = target;\\n    }\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst mostFrequent = (nums, key) => {\\n  const freq = new Uint16Array(1001);\\n  let ret = 0;\\n  for (let i = 0, max = 0; i < nums.length - 1; ++i) {\\n    const target = nums[i + 1];\\n    nums[i] === key && ++freq[target] > max && ((max = freq[target]), (ret = target));\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822247,
                "title": "c-using-hashmap-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<nums.size()-1;++i)\\n        {\\n            if(nums[i]==key)\\n                freq[nums[i+1]]++;\\n        }\\n        int ans=0,mx=INT_MIN;\\n        for(auto it: freq)\\n        {\\n            if(mx<it.second)\\n            {\\n                mx=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<nums.size()-1;++i)\\n        {\\n            if(nums[i]==key)\\n                freq[nums[i+1]]++;\\n        }\\n        int ans=0,mx=INT_MIN;\\n        for(auto it: freq)\\n        {\\n            if(mx<it.second)\\n            {\\n                mx=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822176,
                "title": "java-count-frequency-easy-clean-code",
                "content": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int freq[] = new int[1001];\\n        \\n        //count frequency of numbers which are followed by key\\n        for (int i = 1; i < nums.length; i++) {\\n            //if previous number is key\\n            //increase frequency of the number\\n            if (nums[i - 1] == key) { \\n                freq[nums[i]]++;\\n            }\\n        }\\n        \\n        //check which number is most frequent\\n        int max = 0;\\n        for (int i = 1; i < freq.length; i++) {\\n            if (freq[i] > freq[max]) {\\n                max = i;\\n            }\\n        }\\n        \\n        //return\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int freq[] = new int[1001];\\n        \\n        //count frequency of numbers which are followed by key\\n        for (int i = 1; i < nums.length; i++) {\\n            //if previous number is key\\n            //increase frequency of the number\\n            if (nums[i - 1] == key) { \\n                freq[nums[i]]++;\\n            }\\n        }\\n        \\n        //check which number is most frequent\\n        int max = 0;\\n        for (int i = 1; i < freq.length; i++) {\\n            if (freq[i] > freq[max]) {\\n                max = i;\\n            }\\n        }\\n        \\n        //return\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821947,
                "title": "java-hashmap-simple",
                "content": "```\\nclass Solution {\\n  public int mostFrequent(int[] nums, int key) {\\n\\n    if (nums.length == 0)\\n      return 0;\\n\\n    HashMap < Integer, Integer > map = new HashMap < > ();\\n    int max = 0;\\n    int result = 0;\\n\\n    for (int i = 0; i <= nums.length - 2; i++) {\\n\\n      if (nums[i] == key) {\\n        map.put(nums[i + 1], map.getOrDefault(nums[i + 1], 0) + 1);\\n        if (max < map.get(nums[i + 1])) {\\n          max = Math.max(max, map.get(nums[i + 1]));\\n          result = nums[i + 1];\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int mostFrequent(int[] nums, int key) {\\n\\n    if (nums.length == 0)\\n      return 0;\\n\\n    HashMap < Integer, Integer > map = new HashMap < > ();\\n    int max = 0;\\n    int result = 0;\\n\\n    for (int i = 0; i <= nums.length - 2; i++) {\\n\\n      if (nums[i] == key) {\\n        map.put(nums[i + 1], map.getOrDefault(nums[i + 1], 0) + 1);\\n        if (max < map.get(nums[i + 1])) {\\n          max = Math.max(max, map.get(nums[i + 1]));\\n          result = nums[i + 1];\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134624,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==key && i<nums.size()-1)\\n            {\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        int a=INT_MIN,ans;\\n        for(auto it:m)\\n        {\\n            if(it.second>a)\\n            {\\n                a=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==key && i<nums.size()-1)\\n            {\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        int a=INT_MIN,ans;\\n        for(auto it:m)\\n        {\\n            if(it.second>a)\\n            {\\n                a=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447577,
                "title": "c-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int mostFrequent(vector<int>& nums, int key) {\\n        \\n        int m[1001];\\n        for(int i=0;i<1001;i++)m[i]=0;\\n        \\n        int c=0,res;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                int k =nums[i+1];\\n                m[k]++;\\n            }\\n        }\\n        for(int i=0;i<1001;i++){\\n            if(m[i]>c){\\n                c=m[i];\\n                res=i;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int mostFrequent(vector<int>& nums, int key) {\\n        \\n        int m[1001];\\n        for(int i=0;i<1001;i++)m[i]=0;\\n        \\n        int c=0,res;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                int k =nums[i+1];\\n                m[k]++;\\n            }\\n        }\\n        for(int i=0;i<1001;i++){\\n            if(m[i]>c){\\n                c=m[i];\\n                res=i;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277077,
                "title": "2190-most-frequent-number-following-key-in-an-array",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mostFrequent(vector<int>& nums, int key) {\\n\\t\\t\\tunordered_map<int,int> ump;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]==key)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tump[nums[i+1]]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint max = INT_MIN, ans=0;\\n\\t\\t\\tfor(auto itr: ump)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(itr.second>max)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmax = itr.second;\\n\\t\\t\\t\\t\\tans = itr.first;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mostFrequent(vector<int>& nums, int key) {\\n\\t\\t\\tunordered_map<int,int> ump;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]==key)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tump[nums[i+1]]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1822080,
                "title": "variation-of-most-frequent-element-constant-space",
                "content": "Variation of **MOST FREQUENT ELEMENT**.\\nThey just added the Condition that **frequency of an element will be incremented if it is followed by a key**.\\nWe just have to identify the type of question.\\n# C++\\n    int mostFrequent(vector<int>& nums, int key) {\\n        vector<int> cnt(1001);\\n        int n= size(nums) , mx=0, res=0;\\n        for(int i=0;i<n-1;i++){\\n            int x= nums[i+1];\\n            if(nums[i]==key) {  //if we remove this statement then it would be answer to question -> MOST FREQUENT ELEMENT\\n                cnt[x]++;\\n                if(cnt[x]>mx) mx= cnt[x] , res= x;\\n            }\\n        }\\n        return res;\\n    }\\n**Time** -> O(N)\\n**Space** -> O(1001) -> Constant Space\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "Variation of **MOST FREQUENT ELEMENT**.\\nThey just added the Condition that **frequency of an element will be incremented if it is followed by a key**.\\nWe just have to identify the type of question.\\n# C++\\n    int mostFrequent(vector<int>& nums, int key) {\\n        vector<int> cnt(1001);\\n        int n= size(nums) , mx=0, res=0;\\n        for(int i=0;i<n-1;i++){\\n            int x= nums[i+1];\\n            if(nums[i]==key) {  //if we remove this statement then it would be answer to question -> MOST FREQUENT ELEMENT\\n                cnt[x]++;\\n                if(cnt[x]>mx) mx= cnt[x] , res= x;\\n            }\\n        }\\n        return res;\\n    }\\n**Time** -> O(N)\\n**Space** -> O(1001) -> Constant Space\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3480488,
                "title": "python-2-lines-functional-style",
                "content": "# Intuition\\nGet a list of all the values that come right after the keys\\nThen return the most frequent one\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        l = [t for k,t in zip(nums, nums[1:]) if k == key]\\n        return max(set(l), key = l.count)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        l = [t for k,t in zip(nums, nums[1:]) if k == key]\\n        return max(set(l), key = l.count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883728,
                "title": "100-faster-c-easy-solution-best-optimal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> \\uD83D\\uDE09;\\n        int \\uD83E\\uDD7A = 0,\\uD83D\\uDE02=-1;\\n        for(auto const &\\uD83D\\uDE2D:nums) {\\n            if(\\uD83D\\uDE02==key)\\n            \\uD83E\\uDD7A = max(\\uD83E\\uDD7A,++\\uD83D\\uDE09[\\uD83D\\uDE2D]);\\n            \\uD83D\\uDE02=\\uD83D\\uDE2D;\\n        } \\n        for(auto const &[k,v]:\\uD83D\\uDE09) if(v==\\uD83E\\uDD7A) return k;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> \\uD83D\\uDE09;\\n        int \\uD83E\\uDD7A = 0,\\uD83D\\uDE02=-1;\\n        for(auto const &\\uD83D\\uDE2D:nums) {\\n            if(\\uD83D\\uDE02==key)\\n            \\uD83E\\uDD7A = max(\\uD83E\\uDD7A,++\\uD83D\\uDE09[\\uD83D\\uDE2D]);\\n            \\uD83D\\uDE02=\\uD83D\\uDE2D;\\n        } \\n        for(auto const &[k,v]:\\uD83D\\uDE09) if(v==\\uD83E\\uDD7A) return k;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822405,
                "title": "c-simple-map-solution-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==key){\\n                int temp=nums[i+1];\\n                mp[temp]++;\\n            }\\n        }\\n        int maxi=0;\\n        int ans=0;\\n        for(auto it:mp){\\n            if(it.second>maxi){\\n             maxi=it.second;\\n             ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==key){\\n                int temp=nums[i+1];\\n                mp[temp]++;\\n            }\\n        }\\n        int maxi=0;\\n        int ans=0;\\n        for(auto it:mp){\\n            if(it.second>maxi){\\n             maxi=it.second;\\n             ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822045,
                "title": "c-o-n-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> hash;\\n        int ans,cur=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key && i+1<nums.size()){\\n                hash[nums[i+1]]++;\\n                if(hash[nums[i+1]]>cur){\\n                    cur=hash[nums[i+1]];\\n                    ans=nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> hash;\\n        int ans,cur=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key && i+1<nums.size()){\\n                hash[nums[i+1]]++;\\n                if(hash[nums[i+1]]>cur){\\n                    cur=hash[nums[i+1]];\\n                    ans=nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821955,
                "title": "python3-simple-approach",
                "content": "```\\nimport collections\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dic = collections.defaultdict(int)\\n        ans = float(\"inf\")\\n        temp = 0\\n        for i in range(len(nums)-1):\\n            if nums[i] == key:\\n                dic[nums[i+1]] += 1\\n                if temp < dic[nums[i+1]]:\\n                    ans = nums[i+1]\\n                    temp = dic[nums[i+1]]\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dic = collections.defaultdict(int)\\n        ans = float(\"inf\")\\n        temp = 0\\n        for i in range(len(nums)-1):\\n            if nums[i] == key:\\n                dic[nums[i+1]] += 1\\n                if temp < dic[nums[i+1]]:\\n                    ans = nums[i+1]\\n                    temp = dic[nums[i+1]]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951863,
                "title": "java-easy-solution-with-hashmap-must-see",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int n=nums.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==key){\\n                int target=nums[i+1];\\n                map.put(target,map.getOrDefault(target,0)+1);\\n            }\\n        }\\n        int max=0;\\n        int re=0;\\n        for(int x:map.keySet()){\\n            if(map.get(x)>max){\\n                re=x;\\n                max=map.get(x);\\n            }\\n        }\\n        return re;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int n=nums.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==key){\\n                int target=nums[i+1];\\n                map.put(target,map.getOrDefault(target,0)+1);\\n            }\\n        }\\n        int max=0;\\n        int re=0;\\n        for(int x:map.keySet()){\\n            if(map.get(x)>max){\\n                re=x;\\n                max=map.get(x);\\n            }\\n        }\\n        return re;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445991,
                "title": "clean-short-and-easist-java-solution-takes-1ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintaining a counting array just like we do in counting sort.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int[] count = new int[1001];\\n        \\n        //building our counting array\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                \\n                count[nums[i+1]]++;\\n            }\\n        }\\n\\n        //finding the index with the greatest entry\\n        int maxIndex=0;\\n        for(int i=0; i<count.length; i++) \\n        {\\n            maxIndex = count[i]>count[maxIndex] ? i : maxIndex;\\n        }\\n\\n        return maxIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int[] count = new int[1001];\\n        \\n        //building our counting array\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                \\n                count[nums[i+1]]++;\\n            }\\n        }\\n\\n        //finding the index with the greatest entry\\n        int maxIndex=0;\\n        for(int i=0; i<count.length; i++) \\n        {\\n            maxIndex = count[i]>count[maxIndex] ? i : maxIndex;\\n        }\\n\\n        return maxIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392589,
                "title": "most-frequent-number-following-key-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int i, max=0, ans;\\n        unordered_map<int, int> m;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==key && i<nums.size()-1)\\n            {\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        max = INT_MIN;\\n        for(auto it:m)\\n        {\\n            if(it.second>max)\\n            {\\n                max = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int i, max=0, ans;\\n        unordered_map<int, int> m;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==key && i<nums.size()-1)\\n            {\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        max = INT_MIN;\\n        for(auto it:m)\\n        {\\n            if(it.second>max)\\n            {\\n                max = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392578,
                "title": "most-frequent-number-following-key-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int i, j, count=0, max=0, ans=-1;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==key && i<nums.size()-1 && nums[i+1]!=ans)\\n            {\\n                count=0;\\n                for(j=i+1 ; j<nums.size() ; j++)\\n                {\\n                    if(nums[j-1]==key && nums[j]==nums[i+1])\\n                    {\\n                        count++;\\n                    }\\n                }\\n                if(count>max)\\n                {\\n                    max = count;\\n                    ans = nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int i, j, count=0, max=0, ans=-1;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==key && i<nums.size()-1 && nums[i+1]!=ans)\\n            {\\n                count=0;\\n                for(j=i+1 ; j<nums.size() ; j++)\\n                {\\n                    if(nums[j-1]==key && nums[j]==nums[i+1])\\n                    {\\n                        count++;\\n                    }\\n                }\\n                if(count>max)\\n                {\\n                    max = count;\\n                    ans = nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168514,
                "title": "easy-and-simple-approach-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        int maxi=-1;\\n        int res=-1;\\n        for(auto it:mp)\\n        {\\n            if(maxi<it.second)\\n            {\\n                maxi=it.second;\\n                res=it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        int maxi=-1;\\n        int res=-1;\\n        for(auto it:mp)\\n        {\\n            if(maxi<it.second)\\n            {\\n                maxi=it.second;\\n                res=it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968059,
                "title": "easier-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int maxi=Integer.MIN_VALUE;\\n\\n    int maxvalue=0;\\n\\n    for(int i=0;i<nums.length-1;i++){\\n        \\n    if(nums[i]==key){\\n\\n    if(!mp.containsKey(nums[i+1])){\\n        mp.put(nums[i+1],1);\\n    }\\n    else{\\n        mp.put(nums[i+1],mp.get(nums[i+1])+1);\\n    }\\n\\n    if(maxi<mp.get(nums[i+1])){\\n        maxi=mp.get(nums[i+1]);\\n        maxvalue=nums[i+1];\\n    }\\n\\n    }\\n\\n    }\\n\\n    return maxvalue;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int maxi=Integer.MIN_VALUE;\\n\\n    int maxvalue=0;\\n\\n    for(int i=0;i<nums.length-1;i++){\\n        \\n    if(nums[i]==key){\\n\\n    if(!mp.containsKey(nums[i+1])){\\n        mp.put(nums[i+1],1);\\n    }\\n    else{\\n        mp.put(nums[i+1],mp.get(nums[i+1])+1);\\n    }\\n\\n    if(maxi<mp.get(nums[i+1])){\\n        maxi=mp.get(nums[i+1]);\\n        maxvalue=nums[i+1];\\n    }\\n\\n    }\\n\\n    }\\n\\n    return maxvalue;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761273,
                "title": "scala-hashmap",
                "content": "```\\nimport scala.collection.mutable.HashMap\\n\\nobject Solution {\\n    def mostFrequent(nums: Array[Int], key: Int): Int = {\\n        var freqs = HashMap[Int, Int]()\\n        \\n        nums\\n        .zip {nums drop 1}\\n        .collect {case (a, b) if a == key => b}\\n        .foreach(a => freqs contains a match {\\n            case true => freqs(a) += 1\\n            case _ => freqs(a) = 1\\n         }) // calculate frequencies\\n        \\n        (freqs maxBy {_._2})\\n        ._1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.mutable.HashMap\\n\\nobject Solution {\\n    def mostFrequent(nums: Array[Int], key: Int): Int = {\\n        var freqs = HashMap[Int, Int]()\\n        \\n        nums\\n        .zip {nums drop 1}\\n        .collect {case (a, b) if a == key => b}\\n        .foreach(a => freqs contains a match {\\n            case true => freqs(a) += 1\\n            case _ => freqs(a) = 1\\n         }) // calculate frequencies\\n        \\n        (freqs maxBy {_._2})\\n        ._1\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2570608,
                "title": "ruby-one-liner-solution",
                "content": "```\\n# @param {Integer[]} nums\\n# @param {Integer} key\\n# @return {Integer}\\ndef most_frequent(nums, key)\\n    nums.select.with_index{|_, i| nums[i-1] == key}.tally.sort_by{|_, v| v}.to_h.keys[-1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} key\\n# @return {Integer}\\ndef most_frequent(nums, key)\\n    nums.select.with_index{|_, i| nums[i-1] == key}.tally.sort_by{|_, v| v}.to_h.keys[-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2501649,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n\\t\\t// 2 ms t.c.\\n        int[] arr = new int[1001];\\n        int max = 0;\\n        int ans = 0;\\n\\n        for (int i = 0; i < nums.length - 1; i++){\\n            if (nums[i] == key){\\n                arr[nums[i+1]]++;\\n                if (max < arr[nums[i+1]]){\\n                    max = arr[nums[i+1]];\\n                    ans = nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n        // 45 % runtime - 5 ms t.c.\\n//         Map<Integer, Integer> map = new HashMap<>();\\n\\n//         for (int i = 0; i < nums.length - 1; i++){\\n//             if (nums[i] == key){\\n//                 map.merge(nums[i+1], 1, Integer::sum);\\n//             }\\n//         }\\n//         int max = 0;\\n//         int ans = 0;\\n//         for(int i: map.keySet()){\\n//             if (max < map.get(i)){\\n//                 max = map.get(i);\\n//                 ans = i;\\n//             }\\n//         }\\n//         return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2430687,
                "title": "python-easy-solution",
                "content": "```class Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        cnt=0\\n        res=[]\\n        res1=0\\n        a=0\\n        for i in range(len(nums)-1):\\n            if(nums[i]==key):\\n                res.append(nums[i+1])\\n        for i in res:\\n            if(a<res.count(i)):\\n                cnt=i\\n            a=max(a,res.count(i))\\n        return cnt",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        cnt=0\\n        res=[]\\n        res1=0\\n        a=0\\n        for i in range(len(nums)-1):\\n            if(nums[i]==key):\\n                res.append(nums[i+1])\\n        for i in res:\\n            if(a<res.count(i)):\\n                cnt=i\\n            a=max(a,res.count(i))\\n        return cnt",
                "codeTag": "Java"
            },
            {
                "id": 2421950,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        arr = [nums[i + 1] for i in range(len(nums) - 1) if nums[i] == key]\\n        c = Counter(arr)\\n        return max(c, key=c.get)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        arr = [nums[i + 1] for i in range(len(nums) - 1) if nums[i] == key]\\n        c = Counter(arr)\\n        return max(c, key=c.get)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381335,
                "title": "c-very-easy-solution",
                "content": "map<int,int>m;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i] == key)\\n                m[nums[i+1]]++;\\n        }\\n        \\n        int max=0, res=1;\\n        for(auto i: m)\\n        {\\n            if(i.second > max)\\n            {\\n                max = i.second;\\n                res = i.first;\\n            }\\n        }\\n        return res;",
                "solutionTags": [
                    "C"
                ],
                "code": "map<int,int>m;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i] == key)\\n                m[nums[i+1]]++;\\n        }\\n        \\n        int max=0, res=1;\\n        for(auto i: m)\\n        {\\n            if(i.second > max)\\n            {\\n                max = i.second;\\n                res = i.first;\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 2269234,
                "title": "one-traversal-o-n-time-and-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> mp;\\n        int count=0, res=1;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                mp[nums[i+1]]++;\\n                if(count < mp[nums[i+1]]) {\\n                    res = nums[i+1];\\n                    count = mp[nums[i+1]];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> mp;\\n        int count=0, res=1;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                mp[nums[i+1]]++;\\n                if(count < mp[nums[i+1]]) {\\n                    res = nums[i+1];\\n                    count = mp[nums[i+1]];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213533,
                "title": "go-one-pass",
                "content": "```\\nfunc mostFrequent(nums []int, key int) int {\\n    res, max, d := 0, 0, make(map[int]int)\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if nums[i - 1] == key {\\n            target := nums[i]\\n            \\n            d[target]++\\n            \\n            if d[target] > max {\\n                max = d[target]\\n                res = target\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mostFrequent(nums []int, key int) int {\\n    res, max, d := 0, 0, make(map[int]int)\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if nums[i - 1] == key {\\n            target := nums[i]\\n            \\n            d[target]++\\n            \\n            if d[target] > max {\\n                max = d[target]\\n                res = target\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2209890,
                "title": "a-very-intuitive-approach-only-one-loop-and-a-condition",
                "content": "So basically I am considering it as pairs and storing it in hashmap (key, target) pairs, (Method of storing paris is converting to string) Then the pair whose count is the highest is returned, Then the target in that is obtained via substring and target is returned, \\n\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n        HashMap<String, Integer> hm = new HashMap<>();\\n        int maxCount= Integer.MIN_VALUE;\\n       String ans = \"\";\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n               String s = Integer.toString(nums[i]);\\n                   s+= (Integer.toString(nums[i+1]));\\n               if(hm.containsKey(s))\\n                        {\\n                           hm.put(s,hm.get(s)+1);\\n                           if((int)hm.get(s)>maxCount)\\n                           {\\n                               maxCount = hm.get(s);\\n                               ans = (String)s;\\n                           }\\n                        }\\n               else \\n                        {\\n                            hm.put(s,1);\\n                            if((int)hm.get(s)>maxCount)\\n                           {\\n                               maxCount = hm.get(s);\\n                               ans = (String)s;\\n                           }\\n                        } \\n            }\\n        }\\n        \\n        ans = ans.substring(Integer.toString(key).length());\\n        return Integer.parseInt(ans);\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n        HashMap<String, Integer> hm = new HashMap<>();\\n        int maxCount= Integer.MIN_VALUE;\\n       String ans = \"\";\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n               String s = Integer.toString(nums[i]);\\n                   s+= (Integer.toString(nums[i+1]));\\n               if(hm.containsKey(s))\\n                        {\\n                           hm.put(s,hm.get(s)+1);\\n                           if((int)hm.get(s)>maxCount)\\n                           {\\n                               maxCount = hm.get(s);\\n                               ans = (String)s;\\n                           }\\n                        }\\n               else \\n                        {\\n                            hm.put(s,1);\\n                            if((int)hm.get(s)>maxCount)\\n                           {\\n                               maxCount = hm.get(s);\\n                               ans = (String)s;\\n                           }\\n                        } \\n            }\\n        }\\n        \\n        ans = ans.substring(Integer.toString(key).length());\\n        return Integer.parseInt(ans);\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206477,
                "title": "easy-to-understand-java-super-simple-hashmap",
                "content": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        // Iterate through nums for n - 1 times\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] == key){\\n                // Put the next element into the map and increment its value\\n                map.put(nums[i+1], map.getOrDefault(nums[i+1], 0) + 1);\\n            }\\n        }\\n\\n        int output = 0; // To store the target\\n        int maxCount = 0; // To set the target with maximum frequency\\n        \\n        // Loop through the map\\n        for (var entry : map.entrySet()) {\\n            if(maxCount < entry.getValue()){ // If the value of current entry is greater than maxCount\\n                maxCount = entry.getValue(); // Set the maxCount to that value\\n                output = entry.getKey(); // Set that value\\'s key to output\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        // Iterate through nums for n - 1 times\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] == key){\\n                // Put the next element into the map and increment its value\\n                map.put(nums[i+1], map.getOrDefault(nums[i+1], 0) + 1);\\n            }\\n        }\\n\\n        int output = 0; // To store the target\\n        int maxCount = 0; // To set the target with maximum frequency\\n        \\n        // Loop through the map\\n        for (var entry : map.entrySet()) {\\n            if(maxCount < entry.getValue()){ // If the value of current entry is greater than maxCount\\n                maxCount = entry.getValue(); // Set the maxCount to that value\\n                output = entry.getKey(); // Set that value\\'s key to output\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135601,
                "title": "java-simple-3-liner",
                "content": "**Idea:** Count the frequencies of each target and return the target with max frequency\\n>**T/S:** O(n)/O(n), where n = size(nums)\\n```\\npublic int mostFrequent(int[] nums, int key) {\\n\\tvar targetCount = new HashMap<Integer, Integer>();\\n\\t\\n\\tIntStream.iterate(0, i -> i + 1 < nums.length, i -> i + 1)\\n\\t\\t\\t .filter(i -> nums[i] == key)\\n\\t\\t\\t .forEach(i -> targetCount.compute(nums[i + 1], (k, v) -> v == null ? 1 : ++v));\\n\\t\\n\\treturn Collections.max(targetCount.entrySet(), Comparator.comparingInt(Map.Entry::getValue))\\n\\t\\t\\t\\t\\t  .getKey();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int mostFrequent(int[] nums, int key) {\\n\\tvar targetCount = new HashMap<Integer, Integer>();\\n\\t\\n\\tIntStream.iterate(0, i -> i + 1 < nums.length, i -> i + 1)\\n\\t\\t\\t .filter(i -> nums[i] == key)\\n\\t\\t\\t .forEach(i -> targetCount.compute(nums[i + 1], (k, v) -> v == null ? 1 : ++v));\\n\\t\\n\\treturn Collections.max(targetCount.entrySet(), Comparator.comparingInt(Map.Entry::getValue))\\n\\t\\t\\t\\t\\t  .getKey();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2135357,
                "title": "c-easy-solution-using-maps",
                "content": "class Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map <int,int> m;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        int max=0,ans=0;\\n        for(auto it: m){\\n            if(it.second>max){\\n                max=it.second;\\n                ans= it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map <int,int> m;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                m[nums[i+1]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1948066,
                "title": "simple-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        int ans=0,count=0;\\n        for(auto i:mp){\\n            if(i.second>count){\\n                ans=i.first;\\n                count = i.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        int ans=0,count=0;\\n        for(auto i:mp){\\n            if(i.second>count){\\n                ans=i.first;\\n                count = i.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914928,
                "title": "python3-dictionary-solution-with-explanation",
                "content": "Loop through the nums array, if  we found key chech the elements after it, if we have it in the dictionary increased it\\'s counter (How many time it come after the key) otherwise add it to the dictionary, Finally return the key related to max value in the dictionary.\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        \\n        m = {}\\n        for i in range(len(nums) - 1):\\n            if nums[i] == key:\\n                if nums[i + 1] in m:\\n                    m[nums[i + 1]] += 1\\n                else:\\n                    m[nums[i + 1]] = 1\\n\\n        # Get the value related to the max value in the dictionary\\n\\t\\treturn max(m, key = lambda k : m[k])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        \\n        m = {}\\n        for i in range(len(nums) - 1):\\n            if nums[i] == key:\\n                if nums[i + 1] in m:\\n                    m[nums[i + 1]] += 1\\n                else:\\n                    m[nums[i + 1]] = 1\\n\\n        # Get the value related to the max value in the dictionary\\n\\t\\treturn max(m, key = lambda k : m[k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910546,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nint mostFrequent(vector<int>& nums, int key) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> my_map;\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            if(nums[i] == key)\\n            {\\n                my_map[nums[i + 1]]++;\\n            }\\n        }\\n        \\n        int maxi = 0;\\n        \\n        int max_count = 0;\\n        \\n        for(auto x : my_map)\\n        {\\n            if(x.second > max_count)\\n            {\\n                maxi = x.first;\\n                \\n                max_count = x.second;\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint mostFrequent(vector<int>& nums, int key) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> my_map;\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            if(nums[i] == key)\\n            {\\n                my_map[nums[i + 1]]++;\\n            }\\n        }\\n        \\n        int maxi = 0;\\n        \\n        int max_count = 0;\\n        \\n        for(auto x : my_map)\\n        {\\n            if(x.second > max_count)\\n            {\\n                maxi = x.first;\\n                \\n                max_count = x.second;\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901533,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        int ans,count=INT_MIN;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                mp[nums[i+1]]++;\\n                if(count<mp[nums[i+1]])\\n                {\\n                    count=mp[nums[i+1]];\\n                    ans=nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        int ans,count=INT_MIN;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                mp[nums[i+1]]++;\\n                if(count<mp[nums[i+1]])\\n                {\\n                    count=mp[nums[i+1]];\\n                    ans=nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849316,
                "title": "java-easy-solution-o-n-time",
                "content": "```\\nclass Solution {\\n    public int mostFrequent(int[] arr1, int key) {\\n        int []count =new int[1001]; \\n        for(int i=0;i<arr1.length-1;i++)\\n        {\\n            if(arr1[i]==key)\\n            {\\n                count[arr1[i+1]]++; \\n            }            \\n        }\\n        int ans=0;\\n        int max=0;\\n        for(int i=0;i<count.length;i++)\\n        {\\n            if(count[i]>max)\\n            {\\n                max=count[i];\\n                ans=i;\\n            }            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int mostFrequent(int[] arr1, int key) {\\n        int []count =new int[1001]; \\n        for(int i=0;i<arr1.length-1;i++)\\n        {\\n            if(arr1[i]==key)\\n            {\\n                count[arr1[i+1]]++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1843220,
                "title": "c-solution-using-hash-map",
                "content": "```\\nclass Solution {\\n  public:\\n    int mostFrequent(vector < int > & nums, int key) {\\n      unordered_map < int, int > umap;\\n      int prev = nums[0], maxCount = 0;\\n      int ans;\\n      for (int i = 1; i < nums.size(); i++) {\\n        if (prev == key) {\\n          umap[nums[i]]++;\\n          if (umap[nums[i]] > maxCount) {\\n            maxCount = umap[nums[i]];\\n            ans = nums[i];\\n          }\\n        }\\n        prev = nums[i];\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int mostFrequent(vector < int > & nums, int key) {\\n      unordered_map < int, int > umap;\\n      int prev = nums[0], maxCount = 0;\\n      int ans;\\n      for (int i = 1; i < nums.size(); i++) {\\n        if (prev == key) {\\n          umap[nums[i]]++;\\n          if (umap[nums[i]] > maxCount) {\\n            maxCount = umap[nums[i]];\\n            ans = nums[i];\\n          }\\n        }\\n        prev = nums[i];\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842055,
                "title": "java-hashmap-easy",
                "content": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==key){\\n                if(hm.containsKey(nums[i]))\\n                    hm.put(nums[i],hm.get(nums[i])+1);\\n                else\\n                    hm.put(nums[i],1);\\n            }\\n        }\\n        int max=Integer.MIN_VALUE; \\n        for (Map.Entry<Integer,Integer> e : hm.entrySet()){\\n             if((int)e.getValue()>max){\\n                 max=(int)e.getValue();\\n                 ans=(int)e.getKey();\\n             }\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==key){\\n                if(hm.containsKey(nums[i]))\\n                    hm.put(nums[i],hm.get(nums[i])+1);\\n                else\\n                    hm.put(nums[i],1);\\n            }\\n        }\\n        int max=Integer.MIN_VALUE; \\n        for (Map.Entry<Integer,Integer> e : hm.entrySet()){\\n             if((int)e.getValue()>max){\\n                 max=(int)e.getValue();\\n                 ans=(int)e.getKey();\\n             }\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841758,
                "title": "hashmap-java-easy-solution",
                "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int max=Integer.MIN_VALUE;\\n        int res=0;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<=nums.length-2;i++){\\n        if(nums[i]==key){\\n            if(!map.containsKey(nums[i+1])) map.put(nums[i+1],1);\\n            else map.put(nums[i+1],map.get(nums[i+1])+1); \\n            if(map.get(nums[i+1])>max){\\n                max=map.get(nums[i+1]);\\n                res=nums[i+1];\\n            }\\n        }    \\n        }\\n        return res;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int max=Integer.MIN_VALUE;\\n        int res=0;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<=nums.length-2;i++){\\n        if(nums[i]==key){\\n            if(!map.containsKey(nums[i+1])) map.put(nums[i+1],1);\\n            else map.put(nums[i+1],map.get(nums[i+1])+1); \\n            if(map.get(nums[i+1])>max){\\n                max=map.get(nums[i+1]);\\n                res=nums[i+1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1838200,
                "title": "swift-solution",
                "content": "* use a dictionary to track count of numbers that occur one index AFTER key\\n* track max count\\n* return most frequently seen number\\n\\n```\\n// ~ O(n) time\\n// ~ O(n) space\\n\\nclass Solution {\\n    func mostFrequent(_ nums: [Int], _ key: Int) -> Int {\\n        var numToReturn = Int.min\\n        var maxCount = Int.min\\n        \\n        var numAfterKeyCount = [Int: Int]()\\n        for i in 0 ..< nums.count - 1 {\\n            let num = nums[i]\\n            if num == key {\\n                let numAfterKey = nums[i+1]\\n                var updatedCount = 1\\n                if let count = numAfterKeyCount[numAfterKey] {\\n                    updatedCount = count + 1\\n                }\\n                numAfterKeyCount[numAfterKey] = updatedCount\\n                \\n                if updatedCount > maxCount {\\n                    maxCount = updatedCount\\n                    numToReturn = numAfterKey\\n                }\\n            }\\n        }\\n        \\n        return numToReturn\\n    }\\n}",
                "solutionTags": [
                    "Swift"
                ],
                "code": "class Solution {\\n    func mostFrequent(_ nums: [Int], _ key: Int) -> Int {\\n        var numToReturn = Int.min\\n        var maxCount = Int.min\\n        \\n        var numAfterKeyCount = [Int: Int]()\\n        for i in 0 ..< nums.count - 1 {\\n            let num = nums[i]\\n            if num == key {\\n                let numAfterKey = nums[i+1]\\n                var updatedCount = 1\\n                if let count = numAfterKeyCount[numAfterKey] {\\n                    updatedCount = count + 1\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1828698,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int,int> mp;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]==key)\\n            {\\n                mp[nums[i]]++;\\n            }\\n            \\n        }\\n        \\n        int maxi=INT_MIN;\\n        int ans;\\n        for(auto it:mp)\\n        {\\n            \\n            if(maxi<it.second)\\n            {\\n                ans=it.first;\\n                maxi=it.second;\\n            }\\n          //  cout<<it.first<<\" \"<<it.second<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int,int> mp;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]==key)\\n            {\\n                mp[nums[i]]++;\\n            }\\n            \\n        }\\n        \\n        int maxi=INT_MIN;\\n        int ans;\\n        for(auto it:mp)\\n        {\\n            \\n            if(maxi<it.second)\\n            {\\n                ans=it.first;\\n                maxi=it.second;\\n            }\\n          //  cout<<it.first<<\" \"<<it.second<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1825445,
                "title": "easy-to-understand-for-beginners-as-well",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    const obj={} // to keep track the occurances after the key\\n    let count=0;\\n    let res=nums[0]\\n    for(let i=1;i<nums.length;i++){\\n        if(nums[i-1]===key){\\n            if(obj[nums[i]]){\\n                obj[nums[i]]+=1\\n            }else{\\n                obj[nums[i]]=1\\n            }\\n            if(count<obj[nums[i]]){\\n                count=obj[nums[i]]\\n                res=nums[i]\\n            }\\n        }\\n    }\\n    return res\\n};\\n```\\nRuntime: 115 ms, faster than 100.00% of JavaScript online submissions for Most Frequent Number Following Key In an Array.\\nMemory Usage: 44.6 MB, less than 100.00% of JavaScript online submissions for Most Frequent Number Following Key In an Array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    const obj={} // to keep track the occurances after the key\\n    let count=0;\\n    let res=nums[0]\\n    for(let i=1;i<nums.length;i++){\\n        if(nums[i-1]===key){\\n            if(obj[nums[i]]){\\n                obj[nums[i]]+=1\\n            }else{\\n                obj[nums[i]]=1\\n            }\\n            if(count<obj[nums[i]]){\\n                count=obj[nums[i]]\\n                res=nums[i]\\n            }\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825232,
                "title": "c-frequency-map-solution-100-time-50-space",
                "content": "This is a rather straightforward problem to tackle, if you think about it without being given extra constraints: every time we find a match, we look at the following element, then we update its frequency and act accordingly - we can do it all in a single pass.\\n\\nTo do so, we will start with a few support variables:\\n* `target`, will store the value of the element immediately after the current one, if we find a match;\\n* `res` will keep our best/most frequent result;\\n* `maxF`, will store the value of the maximum frequency found so far - initially set to `-1`;\\n* `freq` is our frequency map, in the value => frequency format.\\n\\nWe will then parse all the elements in `nums` other than the last one (which cannot have a following one) with `i` and whenever we find a match (`nums[i] == key`), we will:\\n* set `target` to be `nums[i + 1]`;\\n* check if its updated frequency (`++freq[target]`) is greater than `maxF` and, in case:\\n\\t* update `maxF` to be  `freq[target]`;\\n\\t* update `res` to be `target`.\\n\\nOnce done, we can `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        // support variables\\n        int target, res, maxF = -1;\\n        unordered_map<int, int> freq;\\n        // parsing nums\\n        for (int i = 0, len = nums.size() - 1; i < len; i++) {\\n            // current elemment is a match\\n            if (nums[i] == key) {\\n                target = nums[i + 1];\\n                // updating the frequency of target and checking if it is a new maximum\\n                if (++freq[target] > maxF) {\\n                    maxF = freq[target];\\n                    res = target;\\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut do we really need a hashtable here?\\n\\nProbably not - better performance with a simple array:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        // support variables\\n        int target, res, maxF = -1, freq[1001] = {};\\n        // parsing nums\\n        for (int i = 0, len = nums.size() - 1; i < len; i++) {\\n            // current elemment is a match\\n            if (nums[i] == key) {\\n                target = nums[i + 1];\\n                // updating the frequency of target and checking if it is a new maximum\\n                if (++freq[target] > maxF) {\\n                    maxF = freq[target];\\n                    res = target;\\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        // support variables\\n        int target, res, maxF = -1;\\n        unordered_map<int, int> freq;\\n        // parsing nums\\n        for (int i = 0, len = nums.size() - 1; i < len; i++) {\\n            // current elemment is a match\\n            if (nums[i] == key) {\\n                target = nums[i + 1];\\n                // updating the frequency of target and checking if it is a new maximum\\n                if (++freq[target] > maxF) {\\n                    maxF = freq[target];\\n                    res = target;\\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        // support variables\\n        int target, res, maxF = -1, freq[1001] = {};\\n        // parsing nums\\n        for (int i = 0, len = nums.size() - 1; i < len; i++) {\\n            // current elemment is a match\\n            if (nums[i] == key) {\\n                target = nums[i + 1];\\n                // updating the frequency of target and checking if it is a new maximum\\n                if (++freq[target] > maxF) {\\n                    maxF = freq[target];\\n                    res = target;\\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823894,
                "title": "java-clean-solution",
                "content": "\\n    public int mostFrequent(int[] nums, int key) {\\n         int arr[] = new int[1001];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i - 1] == key) { \\n                arr[nums[i]]++;\\n            }\\n        }        \\n        int ans = 0;\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > arr[ans]) {\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int mostFrequent(int[] nums, int key) {\\n         int arr[] = new int[1001];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i - 1] == key) { \\n                arr[nums[i]]++;\\n            }\\n        }        \\n        int ans = 0;\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > arr[ans]) {\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1822593,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        c = defaultdict(int)\\n        max_count = 0\\n        max_target = 0 \\n        for i in range(1, len(nums)):\\n            if nums[i-1] == key:\\n                c[nums[i]] += 1\\n                if c[nums[i]] > max_count:\\n                    max_count = c[nums[i]]\\n                    max_target = nums[i]\\n        \\n        return max_target\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        c = defaultdict(int)\\n        max_count = 0\\n        max_target = 0 \\n        for i in range(1, len(nums)):\\n            if nums[i-1] == key:\\n                c[nums[i]] += 1\\n                if c[nums[i]] > max_count:\\n                    max_count = c[nums[i]]\\n                    max_target = nums[i]\\n        \\n        return max_target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822495,
                "title": "o-n-time-single-traversal-solution-easy-to-understand-using-hashmap",
                "content": "```\\nint mostFrequent(vector& nums, int key) {\\n\\tmap<int,int>mp;\\n\\tint target=-1;\\n\\tint max_count = INT_MIN, res = target;\\n\\n    for(int i=0; i<nums.size()-1; i++){\\n        if(nums[i]==key){\\n            target=nums[i+1];\\n            mp[target]++;\\n        if (max_count < mp[target]) {\\n                res = target;\\n                max_count = mp[target];\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\nTime Complexity: **O(N)**\\nSpace Complexity: **O(N)**\\n\\n**Like it? Please Upvote!!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint mostFrequent(vector& nums, int key) {\\n\\tmap<int,int>mp;\\n\\tint target=-1;\\n\\tint max_count = INT_MIN, res = target;\\n\\n    for(int i=0; i<nums.size()-1; i++){\\n        if(nums[i]==key){\\n            target=nums[i+1];\\n            mp[target]++;\\n        if (max_count < mp[target]) {\\n                res = target;\\n                max_count = mp[target];\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822417,
                "title": "simple-kotlin-code",
                "content": "```\\nclass Solution {\\n    fun mostFrequent(nums: IntArray, key: Int): Int {\\n        var map = hashMapOf<Int,Int>()\\n        var target = 0\\n        var maxCount = 0\\n        for(i in 0 until nums.size-1){\\n            if(nums[i] == key){\\n                val currentTarget = nums[i+1]\\n                val count = map.getOrDefault(currentTarget,0) + 1\\n                if(count>maxCount){\\n                    maxCount = count\\n                    target = currentTarget\\n                }\\n                \\n                map[currentTarget] = count\\n            }\\n        }\\n    \\n        return target\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun mostFrequent(nums: IntArray, key: Int): Int {\\n        var map = hashMapOf<Int,Int>()\\n        var target = 0\\n        var maxCount = 0\\n        for(i in 0 until nums.size-1){\\n            if(nums[i] == key){\\n                val currentTarget = nums[i+1]\\n                val count = map.getOrDefault(currentTarget,0) + 1\\n                if(count>maxCount){\\n                    maxCount = count\\n                    target = currentTarget\\n                }\\n                \\n                map[currentTarget] = count\\n            }\\n        }\\n    \\n        return target\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822346,
                "title": "python3-hashmap-easy",
                "content": "```\\n\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        ans=0\\n        d=defaultdict(int)\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                d[nums[i+1]]+=1\\n        z=list(d.items())\\n        z.sort(key=lambda x:x[1])\\n        return z[-1][0]\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        ans=0\\n        d=defaultdict(int)\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                d[nums[i+1]]+=1\\n        z=list(d.items())\\n        z.sort(key=lambda x:x[1])\\n        return z[-1][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822310,
                "title": "c-brute-force-hashmap",
                "content": "```\\nint mostFrequent(vector<int>& nums, int key) {\\n        int hash[1001] = {0};\\n        for(int i=0; i<nums.size(); i++){\\n            hash[nums[i]]++;\\n        }\\n        vector<int>target;\\n        int ans, res = INT_MIN;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == key){\\n                target.push_back(nums[i+1]);\\n            }\\n        }\\n        for(int i=0; i<target.size(); i++){\\n            int occurance = hash[target[i]];\\n            if(occurance > res){\\n                res = occurance;\\n                ans = target[i];\\n            }\\n        }   \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint mostFrequent(vector<int>& nums, int key) {\\n        int hash[1001] = {0};\\n        for(int i=0; i<nums.size(); i++){\\n            hash[nums[i]]++;\\n        }\\n        vector<int>target;\\n        int ans, res = INT_MIN;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == key){\\n                target.push_back(nums[i+1]);\\n            }\\n        }\\n        for(int i=0; i<target.size(); i++){\\n            int occurance = hash[target[i]];\\n            if(occurance > res){\\n                res = occurance;\\n                ans = target[i];\\n            }\\n        }   \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1822289,
                "title": "c-solution-brute-force-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> um;\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==key){\\n                um[nums[i+1]]++;\\n            }\\n        }\\n        nums.clear();\\n        int count=0;\\n        int ele;\\n        for(auto a:um){\\n            if(a.second>count){\\n                count=a.second;\\n                ele=a.first;\\n            }\\n        }\\n        return ele;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> um;\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==key){\\n                um[nums[i+1]]++;\\n            }\\n        }\\n        nums.clear();\\n        int count=0;\\n        int ele;\\n        for(auto a:um){\\n            if(a.second>count){\\n                count=a.second;\\n                ele=a.first;\\n            }\\n        }\\n        return ele;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822280,
                "title": "c-easy-to-understand-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) \\n    {\\n        // Use a map for storing the frequency of target value\\n        map<int,int> mp;\\n        \\n        // as given in question we need to check from 0 to n-2\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)    // if it is our key value then chekc the target \\n            {\\n                mp[nums[i+1]]++;           // increase the frequency of occurance of target \\n            }\\n        }\\n        \\n        // finding the most frequent following key\\n        int mx = INT_MIN;\\n        int target = -1;                                 // initialize target with -1   \\n        \\n        for(auto it : mp)      // iterate upon the map\\n        {\\n            if(mx<it.second) // if found any max frequent element just store that \\n            {\\n                mx = it.second;           // storing that element frequency count\\n                target = it.first;        // storing that element\\n            }\\n        }\\n        return target;\\n    }\\n};\\n```\\n\\nUpvote it , if you liked .........",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) \\n    {\\n        // Use a map for storing the frequency of target value\\n        map<int,int> mp;\\n        \\n        // as given in question we need to check from 0 to n-2\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)    // if it is our key value then chekc the target \\n            {\\n                mp[nums[i+1]]++;           // increase the frequency of occurance of target \\n            }\\n        }\\n        \\n        // finding the most frequent following key\\n        int mx = INT_MIN;\\n        int target = -1;                                 // initialize target with -1   \\n        \\n        for(auto it : mp)      // iterate upon the map\\n        {\\n            if(mx<it.second) // if found any max frequent element just store that \\n            {\\n                mx = it.second;           // storing that element frequency count\\n                target = it.first;        // storing that element\\n            }\\n        }\\n        return target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822224,
                "title": "c-straightforward-solution",
                "content": "The most difficult part, I think is undestanding the description of the problem.\\n* Basically it give an integer array `nums`. E.g. `nums = [1,100,2,300,1,100,1,300]`\\n* then a `key` (which is a value that exists in `nums`). E.g. `key = 1`\\n* with this `key` you need to find `target` (which is the value after `key`), so `target = [100,100,300]` because nums = [1,**100**,2,300,1,**100**,1,**300**]\\n* now just count `target`, in this example in `target` you have \\n\\t* 2 `100`\\n\\t* 1 `300`\\n* The highest is (2 `100`) so the result is `100` \\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int,int> target_count;\\n        \\n\\t\\t//count for each target\\n        for (int i = 0; i < nums.size() - 1; i++)\\n            if (nums[i] == key)\\n                target_count[nums[i + 1]]++;\\n        \\n        int max_target_count = 0;\\n        int target;\\n\\t//find the target with highest count and return it\\n        for (auto c : target_count)\\n            if (c.second > max_target_count){\\n                target = c.first;\\n                max_target_count = c.second;\\n            }\\n        \\n        return target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int,int> target_count;\\n        \\n\\t\\t//count for each target\\n        for (int i = 0; i < nums.size() - 1; i++)\\n            if (nums[i] == key)\\n                target_count[nums[i + 1]]++;\\n        \\n        int max_target_count = 0;\\n        int target;\\n\\t//find the target with highest count and return it\\n        for (auto c : target_count)\\n            if (c.second > max_target_count){\\n                target = c.first;\\n                max_target_count = c.second;\\n            }\\n        \\n        return target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822173,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        int x1=0;int y;\\n        for(auto x:m){\\n            if(x.second >x1){\\n                x1=x.second;y=x.first;\\n            }\\n        }\\n        return y;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        int x1=0;int y;\\n        for(auto x:m){\\n            if(x.second >x1){\\n                x1=x.second;y=x.first;\\n            }\\n        }\\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822070,
                "title": "easy-to-understand-fastest-simplified-o-n-time",
                "content": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dict={}\\n        \\n        for i in range(0,len(nums)-1):\\n            target=nums\\n            if nums[i] == key: \\n                dict[nums[i+1]]=dict.get(nums[i+1],0)+1\\n                \\n        v=list(dict.values())\\n        k=list(dict.keys())\\n        return(k[v.index(max(v))])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dict={}\\n        \\n        for i in range(0,len(nums)-1):\\n            target=nums\\n            if nums[i] == key: \\n                dict[nums[i+1]]=dict.get(nums[i+1],0)+1\\n                \\n        v=list(dict.values())\\n        k=list(dict.keys())\\n        return(k[v.index(max(v))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091881,
                "title": "solution-viva-array-method-hope-this-helps-you",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolved it using array. Where I created a new int array(arr). Then we found the key using for loop iterated till nums.length-1 times. We then incremented the value of target index in arr. and later on ran a loop till arr.length and returned the ans variable at last! \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int arr[]=new int[1000];\\n        for (int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                arr[nums[i+1]-1]++;\\n            }\\n        }\\n        int max=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<1000;i++){\\n            if(max<arr[i]){\\n                max=arr[i];\\n                ans=i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int arr[]=new int[1000];\\n        for (int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                arr[nums[i+1]-1]++;\\n            }\\n        }\\n        int max=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<1000;i++){\\n            if(max<arr[i]){\\n                max=arr[i];\\n                ans=i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078974,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int, int> mp;\\n        int sz = nums.size();\\n        for(int i=1; i<sz; i++){\\n            if(nums[i-1] == key) mp[nums[i]]++;\\n        }\\n        int maxO = 0, ans;\\n        for(auto i : mp){\\n            if(i.second > maxO){\\n                maxO = i.second;\\n                ans = i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int, int> mp;\\n        int sz = nums.size();\\n        for(int i=1; i<sz; i++){\\n            if(nums[i-1] == key) mp[nums[i]]++;\\n        }\\n        int maxO = 0, ans;\\n        for(auto i : mp){\\n            if(i.second > maxO){\\n                maxO = i.second;\\n                ans = i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062592,
                "title": "simple-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> mp;\\n        int maximum=0,ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]==key){\\n                mp[nums[i]]++;\\n            }\\n        }\\n\\n        for(auto x:mp){\\n            if(x.second>maximum){\\n                maximum=x.second;\\n                ans=x.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> mp;\\n        int maximum=0,ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]==key){\\n                mp[nums[i]]++;\\n            }\\n        }\\n\\n        for(auto x:mp){\\n            if(x.second>maximum){\\n                maximum=x.second;\\n                ans=x.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053373,
                "title": "95-runtime-96-memory-using-dict-very-simple-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/92f79640-bd87-49ba-b5c5-f4de5ec66756_1694901926.8940284.png)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d, prev = {}, 0; d_get = d.get\\n\\n        for num in nums:\\n            if prev == key: d[num] = d_get(num,0) + 1\\n            prev = num\\n\\n        m: int = max(d.values())\\n\\n        for i, v in d.items():\\n            if v == m: return i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d, prev = {}, 0; d_get = d.get\\n\\n        for num in nums:\\n            if prev == key: d[num] = d_get(num,0) + 1\\n            prev = num\\n\\n        m: int = max(d.values())\\n\\n        for i, v in d.items():\\n            if v == m: return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044213,
                "title": "java-hashtable-optimial-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(n+map.size()) *--> n=Size of nums(array*)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(n) --> Due to Map Creation**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int target= Integer.MIN_VALUE;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==key){\\n                map.put(nums[i+1], map.getOrDefault(nums[i+1], 0)+1);\\n            }\\n        }\\n\\n        int res=0;\\n        for(int i : map.keySet()){\\n            if(map.get(i) > target){\\n                target = map.get(i);\\n                res=i;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int target= Integer.MIN_VALUE;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==key){\\n                map.put(nums[i+1], map.getOrDefault(nums[i+1], 0)+1);\\n            }\\n        }\\n\\n        int res=0;\\n        for(int i : map.keySet()){\\n            if(map.get(i) > target){\\n                target = map.get(i);\\n                res=i;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035696,
                "title": "most-frequent-number-js-o-n-short-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    res = {}, max = 0, ans = 0\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        target = nums[i+1]\\n        if (nums[i] == key) {\\n            res[target] = res[target] ? res[target] + 1 : 1\\n            if (res[target] > max) {\\n                max = res[target], ans = target\\n            }\\n        }\\n    }\\n\\n    return ans\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    res = {}, max = 0, ans = 0\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        target = nums[i+1]\\n        if (nums[i] == key) {\\n            res[target] = res[target] ? res[target] + 1 : 1\\n            if (res[target] > max) {\\n                max = res[target], ans = target\\n            }\\n        }\\n    }\\n\\n    return ans\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029875,
                "title": "using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        // Using Frequency Array\\n        // int freqArr[]=new int[1001];\\n        // for(int i=0;i<nums.length-1;i++){\\n        //     if(nums[i]==key){\\n        //         int targetElement=nums[i+1];\\n        //          freqArr[targetElement]++;\\n        //     }\\n        // }\\n\\n        // int ans=-1;\\n        // int eleOccurence=-1;\\n\\n        // for(int i=1;i<=1000;i++){\\n        //     if(eleOccurence<freqArr[i]){\\n        //         eleOccurence=freqArr[i];\\n        //         ans=i;\\n        //     }\\n        // }\\n        // return ans;\\n\\n        //using HashMap\\n\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                int targetEle=nums[i+1];\\n                if(hm.containsKey(targetEle)){\\n                    int val=hm.get(targetEle);\\n                    hm.put(targetEle,val+1);\\n                }else{\\n                    hm.put(targetEle,1);\\n                }\\n            }\\n        }\\n        int ans=-1;\\n        int eleOcc=-1;\\n        for(int val:hm.keySet()){\\n            if(hm.get(val)>eleOcc){\\n                eleOcc=hm.get(val);\\n                ans=val;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        // Using Frequency Array\\n        // int freqArr[]=new int[1001];\\n        // for(int i=0;i<nums.length-1;i++){\\n        //     if(nums[i]==key){\\n        //         int targetElement=nums[i+1];\\n        //          freqArr[targetElement]++;\\n        //     }\\n        // }\\n\\n        // int ans=-1;\\n        // int eleOccurence=-1;\\n\\n        // for(int i=1;i<=1000;i++){\\n        //     if(eleOccurence<freqArr[i]){\\n        //         eleOccurence=freqArr[i];\\n        //         ans=i;\\n        //     }\\n        // }\\n        // return ans;\\n\\n        //using HashMap\\n\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                int targetEle=nums[i+1];\\n                if(hm.containsKey(targetEle)){\\n                    int val=hm.get(targetEle);\\n                    hm.put(targetEle,val+1);\\n                }else{\\n                    hm.put(targetEle,1);\\n                }\\n            }\\n        }\\n        int ans=-1;\\n        int eleOcc=-1;\\n        for(int val:hm.keySet()){\\n            if(hm.get(val)>eleOcc){\\n                eleOcc=hm.get(val);\\n                ans=val;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029814,
                "title": "using-frequency-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        // Using Frequency Array\\n        int freqArr[]=new int[1001];\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                int targetElement=nums[i+1];\\n                 freqArr[targetElement]++;\\n            }\\n        }\\n\\n        int ans=-1;\\n        int eleOccurence=-1;\\n\\n        for(int i=1;i<=1000;i++){\\n            if(eleOccurence<freqArr[i]){\\n                eleOccurence=freqArr[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        // Using Frequency Array\\n        int freqArr[]=new int[1001];\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                int targetElement=nums[i+1];\\n                 freqArr[targetElement]++;\\n            }\\n        }\\n\\n        int ans=-1;\\n        int eleOccurence=-1;\\n\\n        for(int i=1;i<=1000;i++){\\n            if(eleOccurence<freqArr[i]){\\n                eleOccurence=freqArr[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012215,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer,Integer>map = new HashMap<>();\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                int target = nums[i+1];\\n                if(map.containsKey(target)){\\n                 map.put(target,map.get(target)+1);\\n                }\\n                else{\\n                    map.put(target,1);\\n                }\\n            }\\n        }\\n        int x = 0;\\n        int y = 0;\\n        for(int i:map.keySet()){\\n            if(map.get(i)>y){\\n                x = i;\\n                y = map.get(i);\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer,Integer>map = new HashMap<>();\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                int target = nums[i+1];\\n                if(map.containsKey(target)){\\n                 map.put(target,map.get(target)+1);\\n                }\\n                else{\\n                    map.put(target,1);\\n                }\\n            }\\n        }\\n        int x = 0;\\n        int y = 0;\\n        for(int i:map.keySet()){\\n            if(map.get(i)>y){\\n                x = i;\\n                y = map.get(i);\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980042,
                "title": "dictionary-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mostFrequent(self, nums, key):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        my_dict = {}\\n        dict_key = \"\"\\n        dict_value = 0\\n\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                if i != len(nums)-1: #If the last value in the array equal to key it will give out of range error.\\n                    dict_key = nums[i+1] \\n                    if dict_key not in my_dict:\\n                        my_dict[dict_key] = dict_value+1\\n                    else:\\n                        my_dict[dict_key] = my_dict[dict_key]+1\\n\\n        max_key = max(my_dict, key= my_dict.get)      \\n        return max_key\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostFrequent(self, nums, key):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        my_dict = {}\\n        dict_key = \"\"\\n        dict_value = 0\\n\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                if i != len(nums)-1: #If the last value in the array equal to key it will give out of range error.\\n                    dict_key = nums[i+1] \\n                    if dict_key not in my_dict:\\n                        my_dict[dict_key] = dict_value+1\\n                    else:\\n                        my_dict[dict_key] = my_dict[dict_key]+1\\n\\n        max_key = max(my_dict, key= my_dict.get)      \\n        return max_key\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971639,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        targets = {}\\n\\n        i = 0\\n\\n        while i < len(nums):\\n            if nums[i] == key:\\n                if i + 1 >= len(nums):\\n                    break\\n                else:\\n                    target = nums[i+1]\\n                    count = 0\\n                    r = i + 1\\n                    while r < len(nums) and nums[r] == target:\\n                        count += 1\\n                        r += 1\\n                    if target in targets:\\n                        targets[target] += count\\n                    else:\\n                        targets[target] = count\\n            i += 1\\n        targets = list(sorted(targets.items(), key = lambda x: -x[1]))\\n\\n        return targets[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        targets = {}\\n\\n        i = 0\\n\\n        while i < len(nums):\\n            if nums[i] == key:\\n                if i + 1 >= len(nums):\\n                    break\\n                else:\\n                    target = nums[i+1]\\n                    count = 0\\n                    r = i + 1\\n                    while r < len(nums) and nums[r] == target:\\n                        count += 1\\n                        r += 1\\n                    if target in targets:\\n                        targets[target] += count\\n                    else:\\n                        targets[target] = count\\n            i += 1\\n        targets = list(sorted(targets.items(), key = lambda x: -x[1]))\\n\\n        return targets[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968643,
                "title": "very-easy-using-unordered-map",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key && i+1<nums.size()){\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        int maxcount = INT_MIN;\\n        int ans = -1;\\n        for(auto i:m){\\n            if(i.second>maxcount){\\n                maxcount = i.second;\\n                ans = i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key && i+1<nums.size()){\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        int maxcount = INT_MIN;\\n        int ans = -1;\\n        for(auto i:m){\\n            if(i.second>maxcount){\\n                maxcount = i.second;\\n                ans = i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956901,
                "title": "runtime-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public static int mostFrequent(int[] nums, int key) {\\n        int target[]= new int [1000];\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] == key){\\n                 target[nums[i+1]-1]++;\\n            }                         \\n        }\\n        int max=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0; i<1000; i++){\\n            if(target[i] > max){\\n                max = target[i];\\n                ans = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int mostFrequent(int[] nums, int key) {\\n        int target[]= new int [1000];\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] == key){\\n                 target[nums[i+1]-1]++;\\n            }                         \\n        }\\n        int max=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0; i<1000; i++){\\n            if(target[i] > max){\\n                max = target[i];\\n                ans = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944309,
                "title": "c-code-easy-to-understand-unorderd-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n       unordered_map<int,int>mp;\\n       int n=nums.size();\\n       for(int i=0;i<n-1;i++)\\n       {\\n           if(nums[i]==key)\\n           {\\n               int target=nums[i+1];\\n               mp[target]++;\\n           }\\n       }\\n       int ans=0;\\n       int max1=0;\\n       for(auto x:mp)\\n       {\\n           if(x.second>max1){\\n           ans=x.first;\\n           max1=x.second;\\n           }\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n       unordered_map<int,int>mp;\\n       int n=nums.size();\\n       for(int i=0;i<n-1;i++)\\n       {\\n           if(nums[i]==key)\\n           {\\n               int target=nums[i+1];\\n               mp[target]++;\\n           }\\n       }\\n       int ans=0;\\n       int max1=0;\\n       for(auto x:mp)\\n       {\\n           if(x.second>max1){\\n           ans=x.first;\\n           max1=x.second;\\n           }\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931262,
                "title": "easiest-way-1ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 1ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:42.87%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n     int result[]=new int[1000];\\n\\n     for(int i=0;i<nums.length-1;i++){\\n         if(nums[i]==key){\\n             result[nums[i+1]-1]++;\\n         }\\n     }\\n    int max=Integer.MIN_VALUE;\\n    int ans=0;\\n    for(int i=0;i<1000;i++){\\n        if(result[i] >max){\\n            max=result[i];\\n            ans=i+1;\\n        }\\n        }\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n     int result[]=new int[1000];\\n\\n     for(int i=0;i<nums.length-1;i++){\\n         if(nums[i]==key){\\n             result[nums[i+1]-1]++;\\n         }\\n     }\\n    int max=Integer.MIN_VALUE;\\n    int ans=0;\\n    for(int i=0;i<1000;i++){\\n        if(result[i] >max){\\n            max=result[i];\\n            ans=i+1;\\n        }\\n        }\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925714,
                "title": "java-array-map-100-faster-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n        int n = nums.length;\\n        int[] targetFreqs = new int[1001];\\n\\n        for(int i = 0; i < n - 1; i++){\\n\\n            if(nums[i] == key){\\n                int target = nums[i + 1];\\n                targetFreqs[target]++;\\n            }\\n        }\\n\\n        int target = -1;\\n        int maxOccur = -1;\\n        for(int val = 1; val <= 1000; val++){\\n            if(targetFreqs[val] > maxOccur) {\\n                maxOccur = targetFreqs[val];\\n                target = val;\\n            }\\n        }\\n        return target;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n        int n = nums.length;\\n        int[] targetFreqs = new int[1001];\\n\\n        for(int i = 0; i < n - 1; i++){\\n\\n            if(nums[i] == key){\\n                int target = nums[i + 1];\\n                targetFreqs[target]++;\\n            }\\n        }\\n\\n        int target = -1;\\n        int maxOccur = -1;\\n        for(int val = 1; val <= 1000; val++){\\n            if(targetFreqs[val] > maxOccur) {\\n                maxOccur = targetFreqs[val];\\n                target = val;\\n            }\\n        }\\n        return target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917052,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        std::unordered_map<int, int> m;\\n        for (int i = 0; i < nums.size() - 1; i++)\\n        {\\n            if (nums[i] == key)\\n            {\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        std::pair<int, int> res = *(m.begin());\\n        for (auto p: m)\\n        {\\n            if (p.second > res.second)\\n            {\\n                res = p;\\n            }\\n        }\\n        return res.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        std::unordered_map<int, int> m;\\n        for (int i = 0; i < nums.size() - 1; i++)\\n        {\\n            if (nums[i] == key)\\n            {\\n                m[nums[i+1]]++;\\n            }\\n        }\\n        std::pair<int, int> res = *(m.begin());\\n        for (auto p: m)\\n        {\\n            if (p.second > res.second)\\n            {\\n                res = p;\\n            }\\n        }\\n        return res.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886922,
                "title": "java-easy-brute-force-approach-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsed single for loop\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n         int maxi=0;\\n        int a=0;\\n        int arr[]=new int[1001];\\n\\n       for(int i=0;i<nums.length-1;i++){\\n        if(nums[i]==key){\\n            int target=nums[i+1];   \\n            arr[target]++;     \\n        }\\n       }\\n\\n       for(int i=0;i<1001;i++){\\n         if(arr[i]>maxi){\\n            maxi=arr[i];\\n            a=i;\\n         }  \\n       }\\n       return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n         int maxi=0;\\n        int a=0;\\n        int arr[]=new int[1001];\\n\\n       for(int i=0;i<nums.length-1;i++){\\n        if(nums[i]==key){\\n            int target=nums[i+1];   \\n            arr[target]++;     \\n        }\\n       }\\n\\n       for(int i=0;i<1001;i++){\\n         if(arr[i]>maxi){\\n            maxi=arr[i];\\n            a=i;\\n         }  \\n       }\\n       return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873865,
                "title": "python-simple-dictionary-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        nums_dict = dict.fromkeys(nums, 0)\\n        for target in nums_dict:\\n            for i in range(0, len(nums) - 1):\\n                if (nums[i] == key and nums[i + 1] == target):\\n                    nums_dict[target] += 1\\n        return max(nums_dict, key = nums_dict.get)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        nums_dict = dict.fromkeys(nums, 0)\\n        for target in nums_dict:\\n            for i in range(0, len(nums) - 1):\\n                if (nums[i] == key and nums[i + 1] == target):\\n                    nums_dict[target] += 1\\n        return max(nums_dict, key = nums_dict.get)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869189,
                "title": "java-no-hashmap-beats-100-0-n-time-and-o-1-space-complexity",
                "content": "# Intuition\\nuse bucket of 0\\'s as int[] array and count occurance of each target value, storing the occurance in bucket[i]. return index for the max value in bucket. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int[] bucket = new int[1001];\\n\\n        int max = Integer.MIN_VALUE;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < nums.length-1; i++) {\\n            if (nums[i] == key) {\\n                bucket[nums[i+1]]++;\\n                max = Math.max(bucket[nums[i+1]], max);\\n                if (bucket[nums[i+1]] == max) {\\n                    ans = nums[i+1];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int[] bucket = new int[1001];\\n\\n        int max = Integer.MIN_VALUE;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < nums.length-1; i++) {\\n            if (nums[i] == key) {\\n                bucket[nums[i+1]]++;\\n                max = Math.max(bucket[nums[i+1]], max);\\n                if (bucket[nums[i+1]] == max) {\\n                    ans = nums[i+1];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865603,
                "title": "easy-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer,Integer> hm=new HashMap<>();\\n        int res=0;\\n        int max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                hm.put(nums[i+1],hm.getOrDefault(nums[i+1],0)+1);\\n            }\\n        }\\n\\n        for(int k : hm.keySet()){\\n            if(hm.get(k)>max){\\n                res=k;\\n                max=hm.get(k);\\n            }\\n        }\\nreturn res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer,Integer> hm=new HashMap<>();\\n        int res=0;\\n        int max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                hm.put(nums[i+1],hm.getOrDefault(nums[i+1],0)+1);\\n            }\\n        }\\n\\n        for(int k : hm.keySet()){\\n            if(hm.get(k)>max){\\n                res=k;\\n                max=hm.get(k);\\n            }\\n        }\\nreturn res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841779,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->First create a dictionary by iterating over the given list.If current value is equal to given key , then add next value in the dictionary with its value incremented by 1.\\n\\nThen iterate over the dictionary, find the key having max. value. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dic = {}\\n        for i,n in enumerate(nums[:-1]):\\n            if (n == key):\\n                dic[nums[i+1]] = dic.setdefault(nums[i+1], 0) + 1\\n        maxx, ans = 0, 0\\n        for k,v in dic.items():\\n            if(v > maxx):\\n                ans = k\\n                maxx = v\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dic = {}\\n        for i,n in enumerate(nums[:-1]):\\n            if (n == key):\\n                dic[nums[i+1]] = dic.setdefault(nums[i+1], 0) + 1\\n        maxx, ans = 0, 0\\n        for k,v in dic.items():\\n            if(v > maxx):\\n                ans = k\\n                maxx = v\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834922,
                "title": "with-explanation-comments-time-xx-ms-98-97-space-xx-mb-89-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        \\n        unordered_map<int, int> mp;\\n        int maxVal=INT_MIN, index=-1;\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n            if(nums[i]==key)\\n                mp[nums[i+1]]++;\\n              \\n        for(auto iter:mp)\\n            if(maxVal<iter.second){\\n                maxVal=iter.second;\\n                index=iter.first;\\n            }\\n        \\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        \\n        unordered_map<int, int> mp;\\n        int maxVal=INT_MIN, index=-1;\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n            if(nums[i]==key)\\n                mp[nums[i+1]]++;\\n              \\n        for(auto iter:mp)\\n            if(maxVal<iter.second){\\n                maxVal=iter.second;\\n                index=iter.first;\\n            }\\n        \\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826279,
                "title": "python-beats-100",
                "content": "![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/b20cc344-19eb-4842-9632-097223c491c3_1690506960.9616005.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d = {}\\n\\n        for i in range(0,len(nums)-1):\\n            if nums[i] == key:\\n                if nums[i+1] not in d:\\n                    d[nums[i+1]] = 1\\n                elif nums[i+1] in d:\\n                    d[nums[i+1]] = d[nums[i+1]] +1\\n        \\n        t = max(d.values())\\n\\n        for i in d:\\n            if d[i] == t:\\n                return i\\n\\n        # 20230728\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d = {}\\n\\n        for i in range(0,len(nums)-1):\\n            if nums[i] == key:\\n                if nums[i+1] not in d:\\n                    d[nums[i+1]] = 1\\n                elif nums[i+1] in d:\\n                    d[nums[i+1]] = d[nums[i+1]] +1\\n        \\n        t = max(d.values())\\n\\n        for i in d:\\n            if d[i] == t:\\n                return i\\n\\n        # 20230728\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813372,
                "title": "most-frequent-number-following-key-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n    HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n      for(int i=0;i<=nums.length-2;i++)\\n      {\\n          if(nums[i]==key)\\n          hm.put(nums[i+1],hm.getOrDefault(nums[i+1],0)+1);\\n      }\\n      int max = 1;\\n      for(Map.Entry<Integer,Integer> e:hm.entrySet())\\n      {\\n          max = Math.max(max,e.getValue());\\n      }\\n      int n=0;\\n      for(Map.Entry<Integer,Integer> e:hm.entrySet())\\n      {\\n          if(e.getValue()==max)\\n          n=e.getKey();\\n      }\\n      return n;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n    HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n      for(int i=0;i<=nums.length-2;i++)\\n      {\\n          if(nums[i]==key)\\n          hm.put(nums[i+1],hm.getOrDefault(nums[i+1],0)+1);\\n      }\\n      int max = 1;\\n      for(Map.Entry<Integer,Integer> e:hm.entrySet())\\n      {\\n          max = Math.max(max,e.getValue());\\n      }\\n      int n=0;\\n      for(Map.Entry<Integer,Integer> e:hm.entrySet())\\n      {\\n          if(e.getValue()==max)\\n          n=e.getKey();\\n      }\\n      return n;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812002,
                "title": "java-with-hashmap",
                "content": "\\nclass Solution {\\n public int mostFrequent(int[] nums, int key) {\\n    \\t\\n    \\tint target=-1;\\n    \\tHashMap<Integer,Integer> mp=new HashMap<>();\\n    \\t\\n    \\tfor(int i=0;i<nums.length-1;i++) {\\n    \\t\\tif(nums[i]==key) {\\n    \\t\\t\\tmp.put(nums[i+1], mp.getOrDefault(nums[i+1], 0)+1);\\n    \\t\\t   }\\n    \\t}\\n    \\t\\n    \\tint max=0;\\n    \\tfor(Map.Entry<Integer, Integer> entry: mp.entrySet()) {\\n    \\t\\tif(entry.getValue()>max) {\\n    \\t\\t\\tmax=entry.getValue();\\n    \\t\\t\\ttarget=entry.getKey();\\n    \\t\\t}\\n    \\t}\\n\\t\\treturn target;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n public int mostFrequent(int[] nums, int key) {\\n    \\t\\n    \\tint target=-1;\\n    \\tHashMap<Integer,Integer> mp=new HashMap<>();\\n    \\t\\n    \\tfor(int i=0;i<nums.length-1;i++) {\\n    \\t\\tif(nums[i]==key) {\\n    \\t\\t\\tmp.put(nums[i+1], mp.getOrDefault(nums[i+1], 0)+1);\\n    \\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 3811542,
                "title": "short-concise-pretty",
                "content": "# Intuition\\nNone\\n\\n# Approach\\nArray lenght is 1000 max. Have an array to store the count of each num, and keep track of the num that shows up the most as you go.\\n\\n# Complexity\\n- Time complexity:\\nO(1); it is a 1000 element\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1); it is a 1000 element\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        idx, cnt = 1, [0] * 1001\\n        for i in range(len(nums) - 1):\\n            if nums[i] == key:\\n                cnt[nums[i+1]] += 1\\n                if cnt[nums[i+1]] > cnt[idx]:\\n                    idx = nums[i+1]\\n\\n        return idx\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        idx, cnt = 1, [0] * 1001\\n        for i in range(len(nums) - 1):\\n            if nums[i] == key:\\n                cnt[nums[i+1]] += 1\\n                if cnt[nums[i+1]] > cnt[idx]:\\n                    idx = nums[i+1]\\n\\n        return idx\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811498,
                "title": "better-time-and-memory-than-100-of-swift-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func mostFrequent(_ nums: [Int], _ key: Int) -> Int {\\n        var frequencies = [Int]()\\n        var keyNumbers = [Int]()\\n        var lastKey = false\\n\\n        for num in nums{\\n            if(lastKey){\\n                if(keyNumbers.contains(num)){\\n                    if let index = keyNumbers.index(of: num){\\n                        frequencies[index] += 1\\n                    }\\n                } else{\\n                    keyNumbers.append(num)\\n                    frequencies.append(1)\\n                }\\n            }\\n\\n            if(num == key){\\n                lastKey = true\\n            } else{\\n                lastKey = false\\n            }\\n        }\\n\\n        var highestFreq = 0\\n        var output: Int = 0;\\n        for (i, num) in keyNumbers.enumerated(){\\n            var freq = frequencies[i]\\n            if(freq > highestFreq){\\n                output = num\\n                highestFreq = freq\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostFrequent(_ nums: [Int], _ key: Int) -> Int {\\n        var frequencies = [Int]()\\n        var keyNumbers = [Int]()\\n        var lastKey = false\\n\\n        for num in nums{\\n            if(lastKey){\\n                if(keyNumbers.contains(num)){\\n                    if let index = keyNumbers.index(of: num){\\n                        frequencies[index] += 1\\n                    }\\n                } else{\\n                    keyNumbers.append(num)\\n                    frequencies.append(1)\\n                }\\n            }\\n\\n            if(num == key){\\n                lastKey = true\\n            } else{\\n                lastKey = false\\n            }\\n        }\\n\\n        var highestFreq = 0\\n        var output: Int = 0;\\n        for (i, num) in keyNumbers.enumerated(){\\n            var freq = frequencies[i]\\n            if(freq > highestFreq){\\n                output = num\\n                highestFreq = freq\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810528,
                "title": "simple-and-easy-solution-rust-tm",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn most_frequent(nums: Vec<i32>, key: i32) -> i32 {\\n        let mut count_map: HashMap<i32, i32> = HashMap::new();\\n        for i in 1..nums.len() {\\n            if nums[i-1] == key {\\n                if let Some(count) = count_map.get_mut(&nums[i]) {\\n                    *count += 1;\\n                }else {\\n                    count_map.insert(nums[i], 1);\\n                } \\n            }\\n        }\\n    \\n        let mut target: i32 = -1;\\n        let mut max_count: i32 = 0;\\n        for (num, count) in count_map.iter() {\\n            if *count > max_count {\\n                max_count = *count;\\n                target = *num;\\n            }\\n        }\\n\\n        target\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn most_frequent(nums: Vec<i32>, key: i32) -> i32 {\\n        let mut count_map: HashMap<i32, i32> = HashMap::new();\\n        for i in 1..nums.len() {\\n            if nums[i-1] == key {\\n                if let Some(count) = count_map.get_mut(&nums[i]) {\\n                    *count += 1;\\n                }else {\\n                    count_map.insert(nums[i], 1);\\n                } \\n            }\\n        }\\n    \\n        let mut target: i32 = -1;\\n        let mut max_count: i32 = 0;\\n        for (num, count) in count_map.iter() {\\n            if *count > max_count {\\n                max_count = *count;\\n                target = *num;\\n            }\\n        }\\n\\n        target\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797446,
                "title": "easy-solution-using-vector-unordered-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> mp;\\n        int maxCount = 0, counter = 0;\\n        for(int i=0; i < nums.size()-1; i++){\\n            if(nums[i]==key){\\n                if(counter < ++mp[nums[i+1]]){\\n                    maxCount = nums[i+1];\\n                    counter = mp[nums[i+1]];\\n                } \\n            } \\n        }\\n        return maxCount;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> mp;\\n        pair<int, int> maxCount = {0,0};\\n        for(int i=0; i < nums.size(); i++){\\n            if(i <= nums.size()-2 and nums[i]==key){\\n                if(maxCount.second < ++mp[nums[i+1]]) maxCount = {nums[i+1], mp[nums[i+1]]};\\n            } \\n        }\\n        return maxCount.first;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        vector<int> targets;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i < nums.size(); i++){\\n            if(i<= nums.size()-2 and nums[i]==key) mp[nums[i+1]]++;\\n        }\\n        pair<int, int> maxCount = {0,0};\\n        for(int i=0; i < nums.size(); i++){\\n            if(i <= nums.size()-2 and nums[i]==key){\\n                if(maxCount.second < mp[nums[i+1]]){\\n                    maxCount = {nums[i+1], mp[nums[i+1]]};\\n                }\\n            }\\n        }\\n        return maxCount.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> mp;\\n        int maxCount = 0, counter = 0;\\n        for(int i=0; i < nums.size()-1; i++){\\n            if(nums[i]==key){\\n                if(counter < ++mp[nums[i+1]]){\\n                    maxCount = nums[i+1];\\n                    counter = mp[nums[i+1]];\\n                } \\n            } \\n        }\\n        return maxCount;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> mp;\\n        pair<int, int> maxCount = {0,0};\\n        for(int i=0; i < nums.size(); i++){\\n            if(i <= nums.size()-2 and nums[i]==key){\\n                if(maxCount.second < ++mp[nums[i+1]]) maxCount = {nums[i+1], mp[nums[i+1]]};\\n            } \\n        }\\n        return maxCount.first;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        vector<int> targets;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i < nums.size(); i++){\\n            if(i<= nums.size()-2 and nums[i]==key) mp[nums[i+1]]++;\\n        }\\n        pair<int, int> maxCount = {0,0};\\n        for(int i=0; i < nums.size(); i++){\\n            if(i <= nums.size()-2 and nums[i]==key){\\n                if(maxCount.second < mp[nums[i+1]]){\\n                    maxCount = {nums[i+1], mp[nums[i+1]]};\\n                }\\n            }\\n        }\\n        return maxCount.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771964,
                "title": "easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>&n , int k){\\n        unordered_map<int,int>mp;\\n        for(int i=0; i<n.size()-1; i++){\\n            if(n[i]==k){\\n                mp[n[i+1]]++;\\n            }\\n        }\\n        int mx=INT_MIN , val;\\n        for(auto i:mp){\\n            if(i.second>mx){\\n                mx=i.second;\\n                val=i.first;\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>&n , int k){\\n        unordered_map<int,int>mp;\\n        for(int i=0; i<n.size()-1; i++){\\n            if(n[i]==k){\\n                mp[n[i+1]]++;\\n            }\\n        }\\n        int mx=INT_MIN , val;\\n        for(auto i:mp){\\n            if(i.second>mx){\\n                mx=i.second;\\n                val=i.first;\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768841,
                "title": "simple-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func mostFrequent(_ nums: [Int], _ key: Int) -> Int {\\n        var map = [Int:Int]()\\n        for i in 0..<nums.count-1{\\n            var i = i\\n            if nums[i] == key {\\n                map[nums[i+1],default:0] += 1\\n            }\\n        }\\n        for (k,_) in map{\\n            if map[k] == map.values.max(){\\n                return k\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostFrequent(_ nums: [Int], _ key: Int) -> Int {\\n        var map = [Int:Int]()\\n        for i in 0..<nums.count-1{\\n            var i = i\\n            if nums[i] == key {\\n                map[nums[i+1],default:0] += 1\\n            }\\n        }\\n        for (k,_) in map{\\n            if map[k] == map.values.max(){\\n                return k\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767695,
                "title": "c-simple-approach",
                "content": "# Approach\\nUsing map to save the target frequency and using for loop to find out the highest frequent number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> table;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key)\\n                table[nums[i+1]]++;\\n        }\\n        int max=0;\\n        int maxIndex=0;\\n        for(auto m:table){\\n            if(m.second > max){\\n                max = m.second;\\n                maxIndex=m.first;\\n            }\\n        }\\n        return maxIndex;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> table;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key)\\n                table[nums[i+1]]++;\\n        }\\n        int max=0;\\n        int maxIndex=0;\\n        for(auto m:table){\\n            if(m.second > max){\\n                max = m.second;\\n                maxIndex=m.first;\\n            }\\n        }\\n        return maxIndex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766742,
                "title": "o-n-solution-in-cpp-runtime-10-ms-beats-70-47-memory-12-4-mb-beats-97-41",
                "content": "\\n# Complexity\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(n)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n       int ans = INT_MIN, cnt  = 0;\\n        int arr[1001] = {};\\n        for(int i = 0; i < nums.size() - 1; i++){\\n            if(nums[i] == key){\\n                if(cnt < ++arr[nums[i+1]]){\\n                    cnt = arr[nums[i+1]];\\n                    ans = nums[i+1];\\n                }\\n            }\\n        }\\n\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(n)```\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n       int ans = INT_MIN, cnt  = 0;\\n        int arr[1001] = {};\\n        for(int i = 0; i < nums.size() - 1; i++){\\n            if(nums[i] == key){\\n                if(cnt < ++arr[nums[i+1]]){\\n                    cnt = arr[nums[i+1]];\\n                    ans = nums[i+1];\\n                }\\n            }\\n        }\\n\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762292,
                "title": "use-python-collections-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        counter = Counter()\\n        for i in range(len(nums) - 1):\\n            if nums[i] == key:\\n                counter[nums[i + 1]] += 1\\n        return counter.most_common(1)[0][0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        counter = Counter()\\n        for i in range(len(nums) - 1):\\n            if nums[i] == key:\\n                counter[nums[i + 1]] += 1\\n        return counter.most_common(1)[0][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759755,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int[] arr = new int[1001];\\n        int maxArr = Integer.MIN_VALUE;\\n        int output = 0;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == key) {\\n                arr[nums[i + 1]]++;\\n                maxArr = Math.max(maxArr, nums[i + 1]);\\n            }\\n            if (i == nums.length - 2) {\\n                int max = Integer.MIN_VALUE;\\n                for (int j = 0; j < maxArr + 1; j++) {\\n                    if (arr[j] > max) {\\n                        output = j;\\n                        max = arr[j];\\n                    }\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int[] arr = new int[1001];\\n        int maxArr = Integer.MIN_VALUE;\\n        int output = 0;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == key) {\\n                arr[nums[i + 1]]++;\\n                maxArr = Math.max(maxArr, nums[i + 1]);\\n            }\\n            if (i == nums.length - 2) {\\n                int max = Integer.MIN_VALUE;\\n                for (int j = 0; j < maxArr + 1; j++) {\\n                    if (arr[j] > max) {\\n                        output = j;\\n                        max = arr[j];\\n                    }\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750456,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let obj = {};\\n\\n    for(let i=0;i<nums.length-1;i++){\\n        if (nums[i]==key){\\n            let next = nums[i+1];\\n            if(obj[next])obj[next]+=1;\\n            else obj[next] = 1;\\n        }\\n    }\\n\\n    let lst = Object.entries(obj).sort((a,b)=>b[1]-a[1]);\\n\\n    return Number(lst[0][0]);\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let obj = {};\\n\\n    for(let i=0;i<nums.length-1;i++){\\n        if (nums[i]==key){\\n            let next = nums[i+1];\\n            if(obj[next])obj[next]+=1;\\n            else obj[next] = 1;\\n        }\\n    }\\n\\n    let lst = Object.entries(obj).sort((a,b)=>b[1]-a[1]);\\n\\n    return Number(lst[0][0]);\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748514,
                "title": "python-very-easy-solution-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dic={}\\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] in dic:\\n                    dic[nums[i]]+=1\\n                else:\\n                    dic[nums[i]]=1\\n        maxC=0\\n        for i in dic:\\n            if dic[i]>maxC:\\n                maxC=dic[i]\\n                res=i\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dic={}\\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] in dic:\\n                    dic[nums[i]]+=1\\n                else:\\n                    dic[nums[i]]=1\\n        maxC=0\\n        for i in dic:\\n            if dic[i]>maxC:\\n                maxC=dic[i]\\n                res=i\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728039,
                "title": "c-dictionary-solution",
                "content": "# Approach\\nUse a hashtable to store target and count values\\n\\n# Complexity\\n- Time complexity:\\nO(n) traverse array one time and also hashtable to find max count\\n\\n- Space complexity:\\nO(n) need extra memory using HashTable\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MostFrequent(int[] nums, int key) {\\n\\n        Dictionary<int, int> map = new Dictionary<int, int>();\\n        int i = 0;\\n\\n        while(i < nums.Length)\\n        {\\n            if(nums[i] == key && i + 1 < nums.Length)\\n            {\\n                if(map.ContainsKey(nums[i + 1]))\\n                {\\n                    map[nums[i + 1]]++;\\n                }\\n                else\\n                {\\n                    map.Add(nums[i + 1], 1);\\n                }\\n            }\\n\\n            i++;\\n        }\\n\\n        int max = 0;\\n        int result = 0;\\n\\n        foreach(var item in map)\\n        {\\n            if(item.Value > max)\\n            {\\n                max = item.Value;\\n                result = item.Key;\\n            }\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int MostFrequent(int[] nums, int key) {\\n\\n        Dictionary<int, int> map = new Dictionary<int, int>();\\n        int i = 0;\\n\\n        while(i < nums.Length)\\n        {\\n            if(nums[i] == key && i + 1 < nums.Length)\\n            {\\n                if(map.ContainsKey(nums[i + 1]))\\n                {\\n                    map[nums[i + 1]]++;\\n                }\\n                else\\n                {\\n                    map.Add(nums[i + 1], 1);\\n                }\\n            }\\n\\n            i++;\\n        }\\n\\n        int max = 0;\\n        int result = 0;\\n\\n        foreach(var item in map)\\n        {\\n            if(item.Value > max)\\n            {\\n                max = item.Value;\\n                result = item.Key;\\n            }\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727615,
                "title": "hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();\\n\\n        for (int i = 0; i < nums.length-1; i++) {\\n            if (nums[i]==key){\\n                if (hashMap.containsKey(nums[i+1])) {\\n                    int count = hashMap.get(nums[i+1]);\\n                    hashMap.put(nums[i+1], count + 1);\\n                } else {\\n                    hashMap.put(nums[i+1], 1);\\n                }\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        int keyWithMaxValue = 0;\\n\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            int value = entry.getValue();\\n\\n            if (value > max) {\\n                max = value;\\n                keyWithMaxValue = entry.getKey();\\n            }\\n        }\\n\\n        return keyWithMaxValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();\\n\\n        for (int i = 0; i < nums.length-1; i++) {\\n            if (nums[i]==key){\\n                if (hashMap.containsKey(nums[i+1])) {\\n                    int count = hashMap.get(nums[i+1]);\\n                    hashMap.put(nums[i+1], count + 1);\\n                } else {\\n                    hashMap.put(nums[i+1], 1);\\n                }\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        int keyWithMaxValue = 0;\\n\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            int value = entry.getValue();\\n\\n            if (value > max) {\\n                max = value;\\n                keyWithMaxValue = entry.getKey();\\n            }\\n        }\\n\\n        return keyWithMaxValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691822,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let map = {}\\n    let maxVal;\\n    let maxCount = 0;\\n    for (let i = 0; i < nums.length - 1; i++) {    \\n        if (nums[i] == key) {\\n            let target = nums[i + 1];\\n            let count = map[target] + 1 || 1;\\n            map[target] = count;\\n            if (count > maxCount) {\\n                maxVal = target;\\n                maxCount = count;\\n            }\\n        }\\n    }\\n    return maxVal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let map = {}\\n    let maxVal;\\n    let maxCount = 0;\\n    for (let i = 0; i < nums.length - 1; i++) {    \\n        if (nums[i] == key) {\\n            let target = nums[i + 1];\\n            let count = map[target] + 1 || 1;\\n            map[target] = count;\\n            if (count > maxCount) {\\n                maxVal = target;\\n                maxCount = count;\\n            }\\n        }\\n    }\\n    return maxVal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3686943,
                "title": "javascript-2190-most-frequent-number-following-key-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar mostFrequent = function (a, key) {\\n  let p;\\n  let o = {}\\n  for (let e of a) {\\n    if (p === key) {\\n      o[e] = o[e] || 0\\n      o[e]++\\n    }\\n    p = e\\n  }\\n  let b = [...Object.entries(o)]\\n  b.sort((a, b) => b[1] - a[1])\\n  return b[0][0]\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostFrequent = function (a, key) {\\n  let p;\\n  let o = {}\\n  for (let e of a) {\\n    if (p === key) {\\n      o[e] = o[e] || 0\\n      o[e]++\\n    }\\n    p = e\\n  }\\n  let b = [...Object.entries(o)]\\n  b.sort((a, b) => b[1] - a[1])\\n  return b[0][0]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3675318,
                "title": "dart-solution-with-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstructions could be easier but I think this is a decent way to search for this most frequent number. After my complaints about de problem description I wanted to create a solution that would work similar as if I was counting on my mind the number of times the condition if matched.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy solution creates a map which stores all the numbers on the original list, each number being a key and their values are the number of times the number matches the condition. Then i just return the numer (key from map) that has the biggest value.\\n\\n# Complexity\\n- Time complexity: 0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int mostFrequent(List<int> nums, int key) {\\n    int mostRepeatedTarget = 0;\\n    int biggestFreq = 0;\\n    Map<int, int> numbersOnList = {};\\n\\n    for(int x = 0; x < nums.length; x++) {\\n      if(x < nums.length - 1) {\\n        if(nums[x] == key) {\\n          if(numbersOnList.containsKey(nums[x+1])) {\\n            numbersOnList[nums[x+1]] = numbersOnList[nums[x+1]]! + 1;\\n          } else {\\n            numbersOnList[nums[x+1]] = 1;\\n          }\\n          if(nums[x+1] != nums[x]) {\\n            x++;\\n          }\\n        }\\n      }\\n    }\\n\\n    numbersOnList.forEach((number, value) {\\n      if(value > biggestFreq) {\\n        biggestFreq = value;\\n        mostRepeatedTarget = number;\\n      }\\n    });\\n\\n    return mostRepeatedTarget;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n  int mostFrequent(List<int> nums, int key) {\\n    int mostRepeatedTarget = 0;\\n    int biggestFreq = 0;\\n    Map<int, int> numbersOnList = {};\\n\\n    for(int x = 0; x < nums.length; x++) {\\n      if(x < nums.length - 1) {\\n        if(nums[x] == key) {\\n          if(numbersOnList.containsKey(nums[x+1])) {\\n            numbersOnList[nums[x+1]] = numbersOnList[nums[x+1]]! + 1;\\n          } else {\\n            numbersOnList[nums[x+1]] = 1;\\n          }\\n          if(nums[x+1] != nums[x]) {\\n            x++;\\n          }\\n        }\\n      }\\n    }\\n\\n    numbersOnList.forEach((number, value) {\\n      if(value > biggestFreq) {\\n        biggestFreq = value;\\n        mostRepeatedTarget = number;\\n      }\\n    });\\n\\n    return mostRepeatedTarget;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668635,
                "title": "cpp-solution-using-hash-table",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approachhas -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int i,max=0,ans;\\n        unordered_map<int,int>mp;\\n        for(int i=0; i<nums.size(); i++){\\n           if(nums[i]==key && i<nums.size()-1){\\n               mp[nums[i+1]]++;\\n           }\\n        }\\n         max=INT_MIN;\\n        for(auto i:mp){\\n            if(i.second>max){\\n                max=i.second;\\n                ans=i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int i,max=0,ans;\\n        unordered_map<int,int>mp;\\n        for(int i=0; i<nums.size(); i++){\\n           if(nums[i]==key && i<nums.size()-1){\\n               mp[nums[i+1]]++;\\n           }\\n        }\\n         max=INT_MIN;\\n        for(auto i:mp){\\n            if(i.second>max){\\n                max=i.second;\\n                ans=i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668633,
                "title": "cpp-solution-using-hash-table",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approachhas -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int i,max=0,ans;\\n        unordered_map<int,int>mp;\\n        for(int i=0; i<nums.size(); i++){\\n           if(nums[i]==key && i<nums.size()-1){\\n               mp[nums[i+1]]++;\\n           }\\n        }\\n         max=INT_MIN;\\n        for(auto i:mp){\\n            if(i.second>max){\\n                max=i.second;\\n                ans=i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int i,max=0,ans;\\n        unordered_map<int,int>mp;\\n        for(int i=0; i<nums.size(); i++){\\n           if(nums[i]==key && i<nums.size()-1){\\n               mp[nums[i+1]]++;\\n           }\\n        }\\n         max=INT_MIN;\\n        for(auto i:mp){\\n            if(i.second>max){\\n                max=i.second;\\n                ans=i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623789,
                "title": "beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let map = new Map();\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === key) {\\n            if (!map.has(nums[i + 1])) {\\n                map.set(nums[i + 1], 1)\\n            } else {\\n                map.set(nums[i + 1], map.get(nums[i+1]) + 1)\\n            }\\n        }\\n    }\\n    let sortMap = new Map([...map.entries()].sort((a,b) => b[1] - a[1]))\\n    let newArr = Array.from(sortMap)\\n\\n    return newArr[0][0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let map = new Map();\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === key) {\\n            if (!map.has(nums[i + 1])) {\\n                map.set(nums[i + 1], 1)\\n            } else {\\n                map.set(nums[i + 1], map.get(nums[i+1]) + 1)\\n            }\\n        }\\n    }\\n    let sortMap = new Map([...map.entries()].sort((a,b) => b[1] - a[1]))\\n    let newArr = Array.from(sortMap)\\n\\n    return newArr[0][0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609431,
                "title": "easy-solution-unordered-map",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)\\n             mp[nums[i+1]]++;\\n        }\\n        int max=INT_MIN,res;\\n        for(auto i:mp)\\n         {\\n             if(i.second>max)\\n             {\\n              max=i.second;\\n              res=i.first;\\n             }\\n         }\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)\\n             mp[nums[i+1]]++;\\n        }\\n        int max=INT_MIN,res;\\n        for(auto i:mp)\\n         {\\n             if(i.second>max)\\n             {\\n              max=i.second;\\n              res=i.first;\\n             }\\n         }\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578716,
                "title": "finding-the-most-frequent",
                "content": "# Intuition\\nDescription of that problenm is awful. It took me a long time to figure out what they wanted from me.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MostFrequent(int[] nums, int key)\\n{\\n     List<int> res = new List<int>();\\n    for (int i = 0; i != nums.Length-1; i++)\\n    {\\n        if (nums[i] == key)\\n        {\\n            res.Add(nums[i + 1]);\\n        }\\n    }\\n    List<int> d = res.Where(x => res.Count(y => y == x) > 1).Distinct().ToList();\\n    return d.Count == 0 ? res[0] : d[0];\\n\\n}\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Counting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MostFrequent(int[] nums, int key)\\n{\\n     List<int> res = new List<int>();\\n    for (int i = 0; i != nums.Length-1; i++)\\n    {\\n        if (nums[i] == key)\\n        {\\n            res.Add(nums[i + 1]);\\n        }\\n    }\\n    List<int> d = res.Where(x => res.Count(y => y == x) > 1).Distinct().ToList();\\n    return d.Count == 0 ? res[0] : d[0];\\n\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565396,
                "title": "easy-using-unordered-map-with-less-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> m;\\n        int max=INT_MIN;\\n        int val=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]==key)\\n            {\\n                m[nums[i]]++;\\n                if(max<m[nums[i]])\\n                {\\n                    max=m[nums[i]];\\n                    val=nums[i];\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> m;\\n        int max=INT_MIN;\\n        int val=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]==key)\\n            {\\n                m[nums[i]]++;\\n                if(max<m[nums[i]])\\n                {\\n                    max=m[nums[i]];\\n                    val=nums[i];\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555098,
                "title": "js-hashmap-solution",
                "content": "\\n```\\n\\nconst mostFrequent = function(nums, key) {\\n    const map = {}\\n\\n    for(let i = 0; i < nums.length; i++) {\\n       if(nums[i] === key) map[nums[i + 1]] = (map[nums[i + 1]] || 0) + 1\\n    }\\n    \\n    const max = Math.max(...Object.values(map))\\n    \\n    return Object.entries(map).find(el => el[1] === max)[0]\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst mostFrequent = function(nums, key) {\\n    const map = {}\\n\\n    for(let i = 0; i < nums.length; i++) {\\n       if(nums[i] === key) map[nums[i + 1]] = (map[nums[i + 1]] || 0) + 1\\n    }\\n    \\n    const max = Math.max(...Object.values(map))\\n    \\n    return Object.entries(map).find(el => el[1] === max)[0]\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3547595,
                "title": "simple-python-code-using-dictionary",
                "content": "# Intuition\\n<!--  -->\\n\\n# Approach \\n<!-- Using Dictionary -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        mp ={}\\n        for i in range(len(nums)-1):\\n            if(nums[i] == key):\\n                if nums[i+1] not in mp:\\n                    mp[nums[i+1]] =1\\n                else:\\n                    mp[nums[i+1]] +=1\\n        key_list = list(mp.keys())\\n        val_list = list(mp.values())\\n        position = val_list.index(max(mp.values()))\\n        return key_list[position]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        mp ={}\\n        for i in range(len(nums)-1):\\n            if(nums[i] == key):\\n                if nums[i+1] not in mp:\\n                    mp[nums[i+1]] =1\\n                else:\\n                    mp[nums[i+1]] +=1\\n        key_list = list(mp.keys())\\n        val_list = list(mp.values())\\n        position = val_list.index(max(mp.values()))\\n        return key_list[position]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526899,
                "title": "java-hashmap-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt`s comfortable to use hashmap container to keep integers and numbers of their appearance.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate over the array and search for targets. If we found a target we write down ot to the hashmap. If hashmap already keep this integer, we just iterate it`s value in hashmap. The integer with max value in hashmap will be the answer!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n\\n        int target=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==key){\\n                target=nums[i+1];\\n                if(map.containsKey(target))map.put(target,map.get(target)+1);\\n                else map.put(target,1);\\n            }\\n\\n\\n        }\\n\\n        return map.entrySet().stream().max((el1,el2)->el1.getValue() > el2.getValue()?1:-1).get().getKey();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n\\n        int target=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==key){\\n                target=nums[i+1];\\n                if(map.containsKey(target))map.put(target,map.get(target)+1);\\n                else map.put(target,1);\\n            }\\n\\n\\n        }\\n\\n        return map.entrySet().stream().max((el1,el2)->el1.getValue() > el2.getValue()?1:-1).get().getKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518465,
                "title": "easy-with-dict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind target and get target reputation in a array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlinear problem solving\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mostFrequent(self, nums, key):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        d=dict()\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                target=nums[i+1]\\n                if target not in d:\\n                    d[target]=1\\n                else:\\n                    d[target]+=1\\n        return max(d, key= lambda x: d[x])\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostFrequent(self, nums, key):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        d=dict()\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                target=nums[i+1]\\n                if target not in d:\\n                    d[target]=1\\n                else:\\n                    d[target]+=1\\n        return max(d, key= lambda x: d[x])\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493311,
                "title": "python-simulating-conditions-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n), where n is the length of the nums list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m), where m is the number of unique elements that follow the key in the list. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        targets = {}\\n\\n        for i in range(1,len(nums)):\\n            if nums[i-1] == key:\\n                target = nums[i]\\n                if target not in targets:\\n                    targets[target] = 1\\n                else:\\n                    targets[target] +=1\\n        return max(targets, key=targets.get)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        targets = {}\\n\\n        for i in range(1,len(nums)):\\n            if nums[i-1] == key:\\n                target = nums[i]\\n                if target not in targets:\\n                    targets[target] = 1\\n                else:\\n                    targets[target] +=1\\n        return max(targets, key=targets.get)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491085,
                "title": "simple-solution-c-unordered-map",
                "content": "# Intuition\\nNot gonna lie, I had a hard time understanding the subject, maybe because it\\'s late in the evening.\\nAnyways, they ask you to count everytime a number stands in front of **key**, the number which occurred the most times immediately after **key** is the answer.\\n\\n# Approach\\nI started by doing a map storing nums[i] and storing and/or incrementing its count (I.e. how many times it occurred after **key**).\\nAs I\\'m storing/incrementing it, I\\'m also checking if its count is already bigger than the last biggest count, if so i redeclare my return int *ret*. This way you won\\'t need to iterate over *map*.\\n\\n# Complexity\\n- Time complexity:\\nO(n).\\n\\n# Code\\n```\\n#include <map>\\n#include <iostream>\\n\\nclass Solution {\\npublic:\\n\\n\\n    int mostFrequent(vector<int>& nums, int key) {\\n        std::unordered_map<int,int> map;\\n        int ret, count = 0;\\n        for(int i = 0; i < nums.size() - 1; i++)\\n        {\\n            if (nums[i] == key)\\n            {\\n                map[nums[i + 1]]++;\\n                if (map[nums[i + 1]] > count)\\n                {\\n                    count = map[nums[i + 1]];\\n                    ret = nums[i + 1];\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <map>\\n#include <iostream>\\n\\nclass Solution {\\npublic:\\n\\n\\n    int mostFrequent(vector<int>& nums, int key) {\\n        std::unordered_map<int,int> map;\\n        int ret, count = 0;\\n        for(int i = 0; i < nums.size() - 1; i++)\\n        {\\n            if (nums[i] == key)\\n            {\\n                map[nums[i + 1]]++;\\n                if (map[nums[i + 1]] > count)\\n                {\\n                    count = map[nums[i + 1]];\\n                    ret = nums[i + 1];\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3490425,
                "title": "easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        ans=[]\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                ans.append(nums[i+1])\\n        c=Counter(ans)\\n        return c.most_common(1)[0][0]\\n        \\n        \\n               \\n       \\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        ans=[]\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                ans.append(nums[i+1])\\n        c=Counter(ans)\\n        return c.most_common(1)[0][0]\\n        \\n        \\n               \\n       \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485844,
                "title": "easy-and-understandable-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i] == key){\\n                map.put(nums[i+1], map.getOrDefault(nums[i+1], 0)+1);\\n            }\\n        }\\n        int max =0, res=0;\\n        for(int k:map.keySet()){\\n            if(map.get(k) > max){\\n                max = map.get(k);\\n                res = k;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i] == key){\\n                map.put(nums[i+1], map.getOrDefault(nums[i+1], 0)+1);\\n            }\\n        }\\n        int max =0, res=0;\\n        for(int k:map.keySet()){\\n            if(map.get(k) > max){\\n                max = map.get(k);\\n                res = k;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477871,
                "title": "simple-easy-approach-c-using-map-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        \\n        int n = nums.size();\\n        int count = 0;\\n        map<int, int> m;\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] == key){\\n                int target = nums[i+1];\\n                m[target]++;\\n            }\\n        }\\n        int maxi = INT_MIN;\\n        int ans = -1;\\n        for(auto it: m){\\n            if(maxi < it.second){\\n                ans = it.first;\\n                maxi = it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        \\n        int n = nums.size();\\n        int count = 0;\\n        map<int, int> m;\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] == key){\\n                int target = nums[i+1];\\n                m[target]++;\\n            }\\n        }\\n        int maxi = INT_MIN;\\n        int ans = -1;\\n        for(auto it: m){\\n            if(maxi < it.second){\\n                ans = it.first;\\n                maxi = it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475529,
                "title": "beats-100-easy-to-understand-hashmap-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int[] arr=new int[1001];\\n        int i=0;\\n        int max=0;\\n        int result=0;\\n\\n    \\n        for(i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                arr[nums[i+1]]++;\\n            }\\n        }\\n\\n\\n        for(i=0;i<1001;i++){\\n            if(max<arr[i]){\\n                max=arr[i];\\n                result=i;\\n            }\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int[] arr=new int[1001];\\n        int i=0;\\n        int max=0;\\n        int result=0;\\n\\n    \\n        for(i=0;i<nums.length-1;i++){\\n            if(nums[i]==key){\\n                arr[nums[i+1]]++;\\n            }\\n        }\\n\\n\\n        for(i=0;i<1001;i++){\\n            if(max<arr[i]){\\n                max=arr[i];\\n                result=i;\\n            }\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472597,
                "title": "simple-solution-on-javascript",
                "content": "# Intuition\\nThis problem can be solved using frequency counter pattern\\n\\n# Approach\\n- I will be creating an object to map i.e. counter{}\\n- I will create the mostFrequent var to store result\\n- I will create temp var to store temp var for comparison\\n- Loop through the elements and store them in counter\\n- Compare the frequency of the repeated numbers\\n\\n# Complexity\\n- Time complexity:\\n  0(n)\\n\\n- Space complexity:\\n0(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n        let counter = {};\\n    let mostFrequent;\\n  let temp = 0;\\n    for(let index in nums){\\n        if(nums[index -1] && nums[index-1] == key){\\n            counter[nums[index]] = (counter[nums[index]] || 0) + 1;\\n        }\\n    }\\n   for(let i in counter){\\n      if(temp < counter[i]){\\n        temp = counter[i];\\n        mostFrequent = i;\\n      }\\n  }\\n  return mostFrequent\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n        let counter = {};\\n    let mostFrequent;\\n  let temp = 0;\\n    for(let index in nums){\\n        if(nums[index -1] && nums[index-1] == key){\\n            counter[nums[index]] = (counter[nums[index]] || 0) + 1;\\n        }\\n    }\\n   for(let i in counter){\\n      if(temp < counter[i]){\\n        temp = counter[i];\\n        mostFrequent = i;\\n      }\\n  }\\n  return mostFrequent\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471902,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> counter;\\n        for (auto i = 1; i < nums.size(); ++i) {\\n            if (nums[i - 1] == key) {\\n                ++counter[nums[i]];\\n            }\\n        } \\n        auto result = 0, ma = 0;\\n        for (const auto& pair : counter) {\\n            if (ma < pair.second) {\\n                ma = pair.second;\\n                result = pair.first;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int, int> counter;\\n        for (auto i = 1; i < nums.size(); ++i) {\\n            if (nums[i - 1] == key) {\\n                ++counter[nums[i]];\\n            }\\n        } \\n        auto result = 0, ma = 0;\\n        for (const auto& pair : counter) {\\n            if (ma < pair.second) {\\n                ma = pair.second;\\n                result = pair.first;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471344,
                "title": "most-frequent-number-following-key-in-an-array",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, a: List[int], key: int) -> int:\\n        dic = {}\\n        for i in range(1,len(a)):\\n            if a[i-1]==key:\\n                if a[i] not in dic:\\n                    dic[a[i]]=1\\n                else:\\n                    dic[a[i]] += 1\\n        a = sorted(dic.values())\\n        for i in dic:\\n            if dic[i]==a[-1]:\\n                return i\\n        \\n            \\n        \\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, a: List[int], key: int) -> int:\\n        dic = {}\\n        for i in range(1,len(a)):\\n            if a[i-1]==key:\\n                if a[i] not in dic:\\n                    dic[a[i]]=1\\n                else:\\n                    dic[a[i]] += 1\\n        a = sorted(dic.values())\\n        for i in dic:\\n            if dic[i]==a[-1]:\\n                return i\\n        \\n            \\n        \\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470395,
                "title": "most-frequent-number-following-key-in-an-array-easiest-with-c-in-0ms-runtime",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<nums.size()-1; i++)\\n            if(nums[i] == key)\\n                mp[nums[i+1]]++;\\n        int ans=0, ct=0;\\n        for(auto [k,v]:mp)\\n            if(v > ct)\\n                ans=k, ct=v;\\n        return ans;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<nums.size()-1; i++)\\n            if(nums[i] == key)\\n                mp[nums[i+1]]++;\\n        int ans=0, ct=0;\\n        for(auto [k,v]:mp)\\n            if(v > ct)\\n                ans=k, ct=v;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3456916,
                "title": "worst-approach-ever-must-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] a, int key) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<a.length-1;i++){\\n            if(a[i]==key){\\n                if(map.containsKey(a[i+1])){\\n                    map.put(a[i+1],map.get(a[i+1])+1);\\n                }\\n                else{\\n                    map.put(a[i+1],1);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int com=0;\\n        for(int i : map.keySet()){\\n            int chk=map.get(i);\\n            if(chk>com){\\n                ans=i;\\n                com=chk;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] a, int key) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<a.length-1;i++){\\n            if(a[i]==key){\\n                if(map.containsKey(a[i+1])){\\n                    map.put(a[i+1],map.get(a[i+1])+1);\\n                }\\n                else{\\n                    map.put(a[i+1],1);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int com=0;\\n        for(int i : map.keySet()){\\n            int chk=map.get(i);\\n            if(chk>com){\\n                ans=i;\\n                com=chk;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438376,
                "title": "easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        x=[]\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                x.append(nums[i+1])\\n        x=Counter(x)\\n        y=list(x.values())\\n        z=list(x.keys())\\n        a=y.index(max(y))\\n        return z[a]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        x=[]\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                x.append(nums[i+1])\\n        x=Counter(x)\\n        y=list(x.values())\\n        z=list(x.keys())\\n        a=y.index(max(y))\\n        return z[a]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422533,
                "title": "easy-cpp-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == key && i<n-1){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n\\n        int t = 0,ans;\\n\\n        for(auto it: mp){\\n            if(t<it.second){\\n                t = it.second;\\n                ans = it.first;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == key && i<n-1){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n\\n        int t = 0,ans;\\n\\n        for(auto it: mp){\\n            if(t<it.second){\\n                t = it.second;\\n                ans = it.first;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402925,
                "title": "java-simple-solution-hashmap-counting-findmax",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int mostFrequent(int[] nums, int key) {\\n        int target = 0;\\n        int maxOccurrences = 0;\\n        Map<Integer, Integer> targetOccurrences = new HashMap<>();\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == key) {\\n                int currentOccurrences = targetOccurrences.getOrDefault(nums[i + 1], 0) + 1;\\n                targetOccurrences.put(nums[i + 1], currentOccurrences);\\n                \\n                if (currentOccurrences > maxOccurrences) {\\n                    maxOccurrences = currentOccurrences;\\n                    target = nums[i + 1];\\n                }\\n            }\\n        }\\n\\n        return target;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int mostFrequent(int[] nums, int key) {\\n        int target = 0;\\n        int maxOccurrences = 0;\\n        Map<Integer, Integer> targetOccurrences = new HashMap<>();\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == key) {\\n                int currentOccurrences = targetOccurrences.getOrDefault(nums[i + 1], 0) + 1;\\n                targetOccurrences.put(nums[i + 1], currentOccurrences);\\n                \\n                if (currentOccurrences > maxOccurrences) {\\n                    maxOccurrences = currentOccurrences;\\n                    target = nums[i + 1];\\n                }\\n            }\\n        }\\n\\n        return target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400580,
                "title": "simple-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>amap;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                amap[nums[i+1]]++;\\n            }\\n        }\\n        int max1=0;\\n        int ans=0;\\n        for(auto i:amap){\\n            if(i.second>max1){\\n                max1=i.second;\\n                ans=i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>amap;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                amap[nums[i+1]]++;\\n            }\\n        }\\n        int max1=0;\\n        int ans=0;\\n        for(auto i:amap){\\n            if(i.second>max1){\\n                max1=i.second;\\n                ans=i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394780,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==key  and i+1<n)\\n                mp[nums[i+1]]++;\\n        }\\n        int a=INT_MIN,ans=0;\\n        for(auto x:mp)\\n        {\\n            if(x.second>a)\\n            {\\n                ans=x.first;\\n                a=x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==key  and i+1<n)\\n                mp[nums[i+1]]++;\\n        }\\n        int a=INT_MIN,ans=0;\\n        for(auto x:mp)\\n        {\\n            if(x.second>a)\\n            {\\n                ans=x.first;\\n                a=x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394763,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        vector<int> vec;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                vec.push_back(nums[i+1]);\\n            }\\n        }\\n        unordered_map<int,int> m;\\n        for(auto x:vec)\\n        {\\n            m[x]++;\\n        }\\n        if(vec.size()==1) return vec[0];\\n        sort(vec.begin(),vec.end(),[&](int a,int b)\\n        {\\n            return m[a]!=m[b]?m[a]>m[b]:a>b;\\n        });\\n        return vec[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        vector<int> vec;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                vec.push_back(nums[i+1]);\\n            }\\n        }\\n        unordered_map<int,int> m;\\n        for(auto x:vec)\\n        {\\n            m[x]++;\\n        }\\n        if(vec.size()==1) return vec[0];\\n        sort(vec.begin(),vec.end(),[&](int a,int b)\\n        {\\n            return m[a]!=m[b]?m[a]>m[b]:a>b;\\n        });\\n        return vec[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386547,
                "title": "java-hash-table-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n       int maxCount = 0, target = -1;\\n\\n       HashMap<Integer,Integer> hm = new HashMap<>();\\n\\n       for(int i=1;i<nums.length;i++) {\\n           int trgt = nums[i];\\n\\n           if(nums[i-1] == key && hm.containsKey(trgt)) {\\n               hm.put(trgt,hm.get(trgt)+1);\\n           } else if(nums[i-1] == key) {\\n               hm.put(trgt,1);\\n           }\\n       }\\n\\n       for(int x : hm.keySet()) {\\n           if(hm.get(x) > maxCount) {\\n               maxCount = hm.get(x);\\n               target = x;\\n           }\\n       }\\n\\n       return target;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n       int maxCount = 0, target = -1;\\n\\n       HashMap<Integer,Integer> hm = new HashMap<>();\\n\\n       for(int i=1;i<nums.length;i++) {\\n           int trgt = nums[i];\\n\\n           if(nums[i-1] == key && hm.containsKey(trgt)) {\\n               hm.put(trgt,hm.get(trgt)+1);\\n           } else if(nums[i-1] == key) {\\n               hm.put(trgt,1);\\n           }\\n       }\\n\\n       for(int x : hm.keySet()) {\\n           if(hm.get(x) > maxCount) {\\n               maxCount = hm.get(x);\\n               target = x;\\n           }\\n       }\\n\\n       return target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383592,
                "title": "easy-c-sol",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> m;\\n        int n=nums.size();\\n        int ans=nums[0];\\n        int count=0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==key){\\n                m[nums[i+1]]++;\\n                if(m[nums[i+1]]>count){// this condition checks for the maximum\\n                    count=m[nums[i+1]];\\n                    ans=nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        unordered_map<int,int> m;\\n        int n=nums.size();\\n        int ans=nums[0];\\n        int count=0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==key){\\n                m[nums[i+1]]++;\\n                if(m[nums[i+1]]>count){// this condition checks for the maximum\\n                    count=m[nums[i+1]];\\n                    ans=nums[i+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382117,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d=dict()\\n        for i in range(len(nums)-1):\\n            if(nums[i]==key):\\n                if(nums[i+1] in d.keys()):\\n                    d[nums[i+1]]=d.get(nums[i+1])+1\\n                else:\\n                    d[nums[i+1]]=1\\n        res=0\\n        c=0\\n        for x,y in d.items():\\n            if(y>c):\\n                res=x\\n                c=y\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d=dict()\\n        for i in range(len(nums)-1):\\n            if(nums[i]==key):\\n                if(nums[i+1] in d.keys()):\\n                    d[nums[i+1]]=d.get(nums[i+1])+1\\n                else:\\n                    d[nums[i+1]]=1\\n        res=0\\n        c=0\\n        for x,y in d.items():\\n            if(y>c):\\n                res=x\\n                c=y\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380626,
                "title": "most-easiest-watch-once-c-o-n",
                "content": "### Explained below inside the code for better Understanding.\\n# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:~O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int,int> mp;\\n        int ans=0,count=-1;\\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i] == key)\\n                mp[nums[i+1]]++;\\n        }\\n\\n        for(auto i:mp)\\n        {\\n            if(count == -1){\\n                count = i.second;\\n                ans = i.first;\\n            }\\n\\n            else{\\n                if(i.second > count){\\n                    count = i.second;\\n                    ans = i.first;\\n                }\\n            }\\n        }\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int,int> mp;\\n        int ans=0,count=-1;\\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i] == key)\\n                mp[nums[i+1]]++;\\n        }\\n\\n        for(auto i:mp)\\n        {\\n            if(count == -1){\\n                count = i.second;\\n                ans = i.first;\\n            }\\n\\n            else{\\n                if(i.second > count){\\n                    count = i.second;\\n                    ans = i.first;\\n                }\\n            }\\n        }\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370058,
                "title": "java-code-using-mapping-beats-100",
                "content": "**EASY JAVA CODE**\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int max = Integer.MIN_VALUE; \\n        int x[] = new int [1000];\\n\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] == key)\\n            x[nums[i+1]-1]++;\\n        }  \\n        int ans = 0;\\n        for(int i=0;i<1000; i++){\\n            if(max < x[i]){\\n                max = x[i];\\n                ans = i+1;\\n            }   \\n        }\\n        return ans; // UPVOTE IF IT HELPED YOU :)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int max = Integer.MIN_VALUE; \\n        int x[] = new int [1000];\\n\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] == key)\\n            x[nums[i+1]-1]++;\\n        }  \\n        int ans = 0;\\n        for(int i=0;i<1000; i++){\\n            if(max < x[i]){\\n                max = x[i];\\n                ans = i+1;\\n            }   \\n        }\\n        return ans; // UPVOTE IF IT HELPED YOU :)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355798,
                "title": "unique-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n\\n        map<int,vector<int>>mp;\\n        for(int i = 0;i<nums.size();i++){\\n\\n            if(nums[i]==key and i+1 < nums.size())mp[key].push_back(i);\\n        }\\n\\n        int maxi = -1;\\n\\n        for(auto i : mp){\\n\\n            vector<int>v = i.second;\\n            map<int,int>m;\\n\\n            for(int j = 0;j<v.size();j++){\\n\\n                m[nums[v[j]+1]]++;\\n\\n\\n            }\\n            int c = 0;\\n\\n            for(auto i : m){\\n\\n                if(i.second>c){\\n                    c=i.second;\\n                    maxi = i.first;\\n                }\\n            }\\n        }\\n        return maxi;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n\\n        map<int,vector<int>>mp;\\n        for(int i = 0;i<nums.size();i++){\\n\\n            if(nums[i]==key and i+1 < nums.size())mp[key].push_back(i);\\n        }\\n\\n        int maxi = -1;\\n\\n        for(auto i : mp){\\n\\n            vector<int>v = i.second;\\n            map<int,int>m;\\n\\n            for(int j = 0;j<v.size();j++){\\n\\n                m[nums[v[j]+1]]++;\\n\\n\\n            }\\n            int c = 0;\\n\\n            for(auto i : m){\\n\\n                if(i.second>c){\\n                    c=i.second;\\n                    maxi = i.first;\\n                }\\n            }\\n        }\\n        return maxi;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353404,
                "title": "java-using-hashmap-simple-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n    Map<Integer,Integer> ma =new HashMap<>();\\n    for(int i=0;i<nums.length-1;i++){\\n        if(nums[i]==key)\\n        ma.put(nums[i+1],ma.getOrDefault(nums[i+1],0)+1);\\n    }\\n    int max=Integer.MIN_VALUE;\\n    for(int k:ma.values()){\\n        if(max<k)  max=k;\\n    }\\n    for(Map.Entry<Integer,Integer> e:ma.entrySet() ){\\n        if(e.getValue()==max)\\n        return e.getKey();\\n    }\\n    return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n    Map<Integer,Integer> ma =new HashMap<>();\\n    for(int i=0;i<nums.length-1;i++){\\n        if(nums[i]==key)\\n        ma.put(nums[i+1],ma.getOrDefault(nums[i+1],0)+1);\\n    }\\n    int max=Integer.MIN_VALUE;\\n    for(int k:ma.values()){\\n        if(max<k)  max=k;\\n    }\\n    for(Map.Entry<Integer,Integer> e:ma.entrySet() ){\\n        if(e.getValue()==max)\\n        return e.getKey();\\n    }\\n    return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320784,
                "title": "python-easy-solution-using-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d=defaultdict(int)\\n        a=0\\n        Min=float(\"-inf\")\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                d[nums[i+1]]+=1\\n        \\n        for k in d:\\n            if d.get(k)>Min:\\n                a=k\\n                Min=d.get(k)\\n        return a\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d=defaultdict(int)\\n        a=0\\n        Min=float(\"-inf\")\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                d[nums[i+1]]+=1\\n        \\n        for k in d:\\n            if d.get(k)>Min:\\n                a=k\\n                Min=d.get(k)\\n        return a\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320541,
                "title": "beginner-level-solution-beats-90-91-runtime-89-9-memory",
                "content": "# Approach\\n1. Iterate through the list, adding the targets & apperance into our dict.\\n2. Run through the dict and find the target with most apperance\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mostFrequent(self, nums, key):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n\\n        targets = {}\\n        n = len(nums)\\n        for i in range(n-1):\\n            if nums[i] == key:\\n                if nums[i+1] in targets:\\n                    targets[nums[i+1]] += 1\\n                else:\\n                    targets[nums[i+1]] = 1\\n\\n        high = 0\\n        output = 0\\n        for target in targets:\\n            if targets[target] > high:\\n                high = targets[target]\\n                output = target\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostFrequent(self, nums, key):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n\\n        targets = {}\\n        n = len(nums)\\n        for i in range(n-1):\\n            if nums[i] == key:\\n                if nums[i+1] in targets:\\n                    targets[nums[i+1]] += 1\\n                else:\\n                    targets[nums[i+1]] = 1\\n\\n        high = 0\\n        output = 0\\n        for target in targets:\\n            if targets[target] > high:\\n                high = targets[target]\\n                output = target\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311015,
                "title": "c-easy-solution-maps",
                "content": "```\\nint mostFrequent(vector<int>& n, int key) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==key && i+1<n.size()){\\n                v.push_back({n[i],n[i+1]});\\n            }\\n        }\\n        map<pair<int,int>,int> m;\\n        for(auto i:v){\\n            m[i]++;\\n        }\\n        int count=0;\\n        int ans;\\n        for(auto i:m){\\n            cout<<i.first.first<<\" \"<<i.first.second<<\"   \"<<i.second<<endl;\\n            if(i.second>count){\\n                count=i.second;\\n                ans=i.first.second;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint mostFrequent(vector<int>& n, int key) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==key && i+1<n.size()){\\n                v.push_back({n[i],n[i+1]});\\n            }\\n        }\\n        map<pair<int,int>,int> m;\\n        for(auto i:v){\\n            m[i]++;\\n        }\\n        int count=0;\\n        int ans;\\n        for(auto i:m){\\n            cout<<i.first.first<<\" \"<<i.first.second<<\"   \"<<i.second<<endl;\\n            if(i.second>count){\\n                count=i.second;\\n                ans=i.first.second;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3292494,
                "title": "simple-python-solution-beats-92-39",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d = collections.defaultdict(int)\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                d[nums[i+1]]+=1\\n        return max([(j,i) for i,j in d.items()])[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        d = collections.defaultdict(int)\\n        for i in range(len(nums)-1):\\n            if nums[i]==key:\\n                d[nums[i+1]]+=1\\n        return max([(j,i) for i,j in d.items()])[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286504,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int max = 0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==key){\\n                hm.put(nums[i+1],hm.getOrDefault(nums[i+1],0)+1);\\n                max = Math.max(max,hm.get(nums[i+1]));\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> i : hm.entrySet()){\\n            if(i.getValue()==max){\\n                ans = i.getKey();\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int max = 0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==key){\\n                hm.put(nums[i+1],hm.getOrDefault(nums[i+1],0)+1);\\n                max = Math.max(max,hm.get(nums[i+1]));\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> i : hm.entrySet()){\\n            if(i.getValue()==max){\\n                ans = i.getKey();\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285170,
                "title": "python-least-readable-one-liner",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        return sorted([nums[i + 1] for i in range(len(nums) - 1) if nums[i] == key], key=[nums[i + 1] for i in range(len(nums) - 1) if nums[i] == key].count)[-1]\\n\\n```\\n\\n# Code \\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        ll = []\\n        for i in range(len(nums) - 1):\\n            if nums[i] == key:\\n                ll.append(nums[i + 1])\\n        \\n        return sorted(ll, key=lambda x: ll.count(x))[-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        return sorted([nums[i + 1] for i in range(len(nums) - 1) if nums[i] == key], key=[nums[i + 1] for i in range(len(nums) - 1) if nums[i] == key].count)[-1]\\n\\n```\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        ll = []\\n        for i in range(len(nums) - 1):\\n            if nums[i] == key:\\n                ll.append(nums[i + 1])\\n        \\n        return sorted(ll, key=lambda x: ll.count(x))[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281306,
                "title": "very-simple-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple brute force approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int max_target = 0;\\n        int prev_count = 0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] == key){\\n                int target = nums[i+1];\\n                int count = 0;\\n                int flag = 0;\\n                for(int j=i; j<nums.length-1; j++){\\n                    if(nums[j] == key && nums[j+1] == target){\\n                        count++;\\n                        if(count >= prev_count){\\n                            prev_count = count;\\n                            flag = 1;\\n                        }\\n                    }\\n                }\\n                if(flag == 1){\\n                    max_target = target;\\n                }\\n            }\\n        }\\n        return max_target; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        int max_target = 0;\\n        int prev_count = 0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] == key){\\n                int target = nums[i+1];\\n                int count = 0;\\n                int flag = 0;\\n                for(int j=i; j<nums.length-1; j++){\\n                    if(nums[j] == key && nums[j+1] == target){\\n                        count++;\\n                        if(count >= prev_count){\\n                            prev_count = count;\\n                            flag = 1;\\n                        }\\n                    }\\n                }\\n                if(flag == 1){\\n                    max_target = target;\\n                }\\n            }\\n        }\\n        return max_target; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280651,
                "title": "easy-and-quck-python-solution-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dict={}\\n        for i in range(len(nums)-1):\\n            \\n            if nums[i]==key:\\n                if nums[i+1] in dict:\\n                    dict[nums[i+1]]+=1\\n                else:\\n                    dict[nums[i+1]]=0\\n        return max(dict,key=dict.get)\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequent(self, nums: List[int], key: int) -> int:\\n        dict={}\\n        for i in range(len(nums)-1):\\n            \\n            if nums[i]==key:\\n                if nums[i+1] in dict:\\n                    dict[nums[i+1]]+=1\\n                else:\\n                    dict[nums[i+1]]=0\\n        return max(dict,key=dict.get)\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277681,
                "title": "javascript-logic",
                "content": "# Code\\n```\\nvar mostFrequent = function(nums, key) {\\n    const map = {};\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === key) map[nums[i + 1]] = ~~map[nums[i + 1]] + 1;\\n    }\\n    return +Object.keys(map).sort((a, b) => map[b] - map[a])[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostFrequent = function(nums, key) {\\n    const map = {};\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === key) map[nums[i + 1]] = ~~map[nums[i + 1]] + 1;\\n    }\\n    return +Object.keys(map).sort((a, b) => map[b] - map[a])[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3265120,
                "title": "java-javascript-solution-jw",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nJava:\\n```\\npublic int mostFrequent(int[] nums, int key) {\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    int mostFreq = -1;\\n    for (int i = 0, n = nums.length, max = 0; i + 1 < n; ++i) {\\n        if (nums[i] == key) {\\n            int candidate = nums[i + 1];\\n            freq.put(candidate, 1 + freq.getOrDefault(candidate, 0));\\n            if (freq.get(candidate) > max) {\\n                max = freq.get(candidate);\\n                mostFreq = candidate;\\n            }\\n        }\\n    }\\n    return mostFreq;\\n}\\n```\\nJavascript:\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let freq = {};\\n    let result = 0;\\n    for (let i = 0, max = 0; i < nums.length - 1; ++i) {\\n    if (nums[i] !== key) continue;\\n    let target = nums[i + 1];\\n    freq[target] = (freq[target] || 0) + 1;\\n    if (freq[target] > max) {\\n        max = freq[target];\\n        result = target;\\n    }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\npublic int mostFrequent(int[] nums, int key) {\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    int mostFreq = -1;\\n    for (int i = 0, n = nums.length, max = 0; i + 1 < n; ++i) {\\n        if (nums[i] == key) {\\n            int candidate = nums[i + 1];\\n            freq.put(candidate, 1 + freq.getOrDefault(candidate, 0));\\n            if (freq.get(candidate) > max) {\\n                max = freq.get(candidate);\\n                mostFreq = candidate;\\n            }\\n        }\\n    }\\n    return mostFreq;\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let freq = {};\\n    let result = 0;\\n    for (let i = 0, max = 0; i < nums.length - 1; ++i) {\\n    if (nums[i] !== key) continue;\\n    let target = nums[i + 1];\\n    freq[target] = (freq[target] || 0) + 1;\\n    if (freq[target] > max) {\\n        max = freq[target];\\n        result = target;\\n    }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3256283,
                "title": "js-javascript-solution-o-n",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let obj = {}\\n    let maxNumber = 0\\n    let maxCounter = 0\\n    for (let i = 0; i <= nums.length - 2; i++){\\n        if (nums[i] === key){\\n            if (obj[nums[i + 1]] === undefined) obj[nums[i + 1]] = 1\\n            else obj[nums[i + 1]]++\\n            if (maxCounter < obj[nums[i + 1]]){\\n                maxCounter = obj[nums[i + 1]]\\n                maxNumber = nums[i + 1]\\n            }\\n        }\\n    }\\n    return maxNumber\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @return {number}\\n */\\nvar mostFrequent = function(nums, key) {\\n    let obj = {}\\n    let maxNumber = 0\\n    let maxCounter = 0\\n    for (let i = 0; i <= nums.length - 2; i++){\\n        if (nums[i] === key){\\n            if (obj[nums[i + 1]] === undefined) obj[nums[i + 1]] = 1\\n            else obj[nums[i + 1]]++\\n            if (maxCounter < obj[nums[i + 1]]){\\n                maxCounter = obj[nums[i + 1]]\\n                maxNumber = nums[i + 1]\\n            }\\n        }\\n    }\\n    return maxNumber\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243380,
                "title": "c-using-map",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int,int>m;\\n        int maxx=-1,target=-1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(key==nums[i]){\\n                m[nums[i+1]]++;\\n\\n                if(m[nums[i+1]]>maxx){\\n                    maxx=m[nums[i+1]];\\n                    target=nums[i+1];\\n                }\\n            }\\n        }\\n\\n        return target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequent(vector<int>& nums, int key) {\\n        map<int,int>m;\\n        int maxx=-1,target=-1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(key==nums[i]){\\n                m[nums[i+1]]++;\\n\\n                if(m[nums[i+1]]>maxx){\\n                    maxx=m[nums[i+1]];\\n                    target=nums[i+1];\\n                }\\n            }\\n        }\\n\\n        return target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243060,
                "title": "javascript-one-loop-hash",
                "content": "- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n```\\nfunction mostFrequent(nums: number[], key: number): number {\\n    const hash = {};\\n    let max = 0;\\n    let num = 0;\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === key) {\\n            if (!hash[nums[i + 1]]) {\\n                hash[nums[i + 1]] = 0;\\n            }\\n\\n            hash[nums[i + 1]]++;\\n\\n            if (max < hash[nums[i + 1]]) {\\n                max = hash[nums[i + 1]];\\n                num = nums[i + 1];\\n            }\\n        } \\n    }\\n\\n    return num;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction mostFrequent(nums: number[], key: number): number {\\n    const hash = {};\\n    let max = 0;\\n    let num = 0;\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === key) {\\n            if (!hash[nums[i + 1]]) {\\n                hash[nums[i + 1]] = 0;\\n            }\\n\\n            hash[nums[i + 1]]++;\\n\\n            if (max < hash[nums[i + 1]]) {\\n                max = hash[nums[i + 1]];\\n                num = nums[i + 1];\\n            }\\n        } \\n    }\\n\\n    return num;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1894775,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1807836,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1854948,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1721273,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1715391,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2059494,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2018695,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1918849,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1856795,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1760627,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1894775,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1807836,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1854948,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1721273,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1715391,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2059494,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2018695,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1918849,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1856795,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1760627,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "awful explanation. It`s totally not clear what is target, what is key and what we are supposed to count!"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "vimala is a koja"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "The problem is asking to find the number that appear the most after a certain key. It is specified that only one number fits this criterion."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "can you describe this question properly?"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "Input:\nTESTCASE NO.97\nnums =\n[1,1,1,1,2,2,2]\nkey =\n1\nOutput\n2\nExpected\n1\nWHAT TO DO IF COUNT OF TARGET IS SAME?\n\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same doubt!"
                    },
                    {
                        "username": "topswe",
                        "content": "Use a frequency counter of all possible targets, and take the max."
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "What is the targets? Basically I can not understand which is targest?"
                    },
                    {
                        "username": "razvanciobanua",
                        "content": "Testcase 80 : nums = [11,22,11,33,11,33] , key = 11 \\nis the maximum count is unique in this case?\\n"
                    },
                    {
                        "username": "arvine",
                        "content": "[@ashish_2298744](/ashish_2298744) wait I am confused though because doesn\\'t 11 also appear after as well 2 times once at index 2 and again at index 4 making it the same count as 33 as in they both appear 2 times after the given key (11) ? "
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "Yes, the targets are 22 (index 1), 33 (index 3) and 33 (index 5) since they all appear after the key element in the array. So the count is also unique with 33 as the right answer."
                    },
                    {
                        "username": "h_karmit",
                        "content": "if key == a[i] --> so find maxvalue of a[i+1]\nreturn maxvalue_key;\n \n\n--> code :\nif(a[i] == t){\n                    int value = map.getOrDefault(a[i+1],0)+1;\n                    if(value>maxvalue){\n                        maxvalue = value;\n                        key = a[i+1];\n                    }\n                    map.put(a[i+1], value);"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": " `nums - [1,1,1,1,2,2,2] , key - 1 , expected - 1`\\n`nums - [11,22,11,33,11,33] , key - 11 , expected - 33`\\n\\n`These 2 test-cases are conflicting.`\\n`In 1st the ans is the smallest no having same frequency`\\n`In 2nd the answer is the largest having same frequnecy`\\n\\n`Please help!`"
                    },
                    {
                        "username": "madhavgupta2001",
                        "content": "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n\\n        int p=0;int r=0;int q=0;int u=0;int s=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(nums[i]==key){\\n                u=q;\\n                    q=0;\\n                p=nums[i+1];\\n                   \\n                for(int j=0;j<nums.length;j++){\\n                    \\n                    if(nums[j]==p){\\n                        q++;\\n                  } }\\n                if(q>u){\\n                    s=p;\\n                \\n                }\\n            }\\n            \\n        }\\n        return s;\\n        \\n    }\\n}\\ni clear 99 test case but for this {1,1,2,1,2} and key =1 not pass.  can anyone tells the mistake?"
                    },
                    {
                        "username": "SambhavChoudhary",
                        "content": "For test case 95 I am getting wrong answer but same when I run on VS code I am getting correct answer."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    \\nint mostFrequent(vector<int>& nums, int key) {\\n        int freq=INT_MIN;\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==key){\\n                mp[nums[i+1]]++;\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>freq){\\n                ans=it.first;\\n                freq=it.second;\\n            }\\n        }\\n        return ans;\\n    }"
                    }
                ]
            }
        ]
    }
]