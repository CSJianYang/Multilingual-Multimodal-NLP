[
    {
        "title": "Domino and Tromino Tiling",
        "question_content": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n&nbsp;\nExample 1:\n\nInput: n = 3\nOutput: 5\nExplanation: The five different ways are show above.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000",
        "solutions": [
            {
                "id": 116581,
                "title": "detail-and-explanation-of-o-n-solution-why-dp-n-2-d-n-1-dp-n-3",
                "content": "when N==0, we need return 0, but in dp , we need make dp[0]=1 for easy to construct formula\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengkaiwei/image_1519539268.png)\nsorry my handwriting is ugly\n\ndp[n]=dp[n-1]+dp[n-2]+ 2*(dp[n-3]+...+d[0])\n=dp[n-1]+dp[n-2]+dp[n-3]+dp[n-3]+2*(dp[n-4]+...+d[0])\n=dp[n-1]+dp[n-3]+(dp[n-2]+dp[n-3]+2*(dp[n-4]+...+d[0]))\n=dp[n-1]+dp[n-3]+dp[n-1]\n=2*dp[n-1]+dp[n-3]\n\n\n\n```\n int numTilings(int N) {\n    int md=1e9;\n    md+=7;\n    vector<long long> v(1001,0);\n    v[1]=1;\n    v[2]=2;\n    v[3]=5;\n    if(N<=3)\n        return v[N];\n    for(int i=4;i<=N;++i){\n        v[i]=2*v[i-1]+v[i-3]; \n        v[i]%=md;\n    }\n    return v[N];\n    \n}\n```\n",
                "solutionTags": [],
                "code": "```\n int numTilings(int N) {\n    int md=1e9;\n    md+=7;\n    vector<long long> v(1001,0);\n    v[1]=1;\n    v[2]=2;\n    v[3]=5;\n    if(N<=3)\n        return v[N];\n    for(int i=4;i<=N;++i){\n        v[i]=2*v[i-1]+v[i-3]; \n        v[i]%=md;\n    }\n    return v[N];\n    \n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116664,
                "title": "schematic-explanation-of-two-equivalent-dp-recurrence-formula",
                "content": "First, how many types of tiles do we have (including rotation)?\\n\\nThe answer is six: two types from domino and four types from trimino. I label them as follows:\\n\\ntype 1: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519580711.png)representing vertical domino\\ntype 2: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519580764.png)representing horizontal domino\\ntype 3: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519580948.png)representing `L`-shaped trimino\\ntype 4: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519580968.png)representing `Gamma`-shaped trimino\\ntype 5: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519581008.png) representing mirrored-`L`-shaped trimino\\ntype 6: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519581060.png)representing mirrored-`Gamma`-shaped trimino\\n\\nNow let\\'s define `T(N)` as the number of ways tiling the `2 x N` board. To obtain the recurrence relations for `T(N)`, we shall consider the very **last tile** in the  `2 x N` board (this is the tile which occupies at least one of the two grids at index `N` and completes the `2 x N` board). So what type can it be?\\n\\nImmediately we can rule out type 3 and 4, because they will never complete the board, thus cannot be the last tile. So we end up with four choices for the last tile:\\n\\n1. **The last tile is of type 1**: in this case, the rest tiles will fill up the `2 x (N-1)` board, then by definition, the number of ways for this case will be `T(N-1)`.\\n\\n2. **The last tile is of type 2**: in this case, the second to last tile must also be of type 2 (so they together fill up the last `2 x 2` region), and the rest tiles will fill up the `2 x (N-2)` board, again by definition, the number of ways for this case will be `T(N-2)`.\\n\\n3. **The last tile is of type 5**: in this case, the rest tiles must fill up the `2 x (N-1)` board except for the lower grid at index `N-1`, like this shape: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519582901.png). Our definition of `T(N)` does not cover this case, so we have to generalize it and define `T_up(N)` as the the number of ways to fill a `2 x N` board except for the last lower grid. Then the number of ways for this case will be `T_up(N-1)`.\\n\\n4. **The last tile is of type 6**: in this case, the rest tiles must fill up the `2 x (N-1)` board except for the upper grid at index `N-1`, like this shape: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519583189.png). Our definition of `T(N)` does not cover this case either, so we define `T_down(N)` as the the number of ways to fill a `2 x N` board except for the last upper grid. Then the number of ways for this case will be `T_down(N-1)`.\\n\\nIt\\'s easy to show that the four cases will not overlap with each other (because at least the last tile will be different), and since the last tile must be one of the four cases, we conclude:\\n\\n `T(N) = T(N-1) + T(N-2) + T_up(N-1) + T_down(N-1)`\\n\\nThis looks like a recurrence formula, except that we do not know `T_up(N)` and `T_down(N)` yet. To figure them out, we can follow exactly the same analyses above by considering the very last tile for each of them.\\n\\nTake `T_up(N)` as an example. We want to fill up a board shape like this: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519583923.png). What could the type of the very last tile be? The answer is: **type 2** (horizontal domino) and **type 4** (`Gamma`-shaped trimino). For the former, the rest of tiles will fill up a `2 x (N-1)` board except for the last upper grid, and by definition, there are `T_down(N-1)` ways to do this. For the latter, the rest tiles will fill up a `2 x (N-2)` board completely, and by definition, there are `T(N-2)` ways to do so. So we conclude:\\n\\n`T_up(N) = T_down(N-1) + T(N-2)`\\n\\nSimilarly we can obtain:\\n\\n`T_down(N) = T_up(N-1) + T(N-2)`\\n\\nAnd, there you go, we have found the recurrence relations for `T(N)`, `T_up(N)`, `T_down(N)`:\\n\\n`T(N) = T(N-1) + T(N-2) + T_up(N-1) + T_down(N-1)`\\n\\n`T_up(N) = T_down(N-1) + T(N-2)`\\n\\n`T_down(N) = T_up(N-1) + T(N-2)`\\n\\nThe termination conditions are as follows:\\n\\nFor `N = 0`, we have `T(0) = 1`, `T_up(0) =  T_down(0) = 0`;\\nFor `N = 1`, we have `T(1) = 1`, `T_up(1) =  T_down(1) = 0`.\\n\\nNow it is straightforward to write the `O(N)` space solution. However, if you notice that `T(N)`, `T_up(N)`, `T_down(N)` are only related to those at indices `N-1` and `N-2`, the space can be cut down to `O(1)`. Here is a quick implementation in Java:\\n\\n\\n```\\nprivate static final int MOD = 1_000_000_007;\\n    \\npublic int numTilings(int N) {\\n    int T_prepre = 1, T_pre = 1;\\n    int T_up_pre = 0, T_down_pre = 0;\\n        \\n    for (int n = 2; n <= N; n++) {\\n        int T_cur = (int)((0L + T_prepre + T_pre + T_up_pre + T_down_pre) % MOD);\\n        int T_up_cur = (T_prepre + T_down_pre) % MOD;\\n        int T_down_cur = (T_prepre + T_up_pre) % MOD;\\n            \\n        T_prepre = T_pre;\\n        T_pre = T_cur;\\n            \\n        T_up_pre = T_up_cur;\\n        T_down_pre = T_down_cur;\\n    }\\n        \\n    return T_pre;\\n}\\n```\\n\\n<br>\\n\\nWait..., we are not done yet. It turns out that the recurrence relations for `T(N)`, `T_up(N)`, `T_down(N)` can be combined into a single one. To see how, first note that we have:\\n\\n `T(N) = T(N-1) + T(N-2) + T_up(N-1) + T_down(N-1)`\\n \\n `T_up(N-1) = T_down(N-2) + T(N-3)`\\n \\n `T_down(N-1) = T_up(N-2) + T(N-3)`\\n \\n Now plugging the second and third equations into the first one, we get:\\n \\n `T(N) = T(N-1) + T(N-2) + T_down(N-2) + T(N-3) + T_up(N-2) + T(N-3)`\\n \\nwhich can be regrouped as:\\n\\n`T(N) = T(N-1) + T(N-3) + [T(N-2) + T(N-3) + T_up(N-2) + T_down(N-2)]`\\n\\t\\nNow if you recognize the part in **square brakets** which is simply `T(N-1)`, we arrive at: \\n \\n `T(N) = 2 * T(N-1) + T(N-3)`.\\n \\nI would refer you to this [post](https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3) shared by [zhengkaiwei](https://leetcode.com/zhengkaiwei/) for more explanations of the meaning of this formula. Anyway, the following is the `O(N)` time and `O(1)` space based on this formula, where I used `p3`, `p2`, `p1` to denote `T(N-3)`, `T(N-2)`, `T(N-1)` respectively, and initialized them to `-1`, `0` and `1` to account for correct recurrence values.\\n\\n```\\nprivate static final int MOD = 1_000_000_007;\\n    \\npublic int numTilings(int N) {\\n    int p3 = -1, p2 = 0, p1 = 1;\\n        \\n    for (int n = 1; n <= N; n++) {\\n        int cur = (int)((p1 * 2L + p3) % MOD);\\n        p3 = p2;\\n        p2 = p1;\\n        p1 = cur;\\n    }\\n        \\n    return p1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nprivate static final int MOD = 1_000_000_007;\\n    \\npublic int numTilings(int N) {\\n    int T_prepre = 1, T_pre = 1;\\n    int T_up_pre = 0, T_down_pre = 0;\\n        \\n    for (int n = 2; n <= N; n++) {\\n        int T_cur = (int)((0L + T_prepre + T_pre + T_up_pre + T_down_pre) % MOD);\\n        int T_up_cur = (T_prepre + T_down_pre) % MOD;\\n        int T_down_cur = (T_prepre + T_up_pre) % MOD;\\n            \\n        T_prepre = T_pre;\\n        T_pre = T_cur;\\n            \\n        T_up_pre = T_up_cur;\\n        T_down_pre = T_down_cur;\\n    }\\n        \\n    return T_pre;\\n}\\n```\n```\\nprivate static final int MOD = 1_000_000_007;\\n    \\npublic int numTilings(int N) {\\n    int p3 = -1, p2 = 0, p1 = 1;\\n        \\n    for (int n = 1; n <= N; n++) {\\n        int cur = (int)((p1 * 2L + p3) % MOD);\\n        p3 = p2;\\n        p2 = p1;\\n        p1 = cur;\\n    }\\n        \\n    return p1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620975,
                "title": "c-python-simple-solution-w-images-explanation-optimization-from-brute-force-to-dp",
                "content": "We are given a `2xn` grid and we need to return number of ways to tile the grid using domino (2x1 shape) and tromino(L shape) tiles.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nFirst let\\'s see what different types of shapes we have with us (considering rotations) -\\n\\n<p align = middle>\\n<img src= https://assets.leetcode.com/users/images/9f0fa40d-874c-45dd-88fb-a6d964026e69_1639105504.9259145.png />\\n</p>\\n\\nSo in total, we get 6 different types of shapes (2 from domino & 4 from tromino). **These tile-1, tile-2,... will henceforth be referred as T1, T2, and so on... respectively**\\n\\nLet\\'s see how we can approach this problem using brute-force approach. Since we are only given a `2xn` grid, let our current position on the grid be denoted by an index `i` which denotes that we are currently at `i`th column of grid. At each column, we have the choice to choose any form of the above 6 tiles. However, the current choice will be limited by our previous choices. For eg. If we previously chose T3, we cannot choose T4 after it since that would leave a gap in the grid. Let\\'s see the different cases we have in which we can place tiles -\\n\\n\\n\\n<p align = middle>\\n<img src = https://assets.leetcode.com/users/images/9a096afe-85f9-4358-a179-5563f960fc37_1639115832.0220907.png />\\n<img src = https://assets.leetcode.com/users/images/6cbfc1b2-edda-402b-a386-27b29ce215cf_1639115869.433002.png />\\n</p>\\n\\nThese are all the possible cases using which we can recursively fill our `2xn` grid. We have two different cases where previous rows have no gaps and where previous rows do have gaps. We need to treat them different as that affects the choices of our tiles. So to sum up, we have - \\n1. **No Previous Gaps:**\\n\\t* Place T1 and move to `i+1`: **`solve(i+1, previousGap=false)`**\\n\\t* Place T2 in pair and move to `i+2`: **`solve(i+2, previousGap=false)`**\\n\\t* Place either T3 or T4 (consider both cases) and move to `i+2` with gap at `i+1`th column: **`2*solve(i+2, previousGap=true)`**\\n\\n2. **Previous Gaps Present:**\\n\\t* Place T5 or T6 & fill previous gap (consider only 1 bcoz depending on current configuration, only 1 grid out of them will fit) and move to `i+1` with no previous gaps remaining: **`solve(i+1, previousGap=false)`**\\n\\t* Place T2 & fill previous gap and move to `i+1` with gap present in `i`th column: **`solve(i+1, previousGap=true)`**\\n\\n\\nThat\\'s it! We now just recursively fill the grid using above cases. If we reach the end of the grid (column `i = n`) with no previous gaps, then we know that we found 1 possible way of tiling grid, so we return 1. Otherwise if we exceed bounds of grid or reach end with previous gaps remaining, then we return false.\\n\\n**C++**\\n> *Tiling from Start-to-End*\\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        return solve(0, n, false);\\n    }\\n    long solve(int i, int n, bool previousGap) {\\n        if(i > n) return 0;                 // previous tiling exceeded bounds of grid - return 0 denoting not a valid tiling\\n        if(i == n) return !previousGap;     // return 1 when there was no previous gap present\\n        if(previousGap)                     // previous column had gap remaining in it\\n            return (solve(i+1, n, false) + solve(i+1, n, true)) % MOD;\\n        return (solve(i+1, n, false) + solve(i+2, n, false) + 2l*solve(i+2, n, true)) % MOD;\\n    }\\n};\\n```\\n> *Tiling from End-to-Start*\\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int numTilings(int n, bool previousGap = false) {\\n        if(n < 0) return 0;\\n        if(n == 0) return !previousGap;\\n        if(previousGap)\\n            return (numTilings(n-1) + numTilings(n-1, true)) % MOD;\\n        return (numTilings(n-1) + numTilings(n-2) + 2l*numTilings(n-2, true)) % MOD;\\n    }\\n};\\n```\\n\\n\\n**Python**\\n> *Tiling from Start-to-End*\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        def solve(i, previous_gap):\\n            if i > n: return 0\\n            if i == n: return not previous_gap\\n            if previous_gap:\\n                return solve(i+1, False) + solve(i+1, True)\\n            return solve(i+1, False) + solve(i+2, False) + 2*solve(i+2, True)\\n        return solve(0, False) % 1_000_000_007\\n```\\n> *Tiling from End-to-Start*\\n```python\\nclass Solution:\\n    def numTilings(self, n, previous_gap = False):\\n        if n < 0: return 0\\n        if n == 0: return not previous_gap\\n        if previous_gap:\\n            return (self.numTilings(n-1) + self.numTilings(n-1, True)) % 1_000_000_007\\n        return (self.numTilings(n-1) + self.numTilings(n-2) + 2*self.numTilings(n-2, True)) % 1_000_000_007\\n```\\n\\n***Time Complexity :*** <code>O(3<sup>N</sup>)</code> where `N` is the given number of columns of grid. We are branching out a max of 3 recursive calls each time and `N` such states giving total  time complexity of <code>O(3<sup>N</sup>)</code> \\n***Space Complexity :*** `O(N)`, required for recursive stack.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nDrawing out the recursion tree for previous approach, we can observe that we were doing many repeated redundant calls to the same function state. But for the given parameters - `i` and `previousGap`, the answer will always remain the same. So, we dont need to repeatedly calculate the same results over and over again. We can instead calculate it once and store the result and whenever same call will be made, we can directly return this result instead of repeating the whole calculation.\\n\\nFor this purpose, we will use dynamic programming and memoize the result before returning from each recursive call. We use a `dp` array where `dp[i][previousGap]` denotes the number of ways to tile a grid starting from the `i`th column and `previousGap` denotes whether previous column had gap in it or not. Whenever we find that `dp[i][previousGap]` is already calculated, we can directly return the result.\\n\\n**C++**\\n> *Tiling from Start-to-End*\\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int dp[1001][2]{};\\n    int numTilings(int n) {\\n        return solve(0, n, false);\\n    }\\n    long solve(int i, int n, bool previousGap) {\\n        if(i > n) return 0;\\n        if(i == n) return !previousGap;\\n        if(dp[i][previousGap]) return dp[i][previousGap];\\n        if(previousGap)\\n            return dp[i][previousGap] = (solve(i+1, n, false) + solve(i+1, n, true)) % MOD;\\n        return dp[i][previousGap] = (solve(i+1, n, false) + solve(i+2, n, false) + 2*solve(i+2, n, true)) % MOD;\\n    }\\n};\\n```\\n> *Tiling from End-to-Start*\\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int dp[1001][2]{};\\n    int numTilings(int n, bool previousGap = false) {\\n        if(n < 0) return 0;\\n        if(n == 0) return !previousGap;\\n        if(dp[n][previousGap]) return dp[n][previousGap];\\n        if(previousGap)\\n            return dp[n][previousGap] = (numTilings(n-1) + numTilings(n-1, true)) % MOD;\\n        return dp[n][previousGap] = (numTilings(n-1) + numTilings(n-2) + 2l*numTilings(n-2, true)) % MOD;\\n    }\\n};\\n```\\n\\n**Python**\\n> *Tiling from Start-to-End*\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        @cache\\n        def solve(i, previous_gap):\\n            if i > n: return 0\\n            if i == n: return not previous_gap\\n            if previous_gap:\\n                return solve(i+1, False) + solve(i+1, True)\\n            return solve(i+1, False) + solve(i+2, False) + 2*solve(i+2, True)\\n        return solve(0, False) % 1_000_000_007\\n```\\n> *Tiling from End-to-Start*\\n```python\\nclass Solution:\\n    @cache\\n    def numTilings(self, n, previous_gap = False):\\n        if n < 0: return 0\\n        if n == 0: return not previous_gap\\n        if previous_gap:\\n            return (self.numTilings(n-1) + self.numTilings(n-1, True)) % 1_000_000_007\\n        return (self.numTilings(n-1) + self.numTilings(n-2) + 2*self.numTilings(n-2, True)) % 1_000_000_007\\n```\\n\\n***Time Complexity :*** <code>O(N)</code> where `N` is the given number of columns of grid\\n***Space Complexity :*** `O(N)`, required for recursive stack and maintaining `dp` \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Tabulation)***\\n\\nWe can also solve this iteratively using dynamic programming. The logic remains similar to the above approach. Here, we again use a `dp` array where `dp[i][0]` denotes the number of ways to tile the grid till `i`th column (including `i`th column) and keeping no gap & `dp[i][1]` denotes the number of ways to completely tile the grid till `i`th column keeping a gap in `i+1`th column (a square protruding out).\\n\\nSimilar to previous solution, we will consider above-mentioned various cases with slight change to adjust for this iterative solutions building in bottom-up manner instead of recursive solution which was calculating in top-down manner. \\n\\n1. **`dp[i][0]`: (number of ways to tile till `i`th column leaving no gap)**\\n\\t* Add T1 at `i`th column updating previous dp state till `i-1`th column that had no previous gap: `dp[i-1][0]`\\n\\t* Add T2 in pair at `i-1`th column updating dp state till `i-2`th column that had no previous gap: `dp[i-2][0]`\\n\\t* Add T5 or T6 at `i-1`th column updating previous dp state till `i-2`th column & filling up the gap at `i-1`th column left by that dp state: `2*dp[i-2][1]` (2x because both T5/T6 can be used to fill the previous dp state having a gap)\\n\\t\\n\\n2. \\t**`dp[i][1]`: (number of ways to tile till `i`th column leaving a gap in `i+1`th column)**\\n\\t* Add T3/T4 at `i`th column updating previous dp state till `i-1`th column having no gap: `dp[i-1][0]`\\n\\t* Use T2 at `i`th column updating previous dp state till `i-1`th column which had a gap at `i`th column: `dp[i-1][1]`\\n\\nThe base conditions are when we have grid with 1 column, `dp[1][0]=1` since we can tile using T1, `dp[1][1]=1` since we can only either use T3 or T4 to tile and leave a gap at `i+1=2`th column. \\nSimilarly, `dp[2][0]=2` since we can tile by adding T1 to `dp[1][0]` ( <img src =\"https://assets.leetcode.com/users/images/89d14903-48f5-47c2-aaab-d0c9f4c7f2e5_1639147300.2449708.png\" height=30 /> ) or use T2 in pairs ( <img src=\"https://assets.leetcode.com/users/images/82ab26e8-e719-4f3c-8897-2749087c5769_1639147180.0998144.png\" height=30 /> ) and `dp[2][1]=2` since we can add T2 to `dp[1][1]` (  <img src=\"https://assets.leetcode.com/users/images/ea4d3fa9-5470-4d6b-a842-cbac38e6e4b3_1639147400.0859642.png\" height=30 /> ) or add T3/T4 to `dp[1][0]` ( <img src=\"https://assets.leetcode.com/users/images/e8709c3f-df65-42ee-93bb-5bc097624a27_1639147533.6720436.png\" height=30 /> ) \\n\\n\\n\\n\\n\\n**C++**\\t\\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(2));\\n        dp[1] = {1, 1}, dp[2] = {2, 2};                 // base cases\\n        for(int i = 3; i <= n; i++) {\\n            dp[i][0] = (dp[i-1][0] + dp[i-2][0] + 2l*dp[i-2][1]) % MOD;\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][1]) % MOD;\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(n+2)]\\n        dp[1], dp[2] = [1, 1], [2, 2]\\n        for i in range(3, n+1):\\n            dp[i][0] = dp[i-1][0] + dp[i-2][0] + 2*dp[i-2][1]\\n            dp[i][1] = dp[i-1][0] + dp[i-1][1]\\n        return dp[n][0] % 1_000_000_007\\n```\\n\\nIf the above wasn\\'t understood, the following is based on slightly different definition of DP which maybe better understood by some people.\\n\\n<blockquote>\\n<details>\\n<summary><b><em>Slight Different DP modelling</em></b></summary>\\n\\nThere\\'s a slightly different way of implementation as well which depends upon how we model & define our dp states. If we consider a dp array, where `dp[i][0]` denotes number of ways to completely tile till & including `i`th column leaving no gap and `dp[i][1]` denotes the number of ways to complete tile till `i-1`th column and leaving a gap at `i` column (Notice the difference from above definition).\\n\\nIn this case, we define the state transition cases as -\\n\\n1. **`dp[i][0]`: (number of ways to tile till `i`th column leaving no gap)**\\n\\t* Add T1 at `i`th column updating previous dp state till `i-1`th column having no previous gap: `dp[i-1][0]`\\n\\t* Add T2 in pair at `i-1`th column updating dp state till `i-2`th column having no previous gap: `dp[i-2][0]`\\n\\t* Add T5 or T6 at `i-1`th column updating previous dp state at `i-1`th column & filling up the gap at `i-1`th column left by that dp state: `2*dp[i-1][1]` (*<- different definition of dp changed this*)\\n\\t\\n2. \\t**`dp[i][1]`: (number of ways to tile till `i-1`th column keeping a gap in `i`th column)** (*different definition of dp changes this*)\\n\\t* Add T3/T4 at `i-1`th column updating dp state till `i-2`th column that had no gap (and this leaves a gap at `i`th column instead of `i+1`th column as in above approach): `dp[i-2][0]`\\n\\t* Use T2 at `i-1`th column updating previous dp state till `i-1`th column that had a gap at `i-1`th column (again this leaves gap at `i`th column instead of `i+1` as in above approach): `dp[i-1][1]`\\n\\nThe base conditions change accordingly as well.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(2));\\n        dp[1] = {1, 1}, dp[2] = {2, 1};                 // base cases\\n        for(int i = 3; i <= n; i++) {\\n            dp[i][0] = (dp[i-1][0] + dp[i-2][0] + 2l*dp[i-1][1]) % MOD;\\n            dp[i][1] = (dp[i-2][0] + dp[i-1][1]) % MOD;\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(n+2)]\\n        dp[1], dp[2] = [1, 1], [2, 1]\\n        for i in range(3, n+1):\\n            dp[i][0] = dp[i-1][0] + dp[i-2][0] + 2*dp[i-1][1]\\n            dp[i][1] = dp[i-2][0] + dp[i-1][1]\\n        return dp[n][0] % 1_000_000_007\\n```\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(N)`, required maintaining `dp` \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space Optimized Dynamic Programming)***\\n\\nIn the above solution, we can observe that we are only ever accesing results stored in `i-1` & `i-2` columns. So we can optimize space by just storing those previous columns which are required to calculate the result for current column.\\n\\nFor this, we can either keep the structure of previous code as it is but use a dp array of only 3 rows and just modulo 3. Or we can use separate variables to store previous results. Use whichever is easier/preferable to your style\\n\\n**C++**\\n*Using mod3 on dp of 3 rows*\\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(3, vector<int>(2));  // note only 3 rows are declared\\n        dp[1] = {1, 1}, dp[2] = {2, 2};\\n        for(int i = 3; i <= n; i++) {\\n            dp[i%3][0] = (dp[(i-1)%3][0] + dp[(i-2)%3][0] + 2l*dp[(i-2)%3][1]) % MOD;\\n            dp[i%3][1] = (dp[(i-1)%3][0] + dp[(i-1)%3][1]) % MOD;\\n        }\\n        return dp[n%3][0];\\n    }\\n};\\n```\\n\\n*Separate variables storing previous results*\\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        if(n <= 2) return n;\\n\\t\\t// filled_prev = dp[i-1][0], filled_prev2 = dp[i-2][0]...same for gap_prev & gap_prev2\\n        int filled_prev = 2, gap_prev = 2, filled_prev2 = 1, gap_prev2 = 1;\\n        for(int i = 3; i <= n; i++) {\\n            int filled = (filled_prev + filled_prev2 + 2l*gap_prev2) % MOD;\\n            int gap = (filled_prev + gap_prev) % MOD;\\n            \\n            filled_prev2 = filled_prev, filled_prev = filled;\\n            gap_prev2 = gap_prev, gap_prev = gap;\\n        }\\n        return filled_prev;\\n    }\\n};\\n```\\n\\n**Python**\\n*Using mod3 of dp of 3 rows*\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(3)]\\n        dp[1], dp[2] = [1, 1], [2, 2]\\n        for i in range(3, n+1):\\n            dp[i%3][0] = dp[(i-1)%3][0] + dp[(i-2)%3][0] + 2*dp[(i-2)%3][1]\\n            dp[i%3][1] = dp[(i-1)%3][0] + dp[(i-1)%3][1]\\n        return dp[n%3][0] % 1_000_000_007\\n```\\n\\n*Separate variables storing previous results*\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        if n <= 2: return n\\n        filled_prev, gap_prev, filled_prev2, gap_prev2 = 2,2,1,1\\n        for i in range(3, n+1):\\n            filled = filled_prev + filled_prev2 + 2*gap_prev2\\n            gap = filled_prev + gap_prev\\n            \\n            filled_prev2, filled_prev, gap_prev2, gap_prev = filled_prev, filled, gap_prev, gap\\n        return filled_prev % 1_000_000_007\\n```\\n\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(1)`, only constant extra space is used\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        return solve(0, n, false);\\n    }\\n    long solve(int i, int n, bool previousGap) {\\n        if(i > n) return 0;                 // previous tiling exceeded bounds of grid - return 0 denoting not a valid tiling\\n        if(i == n) return !previousGap;     // return 1 when there was no previous gap present\\n        if(previousGap)                     // previous column had gap remaining in it\\n            return (solve(i+1, n, false) + solve(i+1, n, true)) % MOD;\\n        return (solve(i+1, n, false) + solve(i+2, n, false) + 2l*solve(i+2, n, true)) % MOD;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int numTilings(int n, bool previousGap = false) {\\n        if(n < 0) return 0;\\n        if(n == 0) return !previousGap;\\n        if(previousGap)\\n            return (numTilings(n-1) + numTilings(n-1, true)) % MOD;\\n        return (numTilings(n-1) + numTilings(n-2) + 2l*numTilings(n-2, true)) % MOD;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        def solve(i, previous_gap):\\n            if i > n: return 0\\n            if i == n: return not previous_gap\\n            if previous_gap:\\n                return solve(i+1, False) + solve(i+1, True)\\n            return solve(i+1, False) + solve(i+2, False) + 2*solve(i+2, True)\\n        return solve(0, False) % 1_000_000_007\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n, previous_gap = False):\\n        if n < 0: return 0\\n        if n == 0: return not previous_gap\\n        if previous_gap:\\n            return (self.numTilings(n-1) + self.numTilings(n-1, True)) % 1_000_000_007\\n        return (self.numTilings(n-1) + self.numTilings(n-2) + 2*self.numTilings(n-2, True)) % 1_000_000_007\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int dp[1001][2]{};\\n    int numTilings(int n) {\\n        return solve(0, n, false);\\n    }\\n    long solve(int i, int n, bool previousGap) {\\n        if(i > n) return 0;\\n        if(i == n) return !previousGap;\\n        if(dp[i][previousGap]) return dp[i][previousGap];\\n        if(previousGap)\\n            return dp[i][previousGap] = (solve(i+1, n, false) + solve(i+1, n, true)) % MOD;\\n        return dp[i][previousGap] = (solve(i+1, n, false) + solve(i+2, n, false) + 2*solve(i+2, n, true)) % MOD;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int dp[1001][2]{};\\n    int numTilings(int n, bool previousGap = false) {\\n        if(n < 0) return 0;\\n        if(n == 0) return !previousGap;\\n        if(dp[n][previousGap]) return dp[n][previousGap];\\n        if(previousGap)\\n            return dp[n][previousGap] = (numTilings(n-1) + numTilings(n-1, true)) % MOD;\\n        return dp[n][previousGap] = (numTilings(n-1) + numTilings(n-2) + 2l*numTilings(n-2, true)) % MOD;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        @cache\\n        def solve(i, previous_gap):\\n            if i > n: return 0\\n            if i == n: return not previous_gap\\n            if previous_gap:\\n                return solve(i+1, False) + solve(i+1, True)\\n            return solve(i+1, False) + solve(i+2, False) + 2*solve(i+2, True)\\n        return solve(0, False) % 1_000_000_007\\n```\n```python\\nclass Solution:\\n    @cache\\n    def numTilings(self, n, previous_gap = False):\\n        if n < 0: return 0\\n        if n == 0: return not previous_gap\\n        if previous_gap:\\n            return (self.numTilings(n-1) + self.numTilings(n-1, True)) % 1_000_000_007\\n        return (self.numTilings(n-1) + self.numTilings(n-2) + 2*self.numTilings(n-2, True)) % 1_000_000_007\\n```\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(2));\\n        dp[1] = {1, 1}, dp[2] = {2, 2};                 // base cases\\n        for(int i = 3; i <= n; i++) {\\n            dp[i][0] = (dp[i-1][0] + dp[i-2][0] + 2l*dp[i-2][1]) % MOD;\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][1]) % MOD;\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(n+2)]\\n        dp[1], dp[2] = [1, 1], [2, 2]\\n        for i in range(3, n+1):\\n            dp[i][0] = dp[i-1][0] + dp[i-2][0] + 2*dp[i-2][1]\\n            dp[i][1] = dp[i-1][0] + dp[i-1][1]\\n        return dp[n][0] % 1_000_000_007\\n```\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(2));\\n        dp[1] = {1, 1}, dp[2] = {2, 1};                 // base cases\\n        for(int i = 3; i <= n; i++) {\\n            dp[i][0] = (dp[i-1][0] + dp[i-2][0] + 2l*dp[i-1][1]) % MOD;\\n            dp[i][1] = (dp[i-2][0] + dp[i-1][1]) % MOD;\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(n+2)]\\n        dp[1], dp[2] = [1, 1], [2, 1]\\n        for i in range(3, n+1):\\n            dp[i][0] = dp[i-1][0] + dp[i-2][0] + 2*dp[i-1][1]\\n            dp[i][1] = dp[i-2][0] + dp[i-1][1]\\n        return dp[n][0] % 1_000_000_007\\n```\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(3, vector<int>(2));  // note only 3 rows are declared\\n        dp[1] = {1, 1}, dp[2] = {2, 2};\\n        for(int i = 3; i <= n; i++) {\\n            dp[i%3][0] = (dp[(i-1)%3][0] + dp[(i-2)%3][0] + 2l*dp[(i-2)%3][1]) % MOD;\\n            dp[i%3][1] = (dp[(i-1)%3][0] + dp[(i-1)%3][1]) % MOD;\\n        }\\n        return dp[n%3][0];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        if(n <= 2) return n;\\n\\t\\t// filled_prev = dp[i-1][0], filled_prev2 = dp[i-2][0]...same for gap_prev & gap_prev2\\n        int filled_prev = 2, gap_prev = 2, filled_prev2 = 1, gap_prev2 = 1;\\n        for(int i = 3; i <= n; i++) {\\n            int filled = (filled_prev + filled_prev2 + 2l*gap_prev2) % MOD;\\n            int gap = (filled_prev + gap_prev) % MOD;\\n            \\n            filled_prev2 = filled_prev, filled_prev = filled;\\n            gap_prev2 = gap_prev, gap_prev = gap;\\n        }\\n        return filled_prev;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(3)]\\n        dp[1], dp[2] = [1, 1], [2, 2]\\n        for i in range(3, n+1):\\n            dp[i%3][0] = dp[(i-1)%3][0] + dp[(i-2)%3][0] + 2*dp[(i-2)%3][1]\\n            dp[i%3][1] = dp[(i-1)%3][0] + dp[(i-1)%3][1]\\n        return dp[n%3][0] % 1_000_000_007\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        if n <= 2: return n\\n        filled_prev, gap_prev, filled_prev2, gap_prev2 = 2,2,1,1\\n        for i in range(3, n+1):\\n            filled = filled_prev + filled_prev2 + 2*gap_prev2\\n            gap = filled_prev + gap_prev\\n            \\n            filled_prev2, filled_prev, gap_prev2, gap_prev = filled_prev, filled, gap_prev, gap\\n        return filled_prev % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116612,
                "title": "easy-to-understand-o-n-solution-with-drawing-picture-explanation",
                "content": "The way to solve is too simple ,it's easy to understand by see the pictrue drawing here:\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yuweiming70/image_1519549786.png)\n\nso the code can be write as this:\n\n```\n    int numTilings(int N) \n    {\n        long long g[1001],u[1001];\n        int mod=1000000007;\n        g[0]=0; g[1]=1; g[2]=2;\n        u[0]=0; u[1]=1; u[2]=2;\n        \n        for(int i=3;i<=N;i++)\n        {\n            u[i] = (u[i-1] + g[i-1]           )   %mod;\n            g[i] = (g[i-1] + g[i-2] + 2*u[i-2])   %mod;\n        }\n        return g[N]%mod;\n    }\n```",
                "solutionTags": [],
                "code": "```\n    int numTilings(int N) \n    {\n        long long g[1001],u[1001];\n        int mod=1000000007;\n        g[0]=0; g[1]=1; g[2]=2;\n        u[0]=0; u[1]=1; u[2]=2;\n        \n        for(int i=3;i<=N;i++)\n        {\n            u[i] = (u[i-1] + g[i-1]           )   %mod;\n            g[i] = (g[i-1] + g[i-2] + 2*u[i-2])   %mod;\n        }\n        return g[N]%mod;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620809,
                "title": "python-java-c-c-dp-image-visualized-explanation-100-faster-o-n",
                "content": "* dp[i] denotes the number of ways to tile an 2 * (i + 1) board, note that dp is 0-indexed.\\n\\t* Intuitively, dp[0] = 1 and dp[1] = 2\\n* dpa[i] denotes the number of ways to tile an 2 * i board and 1 more square left below(or above symmetrically).\\n\\t* Intuitively, dpa[0] = 0 and dpa[1] = 1\\n\\t* I just explained the case where in i-th column, 2nd row is filled. But it should be noted that the two cases(the other is in i-th column, 1st row is filled) are symmetric and the numbers are both dpa[i], you may imagine dpb[i] = dpa[i] for the second case where i-th column 1st row is filled.\\n![image](https://assets.leetcode.com/users/images/875bd993-2f8d-44f5-95eb-c113e8983cc8_1639109494.0658832.jpeg)\\n![image](https://assets.leetcode.com/users/images/de639bbf-995e-48da-96ee-47bc830cd220_1639109512.768774.jpeg)\\n\\nFurther More!\\n![image](https://assets.leetcode.com/users/images/45740626-fc9e-4cc5-be36-6553da40efaa_1639117939.3698611.jpeg)\\n\\n\\n\\n**If you hava any question, feel free to ask. If you like the solution or the explaination, Please UPVOTE!**\\n\\n**Python/Python3**\\n```\\nclass Solution(object):\\n    def numTilings(self, n):\\n        dp = [1, 2, 5] + [0] * n\\n        for i in range(3, n):\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\\n        return dp[n - 1]\\n```\\n```\\nclass Solution(object):\\n    def numTilings(self, n):\\n        dp, dpa = [1, 2] + [0] * n, [1] * n\\n        for i in range(2, n):\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007\\n        return dp[n - 1]\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for (int i = 3; i < n; i ++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 2]; dp[0] = 1; dp[1] = 2;\\n        long[] dpa = new long[n + 2]; dpa[1] = 1;\\n        for (int i = 2; i < n; i ++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\\n**C/C++**\\n```\\nint numTilings(int n) {\\n    unsigned int dp[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n    for (int i = 3; i < n; i ++) {\\n        dp[i] = (2 * dp[i - 1] + dp[i - 3]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```\\n```\\nint numTilings(int n){\\n    if (n == 1) return 1;\\n    unsigned int dp[n]; dp[0] = 1; dp[1] = 2;\\n    unsigned int dpa[n]; dpa[1] = 1;\\n    for (int i = 2; i < n; i ++) {\\n        dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n        dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```\\n\\n**Please UPVOTE!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTilings(self, n):\\n        dp = [1, 2, 5] + [0] * n\\n        for i in range(3, n):\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\\n        return dp[n - 1]\\n```\n```\\nclass Solution(object):\\n    def numTilings(self, n):\\n        dp, dpa = [1, 2] + [0] * n, [1] * n\\n        for i in range(2, n):\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007\\n        return dp[n - 1]\\n```\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for (int i = 3; i < n; i ++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 2]; dp[0] = 1; dp[1] = 2;\\n        long[] dpa = new long[n + 2]; dpa[1] = 1;\\n        for (int i = 2; i < n; i ++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\n```\\nint numTilings(int n) {\\n    unsigned int dp[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n    for (int i = 3; i < n; i ++) {\\n        dp[i] = (2 * dp[i - 1] + dp[i - 3]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```\n```\\nint numTilings(int n){\\n    if (n == 1) return 1;\\n    unsigned int dp[n]; dp[0] = 1; dp[1] = 2;\\n    unsigned int dpa[n]; dpa[1] = 1;\\n    for (int i = 2; i < n; i ++) {\\n        dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n        dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600275,
                "title": "java-dp-diagrams-explanation",
                "content": "### Detailed Explanation:\\n\\n![image](https://assets.leetcode.com/users/images/c1a13d98-45d2-45d5-8ade-515576f004c6_1638081170.1326487.jpeg)\\n![image](https://assets.leetcode.com/users/images/720c22aa-077f-4078-a5b5-fa925077c40a_1638081179.2062912.jpeg)\\n![image](https://assets.leetcode.com/users/images/27ffdec8-22a6-48d2-8435-84de9cdc2303_1638081187.4332094.jpeg)\\n\\n\\n<br/>\\n\\n### Code:\\n\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n <= 2)\\n            return n;\\n        \\n        int mod = 1_000_000_007;\\n        long[] fullTiling = new long[n+1];\\n        long[] partTiling = new long[n+1];\\n        \\n        // One tile vertical can fill a pair of cells (or 1 column)\\n        fullTiling[1] = 1;\\n        // 2 vertical and 2 horizontals can fill up 2 pair of cells (or 2 columns)\\n        fullTiling[2] = 2; \\n        \\n        // Cannot fill one cell (in a column) with either domino or tromino\\n        partTiling[1] = 0; \\n        // If 1 cell out of 4 (2 pair of cells) is already filled then a tromino can fill the remaining 3 cells\\n        partTiling[2] = 1; \\n        \\n        for(int i=3; i <= n; i++){\\n            fullTiling[i] = (fullTiling[i-1] + fullTiling[i-2] + 2 * partTiling[i-1]) % mod;\\n            partTiling[i] = (partTiling[i-1] + fullTiling[i-2]) % mod;\\n        }        \\n        return (int)(fullTiling[n]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n <= 2)\\n            return n;\\n        \\n        int mod = 1_000_000_007;\\n        long[] fullTiling = new long[n+1];\\n        long[] partTiling = new long[n+1];\\n        \\n        // One tile vertical can fill a pair of cells (or 1 column)\\n        fullTiling[1] = 1;\\n        // 2 vertical and 2 horizontals can fill up 2 pair of cells (or 2 columns)\\n        fullTiling[2] = 2; \\n        \\n        // Cannot fill one cell (in a column) with either domino or tromino\\n        partTiling[1] = 0; \\n        // If 1 cell out of 4 (2 pair of cells) is already filled then a tromino can fill the remaining 3 cells\\n        partTiling[2] = 1; \\n        \\n        for(int i=3; i <= n; i++){\\n            fullTiling[i] = (fullTiling[i-1] + fullTiling[i-2] + 2 * partTiling[i-1]) % mod;\\n            partTiling[i] = (partTiling[i-1] + fullTiling[i-2]) % mod;\\n        }        \\n        return (int)(fullTiling[n]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620735,
                "title": "java-dp-detailed-explanation-using-image",
                "content": "**Intution and Explanation:**\\n![image](https://assets.leetcode.com/users/images/67d814a1-a8ef-49be-baea-4edffbd0cdd2_1639143595.6763859.jpeg)\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(n)\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        int dp[] = new int[n+4];\\n        \\n        int mod = (int)(Math.pow(10,9)+7);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        \\n        for(int i=4;i<=n;i++){\\n            dp[i] = ((2*dp[i-1])%mod)+dp[i-3];\\n            dp[i] %= mod;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n\\nThanks for reading it...I hope I was able to explain clearly!!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        int dp[] = new int[n+4];\\n        \\n        int mod = (int)(Math.pow(10,9)+7);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        \\n        for(int i=4;i<=n;i++){\\n            dp[i] = ((2*dp[i-1])%mod)+dp[i-3];\\n            dp[i] %= mod;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620641,
                "title": "c-simple-and-short-solution-with-detailed-explanation",
                "content": "**Idea:**\\nIn any iteration, our empty slots in the board can look in two ways:\\nEither it\\'s a full rectangle or it\\'s a rectangle with one more square sticking out.\\n\\nWe define two functions:\\nD[i] = The number of ways to fill a full rectangle in the size of i * 2.\\nT[i] = The number of ways to fill a rectangle of size i * 2 + one square sticking out.\\n\\n**D[i]:**\\nWe have a rectangle.\\nWe have 3 options:\\n1. put one domino vertically on the side, leaving us with a full rectangle of size i-1 - `D[i-1]`.\\n2. put two dominoes on the side, leaving us with a full rectangle of size i-2 - `D[i-2]`.\\n3. Put a tromino on the side - leaving us with a rectangle of size i-2 plus another sticking out square - `T[i-2]`.\\nThere are two directions to put the tromino, so we have `2 * T[i-2]`.\\n\\nConclusion - **D[i] = D[i-1] + D[1-2] + 2 * T[i-2]**.\\n\\n**T[i]:**\\nWe have a rectangle with a square sticking out, it doesn\\'t matter if on the top row or bottom.\\nWe have two options:\\n1. Put a domino horizontally in the sticking out square, leaving us again with a sticking out square on the other row - `T[i-1]`.\\n2. Put a tromino completing the extra square, leaving us with a full rectangle - `D[i-1]`.\\n\\nConclusion - **T[i] = T[i-1] + D[i-1]**.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if (n < 3) return n;\\n        \\n        int mod = pow(10, 9) + 7;\\n        vector<long> D(n+1, 0), T(n+1, 0);\\n        D[0] = 0, D[1] = 1, D[2] = 2;\\n        T[0] = 0, T[1] = 1, T[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++) {\\n            D[i] = (D[i-1] + D[i-2] + 2*T[i-2]) % mod;\\n            T[i] = (T[i-1] + D[i-1]) % mod;\\n        }\\n        \\n        return D[n];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if (n < 3) return n;\\n        \\n        int mod = pow(10, 9) + 7;\\n        vector<long> D(n+1, 0), T(n+1, 0);\\n        D[0] = 0, D[1] = 1, D[2] = 2;\\n        T[0] = 0, T[1] = 1, T[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++) {\\n            D[i] = (D[i-1] + D[i-2] + 2*T[i-2]) % mod;\\n            T[i] = (T[i-1] + D[i-1]) % mod;\\n        }\\n        \\n        return D[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116506,
                "title": "python-recursive-dp-solution-with-cache-w-explanation",
                "content": "The idea is to have two functions numTilingsD that handles the number of ways of filling using Domio and numTilingsT that handles number of ways of filling using Tromino.\nAs this is a DP with recursive solution we have 2 caches cacheD and cacheT to store the corresponding solutions.\n\nIf you open the images below in a new tab, they are a bit more readable.\n\n[Also, kindly refer to @vegito2002@gmail.com's diagram, in this thread, for a more clear picutre]\n\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/johnyrufus16/image_1519552844.png)\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/johnyrufus16/image_1519552870.png)\n\n\n\n\n\n\n```\ndef numTilings(self, N):\n    def numTilingsD(N):\n        if N in cacheD: return cacheD[N]\n        if N <= 2: return N if N > 0 else 1 \n        cacheD[N] = (numTilingsD(N - 2) + numTilingsD(N - 1) + (2 * numTilingsT(N - 1))) % ((10**9) + 7)\n        return cacheD[N]\n\n    def numTilingsT(N):\n        if N in cacheT: return cacheT[N]\n        if N <= 2: return 0 if N == 1 else 1\n        cacheT[N] = (numTilingsD(N - 2) + numTilingsT(N - 1)) % ((10**9) + 7)\n        return cacheT[N]\n    cacheD, cacheT = {}, {}\n    return numTilingsD(N)\n```",
                "solutionTags": [],
                "code": "```\ndef numTilings(self, N):\n    def numTilingsD(N):\n        if N in cacheD: return cacheD[N]\n        if N <= 2: return N if N > 0 else 1 \n        cacheD[N] = (numTilingsD(N - 2) + numTilingsD(N - 1) + (2 * numTilingsT(N - 1))) % ((10**9) + 7)\n        return cacheD[N]\n\n    def numTilingsT(N):\n        if N in cacheT: return cacheT[N]\n        if N <= 2: return 0 if N == 1 else 1\n        cacheT[N] = (numTilingsD(N - 2) + numTilingsT(N - 1)) % ((10**9) + 7)\n        return cacheT[N]\n    cacheD, cacheT = {}, {}\n    return numTilingsD(N)\n```",
                "codeTag": "Python3"
            },
            {
                "id": 116544,
                "title": "c-java-python-o-n-time-and-o-1-space",
                "content": "The answer will be a recursive sequence as follow: ```1, 1, 2, 5, 11, 24, 53, 117, 258, 569, 1255```\\nIt grows at a speed about 2 times bigger each time.\\nIf you write down this recursive sequence and do some calculations, you may find that: \\n\\n```5 = 2 * 2 + 1```\\n```11 = 5 * 2 + 1```\\n```24 = 11 * 2 + 2```\\n```53 = 24 * 2 + 5```\\n```117 = 53 * 2 + 11```\\n```A[N] = A[N-1] * 2 + A[N-3]```\\n\\nOnce you notice it, the rest work will be easy, even it may be hard to prove it.\\n\\nC++:\\n```\\n    int numTilings(int N) {\\n        int a = 0, b = 1, c = 1, c2, mod = 1e9 + 7;\\n        while (--N) {\\n            c2 = (c * 2 % mod + a) % mod;\\n            a = b;\\n            b = c;\\n            c = c2;\\n        }\\n        return c;\\n    }\\n```\\n\\nJava:\\n```\\n   public int numTilings(int N) {\\n        int a = 0, b = 1, c = 1, c2, mod = 1000000007;\\n        while (--N > 0) {\\n            c2 = (c * 2 % mod + a) % mod;\\n            a = b;\\n            b = c;\\n            c = c2;\\n        }\\n        return c;\\n    }\\n```\\n\\nPython:\\n```\\n    def numTilings(self, N):\\n        a, b, c = 0, 1, 1\\n        for i in range(N - 1): a, b, c = b, c, (c + c + a) % int(1e9 + 7)\\n        return c\\n````\\n\\nUpdated:\\nMy original DP solution:\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/discuss/116534\\n",
                "solutionTags": [],
                "code": "```1, 1, 2, 5, 11, 24, 53, 117, 258, 569, 1255```\n```5 = 2 * 2 + 1```\n```11 = 5 * 2 + 1```\n```24 = 11 * 2 + 2```\n```53 = 24 * 2 + 5```\n```117 = 53 * 2 + 11```\n```A[N] = A[N-1] * 2 + A[N-3]```\n```\\n    int numTilings(int N) {\\n        int a = 0, b = 1, c = 1, c2, mod = 1e9 + 7;\\n        while (--N) {\\n            c2 = (c * 2 % mod + a) % mod;\\n            a = b;\\n            b = c;\\n            c = c2;\\n        }\\n        return c;\\n    }\\n```\n```\\n   public int numTilings(int N) {\\n        int a = 0, b = 1, c = 1, c2, mod = 1000000007;\\n        while (--N > 0) {\\n            c2 = (c * 2 % mod + a) % mod;\\n            a = b;\\n            b = c;\\n            c = c2;\\n        }\\n        return c;\\n    }\\n```\n```\\n    def numTilings(self, N):\\n        a, b, c = 0, 1, 1\\n        for i in range(N - 1): a, b, c = b, c, (c + c + a) % int(1e9 + 7)\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 931254,
                "title": "recursively-solve-sub-problems-with-pictures-no-confusing-dp-math-formulas-o-n",
                "content": "**Imagine we are looking at the `i`th column, all previous columns have been fully tiled.**\\n\\n**There are three possible states at the ith column**\\n\\n**1. BOTH TOP AND BOTTOM CELLS ARE EMPTY**\\n\\n![image](https://assets.leetcode.com/users/images/d71ff7e3-b01a-4466-aa30-dcd6c9bef79c_1605052246.083369.png)\\n\\n**2. ONLY THE BOTTOM CELL IS EMPTY** (green block = used cell)\\n\\n![image](https://assets.leetcode.com/users/images/01adb44e-a3fa-4735-b0f0-ac763547896d_1605052289.985583.png)\\n\\n**3. ONLY THE TOP CELL IS EMPTY** (green block = used cell)\\n\\n![image](https://assets.leetcode.com/users/images/c09c7572-961f-4483-9504-d1ed7bdeb911_1605052313.539652.png)\\n\\n**WHEN BOTH CELLS EMPTY (STATE 1)**\\n\\n**At the current column, we can use**\\n\\n- One vertical domino\\n\\t- **after using it at `i`th column, we need to calculate `i + 1`th column at state 1** (at `i + 1` both cells are still empty)\\n- OR two horizontal dominos\\n\\t- **then we calculate `i + 2`th at state 1** (each horizontal domino takes two columns, at `i + 2` both cells are empty)\\n- OR a L tromino\\n\\t- **then calculate `i+1` at state 3 above** after using it, at `i + 1` the bottom cell will be used.\\n- OR a flipped L tromino\\n\\t- **then calculate `i+1` at state 2 above** after using it, at `i + 1` the top cell will be used.\\n\\n**For state 1, the total number of ways is the sum of all four posibilities**\\n\\n![image](https://assets.leetcode.com/users/images/aa2b11c4-7ca8-4a00-9e31-b04ab949dcd6_1605052038.9683368.png)\\n\\n**WHEN BOTTOM CELL EMPTY (STATE 2)**\\n\\n**we can use**\\n\\n- one horizontal tile at the bottom\\n\\t- **after using it, we need to calculate `i+1` at state 3**, bottom cell of `i+1` is used\\n- one horizontally flipped L tromino\\n\\t- **after using it, we need to calculate `i+2` at state 1**, both top and bottom cells at `i+2` are empty, L tromino takes two columns, hence `i + 2`\\n\\n**Total number of ways is the sum of both possibilities**\\n\\n![image](https://assets.leetcode.com/users/images/33acc706-5062-411c-8277-552770f1be1b_1605052136.7791326.png)\\n\\n**WHEN TOP CELL EMPTY (STATE 3)**\\n\\n**we can use**\\n\\n- one horizontal tile at the top\\n\\t- **after using it, we need to calculate `i+1` at state 2**, top cell of `i+1` is used\\n- one flipped L tromino\\n\\t- **after using it, we need to calculate `i+2` at state 1**, both top and bottom cells at `i+2` are empty, L tromino takes two columns, hence `i + 2`\\n\\n**Total number of ways is the sum of both possibilities**\\n\\n![image](https://assets.leetcode.com/users/images/93b1a388-ca1f-441b-aa74-d73a9d439c69_1605052179.572588.png)\\n\\n**We just need to recursively solve the same problem at each index.**\\n\\n**Implementation**\\n```javascript\\nfunction rc (n, index = 0, state = \\'topBottomFree\\') {\\n    if (index >= n) return state === \\'topBottomFree\\' && index === n ? 1 : 0;\\n    switch (state) {\\n        case \\'topBottomFree\\':\\n            const useVerticalDomino = rc(n, index + 1, \\'topBottomFree\\');\\n            const useTwoHorizontalDomino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useTopTromino = rc(n, index + 1, \\'bottomFree\\');\\n            const useBottomTromino = rc(n, index + 1, \\'topFree\\');\\n            return useVerticalDomino + useTwoHorizontalDomino + useTopTromino + useBottomTromino;\\n        case \\'bottomFree\\':\\n            const useHorizontallyFlippedBottomTromino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useHorizontalDominoAtBottom = rc(n, index + 1, \\'topFree\\');\\n            return useHorizontallyFlippedBottomTromino + useHorizontalDominoAtBottom;\\n        case \\'topFree\\':\\n            const useHorizontallyFlippedTopTromino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useHorizontalDominoAtTop = rc(n, index + 1, \\'bottomFree\\');\\n            return useHorizontallyFlippedTopTromino + useHorizontalDominoAtTop;\\n    }\\n}\\n```\\n\\n**Add memoisation, there are only 3 states at each index, complexity O(3n)**\\n```javascript\\nfunction rc2 (n, index = 0, state = 0, memo = {}) {\\n    if (index >= n) return state === 0 && index === n ? 1 : 0;\\n    \\n    const memoKey = `${index},${state}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey];\\n    \\n    switch (state) {\\n        case 0:\\n            return memo[memoKey] = (rc2(n, index + 1, 0, memo) + rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 1, memo) + rc2(n, index + 1, 2, memo)) % 1000000007;\\n        case 1:\\n            return memo[memoKey] = (rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 2, memo)) % 1000000007;\\n        case 2:\\n            return memo[memoKey] = (rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 1, memo)) % 1000000007;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```javascript\\nfunction rc (n, index = 0, state = \\'topBottomFree\\') {\\n    if (index >= n) return state === \\'topBottomFree\\' && index === n ? 1 : 0;\\n    switch (state) {\\n        case \\'topBottomFree\\':\\n            const useVerticalDomino = rc(n, index + 1, \\'topBottomFree\\');\\n            const useTwoHorizontalDomino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useTopTromino = rc(n, index + 1, \\'bottomFree\\');\\n            const useBottomTromino = rc(n, index + 1, \\'topFree\\');\\n            return useVerticalDomino + useTwoHorizontalDomino + useTopTromino + useBottomTromino;\\n        case \\'bottomFree\\':\\n            const useHorizontallyFlippedBottomTromino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useHorizontalDominoAtBottom = rc(n, index + 1, \\'topFree\\');\\n            return useHorizontallyFlippedBottomTromino + useHorizontalDominoAtBottom;\\n        case \\'topFree\\':\\n            const useHorizontallyFlippedTopTromino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useHorizontalDominoAtTop = rc(n, index + 1, \\'bottomFree\\');\\n            return useHorizontallyFlippedTopTromino + useHorizontalDominoAtTop;\\n    }\\n}\\n```\n```javascript\\nfunction rc2 (n, index = 0, state = 0, memo = {}) {\\n    if (index >= n) return state === 0 && index === n ? 1 : 0;\\n    \\n    const memoKey = `${index},${state}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey];\\n    \\n    switch (state) {\\n        case 0:\\n            return memo[memoKey] = (rc2(n, index + 1, 0, memo) + rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 1, memo) + rc2(n, index + 1, 2, memo)) % 1000000007;\\n        case 1:\\n            return memo[memoKey] = (rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 2, memo)) % 1000000007;\\n        case 2:\\n            return memo[memoKey] = (rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 1, memo)) % 1000000007;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620764,
                "title": "c-easy-to-solve-visualized-image-and-explanations-beginner-friendly",
                "content": "# **Dynamic Thinking Approach**\\n\\n**Intuition:**\\nAfter reading the question we get a intuition of doing recursion and dp .Now those of you who got intuition as recursion you are not wrong but your code will be one of the most unoptimized code. So let\\'s discuss when to use a dp ,If the two case are confirmed in a problem then you can use dp\\n1. If it has overlapping sub problems \\n2. If optimizing the sub problems wll optimize the whole question\\nBoth the above the condition are satisfied in this question. So now let\\'s discuss the approach :)\\n\\n**Algorithm:**\\n1. Wheneve we put a domino or tromino we are either left out with a whole rectangle or with a rectangle + left alone square  [lonely doge]\\n2. So to fill out the whole rectangle the number of ways can be `i*2 `and to fill a lonely doge the number of ways is to fill a rectangle of size `i*2 + one square sticking out.`\\n3. Whenever we use a domino tile we are either left with a full rectangle of size i-1 or  with a full rectangle of size i-2 . This leads to formulation of domino that is *`Domino[i] = Domino[i-1] + Domino[1-2]`*\\n4. Now let\\'s think we put out a tromino first then we are left with lonely doge .so the size of that lonely doge is i-2 . Also tromino is non symmetric in shape so it has two orientaions which leads to 2(i-2).\\nThis makes our end conclusion for domino` Domino=Domino[i] = Domino[i-1] + Domino[1-2] + 2 * Tromino[i-2]`\\n5. Let\\'s continue with tromino i.e whenever we use it we are left alone with a lonely doge so to fill that we got two options\\n* put a domino leaving us all again with a left alone square again .This gives Tromino[i-1]\\n* The second option is put tromino aligning with lonely doge and completing them as a whole rectangle. A happy endng we all want .Btw this gives Domino[i-1]\\n\\n6.Thus to conclude this ,the formula will be `Tromino[i]=Tromino[i-1]+Domino[i-1]`\\n7.And now again ... ok you thought something is remaining, lol the problem is solved .KABOOM\\n\\n**Before starting with code let\\'s take a dry run[You can skip if you are confident :) ]**\\n![image](https://assets.leetcode.com/users/images/75039a8f-b7ac-404a-b753-3cd8e1160b03_1639105851.6693509.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/6ffd3b67-3a83-423d-97e0-0b3f3fa5d346_1639105853.825289.jpeg)\\nI have wrote torino instead of tromino in the above image so pardon me :(\\n\\n\\n**Code :-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        //base case-1\\n        if (n < 3) return n;\\n        //given in the question that answer may be long\\n        int modulo = pow(10, 9) + 7;  \\n        \\n        vector<long> Domino(n+1, 0), Tromino(n+1, 0);\\n        //base case-2\\n        Domino[0] = 0,Domino[1] = 1, Domino[2] = 2;\\n        Tromino[0] = 0, Tromino[1] = 1, Tromino[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++) {\\n            Domino[i] = (Domino[i-1] + Domino[i-2] + 2*Tromino[i-2]) % modulo;\\n            Tromino[i] = (Tromino[i-1] + Domino[i-1]) % modulo;\\n        }\\n        \\n        return Domino[n];\\n    }\\n};\\n```\\n\\n\\n**If you have suggestions or doubts feel free to comment ;)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        //base case-1\\n        if (n < 3) return n;\\n        //given in the question that answer may be long\\n        int modulo = pow(10, 9) + 7;  \\n        \\n        vector<long> Domino(n+1, 0), Tromino(n+1, 0);\\n        //base case-2\\n        Domino[0] = 0,Domino[1] = 1, Domino[2] = 2;\\n        Tromino[0] = 0, Tromino[1] = 1, Tromino[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++) {\\n            Domino[i] = (Domino[i-1] + Domino[i-2] + 2*Tromino[i-2]) % modulo;\\n            Tromino[i] = (Tromino[i-1] + Domino[i-1]) % modulo;\\n        }\\n        \\n        return Domino[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944366,
                "title": "simple-java-solution-with-dynamic-programming-in-o-n-100-beats",
                "content": "\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==1)\\n        return 1;\\n        else if(n==2)\\n        return 2;\\n      int mod = 1000000007;\\n\\n    int [] dp=new int[n+1];\\n\\n    dp[1]=1;\\n    dp[2]=2;\\n    dp[3]=5;\\n    for(int i =4;i<=n;i++){\\n        dp[i]=(2*dp[i-1]%mod+dp[i-3]%mod)%mod;\\n    }\\n    return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==1)\\n        return 1;\\n        else if(n==2)\\n        return 2;\\n      int mod = 1000000007;\\n\\n    int [] dp=new int[n+1];\\n\\n    dp[1]=1;\\n    dp[2]=2;\\n    dp[3]=5;\\n    for(int i =4;i<=n;i++){\\n        dp[i]=(2*dp[i-1]%mod+dp[i-3]%mod)%mod;\\n    }\\n    return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944113,
                "title": "27ms-98-89-13-8mb-99-21-python-explained",
                "content": "# Intuition\\nFirst look at the numbers really good and long.\\nSearch patterns and the according offsets to reach our values...\\nLike sum, fibonacci etc.\\n|i | n | sum|off| \\n|--|--:|--:|-:|\\n1|1|1|+1\\n2|2|3|+2\\n3|5|8|+3\\n4|11|19|+5\\n5|24|43|+10\\n6|53|96|+21\\n7|117|213|+45\\n8|258|471|+98\\n9|569|1040|+215\\n10|1255|\\n\\nFirst this rather looks like powers of 2.\\nBut there are offsets growing irrationally like sums.\\n|n | 2^(i-1) | off|\\n|--|-:|-:|\\n1|1|+0\\n2|2|+0\\n5|4|+1\\n11|8|+3\\n24|16|+8\\n53|32|+21\\n117|64|+53\\n258|128|+130\\n\\nThen it looks like nextN=2*lastN.\\n|n | 2*(n-1) | off|\\n|--|-:|-:|\\n1   |2*0   |(+1)\\n2   |2*1   |(+0)\\n5   |2*2   |(+1)\\n11  |2*5   |(+1)\\n24  |2*11  |(+2)\\n53  |2*24   |+5\\n117 |2*53  |+11\\n258 |2*117 |+24\\n569 |2*258 |+53\\n1255|2*569|+117\\n\\nThis offsets looks really similar!\\n# Approach\\ndefaultcases for 1,2,3,4,5.\\nthen use this vars: a=5 b=11 c=24\\nand for each i up to n:\\n(a,b,c)->(b,c,a+c+c)\\na\\'=b \\nb\\'=c \\nc\\'=a+2c\\n\\nE.g. first defaults:\\n1\\n2\\n5\\n11\\n24\\nThen these jumps from 5,11,24:\\n|a|b|c|\\n|-|-|-|\\n11|24|**53**\\n24|53|**117**\\n53|117|**258**\\n117|258|**569**\\n258|569|**1255**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1: return 1\\n        if n == 2: return 2\\n        if n == 3: return 5\\n        if n == 4: return 11\\n        if n == 5: return 24\\n        a,b,c = 5,11,24 #[a,b,c] => [b,c,a+c+c] => [b,c]+[2*c+a]\\n        for i in range(6,n+1):\\n            a,b,c = b,c,2*c+a\\n        return c % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1: return 1\\n        if n == 2: return 2\\n        if n == 3: return 5\\n        if n == 4: return 11\\n        if n == 5: return 24\\n        a,b,c = 5,11,24 #[a,b,c] => [b,c,a+c+c] => [b,c]+[2*c+a]\\n        for i in range(6,n+1):\\n            a,b,c = b,c,2*c+a\\n        return c % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116534,
                "title": "python-easy-and-concise-solution",
                "content": "3 simple steps to solve this problem:\\n1. Decide use dynamic programming.\\n2. Find dp equation.\\n3. Find initilization.\\n\\n```A[i]``` the number of tiling a ```2*N-1``` board, ```B[i]``` the number of tiling a ```2*N``` board.\\nWe can find this regular as .\\n```\\nA[i] = B[i - 2] + A[i - 1]\\nB[i] = B[i - 1] + B[i - 2] + A[i - 1] * 2\\n```\\nI also initialize ```B[0] = B[1] = 1, A[0] = A[1] = 0```\\n\\nPython:\\n```\\ndef numTilings(self, N):\\n        A = [0] * (N + 1)\\n        B = [1, 1] + [0] * (N - 1)\\n        for i in range(2, N + 1):\\n            A[i] = (B[i - 2] + A[i - 1]) % int(1e9 + 7)\\n            B[i] = (B[i - 1] + B[i - 2] + A[i - 1] * 2) % int(1e9 + 7)\\n        return B[N]\\n```\\n\\nResult:\\n```\\nN =  0   1   2   3   4   5   6    7    8    9    10 ...\\nA = [0,  0,  1,  2,  4,  9, 20,  44,  97, 214,  472 ...\\nB = [1,  1,  2,  5, 11, 24, 53, 117, 258, 569, 1255 ...\\n```\\nThis is in fact a double recursive sequence.\\nThe code will be much simpler if you find out the regular for single recursive sequence.\\nFind here: https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116544/O(N)-time-and-O(1)-space-C++JavaPython",
                "solutionTags": [],
                "code": "```A[i]```\n```2*N-1```\n```B[i]```\n```2*N```\n```\\nA[i] = B[i - 2] + A[i - 1]\\nB[i] = B[i - 1] + B[i - 2] + A[i - 1] * 2\\n```\n```B[0] = B[1] = 1, A[0] = A[1] = 0```\n```\\ndef numTilings(self, N):\\n        A = [0] * (N + 1)\\n        B = [1, 1] + [0] * (N - 1)\\n        for i in range(2, N + 1):\\n            A[i] = (B[i - 2] + A[i - 1]) % int(1e9 + 7)\\n            B[i] = (B[i - 1] + B[i - 2] + A[i - 1] * 2) % int(1e9 + 7)\\n        return B[N]\\n```\n```\\nN =  0   1   2   3   4   5   6    7    8    9    10 ...\\nA = [0,  0,  1,  2,  4,  9, 20,  44,  97, 214,  472 ...\\nB = [1,  1,  2,  5, 11, 24, 53, 117, 258, 569, 1255 ...\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2944191,
                "title": "complete-explanation-with-images-easy-to-understand",
                "content": "#  Consider the following fix width configurations \\uD83D\\uDC47\\n![image](https://assets.leetcode.com/users/images/314ad41a-9604-403b-96ff-2ebafa73808a_1671853682.579165.jpeg)\\n//=======================================================================================================================\\n\\n\\n# FINAL SOLUTION \\uD83D\\uDC47 [FIX-WIDTH CONFIGURATIONS APPENDED WITH (WIDTH - FIXWIDTH) WAYS]\\n![image](https://assets.leetcode.com/users/images/c9df3c5b-53f1-4c43-acbe-335b597b41b1_1671853694.6105545.jpeg)\\n![image](https://assets.leetcode.com/users/images/b209acca-df4b-4704-851a-c7d7e2e95362_1671853700.8129582.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) \\n    {\\n        vector<long long>dp(n + 1);\\n        dp[1] = 1; dp[0] = 1;\\n        int MOD = 1000000007;\\n        for (int width = 2; width <= n; width++)\\n        {\\n            long long totalWays = 0;\\n            for (int fixWidth = 1; fixWidth <= width; fixWidth++)\\n            {\\n                int leftWidth = width - fixWidth;\\n                long long ways = dp[leftWidth]; \\n                if (fixWidth > 2) ways = (ways * 2) % MOD; //because from fixWidth > 2, two configurations exist for each case\\n                //fixWidthConfiguration appended to all dp[leftWidth] configurations\\n                \\n                totalWays = (totalWays + ways) % MOD;\\n            }\\n            dp[width] = totalWays;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) \\n    {\\n        vector<long long>dp(n + 1);\\n        dp[1] = 1; dp[0] = 1;\\n        int MOD = 1000000007;\\n        for (int width = 2; width <= n; width++)\\n        {\\n            long long totalWays = 0;\\n            for (int fixWidth = 1; fixWidth <= width; fixWidth++)\\n            {\\n                int leftWidth = width - fixWidth;\\n                long long ways = dp[leftWidth]; \\n                if (fixWidth > 2) ways = (ways * 2) % MOD; //because from fixWidth > 2, two configurations exist for each case\\n                //fixWidthConfiguration appended to all dp[leftWidth] configurations\\n                \\n                totalWays = (totalWays + ways) % MOD;\\n            }\\n            dp[width] = totalWays;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620750,
                "title": "c-recursive-memoization",
                "content": "```\\nclass Solution {\\n    private:\\n    int MOD = 1e9+7;\\n    private :\\n    int helper(int firstRow, int secondRow, vector<vector<int>> &dp)\\n    {\\n        if(firstRow == 0 && secondRow == 0) \\n            return 1;\\n        \\n        if(firstRow < 0 || secondRow < 0)\\n            return 0;\\n        \\n        if(dp[firstRow][secondRow] != -1) \\n            return dp[firstRow][secondRow];\\n        \\n        int res;\\n        \\n        // 4 cases\\n        // 1) one vertical Domino (1 dot at firstRow, 1 dot at secondRow)\\n        // 2) one horizontal Domino (either 2 dots at firstRow or 2 dots at secondRow, we have to consider both)\\n        // 3) Tromino (2 dots at firstRow & 1 dot at secondRow)\\n        // 4) Inverted Tromino (1 dot at firstRow & 2 dots at secondRow)\\n        if(firstRow == secondRow)\\n        {\\n                  // one vertical Domino\\n            res = ((((helper(firstRow-1, secondRow-1, dp) % MOD + \\n                    \\n                    // one horizontal Domino (consider both first and second row)\\n                    helper(firstRow-2, secondRow-2, dp) % MOD) % MOD + \\n                   \\n                    // Tromino\\n                    helper(firstRow-2, secondRow-1, dp) % MOD) % MOD +\\n                \\n                    // Inverted Tromino\\n                    helper(firstRow-1, secondRow-2, dp) % MOD) % MOD );\\n        }\\n        \\n        // If dots in firstRow > secondRow, then 2 cases (we have to reduce the dots)\\n        // 1) at firstRow, we have to add horizontal Domino (so it will reduce 2 dots)\\n        // 2) Add Tromino (so, it will reduce 2 dots at firstRow, 1 dots at secondRow)\\n        else if(firstRow > secondRow)\\n        {\\n                  // Add horizontal domino at firstRow\\n            res = ((helper(firstRow-2, secondRow, dp) % MOD + \\n                   \\n                    // Add Tromino\\n                    helper(firstRow-2, secondRow-1, dp) % MOD) % MOD);\\n        }\\n        \\n        // If dots in firstRow < secondRow, then 2 cases\\n        // 1) Add Inverted Tromino (so, it will reduce 1 dot at firstRow, 2 dots at secondRow)\\n        // 2) At secondRow, we have to add horizontal Domino (so it will reduce 2 dots)\\n        else if(firstRow < secondRow)\\n        {\\n                  // Add horizontal domino at secondRow\\n            res = ((helper(firstRow, secondRow-2, dp) % MOD + \\n                   \\n                    // Add Inverted Tromino\\n                    helper(firstRow-1, secondRow-2, dp) % MOD) % MOD);\\n        }\\n        \\n        return dp[firstRow][secondRow] = res;\\n    }\\n    \\npublic:\\n    int numTilings(int n) {\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        \\n        // first row, second row (because, we have 2xN board, so 2 rows, N column)\\n        return helper(n, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int MOD = 1e9+7;\\n    private :\\n    int helper(int firstRow, int secondRow, vector<vector<int>> &dp)\\n    {\\n        if(firstRow == 0 && secondRow == 0) \\n            return 1;\\n        \\n        if(firstRow < 0 || secondRow < 0)\\n            return 0;\\n        \\n        if(dp[firstRow][secondRow] != -1) \\n            return dp[firstRow][secondRow];\\n        \\n        int res;\\n        \\n        // 4 cases\\n        // 1) one vertical Domino (1 dot at firstRow, 1 dot at secondRow)\\n        // 2) one horizontal Domino (either 2 dots at firstRow or 2 dots at secondRow, we have to consider both)\\n        // 3) Tromino (2 dots at firstRow & 1 dot at secondRow)\\n        // 4) Inverted Tromino (1 dot at firstRow & 2 dots at secondRow)\\n        if(firstRow == secondRow)\\n        {\\n                  // one vertical Domino\\n            res = ((((helper(firstRow-1, secondRow-1, dp) % MOD + \\n                    \\n                    // one horizontal Domino (consider both first and second row)\\n                    helper(firstRow-2, secondRow-2, dp) % MOD) % MOD + \\n                   \\n                    // Tromino\\n                    helper(firstRow-2, secondRow-1, dp) % MOD) % MOD +\\n                \\n                    // Inverted Tromino\\n                    helper(firstRow-1, secondRow-2, dp) % MOD) % MOD );\\n        }\\n        \\n        // If dots in firstRow > secondRow, then 2 cases (we have to reduce the dots)\\n        // 1) at firstRow, we have to add horizontal Domino (so it will reduce 2 dots)\\n        // 2) Add Tromino (so, it will reduce 2 dots at firstRow, 1 dots at secondRow)\\n        else if(firstRow > secondRow)\\n        {\\n                  // Add horizontal domino at firstRow\\n            res = ((helper(firstRow-2, secondRow, dp) % MOD + \\n                   \\n                    // Add Tromino\\n                    helper(firstRow-2, secondRow-1, dp) % MOD) % MOD);\\n        }\\n        \\n        // If dots in firstRow < secondRow, then 2 cases\\n        // 1) Add Inverted Tromino (so, it will reduce 1 dot at firstRow, 2 dots at secondRow)\\n        // 2) At secondRow, we have to add horizontal Domino (so it will reduce 2 dots)\\n        else if(firstRow < secondRow)\\n        {\\n                  // Add horizontal domino at secondRow\\n            res = ((helper(firstRow, secondRow-2, dp) % MOD + \\n                   \\n                    // Add Inverted Tromino\\n                    helper(firstRow-1, secondRow-2, dp) % MOD) % MOD);\\n        }\\n        \\n        return dp[firstRow][secondRow] = res;\\n    }\\n    \\npublic:\\n    int numTilings(int n) {\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        \\n        // first row, second row (because, we have 2xN board, so 2 rows, N column)\\n        return helper(n, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620867,
                "title": "java-explanation-by-image-visualization-dp",
                "content": "Lets Fill for some small test cases :\\n---\\n|![image](https://assets.leetcode.com/users/images/b910c16e-be2a-4f26-9f46-279c98c3d093_1639110091.7002633.jpeg)|\\n_\\n\\n\\n\\n\\n## Taking out some insight from this : \\n|![image](https://assets.leetcode.com/users/images/89d403d4-b09a-4bbf-b0dc-de2e2155043d_1639110183.932951.jpeg)   |\\n-\\n|   |\\n\\n---\\n---\\n\\n### Why we add 2*p(2)-\\nsee for n=2 , 2*n size grid , there is two ways to partial fill it \\n| ![image](https://assets.leetcode.com/users/images/568b3823-9d75-4a68-ba71-817e7809656e_1639110857.8280482.jpeg) |\\n-\\n So finally  Our equation Comes out :\\n*\\t **f(k)=f(k\\u22121)+f(k\\u22122)+2\\u2217p(k\\u22121)**\\n*\\t**p(k) = p(k-1) + f(k-2)p(k)=p(k\\u22121)+f(k\\u22122)**\\n\\n### Code : \\n---\\n```\\n public int numTilings(int n) {\\n        int MOD  =  1_000_000_000+7;\\n       \\n        if(n<=2) return n;\\n        long[]f =  new long[n+1];//n+1 size because , ans is at n index \\n        long[]p =  new long[n+1];\\n        \\n        // base case \\n        f[1] =1;f[2]=2;\\n        p[2] = 1;                        \\n\\t\\t\\n        for(int i=3;i<n+1;i++){            \\n            f[i] = ( f[i-1]+f[i-2]+2*p[i-1])%MOD;\\n            p[i] =  (p[i-1]+f[i-2])%MOD; // for n=3, 2 col wil contribute partial fill and 1 column contribute fully filled             \\n        }        \\n        return (int)f[n];        \\n    }\\n   \\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int numTilings(int n) {\\n        int MOD  =  1_000_000_000+7;\\n       \\n        if(n<=2) return n;\\n        long[]f =  new long[n+1];//n+1 size because , ans is at n index \\n        long[]p =  new long[n+1];\\n        \\n        // base case \\n        f[1] =1;f[2]=2;\\n        p[2] = 1;                        \\n\\t\\t\\n        for(int i=3;i<n+1;i++){            \\n            f[i] = ( f[i-1]+f[i-2]+2*p[i-1])%MOD;\\n            p[i] =  (p[i-1]+f[i-2])%MOD; // for n=3, 2 col wil contribute partial fill and 1 column contribute fully filled             \\n        }        \\n        return (int)f[n];        \\n    }\\n   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621074,
                "title": "python-2-solutions-dp-and-matrix-power-explained",
                "content": "#### Solution 1\\nAs any problem with tiling, here we need to write down recurrent equations. Let `Fn` be number of tilings for `(n+1)\\xD72` board and `Gn` be number of tilings for `(n+1)\\xD72` board with one cell added. Then it can be shown that `Fn=F_{n\\u22121}+F_{n\\u22122}+2\\u22C5G_{n\\u22122}` and Gn=G_{n\\u22121}+F_{n\\u22121} and `F0=1,F1=2,G0=1,G1=2.`\\n\\n#### Complexity\\nTime and space complexity will be `O(n)`.\\n\\nCode\\n```python\\nclass Solution:\\n    def numTilings(self, N):\\n        M = 10**9 + 7\\n        if N <= 2: return N\\n        F = [1, 2] + [0]*(N-2)\\n        G = [1, 2] + [0]*(N-2)\\n        for i in range(2, N):\\n            F[i] = (F[i-1] + F[i-2] + 2*G[i-2]) % M\\n            G[i] = (G[i-1] + F[i-1]) % M\\n            \\n        return F[-1]\\n```\\n\\n#### Solution 2\\nMoreover it can be shown, that `Fn=2*F_{n\\u22121}+F_{n\\u22123}`, so it can be written using only `O(1)` memory. Also, as for any recurrent equation, it can be solved in `O(log n) * Q^3`, if we evaluate power of the transition matrix `A = [[2, 0, 1], [1, 0, 0], [0, 1, 0]]`, where `Q = 3` is size of this matrix. We need to evaluate `b * A^n`, where `b = [0, 1, 1]` are starting positions.\\n\\n#### Complexity\\nIt is `O(log n) * Q^3`, where `Q = 3`. Space is `O(Q^3)`.\\n\\n#### Code\\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def numTilings(self, N):\\n        def power(M, n, MOD):\\n            result = np.eye(len(M), dtype = np.int64)\\n            while n > 0:\\n                if n%2: result = np.dot(M, result) % MOD\\n                M = np.dot(M, M) % MOD\\n                n //= 2\\n            return result\\n        \\n        m = power([[2,0,1],[1,0,0],[0,1,0]], N-1, 10**9 + 7)\\n        return (m[0][0] + m[0][1]) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def numTilings(self, N):\\n        M = 10**9 + 7\\n        if N <= 2: return N\\n        F = [1, 2] + [0]*(N-2)\\n        G = [1, 2] + [0]*(N-2)\\n        for i in range(2, N):\\n            F[i] = (F[i-1] + F[i-2] + 2*G[i-2]) % M\\n            G[i] = (G[i-1] + F[i-1]) % M\\n            \\n        return F[-1]\\n```\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def numTilings(self, N):\\n        def power(M, n, MOD):\\n            result = np.eye(len(M), dtype = np.int64)\\n            while n > 0:\\n                if n%2: result = np.dot(M, result) % MOD\\n                M = np.dot(M, M) % MOD\\n                n //= 2\\n            return result\\n        \\n        m = power([[2,0,1],[1,0,0],[0,1,0]], N-1, 10**9 + 7)\\n        return (m[0][0] + m[0][1]) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288662,
                "title": "java-o-n-dp-solution-with-really-simple-math",
                "content": "Assume before column n, every cell is filled. In column n, there are two states: both cells filled and only one cell filled. \\nFrom there we have:\\nf(n) as the number of ways to reach the state that both cells are filled in column n.\\ng(n) as the number of ways to reach the state that one cell is filled in column n.\\nWritten as:\\n```\\n1. \\tf(n) = f(n - 1) + f(n - 2) + g(n - 1)\\n2. \\tg(n) = g(n - 1) + 2 * f(n - 2)\\n\\nAccording to formula 1:\\nf(n) - f(n - 1) = [f(n - 1) + f(n - 2) + g(n - 1)] - [f(n - 2) + f(n - 3) + g(n - 2)]\\n=> f(n) = 2 * f(n - 1) - f(n - 3) + g(n - 1) - g(n - 2)\\n\\nBring in formula 2, we get the final formula: f(n) = 2 * f(n - 1) + f(n - 3)\\n```\\nExplained in picture:\\n![image](https://assets.leetcode.com/users/wbowei2008/image_1557300446.png)\\n```\\nJava:\\nclass Solution {\\n    public int numTilings(int N) {\\n        if(N == 1) return 1;\\n        else if(N == 2 ) return 2;\\n        int mod = 1000000007;\\n\\t\\tint[] f = new int[N + 1];\\n        \\n        f[1] = 1;\\n        f[2] = 2;\\n        f[3] = 5;\\n        for(int i = 4; i <= N; i++) {\\n            f[i] = 2 * f[i - 1] % mod + f[i - 3] % mod;\\n            f[i] %= mod;\\n        }\\n        return (int) f[N];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1. \\tf(n) = f(n - 1) + f(n - 2) + g(n - 1)\\n2. \\tg(n) = g(n - 1) + 2 * f(n - 2)\\n\\nAccording to formula 1:\\nf(n) - f(n - 1) = [f(n - 1) + f(n - 2) + g(n - 1)] - [f(n - 2) + f(n - 3) + g(n - 2)]\\n=> f(n) = 2 * f(n - 1) - f(n - 3) + g(n - 1) - g(n - 2)\\n\\nBring in formula 2, we get the final formula: f(n) = 2 * f(n - 1) + f(n - 3)\\n```\n```\\nJava:\\nclass Solution {\\n    public int numTilings(int N) {\\n        if(N == 1) return 1;\\n        else if(N == 2 ) return 2;\\n        int mod = 1000000007;\\n\\t\\tint[] f = new int[N + 1];\\n        \\n        f[1] = 1;\\n        f[2] = 2;\\n        f[3] = 5;\\n        for(int i = 4; i <= N; i++) {\\n            f[i] = 2 * f[i - 1] % mod + f[i - 3] % mod;\\n            f[i] %= mod;\\n        }\\n        return (int) f[N];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946029,
                "title": "c-easy-to-understand-solution-beats-100",
                "content": "# Approach\\nTested on few testcases\\n\\nn = 1 : ans = 1\\nn = 2 : ans = 2\\nn = 3 : ans = 5\\nn = 4 : ans = 11\\nn = 5 : ans = 24\\n\\nConsidering a pattern formed with current **\"n\"** and previously calculated **\"n\"** :\\n`ans[n] = 2 * ans[n-1] + ans[n-3]`\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define md 1000000007\\n    int numTilings(int n) {\\n        vector<long long> v(1001, 0);\\n\\n        v[1] = 1;\\n        v[2] = 2;\\n        v[3] = 5;\\n        \\n        for(int i = 4; i <= n; i++)\\n            v[i] = (2 * v[i-1] + v[i-3]) % md;\\n        \\n    return v[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define md 1000000007\\n    int numTilings(int n) {\\n        vector<long long> v(1001, 0);\\n\\n        v[1] = 1;\\n        v[2] = 2;\\n        v[3] = 5;\\n        \\n        for(int i = 4; i <= n; i++)\\n            v[i] = (2 * v[i-1] + v[i-3]) % md;\\n        \\n    return v[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621160,
                "title": "explanation-with-image-0ms-100-faster",
                "content": "**Idea?**\\n* *Dynamic Programming*\\n* **dp[i] = number of ways to form 2 x i board with gives tiles.**\\n* Suppose, we had already calculated the dp[j] for all j belongs to [1,i-1], Now how to get dp[i] ?\\n* Let\\'s look out certain domino we can place at \\'i\\'th position.\\n\\n![image](https://assets.leetcode.com/users/images/0d9a6e41-89e5-4a89-ba4c-92af0f4a9527_1639123044.4028025.png)\\n\\n![image](https://assets.leetcode.com/users/images/53cb9214-7591-45db-b6cc-6c1eb556c92c_1639123069.2442987.png)\\n\\n![image](https://assets.leetcode.com/users/images/36e79f50-4eb3-4abc-b0fd-f72004a08792_1639123084.2648911.png)\\n\\n**Generating dp relation:-**\\n\\n![image](https://assets.leetcode.com/users/images/072039ac-2f71-43c2-a2a7-6ea930e4bbfc_1639132061.445384.png)\\n\\n\\n**Note:- if n==0, we must return 0 as our answer. Here dp[0] = 1 for calculation.**\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define MOD 1000000007\\n    int numTilings(int n) {\\n        vector<ll> dp(n+1);\\n        iota(dp.begin(),dp.end(),0);\\n        dp[0] = 1;\\n        for(int i=3;i<=n;i++)\\n            dp[i] = (dp[i-1]+dp[i-1]+dp[i-3])%MOD;\\n        return dp.back();\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/76c4c03c-ad60-4fd8-9d1e-3a3983d2129a_1639123137.3745196.png)\\n\\n**Don\\'t forget to Upvote!**\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define MOD 1000000007\\n    int numTilings(int n) {\\n        vector<ll> dp(n+1);\\n        iota(dp.begin(),dp.end(),0);\\n        dp[0] = 1;\\n        for(int i=3;i<=n;i++)\\n            dp[i] = (dp[i-1]+dp[i-1]+dp[i-3])%MOD;\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762470,
                "title": "neat-explanation-c-dp-solution",
                "content": "```\\nlet\\'s focus on the shape of the last column it can be\\nx  (A)                 or          xx   (B)               or       x  (C)\\nx                                  x                               xx\\n\\nif we want to add another column we can get complete figure by using\\nx  (for 1st configuration)                    x  (for 2nd)                            xx  (for 3rd)\\nx                                            xx                                        x \\n\\nso  ans for A[i] =  getting   x   in the last column\\n\\t\\t\\t\\t\\t\\t      x\\t\\t\\t\\nB[i]     =     getting     x         in the last column\\n\\t\\t\\t\\t\\t\\t   xx\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \\n \\n C[i] =   getting   xx   in the last column\\n\\t\\t\\t        x\\n\\nA[i]   =    A[i-1]( adding   x  )   +            A[i-2](adding two xx )     +  ( B[i-1] + C[i-1]) (adding    xx  or   x )\\n\\t\\t\\t\\t\\t\\t     x\\t\\t\\t                           xx                                         x      xx\\nB[i]    =   A[i-2](adding  x   )       +           B[i-1](adding      x              +     xx           =       xxx)  \\n\\t\\t\\t\\t\\t\\t   xx                                         xx                                        xx              \\n\\n\\nC[i] =     A[i-2]       +            C[i-1] \\nbut B and C are numerically same so we can use one array only\\n\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n      if(N <= 2)return N;\\n      vector<long int>A(N+1,0);\\n      vector<long int>B(N+1,0);\\n        A[1] = 1;\\n        A[2] = 2;\\n        B[1] = 0;\\n        B[2] = 1;\\n        int mod = 1000000007;\\n        for(int i=3;i<=N;i++)\\n        {\\n            A[i] = (A[i-1]+A[i-2]+ 2*B[i-1])%mod;\\n            B[i] = (B[i-1] + A[i-2])%mod;\\n        }\\n        \\n        return A[N];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet\\'s focus on the shape of the last column it can be\\nx  (A)                 or          xx   (B)               or       x  (C)\\nx                                  x                               xx\\n\\nif we want to add another column we can get complete figure by using\\nx  (for 1st configuration)                    x  (for 2nd)                            xx  (for 3rd)\\nx                                            xx                                        x \\n\\nso  ans for A[i] =  getting   x   in the last column\\n\\t\\t\\t\\t\\t\\t      x\\t\\t\\t\\nB[i]     =     getting     x         in the last column\\n\\t\\t\\t\\t\\t\\t   xx\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \\n \\n C[i] =   getting   xx   in the last column\\n\\t\\t\\t        x\\n\\nA[i]   =    A[i-1]( adding   x  )   +            A[i-2](adding two xx )     +  ( B[i-1] + C[i-1]) (adding    xx  or   x )\\n\\t\\t\\t\\t\\t\\t     x\\t\\t\\t                           xx                                         x      xx\\nB[i]    =   A[i-2](adding  x   )       +           B[i-1](adding      x              +     xx           =       xxx)  \\n\\t\\t\\t\\t\\t\\t   xx                                         xx                                        xx              \\n\\n\\nC[i] =     A[i-2]       +            C[i-1] \\nbut B and C are numerically same so we can use one array only\\n\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n      if(N <= 2)return N;\\n      vector<long int>A(N+1,0);\\n      vector<long int>B(N+1,0);\\n        A[1] = 1;\\n        A[2] = 2;\\n        B[1] = 0;\\n        B[2] = 1;\\n        int mod = 1000000007;\\n        for(int i=3;i<=N;i++)\\n        {\\n            A[i] = (A[i-1]+A[i-2]+ 2*B[i-1])%mod;\\n            B[i] = (B[i-1] + A[i-2])%mod;\\n        }\\n        \\n        return A[N];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132473,
                "title": "c-dp-faster-than-100-00-explained-with-image",
                "content": "It was a good problem, probably on the harder side of the `Medium` problems. For guys finding it difficult to approach, I would suggest to solve Domino Tiling (not available on leetcode) first. Here I tried to think along the lines of the forming some sort of recurrence relation and the result was pretty satisfying considering the time complexity I obtained. \\n\\n**Image: for better understanding**\\n![image](https://assets.leetcode.com/users/images/c4af608c-c80e-4c1d-b9e4-769ad1fb8e23_1654805144.7800725.jpeg)\\n\\n\\n**Thinking Process:**\\nTo start off, consider establishing some base cases. For n=1, the number of ways would be 1 and for n=2, the number of ways would be 2. (that much is obvious). For n=0, the number of ways would be 1 and for negative integers, it can be assumed to be 0.\\nNow, If we want to find out the number of ways for for n=3, we can do it in a pretty intuitive way. All we need to do is attach a vertical domino at the end of all the different arrangements obtained for n=2 which would be 2. Then we can attach 2 horizontal bars at the end of all the arrangements obtained for n=1 which would be 1. And finally, 2 new patterns will be obtained if we consider the interlocking of two trominoes (which btw is only possible for n>=3). Hence, total no. of arrangements would be 2+1+2 = 5 which is indeed correct.\\nSimilarly, for n=4, we can attach a vertical domino at the end of all the different arrangements obtained for n=3 which would be 5. Then we can attach 2 horizontal bars at the end of all the arrangements obtained for n=2 which would be 2. Then we can attach 2 interlocking trominoes(obtained initially at n=3) at the end of all the arrangements obtained for n=1 which would be 2. And finally, 2 new patterns will be obtained as shown in the figure.\\n\\nHere, we start to see a pattern here.For any n, first we attach single vertical domino (which was initially obtained at n=1) with the arrangements obtained at n-1. then we attach two horizontal dominos(which was initially obtained at n=2) with the arrangements obtained at n-2. Then we attach the 2 new patterns obtained at n=3 with the with the arrangements obtained at n-3 and so on.\\n\\nAnd, it we can see that every n>=3 creates two entirely new patterns. Processing all of this, we can generate a recurrence relation which goes as follows:\\n\\ndp[n] = dp[n-1] + dp[n-2] + 2*dp[n-3] + 2*dp[n-4] + ................. + 2*dp[0].\\n\\nNow, this is a correct recurrence relation, but we can do better.\\nSubstituting n for n-1, in the above relation, we obtain:\\n\\ndp[n-1] = dp[n-2] + dp[n-3] + 2*dp[n-4] + 2*dp[n-5] + ................. + 2*dp[0] + 2*dp[-1].\\n\\nWe already assumed the answer to the negative integers to be 0. Hence it can be removed. Solving  both equation we obtain:\\n\\ndp[n] = 2*dp[i-3] + dp[i-3]\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(n==3)\\n            return 5;\\n        if(n==4)\\n            return 11;\\n        \\n        vector<unsigned int> dp(n+1,0);\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        dp[4] = 11;\\n        \\n        \\n        for(int i=5; i<=n; ++i) {\\n            dp[i] = (2*dp[i-1] +dp[i-3]) % 1000000007;\\n        }\\n        \\n        return dp[n];\\n        \\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/63c5e6af-fcb3-4095-a085-4e0fd6650f5f_1654806632.3793948.png)\\n\\n\\nIn this way we can obtain a time complexity of O(n).\\nPlease upvote if my solution was of any help.\\nP.S.: Comment for any query.\\nHave a great day ;)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(n==3)\\n            return 5;\\n        if(n==4)\\n            return 11;\\n        \\n        vector<unsigned int> dp(n+1,0);\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        dp[4] = 11;\\n        \\n        \\n        for(int i=5; i<=n; ++i) {\\n            dp[i] = (2*dp[i-1] +dp[i-3]) % 1000000007;\\n        }\\n        \\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116622,
                "title": "o-logn-time-o-1-space-linear-algebraic-algorithm-in-python",
                "content": "```\nimport numpy as np\nclass Solution(object):\n    def numTilings(self, n):\n        if n <= 1:\n            return 1\n        elif n == 2: \n            return 2\n        x = np.array([2,1,1],dtype=np.int64)\n        A = np.array([[2,1,1],[3,1,1],[4,2,1]],dtype=np.int64)\n        y1 = np.array([1,1,2],dtype=np.int64)\n        y2 = np.array([2,3,4],dtype=np.int64)\n        if n%2 == 1:\n            k = (n-3)/2\n            y = y1\n        else: \n            k = (n-4)/2\n            y = y2\n        xA = x\n        while k>0:\n            if k%2 == 1:\n                xA = xA.dot(A)%1000000007\n            k /= 2\n            A = A.dot(A)%1000000007\n        return int(xA.dot(y)%1000000007)\n```\nThe rationale of this algorithm is based on the following observation:\nWe first define ```T(n)``` as the number of different tilings when the area to be covered is ```2 x n```. \nFurthermore, if we put a ```2 x 1```  domino, then the area to be covered is ```2 x (n-1)``` left; \nif we put a ```1 x 2``` domino, then we need to align another ```1 x 2``` domino with the previous one so that the area to be covered remains a rectangular ```2 x (n-2)```. Considering all possible first picks, we can expand ```T(n)``` into\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519622531.png)\nDefine the coefficients ```[a1, b1, c1]```, which is initiated as```[1, 1, 2]```, we have\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519622634.png)\nBy expanding ```T(n)```, we can obtained the following relationships,\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519622702.png)\nObviously, the ```T(n)``` can be computed by the following algorithm in ```O(n)``` time:\n```\ndef T(n):\n\ta,b,c = 1,0,0\n\tif n <= 1:\n\t\treturn 1\n\telif n == 2:\n\t\treturn 2\n\tfor i in xrange(n-2):\n\t\ta, b, c = a+b, a+c, 2*a+c\n\treturn 2*a + b + c\n```\nAfter some operations, these equations can be rewritten as\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519622826.png)\nwhich is similar to the recursive form of ```T(n)```. It implies that\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519624128.png)\nTherefore, ```T(n)``` can be represented as the following closed form: when ```n > 2```, ![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519624393.png)\nThis results in an ```O(logn)``` algorithm.\n\n\nThe bottleneck of this algorithm is the computation of ``` A^{k-1} ```, which costs ```O(logn)``` there. If there is better way to solve this problem, maybe the computional complexity can be reduced.\n(I have tried ```numpy.linalg.eig```, but it didn't work)",
                "solutionTags": [],
                "code": "```\nimport numpy as np\nclass Solution(object):\n    def numTilings(self, n):\n        if n <= 1:\n            return 1\n        elif n == 2: \n            return 2\n        x = np.array([2,1,1],dtype=np.int64)\n        A = np.array([[2,1,1],[3,1,1],[4,2,1]],dtype=np.int64)\n        y1 = np.array([1,1,2],dtype=np.int64)\n        y2 = np.array([2,3,4],dtype=np.int64)\n        if n%2 == 1:\n            k = (n-3)/2\n            y = y1\n        else: \n            k = (n-4)/2\n            y = y2\n        xA = x\n        while k>0:\n            if k%2 == 1:\n                xA = xA.dot(A)%1000000007\n            k /= 2\n            A = A.dot(A)%1000000007\n        return int(xA.dot(y)%1000000007)\n```\n```T(n)```\n```2 x n```\n```2 x 1```\n```2 x (n-1)```\n```1 x 2```\n```1 x 2```\n```2 x (n-2)```\n```T(n)```\n```[a1, b1, c1]```\n```[1, 1, 2]```\n```T(n)```\n```T(n)```\n```O(n)```\n```\ndef T(n):\n\ta,b,c = 1,0,0\n\tif n <= 1:\n\t\treturn 1\n\telif n == 2:\n\t\treturn 2\n\tfor i in xrange(n-2):\n\t\ta, b, c = a+b, a+c, 2*a+c\n\treturn 2*a + b + c\n```\n```T(n)```\n```T(n)```\n```n > 2```\n```O(logn)```\n``` A^{k-1} ```\n```O(logn)```\n```numpy.linalg.eig```",
                "codeTag": "Java"
            },
            {
                "id": 215670,
                "title": "java-o-n-math-proof-on-paper",
                "content": "```\\nclass Solution {\\n    \\n    public int numTilings(int N) {\\n        if (N <= 0) return 0;\\n        if (N == 1) return 1;\\n        if (N == 2) return 2;\\n        long[] dp = new long[N + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        int mod = (int) 1e9 + 7;\\n        for (int i = 3; i <= N; i++) {\\n            dp[i] = (2 * dp[i - 1] + dp[i- 3]) % mod;\\n        }\\n        return (int) dp[N];\\n    }\\n    \\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/cheng_coding_attack/image_1546972782.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int numTilings(int N) {\\n        if (N <= 0) return 0;\\n        if (N == 1) return 1;\\n        if (N == 2) return 2;\\n        long[] dp = new long[N + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        int mod = (int) 1e9 + 7;\\n        for (int i = 3; i <= N; i++) {\\n            dp[i] = (2 * dp[i - 1] + dp[i- 3]) % mod;\\n        }\\n        return (int) dp[N];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116513,
                "title": "java-solution-dp",
                "content": "Reference: https://cs.stackexchange.com/questions/66658/domino-and-tromino-combined-tiling\n```\nclass Solution {\n    private static final int MOD = 1000000007;\n    public int numTilings(int N) {\n        if (N == 1) return 1;\n        if (N == 2) return 2;\n        long[] dp = new long[N + 1];\n        dp[0] = 1; dp[1] = 1; dp[2] = 2;\n        for (int i = 3; i <= N; i++) {\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % MOD;\n        }\n        return (int) dp[N];\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    private static final int MOD = 1000000007;\n    public int numTilings(int N) {\n        if (N == 1) return 1;\n        if (N == 2) return 2;\n        long[] dp = new long[N + 1];\n        dp[0] = 1; dp[1] = 1; dp[2] = 2;\n        for (int i = 3; i <= N; i++) {\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % MOD;\n        }\n        return (int) dp[N];\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944361,
                "title": "python-3-4-lines-recurrence-relation-w-example-and-brief-comments-t-m-99-5-86",
                "content": "A few drawings on scratch paper will convince you that there are two states because of the two types of tiles. A little tougher task is determining the recurence relationship and initial counts.\\n```\\nclass Solution:\\n    def numTilings(self,n:int)->int:                            # Example:  n = 5\\n\\n        prev, curr, tri = 1, 1, 0                               #  n   prev  curr  tri \\n                                                                # ---  ----  ----  ----\\n        for i in range(1,n):                                    #   1     1     1     0\\n                                                                #   2     1     2     1\\n            prev, curr, tri = curr, prev+curr+2*tri, prev+tri   #   3     2     5     2\\n                                                                #   4     5    11     4\\n        return curr%1000000007                                  #   5    11    24     9\\n                                                                #              / \\n                                                                #           return\\n```\\n[https://leetcode.com/problems/domino-and-tromino-tiling/submissions/864496961/](http://)\\n\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(1).\\n\\'\\'\\'",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self,n:int)->int:                            # Example:  n = 5\\n\\n        prev, curr, tri = 1, 1, 0                               #  n   prev  curr  tri \\n                                                                # ---  ----  ----  ----\\n        for i in range(1,n):                                    #   1     1     1     0\\n                                                                #   2     1     2     1\\n            prev, curr, tri = curr, prev+curr+2*tri, prev+tri   #   3     2     5     2\\n                                                                #   4     5    11     4\\n        return curr%1000000007                                  #   5    11    24     9\\n                                                                #              / \\n                                                                #           return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620640,
                "title": "python-dynamic-programming-in-4-lines-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        full_0, full_1, incomp_1 = 1, 2, 2\\n        for i in range(2, n):\\n            full_0, full_1, incomp_1 = full_1, full_0 + full_1 + incomp_1, 2 * full_0 + incomp_1\\n        return full_1 % (10 ** 9 + 7) if n >= 2 else 1\\n```\\n\\nThis below one is more readable, but it\\'s O(N) time and O(N) space.\\n* dp_full[i] denotes the number of possible cases where 0, 1, .... i th columns are full\\n dp_full[i] = dp_full[i - 2] + dp_full[i - 1] + dp_incomp[i - 1] because we can achieve the state of dp_full[i] by **dp_full[i - 2] + (horizontal block) x 2** or **dp_full[i - 1] + (vertical block) x 1** or **dp_incomp[i - 1] + (tromino block) x 1**\\n* dp_incomp[i] denotes the number of possible cases where 0, 1, ... i - 1 the columns are full, and i th column is half filled\\n Similarly, dp_incomp[i] = dp_full[i - 2] * 2 + dp_incomp[i - 1] because we can achieve the state of dp_incomp[i] by **dp_full[i - 2] + (vertical block) x 2** or **dp_full[i - 2] + (horizontal block) x 2** or **dp_incomp[i - 1] + (tromino block) x 1**\\n\\n\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        #edge case\\n        if n == 1:\\n            return 1\\n        \\n        mod = 10 ** 9 + 7\\n        dp_full = [0 for _ in range(n)]\\n        dp_incomp = [0 for _ in range(n)]\\n        \\n        dp_full[0] = 1\\n        dp_full[1] = 2\\n        dp_incomp[1] = 2\\n        \\n        for i in range(2, n):\\n            dp_full[i] = dp_full[i - 2] + dp_full[i - 1] + dp_incomp[i - 1]\\n            dp_incomp[i] = dp_full[i - 2] * 2 + dp_incomp[i - 1]\\n        \\n        return dp_full[-1] % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        full_0, full_1, incomp_1 = 1, 2, 2\\n        for i in range(2, n):\\n            full_0, full_1, incomp_1 = full_1, full_0 + full_1 + incomp_1, 2 * full_0 + incomp_1\\n        return full_1 % (10 ** 9 + 7) if n >= 2 else 1\\n```\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        #edge case\\n        if n == 1:\\n            return 1\\n        \\n        mod = 10 ** 9 + 7\\n        dp_full = [0 for _ in range(n)]\\n        dp_incomp = [0 for _ in range(n)]\\n        \\n        dp_full[0] = 1\\n        dp_full[1] = 2\\n        dp_incomp[1] = 2\\n        \\n        for i in range(2, n):\\n            dp_full[i] = dp_full[i - 2] + dp_full[i - 1] + dp_incomp[i - 1]\\n            dp_incomp[i] = dp_full[i - 2] * 2 + dp_incomp[i - 1]\\n        \\n        return dp_full[-1] % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209282,
                "title": "java-top-down-and-bottom-up-dp-explained-with-ascii-pictures",
                "content": "Top-down\\n\\n```\\n/*\\n0 => \\u2589\\u2589\\u2580\\n1 => \\u2589\\u2589\\u2583\\n2 => \\u2589\\u2589\\u2589\\n*/\\npublic int numTilings(int n) {\\n\\treturn numTilingsForFinalStateOf(n, 2);\\n}\\nMap<String, Integer> memo = new HashMap<>();\\npublic int numTilingsForFinalStateOf(int n, int colState) {\\n\\tint mod = 1_000_000_007;\\n\\tif (n < 0) return 0;\\n\\n\\tif (n == 0) {\\n\\t\\tif (colState == 2) { // goal achieved\\n\\t\\t\\treturn 1;\\n\\t\\t} else {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\tString memKey = n+\"|\"+colState;\\n\\tif (memo.containsKey(memKey)) return memo.get(memKey);\\n\\n\\tlong ways = 0;\\n\\tif (colState == 0) { // attempting to generate tilings for \\u2589\\u2589\\u2580 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 1);// \\u2589\\u2583\\n\\t} else if (colState == 1) { // attempting to generate tilings for \\u2589\\u2589\\u2583 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 0);// \\u2589\\u2580\\n\\t} else if (colState == 2) { // attempting to generate tilings for \\u2589\\u2589\\u2589 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 0);// \\u2589\\u2580\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 1);// \\u2589\\u2583\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 2);// \\u2589\\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t}\\n\\n\\tways = Math.floorMod(ways, mod);\\n\\tmemo.put(memKey, (int) ways);\\n\\treturn (int) ways;\\n}\\n```\\n\\nBottom-up\\n```\\n/*\\n0 => \\u2589\\u2589\\u2580\\n1 => \\u2589\\u2589\\u2583\\n2 => \\u2589\\u2589\\u2589\\n*/\\npublic int numTilings(int n) {\\n\\tint mod = 1_000_000_007;\\n\\tlong dp[][] = new long[n+1][3];\\n\\t// entire \"zero-th\" row is possible because DP \\xAF\\\\_(\\u30C4)_/\\xAF\\n\\tdp[0][0] = 1;\\n\\tdp[0][1] = 1;\\n\\tdp[0][2] = 1;\\n\\t// we can start with a full row 1 by placing single domino (\\u2589)\\n\\t// other states are impossible because monominoes don\\'t exist\\n\\tdp[1][0] = 0;\\n\\tdp[1][1] = 0;\\n\\tdp[1][2] = 1;\\n\\n\\tfor (int i = 2; i<=n; i++) {\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2580\\n\\t\\tdp[i][0] += dp[i-1][1]; // \\u2589\\u2583 + \\u2580\\u2580\\n\\t\\tdp[i][0] += dp[i-2][2]; // \\u2589  + \\u2589\\u2580\\n\\t\\tdp[i][0] = Math.floorMod(dp[i][0], mod);\\n\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2583\\n\\t\\tdp[i][1] += dp[i-1][0]; // \\u2589\\u2580 + \\u2583\\u2583\\n\\t\\tdp[i][1] += dp[i-2][2]; // \\u2589  + \\u2589\\u2583\\n\\t\\tdp[i][1] = Math.floorMod(dp[i][1], mod);\\n\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2589\\n\\t\\tdp[i][2] += dp[i-1][2]; // \\u2589\\u2589 + \\u2589\\n\\t\\tdp[i][2] += dp[i-2][2]; // \\u2589  + \\u2550\\u2550\\n\\t\\tdp[i][2] += dp[i-1][0]; // \\u2589\\u2580 + \\u2583\\u2589\\n\\t\\tdp[i][2] += dp[i-1][1]; // \\u2589\\u2583 + \\u2580\\u2589\\n\\t\\tdp[i][2] = Math.floorMod(dp[i][2], mod);\\n\\t}\\n\\n\\treturn (int) dp[n][2];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/*\\n0 => \\u2589\\u2589\\u2580\\n1 => \\u2589\\u2589\\u2583\\n2 => \\u2589\\u2589\\u2589\\n*/\\npublic int numTilings(int n) {\\n\\treturn numTilingsForFinalStateOf(n, 2);\\n}\\nMap<String, Integer> memo = new HashMap<>();\\npublic int numTilingsForFinalStateOf(int n, int colState) {\\n\\tint mod = 1_000_000_007;\\n\\tif (n < 0) return 0;\\n\\n\\tif (n == 0) {\\n\\t\\tif (colState == 2) { // goal achieved\\n\\t\\t\\treturn 1;\\n\\t\\t} else {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\tString memKey = n+\"|\"+colState;\\n\\tif (memo.containsKey(memKey)) return memo.get(memKey);\\n\\n\\tlong ways = 0;\\n\\tif (colState == 0) { // attempting to generate tilings for \\u2589\\u2589\\u2580 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 1);// \\u2589\\u2583\\n\\t} else if (colState == 1) { // attempting to generate tilings for \\u2589\\u2589\\u2583 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 0);// \\u2589\\u2580\\n\\t} else if (colState == 2) { // attempting to generate tilings for \\u2589\\u2589\\u2589 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 0);// \\u2589\\u2580\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 1);// \\u2589\\u2583\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 2);// \\u2589\\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t}\\n\\n\\tways = Math.floorMod(ways, mod);\\n\\tmemo.put(memKey, (int) ways);\\n\\treturn (int) ways;\\n}\\n```\n```\\n/*\\n0 => \\u2589\\u2589\\u2580\\n1 => \\u2589\\u2589\\u2583\\n2 => \\u2589\\u2589\\u2589\\n*/\\npublic int numTilings(int n) {\\n\\tint mod = 1_000_000_007;\\n\\tlong dp[][] = new long[n+1][3];\\n\\t// entire \"zero-th\" row is possible because DP \\xAF\\\\_(\\u30C4)_/\\xAF\\n\\tdp[0][0] = 1;\\n\\tdp[0][1] = 1;\\n\\tdp[0][2] = 1;\\n\\t// we can start with a full row 1 by placing single domino (\\u2589)\\n\\t// other states are impossible because monominoes don\\'t exist\\n\\tdp[1][0] = 0;\\n\\tdp[1][1] = 0;\\n\\tdp[1][2] = 1;\\n\\n\\tfor (int i = 2; i<=n; i++) {\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2580\\n\\t\\tdp[i][0] += dp[i-1][1]; // \\u2589\\u2583 + \\u2580\\u2580\\n\\t\\tdp[i][0] += dp[i-2][2]; // \\u2589  + \\u2589\\u2580\\n\\t\\tdp[i][0] = Math.floorMod(dp[i][0], mod);\\n\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2583\\n\\t\\tdp[i][1] += dp[i-1][0]; // \\u2589\\u2580 + \\u2583\\u2583\\n\\t\\tdp[i][1] += dp[i-2][2]; // \\u2589  + \\u2589\\u2583\\n\\t\\tdp[i][1] = Math.floorMod(dp[i][1], mod);\\n\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2589\\n\\t\\tdp[i][2] += dp[i-1][2]; // \\u2589\\u2589 + \\u2589\\n\\t\\tdp[i][2] += dp[i-2][2]; // \\u2589  + \\u2550\\u2550\\n\\t\\tdp[i][2] += dp[i-1][0]; // \\u2589\\u2580 + \\u2583\\u2589\\n\\t\\tdp[i][2] += dp[i-1][1]; // \\u2589\\u2583 + \\u2580\\u2589\\n\\t\\tdp[i][2] = Math.floorMod(dp[i][2], mod);\\n\\t}\\n\\n\\treturn (int) dp[n][2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413360,
                "title": "c-dp-solution-with-step-by-step-optimization-and-explanation",
                "content": "# Step 1:\\nTwo dimension DP[i, j] array.\\ni is the i-th column of the grid.\\nj indicates 3 states of the i-th column. \\n\\t\\t0 : Fully covered by a tile(Domino or Tromino).\\n\\t\\t1 : Only top part is coverd by a tile.\\n\\t\\t2 : Only bottom part is covered by a tile.\\nNow we can come up with 3 DP formulas: \\n```\\ndp[i,0] = dp[i-2,0] + dp[i-1,0] + dp[i-1,1] + dp[i-1,2];\\ndp[i,1] = dp[i-2,0] + dp[i-1,2];\\ndp[i,2] = dp[i-2,0] + dp[i-1,1];\\n```\\n```\\npublic int NumTilings(int N) {\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long[,] dp = new long[N+1,3];\\n        dp[0,0] = 1;\\n        dp[1,0] = 1;\\n        for(int i = 2; i <= N; i++)\\n        {\\n            dp[i,0] = (dp[i-2,0] + dp[i-1,0] + dp[i-1,1] + dp[i-1,2]) % mod;\\n            dp[i,1] = (dp[i-2,0] + dp[i-1,2]) % mod;\\n            dp[i,2] = (dp[i-2,0] + dp[i-1,1]) % mod;\\n        }\\n        \\n        return (int)dp[N,0];\\n    }\\n```           \\n\\t\\n# Step 2:\\nLook at the formula again, DP[i, 1] and DP[i, 2] are equivalent.\\nSo the formula can be simplified: \\n```\\ndp[i,0] = dp[i-2,0] + dp[i-1,0] + 2 * dp[i-1,1];\\ndp[i,1] = dp[i-2,0] + dp[i-1,1];\\n```\\nDo some math, get rid of dp[i-1,1] and dp[i,1] by :\\n```\\ndp[i-1,1] = 1/2 * (dp[i,0] - dp[i-2,0] - dp[i-1,0]);\\ndp[i,1] = 1/2 * (dp[i+1,0] - dp[i-1,0] - dp[i,0]);\\n```\\nThen we get :\\n```\\n1/2 * (dp[i+1,0] - dp[i-1,0] - dp[i,0]) = dp[i-2,0] + 1/2 * (dp[i,0] - dp[i-2,0] - dp[i-1,0]);\\ndp[i+1,0] **- dp[i-1,0]** - dp[i,0] = 2 * dp[i-2,0] + dp[i,0] - dp[i-2,0] **- dp[i-1,0]**;\\ndp[i+1,0] - dp[i,0] = 2 * **dp[i-2,0]** + dp[i,0] - **dp[i-2,0]**;\\ndp[i+1,0] - **dp[i,0]** = dp[i-2,0] + **dp[i,0]**;\\ndp[i+1,0] = dp[i-2,0] + 2 * dp[i,0];\\ndp[i,0] = dp[i-3,0] + 2 * dp[i-1,0];\\n```\\nNow, the formula can be converted to one dimension array.\\n```\\ndp[i] = dp[i-3] + 2 * dp[i-1];\\n```\\n```\\npublic int NumTilings(int N) {\\n        if(N < 3)\\n            return N;\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long[] dp = new long[N+1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= N; i++)\\n        {\\n            dp[i] = (dp[i-3] + 2 * dp[i-1]) % mod;\\n        }\\n        \\n        return (int)dp[N];\\n    }\\n```\\n\\n# Step 3:\\nNotice that in the formula we only need to track the last 3 previous result, \\nSo we can replace the DP array by 3 variables:\\n```\\npublic int NumTilings(int N) {\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long a = 0, b = 1, c = 1, cur = 1;\\n        while(--N > 0)\\n        {\\n            cur = (a + c * 2) % mod;\\n            a = b;\\n            b = c;\\n            c = cur;\\n        }\\n        return (int)cur;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i,0] = dp[i-2,0] + dp[i-1,0] + dp[i-1,1] + dp[i-1,2];\\ndp[i,1] = dp[i-2,0] + dp[i-1,2];\\ndp[i,2] = dp[i-2,0] + dp[i-1,1];\\n```\n```\\npublic int NumTilings(int N) {\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long[,] dp = new long[N+1,3];\\n        dp[0,0] = 1;\\n        dp[1,0] = 1;\\n        for(int i = 2; i <= N; i++)\\n        {\\n            dp[i,0] = (dp[i-2,0] + dp[i-1,0] + dp[i-1,1] + dp[i-1,2]) % mod;\\n            dp[i,1] = (dp[i-2,0] + dp[i-1,2]) % mod;\\n            dp[i,2] = (dp[i-2,0] + dp[i-1,1]) % mod;\\n        }\\n        \\n        return (int)dp[N,0];\\n    }\\n```\n```\\ndp[i,0] = dp[i-2,0] + dp[i-1,0] + 2 * dp[i-1,1];\\ndp[i,1] = dp[i-2,0] + dp[i-1,1];\\n```\n```\\ndp[i-1,1] = 1/2 * (dp[i,0] - dp[i-2,0] - dp[i-1,0]);\\ndp[i,1] = 1/2 * (dp[i+1,0] - dp[i-1,0] - dp[i,0]);\\n```\n```\\n1/2 * (dp[i+1,0] - dp[i-1,0] - dp[i,0]) = dp[i-2,0] + 1/2 * (dp[i,0] - dp[i-2,0] - dp[i-1,0]);\\ndp[i+1,0] **- dp[i-1,0]** - dp[i,0] = 2 * dp[i-2,0] + dp[i,0] - dp[i-2,0] **- dp[i-1,0]**;\\ndp[i+1,0] - dp[i,0] = 2 * **dp[i-2,0]** + dp[i,0] - **dp[i-2,0]**;\\ndp[i+1,0] - **dp[i,0]** = dp[i-2,0] + **dp[i,0]**;\\ndp[i+1,0] = dp[i-2,0] + 2 * dp[i,0];\\ndp[i,0] = dp[i-3,0] + 2 * dp[i-1,0];\\n```\n```\\ndp[i] = dp[i-3] + 2 * dp[i-1];\\n```\n```\\npublic int NumTilings(int N) {\\n        if(N < 3)\\n            return N;\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long[] dp = new long[N+1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= N; i++)\\n        {\\n            dp[i] = (dp[i-3] + 2 * dp[i-1]) % mod;\\n        }\\n        \\n        return (int)dp[N];\\n    }\\n```\n```\\npublic int NumTilings(int N) {\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long a = 0, b = 1, c = 1, cur = 1;\\n        while(--N > 0)\\n        {\\n            cur = (a + c * 2) % mod;\\n            a = b;\\n            b = c;\\n            c = cur;\\n        }\\n        return (int)cur;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296419,
                "title": "dp-solution-easy-to-understand-with-two-arrays-drawing-picture",
                "content": "Use two arrays for dp, `up[i]` means the board is complete from `0` to `i-1` , only the `i-th` column has only one square, `ret[i]` means the board is compelte from `0` to `i`.\\nSee the picture for clarification.\\n\\n![image](https://assets.leetcode.com/users/liyz1997/image_1558428660.png)\\n\\n```\\nconst int maxn = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        vector<long long> up(N + 1, 0), ret(N + 1, 0);\\n        ret[0] = 1;  // empty considered 1 way\\n        for (int i = 1; i <= N; i++) {\\n\\t\\t\\t// for up[i]\\n            up[i] += up[i - 1];  // case 1\\n            if (i > 1)  // case 2\\n                up[i] += ret[i - 2];\\n\\t\\t\\t\\t\\n            // for ret[i]\\n            ret[i] += ret[i - 1];  // case 1\\n            ret[i] += (2 * up[i - 1]);  // case 2\\n            if (i > 1)  // case 3\\n                ret[i] += ret[i - 2];\\n            \\n            up[i] %= maxn;\\n            ret[i] %= maxn;\\n        }\\n        return ret[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int maxn = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        vector<long long> up(N + 1, 0), ret(N + 1, 0);\\n        ret[0] = 1;  // empty considered 1 way\\n        for (int i = 1; i <= N; i++) {\\n\\t\\t\\t// for up[i]\\n            up[i] += up[i - 1];  // case 1\\n            if (i > 1)  // case 2\\n                up[i] += ret[i - 2];\\n\\t\\t\\t\\t\\n            // for ret[i]\\n            ret[i] += ret[i - 1];  // case 1\\n            ret[i] += (2 * up[i - 1]);  // case 2\\n            if (i > 1)  // case 3\\n                ret[i] += ret[i - 2];\\n            \\n            up[i] %= maxn;\\n            ret[i] %= maxn;\\n        }\\n        return ret[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945616,
                "title": "beats-100-solve-by-simple-linear-equation-with-explanation",
                "content": "My first intution was that f(n) can only depend on f(n-1), f(n-2) and f(n-3). Hence I formulated a linear equation as follows and solved it with known values (you can use leetcode testcase runner or compute manually for n=4,5,6). \\n\\n     linear equation\\n     f(n) = x * f(n-1) + y * f(n-2) + z * f(n-3)\\n     n = 4 => 5x + 2y + z = 11 \\n     n = 5 => 11x + 5y + 2z = 24\\n     n = 6 => 24x + 11y + 5z = 53\\n     With 3 equations we can find 3 unknowns.\\n     x = 2, y = 0, z = 1 \\n     i.e there is no dependency on f(n-2)\\n     \\n     Final equation:\\n     f(n) = 2*f(n-1) + f(n-3)\\n\\n\\nFind the java code here -> using DP tabulation similar to fibonacci\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/dp/DominoTrominoTiling.java",
                "solutionTags": [
                    "Java"
                ],
                "code": "My first intution was that f(n) can only depend on f(n-1), f(n-2) and f(n-3). Hence I formulated a linear equation as follows and solved it with known values (you can use leetcode testcase runner or compute manually for n=4,5,6). \\n\\n     linear equation\\n     f(n) = x * f(n-1) + y * f(n-2) + z * f(n-3)\\n     n = 4 => 5x + 2y + z = 11 \\n     n = 5 => 11x + 5y + 2z = 24\\n     n = 6 => 24x + 11y + 5z = 53\\n     With 3 equations we can find 3 unknowns.\\n     x = 2, y = 0, z = 1 \\n     i.e there is no dependency on f(n-2)\\n     \\n     Final equation:\\n     f(n) = 2*f(n-1) + f(n-3)\\n\\n\\nFind the java code here -> using DP tabulation similar to fibonacci\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/dp/DominoTrominoTiling.java",
                "codeTag": "Unknown"
            },
            {
                "id": 2945016,
                "title": "0ms-dp-solution-with-memoization-c-with-comments-and-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThinking of dp with memoization by finding the number of ways to fill from the column 1 to column i.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // up -> can be 0 or 1, 0 means there is no tile in a cell in first row and 1 means there is a tile in a cell in first row\\n    // down -> can be 0 or 1, 0 means there is no tile in a cell in second row and 1 means there is a tile in a cell in second row\\n    // dp[i][up][down] -> number of ways to fill the first i columns of the grid with the above constraints \\n    int dp[1001][3][3];\\n    int mod=1000000007;\\n    int rec(int i, int n, int up, int down){\\n        if (i==n+1){ // base case, if we reach out of the grid\\n            if (up+down==0) return 1; // No tile should be present in out of the grid, then that will be a valid way\\n            return 0;\\n        } \\n\\n        if (dp[i][up][down]!=-1) // If already calculated, then return the value\\n            return dp[i][up][down];\\n\\n        if (up+down==2) // If both rows have a tile. \\n            return dp[i][up][down]=rec(i+1, n, 0, 0); // Move to next column and in the next column, we have no tile, so both up and down are 0.\\n\\n        else if (up+down==0){ // If both rows have no tile\\n            int a=rec(i+1, n, 0, 0); // Fill with one tile of size 2x1, so for the next column up and down will be zero.\\n            int b=rec(i+1, n, 1, 1); // Fill with two tiles of size 1x2, so for the next column up and down will be one.\\n            int c=rec(i+1, n, 1, 0); // Fill with tromino such that in the next column, up has a tile and down hasn\\'t.\\n            int d=rec(i+1, n, 0, 1); // Fill with tromino such that in the next column, down has a tile and up hasn\\'t.\\n            return dp[i][up][down]=((long long)a+b+c+d)%mod; // Return the total number of ways.\\n        }\\n\\n        else if (up==1){ // If only up has a tile\\n            int a=rec(i+1, n, 1, 1); // Fill with a tromino covering the down and so in the next column, both up and down will have a tile.\\n            int b=rec(i+1, n, 0, 1); // Fill with a tile 1x2 covering the down and so in the next column, up will have no tile and down will have a tile.\\n            return dp[i][up][down]=((long long)a+b)%mod;\\n        }\\n\\n        else if (down==1){ // If only down has a tile\\n            int a=rec(i+1, n, 1, 1); // Fill with a tromino covering the up and so in the next column, both up and down will have a tile.\\n            int b=rec(i+1, n, 1, 0); // Fill with a tile 1x2 covering the up and so in the next column, up will have a tile and down will have no tile.\\n            return dp[i][up][down]=((long long)a+b)%mod;\\n        }\\n        \\n        return 0;\\n    }\\n    int numTilings(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(1, n, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // up -> can be 0 or 1, 0 means there is no tile in a cell in first row and 1 means there is a tile in a cell in first row\\n    // down -> can be 0 or 1, 0 means there is no tile in a cell in second row and 1 means there is a tile in a cell in second row\\n    // dp[i][up][down] -> number of ways to fill the first i columns of the grid with the above constraints \\n    int dp[1001][3][3];\\n    int mod=1000000007;\\n    int rec(int i, int n, int up, int down){\\n        if (i==n+1){ // base case, if we reach out of the grid\\n            if (up+down==0) return 1; // No tile should be present in out of the grid, then that will be a valid way\\n            return 0;\\n        } \\n\\n        if (dp[i][up][down]!=-1) // If already calculated, then return the value\\n            return dp[i][up][down];\\n\\n        if (up+down==2) // If both rows have a tile. \\n            return dp[i][up][down]=rec(i+1, n, 0, 0); // Move to next column and in the next column, we have no tile, so both up and down are 0.\\n\\n        else if (up+down==0){ // If both rows have no tile\\n            int a=rec(i+1, n, 0, 0); // Fill with one tile of size 2x1, so for the next column up and down will be zero.\\n            int b=rec(i+1, n, 1, 1); // Fill with two tiles of size 1x2, so for the next column up and down will be one.\\n            int c=rec(i+1, n, 1, 0); // Fill with tromino such that in the next column, up has a tile and down hasn\\'t.\\n            int d=rec(i+1, n, 0, 1); // Fill with tromino such that in the next column, down has a tile and up hasn\\'t.\\n            return dp[i][up][down]=((long long)a+b+c+d)%mod; // Return the total number of ways.\\n        }\\n\\n        else if (up==1){ // If only up has a tile\\n            int a=rec(i+1, n, 1, 1); // Fill with a tromino covering the down and so in the next column, both up and down will have a tile.\\n            int b=rec(i+1, n, 0, 1); // Fill with a tile 1x2 covering the down and so in the next column, up will have no tile and down will have a tile.\\n            return dp[i][up][down]=((long long)a+b)%mod;\\n        }\\n\\n        else if (down==1){ // If only down has a tile\\n            int a=rec(i+1, n, 1, 1); // Fill with a tromino covering the up and so in the next column, both up and down will have a tile.\\n            int b=rec(i+1, n, 1, 0); // Fill with a tile 1x2 covering the up and so in the next column, up will have a tile and down will have no tile.\\n            return dp[i][up][down]=((long long)a+b)%mod;\\n        }\\n        \\n        return 0;\\n    }\\n    int numTilings(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(1, n, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156332,
                "title": "o-log-n-c-concise-and-clean-and-easy-dp-solution",
                "content": "`f[i]` represents the number of ways to construct such shape:\\n`oooooooooo`\\n`oooooooooo`\\nwhere there are total 2i `o`s.\\n\\n`g[i]` represents the number of ways to construct such shape:\\n`oooooooooo`\\n`ooooooooo`\\nwhere there are total (2i - 1) `o`s.\\n\\nThen:\\n```\\nf(i) = f(i - 1) + f(i -2) + 2g(i - 1)\\ng(i) = g(i - 1) + f(i - 2)\\n```\\n\\nWe can then get an easy O(n) solution.\\n\\n***\\n\\nBut it can be faster:\\nIf we use matrix multiply to calculate f, it can be written as:\\n```\\n[1, 1, 2] [f(i-1), f(i-2), g(i-1)]^T = f(i)  // ^T: matrix\\'s transpose\\n```\\nwe can also use f(i-1), f(i-2), and g(i-1) only to construct f(i-1), g(i):\\n```\\n[1, 0, 0] [f(i-1), f(i-2), g(i-1)]^T = f(i-1)\\n[0, 1, 1] [f(i-1), f(i-2), g(i-1)]^T = g(i)\\n```\\n\\nTHEN,\\n```\\n/ 1 1 2 \\\\  /f(i-1)\\\\     / f(i) \\\\\\n| 1 0 0 |  |f(i-2)|  =  |f(i-1)|\\n\\\\ 0 1 1 /  \\\\g(i-1)/     \\\\ g(i) /\\n```\\n\\n***\\n\\nOkay, if we want to calculate f(4), it will be:\\n```\\n/ 1 1 2 \\\\  / 1 1 2 \\\\  /f(2)\\\\     /f(4)\\\\\\n| 1 0 0 |  | 1 0 0 |  |f(1)|  =  |f(3)|\\n\\\\ 0 1 1 /  \\\\ 0 1 1 /  \\\\g(2)/     \\\\g(4)/\\n```\\ngenerally, let R = `[[1,1,2],[1,0,0],[0,1,1]]`, then\\n```\\n[f(N), f(N - 1), g(N)]^T = R^(N - 2) * [f(2), f(1), g(2)]^T\\n```\\n\\nWe can calculate the matrix exponentiation `R^(N-2)` using a time of O(log N). Done.\\n\\n***\\n\\n```cpp\\n/*\\n/ 1 1 2 \\\\  /f(i-1)\\\\     / f(i) \\\\\\n| 1 0 0 |  |f(i-2)|  =  |f(i-1)|\\n\\\\ 0 1 1 /  \\\\g(i-1)/     \\\\ g(i) /\\n*/\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        if (N <= 2) return N;\\n        vector<vector<ll>> r;\\n        r.push_back({1, 1, 2});\\n        r.push_back({1, 0, 0});\\n        r.push_back({0, 1, 1});\\n        r = power(r, N - 2);\\n        return (r[0][0] * 2 + r[0][1] + r[0][2]) % M;\\n    }\\n    \\n    vector<vector<ll>> power(vector<vector<ll>>& x, int n) {\\n        if (n == 1) return x;\\n        int m = n >> 1;\\n        auto r = power(x, m);\\n        r = multiply(r, r);\\n        if (n & 1) {\\n            r = multiply(r, x);\\n        }\\n        return r;\\n    }\\n    \\nprivate:\\n    vector<vector<ll>> multiply(const vector<vector<ll>>& a, const vector<vector<ll>>& b) {\\n        vector<vector<ll>> r(3, vector<ll>(3, 0));\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                for (int k = 0; k < 3; k++) {\\n                    r[i][j] += a[i][k] * b[k][j];\\n                }\\n                r[i][j] %= M;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nf(i) = f(i - 1) + f(i -2) + 2g(i - 1)\\ng(i) = g(i - 1) + f(i - 2)\\n```\n```\\n[1, 1, 2] [f(i-1), f(i-2), g(i-1)]^T = f(i)  // ^T: matrix\\'s transpose\\n```\n```\\n[1, 0, 0] [f(i-1), f(i-2), g(i-1)]^T = f(i-1)\\n[0, 1, 1] [f(i-1), f(i-2), g(i-1)]^T = g(i)\\n```\n```\\n/ 1 1 2 \\\\  /f(i-1)\\\\     / f(i) \\\\\\n| 1 0 0 |  |f(i-2)|  =  |f(i-1)|\\n\\\\ 0 1 1 /  \\\\g(i-1)/     \\\\ g(i) /\\n```\n```\\n/ 1 1 2 \\\\  / 1 1 2 \\\\  /f(2)\\\\     /f(4)\\\\\\n| 1 0 0 |  | 1 0 0 |  |f(1)|  =  |f(3)|\\n\\\\ 0 1 1 /  \\\\ 0 1 1 /  \\\\g(2)/     \\\\g(4)/\\n```\n```\\n[f(N), f(N - 1), g(N)]^T = R^(N - 2) * [f(2), f(1), g(2)]^T\\n```\n```cpp\\n/*\\n/ 1 1 2 \\\\  /f(i-1)\\\\     / f(i) \\\\\\n| 1 0 0 |  |f(i-2)|  =  |f(i-1)|\\n\\\\ 0 1 1 /  \\\\g(i-1)/     \\\\ g(i) /\\n*/\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        if (N <= 2) return N;\\n        vector<vector<ll>> r;\\n        r.push_back({1, 1, 2});\\n        r.push_back({1, 0, 0});\\n        r.push_back({0, 1, 1});\\n        r = power(r, N - 2);\\n        return (r[0][0] * 2 + r[0][1] + r[0][2]) % M;\\n    }\\n    \\n    vector<vector<ll>> power(vector<vector<ll>>& x, int n) {\\n        if (n == 1) return x;\\n        int m = n >> 1;\\n        auto r = power(x, m);\\n        r = multiply(r, r);\\n        if (n & 1) {\\n            r = multiply(r, x);\\n        }\\n        return r;\\n    }\\n    \\nprivate:\\n    vector<vector<ll>> multiply(const vector<vector<ll>>& a, const vector<vector<ll>>& b) {\\n        vector<vector<ll>> r(3, vector<ll>(3, 0));\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                for (int k = 0; k < 3; k++) {\\n                    r[i][j] += a[i][k] * b[k][j];\\n                }\\n                r[i][j] %= M;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944977,
                "title": "java-dp-in-a-different-way-explained-and-commented",
                "content": "# Intuition\\nThe idea in this problem is to figure out the transitions we can make.\\n\\nBasically we have the following transitions:\\n\\n* Put a 2x1 tile ( | ) then we move to the next column.\\n* Put a 1x2 tile ( _ ) then we must match below and move i+2 column.\\n* Put an L shape tromino. Then we either close with inverted L or put _ above\\n* The previous point can also be inverted therefore we multiply the result by 2 of that transition.\\n\\nThe flag `isAdjacentTaken` in the code is for situations where we put an L shape tromino and move to the next column. In this situation, the row beneath (or above because we can invert the tromino) is taken. This is a unique state that we need to account for.\\n\\n![image.png](https://assets.leetcode.com/users/images/3528a929-a120-43c2-b3cc-3ad326cddd10_1671870454.7892098.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n\\n    public int numTilings(int n) {\\n        long[][] dp = new long[n][2];\\n        for (long[] A : dp) {\\n            Arrays.fill(A, -1);\\n        }\\n        return (int) solve(0, n, false, dp);\\n    }\\n\\n    public long solve(int i, int n, boolean isAdjacentTaken, long[][] dp) {\\n        if (i == n && !isAdjacentTaken) return 1;\\n        if (i >= n) return 0;\\n        if (dp[i][isAdjacentTaken ? 0 : 1] != -1) return dp[i][isAdjacentTaken ? 0 : 1];\\n\\n        long ans = 0;\\n        if (!isAdjacentTaken) {\\n            ans += solve(i + 1, n, false, dp); // if we put 2x1 tile\\n            ans += solve(i + 2, n, false, dp); // 1x2 tiles twice\\n            ans += 2 * solve(i + 1, n, true, dp); // L shape (and inverted L)\\n        } else {\\n            ans += solve(i + 1, n, true, dp); // 1x2 tile and go down\\n            ans += solve(i + 2, n, false, dp); // L to close\\n        }\\n        ans %= MOD;\\n        return dp[i][isAdjacentTaken ? 0 : 1] = ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n\\n    public int numTilings(int n) {\\n        long[][] dp = new long[n][2];\\n        for (long[] A : dp) {\\n            Arrays.fill(A, -1);\\n        }\\n        return (int) solve(0, n, false, dp);\\n    }\\n\\n    public long solve(int i, int n, boolean isAdjacentTaken, long[][] dp) {\\n        if (i == n && !isAdjacentTaken) return 1;\\n        if (i >= n) return 0;\\n        if (dp[i][isAdjacentTaken ? 0 : 1] != -1) return dp[i][isAdjacentTaken ? 0 : 1];\\n\\n        long ans = 0;\\n        if (!isAdjacentTaken) {\\n            ans += solve(i + 1, n, false, dp); // if we put 2x1 tile\\n            ans += solve(i + 2, n, false, dp); // 1x2 tiles twice\\n            ans += 2 * solve(i + 1, n, true, dp); // L shape (and inverted L)\\n        } else {\\n            ans += solve(i + 1, n, true, dp); // 1x2 tile and go down\\n            ans += solve(i + 2, n, false, dp); // L to close\\n        }\\n        ans %= MOD;\\n        return dp[i][isAdjacentTaken ? 0 : 1] = ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353813,
                "title": "recursive-dp-and-iterative-dp-how-i-d-approach-this-in-an-interview",
                "content": "## Approach\\nAfter spending less than a minute on the problem, you\\'ll quickly realize that this is a classical DP problem. So we need to come up with base cases and figure out how to divide a bigger problem into smaller ones or in other words, derive recurrence relations.\\n\\n### Deriving the recurrences\\n\\nLet\\'s define the function `F(n)` = number of ways to solve for a `2 x n` grid \\nFor a `2 x n` grid, we can use either a domino or a tromino.\\n*  **Domino**: If we put the domino vertically, we need to solve `2 x (n-1)` grid. If we put the domino horizontally, we have to use another domino horizontally to fill the slot, which means we need to solve `2 x (n-2)` grid. So choosing a domino requires us to solve sub problems of size `n-1` and `n-2` \\n*  **Tromino**: We can put a tromino in two valid ways, both of which are symmetric sub-problems, but these subproblems are of a different kind. They have one additional tile which can be filled by a domino or a tromino. So we need to define another function:\\n`G(n)` = number of ways to solve a `2 x n` grid with an additional empty tile to fill (at `n+1`st level)\\n\\nFor `G(n)` we have two valid choices:\\n* **Domino**: If we put a domino to fill the additional empty tile, we are left with another empty tile, but the problem reduces by 1 in size namely, `G(n-1)`\\n* **Tromino**: If we use a tromino, we will fill that empty tile and the new problem to solve is `F(n-1)`\\n\\n### Base cases\\nSince we have to fill a `2 x n`  grid, an obvious base case is `2 x 1`. But since we also have a tromino which would not fit in a `2 x 1` grid, we also want to consider `2 x 2` grid for the base case. \\n* For function `F` \\n\\t* A `2 x 1` grid can only be filled with one domino in one way. \\n\\t* A `2 x 2` grid can be filled with only dominoes, but in 2 different ways - both vertical or both horizontal. \\n* For function `G`\\n\\t* A `2 x 1` grid with an additional empty tile can be filled in only one way, by using a tromino.\\n\\t* A `2 x 2` grid with an additional empty tile can be filled in two ways, both by using a domino and a tromino in different configurations.\\n\\nNow we can write the base cases and recurrence relations as follows:\\n```\\n    F(1) = G(1) = 1\\n    F(2) = G(2) = 2\\n    F(n) = F(n-1) + F(n-2) + 2 * G(n-2)\\n    G(n) = F(n-1) + G(n-1)\\n```    \\n\\n### Recursive solution in Python\\n\\n```\\nF(n) = find(n, False)\\nG(n) = find(n, True)\\n```\\n\\n```\\n    def numTilings(self, n: int) -> int:\\n        M = 10**9+7\\n        @cache\\n        def find(m, extra = False):\\n            if m < 3: return m\\n            if extra: return (find(m-1) + find(m-1, True)) % M\\n            return (find(m-1) + find(m-2) + 2*find(m-2, True)) % M\\n            \\n        return find(n)\\n```\\n\\n* `O(n)` time \\n* `O(n)` space due to recursion stack\\n\\n### Iterative solution in Python\\n```\\n    def numTilings(self, n: int) -> int:\\n        if n < 3: return n\\n        M = 10**9+7\\n        F1 = G1 = 1\\n        F2 = G2 = 2\\n        for i in range(n-2): \\n\\t\\t\\tF1, G1, F2, G2 = F2, G2, (F2+F1+2*G1)%M, (F2+G2)%M\\n        return F2\\n```\\n* `O(n)` time \\n* `O(1)` space\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    F(1) = G(1) = 1\\n    F(2) = G(2) = 2\\n    F(n) = F(n-1) + F(n-2) + 2 * G(n-2)\\n    G(n) = F(n-1) + G(n-1)\\n```\n```\\nF(n) = find(n, False)\\nG(n) = find(n, True)\\n```\n```\\n    def numTilings(self, n: int) -> int:\\n        M = 10**9+7\\n        @cache\\n        def find(m, extra = False):\\n            if m < 3: return m\\n            if extra: return (find(m-1) + find(m-1, True)) % M\\n            return (find(m-1) + find(m-2) + 2*find(m-2, True)) % M\\n            \\n        return find(n)\\n```\n```\\n    def numTilings(self, n: int) -> int:\\n        if n < 3: return n\\n        M = 10**9+7\\n        F1 = G1 = 1\\n        F2 = G2 = 2\\n        for i in range(n-2): \\n\\t\\t\\tF1, G1, F2, G2 = F2, G2, (F2+F1+2*G1)%M, (F2+G2)%M\\n        return F2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 182591,
                "title": "javascript-simple-dp-with-graphic-explanations-about-the-equations",
                "content": "### DP\\n`dp[i][0]` means the possibilities when the first `i` columns are full;\\n`dp[i][1]` means the possibilities when the first `i-1` columns are full and the `ith` column has only one item.\\n\\n---------\\n\\n### Equations\\n`dp[i][0] = dp[i-2][0] + dp[i-1][1] + dp[i-1][0];`\\n```\\ndp[i-2][0] ---> dp[i][0]\\n*...*AA\\n*...*BB\\n```\\n```\\ndp[i-1][1] ---> dp[i][0]\\n*...**A\\n*...*AA\\nor\\n*...*AA\\n*...**A\\nPS: dp[i-1][1] already includes the two possibilities above, so no need to multiply 2.\\n```\\n```\\ndp[i-1][0] ---> dp[i][0]\\n*...**A\\n*...**A\\n```\\n`dp[i][1] = dp[i-2][0] * 2 + dp[i-1][1]`\\n```\\ndp[i-2][0]*2 ---> dp[i][1]\\n*...*AA\\n*...*A\\nand\\n*...*A\\n*...*AA\\n```\\n```\\ndp[i-1][1] ---> dp[i][1]\\n*...**\\n*...*AA\\nor\\n*...*AA\\n*...**\\nPS: dp[i-1][1] already includes the two possibilities above, so no need to multiply 2.\\n```\\n\\n-------\\n\\n### Code\\n```\\nvar numTilings = function(N) {\\n    let mod=1e9+7;\\n    let dp=Array.from({length:N+1}, x=>[0,0]);\\n    dp[1][0]=1;\\n    dp[1][1]=0;\\n    if(N>1) dp[2][0]=dp[2][1]=2;\\n    for(let i=3; i<=N; i++){\\n        dp[i][0]=(dp[i-2][0]+dp[i-1][1]+dp[i-1][0])%mod;\\n        dp[i][1]=(dp[i-2][0]*2+dp[i-1][1])%mod;\\n    }\\n    return dp[N][0];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i-2][0] ---> dp[i][0]\\n*...*AA\\n*...*BB\\n```\n```\\ndp[i-1][1] ---> dp[i][0]\\n*...**A\\n*...*AA\\nor\\n*...*AA\\n*...**A\\nPS: dp[i-1][1] already includes the two possibilities above, so no need to multiply 2.\\n```\n```\\ndp[i-1][0] ---> dp[i][0]\\n*...**A\\n*...**A\\n```\n```\\ndp[i-2][0]*2 ---> dp[i][1]\\n*...*AA\\n*...*A\\nand\\n*...*A\\n*...*AA\\n```\n```\\ndp[i-1][1] ---> dp[i][1]\\n*...**\\n*...*AA\\nor\\n*...*AA\\n*...**\\nPS: dp[i-1][1] already includes the two possibilities above, so no need to multiply 2.\\n```\n```\\nvar numTilings = function(N) {\\n    let mod=1e9+7;\\n    let dp=Array.from({length:N+1}, x=>[0,0]);\\n    dp[1][0]=1;\\n    dp[1][1]=0;\\n    if(N>1) dp[2][0]=dp[2][1]=2;\\n    for(let i=3; i<=N; i++){\\n        dp[i][0]=(dp[i-2][0]+dp[i-1][1]+dp[i-1][0])%mod;\\n        dp[i][1]=(dp[i-2][0]*2+dp[i-1][1])%mod;\\n    }\\n    return dp[N][0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947428,
                "title": "best-python-solution-simple-dp-soln-no-complex-full-partial-case-equation-needed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink like we are filling a 2xn matrix with given blocks. First row count is tracked by i and second row count is tracked by j.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen i=j we can put 4 blocks.\\n![Screenshot 2022-12-24 at 3.44.04 PM.png](https://assets.leetcode.com/users/images/8041d634-cb53-48fd-9ee8-207b37aee883_1671918312.788086.png)\\n\\nwhen i>j we can put 2 blocks.\\n![Screenshot 2022-12-24 at 3.44.33 PM.png](https://assets.leetcode.com/users/images/df2a5d14-5a8e-4d88-98c8-3610518ce7cf_1671918368.1857407.png)\\n\\n\\nwhen i<j we can put 2 blocks.\\n![Screenshot 2022-12-24 at 3.44.53 PM.png](https://assets.leetcode.com/users/images/e0250c0c-258b-4e3e-bdee-845f6e1c556c_1671918381.1000497.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        conf = defaultdict(list)\\n        conf[1] = [[1,1],[2,2],[2,1],[1,2]]  ##4 possible blocks when i==j\\n        conf[2] = [[0,2],[1,2]]  ##2 possible blocks when i>j\\n        conf[3] = [[2,0],[2,1]]  ##2 possible blocks when i<j\\n        # @cache\\n        def dp(i,j):\\n            nonlocal conf,n,memo\\n            tempcount = 0\\n\\n            if i==n and j==n:\\n                return 1\\n            if i>n or j>n:\\n                return 0\\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n\\n            if (i==j):\\n                for c in conf[1]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            if (i>j):\\n                for c in conf[2]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            if (i<j):\\n                for c in conf[3]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            \\n            memo[(i,j)] = tempcount\\n            return tempcount\\n        \\n        memo = {}\\n        res = dp(0,0)\\n        \\n        return res%(10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        conf = defaultdict(list)\\n        conf[1] = [[1,1],[2,2],[2,1],[1,2]]  ##4 possible blocks when i==j\\n        conf[2] = [[0,2],[1,2]]  ##2 possible blocks when i>j\\n        conf[3] = [[2,0],[2,1]]  ##2 possible blocks when i<j\\n        # @cache\\n        def dp(i,j):\\n            nonlocal conf,n,memo\\n            tempcount = 0\\n\\n            if i==n and j==n:\\n                return 1\\n            if i>n or j>n:\\n                return 0\\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n\\n            if (i==j):\\n                for c in conf[1]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            if (i>j):\\n                for c in conf[2]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            if (i<j):\\n                for c in conf[3]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            \\n            memo[(i,j)] = tempcount\\n            return tempcount\\n        \\n        memo = {}\\n        res = dp(0,0)\\n        \\n        return res%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947365,
                "title": "python-solution-with-explanation-using-dp",
                "content": "class Solution:\\n\\n    def numTilings(self, n: int) -> int:\\n        dp = [0] * (n + 1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        if n < 2: return dp[n]\\n            \\n        dp[2] = 2\\n        mod = 10**9 + 7\\n        \\n        for i in range(3, n + 1):\\n            dp[i] = (2*dp[i - 1] + dp[i - 3]) % mod\\n            \\n        return dp[n]\\n        \\n        \\n        \\n#For understanding\\n\\n\\n\"\"\"\\ndp[n] = dp[n-1] + dp[n-2] + dp[n-3] * 2 + ... dp[0] * 2:\\nFor all f(n-1), it can be transformed to f(n) by appending a domino |, hence f(n - 1) * 1.\\nFor all f(n - 2), though f(2) contains 2 cases: = and ||, however the case || has been covered by f(n - 1) plus |,\\nso literally there is only one distinct way to transform f(n-2) to f(n), hence f(n - 2) * 1.\\n\\nFor all f(n - i) where i > 2, the ways complementing them to f(n) by dominoes (either horizontal or vertical domino) have been covered by f(n - 1) and f(n - 2),\\nhence the remaining distinct ways are either appending triminoes or combination of triminoes and dominoes. And there are always only 2 ways to do this (as demonstrated in the picture in this post), all of them can be considered as derived from either f(3) or f(4) by adding dominoes.\\n\\n#. dp[n - 1], and dp[n - 2] have one way to transform to dp[n]\\n#. dp[n - 3], ..., dp[1], dp[0], have two way to transform to dp[n]\\n  so,         dp[n] = dp[n-1] + dp[n-2] + 2 * (dp[n-3] + ... + dp[0]) -- E1\\n  shift one:  dp[n-1] = dp[n-2] + dp[n-3] + 2 * (dp[n-4] + ... + dp[0]) -- E2\\n E1 - E2:     dp[n] - dp[n-1] = dp[n-1] + dp[n-3]  \\n E1 - E2:     --> dp[n] = 2*dp[n-1] + dp[n-3]\\n\"\"\"\\nplz upvote if you like it!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\n    def numTilings(self, n: int) -> int:\\n        dp = [0] * (n + 1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        if n < 2: return dp[n]\\n            \\n        dp[2] = 2\\n        mod = 10**9 + 7\\n        \\n        for i in range(3, n + 1):\\n            dp[i] = (2*dp[i - 1] + dp[i - 3]) % mod\\n            \\n        return dp[n]\\n        \\n        \\n        \\n#For understanding\\n\\n\\n\"\"\"\\ndp[n] = dp[n-1] + dp[n-2] + dp[n-3] * 2 + ... dp[0] * 2:\\nFor all f(n-1), it can be transformed to f(n) by appending a domino |, hence f(n - 1) * 1.\\nFor all f(n - 2), though f(2) contains 2 cases: = and ||, however the case || has been covered by f(n - 1) plus |,\\nso literally there is only one distinct way to transform f(n-2) to f(n), hence f(n - 2) * 1.\\n\\nFor all f(n - i) where i > 2, the ways complementing them to f(n) by dominoes (either horizontal or vertical domino) have been covered by f(n - 1) and f(n - 2),\\nhence the remaining distinct ways are either appending triminoes or combination of triminoes and dominoes. And there are always only 2 ways to do this (as demonstrated in the picture in this post), all of them can be considered as derived from either f(3) or f(4) by adding dominoes.\\n\\n#. dp[n - 1], and dp[n - 2] have one way to transform to dp[n]\\n#. dp[n - 3], ..., dp[1], dp[0], have two way to transform to dp[n]\\n  so,         dp[n] = dp[n-1] + dp[n-2] + 2 * (dp[n-3] + ... + dp[0]) -- E1\\n  shift one:  dp[n-1] = dp[n-2] + dp[n-3] + 2 * (dp[n-4] + ... + dp[0]) -- E2\\n E1 - E2:     dp[n] - dp[n-1] = dp[n-1] + dp[n-3]  \\n E1 - E2:     --> dp[n] = 2*dp[n-1] + dp[n-3]\\n\"\"\"\\nplz upvote if you like it!",
                "codeTag": "Java"
            },
            {
                "id": 2945687,
                "title": "dp-solution-o-n-time-and-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs this problem includes tromino, it can happen that one column is partially filled, we will need an extra state ```filled``` to provide us with info if the column is partially filled or not.\\n\\nSo there will be two states in our dp solution ```col``` and ```filled```.\\n\\nCase 1: If the column is partially filled then we have two choices, first is to use a valid domino, which will result in partial filling in next column and second choice is to use tromino which will remove the partial filling.\\n\\nCase 2: If the column is not prtially filled, then we can either choose one vertical domino and move to ```col+1```, or use two horizontal domino and move to ```col+2``` both of these will not result in partial filling but if we choose to use tromino we will have a partial filling at ```col+1```. \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int recurse(int col, int filled,vector<vector<long long int>> &dp){\\n        int n = dp.size();\\n        if(col >= n || (col==n-1 && filled==0)) return 1;\\n        if(col == n-1 && filled == 1) return 0;\\n\\n        if(dp[col][filled] != -1) return dp[col][filled];\\n        if(filled == 0){\\n                return dp[col][filled] = (recurse(col+2,0,dp)+(2*recurse(col+1,1,dp))+recurse(col+1,0,dp))%1000000007;\\n        }\\n        else{\\n            return dp[col][filled]= (recurse(col+1,1,dp) + recurse(col+2,0,dp))%1000000007;\\n        }\\n\\n        return 0;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n,vector<long long int>(2,-1));\\n\\n        return recurse(0,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```filled```\n```col```\n```filled```\n```col+1```\n```col+2```\n```col+1```\n```\\nclass Solution {\\npublic:\\n    long long int recurse(int col, int filled,vector<vector<long long int>> &dp){\\n        int n = dp.size();\\n        if(col >= n || (col==n-1 && filled==0)) return 1;\\n        if(col == n-1 && filled == 1) return 0;\\n\\n        if(dp[col][filled] != -1) return dp[col][filled];\\n        if(filled == 0){\\n                return dp[col][filled] = (recurse(col+2,0,dp)+(2*recurse(col+1,1,dp))+recurse(col+1,0,dp))%1000000007;\\n        }\\n        else{\\n            return dp[col][filled]= (recurse(col+1,1,dp) + recurse(col+2,0,dp))%1000000007;\\n        }\\n\\n        return 0;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n,vector<long long int>(2,-1));\\n\\n        return recurse(0,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944263,
                "title": "simple-java-solution-beats-100-with-o-n-with-explanation",
                "content": "* Mathematical  Analysis\\n   Case-----------Answer\\n   n = 1__________1\\n   n = 2__________2\\n   n = 3__________5\\n   n = 4__________11\\n   n = 5__________24\\n\\n   so the series is following \\n    f(n) = f(n-1)*2 + f(n-3)                    \\n\\n*--------------------------------------------------------------\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if (n == 1) return 1;\\n        if (n == 2) return 2;\\n        long[] dp = new long[n + 1];\\n        int mod = 1000000007;\\n        dp[0] = 1; dp[1] = 1; dp[2] = 2;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % mod;\\n        }\\n        return (int) dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if (n == 1) return 1;\\n        if (n == 2) return 2;\\n        long[] dp = new long[n + 1];\\n        int mod = 1000000007;\\n        dp[0] = 1; dp[1] = 1; dp[2] = 2;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % mod;\\n        }\\n        return (int) dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893115,
                "title": "sneeit-solution-domino-and-tromino-tiling-with-explanation",
                "content": "(This problem is solved using Dynamic Programming that you can learn at: **https://sneeit.com/dynamic-progamming/**)\\n\\n.\\n____\\n# Explanation\\nYou can form a board i from\\n* board i - 1 by adding ![image](https://assets.leetcode.com/users/images/99002dbe-1c70-4fbd-95e2-7c75a97f8ca8_1648522000.2958794.png)\\n* board i - 2 by adding ![image](https://assets.leetcode.com/users/images/e386bb15-1ba4-4388-a49e-6bd507c29217_1648522039.1159534.png)\\n* board i - 3 by adding ![image](https://assets.leetcode.com/users/images/ec0b84fb-e0da-4959-9ea1-3efe45209ccd_1648522175.4989698.png) or ![image](https://assets.leetcode.com/users/images/3bcefba5-a1c4-479f-97e5-7058753e3b46_1657612458.5683823.png)\\n* board i - 4 by adding ![image](https://assets.leetcode.com/users/images/265834f4-c062-42e3-a3e8-65812f996c7f_1648522281.5093086.png) or ![image](https://assets.leetcode.com/users/images/92497a5d-049c-443a-b50c-f3df0ef61905_1648522286.097149.png)\\n* board i - 5 by adding ![image](https://assets.leetcode.com/users/images/0f123209-94e9-43b1-acae-5c061f8fb559_1648522367.9747984.png) or ![image](https://assets.leetcode.com/users/images/03d44911-1155-437c-8dd3-1baf54cabb6f_1648522391.3840377.png)\\n* board i - 6 to board 0 can use the same tile textures like board i - 5 to build board i\\n\\nSo the total ways to build board i is\\nways[i] = ways[i-1] + ways[i-2] + 2 * ( ways[i-3] + ways[i-4] + ... + ways[0] )\\n\\nIf we extract the formula like this\\nways[i] = ways[i-1] + ***ways[i-2] + ways[i-3] + 2  ( ways[i-4] + ... + ways[0] )*** + ways[i-3]\\nways[i] = ways[i-1] + **ways[i-1]** + ways[i-3]\\nways[i] = 2 * ways[i-1] + ways[i-3]\\n\\nThere are always 4 variables involved in calculating our results so we can use an array of 4 to reduce our space. And here is the final code\\n.\\n____\\n# Bottom-Up O(n) Time, O(1) Space\\n```\\nvar numTilings = function(n) {\\n    let mod = 10 ** 9 + 7;    \\n    let len = 4;\\n    let ways = new Array(len).fill(0);\\n\\n    // base cases\\n    ways[0] = 1;\\n    ways[1] = 1;\\n    ways[2] = 2;\\n\\n    // already calculated above\\n    if (n < len - 1) {\\n        return ways[n];\\n    }    \\n\\n    // use % len to circulate values inside our array\\n    for (var i = len - 1; i <= n;i++) {        \\n        ways[i % len] = ( \\n            ways[(len + i - 1) % len] * 2\\n            + \\n            ways[(len + i - 3) % len] \\n        ) % mod;          \\n    }\\n    \\n    return ways[(i - 1) % len];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar numTilings = function(n) {\\n    let mod = 10 ** 9 + 7;    \\n    let len = 4;\\n    let ways = new Array(len).fill(0);\\n\\n    // base cases\\n    ways[0] = 1;\\n    ways[1] = 1;\\n    ways[2] = 2;\\n\\n    // already calculated above\\n    if (n < len - 1) {\\n        return ways[n];\\n    }    \\n\\n    // use % len to circulate values inside our array\\n    for (var i = len - 1; i <= n;i++) {        \\n        ways[i % len] = ( \\n            ways[(len + i - 1) % len] * 2\\n            + \\n            ways[(len + i - 3) % len] \\n        ) % mod;          \\n    }\\n    \\n    return ways[(i - 1) % len];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620920,
                "title": "easy-to-understand-in-c-d-p-bottom-up",
                "content": "**This is the best Approach by D.p(Bottom-up)**\\ndp[0]=0;\\ndp[1]=1;\\ndp[2]=2;\\ndp[3]=5;\\n**Than by Observation:-**\\n   dp[4]=( 2*dp[i-1]+dp[i-3])\\n            =2(5)+1;\\n\\t\\t\\t=11\\n\\nclass Solution {\\npublic:\\n\\n    #define mod 1000000007\\n    int numTilings(int n) {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        if(n==3){\\n            return 5;\\n        }\\n        vector<int>dp(n+1,0);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        for(int i=4;i<=n;i++){\\n            dp[i] = ((2*(dp[i-1])%mod)%mod +(dp[i-3])%mod)%mod;\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    #define mod 1000000007\\n    int numTilings(int n) {\\n        if(n==1){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1370968,
                "title": "c-dp-solution-o-n-time-and-space-with-intuition",
                "content": "```\\nint numTilings(int n) {\\n        \\n        if(n == 1)\\n            return 1;\\n        \\n        long long mod = 1e9+7;\\n     \\n        vector<long long int> dp1(n + 1, 0);\\n        vector<long long int> dp2(n + 1, 0);\\n        vector<long long int> dp3(n + 1, 0);\\n        \\n        /*\\n\\t\\t\\tUsing 1-indexed Levels\\n            dp1[i] denotes the number of ways with all cols from 1 to i filled\\n            dp2[i] denotes the number of ways with all cols from 1 to i - 1 filled and only top grid in col i is filled\\n            dp3[i] denotes the number of ways with all cols from 1 to i - 1 filled and only bottom grid in col i is filled\\n        \\n            to return dp1[n]\\n            \\n            Base Cases:\\n            dp1[1] = 1\\n            dp1[2] = 2\\n            \\n            dp2[1] = 0; dp2[2] = 1\\n            dp3[1] = 0; dp3[2] = 1;\\n            \\n            DP relation: (for all i >= 3)\\n            \\n            dp1[i] = dp1[i - 1] (add 1 vertical domino) + dp1[i - 2] (add 2-horizontal dominoes)  + dp2[i - 1] (add 1 tromino in _| manner) + dp3[i - 1] (add 1 tromino such that top space in i - 1 col and i col gets filled)\\n            \\n            dp2[i] = dp1[i - 2] (put one tribonaaci) + dp3[i - 1] (put on domino in horizontal fashion)\\n            \\n            similarly => dp3[i] = dp1[i - 2] + dp2[i - 1]\\n        */\\n        \\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n\\n        dp2[1] = 0;\\n        dp2[2] = 1;\\n        \\n        dp3[1] = 0;\\n        dp3[2] = 1;\\n\\n        \\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp1[i] = (dp1[i - 1] + dp1[i - 2] + dp2[i - 1]+ dp3[i - 1]) % mod;\\n            dp2[i] = (dp1[i - 2] + dp3[i - 1]) % mod;\\n            dp3[i] = (dp1[i - 2] + dp2[i - 1]) % mod;\\n        }\\n        \\n        return dp1[n];\\n    }\\n```\\n\\nYou can see by symmetry that the values of dp2[i] and dp3[i] would be the same. Hence we can reduce the space constraint by a whole vector. However, at the same time it is important to not that the two sub-problems are different and not the same.\\n\\n```\\n//Improved DP\\n\\n  for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp1[i] = (dp1[i - 1] + dp1[i - 2] + 2*dp2[i - 1]) % mod;\\n            dp2[i] = (dp1[i - 2] + dp2[i - 1]) % mod;\\n        }\\n        \\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint numTilings(int n) {\\n        \\n        if(n == 1)\\n            return 1;\\n        \\n        long long mod = 1e9+7;\\n     \\n        vector<long long int> dp1(n + 1, 0);\\n        vector<long long int> dp2(n + 1, 0);\\n        vector<long long int> dp3(n + 1, 0);\\n        \\n        /*\\n\\t\\t\\tUsing 1-indexed Levels\\n            dp1[i] denotes the number of ways with all cols from 1 to i filled\\n            dp2[i] denotes the number of ways with all cols from 1 to i - 1 filled and only top grid in col i is filled\\n            dp3[i] denotes the number of ways with all cols from 1 to i - 1 filled and only bottom grid in col i is filled\\n        \\n            to return dp1[n]\\n            \\n            Base Cases:\\n            dp1[1] = 1\\n            dp1[2] = 2\\n            \\n            dp2[1] = 0; dp2[2] = 1\\n            dp3[1] = 0; dp3[2] = 1;\\n            \\n            DP relation: (for all i >= 3)\\n            \\n            dp1[i] = dp1[i - 1] (add 1 vertical domino) + dp1[i - 2] (add 2-horizontal dominoes)  + dp2[i - 1] (add 1 tromino in _| manner) + dp3[i - 1] (add 1 tromino such that top space in i - 1 col and i col gets filled)\\n            \\n            dp2[i] = dp1[i - 2] (put one tribonaaci) + dp3[i - 1] (put on domino in horizontal fashion)\\n            \\n            similarly => dp3[i] = dp1[i - 2] + dp2[i - 1]\\n        */\\n        \\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n\\n        dp2[1] = 0;\\n        dp2[2] = 1;\\n        \\n        dp3[1] = 0;\\n        dp3[2] = 1;\\n\\n        \\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp1[i] = (dp1[i - 1] + dp1[i - 2] + dp2[i - 1]+ dp3[i - 1]) % mod;\\n            dp2[i] = (dp1[i - 2] + dp3[i - 1]) % mod;\\n            dp3[i] = (dp1[i - 2] + dp2[i - 1]) % mod;\\n        }\\n        \\n        return dp1[n];\\n    }\\n```\n```\\n//Improved DP\\n\\n  for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp1[i] = (dp1[i - 1] + dp1[i - 2] + 2*dp2[i - 1]) % mod;\\n            dp2[i] = (dp1[i - 2] + dp2[i - 1]) % mod;\\n        }\\n        \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136076,
                "title": "simple-dp-explained-c",
                "content": "Explaination:\\ndp[i][1] -> represents number of ways to fill i tiles(length) and ending tile is completely filled\\ndp[i][0] -> represents number of ways to fill i tiles(length) but ending tile has only one tile filled out of the two.\\n\\nSo we derive the relation:\\ndp[i][1] = dp[i-1][1] (*fill tiles till i-1 and put a 2x1 tile standing with height as 2*)\\n\\\\+ dp[i-2][1] (*fill tiles till i-2 and put two 2x1 tiles sitting on top of each other with length as 2*)  \\n\\\\+ dp[i-1][0] (*fill tiles till i-2 completely but fill only one tile in i-1, and we put a L-shaped tile on the remaining*)\\n\\ndp[i][0] = (dp[i-2][1]\\\\*2) (*completely fill till i-2 and then we can fill the last two tiles by putting 1 L-shaped tile, so that last tile\\'s one part remains*)\\n\\\\+ dp[i-1][0] (*fill with last tile remaining a part, and add 2x1 tile in the end horizontally*)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        int mod = 1000000007;\\n        int dp[N+1][2];\\n        dp[0][1] = 1, dp[0][0] = 0;\\n        dp[1][1] = 1, dp[1][0] = 0;\\n        \\n        for(int i=2; i<N+1; i++){\\n            dp[i][1] = ((dp[i-1][1] + dp[i-2][1])%mod + (dp[i-1][0])%mod)%mod;\\n            dp[i][0] = ((dp[i-2][1]*2)%mod + (dp[i-1][0])%mod)%mod;\\n        }\\n        return dp[N][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        int mod = 1000000007;\\n        int dp[N+1][2];\\n        dp[0][1] = 1, dp[0][0] = 0;\\n        dp[1][1] = 1, dp[1][0] = 0;\\n        \\n        for(int i=2; i<N+1; i++){\\n            dp[i][1] = ((dp[i-1][1] + dp[i-2][1])%mod + (dp[i-1][0])%mod)%mod;\\n            dp[i][0] = ((dp[i-2][1]*2)%mod + (dp[i-1][0])%mod)%mod;\\n        }\\n        return dp[N][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116536,
                "title": "easy-and-very-concise-clear-in-java",
                "content": "```\nclass Solution {\n    static final int mod = 1000000007;\n    public int numTilings(int N) {\n        int dp[] = new int[N + 10];\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 2;\n        dp[3] = 5;\n        for(int i = 4 ; i <= N; i++){\n            dp[i] = dp[i - 1] * 2 % mod + dp[i - 3] % mod;\n            dp[i] %= mod;\n        }\n        return dp[N];\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    static final int mod = 1000000007;\n    public int numTilings(int N) {\n        int dp[] = new int[N + 10];\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 2;\n        dp[3] = 5;\n        for(int i = 4 ; i <= N; i++){\n            dp[i] = dp[i - 1] * 2 % mod + dp[i - 3] % mod;\n            dp[i] %= mod;\n        }\n        return dp[N];\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 116531,
                "title": "o-1-time-o-n-space-solution-3ms",
                "content": "    constexpr uint64_t CON = 1000000007;\n    \n    constexpr uint64_t func(int i) {\n        if (i == 0) return 1;\n        if (i == 1) return 1;\n        if (i == 2) return 2;\n        return (func(i - 1) * 2 % CON + func(i - 3)) % CON;\n    }\n    \n    template<uint64_t... i>\n    constexpr auto calc(index_sequence<i...>) {\n        return array<uint64_t, sizeof...(i)>{func(i)...};\n    }\n    \n    template<uint64_t size>\n    constexpr auto calc() {\n        return calc(make_index_sequence<size>());\n    }\n    \n    constexpr auto f = calc<1000>();\n    \n    class Solution {\n    public:\n        int numTilings(int N) {\n            return f[N];\n        }\n    };",
                "solutionTags": [],
                "code": "class Solution {\n    public:\n        int numTilings(int N) {\n            return f[N];\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3237546,
                "title": "recursion-solution-state-machine-approach",
                "content": "# Intuition\\nthink like in start we have the 0th column empty so we need to fill it first we have four ways to fill it(here 0 means emplty cell 1 means filled) see last ifelse condition. u^d means if upper is epmty ans lower is filled or vice verca then we have 2 ways use a trainagular peice or a horizonatal peice . if both is 1 then simply we ask i+1 for 0 0.\\nbase case is wehn we go ou of block i.e i==n then both up and down shuould be 0 0 \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nstate machine approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst unsigned int M = 1000000007;\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[1000][2][2];\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0);\\n        // return 0;\\n        \\n    }\\n    int f(int i,bool u , bool d){\\n        if(i==n ){\\n            if(!u && !d) return 1;\\n            return 0;\\n        }\\n        if(dp[i][u][d]!=-1) return dp[i][u][d];\\n        int ans=0;\\n        \\n        if(u^d){\\n            ans+=f(i+1,1,1)%M;//1 traingular \\n            ans+=f(i+1,!u,!d)%M;//1 horizontal \\n        }\\n        \\n        else if(u==1 && d==1) ans+=f(i+1,0,0)%M;//just empty cel;\\n        else if(u==0 && d==0){\\n            ans+=f(i+1,1,1)%M;//2 horizontal\\n            ans+=f(i+1,0,0)%M;//1 vertical\\n            ans+=f(i+1,0,1)%M;//1 traiangualar \\n            ans+=f(i+1,1,0)%M;//1 down triangular\\n        }\\n        return dp[i][u][d]=ans%M;\\n    }\\n};\\n```\\n\\nplease upvote if you liked it.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nconst unsigned int M = 1000000007;\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[1000][2][2];\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0);\\n        // return 0;\\n        \\n    }\\n    int f(int i,bool u , bool d){\\n        if(i==n ){\\n            if(!u && !d) return 1;\\n            return 0;\\n        }\\n        if(dp[i][u][d]!=-1) return dp[i][u][d];\\n        int ans=0;\\n        \\n        if(u^d){\\n            ans+=f(i+1,1,1)%M;//1 traingular \\n            ans+=f(i+1,!u,!d)%M;//1 horizontal \\n        }\\n        \\n        else if(u==1 && d==1) ans+=f(i+1,0,0)%M;//just empty cel;\\n        else if(u==0 && d==0){\\n            ans+=f(i+1,1,1)%M;//2 horizontal\\n            ans+=f(i+1,0,0)%M;//1 vertical\\n            ans+=f(i+1,0,1)%M;//1 traiangualar \\n            ans+=f(i+1,1,0)%M;//1 down triangular\\n        }\\n        return dp[i][u][d]=ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947380,
                "title": "pyhton-easy-to-undestand-formula-explanation-98-in-run-time",
                "content": "**The Formule:**\\nif i = 1 -> 1\\nif i = 2 -> 2 \\nif i = 3 -> 5\\nelse:\\nA[i] = A[i-1] * 2 + A[i-3]\\n\\n\\n<table>\\n<tr>\\n<td><b>n</b></td>\\n<td><b>Output</b></td>\\n<td><b>Formula</b></td>\\n<td><b>Assignment</b></td>\\n</tr>\\n\\n<tr>\\n<td>1</td>\\n<td>1</td>\\n</tr>\\n\\n<tr>\\n<td>2</td>\\n<td>2</td>\\n</tr>\\n\\n<tr>\\n<td>3</td>\\n<td>5</td>\\n</tr>\\n\\n<tr>\\n<td>4</td>\\n<td>11</td>\\n<td>A[3] * 2 + A[1]</td>\\n<td>5 * 2 + 1 = 11</td>\\n</tr>\\n\\n<tr>\\n<td>5</td>\\n<td>24</td>\\n<td>A[4] * 2 + A[2]</td>\\n<td>11 * 2 + 2 = 24</td>\\n</tr>\\n\\n<tr>\\n<td>6</td>\\n<td>53</td>\\n<td>A[5] * 2 + A[3]</td>\\n<td>24 * 2 + 5 = 53</td>\\n</tr>\\n\\n<tr>\\n<td>7</td>\\n<td>117</td>\\n<td>A[6] * 2 + A[4]</td>\\n<td>53 * 2 + 11 = 117</td>\\n</tr>\\n\\n<tr>\\n<td>8</td>\\n<td>258</td>\\n<td>A[7] * 2 + A[5]</td>\\n<td>117 * 2 + 24 = 258</td>\\n</tr>\\n</table>\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        helper = [1, 2, 5]\\n        if n <= 3:\\n            return helper[n-1]\\n        for i in range(4, n+1):\\n            ans = helper[-1] *2 +helper[0]\\n            helper.pop(0)\\n            helper.append(ans)\\n        return helper[-1]%(10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        helper = [1, 2, 5]\\n        if n <= 3:\\n            return helper[n-1]\\n        for i in range(4, n+1):\\n            ans = helper[-1] *2 +helper[0]\\n            helper.pop(0)\\n            helper.append(ans)\\n        return helper[-1]%(10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945305,
                "title": "c-solution-for-domino-and-tromino-tiling-problem-using-dp",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to use dynamic programming to store and build upon previously calculated solutions.\\n\\nThe function starts by initializing a vector called dp with the first 3 elements already set to the values 1, 2, and 5. These values represent the number of ways to tile a 1x1 grid, a 2x1 grid, and a 3x1 grid, respectively.\\n\\nThe function then checks if the input value n is less than or equal to 3. If it is, it returns the value stored in dp at the index of n, as these are already pre-calculated and do not need further processing.\\n\\nIf n is greater than 3, the function enters a for loop that starts at 4 and continues until it reaches n. For each iteration, it calculates the number of ways to tile a grid using the previous solutions stored in dp. It does this by setting **dp[i]** equal to 2 times **dp[i-1]** plus **dp[i-3]**. It then takes the modulus of this value with the constant mod, which is set to 1e9+7.\\n\\nFinally, the function returns the value stored in dp at the index of n, taking the modulus with mod once again.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is **O(n)** because the for loop iterates n times, and each iteration involves a constant number of operations (calculating the value of dp[i] and taking the modulus).\\n\\n- Space complexity:\\nThe space complexity is **O(n)** because the solution uses a vector called dp to store the calculated solutions. The size of this vector is directly proportional to the input size n, making the space complexity O(n).\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    const long long mod = 1e9+7;\\npublic:\\n    int numTilings(int n) {\\n        vector<long long> dp(1000, 0);\\n        //If n<=3\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        if(n<=3){\\n            return dp[n];\\n        }\\n        //If n>3\\n        for(int i=4;i<=n;i++){\\n            dp[i]=2*dp[i-1]+dp[i-3];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const long long mod = 1e9+7;\\npublic:\\n    int numTilings(int n) {\\n        vector<long long> dp(1000, 0);\\n        //If n<=3\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        if(n<=3){\\n            return dp[n];\\n        }\\n        //If n>3\\n        for(int i=4;i<=n;i++){\\n            dp[i]=2*dp[i-1]+dp[i-3];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753425,
                "title": "c-top-bottom-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    const int N = 1e9 +7;\\n    int dp[1001][1001];\\n    int rec(int row1, int row2){\\n        \\n        if(row1 ==0 and row2==0)\\n            return 1;\\n        \\n        if(row1<0 or row2<0)\\n            return 0;\\n        \\n        if(dp[row1][row2] != 0)\\n            return dp[row1][row2] % N;\\n        \\n        int ans=0;\\n        \\n        if(row1 == row2){\\n            ans= ((ans%N) + (rec(row1-2,row2-2)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-1,row2-1)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-2,row2-1)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-1,row2-2)) %N)%N;    \\n        }\\n        \\n        if(row1 > row2){\\n            \\n            ans = ((ans%N) + (rec(row1 -2,row2)) %N)%N;\\n            ans = ((ans%N) + (rec(row1-2,row2-1)) %N)%N;\\n            \\n        }\\n        \\n        if(row1 < row2){\\n            \\n            ans = ((ans%N) + (rec(row1,row2-2)) %N)%N;\\n            ans = ((ans%N) + (rec(row1-1,row2-2)) %N)%N;\\n            \\n        }\\n            \\n        return dp[row1][row2] = ans %N;\\n    }\\n    \\n    int numTilings(int n) {\\n        return rec(n,n);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    const int N = 1e9 +7;\\n    int dp[1001][1001];\\n    int rec(int row1, int row2){\\n        \\n        if(row1 ==0 and row2==0)\\n            return 1;\\n        \\n        if(row1<0 or row2<0)\\n            return 0;\\n        \\n        if(dp[row1][row2] != 0)\\n            return dp[row1][row2] % N;\\n        \\n        int ans=0;\\n        \\n        if(row1 == row2){\\n            ans= ((ans%N) + (rec(row1-2,row2-2)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-1,row2-1)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-2,row2-1)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-1,row2-2)) %N)%N;    \\n        }\\n        \\n        if(row1 > row2){\\n            \\n            ans = ((ans%N) + (rec(row1 -2,row2)) %N)%N;\\n            ans = ((ans%N) + (rec(row1-2,row2-1)) %N)%N;\\n            \\n        }\\n        \\n        if(row1 < row2){\\n            \\n            ans = ((ans%N) + (rec(row1,row2-2)) %N)%N;\\n            ans = ((ans%N) + (rec(row1-1,row2-2)) %N)%N;\\n            \\n        }\\n            \\n        return dp[row1][row2] = ans %N;\\n    }\\n    \\n    int numTilings(int n) {\\n        return rec(n,n);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390413,
                "title": "rust-dp-with-detailed-recursive-relation",
                "content": "```\\nimpl Solution {\\n    pub fn num_tilings(n: i32) -> i32 {\\n        // DP by considering filling the last column of space\\n        // T(n) = T(n - 1)      | end with one vertical domino\\n        //      + T(n - 2)      | end with two horizontal domino\\n        //      + T_up(n - 1)   | end with trimino filling the former lower grid\\n        //      + T_down(n - 1) | end with trimino filling the former upper grid//\\n        // T_up(n): having an unfilled lower grid, therefore it can be formed by\\n        // T_up(n) = T(n - 2)      | Fully filled followed with a trimino filling lower grid\\n        //         + T_down(n - 1) | T_down(n - 1) with an upper horizontal domino\\n        // T_down(n): equivalent as above\\n        // T_down(n) = T(n - 2)\\n        //           + T_up(n - 1)\\n\\n        // To sum up:\\n        // T(n) = T(n-1) + T(n-2) + T_up(n-1) + T_down(n-1)\\n        // T_up(n-1) = T_down(n-2) + T(n-3)\\n        // T_down(n-1) = T_up(n-2) + T(n-3)\\n        // --> T(n) = T(n-1) + T(n-2) + T_down(n-2) + T(n-3) + T_up(n-2) + T(n-3)\\n        // --> T(n) = T(n-1) + T(n-3) + [T(n-2) + T(n-3) + T_up(n-2) + T_down(n-2)]\\n        // --> T(n) = 2 * T(n-1) + T(n-3)\\n\\n        // Since every state change only concerns the previous three values\\n        // Space can be reduced to O(1) in three variables\\n\\n        // Base case by reverse calculation:\\n        // Initially, T(0) = 0, T(1) = 1, T(2) = 2, T(3) = 5 ...\\n        // Thus, T(2) = 2 * T(1) + T(-1) --> T(-1) = 0\\n        //       T(1) = 2 * T(0) + T(-2) --> T(-2) = -1\\n\\n        const MOD: i32 = 1_000_000_007;\\n        // T(n-3), T(n-2), T(n-1) respectively\\n        let (mut x, mut y, mut z) = (-1, 0, 1);\\n        for _ in 1..=n {\\n            let cur = (2 * z % MOD + x) % MOD; // mod everytime to prevent overflow\\n            x = y;\\n            y = z;\\n            z = cur;\\n        }\\n        z\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_tilings(n: i32) -> i32 {\\n        // DP by considering filling the last column of space\\n        // T(n) = T(n - 1)      | end with one vertical domino\\n        //      + T(n - 2)      | end with two horizontal domino\\n        //      + T_up(n - 1)   | end with trimino filling the former lower grid\\n        //      + T_down(n - 1) | end with trimino filling the former upper grid//\\n        // T_up(n): having an unfilled lower grid, therefore it can be formed by\\n        // T_up(n) = T(n - 2)      | Fully filled followed with a trimino filling lower grid\\n        //         + T_down(n - 1) | T_down(n - 1) with an upper horizontal domino\\n        // T_down(n): equivalent as above\\n        // T_down(n) = T(n - 2)\\n        //           + T_up(n - 1)\\n\\n        // To sum up:\\n        // T(n) = T(n-1) + T(n-2) + T_up(n-1) + T_down(n-1)\\n        // T_up(n-1) = T_down(n-2) + T(n-3)\\n        // T_down(n-1) = T_up(n-2) + T(n-3)\\n        // --> T(n) = T(n-1) + T(n-2) + T_down(n-2) + T(n-3) + T_up(n-2) + T(n-3)\\n        // --> T(n) = T(n-1) + T(n-3) + [T(n-2) + T(n-3) + T_up(n-2) + T_down(n-2)]\\n        // --> T(n) = 2 * T(n-1) + T(n-3)\\n\\n        // Since every state change only concerns the previous three values\\n        // Space can be reduced to O(1) in three variables\\n\\n        // Base case by reverse calculation:\\n        // Initially, T(0) = 0, T(1) = 1, T(2) = 2, T(3) = 5 ...\\n        // Thus, T(2) = 2 * T(1) + T(-1) --> T(-1) = 0\\n        //       T(1) = 2 * T(0) + T(-2) --> T(-2) = -1\\n\\n        const MOD: i32 = 1_000_000_007;\\n        // T(n-3), T(n-2), T(n-1) respectively\\n        let (mut x, mut y, mut z) = (-1, 0, 1);\\n        for _ in 1..=n {\\n            let cur = (2 * z % MOD + x) % MOD; // mod everytime to prevent overflow\\n            x = y;\\n            y = z;\\n            z = cur;\\n        }\\n        z\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 804473,
                "title": "beats-100-2-dp-n-1-dp-n-3-c",
                "content": "```\\nclass Solution {\\n    const int mod=1e9+7;\\npublic:\\n    /*dp[n]=dp[n-1]+dp[n-2]+ 2*(dp[n-3]+...+d[0])\\n=dp[n-1]+dp[n-2]+dp[n-3]+dp[n-3]+2*(dp[n-4]+...+d[0])\\n=dp[n-1]+dp[n-3]+(dp[n-2]+dp[n-3]+2*(dp[n-4]+...+d[0]))\\n=dp[n-1]+dp[n-3]+dp[n-1]\\n=2*dp[n-1]+dp[n-3]*/\\n    int numTilings(int n) {\\n        vector<int> dp(n+1);\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(n==3)\\n            return 5;\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        for(int i=4;i<=n;i++)\\n        {\\n            dp[i]+=((long)dp[i-1]*2+(long)dp[i-3])%mod;\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    const int mod=1e9+7;\\npublic:\\n    /*dp[n]=dp[n-1]+dp[n-2]+ 2*(dp[n-3]+...+d[0])\\n=dp[n-1]+dp[n-2]+dp[n-3]+dp[n-3]+2*(dp[n-4]+...+d[0])\\n=dp[n-1]+dp[n-3]+(dp[n-2]+dp[n-3]+2*(dp[n-4]+...+d[0]))\\n=dp[n-1]+dp[n-3]+dp[n-1]\\n=2*dp[n-1]+dp[n-3]*/\\n    int numTilings(int n) {\\n        vector<int> dp(n+1);\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(n==3)\\n            return 5;\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        for(int i=4;i<=n;i++)\\n        {\\n            dp[i]+=((long)dp[i-1]*2+(long)dp[i-3])%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 116546,
                "title": "using-recurrence-log-n-very-quick-log-n-in-java-can-run-with-n-1000000000",
                "content": "```\nclass Solution {\n    static final int mod = 1000000007;\n    long[][] base = {{0, 1, 0}, {0, 0, 1}, {1, 0, 2}};\n    public long[][] pow(int n){\n        if(n == 1){\n            long mt[][] = new long[3][3];\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    mt[i][j] = base[i][j];\n                }\n            }\n            return mt;\n        }\n        long[][] f = pow(n / 2);\n        long tmp[][] = new long[3][3];\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                tmp[i][j] = 0;\n                for(int k = 0; k < 3; k++){\n                    tmp[i][j] += ((f[i][k] * f[k][j]) % mod);\n                    tmp[i][j] %= mod;\n                }\n            }\n        }\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                f[i][j] = tmp[i][j];\n            }\n        }\n        if(n % 2 == 1){\n            tmp = new long[3][3];\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    tmp[i][j] = 0;\n                    for(int k = 0; k < 3; k++){\n                        tmp[i][j] += ((base[i][k] * f[k][j]) % mod);\n                        tmp[i][j] %= mod;\n                    }\n                }\n            }\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    f[i][j] = tmp[i][j];\n                }\n            }\n        }\n        return f;\n    }\n    int a = 1, b = 2, c = 5;\n    public int numTilings(int N) {\n        int n = N;\n        if(n == 1) return a;\n        if(n == 2) return b;\n        if(n == 3) return c;\n        long result[][] = pow(N - 3);\n        long ans = (result[2][0] * a % mod + result[2][1] * b % mod) % mod + result[2][2] * c % mod;\n        int xx = (int)(ans % mod);\n        return xx;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    static final int mod = 1000000007;\n    long[][] base = {{0, 1, 0}, {0, 0, 1}, {1, 0, 2}};\n    public long[][] pow(int n){\n        if(n == 1){\n            long mt[][] = new long[3][3];\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    mt[i][j] = base[i][j];\n                }\n            }\n            return mt;\n        }\n        long[][] f = pow(n / 2);\n        long tmp[][] = new long[3][3];\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                tmp[i][j] = 0;\n                for(int k = 0; k < 3; k++){\n                    tmp[i][j] += ((f[i][k] * f[k][j]) % mod);\n                    tmp[i][j] %= mod;\n                }\n            }\n        }\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                f[i][j] = tmp[i][j];\n            }\n        }\n        if(n % 2 == 1){\n            tmp = new long[3][3];\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    tmp[i][j] = 0;\n                    for(int k = 0; k < 3; k++){\n                        tmp[i][j] += ((base[i][k] * f[k][j]) % mod);\n                        tmp[i][j] %= mod;\n                    }\n                }\n            }\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    f[i][j] = tmp[i][j];\n                }\n            }\n        }\n        return f;\n    }\n    int a = 1, b = 2, c = 5;\n    public int numTilings(int N) {\n        int n = N;\n        if(n == 1) return a;\n        if(n == 2) return b;\n        if(n == 3) return c;\n        long result[][] = pow(N - 3);\n        long ans = (result[2][0] * a % mod + result[2][1] * b % mod) % mod + result[2][2] * c % mod;\n        int xx = (int)(ans % mod);\n        return xx;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947563,
                "title": "clean-solution-for-dp-dummy-with-images",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst we need to understand what possible states we can achieve at each width `i`. Apparently there are two states at each width `i`: fully filled and partially filled. Then we need to figure out the relationship between different states so that we can propagate to the next width `i + 1`. It\\'s helpful to look back from the complete board and see what\\'s the last step to take.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Finding the Equations\\n\\nWe will use `f[i]` to denote fully filled state at width `i` and `p[i]` to denote partially filled state at width `i`, where \"partially filled\" means there is one and only one square missing at the end of the board.\\n    \\nTo achieve a fully filled state, we can start from the two aforementioned states:\\n\\n1. Fully filled states: There are two states we can use to get to `f[i]`: `f[i - 1]` and `f[i - 2]`. The following images illustrate how we can fill the board starting from `f[i - 1]` using a vertical domino and `f[i - 2]` using two horizontal dominos:\\n![1.png](https://assets.leetcode.com/users/images/abaae0d2-d302-4c09-a3ab-2ef9aab5dc6b_1671981645.5786984.png)\\n![2.png](https://assets.leetcode.com/users/images/f64fe341-9c6a-465e-9220-c0b8fe5be73b_1671981568.9936988.png)\\n\\n\\n2. Partially filled state: There are two symmetrical states that we can use. Since it\\'s symmetrical, we simply use `p[i - 1]` for both cases and the following images illustarte how a partially filled state `p[i-1]` is filled with a tromino to achieve `f[i]`.\\n![f3.png](https://assets.leetcode.com/users/images/6b0ac0fb-a726-4eb6-b630-3d2e259bb739_1671923920.569472.png)\\n![f4.png](https://assets.leetcode.com/users/images/371eb30d-033f-4f12-b85d-1f914b675104_1671923927.7636256.png)\\n\\nTherefore, there are total of 4 ways to achieve `f[i]`:\\n\\n`f[i] = f[i - 1] + f[i - 2] + 2 * p[i - 1]`\\n\\nNow we have the equation for `f[i]`. What about `p[i]`? By observation, we can find two ways to ahieve `p[i]`:\\n\\n1. From a fully filled state `f[i - 2]`: A tromino is added to a fuly filled state `f[i - 2]` to form a partially filled state `p[i]`.\\n![p2.png](https://assets.leetcode.com/users/images/0c8a0e55-7c94-4286-98db-ac2bc03ecf23_1671924284.977628.png)\\n\\n2. From a previous partially filled state `p[i - 1]`: A horizontal domino is added to a partially filled state `p[i - 1]` to form the next partially filled state `p[i]`.\\n![p1.png](https://assets.leetcode.com/users/images/e76622ec-7770-4283-bd71-b559b48be8b3_1671924298.2419508.png)\\n\\nNow we have the last piece of equation we need:\\n\\n`p[i] = p[i - 1] + f[i - 2]`\\n\\n*Due to symmetry, We can double the number of ways to achieve `p[i]` if we flip the board vertically. This symmetrical doubling (factor of 2x) is already considered in the calculation of `f[i]`. Therefore, it\\'s not considered here.*\\n\\n## Initial Values and Updating\\n\\nAt `i = 1`, the only thing we can do is put a vertical domino and fully fill the board and there is no way to partially fill the board.\\n`f[1] = 1`\\n`p[1] = 0`\\n\\nAt `i = 2`, there are two ways to fully fill the board (2x vertical dominos or 2x horizontal dominos) and one way to partially fill (actually 2 symmetrical ways, but the factor 2 is already considered when calculating `f[i]`).\\n`f[2] = 2`\\n`p[2] = 1`\\n\\nAt `i > 2`, we simply keep updating `f[i]` and `p[i]` using the equations we just found until `i == n`:\\n`f[i] = f[i - 1] + f[i - 2] + 2 * p[i - 1]`\\n`p[i] = p[i - 1] + f[i - 2]`\\n\\nBy close observation, we can see that we only need 4 variables at any given time. There is no need to keep a complete array of all states. Check the code to see which 4 variables are used.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n$$O(n)$$ if using array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if (n == 1) return 1;\\n        if (n == 2) return 2;\\n\\n        int mod = 1e9+7;\\n\\n        unsigned long res, f1 = 2, f2 = 1, p1 = 1;\\n        // res: number of ways to fully fill at f[i]\\n        // f1: number of ways to fully fill at f[i - 1]\\n        // f2: number of ways to fully fill at f[i - 2]\\n        // p1: number of ways to partially fill at p[i - 1]\\n\\n        for (int i = 2; i < n; i++) {\\n            res = (f1 + f2 + 2 * p1) % mod;\\n            p1 = (p1 + f2) % mod;\\n            f2 = f1;\\n            f1 = res;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if (n == 1) return 1;\\n        if (n == 2) return 2;\\n\\n        int mod = 1e9+7;\\n\\n        unsigned long res, f1 = 2, f2 = 1, p1 = 1;\\n        // res: number of ways to fully fill at f[i]\\n        // f1: number of ways to fully fill at f[i - 1]\\n        // f2: number of ways to fully fill at f[i - 2]\\n        // p1: number of ways to partially fill at p[i - 1]\\n\\n        for (int i = 2; i < n; i++) {\\n            res = (f1 + f2 + 2 * p1) % mod;\\n            p1 = (p1 + f2) % mod;\\n            f2 = f1;\\n            f1 = res;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947123,
                "title": "domino-and-tromino-tiling-clean-and-short-dp-solution",
                "content": "# Intuition\\nWhen we look at the problem you can see that we can find a solution using Dynamic Programming. Though, it requires a little bit more than a basic DP formulation. \\n\\n# Approach\\nLet us define three different DP arrays : \\n\\n- dpr[i] is holding the number of ways to tile on a board of length i;\\n- dpu[i] is holding the number of ways to tile on a board of length i where first row has one more cell then the second row\\n- dpd[i] is holding the number of ways to tile on a board of length i where first row has one less cell then the second row\\n \\nIf we consider only the right-most(last) tile there are these alternatives: \\n\\n-  the last tile is a vertical 2*1 domino. Then the number of ways to tile the previous tiles is dpr[i-1]\\n\\n- the last tile is a horizontal 2*1 domino. Then there must be another horizontal domino below that and the number of ways to tile the previous tiles is dpr[i-2]\\n\\n- the last tile is a tromino with 2 cells on the first row.\\n    1 1\\n    0 1\\n    Then, ways to tile the previous tiles is dpd[i-1]\\n\\n- the last tile is a tromino with 2 cells on the second row.\\n    0 1\\n    1 1\\n    Then, ways to tile the previous tiles is dpu[i-1]\\n\\n  \\nso our DP formula for dpr :\\n\\n    dpr[i] = dpr[i-1] + dpr[i-2] + dpu[i-1] + dpd[i-1]\\n\\nwith similar approach we can find formulas for dpu and dpd\\n\\n    dpu[i] = dpd[i-1] + dpr[i-2]\\n\\n    dpd[i] = dpu[i-1] + dpr[i-2]\\n\\n# Complexity\\n- Time complexity:\\nTime complexity to calculate the number of tilings is O(n)\\n\\n\\n- Space complexity:\\nSpace complexity to calculate the number of tilings is also O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    const long MODULO = 1000000007;\\n    public int NumTilings(int n) {\\n        var dpr = new long[n+1];\\n        var dpu = new long[n+1];\\n        var dpd = new long[n+1];\\n        dpr[0] = 1;\\n        dpr[1] = 1;\\n        for (int i = 2; i <= n; i++)\\n        {\\n            dpu[i] = (dpd[i-1] + dpr[i-2]) % MODULO;\\n            dpd[i] = (dpu[i-1] + dpr[i-2]) % MODULO;\\n            dpr[i] = (dpr[i-1] + dpr[i-2] + dpu[i-1] + dpd[i-1]) % MODULO;\\n        }\\n\\n        return (int)dpr[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    const long MODULO = 1000000007;\\n    public int NumTilings(int n) {\\n        var dpr = new long[n+1];\\n        var dpu = new long[n+1];\\n        var dpd = new long[n+1];\\n        dpr[0] = 1;\\n        dpr[1] = 1;\\n        for (int i = 2; i <= n; i++)\\n        {\\n            dpu[i] = (dpd[i-1] + dpr[i-2]) % MODULO;\\n            dpd[i] = (dpu[i-1] + dpr[i-2]) % MODULO;\\n            dpr[i] = (dpr[i-1] + dpr[i-2] + dpu[i-1] + dpd[i-1]) % MODULO;\\n        }\\n\\n        return (int)dpr[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946547,
                "title": "c-100-faster-easy-to-understand-iterative-dp",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1e9 + 7;\\n    \\n    int numTilings(int n) {\\n\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        long long dp[n+1];\\n\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for(int i=4;i<=n;i++) {\\n            dp[i] = 2*dp[i-1] + dp[i-3];\\n            dp[i] %= mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1e9 + 7;\\n    \\n    int numTilings(int n) {\\n\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        long long dp[n+1];\\n\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for(int i=4;i<=n;i++) {\\n            dp[i] = 2*dp[i-1] + dp[i-3];\\n            dp[i] %= mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945524,
                "title": "c-easy-clean-fastest-recursion-memoization-image-detailed-explanation",
                "content": "# Intuition\\nAs we have 2 x n Board to tile only with two tiling options: Domino and Tromino, think of breaking down problem into cases where each case includes tiling the board with domino or tromino (given choices). From this, We can deduce that our problem can be broken down into subproblems which gives intuition of recursion/ memoization/ dp.\\n\\n# Approach\\nPlease check below image for more detailed visualization. It can be observed that a Rectangular (Rec.) board of width n can be broken into cases of Rec. board of width n - 1 and n - 2 when tiling is done using domino. On the other hand if tiling is done with a tromino, Rec. board of width n can be broken into: nonRec. board Down width of n - 1 and Up width of n - 1. Similarly, we can break nonRec. boards into cases when they get tiled by domino or tromino, refer to image below.\\n\\n![Screenshot 2022-12-24 at 4.34.35 PM.png](https://assets.leetcode.com/users/images/6a839363-0dc7-446d-8da2-06f897952960_1671881131.2062058.png)\\n\\nLooking at above image, its not difficult to come up with a recursive approach and then use memoization to solve the overlapping subproblems only once. Clearly, this can be further optimised using DP.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n#define vi vector<int>\\n#define UL unsigned long\\n\\nclass Solution {\\npublic:\\n    const int m = 1e9 + 7;\\n    vi MR, MNRD;\\n\\n    int add(UL a, UL b) { return ((a % m) + (b % m)) % m; }\\n\\n    int dfsRec(int n) {\\n        if(n <= 1) return n >= 0;\\n        if(MR[n] >= 0) return MR[n];\\n        auto rec = add(dfsRec(n - 1), dfsRec(n - 2));\\n        auto nonRec = add(dfsNonRecDown(n - 1), dfsNonRecUp(n - 1));\\n        return MR[n] = add(rec, nonRec);\\n    }\\n\\n    int dfsNonRecDown(int n) {\\n        if(n <= 2) return n == 2;\\n        if(MNRD[n] >= 0) return MNRD[n];\\n        return MNRD[n] = add(dfsNonRecUp(n - 1), dfsRec(n - 2));\\n    }\\n\\n    int dfsNonRecUp(int n) {\\n        return add(dfsNonRecDown(n - 1), dfsRec(n - 2));\\n    }\\n\\n    int dfs(int n) {\\n        MR.resize(n + 1, -1), MNRD.resize(n + 1, -1);\\n        return dfsRec(n);\\n    }\\n\\n    int numTilings(int n) {\\n        return dfs(n);\\n    }\\n};\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define vi vector<int>\\n#define UL unsigned long\\n\\nclass Solution {\\npublic:\\n    const int m = 1e9 + 7;\\n    vi MR, MNRD;\\n\\n    int add(UL a, UL b) { return ((a % m) + (b % m)) % m; }\\n\\n    int dfsRec(int n) {\\n        if(n <= 1) return n >= 0;\\n        if(MR[n] >= 0) return MR[n];\\n        auto rec = add(dfsRec(n - 1), dfsRec(n - 2));\\n        auto nonRec = add(dfsNonRecDown(n - 1), dfsNonRecUp(n - 1));\\n        return MR[n] = add(rec, nonRec);\\n    }\\n\\n    int dfsNonRecDown(int n) {\\n        if(n <= 2) return n == 2;\\n        if(MNRD[n] >= 0) return MNRD[n];\\n        return MNRD[n] = add(dfsNonRecUp(n - 1), dfsRec(n - 2));\\n    }\\n\\n    int dfsNonRecUp(int n) {\\n        return add(dfsNonRecDown(n - 1), dfsRec(n - 2));\\n    }\\n\\n    int dfs(int n) {\\n        MR.resize(n + 1, -1), MNRD.resize(n + 1, -1);\\n        return dfsRec(n);\\n    }\\n\\n    int numTilings(int n) {\\n        return dfs(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945466,
                "title": "dp-solution-memoization-to-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // Memoization\\n    long solve(int n, vector<int>& dp)\\n    {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n == 3) {\\n            return 5;\\n        }\\n\\n        if (dp[n] != -1) {\\n            return dp[n];\\n        }\\n\\n        return ((2 * (solve(n - 1, dp)) + solve(n - 3, dp))) % mod;\\n    }\\n\\n    // Tabulation\\n    int solveTab(int n)\\n    {\\n        vector<long> dp(n + 3, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (2 * ((dp[i - 1]) % mod) + dp[i - 3]);\\n        }\\n\\n        return (dp[n]) % mod;\\n    }\\n\\n    // Space Optimization\\n    int solveUsingSpaceOptimisation(int n)\\n    {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        long prev1 = 2;\\n        long prev2 = 1;\\n        long prev3 = 1;\\n        long curr = 0;\\n        for (int i = 3; i <= n; i++) {\\n\\n            curr = (2 * ((prev1) % mod) + prev3);\\n            prev3 = prev2;\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n\\n        return (curr % mod);\\n    }\\n\\n    int numTilings(int n)\\n    {\\n        // vector<int> dp(n+1,-1);\\n        // return solve(n,dp);\\n        return solveUsingSpaceOptimisation(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // Memoization\\n    long solve(int n, vector<int>& dp)\\n    {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n == 3) {\\n            return 5;\\n        }\\n\\n        if (dp[n] != -1) {\\n            return dp[n];\\n        }\\n\\n        return ((2 * (solve(n - 1, dp)) + solve(n - 3, dp))) % mod;\\n    }\\n\\n    // Tabulation\\n    int solveTab(int n)\\n    {\\n        vector<long> dp(n + 3, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (2 * ((dp[i - 1]) % mod) + dp[i - 3]);\\n        }\\n\\n        return (dp[n]) % mod;\\n    }\\n\\n    // Space Optimization\\n    int solveUsingSpaceOptimisation(int n)\\n    {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        long prev1 = 2;\\n        long prev2 = 1;\\n        long prev3 = 1;\\n        long curr = 0;\\n        for (int i = 3; i <= n; i++) {\\n\\n            curr = (2 * ((prev1) % mod) + prev3);\\n            prev3 = prev2;\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n\\n        return (curr % mod);\\n    }\\n\\n    int numTilings(int n)\\n    {\\n        // vector<int> dp(n+1,-1);\\n        // return solve(n,dp);\\n        return solveUsingSpaceOptimisation(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945202,
                "title": "c-easy-and-simple-solution-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Just Take few test cases and find the relation between the output.\\n- for e.g  Here for 1 --> 1, 2--> 2, 3--> 5, 4-->11 (which is 2 times prev output + third last output) , Same goes for 5--> 24(which is (2*11) + 2).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If input is less than 3 we return the same number else we start claculate till \\'n-2\\' times, as we have calculated for n<3 earlier.\\n2. So we store values of first  outputs in 3 variables $$prev$$,$$prev2$$ and $$prev3$$, and update their values at each iteration.\\n3. One of the important thing is to take (ans)%m at every step to avoid integer overflows.\\n4. Lastly we will have our answer in $$prev$$ and/or $$curr$$ we can return any of them.\\nHope You Understand!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$//Linear Time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ Constant as only variables used.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    int numTilings(int n) {\\n        if(n<3)return n;\\n        else\\n        {\\n            long long prev3 = 1;\\n            long long prev2 = 1;\\n            long long prev  = 2;\\n            long long curr=0;\\n            for(int i=2;i<n;i++)\\n            {\\n                curr = ((prev*2) + prev3)%m;\\n                prev3 = prev2;\\n                prev2 = prev;\\n                prev = curr;\\n            }\\n            return prev;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    int numTilings(int n) {\\n        if(n<3)return n;\\n        else\\n        {\\n            long long prev3 = 1;\\n            long long prev2 = 1;\\n            long long prev  = 2;\\n            long long curr=0;\\n            for(int i=2;i<n;i++)\\n            {\\n                curr = ((prev*2) + prev3)%m;\\n                prev3 = prev2;\\n                prev2 = prev;\\n                prev = curr;\\n            }\\n            return prev;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945079,
                "title": "java-100-faster-simple-clean-solution-fibbonaci-based",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question itself is pretty weird if you look at the way it is described but pretty simple once you try to plot a picture in your head. Now if you draw all the possibilites for first few test cases, you\\'ll notice something.\\n\\n`n = 1, ans = 1`\\n`n = 2, ans = 2`\\n`n = 3, ans = 5`\\n`n = 4, ans = 11`\\n`n = 5, ans = 24`\\n`n = 6, ans = 53`\\n`n = 7, ans = 117`\\n\\nFrom the 4th testcase onwards, it follows a pattern which can be formulated as:\\n`ans[i] = 2 * ans[i - 1] + ans[i - 3]`\\n\\nAnd that is it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an array of size `n` and do a tabulated fibbonaci. Define for first 3 base cases i.e., `n = 1, 2, 3` and calculate for the rest.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        if(n == 3) return 5;\\n        int mod = 1000000007;\\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        ans[2] = 5;\\n        for(int i = 3; i < n; i++) {\\n            ans[i] = (((ans[i - 1] % mod) * 2)% mod + ans[i - 3] % mod) % mod;\\n        }\\n        return ans[n - 1]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        if(n == 3) return 5;\\n        int mod = 1000000007;\\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        ans[2] = 5;\\n        for(int i = 3; i < n; i++) {\\n            ans[i] = (((ans[i - 1] % mod) * 2)% mod + ans[i - 3] % mod) % mod;\\n        }\\n        return ans[n - 1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944758,
                "title": "c-dp-tabulation-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply by dry running some solution we can reach a point to find a pattern involved in it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can analyse that \\ndp[1]=1\\ndp[2]=2\\ndp[3]=5\\ndp[4]=11\\ndp[i]=2*dp[i-1]+dp[i-3]\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt is a 1D with linear time complexity i.e O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe are using only a vector so space complexity is O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<long long>dp(n+1,0);\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(n==3)\\n            return 5;\\n        if(n==4)\\n            return 11;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        dp[4] = 11;\\n        for(int i=5; i<=n; ++i) {\\n            dp[i] = (2*dp[i-1] +dp[i-3]) % 1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<long long>dp(n+1,0);\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(n==3)\\n            return 5;\\n        if(n==4)\\n            return 11;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        dp[4] = 11;\\n        for(int i=5; i<=n; ++i) {\\n            dp[i] = (2*dp[i-1] +dp[i-3]) % 1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944744,
                "title": "matrix-exponentiation-detailed-explanation-o-log-n-solution",
                "content": "# Approach\\n\\nMatrix Exponentiation is one of the most interesting techniques in competitive programming where you can reduce the complexity of your solution from O(N) to O(Log N) for a lot of recurrence relations.\\n\\nI\\'ll not be going into the details of the recurrence relation. This post is about understanding matrix exponentiation given some recurrence relation which in our case is: \\n\\nF(N) = 2\\\\*F(N-1) + 1\\\\*F(N-3)\\n\\nThe above equation can be rewritten as:\\n\\nF(N) = 2\\\\*F(N-1) + 0\\\\*F(N-2) + 1\\\\*F(N-3)\\n\\nSo the current value is depending on 3 previous values\\n\\n[1st Matrix] = [Some matrix] * [3rd Matrix]\\n\\n![1.png](https://assets.leetcode.com/users/images/2a2fc543-bd81-4e4c-88cc-8bb12b75419a_1671863617.9997604.png)\\n\\nDimension of the 1st and 3rd matrix is 3\\\\*1 so the dimension of the 2nd matrix must be 3\\\\*3\\n\\nAccording to our equation:\\n\\nF(N) = 2\\\\*F(N-1) + 0\\\\*F(N-2) + F(N-3)\\nF(N-1) = F(N-1)\\nF(N-2) = F(N-2)\\n\\nWriting this in matrix form we get our second matrix as:\\n\\n| 2 0 1 |\\n| 1 0 0 |\\n| 0 1 0 |\\n\\nOur relation becomes:\\n \\n![2.png](https://assets.leetcode.com/users/images/7e518475-9018-4cd5-a491-26c60214b5e6_1671864145.4730778.png)\\n\\nInitial values are F(0) = 1, F(1) = 1, F(2) = 2\\n\\nFor N = 3 \\n\\n![3.png](https://assets.leetcode.com/users/images/7bc0b7f3-0603-4dc9-ac9b-5aad0e6b3e3a_1671864277.6640637.png)\\n\\nFor N = 4\\n\\n![5.png](https://assets.leetcode.com/users/images/1adf94e6-c6de-40c9-9c65-ed89cab4cc87_1671864831.8639169.png)\\n\\n\\nSo for some N \\n\\n![6.png](https://assets.leetcode.com/users/images/23edab65-0784-4b83-9d0e-8faa89c09af7_1671864958.975979.png)\\n\\n\\nThus we can multiply the second matrix N-2 times and finally multiply it with the base matrix to get the answer for F(N)\\n\\nThis multiplication of the matrix can be done using fast exponentiation which will provide us the final matrix in O(Log N) time \\n\\n# Complexity\\n- Time complexity: O(Log N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n    const int mod=1e9+7;\\n\\n    void multiply(vector<vector<ll>> &A, vector<vector<ll>> &B){\\n        vector<vector<ll>> temp(3, vector<ll>(3));\\n        for(int i=0; i<3; ++i){\\n            for(int j=0; j<3; ++j){\\n                for(int k=0; k<3; ++k){\\n                    (temp[i][j]+=(A[i][k]%mod * B[k][j]%mod)%mod)%mod;\\n                }\\n            }\\n        } \\n        A=temp;\\n    }\\n\\n    void power(vector<vector<ll>> &A, ll n){\\n        if(n==1) return;\\n        power(A, n/2);\\n        multiply(A, A);\\n        if(n%2){\\n            vector<vector<ll>> B={{2, 0, 1}, {1, 0, 0}, {0, 1, 0}};\\n            multiply(A, B);\\n        }\\n    }\\n\\n    int numTilings(int n) {\\n        if(n<=2)return n;\\n        vector<vector<ll>> A={{2, 0, 1}, {1, 0, 0}, {0, 1, 0}};\\n        power(A, n-2);\\n        return (2*A[0][0]%mod + A[0][1]%mod + A[0][2]%mod)%mod;\\n    }\\n};\\n```\\n\\nDo Upvote, If found helpful \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n    const int mod=1e9+7;\\n\\n    void multiply(vector<vector<ll>> &A, vector<vector<ll>> &B){\\n        vector<vector<ll>> temp(3, vector<ll>(3));\\n        for(int i=0; i<3; ++i){\\n            for(int j=0; j<3; ++j){\\n                for(int k=0; k<3; ++k){\\n                    (temp[i][j]+=(A[i][k]%mod * B[k][j]%mod)%mod)%mod;\\n                }\\n            }\\n        } \\n        A=temp;\\n    }\\n\\n    void power(vector<vector<ll>> &A, ll n){\\n        if(n==1) return;\\n        power(A, n/2);\\n        multiply(A, A);\\n        if(n%2){\\n            vector<vector<ll>> B={{2, 0, 1}, {1, 0, 0}, {0, 1, 0}};\\n            multiply(A, B);\\n        }\\n    }\\n\\n    int numTilings(int n) {\\n        if(n<=2)return n;\\n        vector<vector<ll>> A={{2, 0, 1}, {1, 0, 0}, {0, 1, 0}};\\n        power(A, n-2);\\n        return (2*A[0][0]%mod + A[0][1]%mod + A[0][2]%mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944679,
                "title": "c-dp-tabulation-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy analizing the first few results, the following formula is obtained.\\n    Initialize the size of DP =(n+5), as if n<4 it will not through an error.\\n    //Initial DP values are obtained by analizing the first few results. They are\\n    * DP[1] = 1;\\n    * DP[2] = 2;\\n    * DP[3] = 5\\n    * DP[i] = 2*DP[i-1]+DP[i-3];\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    As it is a linear DP traversal, TC will be O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    SC : O(N).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<int>dp(n+5,0);\\n        int mod=1000000007;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=((2*((dp[i-1])%mod))%mod+(dp[i-3])%mod)%(mod);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<int>dp(n+5,0);\\n        int mod=1000000007;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=((2*((dp[i-1])%mod))%mod+(dp[i-3])%mod)%(mod);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944400,
                "title": "c-simple-idea-code-0ms-runtime-explain-by-image-and-comment",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIm just find out the rule of result:\\n![image.png](https://assets.leetcode.com/users/images/d5e4b02d-b832-4bdc-aefe-7a7e968ab5c1_1671938023.1976612.png)\\n -> I don\\'t consider case * **n less than 4** since A(0) doesn\\'t exist.\\n### For example: \\n\\n- **n = 4**\\n![image.png](https://assets.leetcode.com/users/images/5c4679e0-676f-405b-b5e8-28f188d4b786_1671857992.599562.png)\\n- **n = 5**\\n![image.png](https://assets.leetcode.com/users/images/83e469a8-69f1-4ae3-bd9a-9b8a9c516e30_1671858130.2308517.png)\\n- **n = 6**\\n![image.png](https://assets.leetcode.com/users/images/b6518daf-2e1f-4e17-bbcb-1c43a08a7b1e_1671858244.1903396.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor the general, I let variable **a** store (n-3) value and **c** for (n-1) then  we can easily calculate the result.\\n- **n = 4**\\n![image.png](https://assets.leetcode.com/users/images/46ca036e-5f91-4a50-827e-db521ae1f69f_1671859739.1557844.png)\\n\\n- **n = 5**\\n![image.png](https://assets.leetcode.com/users/images/7cc70323-1199-49ec-94dd-ce6bb76163f3_1671859068.1883385.png)\\n\\nand so on..\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n <= 2)\\n            return n;\\n        if(n == 3)\\n            return 5;\\n        //a = n(1), b = n(2), c = n(3)\\n        long res, a = 1, b = 2, c = 5;\\n        while(n-- > 3) {\\n            res = (2*c + a) % int (1e9 + 7);\\n            //shift a,b,c to the right\\n            a = b;\\n            b = c;\\n            c = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n <= 2)\\n            return n;\\n        if(n == 3)\\n            return 5;\\n        //a = n(1), b = n(2), c = n(3)\\n        long res, a = 1, b = 2, c = 5;\\n        while(n-- > 3) {\\n            res = (2*c + a) % int (1e9 + 7);\\n            //shift a,b,c to the right\\n            a = b;\\n            b = c;\\n            c = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944373,
                "title": "tabulation-solution-simple-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n<=2)return n;\\n        int [] arr = new int[n+1];\\n        arr[0] = 0;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n        arr[3] = 5;\\n        int mod = 10*10*10*10*10*10*10*10*10 + 7;\\n        for(int x = 4; x<=n;x++){\\n            arr[x] = arr[x-3]+2*arr[x-1]%(mod);\\n            arr[x] = arr[x]%(mod);\\n        }\\n\\n        return arr[n];\\n    }\\n    // public int domino(int n,int x){\\n    //     if(x<1){\\n    //         if(x<0)return 0;\\n    //         return 1;\\n    //         }\\n    //     int left = domino(n,x-1);\\n    //     int right = domino(n,x-2);\\n    //     return left+right;\\n    // }\\n    // public int tramino(int n,int x){\\n    //     if(x<1){\\n    //         if(x<0)return 0;\\n    //         return 1;\\n    //         }\\n    //     int l = 2*tramino(n,x-4);\\n    //     int right1 = 2*tramino(n,x-3);\\n    //     int right = tramino(n,x-2);\\n    //     int left = tramino(n,x-1);\\n    //     return left+right+right1+l;\\n    // }\\n}\\n```\\n# Request \\nif find recursive solution for the tromino function then please put it in the comments.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n<=2)return n;\\n        int [] arr = new int[n+1];\\n        arr[0] = 0;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n        arr[3] = 5;\\n        int mod = 10*10*10*10*10*10*10*10*10 + 7;\\n        for(int x = 4; x<=n;x++){\\n            arr[x] = arr[x-3]+2*arr[x-1]%(mod);\\n            arr[x] = arr[x]%(mod);\\n        }\\n\\n        return arr[n];\\n    }\\n    // public int domino(int n,int x){\\n    //     if(x<1){\\n    //         if(x<0)return 0;\\n    //         return 1;\\n    //         }\\n    //     int left = domino(n,x-1);\\n    //     int right = domino(n,x-2);\\n    //     return left+right;\\n    // }\\n    // public int tramino(int n,int x){\\n    //     if(x<1){\\n    //         if(x<0)return 0;\\n    //         return 1;\\n    //         }\\n    //     int l = 2*tramino(n,x-4);\\n    //     int right1 = 2*tramino(n,x-3);\\n    //     int right = tramino(n,x-2);\\n    //     int left = tramino(n,x-1);\\n    //     return left+right+right1+l;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944332,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n < 3) return n;\\n        vector<long long> dp(n+1);\\n        dp[0] = 1, dp[1] = 1, dp[2] = 2;\\n        for(int i=3; i<=n; i++) {\\n            dp[i] = (2 * dp[i-1] + dp[i-3]) % mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n < 3) return n;\\n        vector<long long> dp(n+1);\\n        dp[0] = 1, dp[1] = 1, dp[2] = 2;\\n        for(int i=3; i<=n; i++) {\\n            dp[i] = (2 * dp[i-1] + dp[i-3]) % mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944220,
                "title": "observation-o-n-100-fast-easy-understanding-5-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Observation\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int arr[1001],N=1e9+7;\\n    int numTilings(int n) {\\n         arr[1]=1; arr[2]=2; arr[3]=5;\\n         for(int i=4;i<=n;i++){ //obeservation is arr[i]=arr[i-1]*2+arr[i-3]\\n             arr[i]=((arr[i-1]*2)%N+arr[i-3])%N; //for i>=4\\n         }\\n        return arr[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int arr[1001],N=1e9+7;\\n    int numTilings(int n) {\\n         arr[1]=1; arr[2]=2; arr[3]=5;\\n         for(int i=4;i<=n;i++){ //obeservation is arr[i]=arr[i-1]*2+arr[i-3]\\n             arr[i]=((arr[i-1]*2)%N+arr[i-3])%N; //for i>=4\\n         }\\n        return arr[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549003,
                "title": "c-100-fastest-solution-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n,vector<int>&dp){\\n        //base case\\n        if(n==1)return 1;\\n        if(n==2)return 2;\\n        if(n==3)return 5;\\n        //check the cache\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return \\n            dp[n]=((2*solve(n-1,dp))%mod + solve(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        \\n        vector<int>dp(n+10,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n,vector<int>&dp){\\n        //base case\\n        if(n==1)return 1;\\n        if(n==2)return 2;\\n        if(n==3)return 5;\\n        //check the cache\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return \\n            dp[n]=((2*solve(n-1,dp))%mod + solve(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        \\n        vector<int>dp(n+10,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463108,
                "title": "4-line-python",
                "content": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        dp=[0]*(n+3)\\n        dp[1]=1\\n        dp[2]=2\\n        dp[3]=5\\n        for i in range(4,n+1):\\n            dp[i]=int((2*dp[i-1]+dp[i-3])%(1e9+7))\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        dp=[0]*(n+3)\\n        dp[1]=1\\n        dp[2]=2\\n        dp[3]=5\\n        for i in range(4,n+1):\\n            dp[i]=int((2*dp[i-1]+dp[i-3])%(1e9+7))\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622024,
                "title": "c-simple-solution-w-images-explanation-optimization-from-brute-force-to-dp",
                "content": "\\u2714\\uFE0F **Solution (Dynamic Programming - Tabulation)**\\n**1-D DP**\\nSimple basic approach to these question comprises of three steps :\\n\\n**Step 1:** (putting   ![image](https://assets.leetcode.com/users/images/1a819d99-9305-456d-985d-81fc4c12fa8c_1639162617.0363584.png)   at the end , this can be done in **dp[i-1]** ways ) .\\n\\n**Step 2**: (putting     ![image](https://assets.leetcode.com/users/images/c17ad4a1-1f58-4c94-88af-e110f1abc266_1639162680.2571974.png)  at the end , this can be done in **dp[i-2]** ways ) .\\n\\n\\n**Step 3**: ( putting all those boxes formed by the combination of ![image](https://assets.leetcode.com/users/images/a9033da0-53e2-4e72-b124-11af378e6c75_1639162724.4785063.png)![image](https://assets.leetcode.com/users/images/59eaaab0-4f85-4b12-bfc0-f1b7c664d34b_1639162735.3517957.png)\\n\\n![image](https://assets.leetcode.com/users/images/d5edcfbe-1754-4e60-a241-a3830bf63c88_1639162748.0943146.png)  \\n, this can be done by all those combinations **greater than or equal to 3 till n** )\\n\\n**For example** : dp[4] = dp[3] + dp[2] + dp[1]*2 + 2 (2 combination formed by n in step 3)  ; \\n\\nSo , we can genelarise the code as ,\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long int MOD = 1000000007 ;\\n        vector<int>dp(n+2,0);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            dp[i]=(dp[i-1]%MOD+dp[i-2]%MOD+2)%MOD;   \\n            for(int j=3;j<i;j++)\\n            {\\n                dp[i]=(dp[i]%MOD+(dp[i-j]*2)%MOD)%MOD;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\nTime Complexity : O(N^2)\\nSpace Complexity : O(N), required maintaining dp\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long int MOD = 1000000007 ;\\n        vector<int>dp(n+2,0);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            dp[i]=(dp[i-1]%MOD+dp[i-2]%MOD+2)%MOD;   \\n            for(int j=3;j<i;j++)\\n            {\\n                dp[i]=(dp[i]%MOD+(dp[i-j]*2)%MOD)%MOD;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621129,
                "title": "c-recursion-memoization-beats-100",
                "content": "Everytime we reach upto a column, we may have either 2 or 1 untiled cells in that column.\\nIf 2 empty cells are present: \\n* Insert a single vertical domino and move ahead.\\n* Insert 2 horizontal dominos.\\n* Add a tromino, which means next column will only have 1 untiled cell.\\n\\nIf only 1 empty cell is preset:\\n* Place a tromino so that next column has 2 untiled cells.\\n* Add a horizontal domino to continue the 1 untiled cell pattern.\\n```\\n\\tconst int mod = 1e9+7;\\n\\t\\n    long long dp[1001][3];\\n    long long f(int n, int empty){\\n        if(n<=1) return empty==2;//At the last column, there must be 2 empty cells, otherwise this is an invalid way, so return 0\\n        if(dp[n][empty]!=-1) return dp[n][empty]%mod;\\n        long long res = 0;\\n        \\n        if(empty==2){\\n            res += f(n-1, 2)%mod;//single verticle domino\\n            if(n>=2) res += f(n-2, 2)%mod;// 2 horizontal dominos\\n            res += (2 * f(n-1, 1)%mod)%mod;//tromino placed\\n        }\\n        else{\\n            res+= f(n-2, 2)%mod;//placed a tromino to fill the gap\\n            res+= f(n-1, 1)%mod;//horizontal domino added\\n        }\\n        \\n        return dp[n][empty] = res%mod;\\n    }\\n    long long numTilings(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return f(n, 2)%mod;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tconst int mod = 1e9+7;\\n\\t\\n    long long dp[1001][3];\\n    long long f(int n, int empty){\\n        if(n<=1) return empty==2;//At the last column, there must be 2 empty cells, otherwise this is an invalid way, so return 0\\n        if(dp[n][empty]!=-1) return dp[n][empty]%mod;\\n        long long res = 0;\\n        \\n        if(empty==2){\\n            res += f(n-1, 2)%mod;//single verticle domino\\n            if(n>=2) res += f(n-2, 2)%mod;// 2 horizontal dominos\\n            res += (2 * f(n-1, 1)%mod)%mod;//tromino placed\\n        }\\n        else{\\n            res+= f(n-2, 2)%mod;//placed a tromino to fill the gap\\n            res+= f(n-1, 1)%mod;//horizontal domino added\\n        }\\n        \\n        return dp[n][empty] = res%mod;\\n    }\\n    long long numTilings(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return f(n, 2)%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620860,
                "title": "dp-with-bitmasks-c-clear-explanation",
                "content": "* Here In this solution we just need to check all possibilities from the current postion to next position and assign the mask values based on the filled situations.\\n* It\\'s not actually the bitmasking level problem but taken the mask variable to indicates the possible states using the numbers.\\n* We will use memoization for the avoiding repetitive recursion tasks.\\n* Lets Try to under stand the all possible states and their possibilities:\\n* Consider the 2*2 grid. **This dimenstion is taken because this is the minimum dimension required to consider the generated states by using two types of tiles.**\\n\\n\\t![image](https://assets.leetcode.com/users/images/5de6ead3-10f5-4bde-b9ce-dcefe52f74d3_1639195755.7855394.png)\\n\\n\\n\\n\\n* At last we will return 1 if all boxes **filled in valid manner by verifying mask is 0 means state 1.**\\n\\n**Below is the code implementation of the above approach:**\\n```\\nclass Solution {\\npublic:\\n\\n    const int mod = 1e9 + 7;\\n    int dp[1001][4];\\n    int n;\\n    int solve(int index,int mask)\\n    {\\n        if(index > n)\\n        {\\n            return 0;\\n        }\\n        if(index == n)\\n        {\\n            return mask == 0;\\n        }\\n        if(dp[index][mask] != -1) return dp[index][mask];\\n\\n        int ans = 0;\\n\\n        if(mask == 0)\\n        {\\n            ans = (ans + solve(index+1,0))%mod;\\n            ans = (ans + solve(index+2,0))%mod;\\n            ans = (ans + solve(index+1,1))%mod;\\n            ans = (ans + solve(index+1,2))%mod;\\n            \\n            \\n        }\\n        else if(mask == 1)\\n        {\\n            ans = (ans + solve(index+1,3))%mod;\\n            ans = (ans + solve(index+1,2))%mod;\\n        }\\n        else if(mask == 2)\\n        {\\n            ans = (ans + solve(index+1,3))%mod;\\n            ans = (ans + solve(index+1,1))%mod;\\n        }\\n        else\\n        {\\n            ans = solve(index+1,0) % mod;\\n        }\\n        return dp[index][mask] = ans;\\n    }\\n\\n    int numTilings(int N) {\\n        n = N;\\n        memset(dp,-1,sizeof dp);\\n\\n        return solve(0,0);\\n        \\n    }\\n};\\n```\\n\\n**Upvote if you understand this approach. Let me know  if any doubts or other more optimal approach.**\\n\\n\\n",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    const int mod = 1e9 + 7;\\n    int dp[1001][4];\\n    int n;\\n    int solve(int index,int mask)\\n    {\\n        if(index > n)\\n        {\\n            return 0;\\n        }\\n        if(index == n)\\n        {\\n            return mask == 0;\\n        }\\n        if(dp[index][mask] != -1) return dp[index][mask];\\n\\n        int ans = 0;\\n\\n        if(mask == 0)\\n        {\\n            ans = (ans + solve(index+1,0))%mod;\\n            ans = (ans + solve(index+2,0))%mod;\\n            ans = (ans + solve(index+1,1))%mod;\\n            ans = (ans + solve(index+1,2))%mod;\\n            \\n            \\n        }\\n        else if(mask == 1)\\n        {\\n            ans = (ans + solve(index+1,3))%mod;\\n            ans = (ans + solve(index+1,2))%mod;\\n        }\\n        else if(mask == 2)\\n        {\\n            ans = (ans + solve(index+1,3))%mod;\\n            ans = (ans + solve(index+1,1))%mod;\\n        }\\n        else\\n        {\\n            ans = solve(index+1,0) % mod;\\n        }\\n        return dp[index][mask] = ans;\\n    }\\n\\n    int numTilings(int N) {\\n        n = N;\\n        memset(dp,-1,sizeof dp);\\n\\n        return solve(0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430395,
                "title": "domino-tromino-best-0-ms-faster-than-100-simplest-solution-with-intution",
                "content": "In this question the intution starts to build on the basis of 2x1 and Mx1 tiling problem if you haven\\'t done these two then i strongly suggest you to please do these two first.\\nNow you have done those two problems then You will going to able to find a pattern for both domino and tromino that is for domino you will find f[n]=f[n-1]+f[n-2] a recursive solution.\\nso we have a table\\n![image](https://assets.leetcode.com/users/images/432420c9-edd3-49f9-bbb5-4f4c390267b8_1630140280.6376898.png)\\n\\nnow let\\'s analyse the pattern\\n```\\n\\t\\tn=3   f[3]=5\\n\\t\\tn=4   f[4]= 11 =2*5+1;\\n\\t\\tn=5   f[5]= 24 =2*11+2;\\n\\t\\tn=6   f[6]= 53 =2*24+5\\n\\nif we try to generalise the pattern we see\\n\\nf[n]= 2*f[n-1]+f[n-3]  hence we will get our answer\\n\\ncode for the question:\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numTilings(int n) {\\n        vector<long long> dp(n+1);\\n        if(n<3)\\n        return n;\\n        dp[0]=1;//here i have taken dp[0]=1 coz at the edge case that is when n=3 dp[n-3] will give the runtime error but can you find a way without putting it dp[0]=1? \\n\\t\\t\\t\\t\\t\\t//tell me in the comment section\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<n+1;i++)\\n            dp[i]=(2*dp[i-1]+dp[i-3])%mod;\\n        return dp[n];\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numTilings(int n) {\\n        vector<long long> dp(n+1);\\n        if(n<3)\\n        return n;\\n        dp[0]=1;//here i have taken dp[0]=1 coz at the edge case that is when n=3 dp[n-3] will give the runtime error but can you find a way without putting it dp[0]=1? \\n\\t\\t\\t\\t\\t\\t//tell me in the comment section\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<n+1;i++)\\n            dp[i]=(2*dp[i-1]+dp[i-3])%mod;\\n        return dp[n];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1415741,
                "title": "domino-and-tromino-tiling-java-o-n-solution-using-dynamic-programming",
                "content": "\\tThe pattern here is formed when we consider the domino and tromino arrangements seperately and add them to get total number of arrangements.\\n\\tIndexes (n):    0 1 2 3 4 5 6\\n\\tUsing dominos:  0 1 2 3 5 8 13 and so on\\n\\tUsing trominos: 0 0 0 2 6 16 40 and so on\\n\\tTotal:          0 1 2 5 11 24 53\\n\\t\\n\\tIf we initialise our DP array with these total values, exception being that we put dp[0] = 1 as well, we get 1 1 2 5 11 24 53 where we can see that the pattern is defined by: \\n\\tdp[i] = 2 * dp[i-1] + dp[i-3] \\n\\tFor example, 11 = 2 * 5 + 1\\n\\t             24 = 2 * 11 + 2\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t \\n\\t```\\n\\tprivate static final int MODULO = (int) Math.pow(10, 9) + 7;\\n    public int numTilings(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        long[] dp1 = new long[n+1];\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        for(int i = 3; i < dp1.length; i++){\\n            dp1[i] = (dp1[i-1] * 2 + dp1[i-3])%MODULO;  \\n        }\\n        return (int)dp1[n];\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tprivate static final int MODULO = (int) Math.pow(10, 9) + 7;\\n    public int numTilings(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        long[] dp1 = new long[n+1];\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        for(int i = 3; i < dp1.length; i++){\\n            dp1[i] = (dp1[i-1] * 2 + dp1[i-3])%MODULO;  \\n        }\\n        return (int)dp1[n];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174623,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    int MOD = 1000000007;\\n    int solve(int up, int down)\\n    {\\n        if(up==0 && down==0)\\n            return 1;\\n        if(up<0 || down<0)\\n            return 0;\\n        if(dp[up][down]!=-1)\\n            return dp[up][down];\\n        int ans;\\n        //if up==down then all four types are 1=>put vrrtical 2x1 domino, 2=>put 2 horizontal domino on each other, 3=>put one tromino, 4=>put inverted tromino\\n        if(up==down)\\n        {\\n            ans = (((solve(up-1, down-1)%MOD + solve(up-2, down-2)%MOD)%MOD + solve(up-2, down-1)%MOD)%MOD + solve(up-1, down-2)%MOD)%MOD; \\n        }\\n        //if up is more then down, then we have two cases, 1=>put inverted tromino, 2=>put one horizontal domino at top\\n        else if(up==down+1)\\n        {\\n            ans = (solve(up-2, down-1)%MOD +solve(up-2, down)%MOD)%MOD;\\n        }\\n        //if up is less then down, then we have two cases, 1=>put tromino, 2=>put one horizontal domino at bottom\\n        else if(up==down-1)\\n        {\\n            ans = (solve(up-1, down-2)%MOD + solve(up, down-2)%MOD)%MOD;\\n        }\\n        return dp[up][down] = ans;\\n    }\\n    int numTilings(int N) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(N,N);\\n    }\\n};\\n```\\n\\nI hope you understood my solution.\\nFeel free to ask doubts in comment section.\\nHappy Coding :)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    int MOD = 1000000007;\\n    int solve(int up, int down)\\n    {\\n        if(up==0 && down==0)\\n            return 1;\\n        if(up<0 || down<0)\\n            return 0;\\n        if(dp[up][down]!=-1)\\n            return dp[up][down];\\n        int ans;\\n        //if up==down then all four types are 1=>put vrrtical 2x1 domino, 2=>put 2 horizontal domino on each other, 3=>put one tromino, 4=>put inverted tromino\\n        if(up==down)\\n        {\\n            ans = (((solve(up-1, down-1)%MOD + solve(up-2, down-2)%MOD)%MOD + solve(up-2, down-1)%MOD)%MOD + solve(up-1, down-2)%MOD)%MOD; \\n        }\\n        //if up is more then down, then we have two cases, 1=>put inverted tromino, 2=>put one horizontal domino at top\\n        else if(up==down+1)\\n        {\\n            ans = (solve(up-2, down-1)%MOD +solve(up-2, down)%MOD)%MOD;\\n        }\\n        //if up is less then down, then we have two cases, 1=>put tromino, 2=>put one horizontal domino at bottom\\n        else if(up==down-1)\\n        {\\n            ans = (solve(up-1, down-2)%MOD + solve(up, down-2)%MOD)%MOD;\\n        }\\n        return dp[up][down] = ans;\\n    }\\n    int numTilings(int N) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(N,N);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099691,
                "title": "dynamic-programming-solution-o-n-time-and-o-n-space-solution-with-explaination",
                "content": "Types of Tiles after Rotation\\n\\nType 1 :- ![image](https://assets.leetcode.com/users/images/fd53a390-f070-4023-bb2f-27cfdc8347a1_1615202764.4124565.png)\\nType 2 :- ![image](https://assets.leetcode.com/users/images/bb35864e-7e96-465c-a217-b59cc53e7589_1615202818.247449.png)\\nType 3 :- ![image](https://assets.leetcode.com/users/images/22a86c40-ae82-4ad4-8bf2-40064298fd1f_1615202829.6135092.png)\\nType 4 :- ![image](https://assets.leetcode.com/users/images/9e643e52-9282-437e-a5b6-e6cf042eaad1_1615202853.7448912.png)\\nType 5 :- ![image](https://assets.leetcode.com/users/images/478d29b8-b4c9-4390-972a-318f045d5e72_1615202865.6793249.png)\\nType 6 :- ![image](https://assets.leetcode.com/users/images/0fe046ad-4e14-4bd5-a200-a226361e7a71_1615202876.948113.png)\\n\\n\\nlets **define DP[N]** as number of ways to fill the tiles in first N colums of 2XN grid.\\nlets take every tile as last tile\\n\\n**Type 1** :- number of ways will DP[N-1]\\n**Type 2** :- number of ways will DP[N-2] and we will place two tiles of this type parallely.\\n**Type 3** :- cannot take this, because grid will not end or a box will remain empty.\\n**Type 4** :- cannot take this, because grid will not end or a box will remain empty.\\n**Type 5** :- ![image](https://assets.leetcode.com/users/images/5a30ab43-e84a-407c-b541-65cf2848a654_1615203470.964799.png) number of ways will be number of grids ending with this configuration. **DP_UP[N-1]**\\n**Type 6** :- ![image](https://assets.leetcode.com/users/images/0869b3f6-58f2-49e2-9b57-c20d832ea689_1615203560.9002962.png) number of ways will be the number of grids ending with this configuration. **DP_DOWN[N-1]**.\\n\\n\\nso,\\n**DP[N]=DP[N-1]+DP[N-2] + DP_UP[N-1]+DP_DOWN[N-1]**   --------(A)\\n\\n_________________________________________________________________________________________________\\n\\n\\n![image](https://assets.leetcode.com/users/images/5a73a3c5-3608-41b9-a0d9-0f6539e88dae_1615203738.0106196.png) + ![image](https://assets.leetcode.com/users/images/0ba03912-10e6-496c-937a-de0570a22f8a_1615203749.7741885.png) = ![image](https://assets.leetcode.com/users/images/9e4e590f-c67a-4000-be32-a99a6359f768_1615203780.648613.png)\\n\\n\\nand \\n\\n![image](https://assets.leetcode.com/users/images/284b9f10-0426-45fe-97fa-cb0b67ffe4c7_1615203841.987641.png) + ![image](https://assets.leetcode.com/users/images/60a8d7a7-3659-4cf7-b7bb-4ee755bd65f0_1615203850.8945684.png) =![image](https://assets.leetcode.com/users/images/0762cf9b-94f9-4e9c-b55d-6efe4c14c4d1_1615203866.1455088.png)\\n\\nso,\\n**DP_UP[N]=DP_DOWN[N-1] +DP[N-2]**\\n\\nsimilarly\\n\\n**DP_DOWN[N]=DP_UP[N-1] + DP[N-2]**\\n\\n\\nafter using above relations\\n\\n**DP_UP[N-1]=DP_DOWN[N-2] +DP[N-3]**\\n**DP_DOWN[N-1]=DP_UP[N-2] + DP[N-3]**\\n\\nputting above relations in the Equation A\\n\\nDP[N]=DP[N-1] + DP[N-2] + DP_DOWN[N-2] + DP[N-3] + DP_UP[N-2] + DP[N-3]\\n\\nDP[N]=DP[N-1] + DP[N-3] + **{** DP[N-2] + DP[N-3] +DP_UP[N-2] + DP_DOWN[N-2] **}** \\n\\nabove expression in brackets can be replaced by DP[N-1]\\n\\n\\nso ,\\n\\n\\n**DP[N]=2xDP[N-1] + DP[N-2]**\\n\\nwith base cases of \\nDP[0]=1,DP[1]=1,DP[2]=2\\n\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[1001];\\n    int numTilings(int N) { \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for(int i=3; i<=N; i++){\\n            dp[i] = (2*dp[i-1]%mod + dp[i-3]%mod)%mod;\\n        }\\n        \\n        return dp[N]%mod;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[1001];\\n    int numTilings(int N) { \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for(int i=3; i<=N; i++){\\n            dp[i] = (2*dp[i-1]%mod + dp[i-3]%mod)%mod;\\n        }\\n        \\n        return dp[N]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010393,
                "title": "recursion-memoization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> t;\\n    int solve(int i){\\n        if(i<=1)\\n            return 1;\\n        \\n        if(i==2)\\n            return 2;\\n        \\n        if(t[i]!=-1)\\n            return t[i];\\n        \\n        int ans=0;\\n        ans=((2*solve(i-1))%mod+(solve(i-3))%mod)%mod;\\n        \\n        return t[i]=ans;\\n    }\\n    \\n    int numTilings(int N) {\\n        t.resize(N+1,-1);\\n        return solve(N);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> t;\\n    int solve(int i){\\n        if(i<=1)\\n            return 1;\\n        \\n        if(i==2)\\n            return 2;\\n        \\n        if(t[i]!=-1)\\n            return t[i];\\n        \\n        int ans=0;\\n        ans=((2*solve(i-1))%mod+(solve(i-3))%mod)%mod;\\n        \\n        return t[i]=ans;\\n    }\\n    \\n    int numTilings(int N) {\\n        t.resize(N+1,-1);\\n        return solve(N);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802103,
                "title": "c-2-vectors-dp-with-explanation",
                "content": "The whole area is `N*2`, for each small column `i`, there\\'re three possible states:\\n(1) Both cells in the `i`th column is covered.\\n(2) One cell is covered, while the other not.\\n(3) The other one is covered, symmetric to (2).\\n\\nThen `dp[i][0]` is the number of ways to cover all cells through `0` to `i`, and `dp[i][1]`, `dp[i][2]` is the number of ways to cover all cells through `0` to `i-1` and one of the cells in `i`th column.\\n\\nThe relationship between different states is:\\nFor `dp[i][1]`: it can come from either adding a tromino for `dp[i-2][0]` or adding a domino for `dp[i-1][2]`. And `dp[i][2]` is symmetric.\\nFor `dp[i][0]`: it can come from adding a domino for `dp[i-1][0]`, adding 2 horizontal dominos for `dp[i-2][0]`, or adding a tromino for either `dp[i-1][1]` or `dp[i-1][2]`.\\n\\nFinally, `dp[N-1][0]` is the answer. Since state (2) and (3) are symmetric, we can use one vector for both states.\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        if (N <= 2) return N;\\n        const long r = 1000000007;\\n        vector<vector<long>> dp(N, vector<long>(2,0));\\n        dp[0][0] = 1;\\n        dp[1][0] = 2;\\n        dp[1][1] = 1;\\n        for (int i = 2; i < N; i++) {\\n            dp[i][0] = (dp[i-2][0] + dp[i-1][1] * 2 + dp[i-1][0]) % r;\\n            dp[i][1] = (dp[i-2][0] + dp[i-1][1]) % r;\\n        }\\n        return dp[N-1][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        if (N <= 2) return N;\\n        const long r = 1000000007;\\n        vector<vector<long>> dp(N, vector<long>(2,0));\\n        dp[0][0] = 1;\\n        dp[1][0] = 2;\\n        dp[1][1] = 1;\\n        for (int i = 2; i < N; i++) {\\n            dp[i][0] = (dp[i-2][0] + dp[i-1][1] * 2 + dp[i-1][0]) % r;\\n            dp[i][1] = (dp[i-2][0] + dp[i-1][1]) % r;\\n        }\\n        return dp[N-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493004,
                "title": "python-simple-and-easy-to-understand-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def numTilings(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[[0,0,0] for i in range(N+1)]\\n        dp[0][0]=dp[1][0]=1\\n        \\n         #Define: dp[i][0] is number of ways to cover i column, in which both top row and bottom row are coverd: e.g. XXX\\n         #                                                                                                            XXX\\n         #        dp[i][1] is number of ways to cover i column, in which the last spot of bottom row is empty:   e.g. XXX\\n         #                                                                                                            XX   \\n         #        dp[i][2] is number of ways to cover i column, in which the last spot of top row is empty:      e.g. XX\\n         #                                                                                                            XXX\\n        \\n        #   Thus for dp[i][0], there are four ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXXY XXYY XXXY XXYY\\n        #       XXXY XXZZ XXYY XXXY\\n        \\n        \\n        #   Thus for dp[i][1], there are two ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXYY XXYY\\n        #       XXY  XXX\\n        \\n        \\n        #   Similarly for dp[i][2], there are two ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXY   XXX\\n        #       XXYY  XXYY\\n        \\n        for i in range(2,N+1):\\n            dp[i][0]=dp[i-1][0]+dp[i-2][0]+dp[i-1][1]+dp[i-1][2]\\n            dp[i][1]=dp[i-2][0]+dp[i-1][2]\\n            dp[i][2]=dp[i-2][0]+dp[i-1][1]\\n        \\n        return dp[i][0]%(10**9+7)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numTilings(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[[0,0,0] for i in range(N+1)]\\n        dp[0][0]=dp[1][0]=1\\n        \\n         #Define: dp[i][0] is number of ways to cover i column, in which both top row and bottom row are coverd: e.g. XXX\\n         #                                                                                                            XXX\\n         #        dp[i][1] is number of ways to cover i column, in which the last spot of bottom row is empty:   e.g. XXX\\n         #                                                                                                            XX   \\n         #        dp[i][2] is number of ways to cover i column, in which the last spot of top row is empty:      e.g. XX\\n         #                                                                                                            XXX\\n        \\n        #   Thus for dp[i][0], there are four ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXXY XXYY XXXY XXYY\\n        #       XXXY XXZZ XXYY XXXY\\n        \\n        \\n        #   Thus for dp[i][1], there are two ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXYY XXYY\\n        #       XXY  XXX\\n        \\n        \\n        #   Similarly for dp[i][2], there are two ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXY   XXX\\n        #       XXYY  XXYY\\n        \\n        for i in range(2,N+1):\\n            dp[i][0]=dp[i-1][0]+dp[i-2][0]+dp[i-1][1]+dp[i-1][2]\\n            dp[i][1]=dp[i-2][0]+dp[i-1][2]\\n            dp[i][2]=dp[i-2][0]+dp[i-1][1]\\n        \\n        return dp[i][0]%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 393645,
                "title": "concise-dp-solution-o-n-time-o-1-space-picture-illustration-no-lengthy-math-derivation",
                "content": "It\\'s clear that DP is the best way to solve it. However, many solutions seem to have lengthy math drivation before deriving the transfer equation.\\n\\nIf we define two tilting problems, the logic seems a lot simpler:\\n* Let `a[n]` be the tiling ways for `2*n` board (i.e., the answer)\\n* Let `b[n]` be the tiling ways for `2*n+1` board (i.e., the helper DP array)\\n\\nWe have transfer equations:\\n```cpp\\na[n] = a[n-1] + a[n-2] + 2*b[n-2];\\nb[n] = a[n-1] + b[n-1];\\n```\\nwith initial conditions:\\n```cpp\\na[0] = 1, a[1] = 1, b[0] = 0, b[1] = 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/zzg_zzm/image_1569793400.png)\\n\\n```cpp\\n    int numTilings(int n) {\\n      if (n == 1) return 1;\\n      \\n      // initial values\\n      long a, a_pre1 = 1, a_pre2 = 1; // 2xn solution\\n      long b, b_pre1 = 1, b_pre2 = 0; // 2xn+1 solution\\n      const long mod = 1000000007;      \\n      \\n      while (--n >= 1) // iterate n-1 times\\n      { \\n        a = (a_pre1 + a_pre2 + 2*b_pre2)%mod;\\n        b = (a_pre1 + b_pre1)%mod;\\n        \\n        // update a and b\\n        a_pre2 = a_pre1;\\n        a_pre1 = a;\\n        \\n        b_pre2 = b_pre1;\\n        b_pre1 = b;\\n      }\\n      return a;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\na[n] = a[n-1] + a[n-2] + 2*b[n-2];\\nb[n] = a[n-1] + b[n-1];\\n```\n```cpp\\na[0] = 1, a[1] = 1, b[0] = 0, b[1] = 1;\\n```\n```cpp\\n    int numTilings(int n) {\\n      if (n == 1) return 1;\\n      \\n      // initial values\\n      long a, a_pre1 = 1, a_pre2 = 1; // 2xn solution\\n      long b, b_pre1 = 1, b_pre2 = 0; // 2xn+1 solution\\n      const long mod = 1000000007;      \\n      \\n      while (--n >= 1) // iterate n-1 times\\n      { \\n        a = (a_pre1 + a_pre2 + 2*b_pre2)%mod;\\n        b = (a_pre1 + b_pre1)%mod;\\n        \\n        // update a and b\\n        a_pre2 = a_pre1;\\n        a_pre1 = a;\\n        \\n        b_pre2 = b_pre1;\\n        b_pre1 = b;\\n      }\\n      return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 317471,
                "title": "python-intuitive-dfs-based-solution",
                "content": "This solution is intuitive enough to answer in an interview scenario, and greatly demonstrates the analytical skills when approaching such problem.\\n\\nFirst, imagine we are putting the tiles one by one.  We have 8 types of tiles:\\n```\\n        Types # 0  1   2   3   4   5   6   7 \\n        of      X  XX      X   XX  XX   X  XX\\n        Tile    X      XX  XX  X    X  XX  YY\\n```\\nSide note, you might notice that #1 and #2 is identical to #7, this will be explained later.\\n\\nThen, we define 3 kinds of **states**, which represents that after we finished putting first k columns, there should be either: **No additional block**, **one block at top** or **one block at bottom**, illustrates as below:\\n```\\n        States:\\n        \\n        #0 - Empty: .......\\n                    .......\\n                   \\n        #1 - Up:    ......X\\n                    ......\\n        \\n        #2 - Down:  ......\\n                    ......X\\n```\\n\\nThen, we can define the process of putting the tile.  For example, In state 0, we can put an additional tile #0, #3, #4 or #7.  \\n\\n```\\n        Transitions:\\n        State #0: Accepts tile 0, 3, 4, 7\\n        State #1: Accepts tile 2, 6\\n        State #2: Accepts tile 1, 5\\n```\\nAs for why we separate the tile #1 #2 and tile #7, it\\'s because we want to keep the states simple, we dont want something like state #0 plus a tile #1, results in two more additional blocks at top.\\n\\nHaving defined all these, we can simply just run a DFS with a dictionary to keep intermediate results:\\n```\\nclass Solution(object):\\n    def numTilings(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        self.h = {}\\n        self.M = 10**9 + 7\\n        return self.dfs(N, 0)\\n        \\n    def dfs(self, N, state):\\n        key = (N,state)\\n        \\n        if key in self.h:\\n            return self.h[key]\\n        \\n        if N<=1:\\n            ans = 1\\n\\n        elif N==2:\\n            ans = 2 if state==0 else 1\\n            \\n        elif state==0:\\n            ans = self.dfs(N-1,0) + self.dfs(N-1,2) + self.dfs(N-1,1) + self.dfs(N-2,0)\\n        \\n        elif state==1:\\n            ans = self.dfs(N-1,2) + self.dfs(N-2,0)\\n        \\n        elif state==2:\\n            ans = self.dfs(N-1,1) + self.dfs(N-2,0)\\n            \\n        ans %= self.M\\n        self.h[key] = ans\\n        return ans\\n```\\n        \\n        \\n",
                "solutionTags": [],
                "code": "```\\n        Types # 0  1   2   3   4   5   6   7 \\n        of      X  XX      X   XX  XX   X  XX\\n        Tile    X      XX  XX  X    X  XX  YY\\n```\n```\\n        States:\\n        \\n        #0 - Empty: .......\\n                    .......\\n                   \\n        #1 - Up:    ......X\\n                    ......\\n        \\n        #2 - Down:  ......\\n                    ......X\\n```\n```\\n        Transitions:\\n        State #0: Accepts tile 0, 3, 4, 7\\n        State #1: Accepts tile 2, 6\\n        State #2: Accepts tile 1, 5\\n```\n```\\nclass Solution(object):\\n    def numTilings(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        self.h = {}\\n        self.M = 10**9 + 7\\n        return self.dfs(N, 0)\\n        \\n    def dfs(self, N, state):\\n        key = (N,state)\\n        \\n        if key in self.h:\\n            return self.h[key]\\n        \\n        if N<=1:\\n            ans = 1\\n\\n        elif N==2:\\n            ans = 2 if state==0 else 1\\n            \\n        elif state==0:\\n            ans = self.dfs(N-1,0) + self.dfs(N-1,2) + self.dfs(N-1,1) + self.dfs(N-2,0)\\n        \\n        elif state==1:\\n            ans = self.dfs(N-1,2) + self.dfs(N-2,0)\\n        \\n        elif state==2:\\n            ans = self.dfs(N-1,1) + self.dfs(N-2,0)\\n            \\n        ans %= self.M\\n        self.h[key] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182594,
                "title": "python-1-liner-o-log-n-time-o-1-space-with-explanation",
                "content": "1-liner:\\n```python\\ndef numTilings(self, N):\\n    return (lambda m: m[0][0] - m[1][0])(numpy.linalg.matrix_power(numpy.array([[2,0,1],[1,0,0],[0,1,0]], dtype=object), N)) % 1000000007\\n```\\n---\\n\\n### Explanation\\n\\n**Short version:** If you already know why the recurrence relation `t[k] = 2 * t[k-1] + t[k-3]` is true, then just observe that it can be written as follows:\\n```\\nt[k]   = 2 * t[k-1] + 0 * t[k-2] + 1 * t[k-3]\\nt[k-1] = 1 * t[k-1] + 0 * t[k-2] + 0 * t[k-3]\\nt[k-2] = 0 * t[k-1] + 1 * t[k-2] + 0 * t[k-3]\\n```\\n**Long version:** This is easiest to understand if you try to answer _two_ questions instead of one:\\n1. Let `d(k)` be the number of ways can you tile a `2 * k` board.\\n2. Let `t(k)` be the number of ways you can tile a `2 * k + 1` board.\\n\\nFor example, a `2 * 3 + 1` board looks like this:\\n```abc\\n    +---+---+---+\\n    |   |   |   |\\n+---+---+---+---+\\n|   |   |   |   |\\n+---+---+---+---+\\n```\\nThere is a mutually recursive relation between `d(k)` and `t(k)`. First note that `t(k) == t(k-1) + d(k-1)`:\\n```\\n    +---+---+---+        +---+---+---+        +---+---+---+\\n    |   |   |   |        |   |   |   |        | X |   |   |\\n+---+---+---+---+    +---+---+---+---+    +---+---+---+---+\\n|   |   |   |   |    | X | X |   |   |    | X | X |   |   |\\n+---+---+---+---+    +---+---+---+---+    +---+---+---+---+\\n\\n      t(3)        ==       t(2)        +        d(2)\\n```\\nMore to come...\\n",
                "solutionTags": [],
                "code": "```python\\ndef numTilings(self, N):\\n    return (lambda m: m[0][0] - m[1][0])(numpy.linalg.matrix_power(numpy.array([[2,0,1],[1,0,0],[0,1,0]], dtype=object), N)) % 1000000007\\n```\n```\\nt[k]   = 2 * t[k-1] + 0 * t[k-2] + 1 * t[k-3]\\nt[k-1] = 1 * t[k-1] + 0 * t[k-2] + 0 * t[k-3]\\nt[k-2] = 0 * t[k-1] + 1 * t[k-2] + 0 * t[k-3]\\n```\n```abc\\n    +---+---+---+\\n    |   |   |   |\\n+---+---+---+---+\\n|   |   |   |   |\\n+---+---+---+---+\\n```\n```\\n    +---+---+---+        +---+---+---+        +---+---+---+\\n    |   |   |   |        |   |   |   |        | X |   |   |\\n+---+---+---+---+    +---+---+---+---+    +---+---+---+---+\\n|   |   |   |   |    | X | X |   |   |    | X | X |   |   |\\n+---+---+---+---+    +---+---+---+---+    +---+---+---+---+\\n\\n      t(3)        ==       t(2)        +        d(2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 116649,
                "title": "790-domino-and-tromino-tiling-c-with-brief-explanation-pics",
                "content": "The following is the my way to solve the problem, for better graphs (sorry for my poor draw skills), please check [Stack Exchange: Domino and Tromino Combined Tiling](https://cs.stackexchange.com/questions/66658/domino-and-tromino-combined-tiling)\nI use 2 * 7 as an example, f(n) means the ways of tiling for 2 * n.\nFor f(7), we can split it into different part, and remeber, for the Tromino, they must appear by pairs.\n\n**f(6)** : In my graph, if the f(7) comes from f(6), obviously, there is only 1 way for tiling.\n**f(5)**:  if the f(7) comes from f(5), there is a 2 * 2 region, also only 1 way. I also stated that why not another possible (lets call it as possible **A5** ) arrangement, because it has been considered in the f(6).\n\nThen you should note that we are caring about the tails of each arragement, for f(5), the possible **A5** has the same tail as the possible in the f(6). Then possible **A5** in f(5) must be considered in f(6). The same logic for the following analysis. So here we find out that each time when we consider some possible arrangement, we will compare the tail of new possible way with the previous possibilities.\n\nThen by my analysis, we have the formula:\n\n**f(n) = f(n-3) + 2 * f(n-1)**\n\nAlso, boundaries: \nf(0) = 0\nf(1) = 1\nf(2) = 2\nf(3) = 5\n![image](https://s3-lc-upload.s3.amazonaws.com/users/jasonshieh/image_1519577577.png)\n\n\n\nC++ code:\n\n\tclass Solution {\n\tpublic:\n\t\t\tint numTilings(int N) {\n\t\t\t\t\tint MOD =  1000000007;\n\t\t\t\t\tvector<long> dp = {0,1,2,5};\n\t\t\t\t\tfor(int i = 4; i <= N; ++i){\n\t\t\t\t\t\t\tdp.push_back((dp[i-3] + 2*dp[i-1])%MOD);\n\t\t\t\t\t}\n\t\t\t\t\treturn dp[N]%MOD;\n\t\t\t}\n\t};\n\t\n\t\n\n*So any commentaries for saving time/space complexity?\nThanks.*\n",
                "solutionTags": [],
                "code": "class Solution {\n\tpublic:\n\t\t\tint numTilings(int N) {\n\t\t\t\t\tint MOD =  1000000007;\n\t\t\t\t\tvector<long> dp = {0,1,2,5}",
                "codeTag": "Java"
            },
            {
                "id": 116558,
                "title": "easy-python-4-liner-memoization-with-explanation",
                "content": "Let's look at the cases for the last column(s), i.e. the end of the tiling.  It is either of:\n```\nX\nX\n```\n```\nXX\nYY\n```\n```\n*X\nXX\n```\nIf we denote the function `c(N)` as the number of tilings on a 2xN board, then the number of tilings in the first two cases are `c(N-1)` and `c(N-2)` respectively.\n\nFor the last case, observe that the first L-tromino *before* the one we have completes a rectangular board, and furthermore that tromino must be one of the cases:\n```\nY****X\nYY**XX\n```\nor\n```\nYY**X\nY**XX\n```\nThe number of possibilities of the former is `sum([c(i) for i in range(N-4, -1, -2)])` and the number of possibilities of the latter is `sum([c(i) for i in range(N-3, -1, -2)])`.  Remember that the stars can be any number of (horizontal) regular dominoes.\n\nWe have the analogous case of the last L tromino being\n```\nXX\n*X\n```\nso we double the count.\n\nHere is the solution:\n```\n    def numTilings(self, N):\n        c = [1, 1, 2, 5] + [1 for i in range(N+1-4)]\n        for i in range(4, N+1):\n            c[i] = 2*sum(c[:i-2]) + c[i-2] + c[i-1]\n        return c[N] % (10**9 + 7)\n```",
                "solutionTags": [],
                "code": "```\nX\nX\n```\n```\nXX\nYY\n```\n```\n*X\nXX\n```\n```\nY****X\nYY**XX\n```\n```\nYY**X\nY**XX\n```\n```\nXX\n*X\n```\n```\n    def numTilings(self, N):\n        c = [1, 1, 2, 5] + [1 for i in range(N+1-4)]\n        for i in range(4, N+1):\n            c[i] = 2*sum(c[:i-2]) + c[i-2] + c[i-1]\n        return c[N] % (10**9 + 7)\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4036760,
                "title": "domino-and-tromino-tiling-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int first  = 0 ,second = 1 , third = 1 , next , mod = 1e9+7 ;\\n        while(--n)\\n        {\\n            next = ((third * 2) %mod + first)%mod ;\\n            first = second ;\\n            second = third ;\\n            third = next ;\\n        }\\n        return third ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int first  = 0 ,second = 1 , third = 1 , next , mod = 1e9+7 ;\\n        while(--n)\\n        {\\n            next = ((third * 2) %mod + first)%mod ;\\n            first = second ;\\n            second = third ;\\n            third = next ;\\n        }\\n        return third ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574732,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used concept of recurison .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==0||n==1) return 1;\\n        \\n        if(n==2) return n;\\n        if(n==3) return 5;\\n      long f1=1;\\n      long f2=2;\\n      long f3=5;\\n      long mod=1000000007;\\n      for(int i=4;i<=n;i++){\\n        long ans=(f3*2+f1)%mod;\\n        f1=f2;\\n        f2=f3;\\n        f3=ans;\\n      }\\n       return (int)f3;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==0||n==1) return 1;\\n        \\n        if(n==2) return n;\\n        if(n==3) return 5;\\n      long f1=1;\\n      long f2=2;\\n      long f3=5;\\n      long mod=1000000007;\\n      for(int i=4;i<=n;i++){\\n        long ans=(f3*2+f1)%mod;\\n        f1=f2;\\n        f2=f3;\\n        f3=ans;\\n      }\\n       return (int)f3;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468199,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int MOD = 1e9+ 7;\\n        if (n <= 2) {\\n            return n;\\n        }\\n        long fCurrent = 5L;\\n        long fPrevious = 2L; \\n        long fBeforePrevious = 1L; \\n        for (int k = 4; k < n + 1; ++k) {\\n            long tmp = fPrevious;\\n            fPrevious = fCurrent; \\n            fCurrent = (2 * fCurrent + fBeforePrevious) % MOD;\\n            fBeforePrevious = tmp;\\n        }\\n        return fCurrent;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        dp = [1, 2, 5] + [0] * n\\n        for i in range(3, n):\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\\n        return dp[n - 1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==1)\\n        return 1;\\n        else if(n==2)\\n        return 2;\\n      int mod = 1000000007;\\n\\n    int [] dp=new int[n+1];\\n\\n    dp[1]=1;\\n    dp[2]=2;\\n    dp[3]=5;\\n    for(int i =4;i<=n;i++){\\n        dp[i]=(2*dp[i-1]%mod+dp[i-3]%mod)%mod;\\n    }\\n    return dp[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int MOD = 1e9+ 7;\\n        if (n <= 2) {\\n            return n;\\n        }\\n        long fCurrent = 5L;\\n        long fPrevious = 2L; \\n        long fBeforePrevious = 1L; \\n        for (int k = 4; k < n + 1; ++k) {\\n            long tmp = fPrevious;\\n            fPrevious = fCurrent; \\n            fCurrent = (2 * fCurrent + fBeforePrevious) % MOD;\\n            fBeforePrevious = tmp;\\n        }\\n        return fCurrent;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        dp = [1, 2, 5] + [0] * n\\n        for i in range(3, n):\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\\n        return dp[n - 1]\\n```\n```Java []\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==1)\\n        return 1;\\n        else if(n==2)\\n        return 2;\\n      int mod = 1000000007;\\n\\n    int [] dp=new int[n+1];\\n\\n    dp[1]=1;\\n    dp[2]=2;\\n    dp[3]=5;\\n    for(int i =4;i<=n;i++){\\n        dp[i]=(2*dp[i-1]%mod+dp[i-3]%mod)%mod;\\n    }\\n    return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452574,
                "title": "o-n-solution-different-approach-to-divide-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is best explained by drawing out the case for `n = 4`, see below\\n\\n![IMG_4469.jpg](https://assets.leetcode.com/users/images/38aaac09-39b5-420e-8bcf-b1226c4e435e_1682396413.6945324.jpeg)\\n\\nHere, we define a function `no_div(n)`, meaning the number of non-subdivisible patterns that can form a complete rectangle of size `2 * n`. Draw out some example. You\\'ll notice that for `no_div(1) = 1, no_div(2) = 1, no_div(n) = 2 for n > 2`. Such non-subdivisible pattern is found on the top right of the image for `n = 4`, and you can similarly draw out for other `n`s (these 2 will be mirroring images).\\n\\nOnce noticing this, following my drawing that uses the subproblem division. This shrinking subproblem division approach is likely to be the most common first idea for many people. We start from the first subproblem where `n = 3`, and from the example of the question we already have the answer. Then for `n = 2`, and we start to notice some duplicates.\\n\\nHowever, you\\'ll find that all the duplicates that we crossed out are ones that has __subdivisible patterns__ for the part that is NOT covered by the subproblem, such as `||` (which can be subdivided into `|` and `|`). On the other hand, the pattern `\\u4E8C` is not subdivisible.\\n\\nThis trend also applies to `n = 1`, where the solutions with subdivisible patterns `\\u4E8C|`, `|\\u4E8C`, `|||` are all crossed out. Therefore, we will only multiply the count of non-subdivisble patterns with the remaining subproblem\\'s solution to add to our solution.\\n\\n# Approach\\n\\nAbove arrives at the following formula:\\n\\n```\\ndp[i] = no_div(i) + no_div(1)*dp[i-1] + no_div(2)*dp[i-2] + no_div(3)*dp[i-3] + ... + no_div(i-1)*dp[1]\\n      = 2 + dp[i-1] + dp[i-2] + 2*dp[i-3] + ... + 2*dp[1]\\n```\\n\\nNow the optimization: reading this formula, it will make clear that many of the terms here are likely also present in `dp[i-1]`, which is\\n\\n```\\ndp[i-1] = no_div(i) + no_div(1)*dp[i-2] + no_div(2)*dp[i-3] + ... + no_div(i-3)*dp[2] + no_div(i-2)*dp[1]\\n        = 2 + dp[i-2] + dp[i-3] + 2*dp[i-4] + ... + 2*dp[1]\\n\\n```\\n\\nSubtract, and you\\'ll get\\n\\n```\\ndp[i] - dp[i-1] = dp[i-1] + dp[i-3]\\ndp[i] = 2*dp[i-1] + dp[i-3]\\n```\\n\\nAnd we got our O(n) formula!\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n), but apparently can be optimized to O(1) by reducing storage.\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        dp = [0] * (n+1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        dp[2] = 2\\n\\n        for i in range(3, n+1):\\n            dp[i] = (2*dp[i-1] + dp[i-3]) % (10**9 + 7)\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndp[i] = no_div(i) + no_div(1)*dp[i-1] + no_div(2)*dp[i-2] + no_div(3)*dp[i-3] + ... + no_div(i-1)*dp[1]\\n      = 2 + dp[i-1] + dp[i-2] + 2*dp[i-3] + ... + 2*dp[1]\\n```\n```\\ndp[i-1] = no_div(i) + no_div(1)*dp[i-2] + no_div(2)*dp[i-3] + ... + no_div(i-3)*dp[2] + no_div(i-2)*dp[1]\\n        = 2 + dp[i-2] + dp[i-3] + 2*dp[i-4] + ... + 2*dp[1]\\n\\n```\n```\\ndp[i] - dp[i-1] = dp[i-1] + dp[i-3]\\ndp[i] = 2*dp[i-1] + dp[i-3]\\n```\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        dp = [0] * (n+1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        dp[2] = 2\\n\\n        for i in range(3, n+1):\\n            dp[i] = (2*dp[i-1] + dp[i-3]) % (10**9 + 7)\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387487,
                "title": "best-solution-simple-approach",
                "content": "\\n# Approach\\nthink like in start we have the 0th column empty so we need to fill it first we have four ways to fill it(here 0 means emplty cell 1 means filled) see last ifelse condition. u^d means if upper is epmty ans lower is filled or vice verca then we have 2 ways use a trainagular peice or a horizonatal peice . if both is 1 then simply we ask i+1 for 0 0.\\nbase case is wehn we go ou of block i.e i==n then both up and down shuould be 0 0\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n;\\nint mod=1e9+7;\\nint dp[1001][2][2];\\nint fun(int i,bool u,bool l){\\n\\n    if(i>n) return 0;\\n    if(i==n){\\n        if(u==0 && l==0) return 1;\\n        return 0;\\n    }\\n    if(dp[i][u][l]!=-1) return dp[i][u][l];\\n        int ans=0;\\n    if(u==0 && l==0){\\n        //vertical\\n        ans=(ans+fun(i+1,0,0))%mod;\\n        //horizontal\\n        ans=(ans+fun(i+2,0,0))%mod;\\n        //triangular\\n        ans=(ans+fun(i+1,1,0))%mod;\\n        //ulta tragunlar\\n        ans=(ans+fun(i+1,0,1))%mod;\\n    }\\n\\n    if(u==1 && l==1){\\n        ans=(ans+fun(i+1,0,0))%mod;\\n    }\\n\\n    if(u^l){\\n        // if(u==1)\\n         ans=(ans+fun(i+1,!u,!l))%mod;\\n\\n        ans=(ans+fun(i+1,1,1))%mod;\\n    }\\n\\n    // if(u==1 && l==0){\\n    //     //domino\\n    //     ans=(ans+fun(i+1,0,1))%mod;\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n    // else if(u==0 && l==1){\\n    //      ans=(ans+fun(i+1,1,0))%mod;\\n    //      //tromino\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n\\n    return dp[i][u][l]=ans;\\n}\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n;\\nint mod=1e9+7;\\nint dp[1001][2][2];\\nint fun(int i,bool u,bool l){\\n\\n    if(i>n) return 0;\\n    if(i==n){\\n        if(u==0 && l==0) return 1;\\n        return 0;\\n    }\\n    if(dp[i][u][l]!=-1) return dp[i][u][l];\\n        int ans=0;\\n    if(u==0 && l==0){\\n        //vertical\\n        ans=(ans+fun(i+1,0,0))%mod;\\n        //horizontal\\n        ans=(ans+fun(i+2,0,0))%mod;\\n        //triangular\\n        ans=(ans+fun(i+1,1,0))%mod;\\n        //ulta tragunlar\\n        ans=(ans+fun(i+1,0,1))%mod;\\n    }\\n\\n    if(u==1 && l==1){\\n        ans=(ans+fun(i+1,0,0))%mod;\\n    }\\n\\n    if(u^l){\\n        // if(u==1)\\n         ans=(ans+fun(i+1,!u,!l))%mod;\\n\\n        ans=(ans+fun(i+1,1,1))%mod;\\n    }\\n\\n    // if(u==1 && l==0){\\n    //     //domino\\n    //     ans=(ans+fun(i+1,0,1))%mod;\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n    // else if(u==0 && l==1){\\n    //      ans=(ans+fun(i+1,1,0))%mod;\\n    //      //tromino\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n\\n    return dp[i][u][l]=ans;\\n}\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387483,
                "title": "very-simple-approach-with-simple-intuition",
                "content": "\\n# Approach\\nThink like in start we have the 0th column empty so we need to fill it first we have four ways to fill it(here 0 means emplty cell 1 means filled) see last ifelse condition. u^d means if upper is epmty ans lower is filled or vice verca then we have 2 ways use a trainagular peice or a horizonatal peice . if both is 1 then simply we ask i+1 for 0 0.\\nbase case is wehn we go ou of block i.e i==n then both up and down shuould be 0 0\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n;\\nint mod=1e9+7;\\nint dp[1001][2][2];\\nint fun(int i,bool u,bool l){\\n\\n    if(i>n) return 0;\\n    if(i==n){\\n        if(u==0 && l==0) return 1;\\n        return 0;\\n    }\\n    if(dp[i][u][l]!=-1) return dp[i][u][l];\\n        int ans=0;\\n    if(u==0 && l==0){\\n        //vertical\\n        ans=(ans+fun(i+1,0,0))%mod;\\n        //horizontal\\n        ans=(ans+fun(i+2,0,0))%mod;\\n        //triangular\\n        ans=(ans+fun(i+1,1,0))%mod;\\n        //ulta tragunlar\\n        ans=(ans+fun(i+1,0,1))%mod;\\n    }\\n\\n    if(u==1 && l==1){\\n        ans=(ans+fun(i+1,0,0))%mod;\\n    }\\n\\n    if(u^l){\\n        // if(u==1)\\n         ans=(ans+fun(i+1,!u,!l))%mod;\\n\\n        ans=(ans+fun(i+1,1,1))%mod;\\n    }\\n\\n    // if(u==1 && l==0){\\n    //     //domino\\n    //     ans=(ans+fun(i+1,0,1))%mod;\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n    // else if(u==0 && l==1){\\n    //      ans=(ans+fun(i+1,1,0))%mod;\\n    //      //tromino\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n\\n    return dp[i][u][l]=ans;\\n}\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n;\\nint mod=1e9+7;\\nint dp[1001][2][2];\\nint fun(int i,bool u,bool l){\\n\\n    if(i>n) return 0;\\n    if(i==n){\\n        if(u==0 && l==0) return 1;\\n        return 0;\\n    }\\n    if(dp[i][u][l]!=-1) return dp[i][u][l];\\n        int ans=0;\\n    if(u==0 && l==0){\\n        //vertical\\n        ans=(ans+fun(i+1,0,0))%mod;\\n        //horizontal\\n        ans=(ans+fun(i+2,0,0))%mod;\\n        //triangular\\n        ans=(ans+fun(i+1,1,0))%mod;\\n        //ulta tragunlar\\n        ans=(ans+fun(i+1,0,1))%mod;\\n    }\\n\\n    if(u==1 && l==1){\\n        ans=(ans+fun(i+1,0,0))%mod;\\n    }\\n\\n    if(u^l){\\n        // if(u==1)\\n         ans=(ans+fun(i+1,!u,!l))%mod;\\n\\n        ans=(ans+fun(i+1,1,1))%mod;\\n    }\\n\\n    // if(u==1 && l==0){\\n    //     //domino\\n    //     ans=(ans+fun(i+1,0,1))%mod;\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n    // else if(u==0 && l==1){\\n    //      ans=(ans+fun(i+1,1,0))%mod;\\n    //      //tromino\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n\\n    return dp[i][u][l]=ans;\\n}\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950979,
                "title": "o-1-time-complexity-python-solution",
                "content": "# Intuition\\nUse your O(n) solution to create an array of size 1000. Next, perform dp[i] % (10**9+7) for each dp of i so that leetcode can fit your answer! The following dp array looks like this:\\n\\n# Code\\n```\\nclass Solution(object):\\n        def numTilings(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # dp = [1,2,5,11]\\n        \\n        # for i in range (4,n):\\n        #     dp.append(dp[i-3] + 2*dp[i-1])\\n\\n        dp = [1, 2, 5, 11, 24, 53, 117, 258, 569, 1255, 2768, 6105, 13465, 29698, 65501, 144467, 318632, 702765, 1549997, 3418626, 7540017, 16630031, 36678688, 80897393, 178424817, 393528322, 867954037, 914332884, 222194076, 312342182, 539017241, 300228551, 912799284, 364615795, 29460134, 971719552, 308054885, 645569904, 262859346, 833773577, 313117044, 889093434, 611960431, 537037899, 963169225, 538298867, 613635626, 190440463, 919179793, 451995198, 94430852, 108041490, 668078178, 430587201, 969215892, 606509948, 643607090, 256430058, 119370057, 882347204, 21124452, 161618961, 205585119, 432294690, 26208334, 258001787, 948298264, 922804855, 103611483, 155521223, 233847294, 571306071, 298133358, 830114010, 231534077, 761201512, 352517020, 936568117, 634337732, 621192477, 178953057, 992243846, 605680155, 390313360, 772870559, 151421259, 693155878, 159182301, 469785861, 632727593, 424637480, 319060814, 270849214, 966335908, 251732616, 774314446, 514964786, 281662181, 337638801, 190242381, 662146943, 661932680, 514107734, 690362404, 42657474, 599422682, 889207761, 821072989, 241568646, 372345046, 565763074, 373094787, 118534613, 802832300, 978759380, 76053359, 954939018, 888637402, 853328156, 661595316, 211828020, 276984189, 215563687, 642955394, 562894970, 341353620, 325662627, 214220217, 769794054, 865250728, 944721666, 659237372, 183725458, 312172575, 283582515, 750890488, 813953544, 911489596, 573869666, 961692869, 834875320, 243620292, 448933446, 732742205, 709104695, 867142829, 467027849, 643160386, 153463587, 773955023, 191070418, 535604423, 845163862, 881398135, 298400679, 441965213, 765328554, 829057780, 100080759, 965490072, 760037910, 620156572, 205803202, 171644307, 963445186, 132693560, 437031427, 837508033, 807709619, 52450651, 942409335, 692528275, 437507194, 817423716, 327375693, 92258573, 1940855, 331257403, 754773379, 511487606, 354232608, 463238588, 437964775, 230162151, 923562890, 285090541, 800343233, 524249342, 333589218, 467521662, 459292659, 252174529, 971870720, 403034085, 58242692, 88356097, 579746279, 217735243, 523826583, 627399438, 472534112, 468894800, 565189031, 602912167, 674719127, 914627278, 432166709, 539052538, 992732347, 417631389, 374315309, 741362958, 900357298, 175029891, 91422733, 83202757, 341435405, 774293543, 631789836, 605015070, 984323676, 600437174, 805889411, 596102484, 792642135, 391173667, 378449811, 549541750, 490257160, 358964124, 267469991, 25197135, 409358394, 86186772, 197570679, 804499752, 695186269, 587943210, 980386165, 655958585, 899860373, 780106897, 216172365, 332205096, 444517082, 105206522, 542618140, 529753355, 164713225, 872044590, 273842521, 712398267, 296841110, 867524741, 447447735, 191736573, 250997880, 949443495, 90623549, 432244978, 813933444, 718490430, 869225831, 552385092, 823260607, 515747031, 583879147, 991018894, 497784805, 579448750, 149916380, 797617565, 174683866, 499284112, 796185782, 767055423, 33394944, 862975670, 493006749, 19408435, 901792540, 296591815, 612592065, 126976656, 550545127, 713682312, 554341273, 659227666, 32137630, 618616533, 896460725, 825059073, 268734665, 433930048, 692919162, 654572982, 743076005, 179071158, 12715291, 768506587, 716084325, 444883934, 658274448, 32633207, 510150348, 678575137, 389783474, 289717289, 258009708, 905802890, 101323055, 460655818, 827114519, 755552086, 971759983, 770634471, 296821014, 565402004, 901438472, 99697944, 764797892, 431034242, 961766428, 688330734, 807695703, 577157820, 842646367, 492988423, 563134659, 968915678, 430819765, 424774182, 818464035, 67747821, 560269824, 939003676, 945755166, 451780142, 842563953, 630883058, 713546251, 269656441, 170195933, 53938110, 377532661, 925261255, 904460613, 186453873, 298168994, 500798594, 188051054, 674271102, 849340791, 886732629, 447736346, 744813476, 376359567, 200455473, 145724415, 667808397, 536072260, 217868928, 103546246, 743164752, 704198425, 511943089, 767050923, 238300257, 988543603, 744138115, 726576480, 441696549, 627531206, 981638885, 404974305, 437479809, 856598496, 118171283, 673822375, 204243232, 526657747, 727137862, 658518949, 843695638, 414529124, 487577190, 818850011, 52229132, 592035454, 2920905, 58070942, 708177338, 419275574, 896622090, 501421504, 422118575, 740859233, 983139963, 388398487, 517656200, 18452349, 425303185, 368262563, 754977475, 935258128, 238778805, 232535078, 400328277, 39435352, 311405782, 23139834, 85715020, 482835822, 988811478, 63337962, 609511746, 207834956, 479007874, 567527487, 342889923, 164787713, 897102913, 137095735, 438979183, 775061272, 687218272, 813415720, 401892698, 491003661, 795423035, 992738761, 476481169, 748385366, 489509479, 455500120, 659385599, 808280670, 72061446, 803508491, 415297638, 902656722, 608821921, 632941473, 168539654, 945901229, 524743917, 218027481, 381956184, 288656278, 795340037, 972636251, 233928766, 263197562, 499031368, 231991495, 727180552, 953392465, 138776411, 4733367, 962859199, 64494795, 133722957, 230305106, 525105007, 183932964, 598171034, 721447068, 626827093, 851825213, 425097480, 477022046, 805869298, 36836062, 550694170, 907257631, 851351317, 253396790, 414051204, 679453718, 612304219, 638659635, 956772981, 525850167, 690359962, 337492891, 200835942, 92031839, 521556569, 243949073, 579929985, 681416532, 606782130, 793494238, 268404994, 143592111, 80678453, 429761900, 3115904, 86910261, 603582422, 210280741, 507471743, 618525901, 447332536, 402136808, 422799510, 292931549, 987999906, 398799308, 90530158, 169060215, 736919738, 564369627, 297799462, 332518655, 229406930, 756613322, 845745292, 920897507, 598408322, 42561922, 6021344, 610451010, 263463935, 532949214, 676349431, 616162790, 765274787, 206898991, 29960765, 825196317, 857291618, 744543994, 314284291, 485860193, 716264373, 746813030, 979486246, 675236851, 97286718, 174059675, 23356194, 143999106, 462057887, 947471968, 38943028, 539943943, 27359840, 93662708, 727269359, 481898551, 57459803, 842188965, 166276467, 390012737, 622214432, 410705324, 211423378, 45061181, 500827686, 213078743, 471218667, 443265013, 99608762, 670436191, 784137388, 667883531, 6203239, 796543866, 260971249, 528145737, 852835333, 966641908, 461429539, 775694404, 518030702, 497490936, 770676269, 59383226, 616257388, 3191031, 65765288, 747787964, 498766952, 63299185, 874386334, 247539606, 558378397, 991143121, 229825834, 18030058, 27203230, 284232294, 586494646, 200192515, 684617324, 955729287, 111651075, 907919474, 771568221, 654787510, 217494480, 206557174, 67901851, 353298182, 913153538, 894208920, 141716008, 196585547, 287380007, 716476022, 629537584, 546455168, 809386351, 248310272, 43075705, 895537761, 39385780, 121847265, 139232284, 317850348, 757547961, 654328199, 626506739, 10561425, 675451049, 977408830, 965379078, 606209191, 189827198, 345033467, 296276118, 782379434, 909792328, 115860760, 14100947, 937994222, 991849197, 997799334, 933592876, 859034935, 715869190, 365331242, 589697412, 895264007, 155859242, 901415896, 698095785, 552050805, 5517492, 709130769, 970312336, 946142157, 601415069, 173142460, 292427070, 186269202, 545680864, 383788791, 953846784, 453374418, 290537620, 534922017, 523218445, 336974503, 208871016, 940960477, 218895443, 646661902, 234284267, 687463977, 21589842, 277463951, 242391872, 506373586, 290211116, 822814104, 152001780, 594214676, 11243442, 174488664, 943192004, 897627443, 969743543, 882679076, 662985581, 295714691, 474108451, 611202476, 518119636, 510347716, 631897901, 781915431, 74178564, 780255029, 342425475, 759029514, 298314043, 939053561, 637136622, 572587280, 84228107, 805592836, 183772938, 451773983, 709140795, 602054521, 655883018, 20906817, 643868155, 943619321, 908145452, 460159045, 863937404, 636020246, 732199530, 328336450, 292693139, 317585801, 963508052, 219709229, 757004259, 477516556, 174742334, 106488920, 690494396, 555731119, 217951151, 126396691, 808524501, 835000146, 796396976, 401318439, 637637017, 71670996, 544660431, 726957872, 525586733, 595833890, 918625645, 362838009, 321509901, 561645440, 486128882, 293767658, 149180749, 784490380, 862748411, 874677564, 533845494, 930439392, 735556334, 4958148, 940355688, 616267696, 237493533, 415342747, 446953183, 131399892, 678142531, 803238238, 737876361, 153895239, 111028709, 959933779, 73762783, 258554275, 477042322, 27847420, 314249115, 105540545, 238928510, 792106135, 689752808, 618434119, 28974359, 747701526, 113837157, 256648673, 260998865, 635834887, 528318440, 317635738, 271106356, 70531145, 458698028, 188502405, 447535955, 353769931, 896042267, 239620475, 833010881, 562064015, 363748498, 560507870, 683079748, 729907987, 20323830, 723727408, 177362789, 375049408, 473826217, 125015216, 625079840, 723985890, 572986989, 771053811, 266093498, 105173978, 981401767, 228897018, 562968014, 107337781, 443572580, 450113167, 7564108, 458700796, 367514752, 742593612, 943888013, 255290764, 253175133, 450238272, 155767301, 564709735, 579657735, 315082764, 194875256, 969408247, 253899244, 702673744, 374755721, 3410679, 709495102, 793745918, 590902508, 891300111, 576346126, 743594753, 378489603, 333325325, 410245396, 198980388, 731286101, 872817591, 944615563, 620517213, 113852003, 172319562, 965156337, 44164663, 260648888, 486454106, 17072868, 294794624, 76043347, 169159562, 633113748, 342270836, 853701234, 340516202, 23303233, 900307700, 141131588, 305566409, 511440511, 164012603, 633591615, 778623734, 721260064, 76111729, 930847192, 582954434, 242020590, 414888365, 412731157, 67482897, 549854159, 512439468, 92361826, 734577811, 981595083, 55551978, 845681767, 672958603, 401469177, 648620114, 970198824, 341866811, 332353729, 634906275, 611679354, 555712430, 746331128, 104341596, 764395622, 275122358, 654586312, 73568232, 422258822, 499103949, 71776123, 565811068, 630726078, 333228272, 232267605, 95261281, 523750834, 279769266, 654799813, 833350453, 946470165, 547740129, 928830704, 804131559, 156003233, 240837163, 285805878, 727614989, 696067134, 677940139, 83495253, 863057640, 404055405, 891606063, 646269752, 696594902, 284795853, 215861451, 128317797, 541431447, 298724338, 725766473, 992964386, 284653096, 295072658, 583109695, 450872479, 196817609, 976744913, 404362291, 5542184, 987829281, 380020839, 765583862, 518996991, 418014814, 601613483, 722223950, 862462707, 326538883, 375301709, 613066118, 552671112, 480643926, 574353963, 701379031, 883401981, 341157911, 383694846, 650791666, 642741236, 669177311, 989146281, 621033784, 911244872, 811636011, 244305792, 399856449, 611348902, 467003589, 333863620, 279076135, 25155852, 384175324, 47426776, 120009404, 624194132, 295815033, 711639470, 47473058, 390761149, 493161761, 33796573, 458354295, 409870344, 853537261, 165428803, 740727950, 334993147, 835415097, 411558130, 158109400, 151633890, 714825910, 587761213, 327156309, 369138521, 326038248, 979232805]\\n\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n        def numTilings(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # dp = [1,2,5,11]\\n        \\n        # for i in range (4,n):\\n        #     dp.append(dp[i-3] + 2*dp[i-1])\\n\\n        dp = [1, 2, 5, 11, 24, 53, 117, 258, 569, 1255, 2768, 6105, 13465, 29698, 65501, 144467, 318632, 702765, 1549997, 3418626, 7540017, 16630031, 36678688, 80897393, 178424817, 393528322, 867954037, 914332884, 222194076, 312342182, 539017241, 300228551, 912799284, 364615795, 29460134, 971719552, 308054885, 645569904, 262859346, 833773577, 313117044, 889093434, 611960431, 537037899, 963169225, 538298867, 613635626, 190440463, 919179793, 451995198, 94430852, 108041490, 668078178, 430587201, 969215892, 606509948, 643607090, 256430058, 119370057, 882347204, 21124452, 161618961, 205585119, 432294690, 26208334, 258001787, 948298264, 922804855, 103611483, 155521223, 233847294, 571306071, 298133358, 830114010, 231534077, 761201512, 352517020, 936568117, 634337732, 621192477, 178953057, 992243846, 605680155, 390313360, 772870559, 151421259, 693155878, 159182301, 469785861, 632727593, 424637480, 319060814, 270849214, 966335908, 251732616, 774314446, 514964786, 281662181, 337638801, 190242381, 662146943, 661932680, 514107734, 690362404, 42657474, 599422682, 889207761, 821072989, 241568646, 372345046, 565763074, 373094787, 118534613, 802832300, 978759380, 76053359, 954939018, 888637402, 853328156, 661595316, 211828020, 276984189, 215563687, 642955394, 562894970, 341353620, 325662627, 214220217, 769794054, 865250728, 944721666, 659237372, 183725458, 312172575, 283582515, 750890488, 813953544, 911489596, 573869666, 961692869, 834875320, 243620292, 448933446, 732742205, 709104695, 867142829, 467027849, 643160386, 153463587, 773955023, 191070418, 535604423, 845163862, 881398135, 298400679, 441965213, 765328554, 829057780, 100080759, 965490072, 760037910, 620156572, 205803202, 171644307, 963445186, 132693560, 437031427, 837508033, 807709619, 52450651, 942409335, 692528275, 437507194, 817423716, 327375693, 92258573, 1940855, 331257403, 754773379, 511487606, 354232608, 463238588, 437964775, 230162151, 923562890, 285090541, 800343233, 524249342, 333589218, 467521662, 459292659, 252174529, 971870720, 403034085, 58242692, 88356097, 579746279, 217735243, 523826583, 627399438, 472534112, 468894800, 565189031, 602912167, 674719127, 914627278, 432166709, 539052538, 992732347, 417631389, 374315309, 741362958, 900357298, 175029891, 91422733, 83202757, 341435405, 774293543, 631789836, 605015070, 984323676, 600437174, 805889411, 596102484, 792642135, 391173667, 378449811, 549541750, 490257160, 358964124, 267469991, 25197135, 409358394, 86186772, 197570679, 804499752, 695186269, 587943210, 980386165, 655958585, 899860373, 780106897, 216172365, 332205096, 444517082, 105206522, 542618140, 529753355, 164713225, 872044590, 273842521, 712398267, 296841110, 867524741, 447447735, 191736573, 250997880, 949443495, 90623549, 432244978, 813933444, 718490430, 869225831, 552385092, 823260607, 515747031, 583879147, 991018894, 497784805, 579448750, 149916380, 797617565, 174683866, 499284112, 796185782, 767055423, 33394944, 862975670, 493006749, 19408435, 901792540, 296591815, 612592065, 126976656, 550545127, 713682312, 554341273, 659227666, 32137630, 618616533, 896460725, 825059073, 268734665, 433930048, 692919162, 654572982, 743076005, 179071158, 12715291, 768506587, 716084325, 444883934, 658274448, 32633207, 510150348, 678575137, 389783474, 289717289, 258009708, 905802890, 101323055, 460655818, 827114519, 755552086, 971759983, 770634471, 296821014, 565402004, 901438472, 99697944, 764797892, 431034242, 961766428, 688330734, 807695703, 577157820, 842646367, 492988423, 563134659, 968915678, 430819765, 424774182, 818464035, 67747821, 560269824, 939003676, 945755166, 451780142, 842563953, 630883058, 713546251, 269656441, 170195933, 53938110, 377532661, 925261255, 904460613, 186453873, 298168994, 500798594, 188051054, 674271102, 849340791, 886732629, 447736346, 744813476, 376359567, 200455473, 145724415, 667808397, 536072260, 217868928, 103546246, 743164752, 704198425, 511943089, 767050923, 238300257, 988543603, 744138115, 726576480, 441696549, 627531206, 981638885, 404974305, 437479809, 856598496, 118171283, 673822375, 204243232, 526657747, 727137862, 658518949, 843695638, 414529124, 487577190, 818850011, 52229132, 592035454, 2920905, 58070942, 708177338, 419275574, 896622090, 501421504, 422118575, 740859233, 983139963, 388398487, 517656200, 18452349, 425303185, 368262563, 754977475, 935258128, 238778805, 232535078, 400328277, 39435352, 311405782, 23139834, 85715020, 482835822, 988811478, 63337962, 609511746, 207834956, 479007874, 567527487, 342889923, 164787713, 897102913, 137095735, 438979183, 775061272, 687218272, 813415720, 401892698, 491003661, 795423035, 992738761, 476481169, 748385366, 489509479, 455500120, 659385599, 808280670, 72061446, 803508491, 415297638, 902656722, 608821921, 632941473, 168539654, 945901229, 524743917, 218027481, 381956184, 288656278, 795340037, 972636251, 233928766, 263197562, 499031368, 231991495, 727180552, 953392465, 138776411, 4733367, 962859199, 64494795, 133722957, 230305106, 525105007, 183932964, 598171034, 721447068, 626827093, 851825213, 425097480, 477022046, 805869298, 36836062, 550694170, 907257631, 851351317, 253396790, 414051204, 679453718, 612304219, 638659635, 956772981, 525850167, 690359962, 337492891, 200835942, 92031839, 521556569, 243949073, 579929985, 681416532, 606782130, 793494238, 268404994, 143592111, 80678453, 429761900, 3115904, 86910261, 603582422, 210280741, 507471743, 618525901, 447332536, 402136808, 422799510, 292931549, 987999906, 398799308, 90530158, 169060215, 736919738, 564369627, 297799462, 332518655, 229406930, 756613322, 845745292, 920897507, 598408322, 42561922, 6021344, 610451010, 263463935, 532949214, 676349431, 616162790, 765274787, 206898991, 29960765, 825196317, 857291618, 744543994, 314284291, 485860193, 716264373, 746813030, 979486246, 675236851, 97286718, 174059675, 23356194, 143999106, 462057887, 947471968, 38943028, 539943943, 27359840, 93662708, 727269359, 481898551, 57459803, 842188965, 166276467, 390012737, 622214432, 410705324, 211423378, 45061181, 500827686, 213078743, 471218667, 443265013, 99608762, 670436191, 784137388, 667883531, 6203239, 796543866, 260971249, 528145737, 852835333, 966641908, 461429539, 775694404, 518030702, 497490936, 770676269, 59383226, 616257388, 3191031, 65765288, 747787964, 498766952, 63299185, 874386334, 247539606, 558378397, 991143121, 229825834, 18030058, 27203230, 284232294, 586494646, 200192515, 684617324, 955729287, 111651075, 907919474, 771568221, 654787510, 217494480, 206557174, 67901851, 353298182, 913153538, 894208920, 141716008, 196585547, 287380007, 716476022, 629537584, 546455168, 809386351, 248310272, 43075705, 895537761, 39385780, 121847265, 139232284, 317850348, 757547961, 654328199, 626506739, 10561425, 675451049, 977408830, 965379078, 606209191, 189827198, 345033467, 296276118, 782379434, 909792328, 115860760, 14100947, 937994222, 991849197, 997799334, 933592876, 859034935, 715869190, 365331242, 589697412, 895264007, 155859242, 901415896, 698095785, 552050805, 5517492, 709130769, 970312336, 946142157, 601415069, 173142460, 292427070, 186269202, 545680864, 383788791, 953846784, 453374418, 290537620, 534922017, 523218445, 336974503, 208871016, 940960477, 218895443, 646661902, 234284267, 687463977, 21589842, 277463951, 242391872, 506373586, 290211116, 822814104, 152001780, 594214676, 11243442, 174488664, 943192004, 897627443, 969743543, 882679076, 662985581, 295714691, 474108451, 611202476, 518119636, 510347716, 631897901, 781915431, 74178564, 780255029, 342425475, 759029514, 298314043, 939053561, 637136622, 572587280, 84228107, 805592836, 183772938, 451773983, 709140795, 602054521, 655883018, 20906817, 643868155, 943619321, 908145452, 460159045, 863937404, 636020246, 732199530, 328336450, 292693139, 317585801, 963508052, 219709229, 757004259, 477516556, 174742334, 106488920, 690494396, 555731119, 217951151, 126396691, 808524501, 835000146, 796396976, 401318439, 637637017, 71670996, 544660431, 726957872, 525586733, 595833890, 918625645, 362838009, 321509901, 561645440, 486128882, 293767658, 149180749, 784490380, 862748411, 874677564, 533845494, 930439392, 735556334, 4958148, 940355688, 616267696, 237493533, 415342747, 446953183, 131399892, 678142531, 803238238, 737876361, 153895239, 111028709, 959933779, 73762783, 258554275, 477042322, 27847420, 314249115, 105540545, 238928510, 792106135, 689752808, 618434119, 28974359, 747701526, 113837157, 256648673, 260998865, 635834887, 528318440, 317635738, 271106356, 70531145, 458698028, 188502405, 447535955, 353769931, 896042267, 239620475, 833010881, 562064015, 363748498, 560507870, 683079748, 729907987, 20323830, 723727408, 177362789, 375049408, 473826217, 125015216, 625079840, 723985890, 572986989, 771053811, 266093498, 105173978, 981401767, 228897018, 562968014, 107337781, 443572580, 450113167, 7564108, 458700796, 367514752, 742593612, 943888013, 255290764, 253175133, 450238272, 155767301, 564709735, 579657735, 315082764, 194875256, 969408247, 253899244, 702673744, 374755721, 3410679, 709495102, 793745918, 590902508, 891300111, 576346126, 743594753, 378489603, 333325325, 410245396, 198980388, 731286101, 872817591, 944615563, 620517213, 113852003, 172319562, 965156337, 44164663, 260648888, 486454106, 17072868, 294794624, 76043347, 169159562, 633113748, 342270836, 853701234, 340516202, 23303233, 900307700, 141131588, 305566409, 511440511, 164012603, 633591615, 778623734, 721260064, 76111729, 930847192, 582954434, 242020590, 414888365, 412731157, 67482897, 549854159, 512439468, 92361826, 734577811, 981595083, 55551978, 845681767, 672958603, 401469177, 648620114, 970198824, 341866811, 332353729, 634906275, 611679354, 555712430, 746331128, 104341596, 764395622, 275122358, 654586312, 73568232, 422258822, 499103949, 71776123, 565811068, 630726078, 333228272, 232267605, 95261281, 523750834, 279769266, 654799813, 833350453, 946470165, 547740129, 928830704, 804131559, 156003233, 240837163, 285805878, 727614989, 696067134, 677940139, 83495253, 863057640, 404055405, 891606063, 646269752, 696594902, 284795853, 215861451, 128317797, 541431447, 298724338, 725766473, 992964386, 284653096, 295072658, 583109695, 450872479, 196817609, 976744913, 404362291, 5542184, 987829281, 380020839, 765583862, 518996991, 418014814, 601613483, 722223950, 862462707, 326538883, 375301709, 613066118, 552671112, 480643926, 574353963, 701379031, 883401981, 341157911, 383694846, 650791666, 642741236, 669177311, 989146281, 621033784, 911244872, 811636011, 244305792, 399856449, 611348902, 467003589, 333863620, 279076135, 25155852, 384175324, 47426776, 120009404, 624194132, 295815033, 711639470, 47473058, 390761149, 493161761, 33796573, 458354295, 409870344, 853537261, 165428803, 740727950, 334993147, 835415097, 411558130, 158109400, 151633890, 714825910, 587761213, 327156309, 369138521, 326038248, 979232805]\\n\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947652,
                "title": "python3-dp-non-mathematical-detailed-explanation-with-plots",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 3 steps to come up with the final solution:\\n1. recognize it is a DP problem (given examples with smaller n, ask what is the total number of ways for large n)\\n2. top-down relationship to fill up the entire 2 * n grid\\n3. identify the base case to construct bottom-up DP solution\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Step 1.\\nThis is easy to identify. If not you just have to do more problems to become sensitive of the keywords in the problem statement. I will explain 2. and 3.\\n\\n\\n# Step 2.\\nTo fill up the entire 2 * n grid with tiles, at the nth and (n-1)th column, it has to look like one of the followings:\\n- type A: nth column filled by a vertical tile \\n- type B: nth and (n-1)th columns filled by two horizontal tiles\\n- type C: a corner tile at nth and (n-1)th columns but leaves the bottom cell at the (n-1)th column\\n- type D: nth and (n-1)th columns but leaves the upper cell at the (n-1)th column\\n![Screen Shot 2022-12-24 at 4.27.37 PM.png](https://assets.leetcode.com/users/images/03869694-2fed-454e-888f-258fafc7f563_1671928369.2005029.png)\\n\\n\\nIf we could figure out the number of ways to construct each of the above types, we can derive the total number of ways to fill up the entire 2 * n grid. And this number will essentially be equal to the total number of ways to fill up the grey area in the above pictures.\\n\\nWe will need 3 different arrays (x[i], y[i], z[i], where i denotes at the ith column) to calculate the total number of ways to fill up the grey area:\\n- x[i]: total number of ways to fill up the entire 2 * i grid (used by typeA and type B)\\n- y[i]: total number of ways to fill up the entire 2 * (i-1) grid & bottom cell at the ith column (used by typeC)\\n- z[i]: total number of ways to fill up the entire 2 * (i-1) grid & upper cell at the ith column (used by typeD)\\n\\nIn particular, we can further investigate the way to get y[i] and z[i]:\\n- y has to be one of the following conditions (I & II):\\n![Screen Shot 2022-12-24 at 4.28.14 PM.png](https://assets.leetcode.com/users/images/5c5f4a53-d85b-4317-a5d4-4739abacb73a_1671928394.0732508.png)\\n\\nyielding y[i] = z[i-1] + x[i-2]\\n- z has to be one of the following conditions (I & II):\\n![Screen Shot 2022-12-24 at 4.28.26 PM.png](https://assets.leetcode.com/users/images/588ce874-f23f-4389-beb6-bcd23035582a_1671928420.0176294.png)\\n\\nyielding z[i] = y[i-1] + x[i-2]\\n\\ncombining the above relationships, x[i] = typeA + typeB + typeC + typeD = x[i-1] + x[i-2] + y[i-1] + z[i-1], with the final answer being i = n\\n\\n\\n# Step 3.\\nThe base cases are as the followings:\\nwhen i = 1, \\nx[1] = 1 (vertical tile to fill the 1st column)\\ny[1] = 0 (no way can fill in a bottom corner tile)\\nz[1] = 0 (no way can fill in a upper corner tile)\\n![Screen Shot 2022-12-24 at 4.41.01 PM.png](https://assets.leetcode.com/users/images/7748abf3-1a2e-43dc-82a6-b7bed997bf1f_1671928899.1086092.png)\\n\\nwhen i = 2, \\nx[2] = 2 (2 ways, 2 vertical tiles or 2 horizontal tiles)\\ny[2] = 1\\nz[2] = 1\\n![Screen Shot 2022-12-24 at 4.41.07 PM.png](https://assets.leetcode.com/users/images/cdb0d408-f80a-402d-91b1-6d426d602fa0_1671928910.0415542.png)\\n\\nCombining step 2 and 3, we can construct a 2D DP table. The picture below shows an example how to compute the column when i = 3 where the red cell is the sum of the yellow cells using the relationship derived in step 2. :\\n![Screen Shot 2022-12-24 at 4.41.20 PM.png](https://assets.leetcode.com/users/images/0ea9a513-40f2-4970-8975-32347201d26a_1671929018.047585.png)\\n\\nThe following table goes up t0 i = 5:\\n![Screen Shot 2022-12-24 at 4.48.06 PM.png](https://assets.leetcode.com/users/images/9321c969-4fb3-4a81-ad23-da2ce2f89e9b_1671929300.3436341.png)\\n\\n\\nThe final answer will be the last element in array x (representing the total number of ways to fill up the entire 2 * n grid).\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ but can be reduced to $$O(1)$$ as one only needs the previous two columns to compute the current column\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        # 2D DP\\n        dp = [[0] * n for i in range(3)]\\n        # initialize\\n        dp[0][0], dp[0][1], dp[1][1], dp[2][1] = 1, 2, 1, 1\\n        for i in range(2, n):\\n            dp[0][i] = dp[0][i - 1] + dp[1][i - 1] + dp[2][i - 1] + dp[0][i - 2]\\n            dp[1][i] = dp[2][i - 1] + dp[0][i - 2]\\n            dp[2][i] = dp[1][i - 1] + dp[0][i - 2]\\n        return dp[0][-1] % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        # 2D DP\\n        dp = [[0] * n for i in range(3)]\\n        # initialize\\n        dp[0][0], dp[0][1], dp[1][1], dp[2][1] = 1, 2, 1, 1\\n        for i in range(2, n):\\n            dp[0][i] = dp[0][i - 1] + dp[1][i - 1] + dp[2][i - 1] + dp[0][i - 2]\\n            dp[1][i] = dp[2][i - 1] + dp[0][i - 2]\\n            dp[2][i] = dp[1][i - 1] + dp[0][i - 2]\\n        return dp[0][-1] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947410,
                "title": "c-easy-to-understand-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int modulo = 1e9 + 7;\\n    int solver(int n, bool usedTromino, vector<vector<int>> &dp) {\\n        if(n < 0) return 0;\\n        if(n == 0) {\\n            if(usedTromino) return 0;\\n            return 1;\\n        } \\n        \\n        if(dp[n][usedTromino] != -1) return dp[n][usedTromino];\\n        \\n        long long way1 = 0 , way2 = 0 , way3 = 0, way4 = 0;\\n        \\n        // Using Dominos\\n        if(n >= 2 && !usedTromino) way1 = solver(n - 2, usedTromino, dp);\\n        if(n >= 1) way2 = solver(n - 1, usedTromino, dp);\\n        \\n        // Using Trominos . These must be used as a pair i.e even no. times because using a tromino but not coupling with an opposite tromino  will result in a tile being uncovered.\\n        \\n        // Opening Tromino \\n        if(n >= 3 && !usedTromino) way3 = 2 * solver(n - 2, !usedTromino, dp);\\n        // Closing Tromino to fit into the space left by opening tromino\\n        if(n >= 1 && usedTromino) way4 = solver(n - 1, !usedTromino, dp);\\n        \\n        return dp[n][usedTromino] = (way1 + way2 + way3 + way4) % modulo;\\n    }\\n    \\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n  + 1, vector<int>(2, -1));\\n        \\n        return solver(n, false, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int modulo = 1e9 + 7;\\n    int solver(int n, bool usedTromino, vector<vector<int>> &dp) {\\n        if(n < 0) return 0;\\n        if(n == 0) {\\n            if(usedTromino) return 0;\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2947086,
                "title": "java-1d-dp",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int numTilings(int n) {\\n        if (n < 3) {\\n            return n;\\n        }\\n\\n        int mod = 1000000007;\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for (int i = 4; i <= n; i++) {\\n            dp[i] = (2 * dp[i - 1] % mod + dp[i - 3] % mod) % mod;\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int numTilings(int n) {\\n        if (n < 3) {\\n            return n;\\n        }\\n\\n        int mod = 1000000007;\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for (int i = 4; i <= n; i++) {\\n            dp[i] = (2 * dp[i - 1] % mod + dp[i - 3] % mod) % mod;\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947010,
                "title": "faster-than-100-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int md=1e9+7;\\n    int numTilings(int n) {\\n        int dp[n+1];\\n        if(n<=2)\\n        return n;\\n\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++)\\n        {\\n            dp[i]=((dp[i-1]*2)%md+(dp[i-3])%md)%md;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int md=1e9+7;\\n    int numTilings(int n) {\\n        int dp[n+1];\\n        if(n<=2)\\n        return n;\\n\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++)\\n        {\\n            dp[i]=((dp[i-1]*2)%md+(dp[i-3])%md)%md;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946911,
                "title": "easy-c-solution-must-check",
                "content": "**Intuition:**\\n\\nFrom observation\\n\\n`v[0] = 0;\\nv[1] = 1;\\nv[2] = 2;\\nv[3] = 5;`\\n\\n\\nNow we can find the value using the formula ``` v[i] = 2*v[i-1] + v[i-3] ```\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int md = 1e9;\\n        md += 7;\\n\\n        vector<long long> v(1001,0);\\n\\n        v[0] = 0;\\n        v[1] = 1;\\n        v[2] = 2;\\n        v[3] = 5;\\n\\n        if(n <= 3)\\n            return v[n];\\n\\n        for(int i = 4; i <=n;i++)\\n        {\\n            v[i] = 2*v[i-1] + v[i-3];\\n            v[i] = v[i] % md;\\n        }    \\n        return v[n];\\n\\n    }\\n};\\n```\\n\\n\\n\\n**Complexity:**\\n- Time complexity:```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:```O(n)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n----\\n\\n\\nIf this solution helps you, then please ```UPVOTE``` .\\nTill then **keep Learning, Keep Exploring !!!**\\n\\n**Thank you !!**\\n\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "``` v[i] = 2*v[i-1] + v[i-3] ```\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int md = 1e9;\\n        md += 7;\\n\\n        vector<long long> v(1001,0);\\n\\n        v[0] = 0;\\n        v[1] = 1;\\n        v[2] = 2;\\n        v[3] = 5;\\n\\n        if(n <= 3)\\n            return v[n];\\n\\n        for(int i = 4; i <=n;i++)\\n        {\\n            v[i] = 2*v[i-1] + v[i-3];\\n            v[i] = v[i] % md;\\n        }    \\n        return v[n];\\n\\n    }\\n};\\n```\n```O(n)```\n```O(n)```\n```UPVOTE```",
                "codeTag": "Java"
            },
            {
                "id": 2946779,
                "title": "c-explained-recursion-memorization-dp-tabulation-dp",
                "content": "# Intuition\\nWhenever we are asked to find the number of ways we try to think from recursion point of view (Not everytime but mostly we get a way to proceed ahead)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n![image.png](https://assets.leetcode.com/users/images/6b54c7a3-df31-4473-8199-81a4b93c2c81_1671903084.671635.png)\\n![image.png](https://assets.leetcode.com/users/images/95ec3884-a58f-4ace-b8c7-cd53732dcf1e_1671903222.124374.png)\\n\\nThus we get two recurrence relations\\nf(n) = f(n-1) + f(n-2) + 2*(n-2)\\ng(n) = f(n-1) + g(n-1)\\n\\n# Recursion - TLE\\n\\n-> instead of taking a seperate function call for g(n), I have written g(n) = f(n, true)\\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    long long f(int n, bool flag){\\n        if (n < 3) return n;\\n        if (flag)\\n            return (f(n-1, false) + f(n-1, true)) % m;\\n        return (f(n-1, false) + f(n-2, false) + 2*f(n-2, true)) % m;\\n    }\\n    int numTilings(int n) {\\n        int ans = f(n, false);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Memorization \\n-> dp[1001][2] is created as n can take a maximum of 1000\\n-> repeated calls are pruned\\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    long long f(int n, bool flag, vector<vector<int>> &dp){\\n        if (n < 3) return n;\\n        if (dp[n][flag] != -1) return dp[n][flag];\\n        if (flag)\\n            return dp[n][flag] = (f(n-1, false, dp) + f(n-1, true, dp)) % m;\\n        return dp[n][flag] = (f(n-1, false, dp) + f(n-2, false, dp) + 2*f(n-2, true, dp)) % m;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(1001, vector<int>(2, -1));\\n        int ans = f(n, false, dp);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Tabular \\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    int numTilings(int n) {\\n        vector<long long> f(1001, 0);\\n        vector<long long> g(1001, 0);\\n        f[1] = g[1] = 1;\\n        f[2] = g[2] = 2;\\n        for(int i = 3;i <= n; i++){\\n            g[i] = (f[i-1] + g[i-1])%m ;\\n            f[i] = (f[i-1] + f[i-2] + 2*g[i-2])%m;\\n        }\\n        return f[n];\\n    }\\n};\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    Recursion - O(3**n) for each state we are trying to explore 3 sub states\\n    Memorization and Tabular form - O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    long long f(int n, bool flag){\\n        if (n < 3) return n;\\n        if (flag)\\n            return (f(n-1, false) + f(n-1, true)) % m;\\n        return (f(n-1, false) + f(n-2, false) + 2*f(n-2, true)) % m;\\n    }\\n    int numTilings(int n) {\\n        int ans = f(n, false);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    long long f(int n, bool flag, vector<vector<int>> &dp){\\n        if (n < 3) return n;\\n        if (dp[n][flag] != -1) return dp[n][flag];\\n        if (flag)\\n            return dp[n][flag] = (f(n-1, false, dp) + f(n-1, true, dp)) % m;\\n        return dp[n][flag] = (f(n-1, false, dp) + f(n-2, false, dp) + 2*f(n-2, true, dp)) % m;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(1001, vector<int>(2, -1));\\n        int ans = f(n, false, dp);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    int numTilings(int n) {\\n        vector<long long> f(1001, 0);\\n        vector<long long> g(1001, 0);\\n        f[1] = g[1] = 1;\\n        f[2] = g[2] = 2;\\n        for(int i = 3;i <= n; i++){\\n            g[i] = (f[i-1] + g[i-1])%m ;\\n            f[i] = (f[i-1] + f[i-2] + 2*g[i-2])%m;\\n        }\\n        return f[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946271,
                "title": "brute-force-to-space-optimized-c-solution",
                "content": "# 1               2\\n# 3               4\\n**tromino1** : 2->1->3  (works as **gap maker**)\\n**tromino2** : 1->3->4  (works as **gap maker**)\\n**tromino3** : 3->4->2  (works as **gap remover**)\\n**tromino4** : 1->2->4  (works as **gap remover**)\\n       \\n**normalchoice1** -> adding a **domino(verical)**, it **will not create any gap**, go to i + 1\\n**normalchoice2** -> adding **dominoes(horizontal) in pairs**, it **will not create any gap**, go to i + 2       \\n**normalchoice3** -> adding a **tromino1/ tromino2** it will **create a gap**, go to i + 2\\n\\n**NOTE** : you have to consider normalchoice3 two times, because - \\n\\t\\t\\t\\t there will be situation where you can use tromino1 **OR** tromino2\\n\\t\\t\\t\\t \\n**gapchoice1** -> adding a **domino(horizontal)** to fill the prev gap but it will **create a gap**\\n**gapchoice2** -> adding a **tromino3 / tromino4** to fill the prev gap but it will **not create any gap**\\n\\t\\n**NOTE** : you have to consider gapchoice2 **only one time**, because -\\n\\n**(1)** there will **no** situation where you can use tromino3 **OR** tromino4\\n**(2)** there will be **(** a situation where you have to use tromino3 **)**\\n\\t\\t\\t **OR** **(** a situation where you have to use tromino4 **)**\\n\\n**BASIC RECURSIVE SOLUTION :**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int helper(int i,bool empty,int n) {\\n        if(i == n && !empty) return 1;\\n        if(i >= n) return 0;\\n        if(empty) {\\n            long gapchoice1 = helper(i + 1,true,n);\\n            long gapchoice2 = helper(i + 1,false,n);\\n            return (gapchoice1 + gapchoice2) % mod;\\n        }\\n        else {\\n            long normalchoice1 = helper(i + 1,false,n);\\n            long normalchoice2 = helper(i + 2,false,n);\\n            long normalchoice3 = helper(i + 2,true,n);\\n            return  (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n        }\\n    }\\n    \\n    int numTilings(int n) {\\n        return helper(0,false,n);\\n    }\\n};\\n```\\n**Time** : O(3^N)\\n**Space** : O(N)\\n\\n**MEMOIZATION :**\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int helper(int i,bool empty,int n,vector<vector<int>>& dp) {\\n        if(i == n && !empty) return 1;\\n        if(i >= n) return 0;\\n        if(dp[i][empty] != -1) return dp[i][empty];\\n        if(empty) {\\n            long gapchoice1 = helper(i + 1,true,n,dp);\\n            long gapchoice2 = helper(i + 1,false,n,dp);\\n            return dp[i][empty] = (gapchoice1 + gapchoice2) % mod;\\n        }\\n        else {\\n            long normalchoice1 = helper(i + 1,false,n,dp);\\n            long normalchoice2 = helper(i + 2,false,n,dp);\\n            long normalchoice3 = helper(i + 2,true,n,dp);\\n            return dp[i][empty] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n        }\\n    }\\n    \\n    int numTilings(int n) {\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        return helper(0,false,n,dp);\\n    }\\n};\\n```\\n**Time** : O(N)\\n**Space** : O(N)\\n\\n**ITERATIVE SOLUTION (TABULATION) :**\\n```\\nclass Solution {\\npublic:\\n\\n    int numTilings(int n) {\\n        int mod = 1e9 + 7;\\n        vector<vector<int>>dp(n + 2,vector<int>(2,0));\\n        dp[n][0] = 1;\\n        \\n        for(int i = n - 1;i >= 0;i--) {\\n            for(int j = 1;j >= 0;j--) {\\n                if(j) {\\n                    long gapchoice1 = dp[i + 1][1];\\n                    long gapchoice2 = dp[i + 1][0];\\n                    dp[i][j] = (gapchoice1 + gapchoice2) % mod;\\n                }\\n                else {\\n                    long normalchoice1 = dp[i + 1][0];\\n                    long normalchoice2 = dp[i + 2][0];\\n                    long normalchoice3 = dp[i + 2][1];\\n                    dp[i][j] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n**Time** : O(N)\\n**Space** : O(N)\\n\\n**ITERATIVE SOLUTION (SPACE OPTIMIZED) :**\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int mod = 1e9 + 7;\\n        vector<int>second(2,0);\\n        vector<int>first(2,0);\\n        vector<int>curr(2,0);\\n        first[0] = 1;\\n        for(int i = n - 1;i >= 0;i--) {\\n            for(int j = 1;j >= 0;j--) {\\n                if(j) {\\n                    long gapchoice1 = first[1];\\n                    long gapchoice2 = first[0];\\n                    curr[j] = (gapchoice1 + gapchoice2) % mod;\\n                }\\n                else {\\n                    long normalchoice1 = first[0];\\n                    long normalchoice2 = second[0];\\n                    long normalchoice3 = second[1];\\n                    curr[j] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n                }\\n            }\\n            second = first;\\n            first = curr;\\n        }\\n        return first[0];\\n    }\\n};\\n```\\n**Time** : O(N)\\n**Space** : O(1)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int helper(int i,bool empty,int n) {\\n        if(i == n && !empty) return 1;\\n        if(i >= n) return 0;\\n        if(empty) {\\n            long gapchoice1 = helper(i + 1,true,n);\\n            long gapchoice2 = helper(i + 1,false,n);\\n            return (gapchoice1 + gapchoice2) % mod;\\n        }\\n        else {\\n            long normalchoice1 = helper(i + 1,false,n);\\n            long normalchoice2 = helper(i + 2,false,n);\\n            long normalchoice3 = helper(i + 2,true,n);\\n            return  (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n        }\\n    }\\n    \\n    int numTilings(int n) {\\n        return helper(0,false,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int helper(int i,bool empty,int n,vector<vector<int>>& dp) {\\n        if(i == n && !empty) return 1;\\n        if(i >= n) return 0;\\n        if(dp[i][empty] != -1) return dp[i][empty];\\n        if(empty) {\\n            long gapchoice1 = helper(i + 1,true,n,dp);\\n            long gapchoice2 = helper(i + 1,false,n,dp);\\n            return dp[i][empty] = (gapchoice1 + gapchoice2) % mod;\\n        }\\n        else {\\n            long normalchoice1 = helper(i + 1,false,n,dp);\\n            long normalchoice2 = helper(i + 2,false,n,dp);\\n            long normalchoice3 = helper(i + 2,true,n,dp);\\n            return dp[i][empty] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n        }\\n    }\\n    \\n    int numTilings(int n) {\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        return helper(0,false,n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int numTilings(int n) {\\n        int mod = 1e9 + 7;\\n        vector<vector<int>>dp(n + 2,vector<int>(2,0));\\n        dp[n][0] = 1;\\n        \\n        for(int i = n - 1;i >= 0;i--) {\\n            for(int j = 1;j >= 0;j--) {\\n                if(j) {\\n                    long gapchoice1 = dp[i + 1][1];\\n                    long gapchoice2 = dp[i + 1][0];\\n                    dp[i][j] = (gapchoice1 + gapchoice2) % mod;\\n                }\\n                else {\\n                    long normalchoice1 = dp[i + 1][0];\\n                    long normalchoice2 = dp[i + 2][0];\\n                    long normalchoice3 = dp[i + 2][1];\\n                    dp[i][j] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int mod = 1e9 + 7;\\n        vector<int>second(2,0);\\n        vector<int>first(2,0);\\n        vector<int>curr(2,0);\\n        first[0] = 1;\\n        for(int i = n - 1;i >= 0;i--) {\\n            for(int j = 1;j >= 0;j--) {\\n                if(j) {\\n                    long gapchoice1 = first[1];\\n                    long gapchoice2 = first[0];\\n                    curr[j] = (gapchoice1 + gapchoice2) % mod;\\n                }\\n                else {\\n                    long normalchoice1 = first[0];\\n                    long normalchoice2 = second[0];\\n                    long normalchoice3 = second[1];\\n                    curr[j] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n                }\\n            }\\n            second = first;\\n            first = curr;\\n        }\\n        return first[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946235,
                "title": "c-solution-with-explanation-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a 2*n grid and we need to return the number of ways to tile the grid using domino (2x1 shape) and tromino(L shape) tiles.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem we have to observe the pattern\\nBy Observation \\n When n is equal to 0 and 1, the number of ways to tile the grid is 1 using a single domino.\\nWhen n is equal to 2, the number of ways to tile the grid is 2 using two domino.\\nWhen n is equal to 3, the number of ways to tile the grid is 5 using a both domino and tronimo.\\n \\nTherefore, Number of ways = 2*(n-1) + (n-3) \\n```\\ncolumns, n   = 0 1 2 3 4  5  6  7   8  .......so on.\\nno. of ways  = 1 1 2 5 11 24 53 117 258 ......so on.\\n```\\n# Recursive Solution- Gives TLE\\n```\\n    long mod = 1e9+7;\\n    int find(int n){\\n        //Base case\\n        if(n<=1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return (2*find(n-1)%mod +find(n-3)%mod)%mod;\\n    }\\n\\n    int numTilings(int n) {\\n        return find(n);\\n    }\\n```\\n \\n#   Memoization - Recursive Solution \\n   ```\\n long mod = 1e9+7;\\n    int find(int n,vector<int>&dp){\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n] = (2*find(n-1,dp)%mod +find(n-3,dp)%mod)%mod;\\n        return dp[n];\\n    }\\n\\n    int numTilings(int n){\\n        vector<int>dp(1001,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return find(n,dp);\\n    }\\n```\\n\\n# Complexity\\n- Time complexity:O(n) - *where N is the given number of columns of grid*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)  -*required for recursive stack and maintaining dp*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# DP Solution\\n  ```\\n  long mod = 1e9+7;\\n\\n    int numTilings(int n){\\n        vector<int>dp(1001,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n              dp[i] = (2*dp[i-1]%mod +dp[i-3]%mod)%mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:O(n) - *where N is the given number of columns of grid*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)  -*required for maintaining dp*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ncolumns, n   = 0 1 2 3 4  5  6  7   8  .......so on.\\nno. of ways  = 1 1 2 5 11 24 53 117 258 ......so on.\\n```\n```\\n    long mod = 1e9+7;\\n    int find(int n){\\n        //Base case\\n        if(n<=1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return (2*find(n-1)%mod +find(n-3)%mod)%mod;\\n    }\\n\\n    int numTilings(int n) {\\n        return find(n);\\n    }\\n```\n```\\n long mod = 1e9+7;\\n    int find(int n,vector<int>&dp){\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n] = (2*find(n-1,dp)%mod +find(n-3,dp)%mod)%mod;\\n        return dp[n];\\n    }\\n\\n    int numTilings(int n){\\n        vector<int>dp(1001,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return find(n,dp);\\n    }\\n```\n```\\n  long mod = 1e9+7;\\n\\n    int numTilings(int n){\\n        vector<int>dp(1001,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n              dp[i] = (2*dp[i-1]%mod +dp[i-3]%mod)%mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946000,
                "title": "simple-c-solution-with-explanation-tc-o-n-and-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe value starts repeating after 4.\\n1 -> 1\\n2 -> 2\\n3 -> 5\\n4 -> 11 -> (2 X 5)+1\\n5 -> 24 -> (2 X 11)+1\\n6 -> 53 -> (2 X 24)+5\\n7 -> 117 -> (2 X 53)+11\\n8 -> 258 -> (2 X 117)+24\\n9 -> 569 -> (2 X 258)+53\\n10 -> 1255 -> (2 X 569)+117\\n\\nformula = 2*a[n-1]+a[n-3]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are taking list of size 4. Therefore, The size complexity is O(1).\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        list<long> l;\\n        l.push_back(1);\\n        for(int i=1;i<=n;i++)\\n            if(i < 3)\\n                l.push_back(i);\\n            else {\\n                int t = l.front();\\n                l.pop_front();\\n                l.push_back((2*l.back() + t)%1000000007);\\n            }\\n        return l.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        list<long> l;\\n        l.push_back(1);\\n        for(int i=1;i<=n;i++)\\n            if(i < 3)\\n                l.push_back(i);\\n            else {\\n                int t = l.front();\\n                l.pop_front();\\n                l.push_back((2*l.back() + t)%1000000007);\\n            }\\n        return l.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945945,
                "title": "790-domino-and-tromino-tiling-beats-100-c-solutions-explanation-with-images",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Idea here is to maintain a state variable. There are three states possible -> \\n\\n![image.png](https://assets.leetcode.com/users/images/30037b2d-5aaa-4a00-9f1f-887ae68382b2_1671886948.9766946.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we divide the problem into 3 states it\\'ll be easier to solve.\\n\\n### Recursive Calls\\nFor state = 0\\n![image.png](https://assets.leetcode.com/users/images/4e44b1a5-3660-41a1-9e1a-628131f8a0e3_1671888862.7674236.png)\\n![image.png](https://assets.leetcode.com/users/images/a8a05fb5-c95a-4b6c-af3d-f15a2b5da646_1671889209.8903918.png)\\n![image.png](https://assets.leetcode.com/users/images/157037b1-5d85-4f09-ae55-4cecb8bfd894_1671889328.8098805.png)\\n\\n\\n\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/601461d9-dc1f-4ce7-8a9c-c1495940d184_1671888019.2720866.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int cache[1001][3];\\n    int m = 1000000007;\\n    long helper(int n, int state) {\\n        if(n<0) return 0;\\n        if(state==0 && n<=2) {\\n            return n;\\n        }\\n        if(cache[n][state]!=-1) return cache[n][state];\\n        if(n==1) return 0;\\n        if(n==2) return 1;\\n        if(state == 0) {\\n            cache[n][state] = (helper(n-1, 0)%m + helper(n-1, 1)%m + helper(n-1, 2)%m + helper(n-2, 0)%m)%m;\\n        }\\n        else if(state == 1) {\\n            cache[n][state] = (helper(n-2, 0)%m + helper(n-1, 2)%m)%m;\\n        }\\n        else {\\n            cache[n][state] = (helper(n-2, 0)%m + helper(n-1, 1)%m)%m;\\n        }\\n        \\n        return cache[n][state];\\n    }\\npublic:\\n    int numTilings(int n) {\\n        /*\\n        state = 0 - column empty\\n        state = 1 - column top filled, bottom empty\\n        state = 2 - column bottom filled top empty\\n         */\\n        memset(cache, -1, sizeof cache); \\n        return helper(n, 0);\\n    }\\n};\\n```\\n// Please Comment your complexity analysis for this solution!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int cache[1001][3];\\n    int m = 1000000007;\\n    long helper(int n, int state) {\\n        if(n<0) return 0;\\n        if(state==0 && n<=2) {\\n            return n;\\n        }\\n        if(cache[n][state]!=-1) return cache[n][state];\\n        if(n==1) return 0;\\n        if(n==2) return 1;\\n        if(state == 0) {\\n            cache[n][state] = (helper(n-1, 0)%m + helper(n-1, 1)%m + helper(n-1, 2)%m + helper(n-2, 0)%m)%m;\\n        }\\n        else if(state == 1) {\\n            cache[n][state] = (helper(n-2, 0)%m + helper(n-1, 2)%m)%m;\\n        }\\n        else {\\n            cache[n][state] = (helper(n-2, 0)%m + helper(n-1, 1)%m)%m;\\n        }\\n        \\n        return cache[n][state];\\n    }\\npublic:\\n    int numTilings(int n) {\\n        /*\\n        state = 0 - column empty\\n        state = 1 - column top filled, bottom empty\\n        state = 2 - column bottom filled top empty\\n         */\\n        memset(cache, -1, sizeof cache); \\n        return helper(n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945942,
                "title": "0ms-faster-than-100-easy-solution-series-formation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate first 8/9 values and identify the pattern.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long dp[n+1];\\n        dp[0]=1;\\n        for(int i=1; i<=n; i++){\\n            if(i<3)\\n                dp[i]=i;\\n            else\\n                dp[i] = (dp[i-1]*2+dp[i-3])%1000000007;\\n        }\\n        return (int)dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long dp[n+1];\\n        dp[0]=1;\\n        for(int i=1; i<=n; i++){\\n            if(i<3)\\n                dp[i]=i;\\n            else\\n                dp[i] = (dp[i-1]*2+dp[i-3])%1000000007;\\n        }\\n        return (int)dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945859,
                "title": "swift-solution-100-runtime-and-100-memory-with-explanations",
                "content": "![image.png](https://assets.leetcode.com/users/images/4befac27-e42c-434e-bedc-b2fa6e240b8a_1671887797.8681915.png)\\n\\n# Approach\\nThis solution uses dynamic programming to solve the problem. The basic idea is to start from small cases and build up to the final solution.\\n\\nWe use an array dp to store the number of ways to tile a board of size 2 x i. We start by setting dp[0] = 1, dp[1] = 1, and dp[2] = 2, because there is only 1 way to tile a board of size 2 x 0 (no tiles), 1 way to tile a board of size 2 x 1 (1 domino tile), and 2 ways to tile a board of size 2 x 2 (2 domino tiles or 1 tromino tile).\\n\\nThen, we iterate through i from 3 to n, and for each i, we calculate the number of ways to tile a board of size 2 x i by adding the number of ways to tile a board of size 2 x (i - 1) (1 domino tile), the number of ways to tile a board of size 2 x (i - 2) (1 tromino tile), and the number of ways to tile a board of size 2 x (i - 3) (2 domino tiles). We store the result in dp[i] and return dp[n] as the final answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ since we only need to iterate through n once to calculate the result.\\n\\n# Code\\n```\\nclass Solution {\\n    func numTilings(_ n: Int) -> Int {\\n        if n < 3 { return n }\\n        let mod = 1_000_000_007\\n        var dp = [1,1,2]\\n        for i in 3...n {\\n            dp.append((dp[i-1] * 2 + dp[i-3]) % mod)\\n        }\\n        return dp[n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numTilings(_ n: Int) -> Int {\\n        if n < 3 { return n }\\n        let mod = 1_000_000_007\\n        var dp = [1,1,2]\\n        for i in 3...n {\\n            dp.append((dp[i-1] * 2 + dp[i-3]) % mod)\\n        }\\n        return dp[n]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945613,
                "title": "very-easy-simple-c-solution-clean-concise-code-math-s-trick",
                "content": "*If you like it Kindly **Upvote** this solution!*\\n# Cpp Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int mod = 1e9;\\n        mod += 7;\\n\\n        vector<long long> X(1001, 0);\\n        X[1] = 1;\\n        X[2] = 2;\\n        X[3] = 5;\\n        if(n <= 3) {\\n            return X[n];\\n        }\\n        for(int i = 4; i <= n; ++i) {\\n            X[i] = 2 * X[i - 1] + X[i - 3];\\n            X[i] %= mod;\\n        }\\n        return X[n];\\n    }\\n};\\n```\\n\\n# Happy Coding:)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int mod = 1e9;\\n        mod += 7;\\n\\n        vector<long long> X(1001, 0);\\n        X[1] = 1;\\n        X[2] = 2;\\n        X[3] = 5;\\n        if(n <= 3) {\\n            return X[n];\\n        }\\n        for(int i = 4; i <= n; ++i) {\\n            X[i] = 2 * X[i - 1] + X[i - 3];\\n            X[i] %= mod;\\n        }\\n        return X[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945550,
                "title": "c-easy-dp-solution-with-0ms-and-100-acceptance",
                "content": "\\n# Approach\\nfor each value of i in range of n the value can be calculated using \\n**f(i) = 2 * f(i-1) * f(i-3)**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long mod = 1e9+7;\\n    int f(int n, vector<int> &dp){\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=(2*f(n-1,dp)%mod+f(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        if(n<=2) return n;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return f(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long mod = 1e9+7;\\n    int f(int n, vector<int> &dp){\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=(2*f(n-1,dp)%mod+f(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        if(n<=2) return n;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return f(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945548,
                "title": "c-easy-dp-solution-with-0ms-and-100-acceptance",
                "content": "\\n# Approach\\nfor each value of i in range of n the value can be calculated using \\n**f(i) = 2 * f(i-1) * f(i-3)**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long mod = 1e9+7;\\n    int f(int n, vector<int> &dp){\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=(2*f(n-1,dp)%mod+f(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        if(n<=2) return n;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return f(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long mod = 1e9+7;\\n    int f(int n, vector<int> &dp){\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=(2*f(n-1,dp)%mod+f(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        if(n<=2) return n;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return f(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945389,
                "title": "cpp-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) \\n    {\\n        int mod = 1e9 + 7;\\n        // dynamic Programming approach\\n        // for n = 1, ans => 1;\\n        // for n = 2, ans => 2;\\n\\t\\t// for n = 3, ans => 5;\\n\\t\\t// for n = 4, ans => 11; \\n        // for n > 5, \\n        // the pattern is :-\\n        // dp[n] = dp[n-1] + dp[n-2] + 2dp[n-3] + 2dp[n-4] + ... + 2*dp[0].\\n        \\n        // for n-1\\n        // dp[n-1] = dp[n-2] + dp[n-3] + 2dp[n-4] + 2dp[n-5] + ... + 2dp[0] + 2dp[-1].\\n        \\n        // assuming dp[neg] = 0 AND dp[0] = 1\\n        \\n        // which gives us\\n        // => dp[i] = 2 * dp[i-1] + dp[i-3];\\n        \\n        vector<long long> dp(1000, -1);\\n        \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(long long i = 3; i <= n; i++)\\n        {\\n            dp[i] = (2 * dp[i-1] + dp[i-3]) % mod;\\n        }\\n         \\n        return dp[n] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) \\n    {\\n        int mod = 1e9 + 7;\\n        // dynamic Programming approach\\n        // for n = 1, ans => 1;\\n        // for n = 2, ans => 2;\\n\\t\\t// for n = 3, ans => 5;\\n\\t\\t// for n = 4, ans => 11; \\n        // for n > 5, \\n        // the pattern is :-\\n        // dp[n] = dp[n-1] + dp[n-2] + 2dp[n-3] + 2dp[n-4] + ... + 2*dp[0].\\n        \\n        // for n-1\\n        // dp[n-1] = dp[n-2] + dp[n-3] + 2dp[n-4] + 2dp[n-5] + ... + 2dp[0] + 2dp[-1].\\n        \\n        // assuming dp[neg] = 0 AND dp[0] = 1\\n        \\n        // which gives us\\n        // => dp[i] = 2 * dp[i-1] + dp[i-3];\\n        \\n        vector<long long> dp(1000, -1);\\n        \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(long long i = 3; i <= n; i++)\\n        {\\n            dp[i] = (2 * dp[i-1] + dp[i-3]) % mod;\\n        }\\n         \\n        return dp[n] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945198,
                "title": "java-0ms-100-faster-explanation-with-images-dynamic-programming-recursion-and-memoization",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Dynamic Programming States.png](https://assets.leetcode.com/users/images/987ad196-d270-43f9-b3dc-3fd9d1b92707_1671874076.345487.png)\\n\\n![Dynamic Programming States 2.png](https://assets.leetcode.com/users/images/cd5a419c-565f-4945-acc2-a3eb58ac3ce4_1671874102.624622.png)\\n\\n![Dynamic Programming States 3.png](https://assets.leetcode.com/users/images/14f148d2-d15a-485d-80af-b4aaefcd9bbb_1671874125.3365417.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    Integer[][] dp;\\n    int MOD = 1000000007;\\n    private int stateOne(int n) {\\n        if(n < 0) return 0;\\n        if(n == 0 || n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        if(dp[0][n] != null) return dp[0][n];\\n\\n        int a = stateOne(n-1);\\n        int b = stateOne(n-2);\\n        int c = stateTwo(n-1);\\n        int d = stateThree(n-1);\\n\\n        return dp[0][n] = (((((a % MOD) + (b % MOD)) % MOD) + ((c % MOD) + (d % MOD)) % MOD) % MOD);\\n    }\\n    private int stateTwo(int n) {\\n        if(n <= 1) return 0; \\n        if(n == 2) return 1;\\n\\n        if(dp[1][n] != null) return dp[1][n];\\n\\n        int a = stateThree(n-1);\\n        int b = stateOne(n-2);\\n\\n        return dp[1][n] = (((a % MOD) + (b % MOD)) % MOD);\\n\\n    }\\n    private int stateThree(int n) {\\n        if(n <= 1) return 0;\\n        if(n == 2) return 1;\\n\\n        if(dp[2][n] != null) return dp[2][n];\\n\\n        int a = stateTwo(n-1);\\n        int b = stateOne(n-2);\\n\\n        return dp[2][n] = (((a % MOD) + (b % MOD)) % MOD);\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new Integer[3][n+1];\\n        return stateOne(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][] dp;\\n    int MOD = 1000000007;\\n    private int stateOne(int n) {\\n        if(n < 0) return 0;\\n        if(n == 0 || n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        if(dp[0][n] != null) return dp[0][n];\\n\\n        int a = stateOne(n-1);\\n        int b = stateOne(n-2);\\n        int c = stateTwo(n-1);\\n        int d = stateThree(n-1);\\n\\n        return dp[0][n] = (((((a % MOD) + (b % MOD)) % MOD) + ((c % MOD) + (d % MOD)) % MOD) % MOD);\\n    }\\n    private int stateTwo(int n) {\\n        if(n <= 1) return 0; \\n        if(n == 2) return 1;\\n\\n        if(dp[1][n] != null) return dp[1][n];\\n\\n        int a = stateThree(n-1);\\n        int b = stateOne(n-2);\\n\\n        return dp[1][n] = (((a % MOD) + (b % MOD)) % MOD);\\n\\n    }\\n    private int stateThree(int n) {\\n        if(n <= 1) return 0;\\n        if(n == 2) return 1;\\n\\n        if(dp[2][n] != null) return dp[2][n];\\n\\n        int a = stateTwo(n-1);\\n        int b = stateOne(n-2);\\n\\n        return dp[2][n] = (((a % MOD) + (b % MOD)) % MOD);\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new Integer[3][n+1];\\n        return stateOne(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945121,
                "title": "c-memoization-tabulation-space-optimization",
                "content": "# Observation\\nn ---> no. of ways\\n1 ---> 1\\n2 ---> 2\\n3 ---> 5\\n4 ---> 11\\n5 ---> 24\\n6 ---> 53\\n\\n# Approach\\nAs per the Observation we can formulate it as\\n```ans(n) = 2 * ans(n - 1) + ans(n - 3);```\\n\\n# Code\\n```\\n//Memoization\\nclass Solution {\\nconst int mod = 1e9+7;\\npublic:\\n    int solve(int n, vector<int>& dp){\\n        //base case\\n        if(n == 2 || n == 1)\\n            return n;\\n        if(n == 3)\\n            return 5;\\n\\n        //DP table\\n        if(dp[n] != -1)\\n            return dp[n];\\n        \\n        return dp[n] = ((2 * solve(n-1, dp)) % mod + solve(n - 3, dp) % mod) % mod;\\n    }\\n\\n    int numTilings(int n) {\\n        vector<int> dp(n+1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(N+1 + N)\\n```\\n```\\n//Tabulation\\nclass Solution {\\nconst int mod = 1e9+7;\\npublic:\\n    int numTilings(int n) {\\n        vector<int> dp(n+1, 0);\\n           \\n        // Base case \\n        if(n==1 || n==2)\\n            return n;\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;   \\n        \\n        for(int i = 4; i <= n; i++){\\n            dp[i] = ((2 * dp[i-1]) % mod + dp[i-3] % mod) % mod;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(N+1)\\n```\\n\\n```\\n//Space Optimization\\nclass Solution {\\nconst int mod = 1e9+7; \\npublic:\\n    int numTilings(int n) {\\n        // Base case        \\n        if(n==1 || n==2)\\n            return n;\\n        \\n        int n1 = 1;\\n        int n2 = 2;\\n        int n3 = 5;   \\n        \\n        int ans = n3;\\n\\n        for(int i = 4; i <= n; i++){\\n            ans = ((2 * n3) % mod + n1 % mod) % mod;\\n            n1 = n2;\\n            n2 = n3;\\n            n3 = ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(1)\\n```\\n\\n# Pls. Upvote if the solution was helpful. \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```ans(n) = 2 * ans(n - 1) + ans(n - 3);```\n```\\n//Memoization\\nclass Solution {\\nconst int mod = 1e9+7;\\npublic:\\n    int solve(int n, vector<int>& dp){\\n        //base case\\n        if(n == 2 || n == 1)\\n            return n;\\n        if(n == 3)\\n            return 5;\\n\\n        //DP table\\n        if(dp[n] != -1)\\n            return dp[n];\\n        \\n        return dp[n] = ((2 * solve(n-1, dp)) % mod + solve(n - 3, dp) % mod) % mod;\\n    }\\n\\n    int numTilings(int n) {\\n        vector<int> dp(n+1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(N+1 + N)\\n```\n```\\n//Tabulation\\nclass Solution {\\nconst int mod = 1e9+7;\\npublic:\\n    int numTilings(int n) {\\n        vector<int> dp(n+1, 0);\\n           \\n        // Base case \\n        if(n==1 || n==2)\\n            return n;\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;   \\n        \\n        for(int i = 4; i <= n; i++){\\n            dp[i] = ((2 * dp[i-1]) % mod + dp[i-3] % mod) % mod;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(N+1)\\n```\n```\\n//Space Optimization\\nclass Solution {\\nconst int mod = 1e9+7; \\npublic:\\n    int numTilings(int n) {\\n        // Base case        \\n        if(n==1 || n==2)\\n            return n;\\n        \\n        int n1 = 1;\\n        int n2 = 2;\\n        int n3 = 5;   \\n        \\n        int ans = n3;\\n\\n        for(int i = 4; i <= n; i++){\\n            ans = ((2 * n3) % mod + n1 % mod) % mod;\\n            n1 = n2;\\n            n2 = n3;\\n            n3 = ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944995,
                "title": "0ms-faster-than-100-c-3d-dp-easy-understand-commented-nearly-0-n",
                "content": "![image.png](https://assets.leetcode.com/users/images/f5e3b559-3164-47b7-b7ac-a67dea6f7617_1671870750.559493.png)\\nThe shapes which we can choose are vertical I, horizontal I, L-shape and inverted L-shape. We can decide to choose shape for currIndex after having look at previous block.\\n\\nBasically previous 2 vertical blocks can either be fully filled or it can have one of the block unfilled.\\n\\nif previous block is filled then we can \\n1] Add a vertical I\\n2] Add 2 horizontal I\\'s\\n3] Add L\\n4] Add inverted L\\n\\nIf previos block is partially filled we can\\n1] Add opposite L shape to complete the block\\n2] Add horizontal block to vacant block\\n\\nWe will keep a track of previous block and decide to choose shapes for current index.\\n\\n\\n# Code\\n```\\nconst int MOD = (int) 1e9 + 7;\\nint dp[1005][2][2];\\nclass Solution {\\npublic:\\nint findCompleteBlock(pair<int, int> &prev, int ind, int n) {\\n    int up = prev.first;\\n    int dwn = prev.second;\\n\\n    if (ind == n) return (up == 1 && dwn == 1);\\n    \\n    if(dp[ind][up][dwn] != -1) return dp[ind][up][dwn];\\n\\n    int ans = 0;\\n\\n    //prev block is complete\\n    if (prev.first == 1 && prev.second == 1) {\\n        //add a vertical block\\n        prev.first = 1;\\n        prev.second = 1;\\n        ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n        //add 2 horizontal blocks\\n        prev.first = 1;\\n        prev.second = 1;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n\\n        //add a L\\n        prev.first = 0;\\n        prev.second = 1;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n\\n        //add inverted L\\n        prev.first = 1;\\n        prev.second = 0;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n    }\\n    //prev block is half vacant\\n    else {\\n        //upper prev block is vacant\\n        if (prev.first == 0 && prev.second == 1) {\\n            //add opposite L shape to complete the block\\n            prev.first = 1;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n            //add horizontal block to upper vacant block\\n            prev.first = 1;\\n            prev.second = 0;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n        }\\n        //lower prev block is vacant\\n        else {\\n            //add opposite L shape to complete the block\\n            prev.first = 1;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n            //add horizontal block to upper vacant block\\n            prev.first = 0;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n        }\\n    }\\n\\n    return dp[ind][up][dwn] = ans;\\n}\\n    int numTilings(int n) {\\n        pair<int, int> p1 = {1, 1};\\n        memset(dp, -1, sizeof(dp));\\n        return findCompleteBlock(p1, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nconst int MOD = (int) 1e9 + 7;\\nint dp[1005][2][2];\\nclass Solution {\\npublic:\\nint findCompleteBlock(pair<int, int> &prev, int ind, int n) {\\n    int up = prev.first;\\n    int dwn = prev.second;\\n\\n    if (ind == n) return (up == 1 && dwn == 1);\\n    \\n    if(dp[ind][up][dwn] != -1) return dp[ind][up][dwn];\\n\\n    int ans = 0;\\n\\n    //prev block is complete\\n    if (prev.first == 1 && prev.second == 1) {\\n        //add a vertical block\\n        prev.first = 1;\\n        prev.second = 1;\\n        ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n        //add 2 horizontal blocks\\n        prev.first = 1;\\n        prev.second = 1;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n\\n        //add a L\\n        prev.first = 0;\\n        prev.second = 1;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n\\n        //add inverted L\\n        prev.first = 1;\\n        prev.second = 0;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n    }\\n    //prev block is half vacant\\n    else {\\n        //upper prev block is vacant\\n        if (prev.first == 0 && prev.second == 1) {\\n            //add opposite L shape to complete the block\\n            prev.first = 1;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n            //add horizontal block to upper vacant block\\n            prev.first = 1;\\n            prev.second = 0;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n        }\\n        //lower prev block is vacant\\n        else {\\n            //add opposite L shape to complete the block\\n            prev.first = 1;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n            //add horizontal block to upper vacant block\\n            prev.first = 0;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n        }\\n    }\\n\\n    return dp[ind][up][dwn] = ans;\\n}\\n    int numTilings(int n) {\\n        pair<int, int> p1 = {1, 1};\\n        memset(dp, -1, sizeof(dp));\\n        return findCompleteBlock(p1, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944908,
                "title": "c-dp-n-2-dp-n-1-dp-n-3-with-picture-explanation",
                "content": "# Picture\\n![DocScanner 24-Dec-2022 1-24 pm_1.jpg](https://assets.leetcode.com/users/images/1161f5f0-4a87-4255-bf01-e7d4b0127806_1671868753.481655.jpeg)\\n\\n![DocScanner 24-Dec-2022 1-24 pm_2.jpg](https://assets.leetcode.com/users/images/77fa1f82-4e2f-4b10-98d8-313263d52a3b_1671868765.8293238.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) We can reduce it to constant space by taking 3 variable\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[1]=1;\\n        if(n==1 || n==2){\\n            return n;\\n        }\\n        dp[2]=2;\\n        dp[3]=5;\\n        if(n==3){\\n            return 5;\\n        }\\n        long mod=1e9+7;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=((2*dp[i-1])%mod+dp[i-3]%mod)%1000000007;\\n        }\\n\\n        return dp[n];\\n    }\\n    //code by sachin\\n};\\n```\\n\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int T_3=1,T_2=2,T_1=5;;\\n        if(n==1 || n==2){\\n            return n;\\n        }\\n        if(n==3){\\n            return 5;\\n        }\\n        int ans=0;\\n        long mod=1e9+7;\\n        for(int i=4;i<=n;i++){\\n            ans=((2*T_1)%mod+T_3%mod)%1000000007;\\n            T_3=T_2;\\n            T_2=T_1;\\n            T_1=ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n//code by sachin\\n```\\n\\n\\n\\n**Upvote if solution was helpful**\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[1]=1;\\n        if(n==1 || n==2){\\n            return n;\\n        }\\n        dp[2]=2;\\n        dp[3]=5;\\n        if(n==3){\\n            return 5;\\n        }\\n        long mod=1e9+7;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=((2*dp[i-1])%mod+dp[i-3]%mod)%1000000007;\\n        }\\n\\n        return dp[n];\\n    }\\n    //code by sachin\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int T_3=1,T_2=2,T_1=5;;\\n        if(n==1 || n==2){\\n            return n;\\n        }\\n        if(n==3){\\n            return 5;\\n        }\\n        int ans=0;\\n        long mod=1e9+7;\\n        for(int i=4;i<=n;i++){\\n            ans=((2*T_1)%mod+T_3%mod)%1000000007;\\n            T_3=T_2;\\n            T_2=T_1;\\n            T_1=ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n//code by sachin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944723,
                "title": "not-easy-to-discover-the-pattern-dp-o-n-c",
                "content": "\\n# Pattern\\ndp[i] = dp[i - 1] * 2 + dp[i - 3]\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9 + 7;\\n    int numTilings(int n) {\\n        long long dp[1001] = {0};\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= n; i++){\\n            dp[i] = ((dp[i - 1]*2)%MOD + dp[i - 3])%MOD;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9 + 7;\\n    int numTilings(int n) {\\n        long long dp[1001] = {0};\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= n; i++){\\n            dp[i] = ((dp[i - 1]*2)%MOD + dp[i - 3])%MOD;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944680,
                "title": "math-solution-with-the-result-pattern-tc-o-n-sc-constant",
                "content": "# Intuition\\nCalculate the number of ways to tile an 2 * n board for first fews values (n = 1 to 4). You can see a **pattern** in the series of results. With this **Number of Ways** for next value can be calculated.\\n\\n![Screenshot 2022-12-24 at 12.07.21 PM.png](https://assets.leetcode.com/users/images/98951764-a789-4ded-93be-a3d87b4476f5_1671863856.6848295.png)\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIt looks like a pattern. \\nthe result for n (from n = 4), can be calulated using \\n```\\nres[n] = (res[n-1] * 2) + res[n-3]\\n\\n```\\nThis problem can be solved using Math calculations for the pattern.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n <= 3)\\n        {\\n            if(n == 1)\\n            {\\n                return 1;\\n            }\\n            if(n == 2)\\n            {\\n                return 2;\\n            }\\n            if(n == 3)\\n            {\\n                return 5;\\n            }\\n        }\\n\\n        int a1 = 1;\\n        int b1 = 2;\\n        int c1 = 5;\\n        int mod = 1000000007;\\n        \\n        \\n        for(int i = 3; i < n; i++)\\n        {\\n            int rest = (((2*c1) % mod) + (a1 % mod)) % mod;\\n            a1 = b1;\\n            b1 = c1;\\n            c1 = rest;\\n        }\\n        \\n        return c1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nres[n] = (res[n-1] * 2) + res[n-3]\\n\\n```\n```\\nimport java.math.*;\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n <= 3)\\n        {\\n            if(n == 1)\\n            {\\n                return 1;\\n            }\\n            if(n == 2)\\n            {\\n                return 2;\\n            }\\n            if(n == 3)\\n            {\\n                return 5;\\n            }\\n        }\\n\\n        int a1 = 1;\\n        int b1 = 2;\\n        int c1 = 5;\\n        int mod = 1000000007;\\n        \\n        \\n        for(int i = 3; i < n; i++)\\n        {\\n            int rest = (((2*c1) % mod) + (a1 % mod)) % mod;\\n            a1 = b1;\\n            b1 = c1;\\n            c1 = rest;\\n        }\\n        \\n        return c1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944634,
                "title": "c-explanation-with-visuals-memoization-dp",
                "content": "**Intution** : During *recursion* keep checking the **no of rows and columns left** because they can decide what kind of shape we can take at this moment. Check the below visuals by **archit91**\\n\\n![image](https://assets.leetcode.com/users/images/33647289-7e10-43fd-92e4-2d3bb81cd9d1_1671863274.7920697.png)\\n\\n![image](https://assets.leetcode.com/users/images/f8ba9cb6-bc35-44b0-9265-f5541b46d363_1671863217.9040167.png)\\n\\n\\nHere is the solution to that !\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<vector<int>> dp;\\n    int numTilings(int n) {\\n        dp.resize(n+1, vector<int> (n+1, -1));\\n        return solve(n,n);\\n    }\\n    \\n    int solve(int top,int bot){\\n        if(top<0 or bot<0) return 0;\\n        if(top==0 and bot ==0) return 1;\\n        \\n        if(dp[top][bot]!=-1) return dp[top][bot];\\n            \\n        long long ans=0;\\n        if(top>bot){   //                      __      __\\n            // we can take two shapes from here  | and \\n            ans=(solve(top-2,bot-1)%mod+solve(top-2,bot)%mod)%mod;\\n        }\\n        else if(bot>top){                 \\n            // we can take two shapes from here _| and __\\n            ans=(solve(top-1,bot-2)%mod+solve(top,bot-2)%mod)%mod;\\n        }\\n        else if(bot==top){ //                __   __\\n\\t\\t// we can any of the four types | ,  __ ,   | ,  __|\\n            ans=((solve(top-1,bot-1)%mod+solve(top-2,bot-2)%mod)%mod+(solve(top-1,bot-2)%mod+solve(top-2,bot-1)%mod)%mod)%mod;\\n        }\\n        \\n        return dp[top][bot] = ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<vector<int>> dp;\\n    int numTilings(int n) {\\n        dp.resize(n+1, vector<int> (n+1, -1));\\n        return solve(n,n);\\n    }\\n    \\n    int solve(int top,int bot){\\n        if(top<0 or bot<0) return 0;\\n        if(top==0 and bot ==0) return 1;\\n        \\n        if(dp[top][bot]!=-1) return dp[top][bot];\\n            \\n        long long ans=0;\\n        if(top>bot){   //                      __      __\\n            // we can take two shapes from here  | and \\n            ans=(solve(top-2,bot-1)%mod+solve(top-2,bot)%mod)%mod;\\n        }\\n        else if(bot>top){                 \\n            // we can take two shapes from here _| and __\\n            ans=(solve(top-1,bot-2)%mod+solve(top,bot-2)%mod)%mod;\\n        }\\n        else if(bot==top){ //                __   __\\n\\t\\t// we can any of the four types | ,  __ ,   | ,  __|\\n            ans=((solve(top-1,bot-1)%mod+solve(top-2,bot-2)%mod)%mod+(solve(top-1,bot-2)%mod+solve(top-2,bot-1)%mod)%mod)%mod;\\n        }\\n        \\n        return dp[top][bot] = ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944627,
                "title": "runtime-beats-100-memory-beats-93-27",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long f[1009],MOD=1e9+7;\\n        f[0]=1;\\n        f[1]=1;\\n        f[2]=2;\\n        f[3]=5;\\n        for(int i=4;i<=n;i++){\\n            f[i]=(f[i-1]+f[i-2]*2+f[i-3]+f[i-4])%MOD;\\n        }\\n        return f[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long f[1009],MOD=1e9+7;\\n        f[0]=1;\\n        f[1]=1;\\n        f[2]=2;\\n        f[3]=5;\\n        for(int i=4;i<=n;i++){\\n            f[i]=(f[i-1]+f[i-2]*2+f[i-3]+f[i-4])%MOD;\\n        }\\n        return f[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944568,
                "title": "simple-c-solution-using-dp",
                "content": "# Intuition\\nAt each possible length, try to check for different combinations at the right most end. For each such combination, count the number of  ways of filling the previous tiles (Dynamic Programming).\\n\\n# Approach\\n`dp[i]` indictes the number of ways of filling a `2 * (i+1)` board.\\nUpdate each `dp[i]` by using the above logic.\\n\\n# Complexity\\n- Time complexity: `O(n * n)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        const int mod = 1e9 + 7;\\n        vector<long> dp(max(3, n), 0);\\n        dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for(int i=3; i<n; i++) {\\n            //          |       --      |-   |\\n            //          |       --      |   -|\\n            dp[i] = (dp[i-1] + dp[i-2] + 2*dp[i-3]) % mod;\\n            long k = 1;\\n            for(int j=i-4; j>=0; --j) {\\n                //       |  --  --  --  |\\n                //       |-   --  --   -|\\n                k = (k + dp[j]) % mod;\\n            }\\n            dp[i] = (dp[i] + 2*k) % mod;\\n\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        const int mod = 1e9 + 7;\\n        vector<long> dp(max(3, n), 0);\\n        dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for(int i=3; i<n; i++) {\\n            //          |       --      |-   |\\n            //          |       --      |   -|\\n            dp[i] = (dp[i-1] + dp[i-2] + 2*dp[i-3]) % mod;\\n            long k = 1;\\n            for(int j=i-4; j>=0; --j) {\\n                //       |  --  --  --  |\\n                //       |-   --  --   -|\\n                k = (k + dp[j]) % mod;\\n            }\\n            dp[i] = (dp[i] + 2*k) % mod;\\n\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944515,
                "title": "please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthere are 2 rows only and we have 2 tiles to play with. start building tiles from the start and memoize the repetivie work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have 2 rows lets say first row be x and second be y\\nif we place L tile it will be x+1, y+2 right. \\n\\n@@   x+2,y+1\\n@\\n\\n@    x+1,y+1\\n@\\n\\n@@   x+2,y\\n\\n\\n\\nand so on.. \\nnow there are 2 things to wonder here. \\n\\n1) what if we have this state. (@) represents tile / filled.\\n@@@\\n@@\\n\\n    we can\\'t put x+1, y+1 tile here right, since it will create a gap in the y\\'th row. think about this. for this kind of state we have to choose specific tiles only that doesn\\'t lead to any gap.\\n\\n2) when we have x == y, lets say \\n@@\\n@@\\n    in this time you might place x+2,y tile and for the other call x,y+2 tile. but this will overlap the solution. So we need to do x+2,y+2\\n\\n# Complexity\\n- Time complexity: O(N) Reason is for each x we can have (x+1, x-1 or x)values for y. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        dp = {}\\n        return self.helper(n, 0,0, dp)%(10**9+7)\\n\\n    def helper(self, n, x, y, dp):\\n        if x>n or y>n:\\n            return 0\\n        if x==n and y==n:\\n            return 1\\n        if (x,y) in dp:\\n            return dp[(x,y)]\\n        ans = 0\\n        if x==y:\\n            ans+=self.helper(n, x+1, y+1, dp)\\n            ans+=self.helper(n, x+2, y+2, dp)\\n            ans+=self.helper(n, x+1, y+2, dp)\\n            ans+=self.helper(n, x+2, y+1, dp)\\n        elif (x-y)==1:\\n            ans+=self.helper(n, x+1, y+2, dp)\\n            ans+=self.helper(n, x, y+2, dp)\\n        else:\\n            ans+=self.helper(n, x+2, y+1, dp)\\n            ans+=self.helper(n, x+2, y, dp)\\n        dp[(x,y)]=ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        dp = {}\\n        return self.helper(n, 0,0, dp)%(10**9+7)\\n\\n    def helper(self, n, x, y, dp):\\n        if x>n or y>n:\\n            return 0\\n        if x==n and y==n:\\n            return 1\\n        if (x,y) in dp:\\n            return dp[(x,y)]\\n        ans = 0\\n        if x==y:\\n            ans+=self.helper(n, x+1, y+1, dp)\\n            ans+=self.helper(n, x+2, y+2, dp)\\n            ans+=self.helper(n, x+1, y+2, dp)\\n            ans+=self.helper(n, x+2, y+1, dp)\\n        elif (x-y)==1:\\n            ans+=self.helper(n, x+1, y+2, dp)\\n            ans+=self.helper(n, x, y+2, dp)\\n        else:\\n            ans+=self.helper(n, x+2, y+1, dp)\\n            ans+=self.helper(n, x+2, y, dp)\\n        dp[(x,y)]=ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944408,
                "title": "top-down-dp-easy-to-understand",
                "content": "# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        // we can solve this problem using dynamic programming\\n        int MOD = 1e9 + 7;\\n        vector<vector<int>> memo(n+1, vector<int>(2, -1));\\n\\n        function<int(int,bool)> solve = [&](int i, bool flag) {\\n            // if we go out of bounds\\n            if(i < 0) return 0;\\n\\n            // if we tiled the entire board\\n            if(i == 0) return (int)!flag;\\n\\n            // if we memoized the current state\\n            if(memo[i][flag] != -1) return memo[i][flag];\\n\\n            long result = 0;\\n\\n            // if we have 1 cell covered in the current column\\n            if(flag) {\\n                // we can use a horizontal domino\\n                long val1 = solve(i-1, true);\\n\\n                // we can use a tromino\\n                long val2 = solve(i-2, false);\\n\\n                result = val1 + val2;\\n            }\\n            else {\\n                // we can use a vertical domino\\n                long val1 = solve(i-1, false);\\n\\n                // we can use 2 horizontal dominos\\n                long val2 = solve(i-2, false);\\n\\n                // we can use a tromino\\n                // there are two ways of placing it\\n                long val3 = 2*solve(i-1, true);\\n\\n                result = val1 + val2 + val3;\\n            }\\n\\n            return memo[i][flag] = result%MOD;\\n        };\\n\\n        // start with an empty board\\n        return solve(n, false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        // we can solve this problem using dynamic programming\\n        int MOD = 1e9 + 7;\\n        vector<vector<int>> memo(n+1, vector<int>(2, -1));\\n\\n        function<int(int,bool)> solve = [&](int i, bool flag) {\\n            // if we go out of bounds\\n            if(i < 0) return 0;\\n\\n            // if we tiled the entire board\\n            if(i == 0) return (int)!flag;\\n\\n            // if we memoized the current state\\n            if(memo[i][flag] != -1) return memo[i][flag];\\n\\n            long result = 0;\\n\\n            // if we have 1 cell covered in the current column\\n            if(flag) {\\n                // we can use a horizontal domino\\n                long val1 = solve(i-1, true);\\n\\n                // we can use a tromino\\n                long val2 = solve(i-2, false);\\n\\n                result = val1 + val2;\\n            }\\n            else {\\n                // we can use a vertical domino\\n                long val1 = solve(i-1, false);\\n\\n                // we can use 2 horizontal dominos\\n                long val2 = solve(i-2, false);\\n\\n                // we can use a tromino\\n                // there are two ways of placing it\\n                long val3 = 2*solve(i-1, true);\\n\\n                result = val1 + val2 + val3;\\n            }\\n\\n            return memo[i][flag] = result%MOD;\\n        };\\n\\n        // start with an empty board\\n        return solve(n, false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944067,
                "title": "golang-bottom-up-1d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Golang implementation of solution from https://leetcode.com/problems/domino-and-tromino-tiling/discussion/comments/1566271\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc numTilings(n int) int {\\n    if n == 0 {\\n        return 0\\n    }\\n    if n == 1 {\\n        return 1\\n    }\\n    if n == 2 {\\n        return 2\\n    }\\n    m := make([]int, n+1)\\n    m[0] = 1\\n    m[1] = 1\\n    m[2] = 2\\n    for i := 3; i < n+1; i++ {\\n        m[i] = (2 * m[i-1] + m[i-3]) % 1_000_000_007\\n    } \\n    return m[n]\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numTilings(n int) int {\\n    if n == 0 {\\n        return 0\\n    }\\n    if n == 1 {\\n        return 1\\n    }\\n    if n == 2 {\\n        return 2\\n    }\\n    m := make([]int, n+1)\\n    m[0] = 1\\n    m[1] = 1\\n    m[2] = 2\\n    for i := 3; i < n+1; i++ {\\n        m[i] = (2 * m[i-1] + m[i-3]) % 1_000_000_007\\n    } \\n    return m[n]\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2943991,
                "title": "linear-loop-o-n-o-1-better-than-99-5-time-and-99-2-memory-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing recursive formula f(n) = f(n-1) * 2 + f(n-3).\\nThen unwinding recursion into linear loop over array.\\nFinally optimizing memory by storing only last 3 values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        nums = [1, 1, 2]\\n        if n < 3:\\n            return n\\n        for i in range(3, n+1):\\n            nums = [nums[1], nums[2], nums[2] * 2 + nums[0]]\\n        return nums[2] % (10 ** 9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        nums = [1, 1, 2]\\n        if n < 3:\\n            return n\\n        for i in range(3, n+1):\\n            nums = [nums[1], nums[2], nums[2] * 2 + nums[0]]\\n        return nums[2] % (10 ** 9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943965,
                "title": "python",
                "content": "There are 3 states:\\n* top and bottom have the same length\\n* top is longer than bottom by 1\\n* bottom is longer than top by 1\\n\\nWe make choices based on the current state\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        @cache\\n        def dp(t, b):\\n            if t > n or b > n:\\n                return 0\\n            if t == b == n:\\n                return 1\\n            if t > b:\\n                return dp(t, b+2) + dp(t+1, b+2)\\n            if t < b:\\n                return dp(t+2, b) + dp(t+2, b+1)\\n            return dp(t+1, b+1) + dp(t+2, b+2) + dp(t+2, b+1) + dp(t+1, b+2)\\n\\n        return dp(0, 0) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        @cache\\n        def dp(t, b):\\n            if t > n or b > n:\\n                return 0\\n            if t == b == n:\\n                return 1\\n            if t > b:\\n                return dp(t, b+2) + dp(t+1, b+2)\\n            if t < b:\\n                return dp(t+2, b) + dp(t+2, b+1)\\n            return dp(t+1, b+1) + dp(t+2, b+2) + dp(t+2, b+1) + dp(t+1, b+2)\\n\\n        return dp(0, 0) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943889,
                "title": "c-solution-with-comments-and-explanation",
                "content": "# Intuition\\n![image.png](https://assets.leetcode.com/users/images/b7dbe13d-ff96-4bab-b6f4-64a79c4eaafc_1671841615.5294669.png)\\nFirst, picture we have a `2 x n` grid, and we are filling the grid from left to right. One thing that comes to mind is top-down memoization. Intuitively, for every `n`, there are two cases on the right-most column that we are examining: \\n1. only one grid in the column is empty\\n2. both grids in the column are empty\\n\\nWhen both grids are empty, we can have the following:\\n- place one domino vertically\\n- place two domino horizontally\\n- place one tromino, but since there are two orientations, we have two ways of doing so\\n\\nWhen only one grid is empty, we can have the following:\\n- place one domino horizontally\\n- place one tromino\\n\\nAfter understanding the two cases, simply memoize on `n` and `isBothEmpty`. Remember to take the modulo after the calculation :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long int solve(vector<vector<long long int>> &dp, int n, bool isBothEmpty){\\n        // base cases\\n        if(n <= 1) return (isBothEmpty ? 1 : 0);\\n        if(n <= 2) return (isBothEmpty ? 2 : 1);\\n        if(dp[n][isBothEmpty] != -1) return dp[n][isBothEmpty];\\n        long long int ans = 0;\\n        if(isBothEmpty){\\n            // place one domino vertically\\n            ans += solve(dp,n-1,true);\\n            // place two domino horizontally\\n            ans += solve(dp,n-2,true);\\n            // place one tromino (2 ways)\\n            ans += 2*solve(dp,n-1,false);\\n        } else {\\n            // place one domino horizontally\\n            ans += solve(dp,n-1,false);\\n            // place one tromino \\n            ans += solve(dp,n-2,true);\\n        }\\n        return dp[n][isBothEmpty] = ans%mod;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n+1, vector<long long int>(2,-1));\\n        return solve(dp, n, true);\\n    }\\n};\\n```\\n\\n# Compact Version\\n```\\nclass Solution {\\npublic:\\n    long long int solve(vector<vector<long long int>> &dp, int n, bool isBothEmpty){\\n        if(n <= 2) return (isBothEmpty ? n : n-1);\\n        if(dp[n][isBothEmpty] != -1) return dp[n][isBothEmpty];\\n        long long int ans = 0;\\n        if(isBothEmpty)\\n            ans = solve(dp,n-1,true) + solve(dp,n-2,true) + 2*solve(dp,n-1,false);\\n        else \\n            ans = solve(dp,n-1,false) + solve(dp,n-2,true);\\n        return dp[n][isBothEmpty] = ans%((int)1e9+7);\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n+1, vector<long long int>(2,-1));\\n        return solve(dp, n, true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long int solve(vector<vector<long long int>> &dp, int n, bool isBothEmpty){\\n        // base cases\\n        if(n <= 1) return (isBothEmpty ? 1 : 0);\\n        if(n <= 2) return (isBothEmpty ? 2 : 1);\\n        if(dp[n][isBothEmpty] != -1) return dp[n][isBothEmpty];\\n        long long int ans = 0;\\n        if(isBothEmpty){\\n            // place one domino vertically\\n            ans += solve(dp,n-1,true);\\n            // place two domino horizontally\\n            ans += solve(dp,n-2,true);\\n            // place one tromino (2 ways)\\n            ans += 2*solve(dp,n-1,false);\\n        } else {\\n            // place one domino horizontally\\n            ans += solve(dp,n-1,false);\\n            // place one tromino \\n            ans += solve(dp,n-2,true);\\n        }\\n        return dp[n][isBothEmpty] = ans%mod;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n+1, vector<long long int>(2,-1));\\n        return solve(dp, n, true);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long int solve(vector<vector<long long int>> &dp, int n, bool isBothEmpty){\\n        if(n <= 2) return (isBothEmpty ? n : n-1);\\n        if(dp[n][isBothEmpty] != -1) return dp[n][isBothEmpty];\\n        long long int ans = 0;\\n        if(isBothEmpty)\\n            ans = solve(dp,n-1,true) + solve(dp,n-2,true) + 2*solve(dp,n-1,false);\\n        else \\n            ans = solve(dp,n-1,false) + solve(dp,n-2,true);\\n        return dp[n][isBothEmpty] = ans%((int)1e9+7);\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n+1, vector<long long int>(2,-1));\\n        return solve(dp, n, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943847,
                "title": "daily-leetcoding-challenge-december-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** Dynamic Programming (Top-down)\n**Approach 2:** Dynamic Programming (Bottom-up)\n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n**Approach 6:** Math optimization (Fibonacci sequence like)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2276743,
                "title": "stumbling-our-way-to-o-n-solution-eventually",
                "content": "Let us form a 2-D table (i.e. simply an array) by the name dp such that it contains the no. of ways to tile a floor. The n\\'th element in the array denotes the no. of ways to tile 2xn floor. dp[n=N] will be the anwer.\\nLet us consider the a few tile configurations added to the right end.\\n![image](https://assets.leetcode.com/users/images/08da9ec1-2710-4ae1-8a04-6131844c89a6_1657712108.71259.jpeg)\\nThus the code for the following will be:\\n```\\ndef numTilings(self, n: int) -> int:\\n\\tdp = [0] * (n+1)\\n\\tdp[0] = 1\\n\\tfor i in range(1,n+1):\\n\\t\\tfor j in range(1,i+1):\\n\\t\\t\\tif j<=2:\\n\\t\\t\\t\\tdp[i] += dp[i-j]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i] += dp[i-j]*2                \\n\\treturn dp[n]%(10**9+7)\\n```\\nIt\\'s Dynamic Programming but a bit slow, actually a lot slow, on leetcode it beats only 5% of the solutions in time. Clearly, it is O(n^2). Can we optimize it to O(n)? Yes. Let\\'s do some maths :)\\n\\n![image](https://assets.leetcode.com/users/images/7ca27c26-bffb-40c3-9353-661f0f780dc3_1657712258.206752.jpeg)\\n\\nWow, math saves our little pc a lot of unnecessary manual work, let\\'s use it in our code now.\\n```\\ndef numTilings(self, n: int) -> int:\\n\\tdp = [0] * (n+1)\\n\\tif n<=1:\\n\\t\\treturn 1\\n\\telif n<=2:\\n\\t\\treturn 2\\n\\telif n<=3:\\n\\t\\treturn 5\\n\\tdp[0] = 1\\n\\tdp[1] = 1\\n\\tdp[2] = 2\\n\\tdp[3] = 5\\n\\n\\tfor i in range(4,n+1):\\n\\t\\tdp[i] = 2*dp[i-1] + dp[i-3]              \\n\\treturn dp[n]%(10**9+7)\\n```\\nNow, its 0(n)! It beats 90% on leetcode. Great job!\\nThank you :)\\n\\nIf what I ment by last configurations on the very begining didn\\'t make a clear understanding, allow me to explain it well and with clarity using a video.\\n[->Click Here To Watch](https://youtu.be/sZ3d1gkOQeE)",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef numTilings(self, n: int) -> int:\\n\\tdp = [0] * (n+1)\\n\\tdp[0] = 1\\n\\tfor i in range(1,n+1):\\n\\t\\tfor j in range(1,i+1):\\n\\t\\t\\tif j<=2:\\n\\t\\t\\t\\tdp[i] += dp[i-j]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i] += dp[i-j]*2                \\n\\treturn dp[n]%(10**9+7)\\n```\n```\\ndef numTilings(self, n: int) -> int:\\n\\tdp = [0] * (n+1)\\n\\tif n<=1:\\n\\t\\treturn 1\\n\\telif n<=2:\\n\\t\\treturn 2\\n\\telif n<=3:\\n\\t\\treturn 5\\n\\tdp[0] = 1\\n\\tdp[1] = 1\\n\\tdp[2] = 2\\n\\tdp[3] = 5\\n\\n\\tfor i in range(4,n+1):\\n\\t\\tdp[i] = 2*dp[i-1] + dp[i-3]              \\n\\treturn dp[n]%(10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1622465,
                "title": "java-solution-recursion-dp",
                "content": "So what we essentially wanna do is put the tilings in such a way that whole area is covered. Now we have two types of tilings domino and tromino. Taking a high level view of the problem we get that at every step we have to make a choice whether to pick a domino or tromino and if a domino which orientation and if a tromino then which orientation. Sounds like recursion to me!\\n\\nLet\\'s start recursion then.\\n\\nSo let\\u2019s say we are at position x now we look into our options:\\n1.\\tPick a domino: Here again we got two choices:\\n\\ta.\\tWe take vertical domino. So when we take a vertical domino this whole column is covered and we can move to x-1.![image](https://assets.leetcode.com/users/images/c3f52349-593b-410d-b9c6-822304f3ca12_1639195839.8293874.png)\\n\\tb.\\tWe take a horizontal domino. So when we take a horizontal domino two columns of a row are covered and the row other than this has only one option to place a horizontal domino, hence we can move to x-2.![image](https://assets.leetcode.com/users/images/8221f839-eb26-4e2d-a880-b9dabde93eb7_1639195865.765447.png)\\n2.\\tPick a tromino: Now when we pick a tromino we will fill one column and fill the other one partially. Now in the partial filled column we have two options:![image](https://assets.leetcode.com/users/images/ca1ff0b7-56d7-4046-9b4e-2c04904a3777_1639195892.081208.png)\\n\\ta.\\tWe can start a tromino from there. By doing this we would have filled 3 columns completely.![image](https://assets.leetcode.com/users/images/4c8465a6-1b8f-424c-a9c4-18edeb015278_1639195923.0817401.png)\\nb.\\tWe can start a horizontal domino from the partially unfilled area.![image](https://assets.leetcode.com/users/images/7ef8b8cd-c16a-4b23-9664-291b5d1119ba_1639195945.061751.png)\\n\\nSo talking mathematically, \\n\\nf(x) = part1 + part2 + part3 where, \\npart1 = f(x-1) => the case of vertical domino \\npart2 = f(x-2) => the case of horizontal domino \\npart3 = 2*p(x-1) => the case for tromino \\n\\nNow we know f(x), let\\u2019s define p(x). \\n\\np(x) is for the partially filled column. So whenever we put a tromino we call p(x-1) where tromino is put at x so the column previous to that would be partially filled right. Now, \\n\\np(x) = part4 + part5 \\npart4 = f(x-2) => case where we put another domino and completely fill the columns \\npart5 = p(x-1) => case where we put horizontal domino in the partially unfilled column, thus creating another partially filled column. \\n\\nNow you might think why I multiplied by 2 in part3. The reason is that we can place a tromino in 2 ways either its \\u2018L\\u2019 shaped or mirror image of \\u2018L\\u2019. Hence multiplication by 2.\\n\\nRecursive Code:\\n\\n```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    public int numTilings(int n) {\\n        return (int)(recur( n ) % mod);\\n    }\\n    public long recur ( int x ) {\\n        if ( x==0 ) {\\n            return 1;\\n        }\\n        if ( x<0 ) {\\n            return 0;\\n        }\\n        return (long)2*partial(x-1) + recur(x-2) + recur(x-1);\\n    }\\n    public long partial( int x ) {\\n        if ( x==0 ) {\\n            return 0;\\n        }\\n        if ( x<3 ) {\\n            return x-1;\\n        }\\n        return (long)partial(x-1) + recur(x-2);\\n    }\\n}\\n```\\n\\nNow recursion leads to TLE. What to we do know?\\nAnswer: Memoization\\n\\n```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    Long[] full;\\n    Long[] part;\\n    public int numTilings(int n) {\\n        full = new Long[n+1];\\n        part = new Long[n+1];\\n        return recur( n );\\n    }\\n    public int recur ( int x ) {\\n        if ( x==0 ) {\\n            return 1;\\n        }\\n        if ( x<0 ) {\\n            return 0;\\n        }\\n        int temp = 0;\\n        if ( full[x]!=null ) {\\n            temp = (int)(full[x]%mod);\\n            return temp;\\n        }\\n        full[x] = (long)2*partial(x-1) + recur(x-2) + recur(x-1);\\n        temp = (int)(full[x]%mod);\\n        return temp;\\n    }\\n    public int partial( int x ) {\\n        if ( x==0 ) {\\n            return 0;\\n        }\\n        if ( x<3 ) {\\n            return x-1;\\n        }\\n        int temp = 0;\\n        if ( part[x]!=null ) {\\n            temp = (int)(part[x]%mod);\\n            return temp;\\n        }\\n        part[x] = (long)partial(x-1) + recur(x-2);\\n        temp = (int)(part[x]%mod);\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    public int numTilings(int n) {\\n        return (int)(recur( n ) % mod);\\n    }\\n    public long recur ( int x ) {\\n        if ( x==0 ) {\\n            return 1;\\n        }\\n        if ( x<0 ) {\\n            return 0;\\n        }\\n        return (long)2*partial(x-1) + recur(x-2) + recur(x-1);\\n    }\\n    public long partial( int x ) {\\n        if ( x==0 ) {\\n            return 0;\\n        }\\n        if ( x<3 ) {\\n            return x-1;\\n        }\\n        return (long)partial(x-1) + recur(x-2);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    Long[] full;\\n    Long[] part;\\n    public int numTilings(int n) {\\n        full = new Long[n+1];\\n        part = new Long[n+1];\\n        return recur( n );\\n    }\\n    public int recur ( int x ) {\\n        if ( x==0 ) {\\n            return 1;\\n        }\\n        if ( x<0 ) {\\n            return 0;\\n        }\\n        int temp = 0;\\n        if ( full[x]!=null ) {\\n            temp = (int)(full[x]%mod);\\n            return temp;\\n        }\\n        full[x] = (long)2*partial(x-1) + recur(x-2) + recur(x-1);\\n        temp = (int)(full[x]%mod);\\n        return temp;\\n    }\\n    public int partial( int x ) {\\n        if ( x==0 ) {\\n            return 0;\\n        }\\n        if ( x<3 ) {\\n            return x-1;\\n        }\\n        int temp = 0;\\n        if ( part[x]!=null ) {\\n            temp = (int)(part[x]%mod);\\n            return temp;\\n        }\\n        part[x] = (long)partial(x-1) + recur(x-2);\\n        temp = (int)(part[x]%mod);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621978,
                "title": "cpp-solution-better-than-100-using-dp-bottom-up-top-down",
                "content": "CPP SOLUTION\\n\\n**Top Down**\\n\\n\\tclass Solution\\n\\t{\\n\\tpublic:\\n\\t\\tvector<vector<int>> dp;\\n\\n\\t\\tconst int mod = 1e9 + 7;\\n\\t\\tint findState(bool t1, bool t2)\\n\\t\\t{\\n\\t\\t\\tint state = 0;\\n\\t\\t\\tif (t1)\\n\\t\\t\\t\\tstate |= 1;\\n\\t\\t\\tif (t2)\\n\\t\\t\\t\\tstate |= 2;\\n\\t\\t\\treturn state;\\n\\t\\t}\\n\\t\\tint numTilings(int &n, int i, int t1 = true, int t2 = true)\\n\\t\\t{\\n\\t\\t\\tif (i == n)\\n\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\tint state = findState(t1, t2);\\n\\n\\t\\t\\tif (dp[i][state] != -1)\\n\\t\\t\\t\\treturn dp[i][state];\\n\\n\\t\\t\\tbool t3 = i + 1 < n;\\n\\t\\t\\tbool t4 = i + 1 < n;\\n\\n\\t\\t\\tlong long count = 0;\\n\\t\\t\\tif (t1 && t2 && t3)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, true);\\n\\t\\t\\tif (t1 && t2 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, true, false);\\n\\t\\t\\tif (t1 && !t2 && t3 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, false);\\n\\t\\t\\tif (!t1 && t2 && t3 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, false);\\n\\t\\t\\tif (t1 && t2 && t3 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, false);\\n\\t\\t\\tif (t1 && t2)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, true, true);\\n\\t\\t\\tif (!t1 && !t2)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, true, true);\\n\\t\\t\\tif (t1 && !t2 && t3)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, true);\\n\\t\\t\\tif (!t1 && t2 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, true, false);\\n\\t\\t\\treturn dp[i][state] = count % mod;\\n\\t\\t}\\n\\t\\tint numTilings(int n)\\n\\t\\t{\\n\\t\\t\\tdp.resize(n + 1, vector<int>(4, -1));\\n\\t\\t\\treturn numTilings(n, 0);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n**Using Bottom UP **\\nBetter than 100%  submissions\\n\\t\\n\\tclass Solution\\n\\t{\\n\\tpublic:\\n\\t\\tlong long dp[1001][4];\\n\\t\\tconst int mod = 1e9 + 7;\\n\\t\\tint numTilings(int n)\\n\\t\\t{\\n\\t\\t\\tmemset(dp, 0, sizeof(dp));\\n\\t\\t\\tdp[0][3] = 1;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < 4; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch (j)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase 0:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][3];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 1:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][2] + dp[i - 1][0];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][1] + dp[i - 1][0];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 3:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][0] + dp[i - 1][3] + dp[i - 1][2] + dp[i - 1][1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][j] %= mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n][3];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n\\t\\tvector<vector<int>> dp;\\n\\n\\t\\tconst int mod = 1e9 + 7;\\n\\t\\tint findState(bool t1, bool t2)\\n\\t\\t{\\n\\t\\t\\tint state = 0;\\n\\t\\t\\tif (t1)\\n\\t\\t\\t\\tstate |= 1;\\n\\t\\t\\tif (t2)\\n\\t\\t\\t\\tstate |= 2;\\n\\t\\t\\treturn state;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1621804,
                "title": "100ms-c-super-easy-observation-dp-soultion",
                "content": "I loved how beautifully other people are providing recursive and DP solution of this problem. These all solutions are no doubt excellent but I think they should also provide this observation solution which makes this question super easy.\\nMy solution is a Observation DP solution. \\n*I want that people should learn to observe patterns*. Many problems which seem too difficult/complicated to solve can be easily solved if you find the pattern.\\n**Pattern**\\n![image](https://assets.leetcode.com/users/images/742800c0-4b41-4a28-ad08-a07cfdc44cc2_1639156314.7856784.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int a[n+1];\\n        a[0] = 0;\\n        a[1] = 1;\\n        if(n>=2)\\n            a[2] = 2;\\n        if(n>=3)\\n            a[3] = 5;\\n        \\n        unsigned int M = 1e9+7;\\n        for(int i=4; i<n+1; i++){\\n            unsigned long long val = 1; \\n\\t\\t\\t// our val at a[i] is simply, val = (2*a[i-1]) + a[i-3] \\n\\t\\t\\t//but because this val is tool large \\n\\t\\t\\t//we have to take modulo at each step\\n\\t\\t\\tval = (val * a[i-1]) % M;\\n            val = (2 * val) % M;\\n            val = (val + a[i-3])%M;\\n            a[i] = val;\\n        }\\n        \\n        return a[n]; // returned our ans at a[n]\\n    }\\n};\\n```\\n**Please upvote!! If you understand the solution.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int a[n+1];\\n        a[0] = 0;\\n        a[1] = 1;\\n        if(n>=2)\\n            a[2] = 2;\\n        if(n>=3)\\n            a[3] = 5;\\n        \\n        unsigned int M = 1e9+7;\\n        for(int i=4; i<n+1; i++){\\n            unsigned long long val = 1; \\n\\t\\t\\t// our val at a[i] is simply, val = (2*a[i-1]) + a[i-3] \\n\\t\\t\\t//but because this val is tool large \\n\\t\\t\\t//we have to take modulo at each step\\n\\t\\t\\tval = (val * a[i-1]) % M;\\n            val = (2 * val) % M;\\n            val = (val + a[i-3])%M;\\n            a[i] = val;\\n        }\\n        \\n        return a[n]; // returned our ans at a[n]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621772,
                "title": "javscript-dp",
                "content": "```\\nvar numTilings = function(n) {\\n    if(n==1) return 1;\\n    if(n==2) return 2;\\n    if(n==3) return 5;\\n    let dp =[];\\n    dp[1] =1;\\n    dp[2] =2;\\n    dp[3] =5;\\n    let mod = 1e9 ;\\n    mod+=7;\\n    for(let i =4; i<=n; i++){\\n        dp[i] = (2*dp[i-1]%mod + dp[i-3]%mod) % mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTilings = function(n) {\\n    if(n==1) return 1;\\n    if(n==2) return 2;\\n    if(n==3) return 5;\\n    let dp =[];\\n    dp[1] =1;\\n    dp[2] =2;\\n    dp[3] =5;\\n    let mod = 1e9 ;\\n    mod+=7;\\n    for(let i =4; i<=n; i++){\\n        dp[i] = (2*dp[i-1]%mod + dp[i-3]%mod) % mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621154,
                "title": "c-and-java-easy-explained-in-o-n-and-o-1-space",
                "content": "If you see the values for n, like (n = 1 ans  = 1), (n = 2 ans = 2), (n = 3 ans = 5), (n = 4 ans = 11), (n = 5 ans = 24), (n=6 ans = 53)....\\nWe can observe that in general for n, ans[n] = 2*(ans[n-1]) + ans[n-3]\\nNow this is simple DP problem!!\\n\\n***C++ Solution:***\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        \\n        vector<long long> dp(1001,0);\\n        dp[1]=1, dp[2]=2, dp[3]=5;\\n        \\n        if(n<=3)\\n            return dp[n];\\n        \\n        for(int i=4;i<=n;++i)\\n            dp[i]=(2*dp[i-1]+dp[i-3])%1000000007; \\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n***Java Solution:***\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n<=2) \\n            return n;\\n        \\n        int[] dp=new int[n+1];\\n        int mod = (int)(Math.pow(10,9)+7);\\n        dp[0]=1;dp[1]=1;dp[2]=2;\\n        \\n\\t\\tfor(int i=3;i<=n;i++) {\\n            dp[i]=(2*dp[i-1])%mod+dp[i-3];\\n            dp[i]%=mod;\\n        }\\n\\t\\t\\n        return dp[n];\\n    }\\n}\\n```\\n***Time:*** O(n) ***Space:*** O(n)\\n\\nBut what if we want to decrease space too.... \\uD83E\\uDDD0\\uD83E\\uDD14\\n\\nWe can observe that ans[n] is just being dependent on ans[n-1] and ans[n-3]. So we will take 4 variables (namely one, two, three, res). Now we can store dp[1], dp[2], dp[3] into one, two, three variables resp. And res = 2 * three + one. Thats it!!!\\n\\n***C++ Solution:***\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        \\n        long long one=1, two=2, three=5, total;\\n        \\n        if (n==1)\\n            return one;\\n        if (n==2)\\n            return two;\\n        if (n==3)\\n            return three;\\n        \\n        for(int i=4; i<=n; i++){\\n            total = (2*three + one)%1000000007;\\n            one = two;\\n            two = three;\\n            three = total;\\n        }\\n        \\n        return total%1000000007;\\n    }\\n};\\n```\\n\\n***Java Solution:***\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        int one=1, two=2, three=5, total=0;\\n        \\n        if (n==1)\\n            return 1;\\n        if (n==2)\\n            return 2;\\n        if (n==3)\\n            return 5;\\n        \\n        for(int i=4; i<=n; i++){\\n            total = (2*three%1000000007 + one)%1000000007;\\n            one = two;\\n            two = three;\\n            three = total;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```\\n\\n***Time:*** O(n)         ***Space:*** O(1)\\n\\nPlease upvote if you found helpful!!\\u263A\\uFE0F",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        \\n        vector<long long> dp(1001,0);\\n        dp[1]=1, dp[2]=2, dp[3]=5;\\n        \\n        if(n<=3)\\n            return dp[n];\\n        \\n        for(int i=4;i<=n;++i)\\n            dp[i]=(2*dp[i-1]+dp[i-3])%1000000007; \\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n<=2) \\n            return n;\\n        \\n        int[] dp=new int[n+1];\\n        int mod = (int)(Math.pow(10,9)+7);\\n        dp[0]=1;dp[1]=1;dp[2]=2;\\n        \\n\\t\\tfor(int i=3;i<=n;i++) {\\n            dp[i]=(2*dp[i-1])%mod+dp[i-3];\\n            dp[i]%=mod;\\n        }\\n\\t\\t\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        \\n        long long one=1, two=2, three=5, total;\\n        \\n        if (n==1)\\n            return one;\\n        if (n==2)\\n            return two;\\n        if (n==3)\\n            return three;\\n        \\n        for(int i=4; i<=n; i++){\\n            total = (2*three + one)%1000000007;\\n            one = two;\\n            two = three;\\n            three = total;\\n        }\\n        \\n        return total%1000000007;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        int one=1, two=2, three=5, total=0;\\n        \\n        if (n==1)\\n            return 1;\\n        if (n==2)\\n            return 2;\\n        if (n==3)\\n            return 5;\\n        \\n        for(int i=4; i<=n; i++){\\n            total = (2*three%1000000007 + one)%1000000007;\\n            one = two;\\n            two = three;\\n            three = total;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620998,
                "title": "c-simple-o-n-time-and-space-complexity-solution-using-only-one-array",
                "content": "We use a 2d dp array having two states 0 and 1 .\\n\\nWhere 0 represent that both block in this column are empty and 1 represent one block of this colum is filled and one is empty.\\n\\ndp[i][0] gives the possible number of ways of tiling tiles from i to n when ith column is empty\\ndp[i][1] gives the possible number of ways of tiling tiles from i to n when ith column has one filled block.\\n\\nNow dp[i][0] will be \\n\\ndp[i+1][0](we filled the ith column with a vertical domino and moves to next column which is empty )\\n                                         + \\n 2*dp[i+1][1](we fill ith column with a tromino and move to next column which is half filled and we have multiplied it by 2 because there are two ways of putting the tromino  )\\n                                         + \\n dp[i+2][0] (we filled the ith and (i+1)th column with two horizontal domino and moves to i+2 th column which is empty )\\n\\ndp[i][1] will be \\n\\ndp[i+1][1] (we filled the empty block with a horizontal domino which completes this column and makes the next column half filled) \\n                             + \\n dp[i+2][0](we filled this half empty and next column with a tromino and move to i+2 th column)\\n \\n Now the base cases:-\\n \\n if we reach the nth column which is empty we can fill it with vertical domino and complete our tiling so we return 1 but if the nth column is half filled then there is no way to complete the tiling so we return 0.\\n \\nif we reach the n+1th colum directly from n-1 then we will return 1 because all the column till n is completrly filled beacuse whenever we have jumped to i+2 we have always completrd all the column till i+1.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long dp[1001][2];\\n    int mod=1e9+7;\\n    long long solve(int i,int c,int n){\\n        if(i>n){\\n            return 1;\\n        }\\n        if(i==n){\\n            if(c==0)return 1;\\n            return 0;\\n        }\\n        if(dp[i][c]!=-1)return dp[i][c];\\n        if(c==0){\\n            return dp[i][c]=(solve(i+1,0,n)%mod+(2*solve(i+1,1,n)%mod)%mod + solve(i+2,0,n)%mod)%mod;\\n        }else{\\n            return dp[i][c]=(solve(i+1,1,n)%mod+solve(i+2,0,n)%mod)%mod;\\n        }\\n    }\\n    int numTilings(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,0,n)%mod;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[1001][2];\\n    int mod=1e9+7;\\n    long long solve(int i,int c,int n){\\n        if(i>n){\\n            return 1;\\n        }\\n        if(i==n){\\n            if(c==0)return 1;\\n            return 0;\\n        }\\n        if(dp[i][c]!=-1)return dp[i][c];\\n        if(c==0){\\n            return dp[i][c]=(solve(i+1,0,n)%mod+(2*solve(i+1,1,n)%mod)%mod + solve(i+2,0,n)%mod)%mod;\\n        }else{\\n            return dp[i][c]=(solve(i+1,1,n)%mod+solve(i+2,0,n)%mod)%mod;\\n        }\\n    }\\n    int numTilings(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,0,n)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481663,
                "title": "fastest-c-solution-bottom-up-dp-dp-n-2-dp-n-1-dp-n-3",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<long long >dp(n+1,0);\\n        if(n==1) return 1;\\n        if(n==2) return 2;                            //Base Cases\\n        if(n==3) return 5;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        int mod=1000000007;\\n        for(int i=4;i<=n;i++)\\n        {\\n            dp[i]=((2*dp[i-1])%mod+(dp[i-3])%mod)%mod;\\n        }\\n        return dp[n];\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<long long >dp(n+1,0);\\n        if(n==1) return 1;\\n        if(n==2) return 2;                            //Base Cases\\n        if(n==3) return 5;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        int mod=1000000007;\\n        for(int i=4;i<=n;i++)\\n        {\\n            dp[i]=((2*dp[i-1])%mod+(dp[i-3])%mod)%mod;\\n        }\\n        return dp[n];\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343202,
                "title": "lol",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numTilings(int n) {\\n\\t\\t\\tint arr[1001] = {0, 1, 2, 5, 11, 24, 53, 117, 258, 569, 1255, 2768, 6105, 13465, 29698, 65501, 144467, 318632, 702765, 1549997, 3418626, 7540017, 16630031, 36678688, 80897393, 178424817, 393528322, 867954037, 914332884, 222194076, 312342182, 539017241, 300228551, 912799284, 364615795, 29460134, 971719552, 308054885, 645569904, 262859346, 833773577, 313117044, 889093434, 611960431, 537037899, 963169225, 538298867, 613635626, 190440463, 919179793, 451995198, 94430852, 108041490, 668078178, 430587201, 969215892, 606509948, 643607090, 256430058, 119370057, 882347204, 21124452, 161618961, 205585119, 432294690, 26208334, 258001787, 948298264, 922804855, 103611483, 155521223, 233847294, 571306071, 298133358, 830114010, 231534077, 761201512, 352517020, 936568117, 634337732, 621192477, 178953057, 992243846, 605680155, 390313360, 772870559, 151421259, 693155878, 159182301, 469785861, 632727593, 424637480, 319060814, 270849214, 966335908, 251732616, 774314446, 514964786, 281662181, 337638801, 190242381, 662146943, 661932680, 514107734, 690362404, 42657474, 599422682, 889207761, 821072989, 241568646, 372345046, 565763074, 373094787, 118534613, 802832300, 978759380, 76053359, 954939018, 888637402, 853328156, 661595316, 211828020, 276984189, 215563687, 642955394, 562894970, 341353620, 325662627, 214220217, 769794054, 865250728, 944721666, 659237372, 183725458, 312172575, 283582515, 750890488, 813953544, 911489596, 573869666, 961692869, 834875320, 243620292, 448933446, 732742205, 709104695, 867142829, 467027849, 643160386, 153463587, 773955023, 191070418, 535604423, 845163862, 881398135, 298400679, 441965213, 765328554, 829057780, 100080759, 965490072, 760037910, 620156572, 205803202, 171644307, 963445186, 132693560, 437031427, 837508033, 807709619, 52450651, 942409335, 692528275, 437507194, 817423716, 327375693, 92258573, 1940855, 331257403, 754773379, 511487606, 354232608, 463238588, 437964775, 230162151, 923562890, 285090541, 800343233, 524249342, 333589218, 467521662, 459292659, 252174529, 971870720, 403034085, 58242692, 88356097, 579746279, 217735243, 523826583, 627399438, 472534112, 468894800, 565189031, 602912167, 674719127, 914627278, 432166709, 539052538, 992732347, 417631389, 374315309, 741362958, 900357298, 175029891, 91422733, 83202757, 341435405, 774293543, 631789836, 605015070, 984323676, 600437174, 805889411, 596102484, 792642135, 391173667, 378449811, 549541750, 490257160, 358964124, 267469991, 25197135, 409358394, 86186772, 197570679, 804499752, 695186269, 587943210, 980386165, 655958585, 899860373, 780106897, 216172365, 332205096, 444517082, 105206522, 542618140, 529753355, 164713225, 872044590, 273842521, 712398267, 296841110, 867524741, 447447735, 191736573, 250997880, 949443495, 90623549, 432244978, 813933444, 718490430, 869225831, 552385092, 823260607, 515747031, 583879147, 991018894, 497784805, 579448750, 149916380, 797617565, 174683866, 499284112, 796185782, 767055423, 33394944, 862975670, 493006749, 19408435, 901792540, 296591815, 612592065, 126976656, 550545127, 713682312, 554341273, 659227666, 32137630, 618616533, 896460725, 825059073, 268734665, 433930048, 692919162, 654572982, 743076005, 179071158, 12715291, 768506587, 716084325, 444883934, 658274448, 32633207, 510150348, 678575137, 389783474, 289717289, 258009708, 905802890, 101323055, 460655818, 827114519, 755552086, 971759983, 770634471, 296821014, 565402004, 901438472, 99697944, 764797892, 431034242, 961766428, 688330734, 807695703, 577157820, 842646367, 492988423, 563134659, 968915678, 430819765, 424774182, 818464035, 67747821, 560269824, 939003676, 945755166, 451780142, 842563953, 630883058, 713546251, 269656441, 170195933, 53938110, 377532661, 925261255, 904460613, 186453873, 298168994, 500798594, 188051054, 674271102, 849340791, 886732629, 447736346, 744813476, 376359567, 200455473, 145724415, 667808397, 536072260, 217868928, 103546246, 743164752, 704198425, 511943089, 767050923, 238300257, 988543603, 744138115, 726576480, 441696549, 627531206, 981638885, 404974305, 437479809, 856598496, 118171283, 673822375, 204243232, 526657747, 727137862, 658518949, 843695638, 414529124, 487577190, 818850011, 52229132, 592035454, 2920905, 58070942, 708177338, 419275574, 896622090, 501421504, 422118575, 740859233, 983139963, 388398487, 517656200, 18452349, 425303185, 368262563, 754977475, 935258128, 238778805, 232535078, 400328277, 39435352, 311405782, 23139834, 85715020, 482835822, 988811478, 63337962, 609511746, 207834956, 479007874, 567527487, 342889923, 164787713, 897102913, 137095735, 438979183, 775061272, 687218272, 813415720, 401892698, 491003661, 795423035, 992738761, 476481169, 748385366, 489509479, 455500120, 659385599, 808280670, 72061446, 803508491, 415297638, 902656722, 608821921, 632941473, 168539654, 945901229, 524743917, 218027481, 381956184, 288656278, 795340037, 972636251, 233928766, 263197562, 499031368, 231991495, 727180552, 953392465, 138776411, 4733367, 962859199, 64494795, 133722957, 230305106, 525105007, 183932964, 598171034, 721447068, 626827093, 851825213, 425097480, 477022046, 805869298, 36836062, 550694170, 907257631, 851351317, 253396790, 414051204, 679453718, 612304219, 638659635, 956772981, 525850167, 690359962, 337492891, 200835942, 92031839, 521556569, 243949073, 579929985, 681416532, 606782130, 793494238, 268404994, 143592111, 80678453, 429761900, 3115904, 86910261, 603582422, 210280741, 507471743, 618525901, 447332536, 402136808, 422799510, 292931549, 987999906, 398799308, 90530158, 169060215, 736919738, 564369627, 297799462, 332518655, 229406930, 756613322, 845745292, 920897507, 598408322, 42561922, 6021344, 610451010, 263463935, 532949214, 676349431, 616162790, 765274787, 206898991, 29960765, 825196317, 857291618, 744543994, 314284291, 485860193, 716264373, 746813030, 979486246, 675236851, 97286718, 174059675, 23356194, 143999106, 462057887, 947471968, 38943028, 539943943, 27359840, 93662708, 727269359, 481898551, 57459803, 842188965, 166276467, 390012737, 622214432, 410705324, 211423378, 45061181, 500827686, 213078743, 471218667, 443265013, 99608762, 670436191, 784137388, 667883531, 6203239, 796543866, 260971249, 528145737, 852835333, 966641908, 461429539, 775694404, 518030702, 497490936, 770676269, 59383226, 616257388, 3191031, 65765288, 747787964, 498766952, 63299185, 874386334, 247539606, 558378397, 991143121, 229825834, 18030058, 27203230, 284232294, 586494646, 200192515, 684617324, 955729287, 111651075, 907919474, 771568221, 654787510, 217494480, 206557174, 67901851, 353298182, 913153538, 894208920, 141716008, 196585547, 287380007, 716476022, 629537584, 546455168, 809386351, 248310272, 43075705, 895537761, 39385780, 121847265, 139232284, 317850348, 757547961, 654328199, 626506739, 10561425, 675451049, 977408830, 965379078, 606209191, 189827198, 345033467, 296276118, 782379434, 909792328, 115860760, 14100947, 937994222, 991849197, 997799334, 933592876, 859034935, 715869190, 365331242, 589697412, 895264007, 155859242, 901415896, 698095785, 552050805, 5517492, 709130769, 970312336, 946142157, 601415069, 173142460, 292427070, 186269202, 545680864, 383788791, 953846784, 453374418, 290537620, 534922017, 523218445, 336974503, 208871016, 940960477, 218895443, 646661902, 234284267, 687463977, 21589842, 277463951, 242391872, 506373586, 290211116, 822814104, 152001780, 594214676, 11243442, 174488664, 943192004, 897627443, 969743543, 882679076, 662985581, 295714691, 474108451, 611202476, 518119636, 510347716, 631897901, 781915431, 74178564, 780255029, 342425475, 759029514, 298314043, 939053561, 637136622, 572587280, 84228107, 805592836, 183772938, 451773983, 709140795, 602054521, 655883018, 20906817, 643868155, 943619321, 908145452, 460159045, 863937404, 636020246, 732199530, 328336450, 292693139, 317585801, 963508052, 219709229, 757004259, 477516556, 174742334, 106488920, 690494396, 555731119, 217951151, 126396691, 808524501, 835000146, 796396976, 401318439, 637637017, 71670996, 544660431, 726957872, 525586733, 595833890, 918625645, 362838009, 321509901, 561645440, 486128882, 293767658, 149180749, 784490380, 862748411, 874677564, 533845494, 930439392, 735556334, 4958148, 940355688, 616267696, 237493533, 415342747, 446953183, 131399892, 678142531, 803238238, 737876361, 153895239, 111028709, 959933779, 73762783, 258554275, 477042322, 27847420, 314249115, 105540545, 238928510, 792106135, 689752808, 618434119, 28974359, 747701526, 113837157, 256648673, 260998865, 635834887, 528318440, 317635738, 271106356, 70531145, 458698028, 188502405, 447535955, 353769931, 896042267, 239620475, 833010881, 562064015, 363748498, 560507870, 683079748, 729907987, 20323830, 723727408, 177362789, 375049408, 473826217, 125015216, 625079840, 723985890, 572986989, 771053811, 266093498, 105173978, 981401767, 228897018, 562968014, 107337781, 443572580, 450113167, 7564108, 458700796, 367514752, 742593612, 943888013, 255290764, 253175133, 450238272, 155767301, 564709735, 579657735, 315082764, 194875256, 969408247, 253899244, 702673744, 374755721, 3410679, 709495102, 793745918, 590902508, 891300111, 576346126, 743594753, 378489603, 333325325, 410245396, 198980388, 731286101, 872817591, 944615563, 620517213, 113852003, 172319562, 965156337, 44164663, 260648888, 486454106, 17072868, 294794624, 76043347, 169159562, 633113748, 342270836, 853701234, 340516202, 23303233, 900307700, 141131588, 305566409, 511440511, 164012603, 633591615, 778623734, 721260064, 76111729, 930847192, 582954434, 242020590, 414888365, 412731157, 67482897, 549854159, 512439468, 92361826, 734577811, 981595083, 55551978, 845681767, 672958603, 401469177, 648620114, 970198824, 341866811, 332353729, 634906275, 611679354, 555712430, 746331128, 104341596, 764395622, 275122358, 654586312, 73568232, 422258822, 499103949, 71776123, 565811068, 630726078, 333228272, 232267605, 95261281, 523750834, 279769266, 654799813, 833350453, 946470165, 547740129, 928830704, 804131559, 156003233, 240837163, 285805878, 727614989, 696067134, 677940139, 83495253, 863057640, 404055405, 891606063, 646269752, 696594902, 284795853, 215861451, 128317797, 541431447, 298724338, 725766473, 992964386, 284653096, 295072658, 583109695, 450872479, 196817609, 976744913, 404362291, 5542184, 987829281, 380020839, 765583862, 518996991, 418014814, 601613483, 722223950, 862462707, 326538883, 375301709, 613066118, 552671112, 480643926, 574353963, 701379031, 883401981, 341157911, 383694846, 650791666, 642741236, 669177311, 989146281, 621033784, 911244872, 811636011, 244305792, 399856449, 611348902, 467003589, 333863620, 279076135, 25155852, 384175324, 47426776, 120009404, 624194132, 295815033, 711639470, 47473058, 390761149, 493161761, 33796573, 458354295, 409870344, 853537261, 165428803, 740727950, 334993147, 835415097, 411558130, 158109400, 151633890, 714825910, 587761213, 327156309, 369138521, 326038248, 979232805};\\n\\t\\t\\treturn arr[n];\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numTilings(int n) {\\n\\t\\t\\tint arr[1001] = {0, 1, 2, 5, 11, 24, 53, 117, 258, 569, 1255, 2768, 6105, 13465, 29698, 65501, 144467, 318632, 702765, 1549997, 3418626, 7540017, 16630031, 36678688, 80897393, 178424817, 393528322, 867954037, 914332884, 222194076, 312342182, 539017241, 300228551, 912799284, 364615795, 29460134, 971719552, 308054885, 645569904, 262859346, 833773577, 313117044, 889093434, 611960431, 537037899, 963169225, 538298867, 613635626, 190440463, 919179793, 451995198, 94430852, 108041490, 668078178, 430587201, 969215892, 606509948, 643607090, 256430058, 119370057, 882347204, 21124452, 161618961, 205585119, 432294690, 26208334, 258001787, 948298264, 922804855, 103611483, 155521223, 233847294, 571306071, 298133358, 830114010, 231534077, 761201512, 352517020, 936568117, 634337732, 621192477, 178953057, 992243846, 605680155, 390313360, 772870559, 151421259, 693155878, 159182301, 469785861, 632727593, 424637480, 319060814, 270849214, 966335908, 251732616, 774314446, 514964786, 281662181, 337638801, 190242381, 662146943, 661932680, 514107734, 690362404, 42657474, 599422682, 889207761, 821072989, 241568646, 372345046, 565763074, 373094787, 118534613, 802832300, 978759380, 76053359, 954939018, 888637402, 853328156, 661595316, 211828020, 276984189, 215563687, 642955394, 562894970, 341353620, 325662627, 214220217, 769794054, 865250728, 944721666, 659237372, 183725458, 312172575, 283582515, 750890488, 813953544, 911489596, 573869666, 961692869, 834875320, 243620292, 448933446, 732742205, 709104695, 867142829, 467027849, 643160386, 153463587, 773955023, 191070418, 535604423, 845163862, 881398135, 298400679, 441965213, 765328554, 829057780, 100080759, 965490072, 760037910, 620156572, 205803202, 171644307, 963445186, 132693560, 437031427, 837508033, 807709619, 52450651, 942409335, 692528275, 437507194, 817423716, 327375693, 92258573, 1940855, 331257403, 754773379, 511487606, 354232608, 463238588, 437964775, 230162151, 923562890, 285090541, 800343233, 524249342, 333589218, 467521662, 459292659, 252174529, 971870720, 403034085, 58242692, 88356097, 579746279, 217735243, 523826583, 627399438, 472534112, 468894800, 565189031, 602912167, 674719127, 914627278, 432166709, 539052538, 992732347, 417631389, 374315309, 741362958, 900357298, 175029891, 91422733, 83202757, 341435405, 774293543, 631789836, 605015070, 984323676, 600437174, 805889411, 596102484, 792642135, 391173667, 378449811, 549541750, 490257160, 358964124, 267469991, 25197135, 409358394, 86186772, 197570679, 804499752, 695186269, 587943210, 980386165, 655958585, 899860373, 780106897, 216172365, 332205096, 444517082, 105206522, 542618140, 529753355, 164713225, 872044590, 273842521, 712398267, 296841110, 867524741, 447447735, 191736573, 250997880, 949443495, 90623549, 432244978, 813933444, 718490430, 869225831, 552385092, 823260607, 515747031, 583879147, 991018894, 497784805, 579448750, 149916380, 797617565, 174683866, 499284112, 796185782, 767055423, 33394944, 862975670, 493006749, 19408435, 901792540, 296591815, 612592065, 126976656, 550545127, 713682312, 554341273, 659227666, 32137630, 618616533, 896460725, 825059073, 268734665, 433930048, 692919162, 654572982, 743076005, 179071158, 12715291, 768506587, 716084325, 444883934, 658274448, 32633207, 510150348, 678575137, 389783474, 289717289, 258009708, 905802890, 101323055, 460655818, 827114519, 755552086, 971759983, 770634471, 296821014, 565402004, 901438472, 99697944, 764797892, 431034242, 961766428, 688330734, 807695703, 577157820, 842646367, 492988423, 563134659, 968915678, 430819765, 424774182, 818464035, 67747821, 560269824, 939003676, 945755166, 451780142, 842563953, 630883058, 713546251, 269656441, 170195933, 53938110, 377532661, 925261255, 904460613, 186453873, 298168994, 500798594, 188051054, 674271102, 849340791, 886732629, 447736346, 744813476, 376359567, 200455473, 145724415, 667808397, 536072260, 217868928, 103546246, 743164752, 704198425, 511943089, 767050923, 238300257, 988543603, 744138115, 726576480, 441696549, 627531206, 981638885, 404974305, 437479809, 856598496, 118171283, 673822375, 204243232, 526657747, 727137862, 658518949, 843695638, 414529124, 487577190, 818850011, 52229132, 592035454, 2920905, 58070942, 708177338, 419275574, 896622090, 501421504, 422118575, 740859233, 983139963, 388398487, 517656200, 18452349, 425303185, 368262563, 754977475, 935258128, 238778805, 232535078, 400328277, 39435352, 311405782, 23139834, 85715020, 482835822, 988811478, 63337962, 609511746, 207834956, 479007874, 567527487, 342889923, 164787713, 897102913, 137095735, 438979183, 775061272, 687218272, 813415720, 401892698, 491003661, 795423035, 992738761, 476481169, 748385366, 489509479, 455500120, 659385599, 808280670, 72061446, 803508491, 415297638, 902656722, 608821921, 632941473, 168539654, 945901229, 524743917, 218027481, 381956184, 288656278, 795340037, 972636251, 233928766, 263197562, 499031368, 231991495, 727180552, 953392465, 138776411, 4733367, 962859199, 64494795, 133722957, 230305106, 525105007, 183932964, 598171034, 721447068, 626827093, 851825213, 425097480, 477022046, 805869298, 36836062, 550694170, 907257631, 851351317, 253396790, 414051204, 679453718, 612304219, 638659635, 956772981, 525850167, 690359962, 337492891, 200835942, 92031839, 521556569, 243949073, 579929985, 681416532, 606782130, 793494238, 268404994, 143592111, 80678453, 429761900, 3115904, 86910261, 603582422, 210280741, 507471743, 618525901, 447332536, 402136808, 422799510, 292931549, 987999906, 398799308, 90530158, 169060215, 736919738, 564369627, 297799462, 332518655, 229406930, 756613322, 845745292, 920897507, 598408322, 42561922, 6021344, 610451010, 263463935, 532949214, 676349431, 616162790, 765274787, 206898991, 29960765, 825196317, 857291618, 744543994, 314284291, 485860193, 716264373, 746813030, 979486246, 675236851, 97286718, 174059675, 23356194, 143999106, 462057887, 947471968, 38943028, 539943943, 27359840, 93662708, 727269359, 481898551, 57459803, 842188965, 166276467, 390012737, 622214432, 410705324, 211423378, 45061181, 500827686, 213078743, 471218667, 443265013, 99608762, 670436191, 784137388, 667883531, 6203239, 796543866, 260971249, 528145737, 852835333, 966641908, 461429539, 775694404, 518030702, 497490936, 770676269, 59383226, 616257388, 3191031, 65765288, 747787964, 498766952, 63299185, 874386334, 247539606, 558378397, 991143121, 229825834, 18030058, 27203230, 284232294, 586494646, 200192515, 684617324, 955729287, 111651075, 907919474, 771568221, 654787510, 217494480, 206557174, 67901851, 353298182, 913153538, 894208920, 141716008, 196585547, 287380007, 716476022, 629537584, 546455168, 809386351, 248310272, 43075705, 895537761, 39385780, 121847265, 139232284, 317850348, 757547961, 654328199, 626506739, 10561425, 675451049, 977408830, 965379078, 606209191, 189827198, 345033467, 296276118, 782379434, 909792328, 115860760, 14100947, 937994222, 991849197, 997799334, 933592876, 859034935, 715869190, 365331242, 589697412, 895264007, 155859242, 901415896, 698095785, 552050805, 5517492, 709130769, 970312336, 946142157, 601415069, 173142460, 292427070, 186269202, 545680864, 383788791, 953846784, 453374418, 290537620, 534922017, 523218445, 336974503, 208871016, 940960477, 218895443, 646661902, 234284267, 687463977, 21589842, 277463951, 242391872, 506373586, 290211116, 822814104, 152001780, 594214676, 11243442, 174488664, 943192004, 897627443, 969743543, 882679076, 662985581, 295714691, 474108451, 611202476, 518119636, 510347716, 631897901, 781915431, 74178564, 780255029, 342425475, 759029514, 298314043, 939053561, 637136622, 572587280, 84228107, 805592836, 183772938, 451773983, 709140795, 602054521, 655883018, 20906817, 643868155, 943619321, 908145452, 460159045, 863937404, 636020246, 732199530, 328336450, 292693139, 317585801, 963508052, 219709229, 757004259, 477516556, 174742334, 106488920, 690494396, 555731119, 217951151, 126396691, 808524501, 835000146, 796396976, 401318439, 637637017, 71670996, 544660431, 726957872, 525586733, 595833890, 918625645, 362838009, 321509901, 561645440, 486128882, 293767658, 149180749, 784490380, 862748411, 874677564, 533845494, 930439392, 735556334, 4958148, 940355688, 616267696, 237493533, 415342747, 446953183, 131399892, 678142531, 803238238, 737876361, 153895239, 111028709, 959933779, 73762783, 258554275, 477042322, 27847420, 314249115, 105540545, 238928510, 792106135, 689752808, 618434119, 28974359, 747701526, 113837157, 256648673, 260998865, 635834887, 528318440, 317635738, 271106356, 70531145, 458698028, 188502405, 447535955, 353769931, 896042267, 239620475, 833010881, 562064015, 363748498, 560507870, 683079748, 729907987, 20323830, 723727408, 177362789, 375049408, 473826217, 125015216, 625079840, 723985890, 572986989, 771053811, 266093498, 105173978, 981401767, 228897018, 562968014, 107337781, 443572580, 450113167, 7564108, 458700796, 367514752, 742593612, 943888013, 255290764, 253175133, 450238272, 155767301, 564709735, 579657735, 315082764, 194875256, 969408247, 253899244, 702673744, 374755721, 3410679, 709495102, 793745918, 590902508, 891300111, 576346126, 743594753, 378489603, 333325325, 410245396, 198980388, 731286101, 872817591, 944615563, 620517213, 113852003, 172319562, 965156337, 44164663, 260648888, 486454106, 17072868, 294794624, 76043347, 169159562, 633113748, 342270836, 853701234, 340516202, 23303233, 900307700, 141131588, 305566409, 511440511, 164012603, 633591615, 778623734, 721260064, 76111729, 930847192, 582954434, 242020590, 414888365, 412731157, 67482897, 549854159, 512439468, 92361826, 734577811, 981595083, 55551978, 845681767, 672958603, 401469177, 648620114, 970198824, 341866811, 332353729, 634906275, 611679354, 555712430, 746331128, 104341596, 764395622, 275122358, 654586312, 73568232, 422258822, 499103949, 71776123, 565811068, 630726078, 333228272, 232267605, 95261281, 523750834, 279769266, 654799813, 833350453, 946470165, 547740129, 928830704, 804131559, 156003233, 240837163, 285805878, 727614989, 696067134, 677940139, 83495253, 863057640, 404055405, 891606063, 646269752, 696594902, 284795853, 215861451, 128317797, 541431447, 298724338, 725766473, 992964386, 284653096, 295072658, 583109695, 450872479, 196817609, 976744913, 404362291, 5542184, 987829281, 380020839, 765583862, 518996991, 418014814, 601613483, 722223950, 862462707, 326538883, 375301709, 613066118, 552671112, 480643926, 574353963, 701379031, 883401981, 341157911, 383694846, 650791666, 642741236, 669177311, 989146281, 621033784, 911244872, 811636011, 244305792, 399856449, 611348902, 467003589, 333863620, 279076135, 25155852, 384175324, 47426776, 120009404, 624194132, 295815033, 711639470, 47473058, 390761149, 493161761, 33796573, 458354295, 409870344, 853537261, 165428803, 740727950, 334993147, 835415097, 411558130, 158109400, 151633890, 714825910, 587761213, 327156309, 369138521, 326038248, 979232805}",
                "codeTag": "Java"
            },
            {
                "id": 1150428,
                "title": "python3-memoization",
                "content": "Use `i` and `j` to record the next tile to fill for row 0 and row 1, respectively.\\n\\n```python\\nclass Solution:\\n    def numTilings(self, N: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == j == N:\\n                return 1\\n            if i > N or j > N:\\n                return 0\\n            if i == j:\\n                return dp(i+1, j+1) + dp(i+2, j+2) + dp(i+1, j+2) + dp(i+2, j+1)\\n            elif i > j:\\n                return dp(i, j+2) + dp(i+1, j+2)\\n            else:\\n                return dp(i+2, j) + dp(i+2, j+1)\\n        \\n        return dp(0, 0) % MOD\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numTilings(self, N: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == j == N:\\n                return 1\\n            if i > N or j > N:\\n                return 0\\n            if i == j:\\n                return dp(i+1, j+1) + dp(i+2, j+2) + dp(i+1, j+2) + dp(i+2, j+1)\\n            elif i > j:\\n                return dp(i, j+2) + dp(i+1, j+2)\\n            else:\\n                return dp(i+2, j) + dp(i+2, j+1)\\n        \\n        return dp(0, 0) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088361,
                "title": "a-proof-and-explanation-for-the-problem",
                "content": "Let us construct a dp[N+1][3] , such that dp[i][0] = count of ways such that at ith position both the rows are filled , dp[i][1] = number of ways such that only lower row is filled , and dp[i][2] = number of ways sucht that only upper row is filled at i. \\n\\nNow, the base cases can be \\n```\\n\\t\\tdp[1][0] = 1;  // vertical\\n        dp[1][1] = 0; // not possible\\n        dp[1][2] = 0; // not possible \\n        dp[2][0] = 2; // two vertical or two horizontal \\n        dp[2][1] = 1; // L\\n        dp[2][2] = 1; // inverted L\\n\\t\\n```\\nNow, we can calculate the next states using the following recurssions :\\n```\\ndp[i][0] = (dp[i-1][0] + dp[i-2][0] + dp[i-1][1] + dp[i-1][2]); \\n(vertical + two horizontal + L  + inverted Ll)\\n            \\ndp[i][1] = (dp[i-2][0] + dp[i-1][2]);\\n(L + horizontal)\\n            \\ndp[i][2] = (dp[i-2][0] + dp[i-1][1]);\\n(inverted L + horizontal )\\n```\\n\\nAlso, these equations can be reduced to \\n```\\ndp[i] = 2*dp[i-1] + dp[i-3]\\n```\\nThe complete approach \\ndp[i][0] is replaced by dp[i] \\n```\\ndp[i][0] = (dp[i-1][0] + dp[i-2][0] + dp[i-1][1] + dp[i-1][2]);      (1) \\n            \\ndp[i][1] = (dp[i-2][0] + dp[i-1][2]);     (2)\\n            \\ndp[i][2] = (dp[i-2][0] + dp[i-1][1]);      (3)\\n\\n```\\n```\\nfrom 2 and 3\\n\\ndp[i-1][1] = dp[i-3] + dp[i-2][2]\\n\\ndp[i-1][2] = dp[i-3] + dp[i-2][1]\\n\\ndp[i-1][1] + dp[i-1][2] = 2*dp[i-3] + (dp[i-2][2] + dp[i-2][1]);\\n\\n(dp[i-1][1] + dp[i-1][2]) - (dp[i-2][2] + dp[i-2][1]) = 2*dp[i-3];\\n```\\n```\\nfrom 1\\n\\ndp[i-1][0] = (dp[i-2][0] + dp[i-3][0] + dp[i-2][1] + dp[i-2][2]); ---2\\n\\n\\ndp[i] - dp[i-1] = dp[i-1] - dp[i-3] + dp[i-1][1] + dp[i-1][2]   - dp[i-2][1] - dp[i-2][2]\\n\\ndp[i] - dp[i-1] = dp[i-1] - dp[i-3] + 2*dp[i-3];\\n\\ndp[i] = 2*dp[i-1] + dp[i-3] \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\t\\tdp[1][0] = 1;  // vertical\\n        dp[1][1] = 0; // not possible\\n        dp[1][2] = 0; // not possible \\n        dp[2][0] = 2; // two vertical or two horizontal \\n        dp[2][1] = 1; // L\\n        dp[2][2] = 1; // inverted L\\n\\t\\n```\n```\\ndp[i][0] = (dp[i-1][0] + dp[i-2][0] + dp[i-1][1] + dp[i-1][2]); \\n(vertical + two horizontal + L  + inverted Ll)\\n            \\ndp[i][1] = (dp[i-2][0] + dp[i-1][2]);\\n(L + horizontal)\\n            \\ndp[i][2] = (dp[i-2][0] + dp[i-1][1]);\\n(inverted L + horizontal )\\n```\n```\\ndp[i] = 2*dp[i-1] + dp[i-3]\\n```\n```\\ndp[i][0] = (dp[i-1][0] + dp[i-2][0] + dp[i-1][1] + dp[i-1][2]);      (1) \\n            \\ndp[i][1] = (dp[i-2][0] + dp[i-1][2]);     (2)\\n            \\ndp[i][2] = (dp[i-2][0] + dp[i-1][1]);      (3)\\n\\n```\n```\\nfrom 2 and 3\\n\\ndp[i-1][1] = dp[i-3] + dp[i-2][2]\\n\\ndp[i-1][2] = dp[i-3] + dp[i-2][1]\\n\\ndp[i-1][1] + dp[i-1][2] = 2*dp[i-3] + (dp[i-2][2] + dp[i-2][1]);\\n\\n(dp[i-1][1] + dp[i-1][2]) - (dp[i-2][2] + dp[i-2][1]) = 2*dp[i-3];\\n```\n```\\nfrom 1\\n\\ndp[i-1][0] = (dp[i-2][0] + dp[i-3][0] + dp[i-2][1] + dp[i-2][2]); ---2\\n\\n\\ndp[i] - dp[i-1] = dp[i-1] - dp[i-3] + dp[i-1][1] + dp[i-1][2]   - dp[i-2][1] - dp[i-2][2]\\n\\ndp[i] - dp[i-1] = dp[i-1] - dp[i-3] + 2*dp[i-3];\\n\\ndp[i] = 2*dp[i-1] + dp[i-3] \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059526,
                "title": "javascript-short-recursion-memoization",
                "content": "```\\nvar numTilings = function(N) {\\n  const mod = 1e9 + 7\\n  const cash = new Map([[1,1],[2,2],[3,5]])\\n  const count = (n) => {\\n    if (!cash.has(n)) cash.set(n, count(n-1)*2 + count(n-3))\\n    return cash.get(n) % mod\\n  }\\n  return count(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar numTilings = function(N) {\\n  const mod = 1e9 + 7\\n  const cash = new Map([[1,1],[2,2],[3,5]])\\n  const count = (n) => {\\n    if (!cash.has(n)) cash.set(n, count(n-1)*2 + count(n-3))\\n    return cash.get(n) % mod\\n  }\\n  return count(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 857627,
                "title": "0-ms-beats-100-learn-to-solve-all-variations-of-tiling-problem",
                "content": "concept used in my code is very well explained in this link:\\nhttps://journeywithdp.blogspot.com/2018/07/way-to-solve-tiling-problems.html\\nthis will help u to code all variations of tiling problem.\\n![IMG_20230609_203911.jpg](https://assets.leetcode.com/users/images/63eb86fd-c52c-421c-891f-61242e67b09f_1686323520.3678138.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long  f[n+3],g[n+4];\\n        f[1]=1,f[2]=2,g[1]=1,g[2]=2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            f[i]=(f[i-1]+f[i-2]+2*g[i-2])%(1000000007);\\n            g[i]=(f[i-1]+g[i-1])%(1000000007);\\n        }    \\n        return f[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long  f[n+3],g[n+4];\\n        f[1]=1,f[2]=2,g[1]=1,g[2]=2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            f[i]=(f[i-1]+f[i-2]+2*g[i-2])%(1000000007);\\n            g[i]=(f[i-1]+g[i-1])%(1000000007);\\n        }    \\n        return f[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857241,
                "title": "python-visual-explanation",
                "content": "Filling the array from left to right, where the current index is the first column that is not full, the array only has four possible states.\\n<img src=\"https://assets.leetcode.com/users/images/a9382830-233d-445e-9b9d-04f76686d9ab_1600671880.5346115.png\" width=\"80%\">\\nHere is an example of state \"0010\" when i = 3.  \\n<img src=\"https://assets.leetcode.com/users/images/4a06f63d-1351-4481-b35d-91c443dae945_1600671875.1838691.png\" width=\"50%\">\\nIn the above example, there are only two possible items that could be placed next:\\n1. a horizontal domino in the top row.\\n2. a tromino that fills the first 3 open spaces.\\n\\nSo the number of ways to fill the array will be the sum of the number of ways to fill the array after picking option 1 and the number of ways to fill the array after picking option 2.  \\n\\nEach state will have different options, for example in state \\'0000\\' we could choose:\\n1. a horizontal domino in the top row\\n2. a vertical domino\\n3. an L shaped tromino\\n4. or a backward\\'s 7 shaped tromino\\n\\nThe number of ways the array can be filled is the sum of all the ways the array can be filled for each choice.  \\n\\nThe way each choice is represented in the code is by increasing ```i``` to the first row that has an empty space and passing in the state of the four squares made up by columns ```i``` and ```i + 1```.  \\n\\n```python\\n    def numTilings(self, N: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def helper(i, state):\\n            nonlocal N\\n            \\n            if (i == N) and (state == \\'0000\\'): return 1\\n            if i >= N: return 0\\n            \\n            ways = 0\\n            if state == \\'0000\\':\\n                ways += helper(i+1, \\'0000\\') # vertical domino added\\n                ways += helper(i, \\'1100\\')   # horizontal domino top row added\\n                #ways += helper(i, \\'0011\\')  # horizontal domino bottom row added\\n                ways += helper(i+1, \\'0010\\') # tromino up added\\n                ways += helper(i+1, \\'1000\\') # tromino down added\\n                return ways\\n            \\n            if state == \\'1100\\':\\n                ways += helper(i+2, \\'0000\\') # horizontal domino bottom row added\\n                return ways\\n            \\n            if state == \\'0010\\':\\n                ways += helper(i+1, \\'1000\\') # horizontal domino top row added\\n                ways += helper(i+2, \\'0000\\') # tromino added\\n                return ways\\n            \\n            if state == \\'1000\\':\\n                ways += helper(i+1, \\'0010\\') # horizontal domino bottom row added\\n                ways += helper(i+2, \\'0000\\') # tromino added\\n                return ways\\n                \\n        return helper(0, \\'0000\\') % (10**9 + 7)\\n```\\n**Notice the line that has been commented out.**  This is because adding \\'0011\\' (horizontal domino on bottom row) and then \\'1100\\' (horizontal domino in top row) is the exact same as adding \\'1100\\' and then \\'0011\\'.  Because these two ways are not distinct we omit one of them while keeping the other.  \\n\\n**Lastly, here is a cleaned up version where the states have been renamed 0, 2, 1, 3 respectively.**\\n\\n```python\\ndef numTilings(self, N: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, state):\\n\\t\\tnonlocal N\\n\\n\\t\\tif (i == N) and (state == 0): return 1\\n\\t\\tif i >= N: return 0\\n\\n\\t\\tif state == 0:\\n\\t\\t\\treturn helper(i+1, 0) + helper(i+1, 1) + helper(i+1, 2) + helper(i, 3)\\n\\t\\telif state == 1:\\n\\t\\t\\treturn helper(i+2, 0) + helper(i+1, 2)\\n\\t\\telif state == 2:\\n\\t\\t\\treturn helper(i+2, 0) + helper(i+1, 1)\\n\\t\\telse:\\n\\t\\t\\treturn helper(i+2, 0)\\n\\n\\treturn helper(0, 0) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```i```\n```i```\n```i + 1```\n```python\\n    def numTilings(self, N: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def helper(i, state):\\n            nonlocal N\\n            \\n            if (i == N) and (state == \\'0000\\'): return 1\\n            if i >= N: return 0\\n            \\n            ways = 0\\n            if state == \\'0000\\':\\n                ways += helper(i+1, \\'0000\\') # vertical domino added\\n                ways += helper(i, \\'1100\\')   # horizontal domino top row added\\n                #ways += helper(i, \\'0011\\')  # horizontal domino bottom row added\\n                ways += helper(i+1, \\'0010\\') # tromino up added\\n                ways += helper(i+1, \\'1000\\') # tromino down added\\n                return ways\\n            \\n            if state == \\'1100\\':\\n                ways += helper(i+2, \\'0000\\') # horizontal domino bottom row added\\n                return ways\\n            \\n            if state == \\'0010\\':\\n                ways += helper(i+1, \\'1000\\') # horizontal domino top row added\\n                ways += helper(i+2, \\'0000\\') # tromino added\\n                return ways\\n            \\n            if state == \\'1000\\':\\n                ways += helper(i+1, \\'0010\\') # horizontal domino bottom row added\\n                ways += helper(i+2, \\'0000\\') # tromino added\\n                return ways\\n                \\n        return helper(0, \\'0000\\') % (10**9 + 7)\\n```\n```python\\ndef numTilings(self, N: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, state):\\n\\t\\tnonlocal N\\n\\n\\t\\tif (i == N) and (state == 0): return 1\\n\\t\\tif i >= N: return 0\\n\\n\\t\\tif state == 0:\\n\\t\\t\\treturn helper(i+1, 0) + helper(i+1, 1) + helper(i+1, 2) + helper(i, 3)\\n\\t\\telif state == 1:\\n\\t\\t\\treturn helper(i+2, 0) + helper(i+1, 2)\\n\\t\\telif state == 2:\\n\\t\\t\\treturn helper(i+2, 0) + helper(i+1, 1)\\n\\t\\telse:\\n\\t\\t\\treturn helper(i+2, 0)\\n\\n\\treturn helper(0, 0) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 792345,
                "title": "go-0ms-dp",
                "content": "```go\\nfunc numTilings(N int) int {\\n\\tif N == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\tdp1 := make([]int, N+1)\\n\\tdp2 := make([]int, N+1)\\n\\tdp1[1], dp1[2] = 1, 2\\n\\tdp2[2] = 1\\n\\tfor i := 3; i <= N; i++ {\\n\\t\\tdp1[i] = (dp1[i-2] + dp1[i-1] + dp2[i-1]*2) % 1000000007\\n\\t\\tdp2[i] = (dp1[i-2] + dp2[i-1]) % 1000000007\\n\\t}\\n\\treturn dp1[N]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc numTilings(N int) int {\\n\\tif N == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\tdp1 := make([]int, N+1)\\n\\tdp2 := make([]int, N+1)\\n\\tdp1[1], dp1[2] = 1, 2\\n\\tdp2[2] = 1\\n\\tfor i := 3; i <= N; i++ {\\n\\t\\tdp1[i] = (dp1[i-2] + dp1[i-1] + dp2[i-1]*2) % 1000000007\\n\\t\\tdp2[i] = (dp1[i-2] + dp2[i-1]) % 1000000007\\n\\t}\\n\\treturn dp1[N]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734055,
                "title": "psa-for-fast-matrix-exponentiation-o-log-n-solution-c-implementation-100-speed",
                "content": "The idea is very simple, almost every linear recurrence relation can be calculated in O(log n) time and O(1) space. This relies on a process called fast matrix exponentiation.\\nThere are many posts that explain the reasoning behind the recurrence relation. This post will not go into that. It will take the recurrence relation and implement it in O(log n) time complexity.\\nWith that out of the way, let f(N) represent the number of ways to tile a 2xN matrix. The recurrence relation is\\nf(n) = 2 * f(n-1) + f(n-3)\\nNow label the following matrix as A:\\n![image](https://assets.leetcode.com/users/images/1a4d8870-9083-4b51-a04b-62e3ee5ed34d_1594640964.948474.png)\\nand label the following matrix as B(n):\\n![image](https://assets.leetcode.com/users/images/15816a38-847c-4a8c-a656-f9e660581944_1594636909.6774485.png)\\nWhat is the product of A and B(n-1)? It is shown below.\\n![image](https://assets.leetcode.com/users/images/1988c7ee-5a2e-4efb-81f9-d0d063d997ed_1594637598.9115956.png)\\nThis product, from the recurrence relation, is clearly B(n).\\nThus, from our original recurrence, we have found a new recurrence relation:\\nB(n) = A * B(n-1).\\nWhat is the base case for this recurrence? Define B(2) as \\n![image](https://assets.leetcode.com/users/images/a32c9faf-c902-4225-bf33-ef77eec40d17_1594640490.3104377.png)\\nNow, from the recurrence,\\nB(3) = A * B(2)\\nB(4) = A * B(3) = A * A * B(2) = A^2 * B(2)\\nB(5) = A * B(4) = A^3 * B(2)\\nFrom this pattern,\\nB(n) = A^(n-2) * B(2)\\nAnd how is A^(n-2) calculated? We return to the title of this post, fast matrix exponentiation.\\nThe fact of the matter is that a constant time formula for this recurrence can also be derived. However, as in the formula for the Fibonacci sequence, it may contain irrational numbers, which cannot accurately be represented on computers. This post contains an O(log n) procedure for this exponentiation.\\nThe process is very simple. If X is a matrix, then\\nX^n = X * X^(n-1)                      if n is odd\\nX^n = (X^2)^(n/2)                     if n is even\\nThere are atmost two multiplications for each digit in the binary representation of n (which has log n digits). Thus, this algorithm takes O(log n) time.\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n==1) return 1;\\n        else if(n==2) return 2;\\n        vector<vector<long long>> a{\\n            {2, 0, 1},\\n            {1, 0, 0},\\n            {0, 1, 0}\\n        }, res{\\n            {1, 0, 0},\\n            {0, 1, 0},\\n            {0, 0, 1}\\n        }, temp(3,vector<long long>(3));\\n        n-=2;\\n        while(n){\\n            if(n&1){\\n                for(int i=0;i<3;i++){\\n                    for(int j=0;j<3;j++){\\n                        temp[i][j]=0;\\n                        for(int k=0;k<3;k++){\\n                            temp[i][j]+=(res[i][k]*a[k][j])%1000000007;\\n                        }\\n                        temp[i][j]%=1000000007;\\n                    }\\n                }\\n                res=temp;\\n                n--;\\n            }\\n            if(n){\\n                for(int i=0;i<3;i++){\\n                    for(int j=0;j<3;j++){\\n                        temp[i][j]=0;\\n                        for(int k=0;k<3;k++){\\n                            temp[i][j]+=(a[i][k]*a[k][j])%1000000007;\\n                        }\\n                        temp[i][j]%=1000000007;\\n                    }\\n                }\\n                a=temp;\\n            }\\n            n>>=1;\\n        }\\n        return (2*res[0][0]+res[0][1]+res[0][2])%1000000007;\\n    }\\n};\\n```\\nComplexity: O(log n) time\\n\\t\\t\\t\\t\\tO(1) space (only three 3x3 matrices and one variable)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n==1) return 1;\\n        else if(n==2) return 2;\\n        vector<vector<long long>> a{\\n            {2, 0, 1},\\n            {1, 0, 0},\\n            {0, 1, 0}\\n        }, res{\\n            {1, 0, 0},\\n            {0, 1, 0},\\n            {0, 0, 1}\\n        }, temp(3,vector<long long>(3));\\n        n-=2;\\n        while(n){\\n            if(n&1){\\n                for(int i=0;i<3;i++){\\n                    for(int j=0;j<3;j++){\\n                        temp[i][j]=0;\\n                        for(int k=0;k<3;k++){\\n                            temp[i][j]+=(res[i][k]*a[k][j])%1000000007;\\n                        }\\n                        temp[i][j]%=1000000007;\\n                    }\\n                }\\n                res=temp;\\n                n--;\\n            }\\n            if(n){\\n                for(int i=0;i<3;i++){\\n                    for(int j=0;j<3;j++){\\n                        temp[i][j]=0;\\n                        for(int k=0;k<3;k++){\\n                            temp[i][j]+=(a[i][k]*a[k][j])%1000000007;\\n                        }\\n                        temp[i][j]%=1000000007;\\n                    }\\n                }\\n                a=temp;\\n            }\\n            n>>=1;\\n        }\\n        return (2*res[0][0]+res[0][1]+res[0][2])%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630232,
                "title": "python-dp-super-easy-to-understand-solution",
                "content": "```py\\nclass Solution:\\n    def numTilings(self, N: int) -> int:\\n        \\'\\'\\'\\n        Let D(N) be the number of ways to fill a 2 X N rectangle with dominoes and trominos\\n        \\n        Now, the possible first moves are:\\n        \\n        1. using a vertical domino\\n          \\n            X |..........\\n            X |..........\\n           The result boils down to filling 2 X (N-1) rectangle, i.e. D(N-1)\\n          \\n        2. using a horizontal domino, since we can\\'t fill the bottom portion with a vertical domino or a tromino, \\n           it can only be filled with a horizontal domino, as such\\n           \\n            X X |.........\\n            Y Y |.........\\n           The result is then D(N-2)\\n        \\n        3 and 4. using a tromino (both orientations are equivalent)(so, just 2 times one orientation), it can be filled\\n          as:\\n        \\n            X X Y |......... \\n            X Y Y |.........  D(N-3)\\n            \\n            or \\n            \\n            X X Y Y |.......\\n            X W W Y |.......  D(N-4)\\n            \\n            or\\n            \\n            X X V V Y |.....\\n            X W W Y Y |.....  D(N-5)\\n            \\n            or so on till D(N-N)\\n        \\n        So, we can see a recursive relation:\\n          \\n          D(N) = D(N-1) + D(N-2) + 2 * (D(N-3) + D(N-4) + D(N-5) + ... + D(N-N))  where D(0) = 1, D(x < 0) = 0 (it restricts wrong solutions)\\n        \\'\\'\\'\\n        mod = 10**9 + 7\\n        \\n        DP = [1]\\n        sumsDP = [1]\\n        \\n        for i in range(1, N+1):\\n            res = 0\\n            res += DP[i-1] if i >= 1 else 0\\n            res += DP[i-2] if i >= 2 else 0\\n            res += 2*sumsDP[i-3] if i >= 3 else 0\\n            \\n            res = res % mod\\n            \\n            DP.append(res)\\n            sumsDP.append((sumsDP[-1] + res) % mod)\\n        \\n        return DP[N]\\n\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def numTilings(self, N: int) -> int:\\n        \\'\\'\\'\\n        Let D(N) be the number of ways to fill a 2 X N rectangle with dominoes and trominos\\n        \\n        Now, the possible first moves are:\\n        \\n        1. using a vertical domino\\n          \\n            X |..........\\n            X |..........\\n           The result boils down to filling 2 X (N-1) rectangle, i.e. D(N-1)\\n          \\n        2. using a horizontal domino, since we can\\'t fill the bottom portion with a vertical domino or a tromino, \\n           it can only be filled with a horizontal domino, as such\\n           \\n            X X |.........\\n            Y Y |.........\\n           The result is then D(N-2)\\n        \\n        3 and 4. using a tromino (both orientations are equivalent)(so, just 2 times one orientation), it can be filled\\n          as:\\n        \\n            X X Y |......... \\n            X Y Y |.........  D(N-3)\\n            \\n            or \\n            \\n            X X Y Y |.......\\n            X W W Y |.......  D(N-4)\\n            \\n            or\\n            \\n            X X V V Y |.....\\n            X W W Y Y |.....  D(N-5)\\n            \\n            or so on till D(N-N)\\n        \\n        So, we can see a recursive relation:\\n          \\n          D(N) = D(N-1) + D(N-2) + 2 * (D(N-3) + D(N-4) + D(N-5) + ... + D(N-N))  where D(0) = 1, D(x < 0) = 0 (it restricts wrong solutions)\\n        \\'\\'\\'\\n        mod = 10**9 + 7\\n        \\n        DP = [1]\\n        sumsDP = [1]\\n        \\n        for i in range(1, N+1):\\n            res = 0\\n            res += DP[i-1] if i >= 1 else 0\\n            res += DP[i-2] if i >= 2 else 0\\n            res += 2*sumsDP[i-3] if i >= 3 else 0\\n            \\n            res = res % mod\\n            \\n            DP.append(res)\\n            sumsDP.append((sumsDP[-1] + res) % mod)\\n        \\n        return DP[N]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560106,
                "title": "c-dp-solution-o-n-for-both-time-and-space-the-post-includes-tutorial-of-mine",
                "content": "The idea of this problem is demonstrated in the picture below, after some failure and this is the thing I finally came up.\\n![image](https://assets.leetcode.com/users/baonguyentqt/image_1585811937.png)\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        int mod=1000000007;\\n        int n=N;\\n        if (n==1)\\n            return 1;\\n        vector<vector<int>> dp(n+2,vector<int>(3));//dp[index][type]\\n        //base\\n        dp[0][0]=dp[1][0]=dp[1][1]=dp[1][2]=1;\\n        //rest\\n        for (int i=0; i<n; i++)\\n            for (int j=0; j<3; j++)\\n                switch (j){\\n                    case 0:{\\n                        dp[i+1][0]+=dp[i][0],dp[i+1][0]%=mod;\\n                        dp[i+2][0]+=dp[i][0],dp[i+2][0]%=mod;\\n                        dp[i+2][1]+=dp[i][0],dp[i+2][1]%=mod;\\n                        dp[i+2][2]+=dp[i][0],dp[i+2][2]%=mod;\\n                        break;\\n                    }\\n                    case 1:{\\n                        dp[i+1][2]+=dp[i][1],dp[i+1][2]%=mod;\\n                        dp[i+1][0]+=dp[i][1],dp[i+1][0]%=mod;\\n                        break;\\n                    }\\n                    case 2:{\\n                        dp[i+1][1]+=dp[i][2],dp[i+1][1]%=mod;\\n                        dp[i+1][0]+=dp[i][2],dp[i+1][0]%=mod;\\n                        break;\\n                    }\\n                }        \\n        return dp[n-1][0];        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        int mod=1000000007;\\n        int n=N;\\n        if (n==1)\\n            return 1;\\n        vector<vector<int>> dp(n+2,vector<int>(3));//dp[index][type]\\n        //base\\n        dp[0][0]=dp[1][0]=dp[1][1]=dp[1][2]=1;\\n        //rest\\n        for (int i=0; i<n; i++)\\n            for (int j=0; j<3; j++)\\n                switch (j){\\n                    case 0:{\\n                        dp[i+1][0]+=dp[i][0],dp[i+1][0]%=mod;\\n                        dp[i+2][0]+=dp[i][0],dp[i+2][0]%=mod;\\n                        dp[i+2][1]+=dp[i][0],dp[i+2][1]%=mod;\\n                        dp[i+2][2]+=dp[i][0],dp[i+2][2]%=mod;\\n                        break;\\n                    }\\n                    case 1:{\\n                        dp[i+1][2]+=dp[i][1],dp[i+1][2]%=mod;\\n                        dp[i+1][0]+=dp[i][1],dp[i+1][0]%=mod;\\n                        break;\\n                    }\\n                    case 2:{\\n                        dp[i+1][1]+=dp[i][2],dp[i+1][1]%=mod;\\n                        dp[i+1][0]+=dp[i][2],dp[i+1][0]%=mod;\\n                        break;\\n                    }\\n                }        \\n        return dp[n-1][0];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558372,
                "title": "python-dp-with-explanation",
                "content": "The first i layers has dp[i] ways to construct.\\n`dp[i] = dp[i-1] + dp[i-2] + 2*sum(dp[j] for j in range(i-3))`\\n\\nFirstly, let\\'s name these tiles.\\n```\\nXX  <- domino1 (abbr. D1)\\n\\nX  <- D2\\nX\\n\\nXX  <- L1\\nX\\n\\nX\\nXX <- L2\\n\\nXX <- L3\\n X\\n \\n X\\nXX  <- L4\\n```\\n\\nThink of how we get first i layers, we can derive from i-1 layers only with the last layer a D2, from i-2 layers only with the last two layers 2 D1, from i-3 layers with two ways: a. L2+L3 b. L1+L4, from i-3 layers before also with two ways (similar to i-3).\\n\\nSo we get this equation: `dp[i] = dp[i-1] + dp[i-2] + 2*sum(dp[j] for j in range(i-3))`\\n\\n```Python\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        dp = [0]*(1+n)\\n        dp[0] = 1\\n        dp[1] = 1\\n        dp[2] = 2\\n        s = 0\\n        for i in range(3, n+1):\\n            s += dp[i-3]\\n            dp[i] =dp[i-1]+dp[i-2]+s*2\\n        return dp[-1]%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nXX  <- domino1 (abbr. D1)\\n\\nX  <- D2\\nX\\n\\nXX  <- L1\\nX\\n\\nX\\nXX <- L2\\n\\nXX <- L3\\n X\\n \\n X\\nXX  <- L4\\n```\n```Python\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        dp = [0]*(1+n)\\n        dp[0] = 1\\n        dp[1] = 1\\n        dp[2] = 2\\n        s = 0\\n        for i in range(3, n+1):\\n            s += dp[i-3]\\n            dp[i] =dp[i-1]+dp[i-2]+s*2\\n        return dp[-1]%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530954,
                "title": "o-n-dp-solution-with-picture-illustration-hope-it-helps",
                "content": "```\\npackage DP;\\n\\npublic class DominoAndTrominoTiling {\\n    class Solution {\\n        public int numTilings(int N) {\\n            int kMod = 1000000007;\\n            long[][] dp = new long[N + 1][2];\\n            dp[0][0] = dp[1][0] = 1;\\n            for (int i = 2; i <= N; ++i) {\\n                dp[i][0] = (dp[i-1][0] + dp[i - 2][0] + 2 * dp[i-1][1]) % kMod;\\n                dp[i][1] = (dp[i - 2][0] + dp[i - 1][1]) % kMod;\\n            }\\n            return (int)dp[N][0];\\n        }\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/thinkanddo/image_1583528989.png)\\n",
                "solutionTags": [],
                "code": "```\\npackage DP;\\n\\npublic class DominoAndTrominoTiling {\\n    class Solution {\\n        public int numTilings(int N) {\\n            int kMod = 1000000007;\\n            long[][] dp = new long[N + 1][2];\\n            dp[0][0] = dp[1][0] = 1;\\n            for (int i = 2; i <= N; ++i) {\\n                dp[i][0] = (dp[i-1][0] + dp[i - 2][0] + 2 * dp[i-1][1]) % kMod;\\n                dp[i][1] = (dp[i - 2][0] + dp[i - 1][1]) % kMod;\\n            }\\n            return (int)dp[N][0];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382898,
                "title": "java-1ms-very-simple-dp-solution",
                "content": "dp[i][0]: both rows have length i;\\ndp[i][1]: one row has length i and the other i - 1;\\ndp[i][2]: one row has length i and the other i - 2.\\n\\n```\\n    public int numTilings(int N) {\\n        final int mod = 1000000007;\\n        int[][] dp = new int[N + 1][3];\\n        dp[0][0] = 1;\\n        dp[1][0] = 1;\\n        for (int i = 2; i <= N; i++) {\\n            dp[i][2] = dp[i - 2][0];\\n            dp[i][1] = (dp[i - 1][1] + dp[i - 2][0]) % mod;\\n            dp[i][0] = ((dp[i][2] + dp[i - 1][0]) % mod + (dp[i - 1][1] * 2) % mod) % mod;\\n        }\\n        return dp[N][0];\\n    }",
                "solutionTags": [],
                "code": "dp[i][0]: both rows have length i;\\ndp[i][1]: one row has length i and the other i - 1;\\ndp[i][2]: one row has length i and the other i - 2.\\n\\n```\\n    public int numTilings(int N) {\\n        final int mod = 1000000007;\\n        int[][] dp = new int[N + 1][3];\\n        dp[0][0] = 1;\\n        dp[1][0] = 1;\\n        for (int i = 2; i <= N; i++) {\\n            dp[i][2] = dp[i - 2][0];\\n            dp[i][1] = (dp[i - 1][1] + dp[i - 2][0]) % mod;\\n            dp[i][0] = ((dp[i][2] + dp[i - 1][0]) % mod + (dp[i - 1][1] * 2) % mod) % mod;\\n        }\\n        return dp[N][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 121121,
                "title": "clear-java-code-and-detail-about-dp-n-2-dp-n-1-dp-n-3",
                "content": "```\\nclass Solution {\\n    int MOD = (int)Math.pow(10, 9) + 7;\\n    public int numTilings(int N) {\\n        if (N == 1) return 1;\\n        if (N == 2) return 2;\\n        if (N == 3) return 5;\\n        int[] dp = new int[4];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        for (int i = 4; i <= N; ++i) {\\n                dp[i % 4] = (2 * dp[(i - 1)%4]%MOD + dp[(i - 3)%4]) % MOD;\\n        }\\n        return dp[N%4];\\n    }\\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nick_uw/image_1522163280.png)\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nick_uw/image_1522163367.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nick_uw/image_1522163614.png)\\n\\n\\nFor more details, you can visit https://www.jianshu.com/p/33f739a4ba9c\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = (int)Math.pow(10, 9) + 7;\\n    public int numTilings(int N) {\\n        if (N == 1) return 1;\\n        if (N == 2) return 2;\\n        if (N == 3) return 5;\\n        int[] dp = new int[4];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        for (int i = 4; i <= N; ++i) {\\n                dp[i % 4] = (2 * dp[(i - 1)%4]%MOD + dp[(i - 3)%4]) % MOD;\\n        }\\n        return dp[N%4];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116567,
                "title": "those-who-posted-only-code-for-the-equatio-did-you-really-originally-solve-it-during-contest",
                "content": "Many posted there solution that simply encodes the equation without identifying how they came up with the approach. It seems pretty hard to come up with the final correct equation in contest like conditions, but some people have posted code for it within minutes of contest.\n\nDid you really originally solve the problem without seeing it first anywhere? or copied code or solution from somewhere?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 116538,
                "title": "python-explanation",
                "content": "Calculate the number of tilings with both cells in the final row (even) and with only a single cell in the final row (odd).\nWe can make a new even row from the previous even row and a horizontal domino, or the even row before that and 2 vertical dominos, or the previous odd row and a tromino.\nWe can make a new odd row from the previous odd row and a vertical domino, or the i - 2 even row and a tromino in 2 possible orientations.\n\nSpace complexity can be reduced by not storing all the even and odd lists.\n```\nclass Solution(object):\n    def numTilings(self, N):\n        MOD = (10 ** 9) + 7\n\n        even = [0, 1, 2, 5]\n        odd = [0, 0, 2, 4]\n\n        for i in range(4, N + 1):\n\n            new_even = (even[i - 1] + even[i - 2] + odd[i - 1]) % MOD\n            even.append(new_even)\n\n            new_odd = (odd[i - 1] + 2 * even[i - 2]) % MOD\n            odd.append(new_odd)\n\n        return clean[N] % MOD\n\t\t\t\t",
                "solutionTags": [],
                "code": "Calculate the number of tilings with both cells in the final row (even) and with only a single cell in the final row (odd).\nclass Solution(object):\n    def numTilings(self, N):\n        MOD = (10 ** 9) + 7\n        even = [0, 1, 2, 5]\n        odd = [0, 0, 2, 4]\n        for i in range(4, N + 1):\n            new_even = (even[i - 1] + even[i - 2] + odd[i - 1]) % MOD\n            even.append(new_even)\n            new_odd = (odd[i - 1] + 2 * even[i - 2]) % MOD\n            odd.append(new_odd)",
                "codeTag": "Java"
            },
            {
                "id": 3959857,
                "title": "beginner-dp-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n int mod=1e9+7;\\n\\n   int solve(int n,vector<int>&dp){\\n\\n         if(n==1){\\n             return 1;\\n         }\\n\\n         if(n==2){\\n             return 2;\\n         }\\n\\n         if(n==3)\\n         {\\n             return 5;\\n         }\\n\\n         if(dp[n]!=-1){\\n             return dp[n];\\n         }\\n\\n\\n         return dp[n]=((solve(n-1,dp)*2)%mod+(solve(n-3,dp))%mod)%mod;\\n   }\\n    int numTilings(int n) {\\n        \\n\\n        vector<int>dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n int mod=1e9+7;\\n\\n   int solve(int n,vector<int>&dp){\\n\\n         if(n==1){\\n             return 1;\\n         }\\n\\n         if(n==2){\\n             return 2;\\n         }\\n\\n         if(n==3)\\n         {\\n             return 5;\\n         }\\n\\n         if(dp[n]!=-1){\\n             return dp[n];\\n         }\\n\\n\\n         return dp[n]=((solve(n-1,dp)*2)%mod+(solve(n-3,dp))%mod)%mod;\\n   }\\n    int numTilings(int n) {\\n        \\n\\n        vector<int>dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564770,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566271,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726442,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565446,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726085,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1725925,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576070,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726120,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1656867,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566040,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1564770,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566271,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726442,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565446,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726085,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1725925,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576070,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726120,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1656867,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566040,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726877,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1729670,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1986157,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1921355,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1802790,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1728299,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1726549,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1725975,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1570700,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1726092,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 2066958,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 2064286,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 2046687,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 2019433,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 2012378,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1813595,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1797226,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1729325,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1729040,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1727034,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            }
        ]
    },
    {
        "title": "Stone Game II",
        "question_content": "<p>Alice and Bob continue their&nbsp;games with piles of stones.&nbsp; There are a number of&nbsp;piles&nbsp;<strong>arranged in a row</strong>, and each pile has a positive integer number of stones&nbsp;<code>piles[i]</code>.&nbsp; The objective of the game is to end with the most&nbsp;stones.&nbsp;</p>\n\n<p>Alice&nbsp;and Bob take turns, with Alice starting first.&nbsp; Initially, <code>M = 1</code>.</p>\n\n<p>On each player&#39;s turn, that player&nbsp;can take <strong>all the stones</strong> in the <strong>first</strong> <code>X</code> remaining piles, where <code>1 &lt;= X &lt;= 2M</code>.&nbsp; Then, we set&nbsp;<code>M = max(M, X)</code>.</p>\n\n<p>The game continues until all the stones have been taken.</p>\n\n<p>Assuming Alice and Bob play optimally, return the maximum number of stones Alice&nbsp;can get.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> piles = [2,7,9,4,4]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong>  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it&#39;s larger. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> piles = [1,2,3,4,5,100]\n<strong>Output:</strong> 104\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= piles[i]&nbsp;&lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 345230,
                "title": "java-python-dp-solution",
                "content": "**Python:**\\n```python\\n    def stoneGameII(self, A: List[int]) -> int:\\n        N = len(A)\\n        for i in range(N - 2, -1, -1):\\n            A[i] += A[i + 1]\\n        from functools import lru_cache\\n        @lru_cache(None)\\n        def dp(i, m):\\n            if i + 2 * m >= N: return A[i]\\n            return A[i] - min(dp(i + x, max(m, x)) for x in range(1, 2 * m + 1))\\n        return dp(0, 1)\\n```\\n**Java**\\nBy @Seaview\\n```java\\n    public int stoneGameII(int[] piles) {\\n        int[] presum =  Arrays.copyOf(piles, piles.length);\\n        for (int i = presum.length - 2; i >= 0; i--) presum[i] += presum[i + 1];\\n        return dfs(presum, 1, 0, new int[piles.length][piles.length]);\\n    }\\n    private int dfs(int[] presum, int m, int p, int[][] memo) {\\n        if (p + 2 * m >= presum.length) { // last player takes all\\n            return presum[p];\\n        }\\n\\n        if (memo[p][m] > 0) return memo[p][m];\\n        int res = 0, take = 0;\\n        for (int i = 1; i <= 2 * m; i++) {\\n            // current take\\n            take = presum[p] - presum[p + i];\\n            // take max of current + what lefts from other player max take\\n            res = Math.max(res, take + presum[p + i] - dfs(presum, Math.max(i, m), p + i, memo));\\n        }\\n        memo[p][m] = res;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n    def stoneGameII(self, A: List[int]) -> int:\\n        N = len(A)\\n        for i in range(N - 2, -1, -1):\\n            A[i] += A[i + 1]\\n        from functools import lru_cache\\n        @lru_cache(None)\\n        def dp(i, m):\\n            if i + 2 * m >= N: return A[i]\\n            return A[i] - min(dp(i + x, max(m, x)) for x in range(1, 2 * m + 1))\\n        return dp(0, 1)\\n```\n```java\\n    public int stoneGameII(int[] piles) {\\n        int[] presum =  Arrays.copyOf(piles, piles.length);\\n        for (int i = presum.length - 2; i >= 0; i--) presum[i] += presum[i + 1];\\n        return dfs(presum, 1, 0, new int[piles.length][piles.length]);\\n    }\\n    private int dfs(int[] presum, int m, int p, int[][] memo) {\\n        if (p + 2 * m >= presum.length) { // last player takes all\\n            return presum[p];\\n        }\\n\\n        if (memo[p][m] > 0) return memo[p][m];\\n        int res = 0, take = 0;\\n        for (int i = 1; i <= 2 * m; i++) {\\n            // current take\\n            take = presum[p] - presum[p + i];\\n            // take max of current + what lefts from other player max take\\n            res = Math.max(res, take + presum[p + i] - dfs(presum, Math.max(i, m), p + i, memo));\\n        }\\n        memo[p][m] = res;\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 345247,
                "title": "c-dp-tabulation",
                "content": "dp[i][j] is the maximum number of stones Alex can get when starting at index i with M = j\\nsufsum[i] is the total number of stones from index i to the end\\nThe dp matrix for Lee is the same. And the stragegy for Alex is to choose an optimal X to minimize the number of stones Lee can get when starting at index (i + X) with M = max(X,j). Here we have the recurrence formula\\n```\\ndp[i][j] = max(sufsum[i] - dp[i + X][max(j, X)]) where 1<= X <= 2j;\\n```\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int length = piles.size();\\n        vector<vector<int>>dp(length + 1, vector<int>(length + 1,0));\\n        vector<int> sufsum (length + 1, 0);\\n        for (int i = length - 1; i >= 0; i--) {\\n            sufsum[i] = sufsum[i + 1] + piles[i];\\n        }\\n        for (int i = 0; i <= length; i++) {\\n            dp[i][length] = sufsum[i];\\n        }\\n        for (int i = length - 1; i >= 0; i--) {\\n            for (int j = length - 1; j >= 1; j--) {\\n                for (int X = 1; X <= 2 * j && i + X <= length; X++) {\\n                    dp[i][j] = max(dp[i][j], sufsum[i] - dp[i + X][max(j, X)]);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = max(sufsum[i] - dp[i + X][max(j, X)]) where 1<= X <= 2j;\\n```\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int length = piles.size();\\n        vector<vector<int>>dp(length + 1, vector<int>(length + 1,0));\\n        vector<int> sufsum (length + 1, 0);\\n        for (int i = length - 1; i >= 0; i--) {\\n            sufsum[i] = sufsum[i + 1] + piles[i];\\n        }\\n        for (int i = 0; i <= length; i++) {\\n            dp[i][length] = sufsum[i];\\n        }\\n        for (int i = length - 1; i >= 0; i--) {\\n            for (int j = length - 1; j >= 1; j--) {\\n                for (int X = 1; X <= 2 * j && i + X <= length; X++) {\\n                    dp[i][j] = max(dp[i][j], sufsum[i] - dp[i + X][max(j, X)]);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345528,
                "title": "c-beats-100-dp-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // Alex and Lee play optimally and each one takes stones only from the FIRST X\\n    // remaining piles! So they cannot change and take for example the last x piles.\\n    // We use DP for this problem beacuse we have many different combinations to cover!\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        if (piles.empty()) return 0;\\n        // First we calculate the sum of all piles from the end to the begging \\n        // in order to be able to retrieve quickly how many stones a player has\\n        // if for example is in position i of piles and can take 3 piles.\\n        // The answer is sums[i] - (the number of stones the other player will\\n        // take with max 6 piles (2*M))\\n        std::vector<int> sums(piles.size(), 0);\\n        sums[piles.size()-1] = piles[piles.size()-1];\\n        for (int i = piles.size()-2; i >= 0; i--) {\\n            sums[i] = sums[i+1]+piles[i];\\n        }\\n        // We create the memorization vector where dp[i][j] is the optimal choice  \\n        // in the i position of piles with max 2*j piles. \\n        std::vector<std::vector<int>> dp(piles.size(), std::vector<int>(piles.size(), 0));\\n        helper(piles, dp, sums, 0, 1);\\n        // Alex starts first and so he is at position 0 of piles and he beggins with \\n        // max 2*1 options.\\n        return dp[0][1];\\n    }\\n    int helper(vector<int>& piles, vector<vector<int>>& dp, vector<int>& sums, int i, int M) {\\n        if (i == piles.size()) return 0; // We reach the end of piles.\\n        if (2*M >= piles.size()-i) return sums[i];  // If 2*M is equal of more of the rest of the\\n                                                    // piles then the player takes them all because\\n                                                    // every player plays optimally.\\n        if (dp[i][M]) return dp[i][M];  // We might have been in this stage before with the same or \\n                                        // the other player and so we already know the optimal\\n                                        // choice from this position.\\n        \\n        int min = INT_MAX;\\n        // We calculate the more stones the next player will get for every choice of M we will make\\n        // and we choose the minimun of those!\\n        for (int j = 1; j <= 2*M; j++) {\\n            min = std::min(min, helper(piles, dp, sums, i+j, std::max(j, M)));\\n        }\\n        // The stones we will get are those in the sums position we stand minus the ones the next\\n        // player will get!\\n        return dp[i][M] = sums[i]-min;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // Alex and Lee play optimally and each one takes stones only from the FIRST X\\n    // remaining piles! So they cannot change and take for example the last x piles.\\n    // We use DP for this problem beacuse we have many different combinations to cover!\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        if (piles.empty()) return 0;\\n        // First we calculate the sum of all piles from the end to the begging \\n        // in order to be able to retrieve quickly how many stones a player has\\n        // if for example is in position i of piles and can take 3 piles.\\n        // The answer is sums[i] - (the number of stones the other player will\\n        // take with max 6 piles (2*M))\\n        std::vector<int> sums(piles.size(), 0);\\n        sums[piles.size()-1] = piles[piles.size()-1];\\n        for (int i = piles.size()-2; i >= 0; i--) {\\n            sums[i] = sums[i+1]+piles[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 345354,
                "title": "java-dp-with-memorization-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution {\\n    private int[] sums;//the sum from piles[i] to the end\\n    private int[][] hash;\\n    public int stoneGameII(int[] piles) {\\n        if(piles == null || piles.length == 0) return 0;\\n        int n = piles.length;\\n        sums = new int[n];\\n        sums[n-1] = piles[n-1];\\n        for(int i = n -2; i>=0;i--) {\\n            sums[i] = sums[i+1] + piles[i]; //the sum from piles[i] to the end\\n        }\\n        \\n        hash = new int[n][n];\\n        return helper(piles, 0, 1);\\n    }\\n    \\n    private int helper(int[] a, int i, int M) {\\n        if(i == a.length) return 0;\\n        if(2*M >= a.length - i) {\\n            return sums[i];\\n        }\\n        if(hash[i][M] != 0) return hash[i][M];\\n        int min = Integer.MAX_VALUE;//the min value the next player can get\\n        for(int x=1;x<=2*M;x++){\\n            min = Math.min(min, helper(a, i+x, Math.max(M,x)));\\n        }\\n        hash[i][M] = sums[i] - min;  //max stones = all the left stones - the min stones next player can get\\n        return hash[i][M];   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private int[] sums;//the sum from piles[i] to the end\\n    private int[][] hash;\\n    public int stoneGameII(int[] piles) {\\n        if(piles == null || piles.length == 0) return 0;\\n        int n = piles.length;\\n        sums = new int[n];\\n        sums[n-1] = piles[n-1];\\n        for(int i = n -2; i>=0;i--) {\\n            sums[i] = sums[i+1] + piles[i]; //the sum from piles[i] to the end\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 345222,
                "title": "python-minimax-dp-solution",
                "content": "The idea of minimax :\\n\\n1) If am the player 1 (whose winning sum we are trying to calculate), then I recurse on all possibilities and get the max.\\n2) If am the player 2 (the opponent), then I try to minimize what P1 gets, and since we are not interested in what score P2 gets, we only calculate the min(all P1 next moves) and dont include the score P2 gets.\\n\\nThanks to @douzigege for his comment which explains the minimax scenario specifically for this problem. \\n\\n*if player == 1st player, \\n        gain = first x piles + minimax(..., 2nd player),  where the gain is maximized\\nif player == 2nd player,\\n        gain =             0 + minimax(..., 1st player),  where the gain is minimized because the 2nd player tries to maximize his***\\n\\t\\t\\nThanks\\t\\t\\n```\\ndef stoneGameII(self, a: List[int]) -> int:\\n        @lru_cache(maxsize=None)\\n        def minimax(st, m, player):\\n            if st >= len(a): return 0\\n            if player:\\n                return max([sum(a[st:st+x]) + minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\\n            else:\\n                return min([minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\\n        return minimax(0, 1, 1)        \\n```",
                "solutionTags": [],
                "code": "```\\ndef stoneGameII(self, a: List[int]) -> int:\\n        @lru_cache(maxsize=None)\\n        def minimax(st, m, player):\\n            if st >= len(a): return 0\\n            if player:\\n                return max([sum(a[st:st+x]) + minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\\n            else:\\n                return min([minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\\n        return minimax(0, 1, 1)        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3563547,
                "title": "image-explanation-recursion-tree-recursion-memo-bottom-up-suffix-sums-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Stone Game II` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/2441a610-e666-470f-9e6e-bf978fd40c43_1685070892.2972043.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/997041e7-0b32-4905-9f3d-39fbeb5a2069_1685070340.6622007.png)\\n![image.png](https://assets.leetcode.com/users/images/961469ca-614f-4466-8bc9-3f405b2ac5bb_1685070346.9711962.png)\\n![image.png](https://assets.leetcode.com/users/images/8e5f72aa-04e6-4840-a224-841d39d3deff_1685070358.8242962.png)\\n![image.png](https://assets.leetcode.com/users/images/992cd2c5-f08c-4d30-885d-7ef705048e4e_1685070367.2016802.png)\\n![image.png](https://assets.leetcode.com/users/images/d39de152-4352-4be5-8477-c97fa75574a9_1685070374.445438.png)\\n![image.png](https://assets.leetcode.com/users/images/f290a34b-3357-4438-b97e-cab0bb661a87_1685070380.5108848.png)\\n![image.png](https://assets.leetcode.com/users/images/cb31faba-865d-45b6-8fb9-5f7a19d4c481_1685070391.289231.png)\\n![image.png](https://assets.leetcode.com/users/images/ff02665f-704c-4d01-b983-bb7e421e591a_1685070399.9461343.png)\\n![image.png](https://assets.leetcode.com/users/images/cc415b74-ccaf-4b3f-992a-177e9a544183_1685070410.030018.png)\\n![image.png](https://assets.leetcode.com/users/images/6cf2ca4e-ec1b-4e86-962d-06e9d1225566_1685070417.6519198.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int helper(vector<int>& piles, vector<vector<int>>& dp, const vector<int>& suffixSum, int i, int M) {\\n        if (i == piles.size()) return 0; \\n        if (i + 2 * M >= piles.size()) return suffixSum[i]; \\n        if (dp[i][M] != 0) return dp[i][M];\\n        int result = 0;\\n        for (int x = 1; x <= 2 * M; ++x) {\\n            result = max(result, suffixSum[i] - helper(piles, dp, suffixSum, i + x, max(M, x)));\\n        }\\n        dp[i][M] = result;\\n        return result;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        if (piles.empty()) return 0;\\n        vector<vector<int>> dp(piles.size(), std::vector<int>(piles.size(), 0));\\n        vector<int> suffixSum(piles.size());\\n        suffixSum[suffixSum.size() - 1] = piles[piles.size() - 1];\\n        for (int i = piles.size() - 2; i >= 0; --i) suffixSum[i] = piles[i] + suffixSum[i + 1];\\n        return helper(piles, dp, suffixSum, 0, 1);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int helper(int[] piles, int[][] dp, int[] suffixSum, int i, int M) {\\n        if (i == piles.length) return 0;\\n        if (i + 2 * M >= piles.length) return suffixSum[i];\\n\\n        if (dp[i][M] != 0) return dp[i][M];\\n\\n        int result = 0;\\n        for (int x = 1; x <= 2 * M; ++x) {\\n            result = Math.max(result, suffixSum[i] - helper(piles, dp, suffixSum, i + x, Math.max(M, x)));\\n        }\\n\\n        dp[i][M] = result;\\n        return result;\\n    }\\n\\n    public int stoneGameII(int[] piles) {\\n        if (piles.length == 0) return 0;\\n        int[][] dp = new int[piles.length][piles.length];\\n\\n        int[] suffixSum = new int[piles.length];\\n        suffixSum[suffixSum.length - 1] = piles[piles.length - 1];\\n        for (int i = piles.length - 2; i >= 0; --i) suffixSum[i] = piles[i] + suffixSum[i + 1];\\n\\n        return helper(piles, dp, suffixSum, 0, 1);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def helper(self, piles, dp, suffixSum, i, M):\\n        if i == len(piles):\\n            return 0\\n        if i + 2 * M >= len(piles):\\n            return suffixSum[i]\\n\\n        if dp[i][M] != 0:\\n            return dp[i][M]\\n\\n        result = 0\\n        for x in range(1, 2 * M + 1):\\n            result = max(result, suffixSum[i] - self.helper(piles, dp, suffixSum, i + x, max(M, x)))\\n\\n        dp[i][M] = result\\n        return result\\n\\n    def stoneGameII(self, piles):\\n        if not piles:\\n            return 0\\n        dp = [[0] * len(piles) for _ in range(len(piles))]\\n\\n        suffixSum = [0] * len(piles)\\n        suffixSum[-1] = piles[-1]\\n        for i in range(len(piles) - 2, -1, -1):\\n            suffixSum[i] = piles[i] + suffixSum[i + 1]\\n\\n        return self.helper(piles, dp, suffixSum, 0, 1)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int helper(vector<int>& piles, vector<vector<int>>& dp, const vector<int>& suffixSum, int i, int M) {\\n        if (i == piles.size()) return 0; \\n        if (i + 2 * M >= piles.size()) return suffixSum[i]; \\n        if (dp[i][M] != 0) return dp[i][M];\\n        int result = 0;\\n        for (int x = 1; x <= 2 * M; ++x) {\\n            result = max(result, suffixSum[i] - helper(piles, dp, suffixSum, i + x, max(M, x)));\\n        }\\n        dp[i][M] = result;\\n        return result;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        if (piles.empty()) return 0;\\n        vector<vector<int>> dp(piles.size(), std::vector<int>(piles.size(), 0));\\n        vector<int> suffixSum(piles.size());\\n        suffixSum[suffixSum.size() - 1] = piles[piles.size() - 1];\\n        for (int i = piles.size() - 2; i >= 0; --i) suffixSum[i] = piles[i] + suffixSum[i + 1];\\n        return helper(piles, dp, suffixSum, 0, 1);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int helper(int[] piles, int[][] dp, int[] suffixSum, int i, int M) {\\n        if (i == piles.length) return 0;\\n        if (i + 2 * M >= piles.length) return suffixSum[i];\\n\\n        if (dp[i][M] != 0) return dp[i][M];\\n\\n        int result = 0;\\n        for (int x = 1; x <= 2 * M; ++x) {\\n            result = Math.max(result, suffixSum[i] - helper(piles, dp, suffixSum, i + x, Math.max(M, x)));\\n        }\\n\\n        dp[i][M] = result;\\n        return result;\\n    }\\n\\n    public int stoneGameII(int[] piles) {\\n        if (piles.length == 0) return 0;\\n        int[][] dp = new int[piles.length][piles.length];\\n\\n        int[] suffixSum = new int[piles.length];\\n        suffixSum[suffixSum.length - 1] = piles[piles.length - 1];\\n        for (int i = piles.length - 2; i >= 0; --i) suffixSum[i] = piles[i] + suffixSum[i + 1];\\n\\n        return helper(piles, dp, suffixSum, 0, 1);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def helper(self, piles, dp, suffixSum, i, M):\\n        if i == len(piles):\\n            return 0\\n        if i + 2 * M >= len(piles):\\n            return suffixSum[i]\\n\\n        if dp[i][M] != 0:\\n            return dp[i][M]\\n\\n        result = 0\\n        for x in range(1, 2 * M + 1):\\n            result = max(result, suffixSum[i] - self.helper(piles, dp, suffixSum, i + x, max(M, x)))\\n\\n        dp[i][M] = result\\n        return result\\n\\n    def stoneGameII(self, piles):\\n        if not piles:\\n            return 0\\n        dp = [[0] * len(piles) for _ in range(len(piles))]\\n\\n        suffixSum = [0] * len(piles)\\n        suffixSum[-1] = piles[-1]\\n        for i in range(len(piles) - 2, -1, -1):\\n            suffixSum[i] = piles[i] + suffixSum[i + 1]\\n\\n        return self.helper(piles, dp, suffixSum, 0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434340,
                "title": "recursive-bruteforce-recursive-dp-two-state-recursive-dp-single-state-and-iterative-dp-solutions",
                "content": "Recursive Bruteforce.\\n```\\n// This solution will give TLE.\\nclass Solution {\\npublic:\\n    int rec(int idx, int M, vector<int> &piles, int turn){\\n        if(idx >= piles.size()) return 0;\\n        \\n        if(turn){\\n            int alexStones = INT_MAX;\\n            for(int i = 0; i < 2 * M && idx + i < piles.size(); i++){\\n                alexStones = min(alexStones, rec(idx + i + 1, max(M, i + 1), piles, !turn));\\n            }\\n            return alexStones;\\n        }else{\\n            int alexStones = 0, temp = 0;\\n            for(int i = 0; i < 2 * M && idx + i < piles.size(); i++){\\n                temp += piles[idx + i];\\n                alexStones = max(alexStones, temp + rec(idx + i + 1, max(M, i + 1), piles, !turn));\\n            }\\n            return alexStones;\\n        }\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        // vector<vector<int> > \\n        // int pilesLength = piles.size();\\n        return rec(0, 1, piles, 0);        \\n    }\\n};\\n```\\nRecursive DP Two state.\\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &piles, int idx, int M, int noOfPiles, int turn, vector<vector<vector<int> > > &dp){\\n        if(idx >= noOfPiles) return 0;\\n        if(dp[idx][M][turn] != -1){\\n            return dp[idx][M][turn];\\n        }\\n        int alexGotStones;\\n        if(turn){\\n            alexGotStones = INT_MAX;\\n            for(int i = 0; i < 2 * M; i++){\\n                if(!(idx + i < noOfPiles)) break;\\n                alexGotStones = min(alexGotStones, rec(piles, idx + i + 1, max(i + 1, M), noOfPiles, 0, dp));          \\n            } \\n        }else{\\n            alexGotStones = 0;\\n            int tempSum = 0;\\n            for(int i = 0; i < 2 * M; i++){\\n                if(!(idx + i < noOfPiles)) break;\\n                tempSum += piles[idx + i];\\n                alexGotStones = max(alexGotStones, tempSum + rec(piles, idx + i + 1, max(i + 1, M), noOfPiles, 1, dp));          \\n            }\\n        }\\n        dp[idx][M][turn] = alexGotStones;\\n        return alexGotStones;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        vector<vector<vector<int> > > dp(105, vector<vector<int> > (105, vector<int> (2, -1)));\\n        int noOfPiles = piles.size();\\n        return rec(piles, 0, 1, noOfPiles, 0, dp);\\n    }\\n};\\n```\\nRecursive DP with single state.\\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &piles, int idx, int M, int noOfPiles, vector<vector<int> > &dp){\\n        if(idx >= noOfPiles) return 0;\\n        if(dp[idx][M] != -1){\\n            return dp[idx][M];\\n        }\\n        int alexGotStones = INT_MIN;\\n        int tempSum = 0;\\n        for(int i = 0; i < 2 * M; i++){\\n            if(!(idx + i < noOfPiles)) break;\\n            tempSum += piles[idx + i];\\n            alexGotStones = max(alexGotStones, tempSum - rec(piles, idx + i + 1, max(i + 1, M), noOfPiles, dp));          \\n        }\\n        dp[idx][M] = alexGotStones;\\n        return alexGotStones;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        vector<vector<int> > dp(105, vector<int>(105, -1));\\n        int noOfPiles = piles.size();\\n        int sum = 0;\\n        for(int x : piles) sum += x;\\n        return (sum + rec(piles, 0, 1, noOfPiles, dp)) / 2;\\n    }\\n};\\n```\\nIterative DP.\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int noOfPiles = piles.size();\\n        vector<vector<int> > dp(noOfPiles + 1, vector<int>(noOfPiles + 1, -1000001));\\n        vector<int> suffSum(noOfPiles + 1);\\n        int sum = 0;\\n        for(int i = noOfPiles - 1; i >= 0; i--){\\n            sum += piles[i];\\n            suffSum[i] = sum;\\n        }\\n        for(int i = 0; i <= noOfPiles; i++) dp[noOfPiles][i] = 0;\\n        for(int i = noOfPiles - 1; i >= 0; i--){\\n            for(int M = 1; M <= noOfPiles; M++){\\n                for(int x = 1; x <= 2 * M && i + x <= noOfPiles; x++){\\n                    dp[i][M] = max(dp[i][M], (suffSum[i] - suffSum[i + x]) - dp[i + x][max(x, M)]);\\n                }\\n            }\\n        }\\n        return (sum + dp[0][1]) / 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// This solution will give TLE.\\nclass Solution {\\npublic:\\n    int rec(int idx, int M, vector<int> &piles, int turn){\\n        if(idx >= piles.size()) return 0;\\n        \\n        if(turn){\\n            int alexStones = INT_MAX;\\n            for(int i = 0; i < 2 * M && idx + i < piles.size(); i++){\\n                alexStones = min(alexStones, rec(idx + i + 1, max(M, i + 1), piles, !turn));\\n            }\\n            return alexStones;\\n        }else{\\n            int alexStones = 0, temp = 0;\\n            for(int i = 0; i < 2 * M && idx + i < piles.size(); i++){\\n                temp += piles[idx + i];\\n                alexStones = max(alexStones, temp + rec(idx + i + 1, max(M, i + 1), piles, !turn));\\n            }\\n            return alexStones;\\n        }\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        // vector<vector<int> > \\n        // int pilesLength = piles.size();\\n        return rec(0, 1, piles, 0);        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &piles, int idx, int M, int noOfPiles, int turn, vector<vector<vector<int> > > &dp){\\n        if(idx >= noOfPiles) return 0;\\n        if(dp[idx][M][turn] != -1){\\n            return dp[idx][M][turn];\\n        }\\n        int alexGotStones;\\n        if(turn){\\n            alexGotStones = INT_MAX;\\n            for(int i = 0; i < 2 * M; i++){\\n                if(!(idx + i < noOfPiles)) break;\\n                alexGotStones = min(alexGotStones, rec(piles, idx + i + 1, max(i + 1, M), noOfPiles, 0, dp));          \\n            } \\n        }else{\\n            alexGotStones = 0;\\n            int tempSum = 0;\\n            for(int i = 0; i < 2 * M; i++){\\n                if(!(idx + i < noOfPiles)) break;\\n                tempSum += piles[idx + i];\\n                alexGotStones = max(alexGotStones, tempSum + rec(piles, idx + i + 1, max(i + 1, M), noOfPiles, 1, dp));          \\n            }\\n        }\\n        dp[idx][M][turn] = alexGotStones;\\n        return alexGotStones;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        vector<vector<vector<int> > > dp(105, vector<vector<int> > (105, vector<int> (2, -1)));\\n        int noOfPiles = piles.size();\\n        return rec(piles, 0, 1, noOfPiles, 0, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &piles, int idx, int M, int noOfPiles, vector<vector<int> > &dp){\\n        if(idx >= noOfPiles) return 0;\\n        if(dp[idx][M] != -1){\\n            return dp[idx][M];\\n        }\\n        int alexGotStones = INT_MIN;\\n        int tempSum = 0;\\n        for(int i = 0; i < 2 * M; i++){\\n            if(!(idx + i < noOfPiles)) break;\\n            tempSum += piles[idx + i];\\n            alexGotStones = max(alexGotStones, tempSum - rec(piles, idx + i + 1, max(i + 1, M), noOfPiles, dp));          \\n        }\\n        dp[idx][M] = alexGotStones;\\n        return alexGotStones;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        vector<vector<int> > dp(105, vector<int>(105, -1));\\n        int noOfPiles = piles.size();\\n        int sum = 0;\\n        for(int x : piles) sum += x;\\n        return (sum + rec(piles, 0, 1, noOfPiles, dp)) / 2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int noOfPiles = piles.size();\\n        vector<vector<int> > dp(noOfPiles + 1, vector<int>(noOfPiles + 1, -1000001));\\n        vector<int> suffSum(noOfPiles + 1);\\n        int sum = 0;\\n        for(int i = noOfPiles - 1; i >= 0; i--){\\n            sum += piles[i];\\n            suffSum[i] = sum;\\n        }\\n        for(int i = 0; i <= noOfPiles; i++) dp[noOfPiles][i] = 0;\\n        for(int i = noOfPiles - 1; i >= 0; i--){\\n            for(int M = 1; M <= noOfPiles; M++){\\n                for(int x = 1; x <= 2 * M && i + x <= noOfPiles; x++){\\n                    dp[i][M] = max(dp[i][M], (suffSum[i] - suffSum[i + x]) - dp[i + x][max(x, M)]);\\n                }\\n            }\\n        }\\n        return (sum + dp[0][1]) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793881,
                "title": "python-dp-thought-process-explained",
                "content": "This was a really tough problem for me. It is so easy in the end when you got the idea, but it was pretty hard to get there (at least for me). So I\\'m going to share here how I\\'ve got to the optimal bottom-up DP solution for this task.\\n\\nThe first step was to write the straightforward top-down solution.\\nThe basic idea is that on each step\\n* if we\\'re Alex (turn == True) then we try to pick up to `2 * M` piles and pass the turn to Lee\\n* if we\\'re Lee (turn == False) then we also try to pick up to `2 * M` piles and pass the turn to Alex\\n\\nWhile doing that\\n* if we\\'re Alex we try to minimize our opponent\\'s (Lee) sum during next their turns\\n* if we\\'re Lee we try to minimize what Alex got during their turns\\n\\nThen we return both Lee\\'s and Alex\\'s sums (`sum_alex` and `sum_lee`) to reuse this information up in the call stack.\\n\\nThis logic brings us to the following solution (you\\'ll find the snippet with `_suffix_sum` method in the end [1], since it is used in every solution here, and no reason to repeat it every time):\\n\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        suffix_sum = self._suffix_sum(piles)\\n\\n        @lru_cache(None)\\n        def dfs(pile: int, M: int, turn: bool) -> Tuple[int, int]:\\n            # turn: true - alex, false - lee\\n            sum_alex, sum_lee = suffix_sum[pile], suffix_sum[pile]\\n\\n            for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):\\n                sum_alex_next, sum_lee_next = dfs(\\n                    next_pile, max(M, next_pile - pile), not turn\\n                )\\n                range_sum = suffix_sum[pile] - suffix_sum[next_pile]\\n\\n                if turn:\\n                    if sum_lee_next < sum_lee:\\n                        sum_alex = sum_alex_next + range_sum\\n                        sum_lee = sum_lee_next\\n                else:\\n                    if sum_alex_next < sum_alex:\\n                        sum_alex = sum_alex_next\\n                        sum_lee = sum_lee_next + range_sum\\n\\n            return sum_alex, sum_lee\\n\\n        return dfs(0, 1, True)[0]\\n```\\nWhen the code is finished we see that the signature of the recursion function depends only on 3 arguments: `pile`, `M` and `turn`. So if there are repetitions we just cache them. And this is our first Top-Down DP soluiton.\\n\\nBut most of the solutions are different from this one. More conscise and don\\'t use `turn` argument. So we can do better than this.\\nThere is a very simple concept that I was missing and it took a while for me to figure it out.\\nLet\\'s look at modified Top-Down solution and then I\\'ll explain how it works.\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        suffix_sum = self._suffix_sum(piles)\\n\\n        @lru_cache(None)\\n        def dfs(pile: int, M: int) -> int:\\n            sum_next_player = suffix_sum[pile]\\n\\n            for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):\\n                sum_next_player = min(\\n                    sum_next_player, dfs(next_pile, max(M, next_pile - pile))\\n                )\\n\\n            sum_player = suffix_sum[pile] - sum_next_player\\n\\n            return sum_player\\n\\n        return dfs(0, 1)\\n```\\nAs you see it is almost the same, but just a bit shorter.\\nSo the basic idea here is that there is no reason to have separate `sum_alex` and `sum_lee` variables, because they both sum up to `suffix_sum[pile]`\\nHere is an example (`X` - we haven\\'t desided yet, `A` - taken by Alex, `L` - taken by Lee)\\n```\\nXXXXXXXXXXAALAAALLLAALA\\n          ^\\n\\t\\t  pile\\n```\\nFrom this you can see that in order to calculate the number of piles taken by this player so far we just substract the number of the piles taken by another player from the total number of piles up to the current pile position.\\nThe next important thing to notice is that minimizing sum for the one player leads to maximising it for another and vice versa.\\nThis leads us to conclusion that we can do the same with just a single variable `sum_next_player`.\\nThe alrorightm now looks the following way:\\n* We\\'re trying to pick up to `2 * M` piles from the current position and pass the turn to the next player\\n* We\\'re getting back from the next player the maximum sum they were able to get and trying to minimize it\\n* Now when we found the minimum sum for the other player that also means we found the maximum sum for us, so return it\\n\\nThat\\'s how we got to the nice and short Top-Down DP solution.\\nThe only thing left - convert it to Bottom-Up solution to make the interviewer happy. And here is it\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        suffix_sum = self._suffix_sum(piles)\\n\\n        dp = [[0] * (len(piles) + 1) for _ in range(len(piles) + 1)]\\n\\n        for pile in reversed(range(len(piles))):\\n            for M in reversed(range(len(piles))):\\n                sum_next_player = suffix_sum[pile]\\n\\n                for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):\\n                    sum_next_player = min(\\n                        sum_next_player, dp[next_pile][max(M, next_pile - pile)]\\n                    )\\n\\n                sum_player = suffix_sum[pile] - sum_next_player\\n\\n                dp[pile][M] = sum_player\\n\\n        return dp[0][1]\\n```\\nAs you may see the Bottom-Up solution looks almost exactly the same in terms of the logic. And this is basically how I like to approach the conversion. Just take the Top-Down solution and convert it line-by-line to Bottom-Up. It usually works pretty well. The only difference you may spot in the body of the cycle is that we call `dp` table instead of `dfs` recursive function and that is about it.\\n\\nAnd this is everything I wanted to cover in this article, thank you for reading this far.\\n\\n[1] `_suffix_sum` method definition\\n```\\nclass Solution:\\n    @staticmethod\\n    def _suffix_sum(piles: List[int]) -> List[int]:\\n        suffix_sum = [0]\\n\\n        for pile in reversed(piles):\\n            suffix_sum.append(suffix_sum[-1] + pile)\\n\\n        suffix_sum.reverse()\\n\\n        return suffix_sum\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        suffix_sum = self._suffix_sum(piles)\\n\\n        @lru_cache(None)\\n        def dfs(pile: int, M: int, turn: bool) -> Tuple[int, int]:\\n            # turn: true - alex, false - lee\\n            sum_alex, sum_lee = suffix_sum[pile], suffix_sum[pile]\\n\\n            for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):\\n                sum_alex_next, sum_lee_next = dfs(\\n                    next_pile, max(M, next_pile - pile), not turn\\n                )\\n                range_sum = suffix_sum[pile] - suffix_sum[next_pile]\\n\\n                if turn:\\n                    if sum_lee_next < sum_lee:\\n                        sum_alex = sum_alex_next + range_sum\\n                        sum_lee = sum_lee_next\\n                else:\\n                    if sum_alex_next < sum_alex:\\n                        sum_alex = sum_alex_next\\n                        sum_lee = sum_lee_next + range_sum\\n\\n            return sum_alex, sum_lee\\n\\n        return dfs(0, 1, True)[0]\\n```\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        suffix_sum = self._suffix_sum(piles)\\n\\n        @lru_cache(None)\\n        def dfs(pile: int, M: int) -> int:\\n            sum_next_player = suffix_sum[pile]\\n\\n            for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):\\n                sum_next_player = min(\\n                    sum_next_player, dfs(next_pile, max(M, next_pile - pile))\\n                )\\n\\n            sum_player = suffix_sum[pile] - sum_next_player\\n\\n            return sum_player\\n\\n        return dfs(0, 1)\\n```\n```\\nXXXXXXXXXXAALAAALLLAALA\\n          ^\\n\\t\\t  pile\\n```\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        suffix_sum = self._suffix_sum(piles)\\n\\n        dp = [[0] * (len(piles) + 1) for _ in range(len(piles) + 1)]\\n\\n        for pile in reversed(range(len(piles))):\\n            for M in reversed(range(len(piles))):\\n                sum_next_player = suffix_sum[pile]\\n\\n                for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):\\n                    sum_next_player = min(\\n                        sum_next_player, dp[next_pile][max(M, next_pile - pile)]\\n                    )\\n\\n                sum_player = suffix_sum[pile] - sum_next_player\\n\\n                dp[pile][M] = sum_player\\n\\n        return dp[0][1]\\n```\n```\\nclass Solution:\\n    @staticmethod\\n    def _suffix_sum(piles: List[int]) -> List[int]:\\n        suffix_sum = [0]\\n\\n        for pile in reversed(piles):\\n            suffix_sum.append(suffix_sum[-1] + pile)\\n\\n        suffix_sum.reverse()\\n\\n        return suffix_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355710,
                "title": "java-simple-dp-solution-with-explanation",
                "content": "Let `DP[i][m]` be the maximal number of stones a player can get when the 0, 1, ..., i-1 piles have already been taken and the current `M` is `m`.  Let\\'s see how `DP[i][m]` can be calculated.  Let\\'s assume the total number of stones in piles i, i+1, ..., n-1 is `Si`.\\n1. If the player takes only the first pile (piles[i], `x` = 1), the other player can get up to `DP[i+1][max(m, 1)]`.  So the current player can get `Si - DP[i+1][max(m, 1)]`.\\n2. If the player takes the first two piles (piles[i], piles[i+1], `x` = 2), the other player can get up to `DP[i+2][max(m, 2)]`.  So the current player can get `Si - DP[i+2][max(m, 2)]`.\\n3. ...\\n4. If the player takes the first `2m` piles (piles[i], piles[i+1], ..., piles[i+2m], `x` = 2m), the other player can get up to `DP[i+2m][max(m, 2m)]`.  So the current player can get `Si - DP[i+2m][max(m, 2m)]`.\\n\\nWe can calculate all these options and pick the maximum.  \\n\\nNotes:\\n* `DP[i][m]` can be calcuated from `DP[i+x][max(m,x)]`.  We can use the results from larger index and no smaller `m` to calculate it.  This is perfect for dynamic programming, but we will need to do it in reverse order.\\n* We can calculate the cumulative sum of the stones from the last pile backward to the first so that we can easily get the total number of stones in piles i, i+1, ..., n-1.\\n* There is a small optimization to use a smaller `m` to cover some larger ones.  If there are only `n-i` piles left and the `m` is `(n-i+1)/2` or larger, the current player can just take all of the left piles.\\n\\n\\n```\\nfinal int n = piles.length;\\nfor (int i = n - 2; i >= 0; i--) piles[i] += piles[i+1];\\nif (n <= 2) return piles[0];\\nint[][] dp = new int[n][(n+1)/2+1];\\nfor (int i = n-1; i >= 0; i--) {\\n    int sum = piles[i];\\n    int m = (n-i+1)/2;\\n    dp[i][m] = sum;\\n    while (--m > 0) {\\n        dp[i][m] = 0;\\n        for (int x = 1; x <= m * 2 && i+x < n; x++) {\\n            int mx = Math.min((n-i-x+1)/2, Math.max(x, m));\\n            dp[i][m] = Math.max(dp[i][m], sum - dp[i+x][mx]);\\n        }\\n    }\\n}\\nreturn dp[0][1];\\n```",
                "solutionTags": [],
                "code": "```\\nfinal int n = piles.length;\\nfor (int i = n - 2; i >= 0; i--) piles[i] += piles[i+1];\\nif (n <= 2) return piles[0];\\nint[][] dp = new int[n][(n+1)/2+1];\\nfor (int i = n-1; i >= 0; i--) {\\n    int sum = piles[i];\\n    int m = (n-i+1)/2;\\n    dp[i][m] = sum;\\n    while (--m > 0) {\\n        dp[i][m] = 0;\\n        for (int x = 1; x <= m * 2 && i+x < n; x++) {\\n            int mx = Math.min((n-i-x+1)/2, Math.max(x, m));\\n            dp[i][m] = Math.max(dp[i][m], sum - dp[i+x][mx]);\\n        }\\n    }\\n}\\nreturn dp[0][1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1247693,
                "title": "c-memoization-with-proper-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][1001];\\n    int solve(vector<int>& piles,int ind, int m){\\n        //base condn\\n        if(ind>=piles.size()){\\n            return 0;\\n        }\\n        if(dp[ind][m]!=-1){\\n            return dp[ind][m];\\n        }\\n        int sum = 0;\\n        \\n        // let us suppose a edge scene \\n        // suppose we had already traversed our array upto n-4th index, we are having only 4 cells left  to check\\n        // now see if our player found those 4 cells into its range(i.e from 1 to 2*m)\\n        // he will consume all those to make its profit max \\n        if(ind+2*m>=piles.size()){\\n            for(int i=ind;i<piles.size();i++){\\n                sum+=piles[i];     \\n            }\\n            return dp[ind][m] = sum;\\n        }\\n        \\n        int value = INT_MIN;\\n        \\n        for(int i=1;i<=m*2;i++){\\n            sum+=piles[ind+i-1];\\n            \\n            // the sum indicates our current player profit\\n            // the recursive call indicates the optimal profit of our opponent\\n            // so, the value indicates the difference between our profit and our                        opponent profit\\n            // as if this will be maximum then only player will win the game\\n            value = max(value,sum-solve(piles,ind+i,max(m,i)));\\n        }\\n        return dp[ind][m] = value;\\n    }\\n    \\n    \\n    int stoneGameII(vector<int>& piles) {\\n        // this question is 90% same as Stone game-III\\n        int m = 1;\\n        memset(dp,-1,sizeof(dp));\\n        // VALUE is basically the diffrence between the profit of player A and B\\n        int value = solve(piles,0,m);\\n        \\n        // now how to find maximum stones of alice from this value\\n        // profit_alice + profit_bob = total_stones ....... eq(1)\\n        // profit_alice - profit_bob = value        ....... eq(2)\\n        // we add both equation 1 and 2\\n        // 2*profit_alice = total_stones+value\\n        \\n        int total_stones = 0;\\n        for(int i=0;i<piles.size();i++){\\n            total_stones+= piles[i];\\n        }\\n        int profit_alice = (total_stones+value)/2;\\n        return profit_alice;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][1001];\\n    int solve(vector<int>& piles,int ind, int m){\\n        //base condn\\n        if(ind>=piles.size()){\\n            return 0;\\n        }\\n        if(dp[ind][m]!=-1){\\n            return dp[ind][m];\\n        }\\n        int sum = 0;\\n        \\n        // let us suppose a edge scene \\n        // suppose we had already traversed our array upto n-4th index, we are having only 4 cells left  to check\\n        // now see if our player found those 4 cells into its range(i.e from 1 to 2*m)\\n        // he will consume all those to make its profit max \\n        if(ind+2*m>=piles.size()){\\n            for(int i=ind;i<piles.size();i++){\\n                sum+=piles[i];     \\n            }\\n            return dp[ind][m] = sum;\\n        }\\n        \\n        int value = INT_MIN;\\n        \\n        for(int i=1;i<=m*2;i++){\\n            sum+=piles[ind+i-1];\\n            \\n            // the sum indicates our current player profit\\n            // the recursive call indicates the optimal profit of our opponent\\n            // so, the value indicates the difference between our profit and our                        opponent profit\\n            // as if this will be maximum then only player will win the game\\n            value = max(value,sum-solve(piles,ind+i,max(m,i)));\\n        }\\n        return dp[ind][m] = value;\\n    }\\n    \\n    \\n    int stoneGameII(vector<int>& piles) {\\n        // this question is 90% same as Stone game-III\\n        int m = 1;\\n        memset(dp,-1,sizeof(dp));\\n        // VALUE is basically the diffrence between the profit of player A and B\\n        int value = solve(piles,0,m);\\n        \\n        // now how to find maximum stones of alice from this value\\n        // profit_alice + profit_bob = total_stones ....... eq(1)\\n        // profit_alice - profit_bob = value        ....... eq(2)\\n        // we add both equation 1 and 2\\n        // 2*profit_alice = total_stones+value\\n        \\n        int total_stones = 0;\\n        for(int i=0;i<piles.size();i++){\\n            total_stones+= piles[i];\\n        }\\n        int profit_alice = (total_stones+value)/2;\\n        return profit_alice;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345395,
                "title": "c-0-ms",
                "content": "To efficiently count stones from consecutive piles, we can use a prefix sum array ```dp```.\\n\\nWe can perform the search, returning the stone balance between current and previous player. For each player, we check all possible moves, maximizing the balance.\\n\\nIn the end, we can use the first player ballance to determine the number of their stones. To avoid recomputation, we memoise on the current pile and ```m```.\\n> Based on the analysis by [davidluoyes](https://leetcode.com/davidluoyes/), if the number of piles ```n``` is limited to 100, ```m``` will not exceed 32.\\n```\\nint memo[101][32] = {};\\nint dfs(vector<int>& dp, int x, int m, int res = INT_MIN) {\\n  if (x + m * 2 >= dp.size()) return dp[dp.size() - 1] - dp[x - 1];\\n  if (memo[x][m]) return memo[x][m];\\n  for (int i = x; i < x + m * 2 && i < dp.size(); ++i)\\n    res = max(res, dp[i] - (x == 0 ? 0 : dp[x - 1]) - dfs(dp, i + 1, max(m, i - x + 1)));\\n  return memo[x][m] = res;\\n}\\nint stoneGameII(vector<int>& ps) {\\n  partial_sum(begin(ps), end(ps), begin(ps));\\n  return (ps[ps.size() - 1] + dfs(ps, 0, 1)) / 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```dp```\n```m```\n```n```\n```m```\n```\\nint memo[101][32] = {};\\nint dfs(vector<int>& dp, int x, int m, int res = INT_MIN) {\\n  if (x + m * 2 >= dp.size()) return dp[dp.size() - 1] - dp[x - 1];\\n  if (memo[x][m]) return memo[x][m];\\n  for (int i = x; i < x + m * 2 && i < dp.size(); ++i)\\n    res = max(res, dp[i] - (x == 0 ? 0 : dp[x - 1]) - dfs(dp, i + 1, max(m, i - x + 1)));\\n  return memo[x][m] = res;\\n}\\nint stoneGameII(vector<int>& ps) {\\n  partial_sum(begin(ps), end(ps), begin(ps));\\n  return (ps[ps.size() - 1] + dfs(ps, 0, 1)) / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347888,
                "title": "c-straight-forward-dp-with-memo",
                "content": "Here is my straight forward min/max dp where the first player tries to minimize the maximum profit of the second player:\\n```\\nstatic int fast = [](){ios::sync_with_stdio(false);cin.tie(0);return 0;}();\\nstatic int dp[200][200];\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> V;\\n    int n;\\n   \\n    int solve(int start, int m, int leftStones) {\\n        int &res = dp[start][m];\\n        if (res != -1) return res;\\n        \\n        res = 0;\\n        int taken = 0;\\n        int lim = min(n, start + 2 * m);\\n\\n        for (int x = start; x < lim; ++x) {\\n            taken += V[x];\\n            int newM = max(m, x - start + 1);   \\n            res = max(res, \\n                      leftStones - solve(x + 1, newM, leftStones - taken));\\n        }\\n        return res;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n       memset(dp, -1, sizeof(dp));\\n       V = piles; \\n       n = V.size();\\n       return solve(0, 1, accumulate(V.begin(), V.end(), 0));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int fast = [](){ios::sync_with_stdio(false);cin.tie(0);return 0;}();\\nstatic int dp[200][200];\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> V;\\n    int n;\\n   \\n    int solve(int start, int m, int leftStones) {\\n        int &res = dp[start][m];\\n        if (res != -1) return res;\\n        \\n        res = 0;\\n        int taken = 0;\\n        int lim = min(n, start + 2 * m);\\n\\n        for (int x = start; x < lim; ++x) {\\n            taken += V[x];\\n            int newM = max(m, x - start + 1);   \\n            res = max(res, \\n                      leftStones - solve(x + 1, newM, leftStones - taken));\\n        }\\n        return res;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n       memset(dp, -1, sizeof(dp));\\n       V = piles; \\n       n = V.size();\\n       return solve(0, 1, accumulate(V.begin(), V.end(), 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345732,
                "title": "java-o-n-3-beats-100-minimax-dp-readable-and-concise-with-explanation",
                "content": "We will use the minimax algorithm for game theory. It\\'s very simple; taking a quick glance here should explain the concept to you: https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-1-introduction/\\n\\nRegardless of who the player is, we want the function call to only return Alex\\'s score. So, we\\'ll keep a turn variable `isAlex` to keep track of whose turn it is. So if we\\'re Alex, we\\'ll return the maximum of the set: (stones grabbed this turn + recurse on Lee\\'s turn starting at the next index from what we grabbed). If we\\'re Lee, we will return the minumum of (recurse on Alex\\'s turn starting at the next index from what we grabbed). The size of these sets will be--assuming we\\'re not at the end of the array--2m, since one can try grabbing 2m stones at a turn.\\n\\nMemoize it all into a n * n * 2 DP array. \\n\\n```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        return help(piles, 0, 1, 0, new Integer[piles.length + 1][2 * piles.length + 1][2]);\\n    }\\n    \\n    private int help(int[] piles, int i, int m, int isAlex, Integer[][][] dp) {\\n        if (i >= piles.length)\\n            return 0;\\n        \\n        if (dp[i][m][isAlex] != null)\\n            return dp[i][m][isAlex];\\n        \\n        int maxScore = isAlex == 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE;\\n        \\n        int currSum = 0;\\n        \\n        for (int x = i; x < piles.length && x < i + 2 * m; x++) {\\n            currSum += piles[x];\\n            \\n            int next = help(piles, x + 1, Math.max(x - i + 1, m), isAlex ^ 1, dp);\\n            \\n            if (isAlex == 0)\\n                maxScore = Math.max(maxScore, currSum + next);\\n            else\\n                maxScore = Math.min(maxScore, next);\\n        }\\n        \\n        return dp[i][m][isAlex] = maxScore;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        return help(piles, 0, 1, 0, new Integer[piles.length + 1][2 * piles.length + 1][2]);\\n    }\\n    \\n    private int help(int[] piles, int i, int m, int isAlex, Integer[][][] dp) {\\n        if (i >= piles.length)\\n            return 0;\\n        \\n        if (dp[i][m][isAlex] != null)\\n            return dp[i][m][isAlex];\\n        \\n        int maxScore = isAlex == 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE;\\n        \\n        int currSum = 0;\\n        \\n        for (int x = i; x < piles.length && x < i + 2 * m; x++) {\\n            currSum += piles[x];\\n            \\n            int next = help(piles, x + 1, Math.max(x - i + 1, m), isAlex ^ 1, dp);\\n            \\n            if (isAlex == 0)\\n                maxScore = Math.max(maxScore, currSum + next);\\n            else\\n                maxScore = Math.min(maxScore, next);\\n        }\\n        \\n        return dp[i][m][isAlex] = maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345404,
                "title": "simple-dp-solution-clean-code",
                "content": "dp[i][j] is the maximum number of stones Alex can get when starting at index i with M = j\\nsum[i] is the total number of stones from index i to the end\\nThe dp matrix for Bob is the same, and the stragegy for Alex is to choose an optimal X to minimize the number of stones Bob can get when starting at index (i + X) with M = max(X,j), recurrence formula\\n\\n```\\ndp[i][j] = max(dp[i][j], sum[i] - dp[i + X][max(j, X)]) where (1 <= X <= 2*j);\\n```\\nRuntime: 12 ms, faster than 100.00% of C++ online submissions for Stone Game II.\\nMemory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Stone Game II.\\n\\n**This code will take O(n ^ 3) in worst case and O(n^2) Space Complexity**\\n\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        if(n == 0)  return 0;\\n        \\n        vector<int>sum(n+1, 0);\\n        \\n        for(int i= n - 1; i >= 0; i--)  sum[i] = piles[i] + sum[i+1];\\n        \\n        vector<vector<int>>dp(n+1, vector<int>(n+1,0));\\n        for(int i = 0; i <= n; i++)\\n            dp[i][n] = sum[i];\\n        \\n        for(int i = n -1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                for(int x = 1; x <= 2 * j && i + x <= n; x++)\\n                    dp[i][j] = max(dp[i][j], sum[i] - dp[i+x][max(j,x)]);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ndp[i][j] = max(dp[i][j], sum[i] - dp[i + X][max(j, X)]) where (1 <= X <= 2*j);\\n```\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        if(n == 0)  return 0;\\n        \\n        vector<int>sum(n+1, 0);\\n        \\n        for(int i= n - 1; i >= 0; i--)  sum[i] = piles[i] + sum[i+1];\\n        \\n        vector<vector<int>>dp(n+1, vector<int>(n+1,0));\\n        for(int i = 0; i <= n; i++)\\n            dp[i][n] = sum[i];\\n        \\n        for(int i = n -1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                for(int x = 1; x <= 2 * j && i + x <= n; x++)\\n                    dp[i][j] = max(dp[i][j], sum[i] - dp[i+x][max(j,x)]);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867408,
                "title": "c-top-down-dp-easy-with-explanation",
                "content": "We just calculate the net max difference possible. Now let the amount collected by Alex be \\'a\\' and by Lee be \\'b\\'.\\na+b = Total sum of piles \\na-b = MaxDiff\\nSo a = (Total+MaxDiff)/2\\nFor the max difference, we use dfs with memoization. Comment for any doubt.\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[105][105];\\n    int dfs(vector<int>&p, int i,int m)\\n    {\\n        if(i==n) return 0;\\n        if(dp[i][m]!=-1) return dp[i][m];\\n        int ans=INT_MIN,sum=0;\\n        for(int j=i;j<n && j-i+1<=2*m;j++)\\n        {\\n            sum+=p[j];\\n            ans=max(ans,sum-dfs(p,j+1,max(m,j-i+1)));\\n        }\\n        return dp[i][m]=ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        n=piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        int sum= accumulate(piles.begin(),piles.end(),0);\\n        //cout<<sum<<\" \"<<dfs(piles,0,1);\\n        return (sum+dfs(piles,0,1))/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[105][105];\\n    int dfs(vector<int>&p, int i,int m)\\n    {\\n        if(i==n) return 0;\\n        if(dp[i][m]!=-1) return dp[i][m];\\n        int ans=INT_MIN,sum=0;\\n        for(int j=i;j<n && j-i+1<=2*m;j++)\\n        {\\n            sum+=p[j];\\n            ans=max(ans,sum-dfs(p,j+1,max(m,j-i+1)));\\n        }\\n        return dp[i][m]=ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        n=piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        int sum= accumulate(piles.begin(),piles.end(),0);\\n        //cout<<sum<<\" \"<<dfs(piles,0,1);\\n        return (sum+dfs(piles,0,1))/2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 808305,
                "title": "python-dp-memoization-with-explanation",
                "content": "**The idea:**\\n* we know that both players act optimally\\n  * -> we can share the same scoring function for both players\\n* how does one player optimize (maximize) its score?\\n  * we want the opponent to minimize his score after `X` is taken, i.e., explore all possible values for `X` and find an value that minimizes the opponent\\'s score (aka `minimax`)\\n  * let this palyer explore all possible values for `X` \\n    * To get the score for each `X`\\n      * call the recursive function to obtain the maximal score for its *opponent* (because the opponent acts optimally)\\n      * the score for this player `==` `all available score` - `opponent\\'s score` \\n  * return the maximal score from the above loop, which is equivalent to minimizing the opponent\\'s score\\n* memoization: use `dp(start, M)` for memoization\\n* 76 ms, 14.5 MB\\n\\n**Complexity:**\\n* Time: O(n^3)\\n  * number of sub-problems: n^2, i.e., number of opponent\\'s choice\\n  * each subproblem needs to iterate through M options\\n* Space: O(n^2)\\n\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        N = len(piles)\\n        self.dp = {}\\n\\n        def recursiveStoneGame(start, M):            \\n            if start >= N:\\n                return 0\\n            \\n            # take all if possible\\n            if N - start <= 2*M:\\n                return sum(piles[start:])\\n            \\n            # memoization\\n            if (start, M) in self.dp:\\n                return self.dp[(start, M)]\\n\\n            my_score = 0\\n            total_score = sum(piles[start:])\\n            # the opponent can take [1, 2*M] stones\\n            for x in range(1, 2*M+1):\\n                # get opponent\\'s score\\n                opponent_score = recursiveStoneGame(start+x, max(x, M))\\n                # maintains max my_score\\n                my_score = max(my_score, total_score - opponent_score)\\n                \\n            self.dp[(start, M)] = my_score\\n                \\n            return my_score\\n        \\n        \\n        return recursiveStoneGame(0, 1)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        N = len(piles)\\n        self.dp = {}\\n\\n        def recursiveStoneGame(start, M):            \\n            if start >= N:\\n                return 0\\n            \\n            # take all if possible\\n            if N - start <= 2*M:\\n                return sum(piles[start:])\\n            \\n            # memoization\\n            if (start, M) in self.dp:\\n                return self.dp[(start, M)]\\n\\n            my_score = 0\\n            total_score = sum(piles[start:])\\n            # the opponent can take [1, 2*M] stones\\n            for x in range(1, 2*M+1):\\n                # get opponent\\'s score\\n                opponent_score = recursiveStoneGame(start+x, max(x, M))\\n                # maintains max my_score\\n                my_score = max(my_score, total_score - opponent_score)\\n                \\n            self.dp[(start, M)] = my_score\\n                \\n            return my_score\\n        \\n        \\n        return recursiveStoneGame(0, 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169719,
                "title": "coming-up-with-recursion-and-then-with-topdowndp",
                "content": "I could not come up with straight forward top down DP. Infact even the recursion logic was not clear first. Here is recursion logic.\\n\\n* let us assume that our function gives us the difference of scores if both alice and bob plays well.\\n* so diff = aliceBestPossibleScore - bobBestPossibleScore\\n* later we can calculate aliceScore =  ( totalSum + diff ) / 2\\n\\nnow how can we achieve that ? \\n* we iterate over all possible range for alice and get the max value for all her scores and return.\\n* it would be clear when you see the code.\\n\\n```\\n    int maxAlice(vector<int> &piles, int startIndex, int m)\\n    {\\n        if(startIndex >= piles.size())\\n            return 0;\\n        \\n        int currSum = 0;\\n\\t\\t\\n\\t\\t// if a person can take all the remaining stones then, he/she must take them all to get better score\\n        if(startIndex + 2*m >= piles.size())\\n        {\\n            for(int index = startIndex ; index < piles.size() ; index++)\\n                currSum += piles[index];\\n            return currSum;\\n        }\\n        \\n        int ans = INT_MIN;\\n\\t\\t\\n\\t\\t//  now we iterate over all scores that this person can get by iterating over all possible values\\n        for(int x=1 ; x <= 2*m ; x++)\\n        {\\n            currSum += piles[startIndex+x-1];\\n\\n            // max answer that alice can get\\n            ans = max( ans , currSum - maxAlice(piles , startIndex + x ,max(m,x))  );\\n        }\\n        return ans;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int AliceDiffersBobBy = maxAlice(piles, 0 , 1);\\n        int totalSum          = 0;\\n        \\n        for(auto i : piles)\\n            totalSum += i;\\n        \\n        return (totalSum + AliceDiffersBobBy )/2;\\n    }\\n```\\n\\nnow converting this code into TopDownDp becomes really easy, just avoid recomputation of same subproblem\\n```\\nvector<vector<int>> dp;\\n    \\n    int maxAlice(vector<int> &piles, int startIndex, int m)\\n    {\\n        \\n        if(dp[startIndex][m] != -1)\\n            return dp[startIndex][m];\\n        \\n        if(startIndex >= piles.size())\\n            return dp[startIndex][m] = 0;\\n        \\n        int currSum = 0;\\n        if(startIndex + 2*m >= piles.size())\\n        {\\n            for(int index = startIndex ; index < piles.size() ; index++)\\n                currSum += piles[index];\\n            return dp[startIndex][m] = currSum;\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int x=1 ; x <= 2*m ; x++)\\n        {\\n            currSum += piles[startIndex+x-1];\\n\\n            // max answer that alice can get\\n            ans = max( ans , currSum - maxAlice(piles , startIndex + x ,max(m,x))  );\\n        }\\n        return dp[startIndex][m] = ans;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) \\n    {\\n        dp = vector<vector<int>>(piles.size() , vector<int>(50 , -1));\\n        \\n        int AliceDiffersBobBy = maxAlice(piles, 0 , 1);\\n        int totalSum          = 0;\\n        \\n        for(auto i : piles)\\n            totalSum += i;\\n        \\n        return (totalSum + AliceDiffersBobBy )/2;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    int maxAlice(vector<int> &piles, int startIndex, int m)\\n    {\\n        if(startIndex >= piles.size())\\n            return 0;\\n        \\n        int currSum = 0;\\n\\t\\t\\n\\t\\t// if a person can take all the remaining stones then, he/she must take them all to get better score\\n        if(startIndex + 2*m >= piles.size())\\n        {\\n            for(int index = startIndex ; index < piles.size() ; index++)\\n                currSum += piles[index];\\n            return currSum;\\n        }\\n        \\n        int ans = INT_MIN;\\n\\t\\t\\n\\t\\t//  now we iterate over all scores that this person can get by iterating over all possible values\\n        for(int x=1 ; x <= 2*m ; x++)\\n        {\\n            currSum += piles[startIndex+x-1];\\n\\n            // max answer that alice can get\\n            ans = max( ans , currSum - maxAlice(piles , startIndex + x ,max(m,x))  );\\n        }\\n        return ans;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int AliceDiffersBobBy = maxAlice(piles, 0 , 1);\\n        int totalSum          = 0;\\n        \\n        for(auto i : piles)\\n            totalSum += i;\\n        \\n        return (totalSum + AliceDiffersBobBy )/2;\\n    }\\n```\n```\\nvector<vector<int>> dp;\\n    \\n    int maxAlice(vector<int> &piles, int startIndex, int m)\\n    {\\n        \\n        if(dp[startIndex][m] != -1)\\n            return dp[startIndex][m];\\n        \\n        if(startIndex >= piles.size())\\n            return dp[startIndex][m] = 0;\\n        \\n        int currSum = 0;\\n        if(startIndex + 2*m >= piles.size())\\n        {\\n            for(int index = startIndex ; index < piles.size() ; index++)\\n                currSum += piles[index];\\n            return dp[startIndex][m] = currSum;\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int x=1 ; x <= 2*m ; x++)\\n        {\\n            currSum += piles[startIndex+x-1];\\n\\n            // max answer that alice can get\\n            ans = max( ans , currSum - maxAlice(piles , startIndex + x ,max(m,x))  );\\n        }\\n        return dp[startIndex][m] = ans;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) \\n    {\\n        dp = vector<vector<int>>(piles.size() , vector<int>(50 , -1));\\n        \\n        int AliceDiffersBobBy = maxAlice(piles, 0 , 1);\\n        int totalSum          = 0;\\n        \\n        for(auto i : piles)\\n            totalSum += i;\\n        \\n        return (totalSum + AliceDiffersBobBy )/2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563735,
                "title": "dp-with-line-by-line-explanation",
                "content": "**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // dp[i][j] = max stones you can get from piles[i:] with M = j\\n    int dp[101][200], n;\\n    int dfs(vector<int>& piles, int i, int m, int total) {\\n        // if we calculated the result before, use it directly\\n        if (dp[i][m] != -1) return dp[i][m];\\n        // res: used to compare the max number of stones\\n        // taken: used to record how many stones we\\'ve taken\\n        int res = 0, taken = 0;\\n        // i is the starting position\\n        // we can take at most i + 2 * m piles\\n        // however, it may exceed the size of piles \\n        // hence use min to get the max limit\\n        for (int j = i; j < min(i + 2 * m, n); j++) {\\n            // take this pile of stones\\n            taken += piles[j];\\n            // move to the next position\\n            // with the new M = max(M, X)\\n            // where X is how many piles we\\'ve taken so far which is j - i + 1\\n            res = max(res, total - dfs(piles, j + 1, max(m, j - i + 1), total - taken));\\n        }\\n        // memoize the result\\n        return dp[i][m] = res;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        // init dp with value -1\\n        memset(dp, -1, sizeof(dp));\\n        n = piles.size();\\n        return dfs(piles, 0, 1, accumulate(piles.begin(), piles.end(), 0));\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n        @cache\\n        def dfs(i, m, total):\\n            # used to compare the max number of stones\\n            res = 0\\n            # used to record how many stones we\\'ve taken\\n            taken = 0\\n            # i is the starting position\\n            # we can take at most i + 2 * m piles\\n            # however, it may exceed the size of piles \\n            # hence use min to get the max limit\\n            for j in range(i, min(i + 2 * m, n)):\\n                # take this pile of stones\\n                taken += piles[j]\\n                # move to the next position\\n                # with the new M = max(M, X)\\n                # where X is how many piles we\\'ve taken so far which is j - i + 1\\n                res = max(res, total - dfs(j + 1, max(m, j - i + 1), total - taken))\\n            return res\\n        return dfs(0, 1, sum(piles))\\n```\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // dp[i][j] = max stones you can get from piles[i:] with M = j\\n    int dp[101][200], n;\\n    int dfs(vector<int>& piles, int i, int m, int total) {\\n        // if we calculated the result before, use it directly\\n        if (dp[i][m] != -1) return dp[i][m];\\n        // res: used to compare the max number of stones\\n        // taken: used to record how many stones we\\'ve taken\\n        int res = 0, taken = 0;\\n        // i is the starting position\\n        // we can take at most i + 2 * m piles\\n        // however, it may exceed the size of piles \\n        // hence use min to get the max limit\\n        for (int j = i; j < min(i + 2 * m, n); j++) {\\n            // take this pile of stones\\n            taken += piles[j];\\n            // move to the next position\\n            // with the new M = max(M, X)\\n            // where X is how many piles we\\'ve taken so far which is j - i + 1\\n            res = max(res, total - dfs(piles, j + 1, max(m, j - i + 1), total - taken));\\n        }\\n        // memoize the result\\n        return dp[i][m] = res;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        // init dp with value -1\\n        memset(dp, -1, sizeof(dp));\\n        n = piles.size();\\n        return dfs(piles, 0, 1, accumulate(piles.begin(), piles.end(), 0));\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n        @cache\\n        def dfs(i, m, total):\\n            # used to compare the max number of stones\\n            res = 0\\n            # used to record how many stones we\\'ve taken\\n            taken = 0\\n            # i is the starting position\\n            # we can take at most i + 2 * m piles\\n            # however, it may exceed the size of piles \\n            # hence use min to get the max limit\\n            for j in range(i, min(i + 2 * m, n)):\\n                # take this pile of stones\\n                taken += piles[j]\\n                # move to the next position\\n                # with the new M = max(M, X)\\n                # where X is how many piles we\\'ve taken so far which is j - i + 1\\n                res = max(res, total - dfs(j + 1, max(m, j - i + 1), total - taken))\\n            return res\\n        return dfs(0, 1, sum(piles))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563361,
                "title": "recursion-top-down-easy-to-understand-code-simple-code",
                "content": "Both have **options to pick any no. of piles** within a range from (1 to (2 * m))\\nBoth will **try all possibilities of picking** all possible piles\\nBoth will choose the best case according to the following rule\\n**Alice : maximize what I can get**\\n**Bob : minimize what Alice will get**\\n\\n## RECURSION\\n```\\nclass Solution {\\npublic:\\n    //(turn = 0) = ALICE, (turn = 1) = BOB\\n    int stonesAliceGets(vector<int>&piles, int m, int startIdx, int turn)\\n    {\\n        if (startIdx == piles.size()) return 0;\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 0)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = startIdx + x - 1;\\n            if (pileIdx >= piles.size()) break;\\n            takenCount += piles[pileIdx];\\n            \\n            if (turn == 0)\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, max(m, x), pileIdx + 1, 1);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, max(m, x), pileIdx + 1, 0);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return ans; \\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        int ans = stonesAliceGets(piles, 1, 0, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\\n//======================================================================================================================\\n## TOP DOWN MEMOIZATION \\n```\\nclass Solution {\\npublic:\\n    //(turn = 0) = ALICE, (turn = 1) = BOB\\n    int stonesAliceGets(vector<int>&piles, vector<vector<vector<int>>>&dp, int m, int startIdx, int turn)\\n    {\\n        if (startIdx == piles.size()) return 0;\\n        if (dp[m][startIdx][turn] != -1) return dp[m][startIdx][turn]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 0)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = startIdx + x - 1;\\n            if (pileIdx >= piles.size()) break;\\n            takenCount += piles[pileIdx];\\n            \\n            if (turn == 0)\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[m][startIdx][turn] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<vector<int>>>dp(n + 1, vector<vector<int>>(n, vector<int>(2, -1)));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //(turn = 0) = ALICE, (turn = 1) = BOB\\n    int stonesAliceGets(vector<int>&piles, int m, int startIdx, int turn)\\n    {\\n        if (startIdx == piles.size()) return 0;\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 0)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = startIdx + x - 1;\\n            if (pileIdx >= piles.size()) break;\\n            takenCount += piles[pileIdx];\\n            \\n            if (turn == 0)\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, max(m, x), pileIdx + 1, 1);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, max(m, x), pileIdx + 1, 0);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return ans; \\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        int ans = stonesAliceGets(piles, 1, 0, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //(turn = 0) = ALICE, (turn = 1) = BOB\\n    int stonesAliceGets(vector<int>&piles, vector<vector<vector<int>>>&dp, int m, int startIdx, int turn)\\n    {\\n        if (startIdx == piles.size()) return 0;\\n        if (dp[m][startIdx][turn] != -1) return dp[m][startIdx][turn]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 0)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = startIdx + x - 1;\\n            if (pileIdx >= piles.size()) break;\\n            takenCount += piles[pileIdx];\\n            \\n            if (turn == 0)\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[m][startIdx][turn] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<vector<int>>>dp(n + 1, vector<vector<int>>(n, vector<int>(2, -1)));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708282,
                "title": "c-simple-intuitive-solution-w-explanation-dp-memorization",
                "content": "**APPROACH :**\\n\\n* Let Alice win a total of A stones & Bob win a total of B stones.\\n* A + B = Total no. of stones in all piles = ```sum```\\n* A - B = Maximum difference between the scores of Alice & Bob (Since we want to play in such a way that Alice scores max stones, we are making the difference maximum) = ```diff```\\n* So max stones won by Alice = ( (A+B) + (A-B))/2 or  (sum + diff)/2.\\n\\n**Code :**\\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n            \\n        dp.resize(101, vector<int>(202)); \\n\\t\\t\\n        int sum = accumulate(piles.begin(), piles.end(), 0), diff = solve(piles, 0, 1); //sum of stones in all piles\\n        \\n        return (sum + diff)/2; //Max stones won by Alice - We need to maximize the diff so this can be maximum\\n    }\\n    \\n    int solve(vector<int> piles, int i, int M){\\n        if(i >= piles.size()) return 0; //If i>n-1 return 0\\n        \\n        if(dp[i][M] != 0) return dp[i][M]; //memorized value\\n        \\n        int total = 0, ans = INT_MIN; //total stores the total no. of stones won by Alice so far\\n\\t\\t//ans - stores the maximum difference between Alice & Bob\\'s stones\\n        \\n        for(int j=0; j<2*M; j++){   //1<=X<=2*M\\n            if(i+j < piles.size()) total += piles[i+j]; //Each time we\\'re incrementing X, add that index\\'s stones to total\\n            \\n            ans = max(ans, total-solve(piles, i+j+1, max(M, j+1))); //total-solve() is to check if we can maximize the score diff by incrementing X at any time.\\n        }     \\n        return dp[i][M] = ans; //return the maximum diff\\n    }    \\n};\\n```\\n\\n**Do upvote if you like my solution :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```sum```\n```diff```\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n            \\n        dp.resize(101, vector<int>(202)); \\n\\t\\t\\n        int sum = accumulate(piles.begin(), piles.end(), 0), diff = solve(piles, 0, 1); //sum of stones in all piles\\n        \\n        return (sum + diff)/2; //Max stones won by Alice - We need to maximize the diff so this can be maximum\\n    }\\n    \\n    int solve(vector<int> piles, int i, int M){\\n        if(i >= piles.size()) return 0; //If i>n-1 return 0\\n        \\n        if(dp[i][M] != 0) return dp[i][M]; //memorized value\\n        \\n        int total = 0, ans = INT_MIN; //total stores the total no. of stones won by Alice so far\\n\\t\\t//ans - stores the maximum difference between Alice & Bob\\'s stones\\n        \\n        for(int j=0; j<2*M; j++){   //1<=X<=2*M\\n            if(i+j < piles.size()) total += piles[i+j]; //Each time we\\'re incrementing X, add that index\\'s stones to total\\n            \\n            ans = max(ans, total-solve(piles, i+j+1, max(M, j+1))); //total-solve() is to check if we can maximize the score diff by incrementing X at any time.\\n        }     \\n        return dp[i][M] = ans; //return the maximum diff\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563953,
                "title": "c-3d-dp-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // For retrieving the sum of piles between l to r\\n    int get(int l, int r, vector<long long> &pref)\\n    {\\n        return pref[r + 1] - pref[l];\\n    }\\n\\n    int help(int idx, int m, bool aliceTurn, vector<long long> &pref, vector<int> &piles, vector<vector<vector<int>>> &dp)\\n    {\\n        if (idx >= piles.size())\\n            return 0;\\n\\n        if (dp[idx][m][aliceTurn] != -1)\\n            return dp[idx][m][aliceTurn];\\n\\n        // At alice turn maximize the answer \\n        if (aliceTurn)\\n        {\\n            int ans = 0;\\n            for (int x = 1; x <= 2 * m; x++)\\n                if (idx + x - 1 < piles.size())\\n                    ans = max(ans, get(idx, idx + x - 1, pref) + help(idx + x, max(m, x), false, pref, piles, dp));\\n\\n            return dp[idx][m][aliceTurn] = ans;\\n        }\\n\\n        // while at bob\\'s turn minimize the answer\\n        int ans = 1e9;\\n        for (int x = 1; x <= 2 * m; x++)\\n            if (idx + x - 1 < piles.size())\\n                ans = min(ans, help(idx + x, max(m, x), true, pref, piles, dp));\\n\\n        return dp[idx][m][aliceTurn] = ans;\\n    }\\n\\n    int stoneGameII(vector<int> &piles)\\n    {\\n        int n = piles.size();\\n\\n        vector<long long> pref(n + 1, 0);\\n        for (int i = 1; i <= n; i++)\\n            pref[i] = pref[i - 1] + piles[i - 1];\\n\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2 * n + 2, vector<int>(2, -1)));\\n        return help(0, 1, true, pref, piles, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // For retrieving the sum of piles between l to r\\n    int get(int l, int r, vector<long long> &pref)\\n    {\\n        return pref[r + 1] - pref[l];\\n    }\\n\\n    int help(int idx, int m, bool aliceTurn, vector<long long> &pref, vector<int> &piles, vector<vector<vector<int>>> &dp)\\n    {\\n        if (idx >= piles.size())\\n            return 0;\\n\\n        if (dp[idx][m][aliceTurn] != -1)\\n            return dp[idx][m][aliceTurn];\\n\\n        // At alice turn maximize the answer \\n        if (aliceTurn)\\n        {\\n            int ans = 0;\\n            for (int x = 1; x <= 2 * m; x++)\\n                if (idx + x - 1 < piles.size())\\n                    ans = max(ans, get(idx, idx + x - 1, pref) + help(idx + x, max(m, x), false, pref, piles, dp));\\n\\n            return dp[idx][m][aliceTurn] = ans;\\n        }\\n\\n        // while at bob\\'s turn minimize the answer\\n        int ans = 1e9;\\n        for (int x = 1; x <= 2 * m; x++)\\n            if (idx + x - 1 < piles.size())\\n                ans = min(ans, help(idx + x, max(m, x), true, pref, piles, dp));\\n\\n        return dp[idx][m][aliceTurn] = ans;\\n    }\\n\\n    int stoneGameII(vector<int> &piles)\\n    {\\n        int n = piles.size();\\n\\n        vector<long long> pref(n + 1, 0);\\n        for (int i = 1; i <= n; i++)\\n            pref[i] = pref[i - 1] + piles[i - 1];\\n\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2 * n + 2, vector<int>(2, -1)));\\n        return help(0, 1, true, pref, piles, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464936,
                "title": "python-memoization-beats-96-9-lines",
                "content": "![image](https://assets.leetcode.com/users/images/621ccbfb-9e1a-4b0b-a080-32bf1257af19_1661186437.9108002.png)\\n\\nLet\\'s say our **play** function returns the *maximum* amount of stones that current player can get. So if we start it with initial parameters, it will return the desired answer for Alice.\\n\\nNow how it works. It gets two numbers - ***i*** is the *index of very left pile we can take stones from* and ***m*** - the current *m parameter*, as it\\'s described in the task.\\n\\nNow let ***s*** be the number of remaining stones in all heaps. If by this move a player may grab all the stones left *(i + 2m >= len(piles))*, then i have good news for him/her. We *return s*.\\n\\nIf not, something interesting happens. Let\\'s remember that our **play** function returns result *for the current player*, but now we have to pass the turn order to our opponent. So let\\'s consider *all the possible outcomes* of our opponent\\'s game and choose among them the one in which he/she collects the *minimum* number of stones. Then we just need to *subtract from the number of all the stones how many the opponent could get*.\\n\\n*That\\'s it!*\\n *you can also create a postfix sum array for piles to not waste time for repeating calculation in the **play** function*\\n**Please, upvote if you like the explanation!**\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        @lru_cache(None)\\n        def play(i, m):\\n            s = sum(piles[i:])\\n            if i + 2 * m >= len(piles):\\n                return s\\n            return s - min(play(i + x, max(m, x)) for x in range(1, 2 * m + 1))\\n        return play(0, 1)",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/621ccbfb-9e1a-4b0b-a080-32bf1257af19_1661186437.9108002.png)\\n\\nLet\\'s say our **play** function returns the *maximum* amount of stones that current player can get. So if we start it with initial parameters, it will return the desired answer for Alice.\\n\\nNow how it works. It gets two numbers - ***i*** is the *index of very left pile we can take stones from* and ***m*** - the current *m parameter*, as it\\'s described in the task.\\n\\nNow let ***s*** be the number of remaining stones in all heaps. If by this move a player may grab all the stones left *(i + 2m >= len(piles))*, then i have good news for him/her. We *return s*.\\n\\nIf not, something interesting happens. Let\\'s remember that our **play** function returns result *for the current player*, but now we have to pass the turn order to our opponent. So let\\'s consider *all the possible outcomes* of our opponent\\'s game and choose among them the one in which he/she collects the *minimum* number of stones. Then we just need to *subtract from the number of all the stones how many the opponent could get*.\\n\\n*That\\'s it!*\\n *you can also create a postfix sum array for piles to not waste time for repeating calculation in the **play** function*\\n**Please, upvote if you like the explanation!**\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        @lru_cache(None)\\n        def play(i, m):\\n            s = sum(piles[i:])\\n            if i + 2 * m >= len(piles):\\n                return s\\n            return s - min(play(i + x, max(m, x)) for x in range(1, 2 * m + 1))\\n        return play(0, 1)",
                "codeTag": "Java"
            },
            {
                "id": 1960551,
                "title": "c-dp-solution-with-memoization",
                "content": "\\nHere the trick is when we are at bob position we have to maximise its value and minimise alice\\'s value (as for optimal play) but for doing that we would need two stacks so we are doing it here with only one stack by the skipping the bobs piles and minimizing the remaining alice piles , so in thaT WAY WE GET minimum alice when counter is at bob\\'s\\n```\\n int dp[2][202][101];\\n    \\n    int solve(int x,vector<int>& piles,int m,bool pl)\\n    {\\n        int n=piles.size(),i,j;\\n        \\n        if(x>=n){return 0;}\\n        int ans=0;\\n        int cnt=0;\\n        \\n        if(dp[pl][m][x]!=-1){return dp[pl][m][x]; }\\n        \\n        //alice\\n        if(pl==0){\\n            \\n        for(i=1;i<=2*m;i++)\\n        {\\n            if(x+i-1<n)\\n        {\\n            cnt+=piles[x+i-1];\\n        }\\n            \\n            // cout<<2*m<<endl;\\n           // cout<<i<<x<<endl;\\n            ans= max(ans,cnt+solve(x+i,piles,max(i,m),!pl));\\n        }\\n            \\n        }\\n        \\n        //for bob or alice min\\n        \\n        else{\\n            ans=INT_MAX;\\n              for(i=1;i<=2*m;i++)\\n        {\\n        \\n            ans= min(ans,solve(x+i,piles,max(i,m),!pl));\\n        }\\n            \\n        }\\n        \\n        return dp[pl][m][x]=ans;\\n        \\n        \\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,piles,1,0);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n int dp[2][202][101];\\n    \\n    int solve(int x,vector<int>& piles,int m,bool pl)\\n    {\\n        int n=piles.size(),i,j;\\n        \\n        if(x>=n){return 0;}\\n        int ans=0;\\n        int cnt=0;\\n        \\n        if(dp[pl][m][x]!=-1){return dp[pl][m][x]; }\\n        \\n        //alice\\n        if(pl==0){\\n            \\n        for(i=1;i<=2*m;i++)\\n        {\\n            if(x+i-1<n)\\n        {\\n            cnt+=piles[x+i-1];\\n        }\\n            \\n            // cout<<2*m<<endl;\\n           // cout<<i<<x<<endl;\\n            ans= max(ans,cnt+solve(x+i,piles,max(i,m),!pl));\\n        }\\n            \\n        }\\n        \\n        //for bob or alice min\\n        \\n        else{\\n            ans=INT_MAX;\\n              for(i=1;i<=2*m;i++)\\n        {\\n        \\n            ans= min(ans,solve(x+i,piles,max(i,m),!pl));\\n        }\\n            \\n        }\\n        \\n        return dp[pl][m][x]=ans;\\n        \\n        \\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,piles,1,0);\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 530127,
                "title": "python3-top-down-dp",
                "content": "Algorithm: \\nDefine `fn(i, m)` as the net winning stones when a player is at `i` with `m`. Let `X` and `Y` be Alex and Lee\\'s stones respectively. Then, \\n\\n`X - Y = fn(0, 1)` and `X + Y = sum(piles)`.\\n\\nAs a result, `X = (fn(0, 1) + sum(piles))//2`. \\n\\nImplementation (68ms, 68.40%): \\n```\\nfrom functools import lru_cache \\n\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i, m):\\n            \"\"\"Return the net stones one could get at position i with m\"\"\"\\n            if len(piles) - i <= 2*m: return sum(piles[i:])\\n            return max(sum(piles[i:i+j])-fn(i+j, max(m, j)) for j in range(1, 2*m+1))\\n        \\n        return (fn(0, 1) + sum(piles))//2\\n```\\n\\nAnalysis:\\nTime complexity `O(N^2)`\\nSpace complexity `O(N^2)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import lru_cache \\n\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i, m):\\n            \"\"\"Return the net stones one could get at position i with m\"\"\"\\n            if len(piles) - i <= 2*m: return sum(piles[i:])\\n            return max(sum(piles[i:i+j])-fn(i+j, max(m, j)) for j in range(1, 2*m+1))\\n        \\n        return (fn(0, 1) + sum(piles))//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563314,
                "title": "diagram-image-explaination-c-full-optimized-dp-well-explained",
                "content": "# Optimsed\\n \\n![code2flow_4fd67K (6).png](https://assets.leetcode.com/users/images/b2009ce4-7b5e-497a-a088-5d46b3a719be_1685059975.8692973.png)\\n# Bruteforce\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![code2flow_4fd67K (5).png](https://assets.leetcode.com/users/images/e54987d7-9c2d-417d-ac33-d360e172c839_1685059451.0453732.png)\\n\\n\\n# Approach(Bruteforce)\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n- The function `stoneGameII` takes a vector `piles` as input and returns an integer.\\n- It initializes a 2D vector `dp` with dimensions `(length + 1) x (length + 1)` and a 1D vector `sufsum` with length `length + 1`.\\n- It calculates the suffix sum of the input vector `piles` and stores it in the `sufsum` vector.\\n- It initializes the last column of the `dp` table with the suffix sum of the corresponding row in `sufsum`.\\n- It then iterates through the `dp` table from right to left, bottom to top, and calculates the optimal score for each player starting from a certain index and with a certain number of stones.\\n- It does this by simulating all possible moves for the current player and selecting the one that maximizes their score.\\n- Finally, it returns the optimal score for player 1 starting from index 0 with 1 stone.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Approach (optmised)\\n\\n\\n- The `stoneGameII` function initializes a memoization table `dp` and a suffix sum vector `sufsum`, and then calls the `helper` function with initial parameters.\\n- The `helper` function takes the memoization table, suffix sum vector, current index, and maximum number of stones as input, and returns the optimal score for player 1 starting from the current index with the given maximum number of stones.\\n- The `helper` function checks if the result is already stored in the memoization table, and returns it if it is.\\n- Otherwise, it calculates the optimal score by simulating all possible moves for player 1 and selecting the one that minimizes their opponent\\'s score.\\n- It then stores the result in the memoization table and returns it.\\n- The time complexity of this optimized algorithm is O(n^2), and the space complexity is also O(n^2).\\n# Optimised \\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int length = piles.size();\\n        vector<vector<int>> dp(length + 1, vector<int>(length + 1,0));\\n        vector<int> sufsum (length + 1, 0);\\n        for (int i = length - 1; i >= 0; i--) {\\n            sufsum[i] = sufsum[i + 1] + piles[i];\\n        }\\n        return helper(dp, sufsum, 0, 1);\\n    }\\n    \\n    int helper(vector<vector<int>>& dp, vector<int>& sufsum, int i, int M) {\\n        if (i == sufsum.size()) return 0;\\n        if (2*M >= sufsum.size() - i) return sufsum[i];\\n        if (dp[i][M] != 0) return dp[i][M];\\n        int res = INT_MAX;\\n        for (int X = 1; X <= 2*M; X++) {\\n            res = min(res, helper(dp, sufsum, i+X, max(X,M)));\\n        }\\n        dp[i][M] = sufsum[i] - res;\\n        return dp[i][M];\\n    }\\n};\\n\\n```\\n# Code (bruteforce)\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int length = piles.size();\\n        vector<vector<int>>dp(length + 1, vector<int>(length + 1,0));\\n        vector<int> sufsum (length + 1, 0);\\n        for (int i = length - 1; i >= 0; i--) {\\n            sufsum[i] = sufsum[i + 1] + piles[i];\\n        }\\n        for (int i = 0; i <= length; i++) {\\n            dp[i][length] = sufsum[i];\\n        }\\n        for (int i = length - 1; i >= 0; i--) {\\n            for (int j = length - 1; j >= 1; j--) {\\n                for (int X = 1; X <= 2 * j && i + X <= length; X++) {\\n                    dp[i][j] = max(dp[i][j], sufsum[i] - dp[i + X][max(j, X)]);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/8d7d2a35-9a97-4b52-b733-2a120823223f_1685059666.400374.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int length = piles.size();\\n        vector<vector<int>> dp(length + 1, vector<int>(length + 1,0));\\n        vector<int> sufsum (length + 1, 0);\\n        for (int i = length - 1; i >= 0; i--) {\\n            sufsum[i] = sufsum[i + 1] + piles[i];\\n        }\\n        return helper(dp, sufsum, 0, 1);\\n    }\\n    \\n    int helper(vector<vector<int>>& dp, vector<int>& sufsum, int i, int M) {\\n        if (i == sufsum.size()) return 0;\\n        if (2*M >= sufsum.size() - i) return sufsum[i];\\n        if (dp[i][M] != 0) return dp[i][M];\\n        int res = INT_MAX;\\n        for (int X = 1; X <= 2*M; X++) {\\n            res = min(res, helper(dp, sufsum, i+X, max(X,M)));\\n        }\\n        dp[i][M] = sufsum[i] - res;\\n        return dp[i][M];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int length = piles.size();\\n        vector<vector<int>>dp(length + 1, vector<int>(length + 1,0));\\n        vector<int> sufsum (length + 1, 0);\\n        for (int i = length - 1; i >= 0; i--) {\\n            sufsum[i] = sufsum[i + 1] + piles[i];\\n        }\\n        for (int i = 0; i <= length; i++) {\\n            dp[i][length] = sufsum[i];\\n        }\\n        for (int i = length - 1; i >= 0; i--) {\\n            for (int j = length - 1; j >= 1; j--) {\\n                for (int X = 1; X <= 2 * j && i + X <= length; X++) {\\n                    dp[i][j] = max(dp[i][j], sufsum[i] - dp[i + X][max(j, X)]);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276403,
                "title": "java-simple-and-easy-dp-memoization-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    \\n    Integer[][] cache;\\n    \\n    public int stoneGameII(int[] piles) {\\n        \\n        cache = new Integer[piles.length][piles.length * 2];\\n        \\n        int totalStones = 0;\\n        for(int stones : piles) totalStones += stones;\\n        \\n        //(Alice\\'s Stone + Bob\\'s Stone) = totalStones\\n        //(Alice\\'s Stone - Bob\\'s Stone) = Alice\\'s score\\n        \\n        // 2 * Alice\\'s Stone = totalStones + Alice\\'s score\\n        //Alice\\'s Stone      = (totalStones + Alice\\'s score) / 2\\n        \\n        return (totalStones + getAliceScore(piles, 0, 1)) / 2;\\n    }\\n    \\n    private int getAliceScore(int[] piles, int index, int M){\\n        if(index == piles.length) return 0;\\n        \\n        \\n        if(cache[index][M] != null) return cache[index][M];\\n        \\n        int maxScore = Integer.MIN_VALUE;\\n        \\n        int stone = 0;\\n        \\n        for(int x = 0; x < 2 * M; x++){\\n            int i = index + x;\\n            \\n            if(i >= piles.length) continue;\\n            \\n            stone += piles[i];\\n\\n            //calculate score\\n            int score = stone - getAliceScore(piles, i + 1, Math.max(x + 1, M));\\n            \\n            //update score\\n            maxScore = Math.max(maxScore, score);\\n        }\\n        \\n        return cache[index][M] = maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Integer[][] cache;\\n    \\n    public int stoneGameII(int[] piles) {\\n        \\n        cache = new Integer[piles.length][piles.length * 2];\\n        \\n        int totalStones = 0;\\n        for(int stones : piles) totalStones += stones;\\n        \\n        //(Alice\\'s Stone + Bob\\'s Stone) = totalStones\\n        //(Alice\\'s Stone - Bob\\'s Stone) = Alice\\'s score\\n        \\n        // 2 * Alice\\'s Stone = totalStones + Alice\\'s score\\n        //Alice\\'s Stone      = (totalStones + Alice\\'s score) / 2\\n        \\n        return (totalStones + getAliceScore(piles, 0, 1)) / 2;\\n    }\\n    \\n    private int getAliceScore(int[] piles, int index, int M){\\n        if(index == piles.length) return 0;\\n        \\n        \\n        if(cache[index][M] != null) return cache[index][M];\\n        \\n        int maxScore = Integer.MIN_VALUE;\\n        \\n        int stone = 0;\\n        \\n        for(int x = 0; x < 2 * M; x++){\\n            int i = index + x;\\n            \\n            if(i >= piles.length) continue;\\n            \\n            stone += piles[i];\\n\\n            //calculate score\\n            int score = stone - getAliceScore(piles, i + 1, Math.max(x + 1, M));\\n            \\n            //update score\\n            maxScore = Math.max(maxScore, score);\\n        }\\n        \\n        return cache[index][M] = maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564051,
                "title": "stone-game-ii-dynamic-programming-solution",
                "content": "To solve the Stone Game II problem optimally, we can use dynamic programming. Let\\'s define a 2D dp array where dp[i][m] represents the maximum number of stones Alice can get if the game starts at pile i and the value of M is m.\\n\\nTo fill in the dp array, we need to iterate from the last pile to the first pile and from the maximum value of M to 1. At each position (i, m), we calculate the maximum number of stones Alice can get based on the choices she can make.\\n\\nThe formula to calculate dp[i][m] is as follows:\\ndp[i][m] = max(sum(piles[i:]) - dp[i + x][max(m, x)]) for x in range(1, 2*m + 1)\\n\\nHere, sum(piles[i:]) represents the total number of stones from pile i to the end. dp[i + x][max(m, x)] represents the maximum number of stones Alice can get starting from the next pile (i + x) with a new value of M as max(m, x). We subtract this value from the total sum to calculate the number of stones Alice can get from pile i.\\n\\nFinally, the result will be stored in dp[0][1], which represents the maximum number of stones Alice can get if she starts at the first pile with M = 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(n + 1, 0));\\n        vector<int> suffixSum(n + 1, 0);\\n\\n        // Calculating suffix sums \\n        for (int i = n - 1; i >= 0; i--)\\n            suffixSum[i] = suffixSum[i + 1] + piles[i];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int m = 1; m <= n; m++) {\\n                if (i + 2 * m >= n) {\\n                    dp[i][m] = suffixSum[i];\\n                } else {\\n                    for (int x = 1; x <= 2 * m; x++) {\\n                        dp[i][m] = max(dp[i][m], suffixSum[i] - dp[i + x][max(m, x)]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\nThe code initializes the dp array and the suffixSum array. The suffixSum array is used to calculate the cumulative sum of stones from the current pile to the end. Then, using the nested loops, the code fills in the dp array based on the defined formula. Finally, it returns dp[0][1], which represents the maximum number of stones Alice can get if she starts at the first pile with M = 1.\\n\\nThe time complexity of this solution is O(n^3), where n is the number of piles. The space complexity is O(n^2) for the dp array and O(n) for the suffixSum array.\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(n + 1, 0));\\n        vector<int> suffixSum(n + 1, 0);\\n\\n        // Calculating suffix sums \\n        for (int i = n - 1; i >= 0; i--)\\n            suffixSum[i] = suffixSum[i + 1] + piles[i];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int m = 1; m <= n; m++) {\\n                if (i + 2 * m >= n) {\\n                    dp[i][m] = suffixSum[i];\\n                } else {\\n                    for (int x = 1; x <= 2 * m; x++) {\\n                        dp[i][m] = max(dp[i][m], suffixSum[i] - dp[i + x][max(m, x)]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887807,
                "title": "c-recursive-dp-minimax-solution-explained",
                "content": "Runtime: 4 ms, faster than 95.95% of C++ online submissions for Stone Game II.\\nMemory Usage: 7.2 MB, less than 5.42% of C++ online submissions for Stone Game II.\\n\\nProblem is similar to Stone Game problem and so as the solution. As we only need Alex\\'s optimal max \\nstone collection amount, we can ignore the value of Lee\\'s stone collection amount in case of Lee\\'s turn\\nand just minimizing the Alex\\'s stone collection as both plays optimally. Alex will maximize his stone\\ncollection and Lee will minimize Alex\\'s stone collection.\\n\\nDP state in this problem would be : start_index, M and Player => <start,M,player>\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // 3D dp array holds result for state <start,M,player>\\n    int dp[105][105][2];\\n    \\n    // returns max stone Alex can gather when bot Alex and Lee plays optimally \\n    int takeStone(int l, int h, int M, int player, vector<int>& piles)\\n    {\\n        // no stone to collect and so return 0\\n        if(l>h) return 0;\\n        \\n        // return precalculated result\\n        if(dp[l][M][player]!=-1) return dp[l][M][player];\\n        \\n        // max stone collected by Alex \\n        int stones;\\n        \\n        // Alex\\'s tuen, Alex tries to maximize the stone collection\\n        if(player==0)\\n        {\\n            stones = INT_MIN;\\n            int takenStones = 0;\\n            \\n            // call recursion from x = 1 to min(h,2*M) by taking value piles[x+l] in each case\\n            // return max stone collection when Alex and Lee both plays optimally in next steps\\n            for(int x=1; x<=(2*M) && (l+x-1)<=h; x++)\\n            {\\n                takenStones+= piles[l+x-1];\\n                stones = max(stones,takenStones + takeStone(l+x,h,max(M,x),1-player,piles));\\n            }            \\n        }\\n        else\\n        {\\n            stones = INT_MAX;\\n            \\n            // Lee tries to minimize Alex\\'s result by taking the minimum value from recursion call\\n            // As we only need Alex\\'s stone collection we ignore the stone collection of Lee in this case\\n            for(int x=1; x<= (2*M) && (l+x-1)<=h; x++)\\n            {\\n                stones = min(stones, takeStone(l+x,h,max(M,x),1-player,piles));                \\n            }\\n        }\\n        \\n        return dp[l][M][player] = stones;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        \\n        // initialize dp array with -1\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // start game with first turn of Alex and M =1\\n        // player == 0 => Alex ; player == 1 => Lee\\n        return takeStone(0,piles.size()-1,1,0,piles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // 3D dp array holds result for state <start,M,player>\\n    int dp[105][105][2];\\n    \\n    // returns max stone Alex can gather when bot Alex and Lee plays optimally \\n    int takeStone(int l, int h, int M, int player, vector<int>& piles)\\n    {\\n        // no stone to collect and so return 0\\n        if(l>h) return 0;\\n        \\n        // return precalculated result\\n        if(dp[l][M][player]!=-1) return dp[l][M][player];\\n        \\n        // max stone collected by Alex \\n        int stones;\\n        \\n        // Alex\\'s tuen, Alex tries to maximize the stone collection\\n        if(player==0)\\n        {\\n            stones = INT_MIN;\\n            int takenStones = 0;\\n            \\n            // call recursion from x = 1 to min(h,2*M) by taking value piles[x+l] in each case\\n            // return max stone collection when Alex and Lee both plays optimally in next steps\\n            for(int x=1; x<=(2*M) && (l+x-1)<=h; x++)\\n            {\\n                takenStones+= piles[l+x-1];\\n                stones = max(stones,takenStones + takeStone(l+x,h,max(M,x),1-player,piles));\\n            }            \\n        }\\n        else\\n        {\\n            stones = INT_MAX;\\n            \\n            // Lee tries to minimize Alex\\'s result by taking the minimum value from recursion call\\n            // As we only need Alex\\'s stone collection we ignore the stone collection of Lee in this case\\n            for(int x=1; x<= (2*M) && (l+x-1)<=h; x++)\\n            {\\n                stones = min(stones, takeStone(l+x,h,max(M,x),1-player,piles));                \\n            }\\n        }\\n        \\n        return dp[l][M][player] = stones;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        \\n        // initialize dp array with -1\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // start game with first turn of Alex and M =1\\n        // player == 0 => Alex ; player == 1 => Lee\\n        return takeStone(0,piles.size()-1,1,0,piles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799145,
                "title": "javascript-solution-top-down-approach-with-memoization",
                "content": "I didn\\'t come up with the solution, but I thought it would be helpful to put up a solution translated to JavaScript. I also added some comments below to hopefully make it more understandable.\\n\\n```\\nvar stoneGameII = function(piles) {\\n    const n = piles.length;\\n    const memo = new Map();\\n    const sums = new Array(n).fill(0);\\n\\t\\n    sums[n - 1] = piles[n - 1];\\n    \\n    for (let i = n - 2; i >= 0; i--) {\\n        sums[i] = sums[i + 1] + piles[i]; // (1)\\n    }\\n    \\n    return findMax(0, 1);\\n    \\n    function findMax(index, M) { // (2)\\n        const key = `${index}#${M}`;\\n        \\n        // base case\\n        if (n - index <= 2 * M) return sums[index]; // (3)\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        let res = Number.MIN_SAFE_INTEGER;\\n        \\n        for (let x = 1; x <= 2 * M; x++) { // (4)\\n            const newM = Math.max(x, M); // (5)\\n            res = Math.max(res, sums[index] - findMax(index + x, newM)); // (6)\\n        }\\n        \\n        memo.set(key, res);\\n        return res;\\n    }\\n};\\n\\n\\n/* \\nComments:\\n\\n(1) sums[i] = piles[i] + sum(piles[i + 1], piles[i + 2], ... piles[n - 1]).\\n\\n(2) You can think of index as the starting position of the stone piles that are remaining. So at beginning, where index = 0,\\n\\twe have all the original piles left. If index = 2, then we have the piles[2] ... piles[n - 1] unclaimed.\\n\\n(3) In this case the current move will be the last move. Therefore, knowing this, a player will want to take advantage of this \\n\\tinformation by taken the remaining piles.\\n\\n(4) A player at any point in the game will have the option of taking x piles, where 1 <= x <= 2M. If the # of remaining piles is less\\n\\tthan 2M, the if conditional clause at (3) takes care of it.\\n\\n(5) M, which initially equals 1, is the value used to set the limitation of stone piles a player can take at each turn. \\n\\tThe value gets updated to M = Math.max(x, M) and the limit of stone piles is doubled based on the new value of M. \\n\\n(6) As x increases, the current player is taking more piles.\\n\\n*/\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```\\nvar stoneGameII = function(piles) {\\n    const n = piles.length;\\n    const memo = new Map();\\n    const sums = new Array(n).fill(0);\\n\\t\\n    sums[n - 1] = piles[n - 1];\\n    \\n    for (let i = n - 2; i >= 0; i--) {\\n        sums[i] = sums[i + 1] + piles[i]; // (1)\\n    }\\n    \\n    return findMax(0, 1);\\n    \\n    function findMax(index, M) { // (2)\\n        const key = `${index}#${M}`;\\n        \\n        // base case\\n        if (n - index <= 2 * M) return sums[index]; // (3)\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        let res = Number.MIN_SAFE_INTEGER;\\n        \\n        for (let x = 1; x <= 2 * M; x++) { // (4)\\n            const newM = Math.max(x, M); // (5)\\n            res = Math.max(res, sums[index] - findMax(index + x, newM)); // (6)\\n        }\\n        \\n        memo.set(key, res);\\n        return res;\\n    }\\n};\\n\\n\\n/* \\nComments:\\n\\n(1) sums[i] = piles[i] + sum(piles[i + 1], piles[i + 2], ... piles[n - 1]).\\n\\n(2) You can think of index as the starting position of the stone piles that are remaining. So at beginning, where index = 0,\\n\\twe have all the original piles left. If index = 2, then we have the piles[2] ... piles[n - 1] unclaimed.\\n\\n(3) In this case the current move will be the last move. Therefore, knowing this, a player will want to take advantage of this \\n\\tinformation by taken the remaining piles.\\n\\n(4) A player at any point in the game will have the option of taking x piles, where 1 <= x <= 2M. If the # of remaining piles is less\\n\\tthan 2M, the if conditional clause at (3) takes care of it.\\n\\n(5) M, which initially equals 1, is the value used to set the limitation of stone piles a player can take at each turn. \\n\\tThe value gets updated to M = Math.max(x, M) and the limit of stone piles is doubled based on the new value of M. \\n\\n(6) As x increases, the current player is taking more piles.\\n\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345264,
                "title": "java-dp-with-memoization",
                "content": "```\\npublic int stoneGameII(int[] piles) {\\n\\t\\t// calculate the sum from 0 to current index i\\n        for(int i=1;i<piles.length;i++)\\n            piles[i]=piles[i-1]+piles[i];\\n\\t    // use HashMap to cache the max value that the adversary can get, which is associated with M plus current position i\\n        HashMap<String,Integer> cache=new HashMap<>();\\n        return dfs(1,0,piles,cache);\\n    }\\n    int dfs(int M, int i, int[] piles,HashMap<String,Integer> cache){\\n\\t\\t// base case\\n        if(piles.length==i) return 0;\\n        if(cache.containsKey(M+\" \"+i)) return cache.get(M+\" \"+i);\\n\\t\\t// \\'max\\' refers to the max value that the current player can get\\n        int max=-1;\\n\\t\\t// because we start from index i, we calculate the max value from i to end, therefore, we need to calculate the sum from i to end, the sum of (i, end) if piles[piles.length-1]-preSum \\n        int preSum=i-1<0?0:piles[i-1];\\n\\t\\t// try every possibility, [1:2M]\\n        for(int k=0;k<=2*M-1;k++){\\n            if(k+i==piles.length) break;\\n\\t\\t\\t// this is the value that current player can get from next round, which is returned by opponent \\n            int next=dfs(Math.max(k+1,M),i+k+1,piles,cache);\\n            int count=next+piles[k+i]-preSum;\\n\\t\\t\\t// find the max value\\n            max=Math.max(max, count);\\n        }\\n\\t\\t// this is the value that opponent can get \\n        int nextValue=piles[piles.length-1]-preSum-max; \\n\\t\\t// cache\\n        cache.put(M+\" \"+i,nextValue);\\n        if(i==0) return max;\\n        return nextValue;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int stoneGameII(int[] piles) {\\n\\t\\t// calculate the sum from 0 to current index i\\n        for(int i=1;i<piles.length;i++)\\n            piles[i]=piles[i-1]+piles[i];\\n\\t    // use HashMap to cache the max value that the adversary can get, which is associated with M plus current position i\\n        HashMap<String,Integer> cache=new HashMap<>();\\n        return dfs(1,0,piles,cache);\\n    }\\n    int dfs(int M, int i, int[] piles,HashMap<String,Integer> cache){\\n\\t\\t// base case\\n        if(piles.length==i) return 0;\\n        if(cache.containsKey(M+\" \"+i)) return cache.get(M+\" \"+i);\\n\\t\\t// \\'max\\' refers to the max value that the current player can get\\n        int max=-1;\\n\\t\\t// because we start from index i, we calculate the max value from i to end, therefore, we need to calculate the sum from i to end, the sum of (i, end) if piles[piles.length-1]-preSum \\n        int preSum=i-1<0?0:piles[i-1];\\n\\t\\t// try every possibility, [1:2M]\\n        for(int k=0;k<=2*M-1;k++){\\n            if(k+i==piles.length) break;\\n\\t\\t\\t// this is the value that current player can get from next round, which is returned by opponent \\n            int next=dfs(Math.max(k+1,M),i+k+1,piles,cache);\\n            int count=next+piles[k+i]-preSum;\\n\\t\\t\\t// find the max value\\n            max=Math.max(max, count);\\n        }\\n\\t\\t// this is the value that opponent can get \\n        int nextValue=piles[piles.length-1]-preSum-max; \\n\\t\\t// cache\\n        cache.put(M+\" \"+i,nextValue);\\n        if(i==0) return max;\\n        return nextValue;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738142,
                "title": "python-bottom-up-with-in-code-explanation",
                "content": "The solution below is based on the code by [@cychung](https://leetcode.com/problems/stone-game-ii/discuss/705851/DP-bottom-up-%2B-top-down-solution-with-time-space-complexity), kudos to him/her\\n\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        if not piles:\\n            return 0\\n        \\n        n = len(piles)        \\n        # dp array to store intermediate results\\n        dp = [[0]*(n+1) for i in range(n)]\\n        \\n        # compute suffix sum to quickly find the sum of the elements between the two points\\n        for j in range(n-2,-1,-1):\\n            piles[j]+=piles[j+1]\\n                    \\n        # for every possible suffix check all possible values of m and x(derived from x)\\n        # and find optimal solutions for every point.\\n        # we can have at most n turns, and players at every step are playing optimal = choose x \\n        # which maximizes the outcome\\n        for i in range(n-1,-1,-1):\\n            for m in range(n,0,-1):\\n                for x in range(1, 2*m+1):\\n                    # both playing optimal, so we either get all elements if go beyond the arrays\\' limit\\n                    # or have to subtract the best possible value of the next player\\'s move we\\'ve seen.\\n                    # the piles[i] suffix sum is the best possible value we can get for any suffix, so we\\n                    # subtract optimal value for suffix [i+x] calculated for the corresponding \\n                    # \"next\" m =  max(x,m)\\n                    # (remember we are going backwards from the tail)\\n                    val = piles[i] - dp[i+x][max(x,m)] if i+x<n else piles[i]\\n                    dp[i][m]=max(dp[i][m],val)\\n            \\n        #return the max stones possible for the first player\\n        return dp[0][1] \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        if not piles:\\n            return 0\\n        \\n        n = len(piles)        \\n        # dp array to store intermediate results\\n        dp = [[0]*(n+1) for i in range(n)]\\n        \\n        # compute suffix sum to quickly find the sum of the elements between the two points\\n        for j in range(n-2,-1,-1):\\n            piles[j]+=piles[j+1]\\n                    \\n        # for every possible suffix check all possible values of m and x(derived from x)\\n        # and find optimal solutions for every point.\\n        # we can have at most n turns, and players at every step are playing optimal = choose x \\n        # which maximizes the outcome\\n        for i in range(n-1,-1,-1):\\n            for m in range(n,0,-1):\\n                for x in range(1, 2*m+1):\\n                    # both playing optimal, so we either get all elements if go beyond the arrays\\' limit\\n                    # or have to subtract the best possible value of the next player\\'s move we\\'ve seen.\\n                    # the piles[i] suffix sum is the best possible value we can get for any suffix, so we\\n                    # subtract optimal value for suffix [i+x] calculated for the corresponding \\n                    # \"next\" m =  max(x,m)\\n                    # (remember we are going backwards from the tail)\\n                    val = piles[i] - dp[i+x][max(x,m)] if i+x<n else piles[i]\\n                    dp[i][m]=max(dp[i][m],val)\\n            \\n        #return the max stones possible for the first player\\n        return dp[0][1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 713502,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nUse dynamic programming to find the optimal solution by maximizing each player\\'s score.  Each time a recursive call is made, is it the opponent\\'s turn, so subtract the player\\'s maximum score from the recursively computed opponent\\'s maximum score.  After the recursive stack unwinds, we find the overall maximum score for the first player.\\n\\n[\\uD83C\\uDFA8 The **ART** of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n**Note:** Prerequisites to properly understanding this solution are a handful of [game theory](https://en.wikipedia.org/wiki/Game_theory) concepts:\\n* [Zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game)\\n* [Minimax (in Zero-sum games)](https://en.wikipedia.org/wiki/Minimax#In_zero-sum_games)\\n* [Nash Equilibrium](https://en.wikipedia.org/wiki/Nash_equilibrium)\\n\\n---\\n\\n**Top-Down Brute-Force** (TLE)\\n\\n*Javascript*\\n```\\nlet stoneGameII = A => {\\n    let N = A.length;\\n    let go = (i, k, total, take = 0, max = 0) => {\\n        for (let j = i, stones = 1; j < Math.min(i + 2 * k, N); ++j, ++stones) // take each j-th stone until \\uD83D\\uDED1 base case: j == min(i + 2 * k, N)\\n            max = Math.max(max, total - go(j + 1, Math.max(k, stones), total - (take += A[j]))); // \\uD83C\\uDFAF max my score minus max your score\\n        return max;\\n    };\\n    return go(0, 1, A.reduce((a, b) => a + b)); // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    VI A;\\n    int N;\\n    int go(int i, int k, int total, int take = 0, int max = 0) {\\n        for (auto j{ i }, stones{ 1 }; j < min(i + 2 * k, N); ++j, ++stones) // take each j-th stone until \\uD83D\\uDED1 base case: j == min(i + 2 * k, N)\\n            max = std::max(max, total - go(j + 1, std::max(k, stones), total - (take += A[j]))); // \\uD83C\\uDFAF max my score minus max your score\\n        return max;\\n    }\\npublic:\\n    int stoneGameII(VI& A_) {\\n        A = A_;\\n        N = A.size();\\n        return go(0, 1, accumulate(A.begin(), A.end(), 0)); // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n    }\\n};\\n```\\n\\n---\\n\\n**Top-Down with Memo** (AC)\\n\\n*Javascript*\\n```\\nlet stoneGameII = A => {\\n    let N = A.length;\\n    let m = [...Array(N + 1)].map(_ => Array(N + 1).fill(0));\\n    let go = (i, k, total, take = 0) => {\\n        if (m[i][k])\\n            return m[i][k]; // \\uD83E\\uDD14 memo\\n        for (let j = i, stones = 1; j < Math.min(i + 2 * k, N); ++j, ++stones) // take each j-th stone until \\uD83D\\uDED1 base case: j == min(i + 2 * k, N)\\n            m[i][k] = Math.max(m[i][k], total - go(j + 1, Math.max(k, stones), total - (take += A[j]))); // \\uD83C\\uDFAF max my score minus max your score\\n        return m[i][k];\\n    };\\n    return go(0, 1, A.reduce((a, b) => a + b)); // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, unordered_map<int, int>>;\\n    VI A;\\n    int N;\\n    int go(int i, int k, int total, Map&& m = {}, int take = 0) {\\n        if (m[i][k])\\n            return m[i][k]; // \\uD83E\\uDD14 memo\\n        for (auto j{ i }, stones{ 1 }; j < min(i + 2 * k, N); ++j, ++stones) // take each j-th stone until \\uD83D\\uDED1 base case: j == min(i + 2 * k, N)\\n            m[i][k] = std::max(m[i][k], total - go(j + 1, std::max(k, stones), total - (take += A[j]), move(m))); // \\uD83C\\uDFAF max my score minus max your score\\n        return m[i][k];\\n    }\\npublic:\\n    int stoneGameII(VI& A_) {\\n        A = A_;\\n        N = A.size();\\n        return go(0, 1, accumulate(A.begin(), A.end(), 0)); // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n    }\\n};\\n```\\n\\n---\\n\\n**Bottom-Up** (AC)\\n\\n*Javascript*\\n```\\nlet stoneGameII = A => {\\n    let N = A.length;\\n    let dp = [...Array(N + 1)].map(_ => Array(N + 1).fill(0)); // \\uD83E\\uDD14 dp[i][j] == best total possible beginning at i, taking up to max(j, k) stones\\n    let total = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        dp[i][N] = total[i] = total[i + 1] + A[i]; // \\uD83D\\uDED1  base cases: suffix sums, ie. if j == N, then initial state of \"no stones taken\"\\n    for (let i = N - 1; 0 <= i; --i)\\n        for (let k = N - 1; 1 <= k; --k)\\n            for (let j = 1; j <= 2 * k && i + j <= N; ++j)\\n                dp[i][k] = Math.max(dp[i][k], total[i] - dp[i + j][Math.max(j, k)]); // \\uD83C\\uDFAF max my score minus max your score\\n    return dp[0][1]; // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int stoneGameII(VI& A) {\\n        int N = A.size();\\n        VVI dp(N + 1, VI(N + 1)); // \\uD83E\\uDD14 dp[i][j] == best total possible beginning at i, taking up to max(j, k) stones\\n        VI total(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            dp[i][N] = total[i] = total[i + 1] + A[i];  // \\uD83D\\uDED1  base cases: suffix sums, ie. if j == N, then initial state of \"no stones taken\"\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            for (auto k{ N - 1 }; 1 <= k; --k)\\n                for (auto j{ 1 }; j <= 2 * k && i + j <= N; ++j)\\n                    dp[i][k] = max(dp[i][k], total[i] - dp[i + j][max(j, k)]); // \\uD83C\\uDFAF max my score minus max your score\\n        return dp[0][1]; // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet stoneGameII = A => {\\n    let N = A.length;\\n    let go = (i, k, total, take = 0, max = 0) => {\\n        for (let j = i, stones = 1; j < Math.min(i + 2 * k, N); ++j, ++stones) // take each j-th stone until \\uD83D\\uDED1 base case: j == min(i + 2 * k, N)\\n            max = Math.max(max, total - go(j + 1, Math.max(k, stones), total - (take += A[j]))); // \\uD83C\\uDFAF max my score minus max your score\\n        return max;\\n    };\\n    return go(0, 1, A.reduce((a, b) => a + b)); // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    VI A;\\n    int N;\\n    int go(int i, int k, int total, int take = 0, int max = 0) {\\n        for (auto j{ i }, stones{ 1 }; j < min(i + 2 * k, N); ++j, ++stones) // take each j-th stone until \\uD83D\\uDED1 base case: j == min(i + 2 * k, N)\\n            max = std::max(max, total - go(j + 1, std::max(k, stones), total - (take += A[j]))); // \\uD83C\\uDFAF max my score minus max your score\\n        return max;\\n    }\\npublic:\\n    int stoneGameII(VI& A_) {\\n        A = A_;\\n        N = A.size();\\n        return go(0, 1, accumulate(A.begin(), A.end(), 0)); // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n    }\\n};\\n```\n```\\nlet stoneGameII = A => {\\n    let N = A.length;\\n    let m = [...Array(N + 1)].map(_ => Array(N + 1).fill(0));\\n    let go = (i, k, total, take = 0) => {\\n        if (m[i][k])\\n            return m[i][k]; // \\uD83E\\uDD14 memo\\n        for (let j = i, stones = 1; j < Math.min(i + 2 * k, N); ++j, ++stones) // take each j-th stone until \\uD83D\\uDED1 base case: j == min(i + 2 * k, N)\\n            m[i][k] = Math.max(m[i][k], total - go(j + 1, Math.max(k, stones), total - (take += A[j]))); // \\uD83C\\uDFAF max my score minus max your score\\n        return m[i][k];\\n    };\\n    return go(0, 1, A.reduce((a, b) => a + b)); // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, unordered_map<int, int>>;\\n    VI A;\\n    int N;\\n    int go(int i, int k, int total, Map&& m = {}, int take = 0) {\\n        if (m[i][k])\\n            return m[i][k]; // \\uD83E\\uDD14 memo\\n        for (auto j{ i }, stones{ 1 }; j < min(i + 2 * k, N); ++j, ++stones) // take each j-th stone until \\uD83D\\uDED1 base case: j == min(i + 2 * k, N)\\n            m[i][k] = std::max(m[i][k], total - go(j + 1, std::max(k, stones), total - (take += A[j]), move(m))); // \\uD83C\\uDFAF max my score minus max your score\\n        return m[i][k];\\n    }\\npublic:\\n    int stoneGameII(VI& A_) {\\n        A = A_;\\n        N = A.size();\\n        return go(0, 1, accumulate(A.begin(), A.end(), 0)); // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n    }\\n};\\n```\n```\\nlet stoneGameII = A => {\\n    let N = A.length;\\n    let dp = [...Array(N + 1)].map(_ => Array(N + 1).fill(0)); // \\uD83E\\uDD14 dp[i][j] == best total possible beginning at i, taking up to max(j, k) stones\\n    let total = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        dp[i][N] = total[i] = total[i + 1] + A[i]; // \\uD83D\\uDED1  base cases: suffix sums, ie. if j == N, then initial state of \"no stones taken\"\\n    for (let i = N - 1; 0 <= i; --i)\\n        for (let k = N - 1; 1 <= k; --k)\\n            for (let j = 1; j <= 2 * k && i + j <= N; ++j)\\n                dp[i][k] = Math.max(dp[i][k], total[i] - dp[i + j][Math.max(j, k)]); // \\uD83C\\uDFAF max my score minus max your score\\n    return dp[0][1]; // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int stoneGameII(VI& A) {\\n        int N = A.size();\\n        VVI dp(N + 1, VI(N + 1)); // \\uD83E\\uDD14 dp[i][j] == best total possible beginning at i, taking up to max(j, k) stones\\n        VI total(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            dp[i][N] = total[i] = total[i + 1] + A[i];  // \\uD83D\\uDED1  base cases: suffix sums, ie. if j == N, then initial state of \"no stones taken\"\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            for (auto k{ N - 1 }; 1 <= k; --k)\\n                for (auto j{ 1 }; j <= 2 * k && i + j <= N; ++j)\\n                    dp[i][k] = max(dp[i][k], total[i] - dp[i + j][max(j, k)]); // \\uD83C\\uDFAF max my score minus max your score\\n        return dp[0][1]; // \\u2B50\\uFE0F max total possible beginning with the first stone at i = 0 taking the best 2k stones beginning at k = 1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697035,
                "title": "simple-cpp-solution",
                "content": "Runtime: 8 ms, faster than 70.67% of C++ online submissions for Stone Game II.\\nMemory Usage: 7.3 MB, less than 68.68% of C++ online submissions for Stone Game II.\\n```\\n    class Solution {\\n    int helper(vector<int>& piles, int index, int m, int n, int total, vector<vector<int>> &dp){\\n        if(index >= n) return 0;\\n        if(dp[index][m] != -1) return dp[index][m];\\n        int i;\\n        int myScore = INT_MIN;\\n        int sum = 0;\\n        for(int i = 1; i <= 2*m && index + i -1 < n; i++){ // given in the question : On each player\\'s turn,\\n\\t\\t//that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M. \\n\\t\\t//Then, we set M = max(M, X).\\n\\t\\t// so we are taking index ranging from our start to 2*m but it should be less than the size of the array so \\n\\t\\t//index + i -1 < n, then for each case we have to take max of m and x here x will vary from 1 to 2*m \\n\\t\\t//which is value i in loop\\n            sum += piles[index + i-1];\\n\\t\\t\\t// if player takes sum from total the next total will be total - sum\\n            myScore = max((total - helper(piles, index+i, max(m,i), n, total-sum,dp)), myScore);\\n        }\\n        dp[index][m] = myScore;\\n        return myScore;\\n    }\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        int sum = 0;\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        for(int i = 0; i < n; i++) sum += piles[i];\\n        return helper(piles,0,1,n,sum,dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int helper(vector<int>& piles, int index, int m, int n, int total, vector<vector<int>> &dp){\\n        if(index >= n) return 0;\\n        if(dp[index][m] != -1) return dp[index][m];\\n        int i;\\n        int myScore = INT_MIN;\\n        int sum = 0;\\n        for(int i = 1; i <= 2*m && index + i -1 < n; i++){ // given in the question : On each player\\'s turn,\\n\\t\\t//that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M. \\n\\t\\t//Then, we set M = max(M, X).\\n\\t\\t// so we are taking index ranging from our start to 2*m but it should be less than the size of the array so \\n\\t\\t//index + i -1 < n, then for each case we have to take max of m and x here x will vary from 1 to 2*m \\n\\t\\t//which is value i in loop\\n            sum += piles[index + i-1];\\n\\t\\t\\t// if player takes sum from total the next total will be total - sum\\n            myScore = max((total - helper(piles, index+i, max(m,i), n, total-sum,dp)), myScore);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 524631,
                "title": "c-recursion-with-memorization",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> p;\\n\\t\\tint n;\\n\\t\\tvector<vector<int>> dp;\\n\\t\\tint winDiff(int start, int m){\\n\\t\\t\\tif(start>=n) return 0;\\n\\t\\t\\tif(dp[start][m]>0) return dp[start][m];\\n\\n\\t\\t\\tif(start+2*m>=n){\\n\\t\\t\\t\\tint cur=0;\\n\\t\\t\\t\\tfor(int i=start;i<n;i++){\\n\\t\\t\\t\\t\\tcur+=p[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[start][m]=cur;\\n\\t\\t\\t\\treturn dp[start][m];\\n\\t\\t\\t}\\n\\t\\t\\tint tem=0;\\n\\t\\t\\tint ans=INT_MIN;\\n\\t\\t\\tfor(int x=1;x<=2*m;x++){\\n\\t\\t\\t\\ttem+=p[start+x-1];\\n\\t\\t\\t\\tans=max(ans,tem-winDiff(start+x,max(m,x)));\\n\\t\\t\\t}\\n\\t\\t\\tdp[start][m]=ans;\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t\\tint stoneGameII(vector<int>& piles) {\\n\\t\\t\\tp=piles;\\n\\t\\t\\tn=piles.size();\\n\\t\\t\\tdp.assign(n+1,vector<int>(n+1));\\n\\n\\t\\t\\tint tol=0;\\n\\t\\t\\tfor(auto& x:piles){\\n\\t\\t\\t\\ttol+=x;\\n\\t\\t\\t}\\n\\t\\t\\treturn (tol+winDiff(0,1))/2;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> p;\\n\\t\\tint n;\\n\\t\\tvector<vector<int>> dp;\\n\\t\\tint winDiff(int start, int m){\\n\\t\\t\\tif(start>=n) return 0;\\n\\t\\t\\tif(dp[start][m]>0) return dp[start][m];\\n\\n\\t\\t\\tif(start+2*m>=n){\\n\\t\\t\\t\\tint cur=0;\\n\\t\\t\\t\\tfor(int i=start;i<n;i++){\\n\\t\\t\\t\\t\\tcur+=p[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 345221,
                "title": "dp-with-memorization-python",
                "content": "memo[(i,M)] records most stones we can get if the list starts at i-th position and with value M.\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        self.memo = {}\\n        weight = [0]\\n        for i in range(len(piles)):\\n            weight += [weight[-1] + piles[-1-i]]\\n        weight.reverse()\\n        weight.pop()\\n        def dp(i,M):\\n            if (i,M) not in self.memo:\\n                if len(piles) - i <= 2*M:\\n                    self.memo[(i,M)]= weight[i]\\n                else:\\n                    tmp = 0\\n                    for k in range(1,2*M+1):\\n                        new_M = max(M,k)\\n                        tmp = max(tmp,weight[i]-dp(i+k,new_M))\\n                    self.memo[(i,M)] = tmp\\n            return self.memo[(i,M)]\\n        return dp(0,1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        self.memo = {}\\n        weight = [0]\\n        for i in range(len(piles)):\\n            weight += [weight[-1] + piles[-1-i]]\\n        weight.reverse()\\n        weight.pop()\\n        def dp(i,M):\\n            if (i,M) not in self.memo:\\n                if len(piles) - i <= 2*M:\\n                    self.memo[(i,M)]= weight[i]\\n                else:\\n                    tmp = 0\\n                    for k in range(1,2*M+1):\\n                        new_M = max(M,k)\\n                        tmp = max(tmp,weight[i]-dp(i+k,new_M))\\n                    self.memo[(i,M)] = tmp\\n            return self.memo[(i,M)]\\n        return dp(0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565792,
                "title": "c-java-easy-and-clean-code-dp-top-down-bottom-up-beats",
                "content": "# Please Upvote if you like my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n\\n# Complexity \\n- Time complexity: $$O(N^2)$$ where `N` is size of `piles` array. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\n    int stoneGameIIHelp(int ind, int m, vector<vector<int>> &dp, vector<int> &preSum){\\n        if( ind >= preSum.size() ) return 0;\\n        if( dp[ind][m] != -1 ) return dp[ind][m];\\n\\n        int maxi = 0, n = preSum.size();\\n        for(int x=1; x<=min(2*m, n-ind); x++)\\n            maxi = max(maxi, preSum[ind] - stoneGameIIHelp(ind+x, max(m, x), dp, preSum));\\n            \\n        return dp[ind][m] = maxi;\\n    }\\n\\npublic:\\n    // TOP DOWN\\n    int stoneGameII1(vector<int>& ps) {\\n        int n = ps.size();\\n        for(int i=n-2; i>=0; i--) ps[i] += ps[i+1];\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n        return stoneGameIIHelp(0, 1, dp, ps); \\n    }\\n\\n\\n    // Bottom Up\\n    int stoneGameII(vector<int>& preSum) {\\n        int n = preSum.size();\\n        for(int i=n-2; i>=0; i--) preSum[i] += preSum[i+1];\\n        vector<vector<int>> dp(n+1, vector<int>(n+1));\\n        \\n        for(int ind=n-1; ind>=0; ind--){\\n            for(int m = n; m>=1; m--){\\n                int maxi = 0;\\n                for(int x=1; x<=min(2*m, n-ind); x++)\\n                    maxi = max(maxi, preSum[ind] - dp[ind+x][max(m, x)]);\\n        \\n                dp[ind][m] = maxi;\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    private int stoneGameIIHelp(int ind, int m, int dp[][], int[] preSum){\\n        if( ind >= preSum.length ) return 0;\\n        if( dp[ind][m] != -1 ) return dp[ind][m];\\n\\n        int maxi = 0, n = preSum.length;\\n        for(int x=1; x <= Math.min(2*m, n-ind); x++)\\n            maxi = Math.max(maxi, preSum[ind] - stoneGameIIHelp(ind+x, Math.max(m, x), dp, preSum));\\n\\n        return dp[ind][m] = maxi;\\n    }\\n\\n\\n    // TOP DOWN\\n    public int stoneGameII1(int[] piles) {\\n        int n = piles.length;\\n        for(int i=n-2; i>=0; i--) piles[i] += piles[i+1];\\n        int dp[][] = new int[n][n+1];\\n        for(int i=0; i<n; i++) Arrays.fill(dp[i], -1);\\n        return  stoneGameIIHelp(0, 1, dp, piles);\\n    }\\n\\n\\n    // Bottom Up\\n    int stoneGameII(int[] preSum) {\\n        int n = preSum.length;\\n        for(int i=n-2; i>=0; i--) preSum[i] += preSum[i+1];\\n        int dp[][] = new int[n+1][n+1];\\n        \\n        for(int ind=n-1; ind>=0; ind--){\\n            for(int m = n; m>=1; m--){\\n                int maxi = 0;\\n                for(int x=1; x<=Math.min(2*m, n-ind); x++)\\n                    maxi = Math.max(maxi, preSum[ind] - dp[ind+x][Math.max(m, x)]);\\n        \\n                dp[ind][m] = maxi;\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n}\\n```\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/d20562b8-5ddb-40b3-8b8a-5d7a0a6f0b57_1684136359.2221565.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int stoneGameIIHelp(int ind, int m, vector<vector<int>> &dp, vector<int> &preSum){\\n        if( ind >= preSum.size() ) return 0;\\n        if( dp[ind][m] != -1 ) return dp[ind][m];\\n\\n        int maxi = 0, n = preSum.size();\\n        for(int x=1; x<=min(2*m, n-ind); x++)\\n            maxi = max(maxi, preSum[ind] - stoneGameIIHelp(ind+x, max(m, x), dp, preSum));\\n            \\n        return dp[ind][m] = maxi;\\n    }\\n\\npublic:\\n    // TOP DOWN\\n    int stoneGameII1(vector<int>& ps) {\\n        int n = ps.size();\\n        for(int i=n-2; i>=0; i--) ps[i] += ps[i+1];\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n        return stoneGameIIHelp(0, 1, dp, ps); \\n    }\\n\\n\\n    // Bottom Up\\n    int stoneGameII(vector<int>& preSum) {\\n        int n = preSum.size();\\n        for(int i=n-2; i>=0; i--) preSum[i] += preSum[i+1];\\n        vector<vector<int>> dp(n+1, vector<int>(n+1));\\n        \\n        for(int ind=n-1; ind>=0; ind--){\\n            for(int m = n; m>=1; m--){\\n                int maxi = 0;\\n                for(int x=1; x<=min(2*m, n-ind); x++)\\n                    maxi = max(maxi, preSum[ind] - dp[ind+x][max(m, x)]);\\n        \\n                dp[ind][m] = maxi;\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int stoneGameIIHelp(int ind, int m, int dp[][], int[] preSum){\\n        if( ind >= preSum.length ) return 0;\\n        if( dp[ind][m] != -1 ) return dp[ind][m];\\n\\n        int maxi = 0, n = preSum.length;\\n        for(int x=1; x <= Math.min(2*m, n-ind); x++)\\n            maxi = Math.max(maxi, preSum[ind] - stoneGameIIHelp(ind+x, Math.max(m, x), dp, preSum));\\n\\n        return dp[ind][m] = maxi;\\n    }\\n\\n\\n    // TOP DOWN\\n    public int stoneGameII1(int[] piles) {\\n        int n = piles.length;\\n        for(int i=n-2; i>=0; i--) piles[i] += piles[i+1];\\n        int dp[][] = new int[n][n+1];\\n        for(int i=0; i<n; i++) Arrays.fill(dp[i], -1);\\n        return  stoneGameIIHelp(0, 1, dp, piles);\\n    }\\n\\n\\n    // Bottom Up\\n    int stoneGameII(int[] preSum) {\\n        int n = preSum.length;\\n        for(int i=n-2; i>=0; i--) preSum[i] += preSum[i+1];\\n        int dp[][] = new int[n+1][n+1];\\n        \\n        for(int ind=n-1; ind>=0; ind--){\\n            for(int m = n; m>=1; m--){\\n                int maxi = 0;\\n                for(int x=1; x<=Math.min(2*m, n-ind); x++)\\n                    maxi = Math.max(maxi, preSum[ind] - dp[ind+x][Math.max(m, x)]);\\n        \\n                dp[ind][m] = maxi;\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983249,
                "title": "top-down-approach-with-explaination",
                "content": "### I tried my best to make the recurrence relation as simple as possible \\n\\n###### Note that both palyers are playing optimally **( both of them wants to collect as many stones as possible )**.\\nNow, the biggest question is how do I start ?\\nWell, If you see carefully there are two variable here, ( **m & starting index of the array**)\\nWe are given that first turn is of Alice\\'s, and second Bob, third Alice, etc  this process continues till the end.\\n### How do we differentiate between Alice and Bob ?\\nEach subproblem can have different states ( different combinations of variables )\\nLet\\'s now introduce a third variable to state of the subproblem and which determines whose turn it is to use that subproblem.\\nLet **p** be the required variable, and let\\'s assume that **p is True for Alice and False for Bob**.\\nThis is the key variable that determines how we should solve the subproblem.\\n\\nAs already mentioned, both the players should play optimally. Which means ( in their respective turns they should collect stones such that their total at the end would be maximised ).\\n\\n### What is the recurrence relation here, and How it should act as the turns change ?\\nlet **dp(index,m,P)** be the dp function or ( a state of the subproblem ).\\nSo, the final answer or state we want is **dp(0,1,True)**\\nWhich is **starting index =0  and m =1 and It\\'s Alice\\'s  turn.**\\n\\nNow in every state player should choose exactly first **X** elements starting from the start-index of the array. Also, **1<=X<=2m** and in next state, value of m would be **maximum(m,X)**.\\n\\nWe can divide each state in to cases.\\n\\n### case 1 : Alice\\'s Turn ( p = True)\\n\\nIn this state alice wants to maximize the **sum of first x of elements + value from subproblem\\'s state**\\nThis is true for Bob\\'s turn as well. But, since we are only interested in Alice, I made a minor modification there.\\nIt is Bob\\'s turn in the next state. It is the tricky part  ( at least for me though \\uD83D\\uDE02) in this approach.\\n\\n### case 2: Bob\\'s Turn ( p = False)\\nAs we are only interested in Alice\\'s value, we can ignore the value of Bob, but the state information is neccessary. \\nNow, in his turn bob also collects first x stones to maximize his total collection.\\n\\nNote that, the stones collected by Bob cannot be selected by Alice. So, these **first X** elements would contribute nothing to the alice\\'s collection.\\n\\nAlso, Bob making a move to maximize his collection implies that he\\'s indirectly minimizing the total collection of Alice.\\n\\nSo this state returns the value which is the  **0+minimum of  value\\'s from subproblems state**\\n Here, in next state it\\'s alice\\'s turn.\\n This process continues till the end.\\n Each state iterate over multiple values of **X** as we don\\'t know which value of **X** would lead to optimal solution.\\n\\n#### state transition :\\n\\t\\t\\t\\n\\t\\t\\tAlice ---> Bob ---> Alice ---> Bob ----> .......................\\n\\t\\t\\t\\n### Python Code :\\n\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def stoneGameII(self, piles):\\n        n = len(piles)\\n        @lru_cache(None)\\n        def dp(m,i,p):\\n            if i==n:\\n                return 0\\n            if p:\\n                Max = piles[i]+dp(max(m,1),i+1,not p)  \\n            else:\\n                Max = dp(max(m,1),i+1,not p)\\n            for x in range(1,2*m):\\n                if i+x <n:\\n                    if p:\\n                        Max = max(Max,sum(piles[i:i+x+1])+dp(max(m,x+1),i+x+1, not p))\\n                    else:\\n                        Max = min(Max,dp(max(m,x+1),i+x+1, not p))\\n                else:\\n                    return Max\\n            return Max\\n        return dp(1,0,True)\\n\\n```\\n##  **Space Complexity**\\n```\\n1.  m can go upto n.\\n2.  There are n indices.\\n3.  2  (Alice or Bob) choices for each possible pair m, iindex,\\n```\\nSo, space complexity is **O(n^2)**\\n\\n## **Time Complexity**\\n```\\n1. For every possible tuple (m, index, player), there is an inner loop \\n\\t\\t\\t\\t\\t\\tfor x in range(1,2*m)\\n2. The for has a complexity of O(n).\\n```\\nSo, time complexity is **O(n.(n^2)) = O(n^3)**\\n",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def stoneGameII(self, piles):\\n        n = len(piles)\\n        @lru_cache(None)\\n        def dp(m,i,p):\\n            if i==n:\\n                return 0\\n            if p:\\n                Max = piles[i]+dp(max(m,1),i+1,not p)  \\n            else:\\n                Max = dp(max(m,1),i+1,not p)\\n            for x in range(1,2*m):\\n                if i+x <n:\\n                    if p:\\n                        Max = max(Max,sum(piles[i:i+x+1])+dp(max(m,x+1),i+x+1, not p))\\n                    else:\\n                        Max = min(Max,dp(max(m,x+1),i+x+1, not p))\\n                else:\\n                    return Max\\n            return Max\\n        return dp(1,0,True)\\n\\n```\n```\\n1.  m can go upto n.\\n2.  There are n indices.\\n3.  2  (Alice or Bob) choices for each possible pair m, iindex,\\n```\n```\\n1. For every possible tuple (m, index, player), there is an inner loop \\n\\t\\t\\t\\t\\t\\tfor x in range(1,2*m)\\n2. The for has a complexity of O(n).\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851536,
                "title": "beat-100-intuitive-code-with-explanation",
                "content": "Basically, this is an one-to-one game and the sum of scores(stones) is fixed. \\nIf one player wants to get most, the other must get fewest. \\nBased on the logic, we can solve it by recursion plus DP.\\n\\nCode with clear explanation.\\nHope it\\'s helpful.\\nWelcome suggestion, question, comments and upvote.\\n```\\nclass Solution:\\n    def stoneGameII(self, piles):\\n        # accumulated sum table of the rest of all stores reversely for quick check\\n        a = [*accumulate(piles[::-1])][::-1]\\n\\t\\t\\n        # dp cache \\n        @lru_cache(None)\\n        def game(i, m): \\n\\t\\t    # i: current index, m: current maximal move\\n            # if player\\'s move can arrive goal, get all rest stones\\n            if i + 2 * m >= len(piles): return a[i]\\n            \\n            # otherwise, \\n            # the rest of all stones must subtract rival\\'s minimum  \\n            # _minScore: rival\\'s minimum         \\n            _minScore = 2**31 - 1  \\n\\n            # find which move can get maximum\\n            # x: how many moves\\n            for x in range(1, 2 * m + 1):\\n                # get rival\\'s score\\n                score = game(i + x, x) if x > m else game(i + x, m)\\n                # update rival\\'s new minimum \\n                if score < _minScore: _minScore = score\\n\\n            # the rest of all stores of current position\\n            # subtract rival\\'s minimum to get best result\\n            return a[i] - _minScore\\n            \\n        return game(0, 1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles):\\n        # accumulated sum table of the rest of all stores reversely for quick check\\n        a = [*accumulate(piles[::-1])][::-1]\\n\\t\\t\\n        # dp cache \\n        @lru_cache(None)\\n        def game(i, m): \\n\\t\\t    # i: current index, m: current maximal move\\n            # if player\\'s move can arrive goal, get all rest stones\\n            if i + 2 * m >= len(piles): return a[i]\\n            \\n            # otherwise, \\n            # the rest of all stones must subtract rival\\'s minimum  \\n            # _minScore: rival\\'s minimum         \\n            _minScore = 2**31 - 1  \\n\\n            # find which move can get maximum\\n            # x: how many moves\\n            for x in range(1, 2 * m + 1):\\n                # get rival\\'s score\\n                score = game(i + x, x) if x > m else game(i + x, m)\\n                # update rival\\'s new minimum \\n                if score < _minScore: _minScore = score\\n\\n            # the rest of all stores of current position\\n            # subtract rival\\'s minimum to get best result\\n            return a[i] - _minScore\\n            \\n        return game(0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564226,
                "title": "easy-python-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,nums,m,turn,dct):\\n        if i>=len(nums):\\n            return 0\\n        if (i,m,turn) in dct:\\n            return dct[(i,m,turn)]\\n        mx=0\\n        if turn:\\n            for j in range(1,(2*m)+1):\\n                x=self.dp(i+j,nums,max(m,j),False,dct)+sum(nums[i:i+j])\\n                mx=max(mx,x)\\n            dct[(i,m,turn)]=mx\\n            return mx\\n        else:\\n            mn=float(\"infinity\")\\n            for j in range(1,(2*m)+1):\\n                y=self.dp(i+j,nums,max(m,j),True,dct)\\n                # print(y)\\n                mn=min(mn,y)\\n            dct[(i,m,turn)]=mn\\n            return mn\\n        \\n\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n=len(piles)\\n        return self.dp(0,piles,1,True,{})\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self,i,nums,m,turn,dct):\\n        if i>=len(nums):\\n            return 0\\n        if (i,m,turn) in dct:\\n            return dct[(i,m,turn)]\\n        mx=0\\n        if turn:\\n            for j in range(1,(2*m)+1):\\n                x=self.dp(i+j,nums,max(m,j),False,dct)+sum(nums[i:i+j])\\n                mx=max(mx,x)\\n            dct[(i,m,turn)]=mx\\n            return mx\\n        else:\\n            mn=float(\"infinity\")\\n            for j in range(1,(2*m)+1):\\n                y=self.dp(i+j,nums,max(m,j),True,dct)\\n                # print(y)\\n                mn=min(mn,y)\\n            dct[(i,m,turn)]=mn\\n            return mn\\n        \\n\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n=len(piles)\\n        return self.dp(0,piles,1,True,{})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564086,
                "title": "memoization-completely-explained-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution is a recursive approach. The question asks us to take turns and use first $$X$$ stones that were not previously taken and add them to score. $$X$$ can be any number from $$1 \\\\; to \\\\;\\\\; 2M$$ (M starts with 1). $$M$$ is updated in each step as  $$max(X,M)$$. \\nWe  can form a function with parameters $$i, m, a$$, where,\\n- $$i$$ is current index upto where we have used the stones (we would like to pick any $$X$$ stones beginning from $$i_{th}$$ stone).\\n- $$m$$ is current value of $$M$$.\\n- $$a$$ denotes whose turn is this, $$a = 1$$ means Alice turn $$a = 0$$ means Bob\\'s turn.\\n\\n# Approach\\nWhen it is turn of Alice we return the max possible answer by adding the values of first $$X $$index starting from $$ i \\\\;\\\\; to \\\\;\\\\; i+2m$$ as $$X$$ can range from $$(1 \\\\; to \\\\; 2m)$$ and update $$m$$ as max of $$m$$ and $$X$$ (remember $$X$$ is count of indices that we can pick up starting from $$i$$ not index itself).\\nWhen it is the turn of Bob, we do nothing but skip the indexes starting from $$i$$ (that we don\\'t want to give to Alice), we take the minimum over all possible $$Xs$$ as Bob wants to minimize score of Alice.\\nFinally memoize the solution using a `dp` array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^3)\\n$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][301][2];\\n    int solve(int i , int n , int m , vector<int>& v, int a){\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[i][m][a]!=-1) return dp[i][m][a];\\n        int ans = 0;\\n        int cur =0;\\n        \\\\\\\\ alice turn\\n        if(a){\\n            for(int j = i;j<n&&j<i+2*m;j++){\\n                cur+=v[j];\\n                ans = max(ans,cur+solve(j+1,n,max(m,j-i+1),v, 1-a));\\n            }\\n        }\\n        \\\\\\\\ bob turn\\n        else{\\n            ans = 1e6;\\n            for(int j = i;j<n&&j<i+2*m;j++){\\n                ans = min(ans,solve(j+1,n,max(m,j-i+1),v, 1-a));\\n            }\\n        }\\n        return dp[i][m][a]=ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,n,1,piles,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][301][2];\\n    int solve(int i , int n , int m , vector<int>& v, int a){\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[i][m][a]!=-1) return dp[i][m][a];\\n        int ans = 0;\\n        int cur =0;\\n        \\\\\\\\ alice turn\\n        if(a){\\n            for(int j = i;j<n&&j<i+2*m;j++){\\n                cur+=v[j];\\n                ans = max(ans,cur+solve(j+1,n,max(m,j-i+1),v, 1-a));\\n            }\\n        }\\n        \\\\\\\\ bob turn\\n        else{\\n            ans = 1e6;\\n            for(int j = i;j<n&&j<i+2*m;j++){\\n                ans = min(ans,solve(j+1,n,max(m,j-i+1),v, 1-a));\\n            }\\n        }\\n        return dp[i][m][a]=ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,n,1,piles,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754390,
                "title": "java-solution-with-detail-explanation-in-code",
                "content": "My solution is similar to others. Explained the dp function in depth. Hope it helps.\\n\\n```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        \\n        //sumPiles[i] -> storing sum of remaining stones in all piles starting at i\\n        //We are creating sumPiles to quickly calculate the piles a player P can take in his turn i.e. P can take all the piles or P can take max piles as per constraints 1<=X<=2M\\n        \\n        int[] sumPiles = new int[n];\\n        sumPiles[n-1] = piles[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            sumPiles[i] = sumPiles[i+1] + piles[i];\\n        }\\n        \\n        //We will start from the end i.e. last pile, n-1. If Alex is standing at last pile, he will pick the last one for himself as thats the best possible option in front of him. We will move backwards and pick the best decision for Alex.\\n        //Idea is to maximize the stones of any player at all positions.\\n        //We will generalize the best decision of Alex at any position i. But there is another unknown for us i.e. M which constraints our picking process. As we don\\'t know value of M, this has to be present in dp function.\\n        // dp[i][m] => At ith pile, given m(concluded at the end of Lee turn), how many max stone picking Alex can do. Example, at the last and second last pile, Alex can pick all remaining piles as per constraint, X<=2M. This also implies M cannot go beyond n/2. \\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=n-1; i>=0; i--){\\n            for(int m=1; m<=n/2; m++){\\n                for(int x=1; x<=2*m && i+x<=n; x++){\\n                    //At any position i, player is given a value of m. After this turn player will pick certain number of piles(with constraints), lets say player picks X piles then the next turn player will start at i+x position and for next player value of m will be max of (x,m).\\n                    dp[i][m] = Math.max( dp[i][m], sumPiles[i] - dp[i+x][Math.max(x,m)]);\\n                }\\n            }\\n        }\\n        return dp[0][1];    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        \\n        //sumPiles[i] -> storing sum of remaining stones in all piles starting at i\\n        //We are creating sumPiles to quickly calculate the piles a player P can take in his turn i.e. P can take all the piles or P can take max piles as per constraints 1<=X<=2M\\n        \\n        int[] sumPiles = new int[n];\\n        sumPiles[n-1] = piles[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            sumPiles[i] = sumPiles[i+1] + piles[i];\\n        }\\n        \\n        //We will start from the end i.e. last pile, n-1. If Alex is standing at last pile, he will pick the last one for himself as thats the best possible option in front of him. We will move backwards and pick the best decision for Alex.\\n        //Idea is to maximize the stones of any player at all positions.\\n        //We will generalize the best decision of Alex at any position i. But there is another unknown for us i.e. M which constraints our picking process. As we don\\'t know value of M, this has to be present in dp function.\\n        // dp[i][m] => At ith pile, given m(concluded at the end of Lee turn), how many max stone picking Alex can do. Example, at the last and second last pile, Alex can pick all remaining piles as per constraint, X<=2M. This also implies M cannot go beyond n/2. \\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=n-1; i>=0; i--){\\n            for(int m=1; m<=n/2; m++){\\n                for(int x=1; x<=2*m && i+x<=n; x++){\\n                    //At any position i, player is given a value of m. After this turn player will pick certain number of piles(with constraints), lets say player picks X piles then the next turn player will start at i+x position and for next player value of m will be max of (x,m).\\n                    dp[i][m] = Math.max( dp[i][m], sumPiles[i] - dp[i+x][Math.max(x,m)]);\\n                }\\n            }\\n        }\\n        return dp[0][1];    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700847,
                "title": "concise-dp-with-explanation",
                "content": "Define the 2D DP variable to be\\n> `dp[i][m]`: max number of stones current player can get with game starting at `piles[i]` and `M = m`. \\n\\n**Range of i:** `0 <= i <= n` (if `i == n`, game is over and `dp[n][:] = 0`)\\n\\n**Range of m:**\\nNote that one can takes first `x` piles with `1 <= x <= m`. However, there are only `(n-i)` piles remaining in the game if starting at `piles[i]`. Therefore, the max value for `m` which makes sense is\\n> `maxM(i) = (int)ceil((n-i)/2.`\\n\\nAny value larger than `maxM(i)` doesn\\'t change the strategy of the game.\\n\\n**DP Transfer Equation:**\\nStarting at `piles[i]`, there are total `sum(piles[i:])` number of stones remaining. To maximize `dp[i][m]`, we just need to try all possible `x` such that \\n> `dp[i][m] = max(sum(piles[i:]) - dp[i+x][max(x, m)])` for all `x`,\\n\\nwhere `dp[i+x][max(x, m)]` is the opponent\\'s best strategy after current player took the first `x` piles.\\n\\n```cpp\\n  int stoneGameII(vector<int>& piles) {\\n    int n = piles.size();\\n    \\n    // max value of M if game starts at piles[i] (i.e., 2*M <= (n-i)+1)\\n    auto maxM = [&](int i) { return (int)ceil((n-i)/2.); };\\n    \\n    // dp[i][m]: max stones one can get starting at piles[i] with M = m\\n    vector<vector<int>> dp(n+1, vector<int>(maxM(0)+1, 0));\\n    \\n    // build suffix sum of piles[i:]\\n    vector<int> suffixSum(n+1);\\n    suffixSum[0] = accumulate(piles.begin(), piles.end(), 0);\\n    for (int i = 1; i <= n; i++)\\n      suffixSum[i] = suffixSum[i-1] - piles[i-1];\\n    \\n    // DP\\n    for (int i = n-1; i >= 0; i--)\\n      for (int m = 1; m <= maxM(i); m++)\\n        for (int x = 1; x <= min(2*m, n-i); x++) {\\n          int ii = i+x; // opponent i\\n          int mm = min(max(m, x), maxM(ii)); // opponent m\\n          dp[i][m] = max(dp[i][m], suffixSum[i] - dp[ii][mm]);\\n        }\\n    \\n    return dp[0][1]; // start at first pile with M = 1\\n  }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n  int stoneGameII(vector<int>& piles) {\\n    int n = piles.size();\\n    \\n    // max value of M if game starts at piles[i] (i.e., 2*M <= (n-i)+1)\\n    auto maxM = [&](int i) { return (int)ceil((n-i)/2.); };\\n    \\n    // dp[i][m]: max stones one can get starting at piles[i] with M = m\\n    vector<vector<int>> dp(n+1, vector<int>(maxM(0)+1, 0));\\n    \\n    // build suffix sum of piles[i:]\\n    vector<int> suffixSum(n+1);\\n    suffixSum[0] = accumulate(piles.begin(), piles.end(), 0);\\n    for (int i = 1; i <= n; i++)\\n      suffixSum[i] = suffixSum[i-1] - piles[i-1];\\n    \\n    // DP\\n    for (int i = n-1; i >= 0; i--)\\n      for (int m = 1; m <= maxM(i); m++)\\n        for (int x = 1; x <= min(2*m, n-i); x++) {\\n          int ii = i+x; // opponent i\\n          int mm = min(max(m, x), maxM(ii)); // opponent m\\n          dp[i][m] = max(dp[i][m], suffixSum[i] - dp[ii][mm]);\\n        }\\n    \\n    return dp[0][1]; // start at first pile with M = 1\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402126,
                "title": "easy-to-understand-using-real-dp-clear-interpretation",
                "content": "We first can use simple case to classify the concept.\\ncase 1 : [9,4,4]\\nA=9       B=4+4     A win 1\\nA=9+4  B=4          A win 9\\n\\ncase 2 : [7,9,4,4]\\nA=7       B=4+4     A lose 2\\nA=7+9  B=4          A win 8\\n\\ncase 3 : [2,7,9,4,4]\\nA=2       B=[B win 8]------- look at above case             A lose 6\\nA=2+7  B=[B take all remaining stones]                         A lose 8\\n\\nTherefore, \\npiles: 1........,x,x+1,.............n\\n\\nSet a function dp(i,M)\\nIt means that the player choose from i to last pile and at the same time M=1\\n\\ne.g. \\ndp(0,1)\\nA choose piles which from 0 to last one\\nand when M=1\\nA has two option to choose:\\nthe first one is A chose the first pile and B can choose from piles 1 to the last one (M is still 1)\\n----->piles[0]-dp(1,1)\\nthe second one is A chose the first two piles and B can choose from piles 2 to the last one (M is now updated to 2)\\n----->piles[0]+piles[1]-dp(2,2)\\n\\nAs result,\\nwe can get \\n---->sum(piles[i:i+x])-dp(i+x,max(x,M)) \\n\\nand there is a special condition that when the remaining piles of stone is less than 2*M\\nthe player must take them all\\n--->if len(piles)-i<=2*M : \\n                        return sum(piles[i:])\\n\\nMoreover,\\nyou should be careful about the input i\\nif input i is longer than the length of stone\\nwe should return 0\\n\\nLastly,\\nwe need to build dp-array to save the data we computed before in order to save time.\\n if dyp[i][M]==0:\\n then run dp-function\\n if not \\n retrurn  dyp[i][M]\\n```\\ndyp=[[0]*(len(piles)) for i in range(len(piles))]  \\n        \\n        def dp(i, M): \\n            if dyp[i][M]==0:\\n                while i<len(piles):\\n                    if len(piles)-i<=2*M : \\n                        return sum(piles[i:])\\n                             \\n                    temp=-float(\\'inf\\')                   \\n                    for x in range(1,2*M+1):\\n                        if sum(piles[i:i+x])-dp(i+x,max(x,M)) > temp:\\n                            temp=sum(piles[i:i+x])-dp(i+x,max(x,M)) \\n                    dyp[i][M]=temp\\n                    return temp \\n                return 0   \\n            else:\\n                return dyp[i][M]\\n        #call function\\n        return (sum(piles[:])+dp(0,1))/2\\n```",
                "solutionTags": [],
                "code": "```\\ndyp=[[0]*(len(piles)) for i in range(len(piles))]  \\n        \\n        def dp(i, M): \\n            if dyp[i][M]==0:\\n                while i<len(piles):\\n                    if len(piles)-i<=2*M : \\n                        return sum(piles[i:])\\n                             \\n                    temp=-float(\\'inf\\')                   \\n                    for x in range(1,2*M+1):\\n                        if sum(piles[i:i+x])-dp(i+x,max(x,M)) > temp:\\n                            temp=sum(piles[i:i+x])-dp(i+x,max(x,M)) \\n                    dyp[i][M]=temp\\n                    return temp \\n                return 0   \\n            else:\\n                return dyp[i][M]\\n        #call function\\n        return (sum(piles[:])+dp(0,1))/2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 360634,
                "title": "python-runtime-beats-100-memory-beats-100",
                "content": "#### Runtime: 36 ms, faster than 100.00% of Python online submissions for Stone Game II.\\n#### Memory Usage: 12.1 MB, less than 100.00% of Python online submissions for Stone Game II.\\nThe fastest code I could achieve, some methods to speed up:\\n1. use memorize-search(variable d in code), obviously speed up;\\n2. use 2d-list instead of dict, tiny speed up;\\n3. do not use list-comprehension, min(list) is slower than multi-line code, tiny speed up;\\n4. pre-compute piles[i] as sum(old_pile[i:]), obviously speed up;\\n\\n```\\nclass Solution(object):\\n    def stoneGameII(self, piles):\\n\\n        length = len(piles)\\n        d = [[0] * length for j in range(64)]\\n        for i in range(length - 2, -1, -1):\\n            piles[i] += piles[i + 1]\\n\\n        def find(m, curr):\\n            if length - curr <= m * 2:\\n                return piles[curr]\\n            if d[m][curr]:\\n                return d[m][curr]\\n\\n            min_count = sys.maxsize\\n            for x in range(1, m * 2 + 1):\\n                count = find(max(x, m), curr + x)\\n                if count < min_count:\\n                    min_count = count\\n            d[m][curr] = piles[curr] - min_count\\n            return piles[curr] - min_count\\n        return find(1, 0)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def stoneGameII(self, piles):\\n\\n        length = len(piles)\\n        d = [[0] * length for j in range(64)]\\n        for i in range(length - 2, -1, -1):\\n            piles[i] += piles[i + 1]\\n\\n        def find(m, curr):\\n            if length - curr <= m * 2:\\n                return piles[curr]\\n            if d[m][curr]:\\n                return d[m][curr]\\n\\n            min_count = sys.maxsize\\n            for x in range(1, m * 2 + 1):\\n                count = find(max(x, m), curr + x)\\n                if count < min_count:\\n                    min_count = count\\n            d[m][curr] = piles[curr] - min_count\\n            return piles[curr] - min_count\\n        return find(1, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712305,
                "title": "c-dp-solves-stone-game2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDP using 3D array and recursion.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n877. Stone Game\\n1140. Stone Game II\\n1406. Stone Game III\\n1510. Stone Game IV\\n1563. Stone Game V\\n1686. Stone Game VI\\n1690. Stone Game VII\\n1872. Stone Game VIII\\n2029. Stone Game IX\\nThe following is on the stone game 3, please turn on English subtitles if neccessary.\\n[https://youtu.be/ZN9j4MqPGtM](https://youtu.be/ZN9j4MqPGtM)\\nhttps://leetcode.com/problems/stone-game-iii/solutions/3566335/easy-c-recursive-solutions-with-memoization-iterating-with-explanation/\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int alice(int isBob, int i, int m, vector<int>& piles, int n){\\n        if (i == n) return 0;\\n        if (dp[isBob][i][m]!=-1) return dp[isBob][i][m];\\n        int stones =( isBob == 0 )? 0: INT_MAX;\\n        int sum = 0;\\n        for (int x = 1; x <= min(2 * m, n - i); x++) {\\n            sum += piles[i + x - 1];\\n            if (isBob) \\n                stones = min(stones, alice(0, i + x, max(m, x), piles, n));\\n            else \\n                stones = max(stones, \\n                sum + alice(1, i + x, max(m, x), piles,n ));                       \\n        }\\n        dp[isBob][i][m]=stones;\\n        return stones;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        dp.assign(2,vector(n+1, vector<int>(n+1, -1) ));\\n        return alice(0, 0, 1,  piles, n );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int alice(int isBob, int i, int m, vector<int>& piles, int n){\\n        if (i == n) return 0;\\n        if (dp[isBob][i][m]!=-1) return dp[isBob][i][m];\\n        int stones =( isBob == 0 )? 0: INT_MAX;\\n        int sum = 0;\\n        for (int x = 1; x <= min(2 * m, n - i); x++) {\\n            sum += piles[i + x - 1];\\n            if (isBob) \\n                stones = min(stones, alice(0, i + x, max(m, x), piles, n));\\n            else \\n                stones = max(stones, \\n                sum + alice(1, i + x, max(m, x), piles,n ));                       \\n        }\\n        dp[isBob][i][m]=stones;\\n        return stones;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        dp.assign(2,vector(n+1, vector<int>(n+1, -1) ));\\n        return alice(0, 0, 1,  piles, n );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566320,
                "title": "the-best-solutions-you-can-find-here",
                "content": "# Option 1:\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n\\n        @cache\\n        def dp(l, M=1):\\n            min_stones = left_stones = sum(piles[l:])\\n            \\n            R = min(l + 2*M, n) + 1\\n            for r in range(l+1, R):\\n                stones = dp(r, max(M, r - l))\\n                min_stones = min(min_stones, stones)\\n            \\n            return left_stones - min_stones\\n\\n        return dp(0)\\n```\\n\\n# Option 2: Option 1 + suffix sum of piles\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n        piles.append(0)\\n        for i in range(n-1, -1, -1):\\n            piles[i] += piles[i+1]\\n\\n        @cache\\n        def dp(l, M=1):\\n            min_stones = left_stones = piles[l]\\n\\n            R = min(l + 2*M, n) + 1\\n            for r in range(l+1, R):\\n                stones = dp(r, max(M, r - l))\\n                min_stones = min(min_stones, stones)\\n            \\n            return left_stones - min_stones\\n\\n        return dp(0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n\\n        @cache\\n        def dp(l, M=1):\\n            min_stones = left_stones = sum(piles[l:])\\n            \\n            R = min(l + 2*M, n) + 1\\n            for r in range(l+1, R):\\n                stones = dp(r, max(M, r - l))\\n                min_stones = min(min_stones, stones)\\n            \\n            return left_stones - min_stones\\n\\n        return dp(0)\\n```\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n        piles.append(0)\\n        for i in range(n-1, -1, -1):\\n            piles[i] += piles[i+1]\\n\\n        @cache\\n        def dp(l, M=1):\\n            min_stones = left_stones = piles[l]\\n\\n            R = min(l + 2*M, n) + 1\\n            for r in range(l+1, R):\\n                stones = dp(r, max(M, r - l))\\n                min_stones = min(min_stones, stones)\\n            \\n            return left_stones - min_stones\\n\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564740,
                "title": "golang-recursive-dp-with-explanation",
                "content": "# Intuition\\n\\n- It is not best strategy to always take as much as you can \\n(second example gives you hint about that).\\n\\n\\n---\\n\\n- Each turn can be described by two values:\\n\\n    - amount of already taken piles $p$;\\n    - current $m$ value.\\n    \\n- Imagine you took exactly $x$ piles. Next turn will be $$(a, b)$$, where \\n    - $a = p + x$;\\n    - $b = max(x, m)$.\\n\\n---\\n\\n- But what $$x$$ should you choose? To answer this question you need to imagine next scenario:\\n\\n    - Let\\'s $n$ is the total amount of piles.\\n\\n    - Instead of starting new turn your opponent starts the same game, but with piles from $a$ to $n$ and starting value of $m = b$.\\n    \\n    - Now your opponent solves the same problem, but with new starting parameters.\\n    \\n    - Let\\'s your opponent made some optimal desicions and got exactly $k$ stones from the new game. \\n    How many stones did you get?\\n\\n\\n# Approach\\n\\n- This problem could be solved by *dynamic programming*.\\n\\n- State is described by:\\n    - amount of already taken piles $p$;\\n    - current $m$ value.\\n\\n- Answer for the state $(p, m)$ could be calculated next way:\\n\\n    - If $p \\\\ge n$ - no stones left, so answer is 0.\\n    \\n    - Let\\'s $suff_P$ is the total amount of stones in piles $p + 1$, $p + 2$, $\\\\dots$, $n - 1$.\\n    - Iterate over all $x$ from $1$ to $2 \\\\cdot m$.\\n    - Let\\'s $k$ is the optimal answer for the opponent turn \\n    $(p + x, max(m, x))$.\\n    - If you take $x$ piles, you will get exactly $q = suff_P - k$ stones.\\n    - answer would be maximal $q$ over all $x$.\\n    \\n- Total answer for the original problem is answer for the state $(0, 1)$ - no piles are taken and $m = 1$ from the statement.\\n\\n---\\n    \\n- It can be easier to use recursion with memoization.\\n- Array $suff$ could be calculated in $O(n)$ initially.\\n    \\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\ntype Solver struct {\\n    n           int\\n    suffSums    []int \\n    dp          [][]int\\n}\\n\\nfunc createSolver(piles []int) *Solver {\\n    n := len(piles)\\n\\n    suffSums := make([]int, n + 1)\\n    for i := n - 1; i >= 0; i-- {\\n        suffSums[i] = suffSums[i + 1] + piles[i]\\n    }\\n\\n    dp := make([][]int, n + 1)\\n    for i := range dp {\\n        dp[i] = make([]int, n + 1)\\n        for j := range dp[i] {\\n            dp[i][j] = -1\\n        }\\n    }\\n\\n    return &Solver {\\n        n: n,\\n        suffSums: suffSums,\\n        dp: dp,\\n    }\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc (solver *Solver) calculate(start, m int) (ans int) {\\n    if start >= solver.n {\\n        return 0\\n    }\\n\\n    ans = solver.dp[start][m]\\n    if ans >= 0 {\\n        return ans\\n    }\\n\\n    fullSuffix := solver.suffSums[start]\\n    for taken := 1; taken <= 2 * m; taken++ {\\n        ans = max(\\n            ans,\\n            fullSuffix - solver.calculate(start + taken, max(taken, m)),\\n        )\\n    }\\n\\n    solver.dp[start][m] = ans\\n    return ans\\n}\\n\\nfunc stoneGameII(piles []int) int {\\n    solver := createSolver(piles)\\n    return solver.calculate(0, 1)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\ntype Solver struct {\\n    n           int\\n    suffSums    []int \\n    dp          [][]int\\n}\\n\\nfunc createSolver(piles []int) *Solver {\\n    n := len(piles)\\n\\n    suffSums := make([]int, n + 1)\\n    for i := n - 1; i >= 0; i-- {\\n        suffSums[i] = suffSums[i + 1] + piles[i]\\n    }\\n\\n    dp := make([][]int, n + 1)\\n    for i := range dp {\\n        dp[i] = make([]int, n + 1)\\n        for j := range dp[i] {\\n            dp[i][j] = -1\\n        }\\n    }\\n\\n    return &Solver {\\n        n: n,\\n        suffSums: suffSums,\\n        dp: dp,\\n    }\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc (solver *Solver) calculate(start, m int) (ans int) {\\n    if start >= solver.n {\\n        return 0\\n    }\\n\\n    ans = solver.dp[start][m]\\n    if ans >= 0 {\\n        return ans\\n    }\\n\\n    fullSuffix := solver.suffSums[start]\\n    for taken := 1; taken <= 2 * m; taken++ {\\n        ans = max(\\n            ans,\\n            fullSuffix - solver.calculate(start + taken, max(taken, m)),\\n        )\\n    }\\n\\n    solver.dp[start][m] = ans\\n    return ans\\n}\\n\\nfunc stoneGameII(piles []int) int {\\n    solver := createSolver(piles)\\n    return solver.calculate(0, 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564236,
                "title": "easy-solution-by-using-bottom-up-dynamic-programming",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        vector<int> prefixSum(n + 1, 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            prefixSum[i] = prefixSum[i + 1] + piles[i];\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int m = 1; m <= n; ++m) {\\n                if (i + 2 * m >= n) {\\n                    dp[i][m] = prefixSum[i];\\n                } else {\\n                    for (int x = 1; x <= 2 * m; ++x) {\\n                        dp[i][m] = max(dp[i][m], prefixSum[i] - dp[i + x][max(m, x)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1]; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        vector<int> prefixSum(n + 1, 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            prefixSum[i] = prefixSum[i + 1] + piles[i];\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int m = 1; m <= n; ++m) {\\n                if (i + 2 * m >= n) {\\n                    dp[i][m] = prefixSum[i];\\n                } else {\\n                    for (int x = 1; x <= 2 * m; ++x) {\\n                        dp[i][m] = max(dp[i][m], prefixSum[i] - dp[i + x][max(m, x)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1]; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563636,
                "title": "c-similar-to-stone-game-i-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuilding it on [Stone Game 1 solution](https://leetcode.com/problems/stone-game/solutions/3563643/c-easy-to-understand-memoization/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe want both the players to play optimally\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& piles, int m, int startIndex, int sum, vector<vector<int>>& dp) {\\n        int n = piles.size();\\n        if(startIndex>=n) {\\n            return 0;\\n        }\\n        if(dp[m][startIndex] != -1) {\\n            return dp[m][startIndex];\\n        }\\n        int maxStones = 0;\\n        int cumulativeSum = 0;\\n        for(int x = 1; x<=2*m; x++) {\\n            int index = startIndex + x - 1;\\n            if(index>=n) {\\n                break;\\n            }\\n            cumulativeSum += piles[index];\\n            maxStones = max(sum - helper(piles, max(m,x), startIndex+x, sum - cumulativeSum, dp), maxStones);\\n        }\\n        return dp[m][startIndex] = maxStones;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int m = 1, n = piles.size(), startIndex = 0;\\n        int totalStones = 0;\\n        for(int i=0;i<n;i++) {\\n            totalStones += piles[i];\\n        }\\n        vector<vector<int>> dp(2*n, vector<int>(n,-1));\\n        return helper(piles,m,startIndex,totalStones,dp);\\n    }\\n};\\n```\\n\\nUpvote if you like it!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& piles, int m, int startIndex, int sum, vector<vector<int>>& dp) {\\n        int n = piles.size();\\n        if(startIndex>=n) {\\n            return 0;\\n        }\\n        if(dp[m][startIndex] != -1) {\\n            return dp[m][startIndex];\\n        }\\n        int maxStones = 0;\\n        int cumulativeSum = 0;\\n        for(int x = 1; x<=2*m; x++) {\\n            int index = startIndex + x - 1;\\n            if(index>=n) {\\n                break;\\n            }\\n            cumulativeSum += piles[index];\\n            maxStones = max(sum - helper(piles, max(m,x), startIndex+x, sum - cumulativeSum, dp), maxStones);\\n        }\\n        return dp[m][startIndex] = maxStones;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int m = 1, n = piles.size(), startIndex = 0;\\n        int totalStones = 0;\\n        for(int i=0;i<n;i++) {\\n            totalStones += piles[i];\\n        }\\n        vector<vector<int>> dp(2*n, vector<int>(n,-1));\\n        return helper(piles,m,startIndex,totalStones,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563606,
                "title": "java-solution-for-stone-game-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use dynamic programming with memoization to determine the maximum number of stones Alice can get. The approach involves recursively exploring all possible moves and keeping track of the maximum stones obtained.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the prefix sum array prefixSum to store the sum of stones from each index to the end of the array.\\n1. Initialize a memoization array memo to store the results of subproblems. The value -1 indicates that the result has not been calculated yet.\\n1. Call the dfs function, which is a recursive helper function that performs the dynamic programming with memoization.\\n1. In the dfs function, handle the base cases:\\n- If we have reached the end of the array (i == piles.length), return 0.\\n- If 2 * M is greater than or equal to the remaining number of piles, return the sum of stones from the current index to the end of the array (prefixSum[i]).\\n- If the result for the current subproblem has already been calculated, return the memoized result.\\n5. Initialize the maxStones variable to store the maximum number of stones Alice can get from the current position.\\n6. Iterate from 1 to 2 * M (inclusive) to try different numbers of piles that Alice can take.\\n- For each iteration, calculate the remaining stones by subtracting the result of the recursive call with the updated index and the new maximum number of piles (Math.max(M, x)).\\n- Update maxStones with the maximum value between the current maxStones and the remaining stones.\\n7. Memoize the result by storing it in the memo array and return maxStones.\\n8. The main stoneGameII function initializes the prefix sum array, the memoization array, and starts the recursion by calling dfs with the initial parameters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n^2) because the recursion has two nested loops: one iterating from 1 to 2 * M, and the other iterating from the current index to the end of the array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity is O(n^2) as well due to the memoization array.\\n\\n# Code\\n```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        int[] prefixSum = new int[n];\\n        prefixSum[n - 1] = piles[n - 1];\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            prefixSum[i] = prefixSum[i + 1] + piles[i];\\n        }\\n        \\n        int[][] memo = new int[n][n];\\n        for (int[] row : memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return dfs(piles, prefixSum, memo, 0, 1);\\n    }\\n     private int dfs(int[] piles, int[] prefixSum, int[][] memo, int i, int M) {\\n        if (i == piles.length) {\\n            return 0;\\n        }\\n        \\n        if (2 * M >= piles.length - i) {\\n            return prefixSum[i];\\n        }\\n        \\n        if (memo[i][M] != -1) {\\n            return memo[i][M];\\n        }\\n        \\n        int maxStones = 0;\\n        for (int x = 1; x <= 2 * M; x++) {\\n            int remainingStones = prefixSum[i] - dfs(piles, prefixSum, memo, i + x, Math.max(M, x));\\n            maxStones = Math.max(maxStones, remainingStones);\\n        }\\n        \\n        memo[i][M] = maxStones;\\n        return maxStones;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        int[] prefixSum = new int[n];\\n        prefixSum[n - 1] = piles[n - 1];\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            prefixSum[i] = prefixSum[i + 1] + piles[i];\\n        }\\n        \\n        int[][] memo = new int[n][n];\\n        for (int[] row : memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return dfs(piles, prefixSum, memo, 0, 1);\\n    }\\n     private int dfs(int[] piles, int[] prefixSum, int[][] memo, int i, int M) {\\n        if (i == piles.length) {\\n            return 0;\\n        }\\n        \\n        if (2 * M >= piles.length - i) {\\n            return prefixSum[i];\\n        }\\n        \\n        if (memo[i][M] != -1) {\\n            return memo[i][M];\\n        }\\n        \\n        int maxStones = 0;\\n        for (int x = 1; x <= 2 * M; x++) {\\n            int remainingStones = prefixSum[i] - dfs(piles, prefixSum, memo, i + x, Math.max(M, x));\\n            maxStones = Math.max(maxStones, remainingStones);\\n        }\\n        \\n        memo[i][M] = maxStones;\\n        return maxStones;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762056,
                "title": "python-top-down-dp-key-concepts",
                "content": "```\\n\"\"\"\\n1140. Stone Game II\\n\\n\\nmin-max dp problem. we use top down memoization\\n\\nsince both players follow the same strategy, we can use recursion to \\nmaximize our score and minimize the opponents score all \\n\\nsteps: \\n1. preprocess accumulate suffix sum for piles to eliminate redundant computation. \\nthis represents the remaining possible score for each index.\\n2. define dp state variables for i, and M, which\\nrepresent max stones from piles[i..n] and the remaining score in suffixsum[1...n]\\n3. both players follow the same stategy. i=0 will be alice, bob will be i+1, etc.\\n3. for each turn try to maximize the value for i by finding\\nthe minimum of the opponent value and taking the difference\\nbetween the suffixsum at that index and that value\\n\\nx can range in entire [1... 2M] inclusive.\\nwe update m on the fly based on x for the subproblems\\n\\nthe base case allow us to take the remaining score if possible. \\n\\nComplexity:\\nO(n^3) time\\nO(n^2) space\\n\\n\"\"\"\\n\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n\\n        # cache postsum\\n        suffixsum = list(itertools.accumulate(reversed(piles)))[::-1]\\n\\n        @cache  \\n        def dfs(i, M):            \\n            # if allowed to take everything, take everything\\n            if i + 2 * M >= n:\\n                return suffixsum[i]\\n            \\n            # try to pick value to minmax the other player\\n            min_opponent_value = inf\\n            for x in range(1, 2 * M + 1):\\n                opponent_value = dfs(i + x, max(M, x))\\n                min_opponent_value = min(min_opponent_value, opponent_value)\\n            \\n            my_value = suffixsum[i] - min_opponent_value\\n                           \\n            return my_value\\n                           \\n        return dfs(0, 1)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n\"\"\"\\n1140. Stone Game II\\n\\n\\nmin-max dp problem. we use top down memoization\\n\\nsince both players follow the same strategy, we can use recursion to \\nmaximize our score and minimize the opponents score all \\n\\nsteps: \\n1. preprocess accumulate suffix sum for piles to eliminate redundant computation. \\nthis represents the remaining possible score for each index.\\n2. define dp state variables for i, and M, which\\nrepresent max stones from piles[i..n] and the remaining score in suffixsum[1...n]\\n3. both players follow the same stategy. i=0 will be alice, bob will be i+1, etc.\\n3. for each turn try to maximize the value for i by finding\\nthe minimum of the opponent value and taking the difference\\nbetween the suffixsum at that index and that value\\n\\nx can range in entire [1... 2M] inclusive.\\nwe update m on the fly based on x for the subproblems\\n\\nthe base case allow us to take the remaining score if possible. \\n\\nComplexity:\\nO(n^3) time\\nO(n^2) space\\n\\n\"\"\"\\n\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n\\n        # cache postsum\\n        suffixsum = list(itertools.accumulate(reversed(piles)))[::-1]\\n\\n        @cache  \\n        def dfs(i, M):            \\n            # if allowed to take everything, take everything\\n            if i + 2 * M >= n:\\n                return suffixsum[i]\\n            \\n            # try to pick value to minmax the other player\\n            min_opponent_value = inf\\n            for x in range(1, 2 * M + 1):\\n                opponent_value = dfs(i + x, max(M, x))\\n                min_opponent_value = min(min_opponent_value, opponent_value)\\n            \\n            my_value = suffixsum[i] - min_opponent_value\\n                           \\n            return my_value\\n                           \\n        return dfs(0, 1)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1266131,
                "title": "why-is-stone-game-ii-medium-and-stone-game-iii-hard-when-it-is-the-exact-opposite",
                "content": "[Stone Game II](https://leetcode.com/problems/stone-game-ii) which is the current problem is using the variable M to select number of stones and it is even dynamically increasing. And its a \"Medium\" level problem\\n\\nIn [Stone Game III](https://leetcode.com/problems/stone-game-iii/) the \\'M\\' value is hardcoded as 3. I just solved it using the exact same code of Stone Game II by just hardcoding M to 3 and apparently it is a \"Hard\" level problem.\\n\\nWho in the world is giving these levels to the problems?\\n\\nHere\\'s the code in case you want to have a look\\n\\nStone Game II Solution\\n\\n```\\nclass Solution(object):\\n    \\n    def helper(self, i , m , piles , memo):\\n        \\n        \\n        if i >= len(piles):\\n            return 0\\n        \\n        if memo[i][m] != -1:\\n            return memo[i][m]\\n        \\n        total = 0\\n        answer = -sys.maxsize\\n        \\n        # j starts from 0 so that even first element is included\\n        for j in range(2*m):\\n            if i+j >= len(piles): break\\n                \\n            total += piles[i + j]\\n            # Stones Picked is j+1 so value of \\'X\\' is j+1\\n            answer = max(answer,total - self.helper(i + j + 1 , max(j+1,m) , piles , memo))\\n        \\n        memo[i][m] = answer\\n        return answer\\n    \\n    def stoneGameII(self, piles):\\n        memo = [[-1 for _ in range(2*len(piles))] for _ in range(len(piles))]\\n        diff = self.helper(0,1,piles,memo)\\n        return (diff+sum(piles))//2\\n```\\n\\nStone Game III solution\\n\\n```\\nclass Solution(object):\\n    \\n    def helper(self , i , m , piles , memo):\\n        \\n        if i >= len(piles):\\n            return 0\\n        \\n        if memo[i][m] != -1:\\n            return memo[i][m]\\n        \\n        total = 0\\n        answer = -sys.maxsize\\n        \\n        for j in range(m):\\n            if i + j >= len(piles):break\\n                \\n            # pick 1,2 or 3 stones\\n            total += piles[i + j]\\n            \\n            # update max value\\n            # alice curr score - bob score \\n            answer = max(answer,total - self.helper(i + j + 1 , m , piles , memo) )\\n        \\n        memo[i][m] = answer\\n        return answer\\n    \\n    \\n    def stoneGameIII(self, stoneValue):\\n        memo = [[-1 for _ in range(4)] for _ in range(len(stoneValue))]\\n        diff = self.helper(0,3,stoneValue,memo)\\n        \\n        alice = (diff+sum(stoneValue))//2\\n        bob = sum(stoneValue) - alice\\n        \\n        return \"Tie\" if alice==bob else (\"Alice\" if alice>bob else \"Bob\")\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def helper(self, i , m , piles , memo):\\n        \\n        \\n        if i >= len(piles):\\n            return 0\\n        \\n        if memo[i][m] != -1:\\n            return memo[i][m]\\n        \\n        total = 0\\n        answer = -sys.maxsize\\n        \\n        # j starts from 0 so that even first element is included\\n        for j in range(2*m):\\n            if i+j >= len(piles): break\\n                \\n            total += piles[i + j]\\n            # Stones Picked is j+1 so value of \\'X\\' is j+1\\n            answer = max(answer,total - self.helper(i + j + 1 , max(j+1,m) , piles , memo))\\n        \\n        memo[i][m] = answer\\n        return answer\\n    \\n    def stoneGameII(self, piles):\\n        memo = [[-1 for _ in range(2*len(piles))] for _ in range(len(piles))]\\n        diff = self.helper(0,1,piles,memo)\\n        return (diff+sum(piles))//2\\n```\n```\\nclass Solution(object):\\n    \\n    def helper(self , i , m , piles , memo):\\n        \\n        if i >= len(piles):\\n            return 0\\n        \\n        if memo[i][m] != -1:\\n            return memo[i][m]\\n        \\n        total = 0\\n        answer = -sys.maxsize\\n        \\n        for j in range(m):\\n            if i + j >= len(piles):break\\n                \\n            # pick 1,2 or 3 stones\\n            total += piles[i + j]\\n            \\n            # update max value\\n            # alice curr score - bob score \\n            answer = max(answer,total - self.helper(i + j + 1 , m , piles , memo) )\\n        \\n        memo[i][m] = answer\\n        return answer\\n    \\n    \\n    def stoneGameIII(self, stoneValue):\\n        memo = [[-1 for _ in range(4)] for _ in range(len(stoneValue))]\\n        diff = self.helper(0,3,stoneValue,memo)\\n        \\n        alice = (diff+sum(stoneValue))//2\\n        bob = sum(stoneValue) - alice\\n        \\n        return \"Tie\" if alice==bob else (\"Alice\" if alice>bob else \"Bob\")\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 803363,
                "title": "much-simpler-dp-code-c-96-ile",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100][100];\\n    int stoneGameII(vector<int>& piles) {\\n      int N = piles.size();\\n      memset(dp, 0, sizeof(dp));\\n      \\n      // update piles[i] to sum of i to N stones\\n      for ( int i = N-2; i >= 0; i--)\\n        piles[i] += piles[i+1];\\n      \\n      dfs(0, 1, N, piles);\\n      return dp[0][1];\\n        \\n    }\\n  void dfs(int i, int m, int N, vector<int>& piles) {\\n    // if we can take everything, do so\\n    if (m*2 + i >= N) {\\n      dp[i][m] = piles[i]; \\n      return;\\n    }\\n    if (dp[i][m] != 0) return;\\n    \\n    int ans = 0;\\n    // try all possible j values to find the one that maximizes current players count\\n    for (int j = 1; j <= m*2; j++) {\\n      dfs( i+j, max(m , j), N, piles);\\n      ans = max(ans, piles[i] - dp[i+j][max(m,j)]);\\n    }\\n    dp[i][m] = ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100][100];\\n    int stoneGameII(vector<int>& piles) {\\n      int N = piles.size();\\n      memset(dp, 0, sizeof(dp));\\n      \\n      // update piles[i] to sum of i to N stones\\n      for ( int i = N-2; i >= 0; i--)\\n        piles[i] += piles[i+1];\\n      \\n      dfs(0, 1, N, piles);\\n      return dp[0][1];\\n        \\n    }\\n  void dfs(int i, int m, int N, vector<int>& piles) {\\n    // if we can take everything, do so\\n    if (m*2 + i >= N) {\\n      dp[i][m] = piles[i]; \\n      return;\\n    }\\n    if (dp[i][m] != 0) return;\\n    \\n    int ans = 0;\\n    // try all possible j values to find the one that maximizes current players count\\n    for (int j = 1; j <= m*2; j++) {\\n      dfs( i+j, max(m , j), N, piles);\\n      ans = max(ans, piles[i] - dp[i+j][max(m,j)]);\\n    }\\n    dp[i][m] = ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766184,
                "title": "very-simple-python-solution-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def stoneGameII(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Intuition: We are trying to find out how much maximum Alex can score with this program\\n        # So we try to maximise Alex\\'s score when it is Alex\\'s turn\\n        # When it is Lee\\'s turn, he will try to maximise his score and since we are returning just Alex\\'s score, we need to minimize\\n        # Alex\\'s score when it is Lee\\'s turn.\\n        \\n        def recursion(arr, low, high, m, is_it_alex_turn):\\n            # Start with base case:\\n            # If there are less than 2 * m piles remaining, Alex or Lee will always take all of it\\n            # If it is Alex\\'s turn, he takes full and we return sum of all piles\\n            # If it is Lee\\'s turn, he takes full and we return 0 because this program is tracking Alex\\'s score. Which would be zero if Lee takes it all. \\n            \\n            if high - low + 1 <= 2 * m:\\n                if is_it_alex_turn:\\n                    return sum(arr[low: high + 1])\\n                else:\\n                    return 0\\n            \\n            \\n            if is_it_alex_turn:\\n                # if it is Alex\\'s turn, he will try to maximise his own return\\n                cur_score = 0\\n                for k in range(1, 2 * m + 1):\\n                    score = sum(arr[low : low + k]) + recursion(arr, low + k, high, max(m, k), not is_it_alex_turn)\\n                    cur_score = max(cur_score, score)\\n\\n                return cur_score\\n            else:\\n                # It is Lee\\'s turn who will try to maximise his own return by decreasing Alex\\'s score.\\n                # Because we are trying to return just Alex\\'s score, we decrease Alex\\'s score instead by choosing minimum here\\n                cur_score = sys.maxint\\n                for k in range(1, 2 * m + 1):\\n                    score = 0 + recursion(arr, low + k, high, max(m, k), not is_it_alex_turn)\\n                    cur_score = min(cur_score, score)\\n                \\n                return cur_score\\n        \\n        def memoization(arr, low, high, m, is_it_alex_turn):\\n            if high - low + 1 <= 2 * m:\\n                if is_it_alex_turn:\\n                    return sum(arr[low: high + 1])\\n                else:\\n                    return 0\\n                \\n            if memoize[low][m][is_it_alex_turn] is not None:\\n                return memoize[low][m][is_it_alex_turn]\\n            \\n            if is_it_alex_turn:\\n                # if it is Alex\\'s turn, he will try to maximise his own return\\n                cur_score = 0\\n                for k in range(1, 2 * m + 1):\\n                    score = sum(arr[low : low + k]) + memoization(arr, low + k, high, max(m, k), is_it_alex_turn ^ 1)\\n                    cur_score = max(cur_score, score)\\n                \\n                memoize[low][m][is_it_alex_turn] = cur_score\\n                return cur_score\\n            else:\\n                # It is Lee\\'s turn who will try to maximise his own return by decreasing Alex\\'s score.\\n                # Because we are trying to return just Alex\\'s score, we decrease Alex\\'s score instead by choosing minimum here\\n                cur_score = sys.maxint\\n                for k in range(1, 2 * m + 1):\\n                    score = 0 + memoization(arr, low + k, high, max(m, k), is_it_alex_turn ^ 1)\\n                    cur_score = min(cur_score, score)\\n                \\n                memoize[low][m][is_it_alex_turn] = cur_score\\n                return cur_score\\n                \\n                \\n        # m = 1\\n        # is_it_alex_turn = True\\n        # return recursion(piles, 0, len(piles) - 1, m, is_it_alex_turn)\\n        \\n        memoize = [[[None for _ in range(0, 2)] for _ in range(3 * len(piles))] for _ in range(len(piles))]\\n        m = 1\\n        is_it_alex_turn = 1\\n        return memoization(piles, 0, len(piles) - 1, m, is_it_alex_turn)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def stoneGameII(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Intuition: We are trying to find out how much maximum Alex can score with this program\\n        # So we try to maximise Alex\\'s score when it is Alex\\'s turn\\n        # When it is Lee\\'s turn, he will try to maximise his score and since we are returning just Alex\\'s score, we need to minimize\\n        # Alex\\'s score when it is Lee\\'s turn.\\n        \\n        def recursion(arr, low, high, m, is_it_alex_turn):\\n            # Start with base case:\\n            # If there are less than 2 * m piles remaining, Alex or Lee will always take all of it\\n            # If it is Alex\\'s turn, he takes full and we return sum of all piles\\n            # If it is Lee\\'s turn, he takes full and we return 0 because this program is tracking Alex\\'s score. Which would be zero if Lee takes it all. \\n            \\n            if high - low + 1 <= 2 * m:\\n                if is_it_alex_turn:\\n                    return sum(arr[low: high + 1])\\n                else:\\n                    return 0\\n            \\n            \\n            if is_it_alex_turn:\\n                # if it is Alex\\'s turn, he will try to maximise his own return\\n                cur_score = 0\\n                for k in range(1, 2 * m + 1):\\n                    score = sum(arr[low : low + k]) + recursion(arr, low + k, high, max(m, k), not is_it_alex_turn)\\n                    cur_score = max(cur_score, score)\\n\\n                return cur_score\\n            else:\\n                # It is Lee\\'s turn who will try to maximise his own return by decreasing Alex\\'s score.\\n                # Because we are trying to return just Alex\\'s score, we decrease Alex\\'s score instead by choosing minimum here\\n                cur_score = sys.maxint\\n                for k in range(1, 2 * m + 1):\\n                    score = 0 + recursion(arr, low + k, high, max(m, k), not is_it_alex_turn)\\n                    cur_score = min(cur_score, score)\\n                \\n                return cur_score\\n        \\n        def memoization(arr, low, high, m, is_it_alex_turn):\\n            if high - low + 1 <= 2 * m:\\n                if is_it_alex_turn:\\n                    return sum(arr[low: high + 1])\\n                else:\\n                    return 0\\n                \\n            if memoize[low][m][is_it_alex_turn] is not None:\\n                return memoize[low][m][is_it_alex_turn]\\n            \\n            if is_it_alex_turn:\\n                # if it is Alex\\'s turn, he will try to maximise his own return\\n                cur_score = 0\\n                for k in range(1, 2 * m + 1):\\n                    score = sum(arr[low : low + k]) + memoization(arr, low + k, high, max(m, k), is_it_alex_turn ^ 1)\\n                    cur_score = max(cur_score, score)\\n                \\n                memoize[low][m][is_it_alex_turn] = cur_score\\n                return cur_score\\n            else:\\n                # It is Lee\\'s turn who will try to maximise his own return by decreasing Alex\\'s score.\\n                # Because we are trying to return just Alex\\'s score, we decrease Alex\\'s score instead by choosing minimum here\\n                cur_score = sys.maxint\\n                for k in range(1, 2 * m + 1):\\n                    score = 0 + memoization(arr, low + k, high, max(m, k), is_it_alex_turn ^ 1)\\n                    cur_score = min(cur_score, score)\\n                \\n                memoize[low][m][is_it_alex_turn] = cur_score\\n                return cur_score\\n                \\n                \\n        # m = 1\\n        # is_it_alex_turn = True\\n        # return recursion(piles, 0, len(piles) - 1, m, is_it_alex_turn)\\n        \\n        memoize = [[[None for _ in range(0, 2)] for _ in range(3 * len(piles))] for _ in range(len(piles))]\\n        m = 1\\n        is_it_alex_turn = 1\\n        return memoization(piles, 0, len(piles) - 1, m, is_it_alex_turn)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721224,
                "title": "dp-idea",
                "content": "**Each player plays optimally**. So the player who has the chance will always try to make the other player lose. So whenever Alex is playing, he\\'ll try to increase his score. Whenever Lee is playing, he\\'ll try to increase his score or he will pick such that the other player gets minimum score possible from the subsequent chances.\\n\\n```\\n    int memo[101][101][2];\\n    int dp(int i,int p,int m,vector<int>& stones)\\n    {\\n        if(i>=stones.size())\\n            return 0;\\n        else if(memo[i][m][p]!=0)\\n            return memo[i][m][p];\\n        else\\n        {\\n            int val=0,q=(p==0?INT_MIN:INT_MAX),temp=0;\\n            for(int j=1;j<=2*m&&i+j<=stones.size();++j)\\n            {\\n                val+=stones[i+j-1];\\n                if(p==0)\\n                    q=max(q,val+dp(i+j,1,max(j,m),stones));\\n                else\\n                    q=min(q,dp(i+j,0,max(j,m),stones));\\n            }\\n            return memo[i][m][p]=q;\\n        }\\n    }\\n    int stoneGameII(vector<int>& piles)\\n\\t{\\n        return dp(0,0,1,piles);\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int memo[101][101][2];\\n    int dp(int i,int p,int m,vector<int>& stones)\\n    {\\n        if(i>=stones.size())\\n            return 0;\\n        else if(memo[i][m][p]!=0)\\n            return memo[i][m][p];\\n        else\\n        {\\n            int val=0,q=(p==0?INT_MIN:INT_MAX),temp=0;\\n            for(int j=1;j<=2*m&&i+j<=stones.size();++j)\\n            {\\n                val+=stones[i+j-1];\\n                if(p==0)\\n                    q=max(q,val+dp(i+j,1,max(j,m),stones));\\n                else\\n                    q=min(q,dp(i+j,0,max(j,m),stones));\\n            }\\n            return memo[i][m][p]=q;\\n        }\\n    }\\n    int stoneGameII(vector<int>& piles)\\n\\t{\\n        return dp(0,0,1,piles);\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 485246,
                "title": "rz-top-down-solution-from-top-voted-solution-and-corresponding-bottom-up-solution-in-python",
                "content": "One important difference between this problem and problem Stone Game https://leetcode.com/problems/stone-game/\\n\\nIn Stone Game, range of the sub-problem (for example, from piles[i] to piles[j]) is the only variable affecting the result because we can only pick either the left end pile or right end pile. However, in this problem, even with the same piles of stones, the result still depends on M, so M needs to be part of the dp array.\\n\\n**1. Top down solution with memoization**\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        if not piles:\\n            return 0\\n        \\n        n = len(piles)\\n        postSum = [0] * n\\n        postSum[n - 1] = piles[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            postSum[i] = postSum[i + 1] + piles[i]\\n        \\n        return self.helper(0, 1, postSum, {})\\n    \\n    def helper(self, start, M, postSum, cache):\\n        if (start, M) in cache:\\n            return cache[(start, M)]\\n        \\n        n = len(postSum)\\n        if start >= n:\\n            return 0\\n        if n - start <= 2 * M:\\n            return postSum[start]\\n        \\n        minNext = float(\\'inf\\')\\n        for x in range(1, 2 * M + 1):\\n            minNext = min(minNext, self.helper(start + x, max(M, x), postSum, cache))\\n        res = postSum[start] - minNext\\n        cache[(start, M)] = res\\n        return res\\n```\\n\\n**2. Bottom up solution**\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        if not piles:\\n            return 0\\n        \\n        n = len(piles)\\n        postSum = [0] * n\\n        postSum[n - 1] = piles[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            postSum[i] = postSum[i + 1] + piles[i]\\n        \\n        f = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n - 1, -1, -1):\\n            for m in range(1, n):\\n                if n - i <= 2 * m:\\n                    f[i][m] = postSum[i]\\n                    continue\\n                \\n                minNext = float(\\'inf\\')\\n                for x in range(1, 2 * m + 1):\\n                    minNext = min(minNext, f[i + x][max(m, x)])\\n                f[i][m] = postSum[i] - minNext\\n\\t\\t\\t\\t\\n        return f[0][1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        if not piles:\\n            return 0\\n        \\n        n = len(piles)\\n        postSum = [0] * n\\n        postSum[n - 1] = piles[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            postSum[i] = postSum[i + 1] + piles[i]\\n        \\n        return self.helper(0, 1, postSum, {})\\n    \\n    def helper(self, start, M, postSum, cache):\\n        if (start, M) in cache:\\n            return cache[(start, M)]\\n        \\n        n = len(postSum)\\n        if start >= n:\\n            return 0\\n        if n - start <= 2 * M:\\n            return postSum[start]\\n        \\n        minNext = float(\\'inf\\')\\n        for x in range(1, 2 * M + 1):\\n            minNext = min(minNext, self.helper(start + x, max(M, x), postSum, cache))\\n        res = postSum[start] - minNext\\n        cache[(start, M)] = res\\n        return res\\n```\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        if not piles:\\n            return 0\\n        \\n        n = len(piles)\\n        postSum = [0] * n\\n        postSum[n - 1] = piles[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            postSum[i] = postSum[i + 1] + piles[i]\\n        \\n        f = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n - 1, -1, -1):\\n            for m in range(1, n):\\n                if n - i <= 2 * m:\\n                    f[i][m] = postSum[i]\\n                    continue\\n                \\n                minNext = float(\\'inf\\')\\n                for x in range(1, 2 * m + 1):\\n                    minNext = min(minNext, f[i + x][max(m, x)])\\n                f[i][m] = postSum[i] - minNext\\n\\t\\t\\t\\t\\n        return f[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345486,
                "title": "java-dp-bottom-up",
                "content": "```\\npublic int stoneGameII(int[] piles) {\\n\\tint l = piles.length;\\n\\n\\tint[] preSum = new int[l+1];\\n\\tfor (int i = 1; i <= l; i++) {\\n\\t\\tpreSum[i] = preSum[i-1] + piles[i-1];\\n\\t}\\n\\n\\tint[][] dp = new int[l+1][l+1];\\n\\tfor (int i = l-1; i >= 0; i--) {\\n\\t\\tfor (int M = 1; M <= l; M++) {\\n\\t\\t\\tint maxToTake = Math.min(2*M, l-i);\\n\\t\\t\\tfor (int X = 1; X <= maxToTake; X++) {\\n\\t\\t\\t\\tint nextM = Math.max(M, X);\\n\\t\\t\\t\\tdp[i][M] = Math.max(dp[i][M], preSum[l] - preSum[i] - dp[i+X][nextM]);  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[0][1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int stoneGameII(int[] piles) {\\n\\tint l = piles.length;\\n\\n\\tint[] preSum = new int[l+1];\\n\\tfor (int i = 1; i <= l; i++) {\\n\\t\\tpreSum[i] = preSum[i-1] + piles[i-1];\\n\\t}\\n\\n\\tint[][] dp = new int[l+1][l+1];\\n\\tfor (int i = l-1; i >= 0; i--) {\\n\\t\\tfor (int M = 1; M <= l; M++) {\\n\\t\\t\\tint maxToTake = Math.min(2*M, l-i);\\n\\t\\t\\tfor (int X = 1; X <= maxToTake; X++) {\\n\\t\\t\\t\\tint nextM = Math.max(M, X);\\n\\t\\t\\t\\tdp[i][M] = Math.max(dp[i][M], preSum[l] - preSum[i] - dp[i+X][nextM]);  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[0][1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345289,
                "title": "simple-java-solution-based-dfs-backtracking",
                "content": "Integer[][] memo = new Integer[piles.length][piles.length + 1];\\nthis array will help to track max numer of coins one player can get from current index i to the end of this array with parameter m = j in the next move.\\n\\n\\n```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        Integer[][] memo = new Integer[piles.length][piles.length + 1];\\n        int[] prefixSum = new int[piles.length + 1];\\n        for(int i = 0; i < piles.length; ++i) {\\n            prefixSum[i+1] = prefixSum[i] + piles[i];\\n        }\\n        \\n        dfs(memo, prefixSum, 0, 1);\\n        \\n        return memo[0][1];\\n    }\\n    \\n    private int dfs(Integer[][] memo, int[] prefixSum, int curIdx, int m) {\\n        if(curIdx + 1 >= prefixSum.length || m > memo.length) {\\n            return 0;\\n        }\\n        \\n        if(memo[curIdx][m] != null) {\\n            return memo[curIdx][m];\\n        }\\n        \\n        if(prefixSum.length - curIdx - 1 <= 2 * m) {\\n            memo[curIdx][m] = prefixSum[prefixSum.length-1] - prefixSum[curIdx];\\n            return memo[curIdx][m] ;\\n        }\\n        \\n        int minLoss = Integer.MAX_VALUE, newM = 0, lossTmp = 0;\\n        for(int i = 1; i <= 2 * m; ++i) {\\n            newM = Math.max(i, m);\\n            lossTmp = dfs(memo, prefixSum, curIdx + i, newM);\\n            minLoss = Math.min(minLoss, lossTmp);\\n        }\\n        \\n        memo[curIdx][m] = prefixSum[prefixSum.length-1] - prefixSum[curIdx] - minLoss;\\n        return memo[curIdx][m];\\n    }\\n}``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        Integer[][] memo = new Integer[piles.length][piles.length + 1];\\n        int[] prefixSum = new int[piles.length + 1];\\n        for(int i = 0; i < piles.length; ++i) {\\n            prefixSum[i+1] = prefixSum[i] + piles[i];\\n        }\\n        \\n        dfs(memo, prefixSum, 0, 1);\\n        \\n        return memo[0][1];\\n    }\\n    \\n    private int dfs(Integer[][] memo, int[] prefixSum, int curIdx, int m) {\\n        if(curIdx + 1 >= prefixSum.length || m > memo.length) {\\n            return 0;\\n        }\\n        \\n        if(memo[curIdx][m] != null) {\\n            return memo[curIdx][m];\\n        }\\n        \\n        if(prefixSum.length - curIdx - 1 <= 2 * m) {\\n            memo[curIdx][m] = prefixSum[prefixSum.length-1] - prefixSum[curIdx];\\n            return memo[curIdx][m] ;\\n        }\\n        \\n        int minLoss = Integer.MAX_VALUE, newM = 0, lossTmp = 0;\\n        for(int i = 1; i <= 2 * m; ++i) {\\n            newM = Math.max(i, m);\\n            lossTmp = dfs(memo, prefixSum, curIdx + i, newM);\\n            minLoss = Math.min(minLoss, lossTmp);\\n        }\\n        \\n        memo[curIdx][m] = prefixSum[prefixSum.length-1] - prefixSum[curIdx] - minLoss;\\n        return memo[curIdx][m];\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878347,
                "title": "c-dp-beats-87-easy-to-read",
                "content": "\\n# Complexity\\n- Time complexity: O(N^N) or O(N^2M). However since we use dp and we can reuse the result, the time comsumption can be faster.\\n<!-- Add your time complexity here, e.g. $$O()$$ -->\\n\\n- Space complexity:O (N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        // Init dp: dp[i][j] means relative score at index i with j = M\\n        vector<vector<int>> dp(n, vector<int>(n + 1, -1));\\n        int sum = 0;\\n        for (int& each : piles) sum += each;\\n        int res = optimalSolution(piles, dp, 0, 1);\\n        // res is a relative score for the first player\\n        // (sum + res) / 2 is \\n        //      first: get rid of the difference between 2 players\\n        //      second: divid it by two, and get the answer\\n        return (sum + res) / 2;\\n    }\\n\\n    int optimalSolution(vector<int>& piles, vector<vector<int>>& dp, int idx, int M) {\\n        if (idx == piles.size()) return 0;\\n        if (dp[idx][M] != -1) return dp[idx][M];\\n        int maxRes = INT_MIN, sumOfFirstIPiles = 0;\\n        // recursion here, with edge checking\\n        for (int i = 1; i <= 2 * M && i + idx <= piles.size(); ++i) {\\n            sumOfFirstIPiles += piles[idx + i - 1];\\n            maxRes = max(maxRes, sumOfFirstIPiles - optimalSolution(piles, dp, idx + i, max(M, i)));\\n        }\\n        // assign dp[i][j] at last and return\\n        return dp[idx][M] = maxRes;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        // Init dp: dp[i][j] means relative score at index i with j = M\\n        vector<vector<int>> dp(n, vector<int>(n + 1, -1));\\n        int sum = 0;\\n        for (int& each : piles) sum += each;\\n        int res = optimalSolution(piles, dp, 0, 1);\\n        // res is a relative score for the first player\\n        // (sum + res) / 2 is \\n        //      first: get rid of the difference between 2 players\\n        //      second: divid it by two, and get the answer\\n        return (sum + res) / 2;\\n    }\\n\\n    int optimalSolution(vector<int>& piles, vector<vector<int>>& dp, int idx, int M) {\\n        if (idx == piles.size()) return 0;\\n        if (dp[idx][M] != -1) return dp[idx][M];\\n        int maxRes = INT_MIN, sumOfFirstIPiles = 0;\\n        // recursion here, with edge checking\\n        for (int i = 1; i <= 2 * M && i + idx <= piles.size(); ++i) {\\n            sumOfFirstIPiles += piles[idx + i - 1];\\n            maxRes = max(maxRes, sumOfFirstIPiles - optimalSolution(piles, dp, idx + i, max(M, i)));\\n        }\\n        // assign dp[i][j] at last and return\\n        return dp[idx][M] = maxRes;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652899,
                "title": "easy-memoization",
                "content": "# Intuition\\ndpp\\n\\n# Approach\\nwe create a suffix sum array and everytime we have to calculate for a given value of x we try to maximise the result for alice like if alice takes one then after bob chooses what can alice choose further, that is the basic reason to do i+x because after ix the chance to choose will be in alice\\'s hands\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\ndp array size + suffix sum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &piles,vector<vector<int>> &dp,int i , int m ,vector<int> &suffix){\\n        if(i==piles.size()) return 0;\\n        if(i+2*m >=piles.size()) return suffix[i];\\n        if(dp[i][m]!=0) return dp[i][m];\\n          int res =0;\\n        for( int x=1;x<=2*m;x++){\\n             res = max( res, suffix[i]- helper(piles,dp,i+x,max(m,x),suffix));\\n        }\\n        dp[i][m] = res;\\n        return res;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        if(piles.empty()) return 0;\\n        int n = piles.size();\\n        vector<int> suffix(n);\\n        suffix[n-1] = piles[n-1];\\n        for( int i =n-2;i>=0;i--){\\n            suffix[i] = suffix[i+1] + piles[i];\\n        }\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        return helper(piles,dp,0,1,suffix);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &piles,vector<vector<int>> &dp,int i , int m ,vector<int> &suffix){\\n        if(i==piles.size()) return 0;\\n        if(i+2*m >=piles.size()) return suffix[i];\\n        if(dp[i][m]!=0) return dp[i][m];\\n          int res =0;\\n        for( int x=1;x<=2*m;x++){\\n             res = max( res, suffix[i]- helper(piles,dp,i+x,max(m,x),suffix));\\n        }\\n        dp[i][m] = res;\\n        return res;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        if(piles.empty()) return 0;\\n        int n = piles.size();\\n        vector<int> suffix(n);\\n        suffix[n-1] = piles[n-1];\\n        for( int i =n-2;i>=0;i--){\\n            suffix[i] = suffix[i+1] + piles[i];\\n        }\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        return helper(piles,dp,0,1,suffix);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573070,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach: Recursive DP\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 3)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n is number of piles.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def stoneGameII(self, piles: list[int]) -> int:\\n        suffix_sums = tuple(reversed(tuple(accumulate(reversed(piles)))))\\n\\n        @cache\\n        def score(i: int, m: int) -> int:\\n            return (i < len(piles)) and max(suffix_sums[i] - score(i + x, max(m, x)) for x in range(1, 2 * m + 1))\\n        \\n        return score(0, 1)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```python\\nclass Solution:\\n    def stoneGameII(self, piles: list[int]) -> int:\\n        suffix_sums = tuple(reversed(tuple(accumulate(reversed(piles)))))\\n\\n        @cache\\n        def score(i: int, m: int) -> int:\\n            return (i < len(piles)) and max(suffix_sums[i] - score(i + x, max(m, x)) for x in range(1, 2 * m + 1))\\n        \\n        return score(0, 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565339,
                "title": "python3-see-this-post-if-you-are-frustrating-with-cryptic-codes",
                "content": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        \\n\\t\\t# Constants\\n        ALICE = 1 # To represent current turn.\\n        BOB = -1 # To represent current turn.\\n        N = len(piles)\\n        \\n\\t\\t# Helpers\\n        @cache\\n        def max_piles_from(idx, m, turn): # Returns alice\\'s gain from the given state.\\n            if idx == N:\\n                return 0\\n\\t\\t\\n            # Note: We need to maximize alice\\'s gain in alice\\'s turn, minimize alice\\'s gain in bob\\'s turn.\\n            localMax = 0\\n            localMin = float(\\'inf\\')\\n            turnSum = 0\\n            \\n\\t\\t\\t# Try all choices.\\n            for x in range(1, min(2*m, N-idx) + 1): # harvesting index\\'s upper is N-1.\\n                harvesting_idx = idx + x - 1\\n                turnSum += piles[harvesting_idx]\\n                next_m = max(m, x)\\n                \\n                current_turn_gain = turnSum if turn == ALICE else 0\\n                future_gain = max_piles_from(harvesting_idx+1, next_m, -turn) # Switching turn by multipling -1.\\n                \\n                localMax = max(localMax, current_turn_gain + future_gain)\\n                localMin = min(localMin, current_turn_gain + future_gain)\\n                \\n            return localMax if turn == ALICE else localMin\\n        \\n        # Main\\n        return max_piles_from(0, 1, ALICE)\\n```",
                "solutionTags": [
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        \\n\\t\\t# Constants\\n        ALICE = 1 # To represent current turn.\\n        BOB = -1 # To represent current turn.\\n        N = len(piles)\\n        \\n\\t\\t# Helpers\\n        @cache\\n        def max_piles_from(idx, m, turn): # Returns alice\\'s gain from the given state.\\n            if idx == N:\\n                return 0\\n\\t\\t\\n            # Note: We need to maximize alice\\'s gain in alice\\'s turn, minimize alice\\'s gain in bob\\'s turn.\\n            localMax = 0\\n            localMin = float(\\'inf\\')\\n            turnSum = 0\\n            \\n\\t\\t\\t# Try all choices.\\n            for x in range(1, min(2*m, N-idx) + 1): # harvesting index\\'s upper is N-1.\\n                harvesting_idx = idx + x - 1\\n                turnSum += piles[harvesting_idx]\\n                next_m = max(m, x)\\n                \\n                current_turn_gain = turnSum if turn == ALICE else 0\\n                future_gain = max_piles_from(harvesting_idx+1, next_m, -turn) # Switching turn by multipling -1.\\n                \\n                localMax = max(localMax, current_turn_gain + future_gain)\\n                localMin = min(localMin, current_turn_gain + future_gain)\\n                \\n            return localMax if turn == ALICE else localMin\\n        \\n        # Main\\n        return max_piles_from(0, 1, ALICE)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565317,
                "title": "straight-forward-recursive-cache",
                "content": "# Intuition/Approach\\n\\nrecurssively parcour the list and:\\n- maximize the score on Alice turn \\n- minimize the score on bob turn.\\n\\nuse a cache to minimize the tree search.\\n\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn stone_game_ii(piles: Vec<i32>) -> i32 {\\n        fn minmax(\\n            idx:usize, \\n            piles: &Vec<i32>, \\n            m:usize, \\n            turn:bool, \\n            cache: &mut HashMap<(usize,usize,bool),i32>,\\n            ) -> i32 {\\n\\n                //println!(\"{}\",cache.keys().len());\\n                if idx>= piles.len() { return 0 };\\n                if let Some(&val) = cache.get(&(idx, m, turn)) { return val };\\n                \\n                if turn {\\n                    let mut mx:i32 = 0;\\n                    for i in 1..=(2*m).min(piles.len()-idx) {\\n                        let x = minmax(idx+i, &piles, m.max(i), false, cache);\\n                        let s = &piles[idx..(idx+i)].iter().sum();\\n                        mx = mx.max(x+s);\\n                    }\\n                    //println!(\"idx={} => {}\",idx, mx);\\n                    cache.insert((idx,m,true),mx);\\n                    return mx\\n                }else{\\n                    let mut mn:i32 = 9999999;\\n                    for i in 1..=(2*m).min(piles.len()-idx) {\\n                        let x = minmax(idx+i, &piles, m.max(i), true, cache);\\n                        mn = mn.min(x);\\n                    } \\n                    cache.insert((idx,m,false),mn);\\n                    return mn\\n                }\\n            }\\n    \\n            minmax(0,&piles,1, true, &mut HashMap::with_capacity((piles.len()-1).pow(2)))\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn stone_game_ii(piles: Vec<i32>) -> i32 {\\n        fn minmax(\\n            idx:usize, \\n            piles: &Vec<i32>, \\n            m:usize, \\n            turn:bool, \\n            cache: &mut HashMap<(usize,usize,bool),i32>,\\n            ) -> i32 {\\n\\n                //println!(\"{}\",cache.keys().len());\\n                if idx>= piles.len() { return 0 };\\n                if let Some(&val) = cache.get(&(idx, m, turn)) { return val };\\n                \\n                if turn {\\n                    let mut mx:i32 = 0;\\n                    for i in 1..=(2*m).min(piles.len()-idx) {\\n                        let x = minmax(idx+i, &piles, m.max(i), false, cache);\\n                        let s = &piles[idx..(idx+i)].iter().sum();\\n                        mx = mx.max(x+s);\\n                    }\\n                    //println!(\"idx={} => {}\",idx, mx);\\n                    cache.insert((idx,m,true),mx);\\n                    return mx\\n                }else{\\n                    let mut mn:i32 = 9999999;\\n                    for i in 1..=(2*m).min(piles.len()-idx) {\\n                        let x = minmax(idx+i, &piles, m.max(i), true, cache);\\n                        mn = mn.min(x);\\n                    } \\n                    cache.insert((idx,m,false),mn);\\n                    return mn\\n                }\\n            }\\n    \\n            minmax(0,&piles,1, true, &mut HashMap::with_capacity((piles.len()-1).pow(2)))\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564486,
                "title": "java-top-down-dp-memoization-approach",
                "content": "```\\n// Approach 2: Top Down DP (Memoization)\\n\\n// Time complexity: O(n^3)\\n// Space complexity: O(n^2)\\n\\nclass Solution {\\n    int[] piles;\\n    Integer[][][] memo;\\n    \\n    public int stoneGameII(int[] piles) {\\n        this.piles = piles;\\n        memo = new Integer[2][piles.length + 1][piles.length + 1];\\n        \\n        return dfs(0, 0, 1);\\n    }\\n    \\n    private int dfs(int p, int i, int m) {\\n        if (i >= piles.length)\\n            return 0;\\n        \\n        if (memo[p][i][m] != null) \\n            return memo[p][i][m];\\n        \\n        int res = p == 0 ? 0 : 1000000;\\n        int total = 0;\\n        \\n        for (int x = 1; x <= 2 * m; x++) {\\n            if (i + x > piles.length)\\n                break;\\n            \\n            total += piles[i + x - 1];\\n            \\n            if (p == 0)\\n                res = Math.max(res, total + dfs(1, i + x, Math.max(m, x)));\\n            else\\n                res = Math.min(res, dfs(0, i + x, Math.max(m, x)));\\n        }\\n        \\n        return memo[p][i][m] = res;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// Approach 2: Top Down DP (Memoization)\\n\\n// Time complexity: O(n^3)\\n// Space complexity: O(n^2)\\n\\nclass Solution {\\n    int[] piles;\\n    Integer[][][] memo;\\n    \\n    public int stoneGameII(int[] piles) {\\n        this.piles = piles;\\n        memo = new Integer[2][piles.length + 1][piles.length + 1];\\n        \\n        return dfs(0, 0, 1);\\n    }\\n    \\n    private int dfs(int p, int i, int m) {\\n        if (i >= piles.length)\\n            return 0;\\n        \\n        if (memo[p][i][m] != null) \\n            return memo[p][i][m];\\n        \\n        int res = p == 0 ? 0 : 1000000;\\n        int total = 0;\\n        \\n        for (int x = 1; x <= 2 * m; x++) {\\n            if (i + x > piles.length)\\n                break;\\n            \\n            total += piles[i + x - 1];\\n            \\n            if (p == 0)\\n                res = Math.max(res, total + dfs(1, i + x, Math.max(m, x)));\\n            else\\n                res = Math.min(res, dfs(0, i + x, Math.max(m, x)));\\n        }\\n        \\n        return memo[p][i][m] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563759,
                "title": "c-solution-dp-o-n-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int StoneGameII(int[] piles) {\\n        int n = piles.Length;\\n        int[,] dp = new int[n,n];\\n        int[] sums = new int[n];\\n        sums[n-1] = piles[n-1];\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i,j] = -1;\\n            }\\n        }\\n\\n        // Calculate the Prefix sum to store the number of stones\\n        // that are available post this particular postion\\n        for(int i=piles.Length-2; i>=0; i--){\\n            sums[i] = sums[i+1]+piles[i];\\n        }\\n\\n        return DFS(piles, sums, dp, 0, 1);\\n    }\\n\\n    private int DFS(int[] piles, int[] sums, int[,] dp, int i, int M){\\n        // No piles left\\n        if(i==piles.Length){\\n            return 0;\\n        }\\n\\n        // store 2*M to avoid calculation again and again\\n        int twiceM = (M<<1);\\n\\n        // Player will get all the piles\\n        if(i + twiceM >= piles.Length){\\n            return sums[i];\\n        }\\n        \\n        // If already calculated for i and M combination. Return that Value.\\n        if(dp[i, M] != -1){\\n            return dp[i, M];\\n        }\\n\\n        int min = int.MaxValue;\\n\\n        // Find out the min piles that can be taken By next Player\\n        for(int j=1; j<=twiceM; j++){\\n            min = Math.Min(min, DFS(piles, sums, dp, i+j, Math.Max(j, M)));\\n        }\\n\\n        // return the number of stones.\\n        return dp[i, M] = sums[i] - min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public int StoneGameII(int[] piles) {\\n        int n = piles.Length;\\n        int[,] dp = new int[n,n];\\n        int[] sums = new int[n];\\n        sums[n-1] = piles[n-1];\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i,j] = -1;\\n            }\\n        }\\n\\n        // Calculate the Prefix sum to store the number of stones\\n        // that are available post this particular postion\\n        for(int i=piles.Length-2; i>=0; i--){\\n            sums[i] = sums[i+1]+piles[i];\\n        }\\n\\n        return DFS(piles, sums, dp, 0, 1);\\n    }\\n\\n    private int DFS(int[] piles, int[] sums, int[,] dp, int i, int M){\\n        // No piles left\\n        if(i==piles.Length){\\n            return 0;\\n        }\\n\\n        // store 2*M to avoid calculation again and again\\n        int twiceM = (M<<1);\\n\\n        // Player will get all the piles\\n        if(i + twiceM >= piles.Length){\\n            return sums[i];\\n        }\\n        \\n        // If already calculated for i and M combination. Return that Value.\\n        if(dp[i, M] != -1){\\n            return dp[i, M];\\n        }\\n\\n        int min = int.MaxValue;\\n\\n        // Find out the min piles that can be taken By next Player\\n        for(int j=1; j<=twiceM; j++){\\n            min = Math.Min(min, DFS(piles, sums, dp, i+j, Math.Max(j, M)));\\n        }\\n\\n        // return the number of stones.\\n        return dp[i, M] = sums[i] - min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563533,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n  public:\\n    int dfs(int idx_start, int M, vector<int> &postfix, int n, vector<vector<int>> &cach) {\\n        if (idx_start >= n)\\n            return 0;\\n\\n        int minnum = 1000001;\\n        if (cach[idx_start][M] >= 0) {\\n            return cach[idx_start][M];\\n        }\\n        for (int i = idx_start + 1; i <= idx_start + 2 * M && i <= n; i++) { \\n            int tmp = dfs(i, std::max(i - idx_start, M), postfix, n, cach);\\n            if (minnum > tmp) {\\n                minnum = tmp;\\n            }\\n        }\\n        cach[idx_start][M] = postfix[idx_start] - minnum;\\n        return cach[idx_start][M];\\n    }\\n    int stoneGameII(vector<int> &piles) {\\n        int n = piles.size();\\n        vector<int> postfix(n + 1, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            postfix[i] = postfix[i + 1] + piles[i];\\n        }\\n        vector<vector<int>> cach(n + 1, vector<int>(n + 1, -1));\\n        return dfs(0, 1, postfix, n, cach);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int dfs(int idx_start, int M, vector<int> &postfix, int n, vector<vector<int>> &cach) {\\n        if (idx_start >= n)\\n            return 0;\\n\\n        int minnum = 1000001;\\n        if (cach[idx_start][M] >= 0) {\\n            return cach[idx_start][M];\\n        }\\n        for (int i = idx_start + 1; i <= idx_start + 2 * M && i <= n; i++) { \\n            int tmp = dfs(i, std::max(i - idx_start, M), postfix, n, cach);\\n            if (minnum > tmp) {\\n                minnum = tmp;\\n            }\\n        }\\n        cach[idx_start][M] = postfix[idx_start] - minnum;\\n        return cach[idx_start][M];\\n    }\\n    int stoneGameII(vector<int> &piles) {\\n        int n = piles.size();\\n        vector<int> postfix(n + 1, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            postfix[i] = postfix[i + 1] + piles[i];\\n        }\\n        vector<vector<int>> cach(n + 1, vector<int>(n + 1, -1));\\n        return dfs(0, 1, postfix, n, cach);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563516,
                "title": "easy-o-n-3-optimal-solution-dp-explained-in-3-sentences",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo maximize the stones you get, it\\'s equivalent to maximize the `score` you get, where `score` is defined to be\\n$$\\n\\\\text{score} = \\\\text{stones you get} - \\\\text{stones next player get}\\n$$\\n\\nYou could choose to pick some stones, now the piles would be in another index and maybe an updated `m`, so it\\'s staightforward dp:\\n`dp[i][m] = max(dp[i][m], stones_taken - dp[i + t][future_m])`\\n> It\\'s `stones_taken - \"dp next\"` because players take turns.\\n\\nand run this for all possible t.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^3)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n  int stoneGameII(vector<int>& piles) {\\n    const int S = std::accumulate(piles.begin(), piles.end(), 0);\\n    const int N = piles.size();\\n    // score[i][m] := the best score the player can get when facing index i of the piles\\n    // and with the m value set.\\n    // `score` means the *difference* between the stone this player can get and the next\\n    // player.\\n    vector<vector<int>> scores(N + 1, vector<int>(N + 1, -S));\\n    for (int m = 1; m <= N; ++m) {\\n      scores.back()[m] = 0;\\n    }\\n    for (int i = N - 1; i >= 0; --i) {\\n      vector<int>& i_score = scores[i];\\n      int stone = 0;\\n      for (int j = i; j < N; ++j) {\\n        stone += piles[j];\\n        int taken = j - i + 1;\\n        for (int m = (taken + 1) / 2; m <= N; ++m) {\\n          int future_m = max(m, taken);\\n          i_score[m] = max(i_score[m], stone - scores[j + 1][future_m]);\\n        }\\n      }\\n    }\\n    return (scores[0][1] + S) / 2;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n  int stoneGameII(vector<int>& piles) {\\n    const int S = std::accumulate(piles.begin(), piles.end(), 0);\\n    const int N = piles.size();\\n    // score[i][m] := the best score the player can get when facing index i of the piles\\n    // and with the m value set.\\n    // `score` means the *difference* between the stone this player can get and the next\\n    // player.\\n    vector<vector<int>> scores(N + 1, vector<int>(N + 1, -S));\\n    for (int m = 1; m <= N; ++m) {\\n      scores.back()[m] = 0;\\n    }\\n    for (int i = N - 1; i >= 0; --i) {\\n      vector<int>& i_score = scores[i];\\n      int stone = 0;\\n      for (int j = i; j < N; ++j) {\\n        stone += piles[j];\\n        int taken = j - i + 1;\\n        for (int m = (taken + 1) / 2; m <= N; ++m) {\\n          int future_m = max(m, taken);\\n          i_score[m] = max(i_score[m], stone - scores[j + 1][future_m]);\\n        }\\n      }\\n    }\\n    return (scores[0][1] + S) / 2;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563410,
                "title": "ruby-minimax-with-recursion",
                "content": "# Code\\n\\n```ruby\\ndef min(a, b) = a < b ? a : b\\ndef max(a, b) = a > b ? a : b\\ndef stone_game_ii(piles)\\n  st = 0\\n  ps = piles.map! { st += _1 }.unshift(0)\\n  z = ps.size\\n  game = Array.new(z) do |i|\\n    remaining_stones = ps[-1] - ps[i]\\n    Hash.new do |h, m|\\n      min_best_response = (i + 1..min(i + 2 * m, z)).map { game[_1][max(m, _1 - i)] }.min\\n      h[m] = remaining_stones - min_best_response\\n    end\\n  end << -> _ { 0 }\\n\\n  game[0][1]\\nend\\n```\\n\\n# Time complexity\\n\\n$$\\\\mathcal{O}(n^2)$$\\n\\n# Space complexity\\n\\n$$\\\\mathcal{O}(n^2)$$",
                "solutionTags": [
                    "Ruby",
                    "Recursion",
                    "Game Theory"
                ],
                "code": "```ruby\\ndef min(a, b) = a < b ? a : b\\ndef max(a, b) = a > b ? a : b\\ndef stone_game_ii(piles)\\n  st = 0\\n  ps = piles.map! { st += _1 }.unshift(0)\\n  z = ps.size\\n  game = Array.new(z) do |i|\\n    remaining_stones = ps[-1] - ps[i]\\n    Hash.new do |h, m|\\n      min_best_response = (i + 1..min(i + 2 * m, z)).map { game[_1][max(m, _1 - i)] }.min\\n      h[m] = remaining_stones - min_best_response\\n    end\\n  end << -> _ { 0 }\\n\\n  game[0][1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3563353,
                "title": "ruby-solution-with-memoization-100-100",
                "content": "# Intuition\\nUse memoization to find the optimal play.\\n\\n# Approach\\n1. Create a memo object and a class variable for piles.\\n2. Find the max score difference (Alice\\'s score - Bob\\'s score) Alice can get, starting at index 0 with a max of 1.\\n3. Find the number of points Alice and Bob split evenly.  (For example, if there were 12 point total and Alice got 4 more, that means the other 8 points were split evenly.  The intuition doesn\\'t fit as well if Alice got fewer points, but the math does.)\\n4. Give Alice that half of the points that were evenly split, plus her score difference.\\n\\nHelper function:\\n1. Return 0 if all stones have been taken\\n2. Return a memoized value if possible\\n3. Find all possible scores (where a score is calculated by taking a certain number of stones and adding those points, then *subtracting* the score from Bob\\'s option).  Choose the max score, and update the max variable if appropriate.\\n4. Memoize and return the max score.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n * log(n))$$\\n\\n# Code\\n```\\ndef stone_game_ii(piles)\\n    @memo = {}\\n    @piles = piles\\n    score = score(0,1)\\n    sum = piles.sum - score\\n    score + sum / 2\\nend\\n\\ndef score(idx,max)\\n    return 0 if idx >= @piles.length\\n    return @memo[[idx,max]] if @memo[[idx,max]]\\n    orig_max = max\\n\\n    max_score = -Float::INFINITY\\n    (1..2*max).each do |i|\\n        next if idx + i > @piles.length\\n        \\n        curr_score = @piles[idx...idx+i].sum - score(idx+i,[i,max].max)\\n        if curr_score > max_score\\n            max_score = curr_score\\n            max = i if i > max\\n        end\\n    end\\n\\n    @memo[[idx,orig_max]] = max_score\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef stone_game_ii(piles)\\n    @memo = {}\\n    @piles = piles\\n    score = score(0,1)\\n    sum = piles.sum - score\\n    score + sum / 2\\nend\\n\\ndef score(idx,max)\\n    return 0 if idx >= @piles.length\\n    return @memo[[idx,max]] if @memo[[idx,max]]\\n    orig_max = max\\n\\n    max_score = -Float::INFINITY\\n    (1..2*max).each do |i|\\n        next if idx + i > @piles.length\\n        \\n        curr_score = @piles[idx...idx+i].sum - score(idx+i,[i,max].max)\\n        if curr_score > max_score\\n            max_score = curr_score\\n            max = i if i > max\\n        end\\n    end\\n\\n    @memo[[idx,orig_max]] = max_score\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3563323,
                "title": "prefix-sum-approach-c-beats-96",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> p;\\n    vector<int> p_sum;\\n    vector<vector<int>> dp;\\n    \\n    int stoneGameII(vector<int>& p) \\n    {\\n        this->n = p.size();\\n        this->p = p;\\n        \\n        dp.resize(n, vector<int>(n, -1));\\n        \\n        p_sum.resize(n+1, 0);\\n        for(int i = 1 ; i <= n ; ++i) {\\n            p_sum[i] = p_sum[i-1] + p[i-1];\\n        }\\n        \\n        return solve(0, 1);\\n    }\\n    int solve(int index, int m)\\n    {\\n        if(index >= n) {\\n        return 0;            \\n        }\\n        if(index + 2*m >= n){\\n        return p_sum[n] - p_sum[index];\\n        } \\n        if(dp[index][m] != -1){\\n        return dp[index][m];\\n        } \\n        \\n        int ans = INT_MAX;\\n        for(int i = 1 ; i <= 2*m ; ++i)\\n        {\\n            ans = min(ans, solve(index + i, max(i, m)));\\n        }\\n        return dp[index][m] = (p_sum[n] - p_sum[index] - ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Prefix Sum",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> p;\\n    vector<int> p_sum;\\n    vector<vector<int>> dp;\\n    \\n    int stoneGameII(vector<int>& p) \\n    {\\n        this->n = p.size();\\n        this->p = p;\\n        \\n        dp.resize(n, vector<int>(n, -1));\\n        \\n        p_sum.resize(n+1, 0);\\n        for(int i = 1 ; i <= n ; ++i) {\\n            p_sum[i] = p_sum[i-1] + p[i-1];\\n        }\\n        \\n        return solve(0, 1);\\n    }\\n    int solve(int index, int m)\\n    {\\n        if(index >= n) {\\n        return 0;            \\n        }\\n        if(index + 2*m >= n){\\n        return p_sum[n] - p_sum[index];\\n        } \\n        if(dp[index][m] != -1){\\n        return dp[index][m];\\n        } \\n        \\n        int ans = INT_MAX;\\n        for(int i = 1 ; i <= 2*m ; ++i)\\n        {\\n            ans = min(ans, solve(index + i, max(i, m)));\\n        }\\n        return dp[index][m] = (p_sum[n] - p_sum[index] - ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559483,
                "title": "c-dp-easy-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int helper(vector<int>& piles,vector<vector<int>>& memo,vector<int>& sum, int start, int M){\\n        if(start == n-1) return piles[start];\\n        if(memo[start][M] != -1) return memo[start][M];\\n        \\n        //if M> number of piles left, take the suffix sum directly\\n        if(n-start<= 2*M) return sum[start];\\n        \\n        int ans =INT_MAX;\\n        //can take minimum 1, maximum 2M piles\\n        for(int i=1;i<=2*M;i++){\\n            //to minimize opponent\\'s choice\\n            ans =min(ans, helper(piles,memo,sum,start+i,max(M,i)));\\n        }\\n        \\n        //result is (sum - opponent\\'s score)\\n         return memo[start][M] =sum[start] - ans;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        n=piles.size();\\n        \\n        //calculate suffix sum        \\n        vector<int> sum(n);\\n        sum[n-1] = piles[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            sum[i] = piles[i] + sum[i+1];\\n        }\\n        \\n        //<start index,M>\\n        vector<vector<int>> memo(n,vector<int>(2*n,-1));\\n        return helper(piles,memo,sum,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int helper(vector<int>& piles,vector<vector<int>>& memo,vector<int>& sum, int start, int M){\\n        if(start == n-1) return piles[start];\\n        if(memo[start][M] != -1) return memo[start][M];\\n        \\n        //if M> number of piles left, take the suffix sum directly\\n        if(n-start<= 2*M) return sum[start];\\n        \\n        int ans =INT_MAX;\\n        //can take minimum 1, maximum 2M piles\\n        for(int i=1;i<=2*M;i++){\\n            //to minimize opponent\\'s choice\\n            ans =min(ans, helper(piles,memo,sum,start+i,max(M,i)));\\n        }\\n        \\n        //result is (sum - opponent\\'s score)\\n         return memo[start][M] =sum[start] - ans;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        n=piles.size();\\n        \\n        //calculate suffix sum        \\n        vector<int> sum(n);\\n        sum[n-1] = piles[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            sum[i] = piles[i] + sum[i+1];\\n        }\\n        \\n        //<start index,M>\\n        vector<vector<int>> memo(n,vector<int>(2*n,-1));\\n        return helper(piles,memo,sum,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373505,
                "title": "c-simple-dp-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,dp[101][501];\\n    vector<int>suff; // suffix sum array\\n    int dfs(int curr,int m,vector<int>&nums){\\n        if(curr==n) return 0;\\n        if(curr+2*m>=n)  // take all the remaining elements if it\\'s possible\\n            return suff[curr];\\n        if(dp[curr][m]!=-1)  // if already calculated\\n            return dp[curr][m];\\n        int mx=0,sum=0;\\n        for(int i=1;i<=2*m && curr+i<n;i++){\\n            sum+=nums[curr+i-1]; // sum keeps track of what curr player will take\\n            \\n            // once the current player is done, the next player will take the maximum he can out of remaining elements, so what the current player will get is : sum + (whatever is remaining)\\n            mx=max(mx,sum+suff[curr+i]-dfs(curr+i,max(m,i),nums)); \\n        }\\n        return dp[curr][m]=mx;\\n    }\\n    int stoneGameII(vector<int>& nums) {\\n        n=nums.size();\\n        suff=nums;\\n        for(int i=n-2;i>=0;i--)\\n            suff[i]+=suff[i+1];\\n        suff.push_back(0);\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(0,1,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,dp[101][501];\\n    vector<int>suff; // suffix sum array\\n    int dfs(int curr,int m,vector<int>&nums){\\n        if(curr==n) return 0;\\n        if(curr+2*m>=n)  // take all the remaining elements if it\\'s possible\\n            return suff[curr];\\n        if(dp[curr][m]!=-1)  // if already calculated\\n            return dp[curr][m];\\n        int mx=0,sum=0;\\n        for(int i=1;i<=2*m && curr+i<n;i++){\\n            sum+=nums[curr+i-1]; // sum keeps track of what curr player will take\\n            \\n            // once the current player is done, the next player will take the maximum he can out of remaining elements, so what the current player will get is : sum + (whatever is remaining)\\n            mx=max(mx,sum+suff[curr+i]-dfs(curr+i,max(m,i),nums)); \\n        }\\n        return dp[curr][m]=mx;\\n    }\\n    int stoneGameII(vector<int>& nums) {\\n        n=nums.size();\\n        suff=nums;\\n        for(int i=n-2;i>=0;i--)\\n            suff[i]+=suff[i+1];\\n        suff.push_back(0);\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(0,1,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223050,
                "title": "python-well-written-comment-explanation-dp-easy",
                "content": "# EXPLANATION\\n```\\nThe question is based on Game Theory\\n\\nOn each turn the player plays their turn and then swap the turns so \\nalice plays - > bob plays - > alice plays ......\\n\\nBoth play optimally i.e. to win the game\\n\\nIn such problems we use minmax algorithm i.e. \\nLet us say that the turn is of Alice , now alice have say 5 choices so Alice will select the choice \\nwhich will minimize bob next score\\ni.e. instead of maxmizing a player score we are focusing on minimizing the opponent score\\n```\\n\\n\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n        dp = {} \\n        def recursion(index,M):\\n            # if we reached to the end we cannot score any value\\n            if index == n:\\n                return 0\\n            # we search if we have solved the same case earlier\\n            if (index,M) in dp:\\n                return dp[(index,M)] \\n            # total remaining score is the sum of array from index to the end\\n            total = sum(piles[index:])           \\n            # if we can take the complete array it is the best choice\\n            if index + 2*M >= n :return total\\n            # my_score is the score we are getting as the player who is playing\\n            my_score = 0\\n            for x in range(index,index+2*M):\\n                # opponent score will be calculated by next recursion\\n                opponent_score = recursion(x+1,max(M,x-index+1))\\n                # my_score is the remaining value of total - opponent_score\\n                my_score = max(my_score,total - opponent_score)          \\n            # this is memoization part\\n            dp[(index,M)] = my_score\\n            # return the score\\n            return my_score\\n        \\n        return recursion(0,1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nThe question is based on Game Theory\\n\\nOn each turn the player plays their turn and then swap the turns so \\nalice plays - > bob plays - > alice plays ......\\n\\nBoth play optimally i.e. to win the game\\n\\nIn such problems we use minmax algorithm i.e. \\nLet us say that the turn is of Alice , now alice have say 5 choices so Alice will select the choice \\nwhich will minimize bob next score\\ni.e. instead of maxmizing a player score we are focusing on minimizing the opponent score\\n```\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        n = len(piles)\\n        dp = {} \\n        def recursion(index,M):\\n            # if we reached to the end we cannot score any value\\n            if index == n:\\n                return 0\\n            # we search if we have solved the same case earlier\\n            if (index,M) in dp:\\n                return dp[(index,M)] \\n            # total remaining score is the sum of array from index to the end\\n            total = sum(piles[index:])           \\n            # if we can take the complete array it is the best choice\\n            if index + 2*M >= n :return total\\n            # my_score is the score we are getting as the player who is playing\\n            my_score = 0\\n            for x in range(index,index+2*M):\\n                # opponent score will be calculated by next recursion\\n                opponent_score = recursion(x+1,max(M,x-index+1))\\n                # my_score is the remaining value of total - opponent_score\\n                my_score = max(my_score,total - opponent_score)          \\n            # this is memoization part\\n            dp[(index,M)] = my_score\\n            # return the score\\n            return my_score\\n        \\n        return recursion(0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626740,
                "title": "javascript-dp-tabulation",
                "content": "dp[i][j] is the maximum number of stones Alex can get when starting at index i with M = j\\nsufsum[i] is the total number of stones from index i to the end\\nThe dp matrix for Lee is the same. And the stragegy for Alex is to choose an optimal X to minimize the number of stones Lee can get when starting at index (i + X) with M = max(X,j). Here we have the recurrence formula\\n\\n```\\ndp[i][j] = max(sufsum[i] - dp[i + X][max(j, X)]) where 1<= X <= 2j;\\n```\\n\\n```\\nvar stoneGameII = function(piles) {\\n  const length = piles.length;\\n  const dp = [...Array(length + 1).fill(null)].map((_) =>\\n    Array(length + 1).fill(0)\\n  );\\n  const sufsum = new Array(length + 1).fill(0);\\n  for (let i = length - 1; i >= 0; i--) {\\n    sufsum[i] = sufsum[i + 1] + piles[i];\\n  }\\n  for (let i = 0; i <= length; i++) {\\n    dp[i][length] = sufsum[i];\\n  }\\n  for (let i = length - 1; i >= 0; i--) {\\n    for (let j = length - 1; j >= 1; j--) {\\n      for (let X = 1; X <= 2 * j && i + X <= length; X++) {\\n        dp[i][j] = Math.max(dp[i][j], sufsum[i] - dp[i + X][Math.max(j, X)]);\\n      }\\n    }\\n  }\\n  return dp[0][1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j] = max(sufsum[i] - dp[i + X][max(j, X)]) where 1<= X <= 2j;\\n```\n```\\nvar stoneGameII = function(piles) {\\n  const length = piles.length;\\n  const dp = [...Array(length + 1).fill(null)].map((_) =>\\n    Array(length + 1).fill(0)\\n  );\\n  const sufsum = new Array(length + 1).fill(0);\\n  for (let i = length - 1; i >= 0; i--) {\\n    sufsum[i] = sufsum[i + 1] + piles[i];\\n  }\\n  for (let i = 0; i <= length; i++) {\\n    dp[i][length] = sufsum[i];\\n  }\\n  for (let i = length - 1; i >= 0; i--) {\\n    for (let j = length - 1; j >= 1; j--) {\\n      for (let X = 1; X <= 2 * j && i + X <= length; X++) {\\n        dp[i][j] = Math.max(dp[i][j], sufsum[i] - dp[i + X][Math.max(j, X)]);\\n      }\\n    }\\n  }\\n  return dp[0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1586738,
                "title": "c-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101] = {[0 ... 100][0 ... 100] = -1};\\n    int dfs (int i, int M, vector<int>& piles, int sum) {\\n        int ret = 0, n = piles.size(), e = i + 2 * M;\\n        if (e >= n) return sum;\\n        if (dp[i][e] >= 0) return dp[i][e];\\n        for (int j = i, nsum = sum; j < e; j++) {\\n            M = max(M, j - i + 1);\\n            nsum -= piles[j];\\n            ret = max(ret, sum - dfs(j + 1, M, piles, nsum));\\n        }\\n        return dp[i][e] = ret;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        return dfs(0, 1, piles, accumulate(piles.begin(), piles.end(), 0));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101] = {[0 ... 100][0 ... 100] = -1};\\n    int dfs (int i, int M, vector<int>& piles, int sum) {\\n        int ret = 0, n = piles.size(), e = i + 2 * M;\\n        if (e >= n) return sum;\\n        if (dp[i][e] >= 0) return dp[i][e];\\n        for (int j = i, nsum = sum; j < e; j++) {\\n            M = max(M, j - i + 1);\\n            nsum -= piles[j];\\n            ret = max(ret, sum - dfs(j + 1, M, piles, nsum));\\n        }\\n        return dp[i][e] = ret;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        return dfs(0, 1, piles, accumulate(piles.begin(), piles.end(), 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394518,
                "title": "c-solution-using-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n/*\\nLogic:Simple recursion will give you tle ,so we will go with memorizing steps.\\nNow here we are calculating the difference in the scores of alice and bob , \\ni.e we are playing optimally for both alice and bob, so what we will be doing is just\\nadding the current pile score to total and playing optimally for opponent player and calculating the difference in their score.\\nso let us supoose we have alice score->A and bob score->B then from \\nhelper function we are getting A-B and we know that sum of piles=A+B \\nthen A=((A+B)+(A-B))/2.....\\n*/\\n    int dp[101][202];\\n    int helper(int i,int M,vector<int>&piles){\\n        //base case\\n        if(i>=piles.size())\\n            return 0;\\n        //memorised step\\n        if(dp[i][M]!=-1)\\n            return dp[i][M];\\n        //calculate total for current player and let opponent play for themself.\\n        int tot=0;\\n        //initialize ans for comparing ans and having maximum.\\n        int ans=INT_MIN;\\n        for(int j=0;j<2*M;j++){\\n            if(i+j<piles.size())\\n                tot+=piles[i+j];\\n            ans=max(ans,tot-helper(i+j+1,max(M,j+1),piles));\\n        }\\n        return dp[i][M]=ans;\\n    }\\n    \\n    \\n    int stoneGameII(vector<int>& piles) {\\n        //initialise dp with -1.\\n        memset(dp,-1,sizeof dp);\\n        int sum=0;\\n        for(int i=0;i<piles.size();i++)\\n            sum+=piles[i];\\n        int diff=helper(0,1,piles);\\n        return (sum+diff)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\nLogic:Simple recursion will give you tle ,so we will go with memorizing steps.\\nNow here we are calculating the difference in the scores of alice and bob , \\ni.e we are playing optimally for both alice and bob, so what we will be doing is just\\nadding the current pile score to total and playing optimally for opponent player and calculating the difference in their score.\\nso let us supoose we have alice score->A and bob score->B then from \\nhelper function we are getting A-B and we know that sum of piles=A+B \\nthen A=((A+B)+(A-B))/2.....\\n*/\\n    int dp[101][202];\\n    int helper(int i,int M,vector<int>&piles){\\n        //base case\\n        if(i>=piles.size())\\n            return 0;\\n        //memorised step\\n        if(dp[i][M]!=-1)\\n            return dp[i][M];\\n        //calculate total for current player and let opponent play for themself.\\n        int tot=0;\\n        //initialize ans for comparing ans and having maximum.\\n        int ans=INT_MIN;\\n        for(int j=0;j<2*M;j++){\\n            if(i+j<piles.size())\\n                tot+=piles[i+j];\\n            ans=max(ans,tot-helper(i+j+1,max(M,j+1),piles));\\n        }\\n        return dp[i][M]=ans;\\n    }\\n    \\n    \\n    int stoneGameII(vector<int>& piles) {\\n        //initialise dp with -1.\\n        memset(dp,-1,sizeof dp);\\n        int sum=0;\\n        for(int i=0;i<piles.size();i++)\\n            sum+=piles[i];\\n        int diff=helper(0,1,piles);\\n        return (sum+diff)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245591,
                "title": "cpp-dp-recursion",
                "content": "points  function will return the points alice scores at any state. \\nAlice will try to maximize her own points\\nand Bob will try to minimize the points being sent to alice.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[101][201][2];\\n    int points(vector<int>& piles, int start, int M, bool alice){\\n        int n = piles.size();\\n        if(start>=n) return 0;\\n        if(dp[start][M][alice]!=-1) return dp[start][M][alice];\\n        int pointsgot;\\n        if(alice){\\n            pointsgot = INT_MIN;\\n            int temppoints = 0;\\n            for(int x=start; x<min(2*M+start,n); x++){\\n                temppoints += piles[x];\\n                pointsgot = max(pointsgot, temppoints+points(piles,x+1,max(M,x+1-start),false));\\n            }\\n        }\\n        else{\\n            pointsgot = INT_MAX;\\n            for(int x=start; x<min(2*M+start,n); x++){\\n                pointsgot = min(pointsgot, points(piles,x+1,max(M,x+1-start),true));\\n            }\\n        }\\n        dp[start][M][alice] = pointsgot;\\n        return pointsgot;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        for(int i=0; i<101; i++)\\n            for(int j=0; j<201; j++)\\n                for(int k=0; k<2; k++)\\n                    dp[i][j][k]=-1;\\n        return points(piles, 0, 1, true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[101][201][2];\\n    int points(vector<int>& piles, int start, int M, bool alice){\\n        int n = piles.size();\\n        if(start>=n) return 0;\\n        if(dp[start][M][alice]!=-1) return dp[start][M][alice];\\n        int pointsgot;\\n        if(alice){\\n            pointsgot = INT_MIN;\\n            int temppoints = 0;\\n            for(int x=start; x<min(2*M+start,n); x++){\\n                temppoints += piles[x];\\n                pointsgot = max(pointsgot, temppoints+points(piles,x+1,max(M,x+1-start),false));\\n            }\\n        }\\n        else{\\n            pointsgot = INT_MAX;\\n            for(int x=start; x<min(2*M+start,n); x++){\\n                pointsgot = min(pointsgot, points(piles,x+1,max(M,x+1-start),true));\\n            }\\n        }\\n        dp[start][M][alice] = pointsgot;\\n        return pointsgot;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        for(int i=0; i<101; i++)\\n            for(int j=0; j<201; j++)\\n                for(int k=0; k<2; k++)\\n                    dp[i][j][k]=-1;\\n        return points(piles, 0, 1, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191798,
                "title": "java-clean-o-n-2-memoization-solution-with-detailed-comments",
                "content": "This memoization solution is very straightforward. The reason why I avoid Dynamic Programming is its base cases are a little bit arkward. The prefix sum array is constructed for the purpose of fast calculation of range sum. \\n```\\npfxSum[0] = 0\\npfxSum[1] = 0 + piles[0]\\n       ...\\npfxSum[i] = 0 + piles[0] + ... + piles[i-1]\\npfxSum[i+1] = 0 + piles[0] + ... + piles[i-1] + piles[i]\\n\\n//Thus piles[i : j] = pfxSum[j+1] - pfxSum[i];\\n```\\n\\nNow there\\'s really no tricks in this Solution.\\n\\n```\\nclass Solution {\\n    private int[] pfxSum;\\n    private int n;\\n    \\n    // memo[i][j] : max score when starting with stone index = i, with M = j\\n    private int[][] memo;\\n    \\n    public int stoneGameII(int[] piles) {\\n        this.n = piles.length;\\n        this.memo = new int[n][n+1];\\n        \\n        this.pfxSum = new int[n+1];\\n        for (int i = 0; i < n; i++) {\\n            pfxSum[i+1] = pfxSum[i] + piles[i]; \\n        }\\n        \\n        return dfs(0, 1);\\n    }\\n    \\n    private int dfs(int idx, int M) {\\n        if (idx >= n) return 0;\\n        if (memo[idx][M] != 0) return memo[idx][M];\\n        \\n        int res = 0;\\n        \\n        // may take [0, 2 * M] piles \\n        for (int i = idx; i < Math.min(idx + 2 * M, n); i++) {\\n            int X = i - idx + 1;\\n            \\n            // the other player will start from index = i+1, with M = max(M, X);\\n            res = Math.max(res, pfxSum[n] - pfxSum[idx] - dfs(i + 1, Math.max(M, X)));\\n        }\\n        \\n        return memo[idx][M] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\npfxSum[0] = 0\\npfxSum[1] = 0 + piles[0]\\n       ...\\npfxSum[i] = 0 + piles[0] + ... + piles[i-1]\\npfxSum[i+1] = 0 + piles[0] + ... + piles[i-1] + piles[i]\\n\\n//Thus piles[i : j] = pfxSum[j+1] - pfxSum[i];\\n```\n```\\nclass Solution {\\n    private int[] pfxSum;\\n    private int n;\\n    \\n    // memo[i][j] : max score when starting with stone index = i, with M = j\\n    private int[][] memo;\\n    \\n    public int stoneGameII(int[] piles) {\\n        this.n = piles.length;\\n        this.memo = new int[n][n+1];\\n        \\n        this.pfxSum = new int[n+1];\\n        for (int i = 0; i < n; i++) {\\n            pfxSum[i+1] = pfxSum[i] + piles[i]; \\n        }\\n        \\n        return dfs(0, 1);\\n    }\\n    \\n    private int dfs(int idx, int M) {\\n        if (idx >= n) return 0;\\n        if (memo[idx][M] != 0) return memo[idx][M];\\n        \\n        int res = 0;\\n        \\n        // may take [0, 2 * M] piles \\n        for (int i = idx; i < Math.min(idx + 2 * M, n); i++) {\\n            int X = i - idx + 1;\\n            \\n            // the other player will start from index = i+1, with M = max(M, X);\\n            res = Math.max(res, pfxSum[n] - pfxSum[idx] - dfs(i + 1, Math.max(M, X)));\\n        }\\n        \\n        return memo[idx][M] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184818,
                "title": "clean-python-solution",
                "content": "```python\\n\"\"\"\\nhelper(start, m) := the max stones that the first player will get with given piles[start:] and M.\\nmax_stones = MAX{ (sum of all the stones) - (max_stones the other player will get) } = MAX{ sum(piles[start:]) - helper(start+x, max(m, x)) }\\n\"\"\"\\nclass Solution(object):\\n    def stoneGameII(self, piles):\\n        def helper(start, m):\\n            if (start, m) in history: return history[(start, m)]\\n            \\n            if start>=len(piles): return 0\\n            if start+m*2>=len(piles): return sum(piles[start:])\\n            \\n            max_stones = float(\\'-inf\\')\\n            for x in xrange(1, m*2+1):\\n                max_stones = max(max_stones, sum(piles[start:])-helper(start+x, max(m, x)))\\n            \\n            history[(start, m)] = max_stones\\n            return history[(start, m)]\\n        \\n        history = {}\\n        return helper(0, 1)\\n\\n\"\"\"\\nSimilar Problems: 312, 664, 1024, 1039, 1140, 1130\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nhelper(start, m) := the max stones that the first player will get with given piles[start:] and M.\\nmax_stones = MAX{ (sum of all the stones) - (max_stones the other player will get) } = MAX{ sum(piles[start:]) - helper(start+x, max(m, x)) }\\n\"\"\"\\nclass Solution(object):\\n    def stoneGameII(self, piles):\\n        def helper(start, m):\\n            if (start, m) in history: return history[(start, m)]\\n            \\n            if start>=len(piles): return 0\\n            if start+m*2>=len(piles): return sum(piles[start:])\\n            \\n            max_stones = float(\\'-inf\\')\\n            for x in xrange(1, m*2+1):\\n                max_stones = max(max_stones, sum(piles[start:])-helper(start+x, max(m, x)))\\n            \\n            history[(start, m)] = max_stones\\n            return history[(start, m)]\\n        \\n        history = {}\\n        return helper(0, 1)\\n\\n\"\"\"\\nSimilar Problems: 312, 664, 1024, 1039, 1140, 1130\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154772,
                "title": "explained-approach-c-using-dp",
                "content": "Here, memo[i][m] represents maximum number of stones Alice can pick from position i till end where m governs total no of stones she can pick, i.e. x, such that 1 <= x <= 2 * m\\nWhen at position i, if Alice can pick max stone_count stones, then Bob can pick suffixSum[i] - stone_count stones. \\nSo for our dp state (i, m)\\nmemo[i][m] = Max no of stones Alice can pick\\nsuffixSum[i] - memo[i][m] = Max no of stones Bob can pick\\n\\nLet\\'s say we are at position i now, and m = 2, then Alice can pick piles x: 1, 2, 3... 4\\nthen for Bob, in next position, he can get stones memo[i + x][max(x, m)], which means Alice can get stones suffixSum[i + x] - memo[i + x][max(x, m)]\\n\\nSo, here we want to maximize stones Alice can get\\nsuffix[i] - suffix[i + x] + suffix[i + x] - memo[i + x][max(x, m)]\\n= suffix[i] - memo[i + x][max(x, m)]\\n, where x = 1... 2 * m\\n\\nAlso here m represents limit on no of piles to be chosen, so it cant exceed no of piles.\\nTop-down approach\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();        \\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n        vector<int> suffix(n + 1, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + piles[i];\\n        }\\n        \\n        return getStones(piles, 0, 1, memo, suffix);\\n    }\\n    \\n    int getStones(vector<int>& piles, int index, int m, vector<vector<int>>& memo, vector<int>& suffix) {     \\n        if (index + 2 * m >= piles.size()) {\\n            return suffix[index];\\n        } \\n        \\n        if (memo[index][m] != -1) {\\n            return memo[index][m];\\n        }\\n        \\n        int val = -1;\\n        for (int x = index + 1; x <= index + 2 * m; x++) {\\n            val = max(val, suffix[index] - getStones(piles, x, max(x - index, m), memo, suffix));    \\n        }\\n        \\n        memo[index][m] = val;\\n        return val;\\n    }\\n};\\n```\\n\\nBottom-Up approach\\n```\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();        \\n        vector<vector<int>> memo(n + 1, vector<int>(n + 1, -1));\\n        vector<int> suffix(n + 1, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + piles[i];\\n        }\\n        \\n        for (int index = n - 1; index >= 0; index--) {\\n            for (int m = 1; m <= n; m++) {\\n                if (index + 2 * m >= piles.size()) {\\n                    memo[index][m] = suffix[index];\\n                    continue;\\n                }\\n                \\n                int val = -1;\\n                for (int x = index + 1; x <= index + 2 * m; x++) {\\n                    val = max(val, suffix[index] - memo[x][max(x - index, m)]);    \\n                }\\n\\n                memo[index][m] = val;\\n            }\\n        }\\n        \\n        return memo[0][1];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();        \\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n        vector<int> suffix(n + 1, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + piles[i];\\n        }\\n        \\n        return getStones(piles, 0, 1, memo, suffix);\\n    }\\n    \\n    int getStones(vector<int>& piles, int index, int m, vector<vector<int>>& memo, vector<int>& suffix) {     \\n        if (index + 2 * m >= piles.size()) {\\n            return suffix[index];\\n        } \\n        \\n        if (memo[index][m] != -1) {\\n            return memo[index][m];\\n        }\\n        \\n        int val = -1;\\n        for (int x = index + 1; x <= index + 2 * m; x++) {\\n            val = max(val, suffix[index] - getStones(piles, x, max(x - index, m), memo, suffix));    \\n        }\\n        \\n        memo[index][m] = val;\\n        return val;\\n    }\\n};\\n```\n```\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();        \\n        vector<vector<int>> memo(n + 1, vector<int>(n + 1, -1));\\n        vector<int> suffix(n + 1, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + piles[i];\\n        }\\n        \\n        for (int index = n - 1; index >= 0; index--) {\\n            for (int m = 1; m <= n; m++) {\\n                if (index + 2 * m >= piles.size()) {\\n                    memo[index][m] = suffix[index];\\n                    continue;\\n                }\\n                \\n                int val = -1;\\n                for (int x = index + 1; x <= index + 2 * m; x++) {\\n                    val = max(val, suffix[index] - memo[x][max(x - index, m)]);    \\n                }\\n\\n                memo[index][m] = val;\\n            }\\n        }\\n        \\n        return memo[0][1];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078912,
                "title": "memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int dyn(vector<int> piles,int m){\\n        int mx=0, n=piles.size(), tot=accumulate(piles.begin(),piles.end(),0);\\n        if(dp[n][m]!=-1) return dp[n][m];\\n        if(n==0) return dp[n][m]=0;       \\n        for(int i=1;i<=min(n,2*m);i++){\\n            vector<int> ar(n-i);\\n            copy(piles.begin()+i,piles.end(),ar.begin());\\n            mx=max(mx,tot-dyn(ar,max(i,m)));\\n        }\\n        return dp[n][m]=mx;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        vector<vector<int>> dpp(200,vector<int>(200,-1));\\n        dp=dpp;\\n        return dyn(piles,1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int dyn(vector<int> piles,int m){\\n        int mx=0, n=piles.size(), tot=accumulate(piles.begin(),piles.end(),0);\\n        if(dp[n][m]!=-1) return dp[n][m];\\n        if(n==0) return dp[n][m]=0;       \\n        for(int i=1;i<=min(n,2*m);i++){\\n            vector<int> ar(n-i);\\n            copy(piles.begin()+i,piles.end(),ar.begin());\\n            mx=max(mx,tot-dyn(ar,max(i,m)));\\n        }\\n        return dp[n][m]=mx;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        vector<vector<int>> dpp(200,vector<int>(200,-1));\\n        dp=dpp;\\n        return dyn(piles,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068664,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[105][105][2];\\n    \\n    int solve(vector<int>&piles,int id,int m,int player)\\n    {\\n        if(id>=piles.size())\\n            return 0;\\n        \\n        else if(dp[id][m][player]!=-1)\\n            return  dp[id][m][player];\\n        \\n        int stone;\\n        \\n         if(player==0)\\n        {\\n             stone=INT_MIN;\\n            int taken=0;\\n            \\n             for(int x=1;x<=2*m&&id+x-1<piles.size();x++)\\n        {\\n            taken+=piles[id+x-1];\\n            stone=max(stone,taken+solve(piles,id+x,max(m,x),1-player));\\n        }\\n        \\n        }\\n        else\\n        {\\n            stone=INT_MAX;\\n            \\n             for(int x=1;x<=2*m&&id+x-1<piles.size();x++)\\n        {\\n            stone=min(stone,solve(piles,id+x,max(m,x),1-player));\\n        } \\n            \\n            \\n        }\\n       \\n        return dp[id][m][player]=stone;\\n            \\n    }\\n    \\n    int stoneGameII(vector<int>& piles) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n       int u= solve(piles,0,1,0);\\n        return u;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][105][2];\\n    \\n    int solve(vector<int>&piles,int id,int m,int player)\\n    {\\n        if(id>=piles.size())\\n            return 0;\\n        \\n        else if(dp[id][m][player]!=-1)\\n            return  dp[id][m][player];\\n        \\n        int stone;\\n        \\n         if(player==0)\\n        {\\n             stone=INT_MIN;\\n            int taken=0;\\n            \\n             for(int x=1;x<=2*m&&id+x-1<piles.size();x++)\\n        {\\n            taken+=piles[id+x-1];\\n            stone=max(stone,taken+solve(piles,id+x,max(m,x),1-player));\\n        }\\n        \\n        }\\n        else\\n        {\\n            stone=INT_MAX;\\n            \\n             for(int x=1;x<=2*m&&id+x-1<piles.size();x++)\\n        {\\n            stone=min(stone,solve(piles,id+x,max(m,x),1-player));\\n        } \\n            \\n            \\n        }\\n       \\n        return dp[id][m][player]=stone;\\n            \\n    }\\n    \\n    int stoneGameII(vector<int>& piles) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n       int u= solve(piles,0,1,0);\\n        return u;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042503,
                "title": "swift-dp-solution-with-comments",
                "content": "**Time Complexity**: O(n^3) for explanation see this https://leetcode.com/problems/stone-game-ii/discuss/345230/JavaPython-DP-Solution/313478\\n**Space Complexity**:  O(n^2) for the cache and the recursion depth shouldnt be more than n\\n```\\nclass Solution {\\n    func stoneGameII(_ piles: [Int]) -> Int {\\n        let pileCount = piles.count\\n        \\n        // The `postSum` at each index stores the sum of all the elements\\n        // after and including that index\\n        var postSum = piles\\n        for i in stride(from: piles.count - 2, through: 0, by: -1) {\\n            postSum[i] += postSum[i+1]\\n        }\\n        \\n        // Stores the score a player can get using the piles starting at index `p`\\n        // and the maximum number of piles the player is allowed to take at that round is `m`\\n        // the key for the cache is [p,m] ( a list of the two values)\\n        var cache = [[Int]:Int]()\\n        \\n        func helper(_ m: Int, _ p: Int) -> Int {\\n            // If the maximum number of piles you can take in this move\\n            // can possibly get you all the remaning the piles, the best move is\\n            // to take all the piles otherwise in the next move your opponent\\n            // is probably going to take them all\\n            // print(m,p, cache)\\n            guard p + 2*m <= pileCount - 1 else {\\n                return postSum[p]\\n            }\\n            \\n            if let cachedValue = cache[[p,m]] {\\n                return cachedValue\\n            }\\n            \\n            // For every possible number of piles you can take from the start\\n            // see how much the next player will probably get using the remaining\\n            // piles and the possible number of piles that user can pick\\n            // \\n            // We should subtract the score the next user can get from the total points available\\n            // starting at the pile after the ones we currently chose, that will give us the\\n            // amount that is left for us to take apart from the the score we got from the \\n            // piles we took \\n            var res = 0\\n            for i in 0..<(2*m) {\\n                let current = postSum[p] - postSum[p+i+1] \\n                res = max(res, current + postSum[p+i+1] - helper(max(m,i+1), p+i+1))\\n            }\\n        \\n            cache[[p,m]] = res\\n            return res\\n        }\\n        \\n        return helper(1,0)\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func stoneGameII(_ piles: [Int]) -> Int {\\n        let pileCount = piles.count\\n        \\n        // The `postSum` at each index stores the sum of all the elements\\n        // after and including that index\\n        var postSum = piles\\n        for i in stride(from: piles.count - 2, through: 0, by: -1) {\\n            postSum[i] += postSum[i+1]\\n        }\\n        \\n        // Stores the score a player can get using the piles starting at index `p`\\n        // and the maximum number of piles the player is allowed to take at that round is `m`\\n        // the key for the cache is [p,m] ( a list of the two values)\\n        var cache = [[Int]:Int]()\\n        \\n        func helper(_ m: Int, _ p: Int) -> Int {\\n            // If the maximum number of piles you can take in this move\\n            // can possibly get you all the remaning the piles, the best move is\\n            // to take all the piles otherwise in the next move your opponent\\n            // is probably going to take them all\\n            // print(m,p, cache)\\n            guard p + 2*m <= pileCount - 1 else {\\n                return postSum[p]\\n            }\\n            \\n            if let cachedValue = cache[[p,m]] {\\n                return cachedValue\\n            }\\n            \\n            // For every possible number of piles you can take from the start\\n            // see how much the next player will probably get using the remaining\\n            // piles and the possible number of piles that user can pick\\n            // \\n            // We should subtract the score the next user can get from the total points available\\n            // starting at the pile after the ones we currently chose, that will give us the\\n            // amount that is left for us to take apart from the the score we got from the \\n            // piles we took \\n            var res = 0\\n            for i in 0..<(2*m) {\\n                let current = postSum[p] - postSum[p+i+1] \\n                res = max(res, current + postSum[p+i+1] - helper(max(m,i+1), p+i+1))\\n            }\\n        \\n            cache[[p,m]] = res\\n            return res\\n        }\\n        \\n        return helper(1,0)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976069,
                "title": "very-short-and-clean-c-code-with-comments",
                "content": "```\\n    int N, total;\\n    vector<vector<int>> dp;\\n    vector<int> sum;\\n    \\n    int dfs(int M, int i) { // from i to end, what is the max [the person that takes first] can get\\n        if (i + 2 * M >= N) return total - sum[i];\\n        if (dp[i][M]) return dp[i][M];\\n        \\n        int res=0;\\n        for (int j = 1; j <= 2 * M; j++) {\\n            res = max(res, total - sum[i] - dfs(max(j, M), i + j)); // dfs(max(j, M), i + j) is the the max another person can get because he takes first\\n        }\\n        return dp[i][M] = res;\\n    }\\n    \\n    public:\\n    int stoneGameII(vector<int>& piles) {\\n        N = piles.size();\\n        \\n        dp.resize(N, vector<int>(N, 0));\\n        \\n        sum.resize(N+1, 0);\\n        partial_sum(piles.begin(), piles.end(), sum.begin()+1);\\n        total = sum[N];\\n        \\n        return dfs(1, 0);\\n    }",
                "solutionTags": [],
                "code": "```\\n    int N, total;\\n    vector<vector<int>> dp;\\n    vector<int> sum;\\n    \\n    int dfs(int M, int i) { // from i to end, what is the max [the person that takes first] can get\\n        if (i + 2 * M >= N) return total - sum[i];\\n        if (dp[i][M]) return dp[i][M];\\n        \\n        int res=0;\\n        for (int j = 1; j <= 2 * M; j++) {\\n            res = max(res, total - sum[i] - dfs(max(j, M), i + j)); // dfs(max(j, M), i + j) is the the max another person can get because he takes first\\n        }\\n        return dp[i][M] = res;\\n    }\\n    \\n    public:\\n    int stoneGameII(vector<int>& piles) {\\n        N = piles.size();\\n        \\n        dp.resize(N, vector<int>(N, 0));\\n        \\n        sum.resize(N+1, 0);\\n        partial_sum(piles.begin(), piles.end(), sum.begin()+1);\\n        total = sum[N];\\n        \\n        return dfs(1, 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 973053,
                "title": "java-short-and-crisp-dfs-memoization-with-intuition",
                "content": "As we have to distribute total stones between Person1 & Person2.\\n        If we maximize difference between them, then we will get maximum Person1 can get (minimum Person2 can get)\\n        ->Person1+Person2=sum_of_stones_in_piles.\\n        -> We caluculate maximum difference.int max_diff=Person1-Person2=dfs()\\n        Person1=(sum_of_stones_in_piles+max_diff)/2,Person2=sum_of_stones_in_piles-Person1.\\n->Here as both players play optimally and as they will be switching,so at every instance we try to find maximum possible score by selecting 1 to 2*M from start. and **add** it to score if it is Player1 or **subtract** if it is Player2.\\n->So as we are finding difference between Person1 & Person2. **-DFS** will be called even no.of times for Player1 and odd no.of times for Player2,So value of picked stone will get **added** for Player1 and **subtracted** for Player2.\\nHere as -dfs() takes care of whether adding/subtracting , dfs(index,M) will be same irrespective of the person. So we can use a hashMap to store already computed results and **add** it to current diff if it is Person_1 or **subtract** if it is Person2.\\n->dfs(start,M) gives\\nPerson1=selects_stones-dfs(Person2=select_stones-dfs(Person1=select_stones-dfs(.....)))\\nAt the end we can see that, (sum of stones of Person1)- (sum of stones of Person2)\\n```\\nclass Solution {\\n    int[] prefix_sum;\\n    int[] piles;\\n    int n;\\n    HashMap<String,Integer> memo=new HashMap();\\n    public int stoneGameII(int[] nums) {\\n        n=nums.length;prefix_sum=new int[n];piles=nums;\\n        for(int i=0;i<n;i++)\\n            prefix_sum[i]=piles[i]+((i==0)?0:prefix_sum[i-1]);\\n        int max_diff=dfs(0,1);\\n        return (prefix_sum[n-1]+max_diff)/2;\\n    }\\n    private int dfs(int start,int M){\\n        if(start>=n) return 0;\\n\\t\\t/*If total-range of values <=2*M,then\\n\\t\\tto get maximum score current_player will take all the stones in this range.*/\\n        if(n-start<=2*M) return prefix_sum[n-1]-((start==0)?0:prefix_sum[start-1]);\\n        String key=start+\" \"+M;\\n        if(memo.containsKey(key)) return memo.get(key);\\n        int res=Integer.MIN_VALUE;\\n        for(int k=1;k<=2*M;k++)\\n\\t\\t//Select the maximum difference\\n            res=Math.max(res,\\n\\t\\t\\t/*Current_player takes k-stones and calls -dfs() for next person*/\\n                         (prefix_sum[start+k-1]-((start==0)?0:prefix_sum[start-1]))\\n                         -dfs(start+k,Math.max(M,k)));\\n        memo.put(key,res);\\n        return res;\\n        \\n    }\\n}\\n```\\nSimilar Questions wiht explanations:\\n**Stone_Game4:**\\nhttps://leetcode.com/problems/stone-game-iv/discuss/974415/Java-5-lines-of-code-or-3-Approaches-or-DFS%2BMemoization-or-DP-or-with-explanation.\\n**Stone_Game3:**\\nhttps://leetcode.com/problems/stone-game-iii/discuss/974109/Java-5-lines-of-code-or-*-DP-O(N)-TimeO(1)-Space-*-or-DFS%2BMemoization\\n**Stone_game1:**\\nhttps://leetcode.com/problems/stone-game/discuss/972898/Java-short-and-crisp-or-DFS%2BMemoization-5-lines-or-DP-or-with-detailed-explanation",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] prefix_sum;\\n    int[] piles;\\n    int n;\\n    HashMap<String,Integer> memo=new HashMap();\\n    public int stoneGameII(int[] nums) {\\n        n=nums.length;prefix_sum=new int[n];piles=nums;\\n        for(int i=0;i<n;i++)\\n            prefix_sum[i]=piles[i]+((i==0)?0:prefix_sum[i-1]);\\n        int max_diff=dfs(0,1);\\n        return (prefix_sum[n-1]+max_diff)/2;\\n    }\\n    private int dfs(int start,int M){\\n        if(start>=n) return 0;\\n\\t\\t/*If total-range of values <=2*M,then\\n\\t\\tto get maximum score current_player will take all the stones in this range.*/\\n        if(n-start<=2*M) return prefix_sum[n-1]-((start==0)?0:prefix_sum[start-1]);\\n        String key=start+\" \"+M;\\n        if(memo.containsKey(key)) return memo.get(key);\\n        int res=Integer.MIN_VALUE;\\n        for(int k=1;k<=2*M;k++)\\n\\t\\t//Select the maximum difference\\n            res=Math.max(res,\\n\\t\\t\\t/*Current_player takes k-stones and calls -dfs() for next person*/\\n                         (prefix_sum[start+k-1]-((start==0)?0:prefix_sum[start-1]))\\n                         -dfs(start+k,Math.max(M,k)));\\n        memo.put(key,res);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972292,
                "title": "python-dp-explanation-thought-process",
                "content": "**Thought Process**\\n\\nWe must understand the question. In my opinon the question is difficult to understand if you have never seen it before. Let us go over the question breifly.\\n\\n- Alice starts the game\\n- `M = 1` when starting the game\\n- She can take between `1 <= X <= 2*M` stones from the front of the pile, **A.K.A, she can take stones from the left hand side of the input array only**\\n- After she has taken the stones, `M = max(M, X)` & it is now Bob\\'s turn\\n- The game repeats\\n\\n1. This tells us a few things. Firstly, we are only reading from the left hand side of the array.\\n2. Second, we can take a variable number of \"elements\" from the array each time, specifically `1 <= X <= 2*M` elements.\\n3. We sum the elements of the array to calculate the total number of stones\\n4. It is first Alice\\'s turn, then Bob\\'s turn, then Alice\\'s turn again, etc, etc\\n\\nThis allows us to explore the idea of a function that takes in the start index, and a value of `M`. We can iterate over the range of `M` from `1 <= X <= 2*M`,  calculate the possible score minus the next possible maxmimum score (as we want to subtract Bob\\'s score), and then return the maxmimum possible score from this.\\n\\nA key point is we subtract our function `dp`, from the `sum` of piles. Again, this is because we want to subtract Bob\\'s best possible score from Alice\\'s score. This is how we handle the changing turns between Alice & Bob. \\n\\nOne small cavet is our function `dp` returns the delta or difference between Alice\\'s score & Bob\\'s score. Some quick algebra yeilds Alice\\'s score:\\n\\n```\\nsum(piles) = alice score + bob score\\ndelta = alice score - bob score\\nbob score = alice score - delta\\ntherefore sum(piles) = 2 * alice score - delta\\ntherefore alice score = (delta + sum(piles)) / 2\\n```\\n\\nBelow is the final answer.\\n\\n- `@lru_cache` is used for memoization\\n- List comprehension is used instead of a for-loop\\n\\n**Final Answer**\\n\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n                        \\n        @functools.lru_cache(maxsize=None)\\n        def dp(idx, m):            \\n            if idx >= len(piles): return 0            \\n            return max( # select the max score Alice can have from her choices\\n                [sum(piles[idx:idx+x]) - dp(idx+x, max(m, x)) # take element from front of array, subtract Bob\\'s optimal score\\n                 for x in range(1, (2*m) + 1)] # we iterate over every possible number of elements we can take from front of array\\n            )\\n               \\n\\t\\t# perform algebra to go from delta -> alice\\'s total score (see above)\\n        return (sum(piles) + dp(0, 1)) // 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nsum(piles) = alice score + bob score\\ndelta = alice score - bob score\\nbob score = alice score - delta\\ntherefore sum(piles) = 2 * alice score - delta\\ntherefore alice score = (delta + sum(piles)) / 2\\n```\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n                        \\n        @functools.lru_cache(maxsize=None)\\n        def dp(idx, m):            \\n            if idx >= len(piles): return 0            \\n            return max( # select the max score Alice can have from her choices\\n                [sum(piles[idx:idx+x]) - dp(idx+x, max(m, x)) # take element from front of array, subtract Bob\\'s optimal score\\n                 for x in range(1, (2*m) + 1)] # we iterate over every possible number of elements we can take from front of array\\n            )\\n               \\n\\t\\t# perform algebra to go from delta -> alice\\'s total score (see above)\\n        return (sum(piles) + dp(0, 1)) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745243,
                "title": "c-recursive-memoizarion-explaination",
                "content": "## Explanantion:\\nFor the sample test case : [2,7,9,4,4]\\nAlex initially has 2 options\\nEither choose first 2 elements or choose only the first element;\\nSo solving it recursively,\\nwe return ```(sum of choosen elements) + solve(new_starting_index, new_M);```\\nBut the  ```solve(new_starting_index, new_M)``` returns the sum of stones chosen by Lee and not Alex.\\nThe key trick is to subtract the ```solve(new_starting_index, new_M)``` with the total number of stones from ```[new_index ... end]```\\n\\n### C++ solution\\n```\\nclass Solution {\\npublic:\\n    int suffix[101];\\n    int dp[101][101];\\n    int n;\\n    vector<int> arr;\\n    int solve(int index, int M) {\\n        if(index >= n) {\\n            return 0;\\n        }\\n        if(dp[index][M] != -1)\\n            return dp[index][M];\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i = index; i < min(n, index + 2*M); i++) {\\n            sum += arr[i];\\n            int t = sum + suffix[i+1] - solve(i+1, max(M, i-index+1));\\n            ans = max(ans, t);\\n        }\\n        return dp[index][M] = ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        memset(suffix, 0, sizeof(suffix));\\n        n = piles.size();\\n        for(int i = 0; i <= n; i++) {\\n            for(int j = 0; j <= n; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        arr = piles;\\n        suffix[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--) {\\n            suffix[i] = arr[i] + suffix[i+1];\\n        }\\n        return solve(0, 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```(sum of choosen elements) + solve(new_starting_index, new_M);```\n```solve(new_starting_index, new_M)```\n```solve(new_starting_index, new_M)```\n```[new_index ... end]```\n```\\nclass Solution {\\npublic:\\n    int suffix[101];\\n    int dp[101][101];\\n    int n;\\n    vector<int> arr;\\n    int solve(int index, int M) {\\n        if(index >= n) {\\n            return 0;\\n        }\\n        if(dp[index][M] != -1)\\n            return dp[index][M];\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i = index; i < min(n, index + 2*M); i++) {\\n            sum += arr[i];\\n            int t = sum + suffix[i+1] - solve(i+1, max(M, i-index+1));\\n            ans = max(ans, t);\\n        }\\n        return dp[index][M] = ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        memset(suffix, 0, sizeof(suffix));\\n        n = piles.size();\\n        for(int i = 0; i <= n; i++) {\\n            for(int j = 0; j <= n; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        arr = piles;\\n        suffix[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--) {\\n            suffix[i] = arr[i] + suffix[i+1];\\n        }\\n        return solve(0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719632,
                "title": "java-dp-simple-and-concise",
                "content": "```\\nclass Solution {\\n    public int stoneGameII(int[] ps) {\\n        int n = ps.length, sum = 0;\\n        Integer dp[][] = new Integer[n + 1][n / 2 + 2]; //dp[i][j] means max winning stone when first i taken, and M == j;\\n        for (int p : ps) sum += p;\\n        return (sum + dfs(dp, ps, 0, 1, n)) / 2; \\n    } \\n    \\n    private int dfs(Integer[][] dp, int[] ps, int taken, int m, int n) { \\n        int res = Integer.MIN_VALUE, sum = 0;\\n        if (taken >= n) return 0;\\n        if (dp[taken][m] != null) return dp[taken][m];\\n        for (int i = 1; i <= m * 2 && taken + i - 1 < n; i++) {\\n            sum += ps[taken + i - 1];\\n            res = Math.max(res, sum - dfs(dp, ps, taken + i, Math.max(m, i), n));\\n        }\\n        dp[taken][m] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] ps) {\\n        int n = ps.length, sum = 0;\\n        Integer dp[][] = new Integer[n + 1][n / 2 + 2]; //dp[i][j] means max winning stone when first i taken, and M == j;\\n        for (int p : ps) sum += p;\\n        return (sum + dfs(dp, ps, 0, 1, n)) / 2; \\n    } \\n    \\n    private int dfs(Integer[][] dp, int[] ps, int taken, int m, int n) { \\n        int res = Integer.MIN_VALUE, sum = 0;\\n        if (taken >= n) return 0;\\n        if (dp[taken][m] != null) return dp[taken][m];\\n        for (int i = 1; i <= m * 2 && taken + i - 1 < n; i++) {\\n            sum += ps[taken + i - 1];\\n            res = Math.max(res, sum - dfs(dp, ps, taken + i, Math.max(m, i), n));\\n        }\\n        dp[taken][m] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705851,
                "title": "dp-bottom-up-top-down-solution-with-time-space-complexity",
                "content": "#### Bottom-up\\n```\\nclass Solution {\\npublic:\\n    // Time: O(n^3)\\n    // Space: O(n^2)\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<int> suf_sum(n, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (i == n - 1) suf_sum[i] = piles[i];\\n            else suf_sum[i] = suf_sum[i + 1] + piles[i];\\n        }\\n        vector<vector<int>> dp(n, vector<int>(n + 1, 0));\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int M = n; M >= 1; M--) {\\n                for (int x = 1; x <= 2 * M; x++) {\\n                    int opt;\\n                    if (i + x >= n) opt = suf_sum[i];\\n                    else opt = suf_sum[i] - dp[i + x][max(x, M)];\\n                    dp[i][M] = max(dp[i][M], opt);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n#### Top-down\\n```\\nclass Solution2 {\\npublic:\\n    // Time: O(n^3)\\n    // Space: O(n^2)\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<int> suf_sum(n, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (i == n - 1) suf_sum[i] = piles[i];\\n            else suf_sum[i] = suf_sum[i + 1] + piles[i];\\n        }\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        return helper(piles, 0, 1, dp, suf_sum);\\n    }\\n    int helper(vector<int> piles, int i, int M, vector<vector<int>>& dp, const vector<int>& suf_sum) {\\n        if (2 * M >= piles.size() - i) {\\n            return suf_sum[i];\\n        }\\n        if (dp[i][M] != 0) return dp[i][M];\\n        int res = INT_MAX;\\n        for (int x = 1; x <= 2 * M; x++) {\\n            int new_m = max(M, x);\\n            res = min(res, helper(piles, i + x, new_m, dp, suf_sum));\\n        }\\n        dp[i][M] = suf_sum[i] - res;\\n        return dp[i][M];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time: O(n^3)\\n    // Space: O(n^2)\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<int> suf_sum(n, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (i == n - 1) suf_sum[i] = piles[i];\\n            else suf_sum[i] = suf_sum[i + 1] + piles[i];\\n        }\\n        vector<vector<int>> dp(n, vector<int>(n + 1, 0));\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int M = n; M >= 1; M--) {\\n                for (int x = 1; x <= 2 * M; x++) {\\n                    int opt;\\n                    if (i + x >= n) opt = suf_sum[i];\\n                    else opt = suf_sum[i] - dp[i + x][max(x, M)];\\n                    dp[i][M] = max(dp[i][M], opt);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution2 {\\npublic:\\n    // Time: O(n^3)\\n    // Space: O(n^2)\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<int> suf_sum(n, 0);\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (i == n - 1) suf_sum[i] = piles[i];\\n            else suf_sum[i] = suf_sum[i + 1] + piles[i];\\n        }\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        return helper(piles, 0, 1, dp, suf_sum);\\n    }\\n    int helper(vector<int> piles, int i, int M, vector<vector<int>>& dp, const vector<int>& suf_sum) {\\n        if (2 * M >= piles.size() - i) {\\n            return suf_sum[i];\\n        }\\n        if (dp[i][M] != 0) return dp[i][M];\\n        int res = INT_MAX;\\n        for (int x = 1; x <= 2 * M; x++) {\\n            int new_m = max(M, x);\\n            res = min(res, helper(piles, i + x, new_m, dp, suf_sum));\\n        }\\n        dp[i][M] = suf_sum[i] - res;\\n        return dp[i][M];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595946,
                "title": "easy-to-understand-java-dp-solution",
                "content": "It took me hours to even read solutions from discussion. Finally I figuted the problem is not paricular hard, the introduction of M (as a middle layer) make the problem complex. \\n\\nActually, just loop M from 1 to n/2, it didn\\'t make the problem too complicated. \\n\\n```\\n public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        \\n        //calculate presum from right to left \\n        //sum[i] is the total number of stones from index i to the end\\n        int[] sums = new int[n];\\n        sums[n - 1] = piles[n -1];\\n        for (int i = n - 2; i >=0; i--) {\\n            sums[i] += sums[i + 1] + piles[i];\\n        }\\n\\n        int[][] dp = new int[n][n];\\n        for (int i = n-1; i >=0 ; i--) {\\n            for (int m = 1; m <= n/2 + 1; m++) {\\n                for(int x = 1; x <= 2 * m && i + x <= n; x++)\\n                      if(i + x == n)\\n                          dp[i][m] = Math.max(dp[i][m], sums[i]);\\n                      else\\n                        dp[i][m] = Math.max(dp[i][m], sums[i] - dp[i+x][Math.max(m,x)]);\\n            }\\n        }\\n        \\n        return dp[0][1];\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        \\n        //calculate presum from right to left \\n        //sum[i] is the total number of stones from index i to the end\\n        int[] sums = new int[n];\\n        sums[n - 1] = piles[n -1];\\n        for (int i = n - 2; i >=0; i--) {\\n            sums[i] += sums[i + 1] + piles[i];\\n        }\\n\\n        int[][] dp = new int[n][n];\\n        for (int i = n-1; i >=0 ; i--) {\\n            for (int m = 1; m <= n/2 + 1; m++) {\\n                for(int x = 1; x <= 2 * m && i + x <= n; x++)\\n                      if(i + x == n)\\n                          dp[i][m] = Math.max(dp[i][m], sums[i]);\\n                      else\\n                        dp[i][m] = Math.max(dp[i][m], sums[i] - dp[i+x][Math.max(m,x)]);\\n            }\\n        }\\n        \\n        return dp[0][1];\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 546436,
                "title": "python-recursion-with-memorization",
                "content": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        def dfs(total, start, M, cache):\\n            key = (M, start)\\n            if not key in cache:\\n                if start >= len(piles):\\n                    cache[key] = 0\\n                else:\\n                    cur_sum = 0\\n                    for x in range(1, 2*M+1):\\n                        index = start + (x-1)\\n                        if index < len(piles):\\n                            cur_sum += piles[index]\\n                            cache[key] = max(cache[key], total - dfs(total-cur_sum, index+1, max(M, x), cache))\\n            return cache[key]\\n        \\n        total = sum(piles)\\n        return dfs(total, 0, 1, collections.defaultdict(int))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        def dfs(total, start, M, cache):\\n            key = (M, start)\\n            if not key in cache:\\n                if start >= len(piles):\\n                    cache[key] = 0\\n                else:\\n                    cur_sum = 0\\n                    for x in range(1, 2*M+1):\\n                        index = start + (x-1)\\n                        if index < len(piles):\\n                            cur_sum += piles[index]\\n                            cache[key] = max(cache[key], total - dfs(total-cur_sum, index+1, max(M, x), cache))\\n            return cache[key]\\n        \\n        total = sum(piles)\\n        return dfs(total, 0, 1, collections.defaultdict(int))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448158,
                "title": "c-easy-memo-4ms-only-20-lines",
                "content": "```C++\\nclass Solution {\\npublic:\\n    \\n    int maximum(vector<int>& piles, int start, int M, int total) {\\n\\n        if (start >= piles.size()) return 0;\\n\\n        if (cache[start][M] != -1) {\\n            return cache[start][M];\\n        }\\n        \\n        int result = INT_MIN;\\n        \\n        for (int X = 1, sum = 0; X <= 2 * M && X + start <= piles.size(); X++) {\\n            sum += piles[start + X - 1];\\n            result = max(result, total - maximum(piles, start + X, max(M, X), total - sum));\\n        }\\n        return cache[start][M] = result;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        cache = vector<vector<int>>(piles.size() + 1, vector<int>(piles.size() + 1, -1));\\n        return maximum(piles, 0, 1, accumulate(piles.begin(), piles.end(), 0));\\n    }\\nprivate:\\n    vector<vector<int>> cache;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    \\n    int maximum(vector<int>& piles, int start, int M, int total) {\\n\\n        if (start >= piles.size()) return 0;\\n\\n        if (cache[start][M] != -1) {\\n            return cache[start][M];\\n        }\\n        \\n        int result = INT_MIN;\\n        \\n        for (int X = 1, sum = 0; X <= 2 * M && X + start <= piles.size(); X++) {\\n            sum += piles[start + X - 1];\\n            result = max(result, total - maximum(piles, start + X, max(M, X), total - sum));\\n        }\\n        return cache[start][M] = result;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        cache = vector<vector<int>>(piles.size() + 1, vector<int>(piles.size() + 1, -1));\\n        return maximum(piles, 0, 1, accumulate(piles.begin(), piles.end(), 0));\\n    }\\nprivate:\\n    vector<vector<int>> cache;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417672,
                "title": "c-memoization-code-with-two-turns",
                "content": "In my code i keep in one variable if it is the turn of P1.\\nIf tue, I calculate the maximum sum that I can have from all available piles + the recursion.\\nIf false, I simply chek all the cases skipping the piles that could be taken by P2. I will take the minimum value here, since also P2 plays at the best he can.\\nThe coude could be easily extended to support players > 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles,\\n                    int start,\\n                    int M,\\n                    bool p1Turn,\\n                    vector<vector<vector<int>>>& cache)\\n    {\\n        if (start >= piles.size())\\n            return 0;\\n        \\n        if (cache[start][M][p1Turn] != -1)\\n            return cache[start][M][p1Turn];\\n        \\n        int maxIndex = std::min(static_cast<int>(piles.size()), start + 2 * M);\\n        int sum = 0;\\n        int ans = 0;\\n        \\n        if (p1Turn)\\n        {\\n            ans = 0;\\n            \\n            for (int i = start; i < maxIndex; ++i)\\n            {\\n                sum += piles[i];\\n                ans = std::max(ans, sum + stoneGameII(piles, i + 1, std::max(i - start + 1, M), false, cache));\\n            }\\n        }\\n        else\\n        {\\n            ans = std::numeric_limits<int>::max();\\n            \\n            for (int i = start; i < maxIndex; ++i)\\n            {\\n                ans = std::min(ans, stoneGameII(piles, i + 1, std::max(i - start + 1, M), true, cache));\\n            }\\n        }\\n        \\n        cache[start][M][p1Turn] = ans;\\n        return ans;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles)\\n    {\\n        int n = piles.size();\\n        \\n        vector<vector<vector<int>>> cache(n + 1, vector<vector<int>>(n + 1, vector<int>(2, -1)));\\n\\n        return stoneGameII(piles, 0, 1, true, cache);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles,\\n                    int start,\\n                    int M,\\n                    bool p1Turn,\\n                    vector<vector<vector<int>>>& cache)\\n    {\\n        if (start >= piles.size())\\n            return 0;\\n        \\n        if (cache[start][M][p1Turn] != -1)\\n            return cache[start][M][p1Turn];\\n        \\n        int maxIndex = std::min(static_cast<int>(piles.size()), start + 2 * M);\\n        int sum = 0;\\n        int ans = 0;\\n        \\n        if (p1Turn)\\n        {\\n            ans = 0;\\n            \\n            for (int i = start; i < maxIndex; ++i)\\n            {\\n                sum += piles[i];\\n                ans = std::max(ans, sum + stoneGameII(piles, i + 1, std::max(i - start + 1, M), false, cache));\\n            }\\n        }\\n        else\\n        {\\n            ans = std::numeric_limits<int>::max();\\n            \\n            for (int i = start; i < maxIndex; ++i)\\n            {\\n                ans = std::min(ans, stoneGameII(piles, i + 1, std::max(i - start + 1, M), true, cache));\\n            }\\n        }\\n        \\n        cache[start][M][p1Turn] = ans;\\n        return ans;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles)\\n    {\\n        int n = piles.size();\\n        \\n        vector<vector<vector<int>>> cache(n + 1, vector<vector<int>>(n + 1, vector<int>(2, -1)));\\n\\n        return stoneGameII(piles, 0, 1, true, cache);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393866,
                "title": "python-dp-solution-clearly-explained-top-down-approach",
                "content": "## Stone Game 2\\n\\n### Given pile of stones , On each player\\'s turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X). Find max stones Alex takes. Alex starts first\\n\\n1. Concept is that, on each turn , each player will want to maximize their gains. When it is Alex\\'s turn , we return the current gain + max value of remaining steps left in the recursion. When it is Lee\\'s turn , he wants to maximize his gain , it means we need to return the minimum value of the remaining piles (since Lee will leave out the min and not take them).\\n2. We have a recursive solution where at each point, we check for 2 things:\\nIf it is Alex: return current gains = max(first x piles + recursive solution of Lee\\'s turn)\\nIf it is Lee: return min(recursive solution of Alex\\'s turn)\\n3. It will look like this --> max(first x piles + min(max(next x piles + min ( max( next x piles ))))...and so on)\\n4. Base case is when index exceeds\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        N = len(piles)\\n        import functools\\n        @functools.lru_cache(None)\\n        def dp( i , m , player1):\\n            if i>N: return 0\\n            if player1:\\n                #maximize sum if Alex \\n                return max(sum(piles[i:i+alex_turn]) + dp(i+alex_turn , max(m , alex_turn) , player1^True) for alex_turn in range(1 , 2*m+1))\\n            else:\\n                #minimize sum if Lee\\n                return min(dp(i+lee_turn , max(m , lee_turn) , player1^True) for lee_turn in range(1 , 2*m+1))\\n        return dp ( 0,  1 ,True)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        N = len(piles)\\n        import functools\\n        @functools.lru_cache(None)\\n        def dp( i , m , player1):\\n            if i>N: return 0\\n            if player1:\\n                #maximize sum if Alex \\n                return max(sum(piles[i:i+alex_turn]) + dp(i+alex_turn , max(m , alex_turn) , player1^True) for alex_turn in range(1 , 2*m+1))\\n            else:\\n                #minimize sum if Lee\\n                return min(dp(i+lee_turn , max(m , lee_turn) , player1^True) for lee_turn in range(1 , 2*m+1))\\n        return dp ( 0,  1 ,True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386634,
                "title": "java-dp-straight-solution-with-clear-explanation",
                "content": "Not the fastest but should be easy to understand.\\n```\\n    public int stoneGameII(int[] piles) {\\n        int len = piles.length;\\n        int[] sum = new int[len + 1];\\n        int[][] dp = new int[len+1][len+1];//dp[i][M] : the best result a player can get from pile i to pile len - 1, with M as defined in the problem\\n        for(int i = len -1; i>=0; i--){\\n            sum[i] = sum[i+1] + piles[i];  \\n        }\\n        \\n        for(int i = len-1; i >= 0; i--){            \\n            for(int M = 1; M <= (len-i)/2; M++){\\n                int max = 0;\\n                for(int k = 1; k <= M *2; k++){\\n                    // actually is (sum[i] - sum[i+k]) + (sum[i+k] - dp[i+k][Math.max(k, M)])\\n                    // (sum[i] - sum[i+k]): choose the first K piles, start from i\\n                    // dp[i+k][Math.max(k, M)]: max # of stones player 2 can get from remaining piles, with possibly changed M\\n                    // (sum[i+k] - dp[i+k][Math.max(k, M)]): the best result player 1 can get after player 2 chooses. Both plays optimally.\\n                    int cur = sum[i] - dp[i+k][Math.max(k, M)];\\n                    max = Math.max(max, cur);\\n                }\\n                dp[i][M] = max;\\n            }\\n            for(int M = (len-i)/2 + 1; M<=len/2; M++){//len - i is the # of the remaining piles, if M is no less than half of the #, the player can take all the remaing piles (x <= 2*M)\\n                dp[i][M] = sum[i];\\n            }            \\n        }\\n        return dp[0][1];// start from pile 0, M = 1\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int stoneGameII(int[] piles) {\\n        int len = piles.length;\\n        int[] sum = new int[len + 1];\\n        int[][] dp = new int[len+1][len+1];//dp[i][M] : the best result a player can get from pile i to pile len - 1, with M as defined in the problem\\n        for(int i = len -1; i>=0; i--){\\n            sum[i] = sum[i+1] + piles[i];  \\n        }\\n        \\n        for(int i = len-1; i >= 0; i--){            \\n            for(int M = 1; M <= (len-i)/2; M++){\\n                int max = 0;\\n                for(int k = 1; k <= M *2; k++){\\n                    // actually is (sum[i] - sum[i+k]) + (sum[i+k] - dp[i+k][Math.max(k, M)])\\n                    // (sum[i] - sum[i+k]): choose the first K piles, start from i\\n                    // dp[i+k][Math.max(k, M)]: max # of stones player 2 can get from remaining piles, with possibly changed M\\n                    // (sum[i+k] - dp[i+k][Math.max(k, M)]): the best result player 1 can get after player 2 chooses. Both plays optimally.\\n                    int cur = sum[i] - dp[i+k][Math.max(k, M)];\\n                    max = Math.max(max, cur);\\n                }\\n                dp[i][M] = max;\\n            }\\n            for(int M = (len-i)/2 + 1; M<=len/2; M++){//len - i is the # of the remaining piles, if M is no less than half of the #, the player can take all the remaing piles (x <= 2*M)\\n                dp[i][M] = sum[i];\\n            }            \\n        }\\n        return dp[0][1];// start from pile 0, M = 1\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347675,
                "title": "c-4ms-dfs-with-memo-with-comments",
                "content": "### Feel free to decomment the printf to understand how recursion goes.\\n```cpp\\n// min - max memo solution, Alex tries to maximize himself and Lee try to minimize the opponent\\nclass Solution \\n{\\n    public:\\n    int dfs(int suffix_sum[101], int dp[101][101], int l, int M, int n) // l is the starting point, M as problem described and n is the border\\n    {\\n        // printf(\"L %d M %d \", l, M);\\n        if(l >= n) // out of bound, nothing to take\\n        {\\n            // printf(\"L >= n, return 0 \\\\n\");\\n            return 0; \\n        }\\n        else if(dp[l][M] > 0) // return the cached answer if already computerd before\\n        {\\n            // printf(\"cached: %d\\\\n\", dp[l][M]);\\n            return dp[l][M];\\n        }\\n        else // update the max possibilities for Alex, starting from l and take at most 2M\\\\\\n             // then maximize all the possibilities when compete with Lee\\n        {\\n            for(int i = 1; i <= 2 * M && l + i <= n; i++)\\n            {\\n                // printf(\"%d, %d call %d, %d \\\\n\", l, M,  i + l, max(M, i));\\n                dp[l][M] = max(dp[l][M], suffix_sum[l] - dfs(suffix_sum, dp, i + l, max(M, i), n)); // what Alex can take equals to the (suffix_sum from end to current l(start) minus all the posibilities that Lee can do starting from index i + l(since Alex has taken i stones)) \\n            }\\n            return dp[l][M];\\n        }\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        int dp[101][101] = {0}; // dp i j is the maximum value for Alex start at i and take at most M = j stones\\n        int suffix_sum[101] = {0};\\n        suffix_sum[n - 1] = piles[n -1];\\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            suffix_sum[i] = suffix_sum[i + 1] + piles[i];\\n        }\\n        return dfs(suffix_sum, dp, 0, 1, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// min - max memo solution, Alex tries to maximize himself and Lee try to minimize the opponent\\nclass Solution \\n{\\n    public:\\n    int dfs(int suffix_sum[101], int dp[101][101], int l, int M, int n) // l is the starting point, M as problem described and n is the border\\n    {\\n        // printf(\"L %d M %d \", l, M);\\n        if(l >= n) // out of bound, nothing to take\\n        {\\n            // printf(\"L >= n, return 0 \\\\n\");\\n            return 0; \\n        }\\n        else if(dp[l][M] > 0) // return the cached answer if already computerd before\\n        {\\n            // printf(\"cached: %d\\\\n\", dp[l][M]);\\n            return dp[l][M];\\n        }\\n        else // update the max possibilities for Alex, starting from l and take at most 2M\\\\\\n             // then maximize all the possibilities when compete with Lee\\n        {\\n            for(int i = 1; i <= 2 * M && l + i <= n; i++)\\n            {\\n                // printf(\"%d, %d call %d, %d \\\\n\", l, M,  i + l, max(M, i));\\n                dp[l][M] = max(dp[l][M], suffix_sum[l] - dfs(suffix_sum, dp, i + l, max(M, i), n)); // what Alex can take equals to the (suffix_sum from end to current l(start) minus all the posibilities that Lee can do starting from index i + l(since Alex has taken i stones)) \\n            }\\n            return dp[l][M];\\n        }\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        int dp[101][101] = {0}; // dp i j is the maximum value for Alex start at i and take at most M = j stones\\n        int suffix_sum[101] = {0};\\n        suffix_sum[n - 1] = piles[n -1];\\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            suffix_sum[i] = suffix_sum[i + 1] + piles[i];\\n        }\\n        return dfs(suffix_sum, dp, 0, 1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346060,
                "title": "java-dfs-with-memoization",
                "content": "```java\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int sum = 0;\\n        for(int pile : piles) {\\n            sum += pile;\\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        return dfs(piles, sum, 0, 1, map);\\n    }\\n    \\n\\t// max value we can get if we start at idx with m\\n    private int dfs(int[] piles, int sum, int idx, int m, Map<String, Integer> map) {\\n        if(idx >= piles.length) {\\n            return 0;\\n        }\\n        \\n        if(map.containsKey((\"\" + idx) + m)) {\\n            return map.get((\"\" + idx) + m);\\n        }\\n        \\n        int max = 0;\\n        int choose = 0;\\n        for(int i = idx; i < idx + 2 * m && i < piles.length; i++) {\\n\\t\\t\\t//we choose stones from idx to i \\n            choose += piles[i];\\n            \\n\\t\\t\\t// sum: sum of stones left\\n\\t\\t\\t// sum - dfs(...) is the value we can get in this turn.\\n\\t\\t\\t// the next player also plays optimally\\n            max = Math.max(max, sum - dfs(piles, sum - choose, i + 1, Math.max(i - idx + 1, m), map));\\n        } \\n        \\n        map.put((\"\" + idx) + m, max);\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int sum = 0;\\n        for(int pile : piles) {\\n            sum += pile;\\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        return dfs(piles, sum, 0, 1, map);\\n    }\\n    \\n\\t// max value we can get if we start at idx with m\\n    private int dfs(int[] piles, int sum, int idx, int m, Map<String, Integer> map) {\\n        if(idx >= piles.length) {\\n            return 0;\\n        }\\n        \\n        if(map.containsKey((\"\" + idx) + m)) {\\n            return map.get((\"\" + idx) + m);\\n        }\\n        \\n        int max = 0;\\n        int choose = 0;\\n        for(int i = idx; i < idx + 2 * m && i < piles.length; i++) {\\n\\t\\t\\t//we choose stones from idx to i \\n            choose += piles[i];\\n            \\n\\t\\t\\t// sum: sum of stones left\\n\\t\\t\\t// sum - dfs(...) is the value we can get in this turn.\\n\\t\\t\\t// the next player also plays optimally\\n            max = Math.max(max, sum - dfs(piles, sum - choose, i + 1, Math.max(i - idx + 1, m), map));\\n        } \\n        \\n        map.put((\"\" + idx) + m, max);\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346047,
                "title": "python-cached-dfs",
                "content": "```python\\nclass Solution:\\n    def stoneGameII(self, A: List[int]) -> int:\\n        n = len(A)\\n        for i in range(n - 1):\\n            A[i + 1] += A[i]\\n        d = {}\\n        def helper(i, m):\\n            if i >= n: return 0\\n            if (i, m) in d: return d[i, m]\\n            res = 0\\n            for x in range(1, min(2 * m + 1, n - i + 1)):\\n                res = max(res, A[n - 1] - (A[i - 1] if i > 0 else 0) - helper(i + x, max(m, x)))\\n            d[i, m] = res\\n            return res\\n        return helper(0, 1)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def stoneGameII(self, A: List[int]) -> int:\\n        n = len(A)\\n        for i in range(n - 1):\\n            A[i + 1] += A[i]\\n        d = {}\\n        def helper(i, m):\\n            if i >= n: return 0\\n            if (i, m) in d: return d[i, m]\\n            res = 0\\n            for x in range(1, min(2 * m + 1, n - i + 1)):\\n                res = max(res, A[n - 1] - (A[i - 1] if i > 0 else 0) - helper(i + x, max(m, x)))\\n            d[i, m] = res\\n            return res\\n        return helper(0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345984,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        n = piles.size();\\n        vdp = vector<vector<int>>(65, vector<int>(n, 0));\\n        for (auto x : piles) vsum.push_back(x + vsum.back());\\n        return dp(1, 0);\\n    }\\n\\n    int dp(const int m, const int i) {\\n        if (i == n) return 0;\\n        if (vdp[m][i] > 0) return vdp[m][i];\\n        for (int x = 1; x <= 2 * m && i + x <= n; x++)\\n            vdp[m][i] = max(vdp[m][i], vsum[n] - vsum[i] - dp(max(m, x), i + x));\\n        return vdp[m][i];\\n    }\\n\\n    int n;\\n    vector<vector<int>> vdp; // {M, i}\\n    vector<int> vsum = { 0 };\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        n = piles.size();\\n        vdp = vector<vector<int>>(65, vector<int>(n, 0));\\n        for (auto x : piles) vsum.push_back(x + vsum.back());\\n        return dp(1, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 345277,
                "title": "dp-cache-python",
                "content": "Trick is to build look up id using length of remaining pile + M value\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        cache = {}\\n        n = len(piles)\\n        def cal(piles, M):\\n            p = str(len(piles)) + \"-\" + str(M)\\n            if p in cache:\\n                return cache[p]\\n            tot = sum(piles)\\n            if len(piles) <= 2*M: return tot\\n            num = tot\\n            for x in range(1, 2*M+1):\\n                num = min(num, cal(piles[x:], max(x, M)))\\n            ans = tot - num\\n            cache[p] = ans\\n            return ans        \\n        return cal(piles, 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        cache = {}\\n        n = len(piles)\\n        def cal(piles, M):\\n            p = str(len(piles)) + \"-\" + str(M)\\n            if p in cache:\\n                return cache[p]\\n            tot = sum(piles)\\n            if len(piles) <= 2*M: return tot\\n            num = tot\\n            for x in range(1, 2*M+1):\\n                num = min(num, cal(piles[x:], max(x, M)))\\n            ans = tot - num\\n            cache[p] = ans\\n            return ans        \\n        return cal(piles, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925136,
                "title": "easy-python-game-theory-dp-solution-2d",
                "content": "# Intuition\\nEach player at any point of the game will the stones he collects at this round and the number of stones left minus the max number of stones the other player can get.\\n```\\nF(M, i) = max(sum(pile[i:i + x]) + postfix[i+1] - F(max(M, x), i + x))\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: N^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        postfix = [0 for _ in piles]\\n        csum = 0\\n        for i in range(len(piles)-1 , -1, -1):\\n            csum += piles[i]\\n            postfix[i] = csum\\n        @functools.cache\\n        def dp(M, c):\\n            if 2 * M >= len(piles) - c:\\n                return sum(piles[c:])\\n            else:\\n                val = 0\\n                cmax = 0\\n                for i in range(c, min(len(piles), c + 2* M)):\\n                    val += piles[i]\\n                    cmax = max(val + postfix[i + 1] - dp(max(i - c + 1, M), i + 1), cmax)\\n                return cmax\\n\\n        return dp(1, 0)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nF(M, i) = max(sum(pile[i:i + x]) + postfix[i+1] - F(max(M, x), i + x))\\n```\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        postfix = [0 for _ in piles]\\n        csum = 0\\n        for i in range(len(piles)-1 , -1, -1):\\n            csum += piles[i]\\n            postfix[i] = csum\\n        @functools.cache\\n        def dp(M, c):\\n            if 2 * M >= len(piles) - c:\\n                return sum(piles[c:])\\n            else:\\n                val = 0\\n                cmax = 0\\n                for i in range(c, min(len(piles), c + 2* M)):\\n                    val += piles[i]\\n                    cmax = max(val + postfix[i + 1] - dp(max(i - c + 1, M), i + 1), cmax)\\n                return cmax\\n\\n        return dp(1, 0)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694250,
                "title": "dp-on-stones-c-full-explanation",
                "content": "\\n\\n# Approach\\nThe Recursive function definition => It gives the difference of score of player who is playing in this chance and the other player.\\n\\nAccordingly we try out all possible combinations of stones that can be picked from 1 -> M.\\n\\nFinally we have the value of (a-b) from function. And a+b, we can calculate from array.\\n\\nThus ans = (a+b + a-b)/2\\n\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n\\n        int rec(vector<int> &v, vector<vector<int>> &dp, int m, int i)\\n        {\\n            int ans = INT_MIN;\\n            if (i >= v.size()) return 0;\\n\\n           \\tif(dp[i][m] != -1) return dp[i][m];\\n            int tot = 0;\\n            for(int j=0;j<2*m;j++){\\n                \\n                if(i+j < v.size()){\\n                    tot += v[i+j];\\n                }\\n                ans = max(ans, tot - rec(v, dp, max(m, j+1), i+j+1));\\n            }\\n\\n            return dp[i][m] = ans;\\n        }\\n\\n\\n    int stoneGameII(vector<int> &piles) {\\n        int n = piles.size();\\n        int s = 0;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1,-1));\\n        s = accumulate(piles.begin(), piles.end(), s);\\n        int diff = rec(piles, dp, 1, 0);\\n        return (s+diff)/2;\\n    }\\n};\\n```\\n\\nIF THE EXPLANATION WAS GOOD, PLEASE UPVOTE, IT REALLY MEANS A LOT AND I WILL TRY TO GIVE SIMILAR SOLUTIONS TO MORE QUESTIONS\\n\\n![bird2.gif](https://assets.leetcode.com/users/images/bffe7105-cd11-47ec-b9f2-82192833f831_1687979644.2160776.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n\\n        int rec(vector<int> &v, vector<vector<int>> &dp, int m, int i)\\n        {\\n            int ans = INT_MIN;\\n            if (i >= v.size()) return 0;\\n\\n           \\tif(dp[i][m] != -1) return dp[i][m];\\n            int tot = 0;\\n            for(int j=0;j<2*m;j++){\\n                \\n                if(i+j < v.size()){\\n                    tot += v[i+j];\\n                }\\n                ans = max(ans, tot - rec(v, dp, max(m, j+1), i+j+1));\\n            }\\n\\n            return dp[i][m] = ans;\\n        }\\n\\n\\n    int stoneGameII(vector<int> &piles) {\\n        int n = piles.size();\\n        int s = 0;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1,-1));\\n        s = accumulate(piles.begin(), piles.end(), s);\\n        int diff = rec(piles, dp, 1, 0);\\n        return (s+diff)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680983,
                "title": "easy-best-solution-iit-dp-100-faster",
                "content": "# Intuition\\nAgain this is a choosing type problem, where it is difficult to say greedily. Hence dp comes into the picture. Now, what are the states and transitions. \\nSo what things describe a state uniquely? In this question, which player is playing, value of m at that instant, and no. of piles already taken by the players. These 3 things are the criteria that uniquely describes the games proceeding.\\nSo, in our dp[i][j][k] -> it will store maximum points alice can store if currently ith player\\'s turn, with m value equal to j, and elements from k to n are remaining. \\nNow, when Bob\\'s turn is there it will try to reduce the score, and when alice turn\\'s it will try to maximise it.\\n# Approach\\nSimply writing transitions,\\ndp[i][j][k] can be found by looping over the values of x than can be taken by the current player, and then passing it to other player that means moving to next dp state. When Alice turn, maximise score will be there as he will try to maximise his score, and Bob will try to minimise dp as he will try to minimise alice\\'s score.\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n- Space complexity:\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        n = piles.size();\\n        vector<int> pre(n+1, 0);\\n        for(int i = 1; i <= piles.size(); i++)\\n        {\\n            pre[i] = pre[i-1] + piles[i-1];\\n        }\\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(n+5, vector<int>(n+5, -1)));\\n        return dp_fun(dp, piles, pre, 0, 0, 1);\\n    }\\n\\n    int dp_fun(vector<vector<vector<int>>>&dp, vector<int>&p, vector<int>&pre, int chn, int rem, int m)\\n    {\\n        if(rem >= n)\\n        {\\n            return 0;\\n        }\\n        if(dp[chn][rem][m] == -1)\\n        {\\n            dp[chn][rem][m] = 0;\\n            if(chn == 1)\\n            {\\n                dp[chn][rem][m] = 1e8;\\n            }\\n            for(int i = rem; i < min(n, rem + 2*m); i++)\\n            {\\n                int tkn = i-rem+1;\\n                //alice turn\\n                if(chn == 0)\\n                {   \\n                    int ext = pre[i+1] - pre[rem];\\n                    dp[chn][rem][m] = max(dp[chn][rem][m], dp_fun(dp, p, pre, 1, i+1, max(m, tkn))+ext);                    \\n                }\\n                else //bob turn\\n                {\\n                    dp[chn][rem][m] = min(dp[chn][rem][m], dp_fun(dp, p, pre, 0, i+1, max(m, tkn)));                    \\n                }\\n            }\\n        }\\n        return dp[chn][rem][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        n = piles.size();\\n        vector<int> pre(n+1, 0);\\n        for(int i = 1; i <= piles.size(); i++)\\n        {\\n            pre[i] = pre[i-1] + piles[i-1];\\n        }\\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(n+5, vector<int>(n+5, -1)));\\n        return dp_fun(dp, piles, pre, 0, 0, 1);\\n    }\\n\\n    int dp_fun(vector<vector<vector<int>>>&dp, vector<int>&p, vector<int>&pre, int chn, int rem, int m)\\n    {\\n        if(rem >= n)\\n        {\\n            return 0;\\n        }\\n        if(dp[chn][rem][m] == -1)\\n        {\\n            dp[chn][rem][m] = 0;\\n            if(chn == 1)\\n            {\\n                dp[chn][rem][m] = 1e8;\\n            }\\n            for(int i = rem; i < min(n, rem + 2*m); i++)\\n            {\\n                int tkn = i-rem+1;\\n                //alice turn\\n                if(chn == 0)\\n                {   \\n                    int ext = pre[i+1] - pre[rem];\\n                    dp[chn][rem][m] = max(dp[chn][rem][m], dp_fun(dp, p, pre, 1, i+1, max(m, tkn))+ext);                    \\n                }\\n                else //bob turn\\n                {\\n                    dp[chn][rem][m] = min(dp[chn][rem][m], dp_fun(dp, p, pre, 0, i+1, max(m, tkn)));                    \\n                }\\n            }\\n        }\\n        return dp[chn][rem][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619679,
                "title": "simple-to-understand-c-memoization",
                "content": "# Approach\\n* Starting with Alice , Alice will try to maximise the score thus choosing maximum from all possibilities\\n* Bob will try to minimize Alice\\'s score thus choosing minimum from all possibilities\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alice(vector<int>&p , int idx , int m , vector<vector<vector<int>>>&dp){\\n        if(idx>=p.size()) return 0;\\n\\n        if(dp[idx][m][1] != -1) return dp[idx][m][1];\\n\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i = 0;i<(2*m) && (idx + i)<p.size();i++){\\n            sum += p[idx + i];\\n            ans = max(ans , sum + bob(p , idx+i+1 , max(i+1 , m) , dp));\\n        }\\n        return dp[idx][m][1] = ans;\\n    }\\n\\n    int bob(vector<int>&p , int idx , int m , vector<vector<vector<int>>>&dp){\\n        if(idx>=p.size()) return 0;\\n        if(dp[idx][m][0] != -1) return dp[idx][m][0];\\n        int ans = INT_MAX;\\n        for(int i = 0;i<(2*m) && (idx + i)<p.size();i++){\\n            ans = min(ans , alice(p , idx+i+1 , max(i+1 , m) , dp));\\n        }\\n        return dp[idx][m][0] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        vector<vector<vector<int>>>dp(piles.size() , vector<vector<int>>(piles.size()+1 , vector<int>(2,-1)));\\n        return alice(piles , 0 , 1 , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alice(vector<int>&p , int idx , int m , vector<vector<vector<int>>>&dp){\\n        if(idx>=p.size()) return 0;\\n\\n        if(dp[idx][m][1] != -1) return dp[idx][m][1];\\n\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i = 0;i<(2*m) && (idx + i)<p.size();i++){\\n            sum += p[idx + i];\\n            ans = max(ans , sum + bob(p , idx+i+1 , max(i+1 , m) , dp));\\n        }\\n        return dp[idx][m][1] = ans;\\n    }\\n\\n    int bob(vector<int>&p , int idx , int m , vector<vector<vector<int>>>&dp){\\n        if(idx>=p.size()) return 0;\\n        if(dp[idx][m][0] != -1) return dp[idx][m][0];\\n        int ans = INT_MAX;\\n        for(int i = 0;i<(2*m) && (idx + i)<p.size();i++){\\n            ans = min(ans , alice(p , idx+i+1 , max(i+1 , m) , dp));\\n        }\\n        return dp[idx][m][0] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        vector<vector<vector<int>>>dp(piles.size() , vector<vector<int>>(piles.size()+1 , vector<int>(2,-1)));\\n        return alice(piles , 0 , 1 , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583319,
                "title": "stone-game-mayhem-crushing-opponents-and-chasing-the-ultimate-pile",
                "content": "**Introduction**:\\n\\nWelcome to the fascinating realm of the Stone Game, where players engage in a battle of wits and strategic prowess. In this article, we will embark on a comprehensive exploration of this mind-bending challenge. Prepare yourself for an in-depth analysis of the game\\'s mechanics, an examination of the zero-sum nature of the game, an unveiling of the optimal strategy, and an understanding of why Bob\\'s lack of a \"current_sum\" doesn\\'t hinder his chances of victory. Get ready to immerse yourself in the captivating world of the Stone Game and emerge as a master tactician!\\n\\n1. The Stone Game: A Game of Stones and Strategy:\\nImagine a scenario where piles of stones are strategically arranged, and two players, Alice and Bob, take turns in an attempt to maximize their individual gains. The objective is to end the game with the highest number of stones, and achieving this requires calculated moves and a deep understanding of game theory.\\n\\n2. Zero Sum and Strategic Brilliance:\\nThe Stone Game falls under the category of a zero-sum game, meaning that the total gain for one player is equal to the total loss of the other player. Every stone acquired by Alice is effectively a stone denied to Bob, and vice versa. This dynamic sets the stage for intense strategic maneuvering, as each player aims to outwit their opponent and secure a substantial advantage.\\n\\n3. The Optimal Strategy: Decoding Alice\\'s Path to Victory:\\nTo conquer the Stone Game, Alice employs a meticulously crafted strategy that maximizes her gains while putting Bob at a disadvantage. The solution lies in a dynamic programming algorithm that optimizes decision-making through memoization. By efficiently storing and recalling previous moves, Alice can make informed choices and inch closer to victory.\\n\\n4. Understanding the Recursive Algorithm:\\nAlice takes the first turn and begins by evaluating all possible options. She carefully calculates the cumulative sum of stones she can acquire from a range of piles, considering the constraint that she can select between 1 and 2M piles, where M represents her maximum selection range. Alice then recursively calls the function, passing the turn to Bob and adjusting the selection range accordingly.\\n\\n5. Bob\\'s Strategic Brilliance:\\nCuriously, Bob\\'s strategy does not require him to keep track of a \"current_sum\" as Alice does. Bob\\'s sole objective is to minimize Alice\\'s gains, adopting a defensive approach that thwarts her progress. By strategically selecting the optimal number of stones from the remaining piles, Bob effectively hinders Alice\\'s cumulative sum, ensuring that her score remains in check.\\n\\n6. Unveiling the Zero Game\\'s Intricacies:\\nThe Stone Game is not a mere battle of luck but a complex arena where strategic thinking reigns supreme. With each turn, Alice and Bob engage in a battle of wits, evaluating the potential gains and losses, calculating the optimal number of stones to select, and adjusting their strategies on the fly.\\n\\n**Conclusion**:\\nAs we conclude our captivating exploration of the Stone Game, we witness the brilliance and depth of strategic thinking required to emerge victorious. Alice\\'s optimal strategy, guided by dynamic programming, allows her to make calculated moves and maximize her gains. Bob, on the other hand, relies on his tactical prowess to disrupt Alice\\'s progress without the need for a \"current_sum.\" Together, they epitomize the intensity and intellectual depth of the zero-sum game.\\n\\nSo, step into the realm of the Stone Game, where stones become the embodiment of strategic opportunities, and every move holds the potential to sway the outcome. Immerse yourself in the art of outsmarting your opponent, grasp the intricacies of game theory, and emerge as a master of the Stone Game\\'s strategic brilliance!\\n\\n**Solution**\\n\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        @cache\\n        def solve(hero, x, m):\\n\\n            if x == len(piles):\\n                return 0\\n\\n            if hero == 0:\\n                current_sum = 0\\n                ans = float(\\'-inf\\')\\n                for y in range(1, min(2 * m, len(piles) - x) + 1):\\n                    current_sum += piles[x + y - 1]\\n                    ans = max(ans, current_sum + solve(1, x + y, max(y, m)))\\n            else:\\n                ans = float(\\'inf\\')\\n                for y in range(1, min(2 * m, len(piles) - x) + 1):\\n                    ans = min(ans, solve(0, x + y, max(y, m)))\\n\\n            return ans\\n\\n        return solve(0, 0, 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        @cache\\n        def solve(hero, x, m):\\n\\n            if x == len(piles):\\n                return 0\\n\\n            if hero == 0:\\n                current_sum = 0\\n                ans = float(\\'-inf\\')\\n                for y in range(1, min(2 * m, len(piles) - x) + 1):\\n                    current_sum += piles[x + y - 1]\\n                    ans = max(ans, current_sum + solve(1, x + y, max(y, m)))\\n            else:\\n                ans = float(\\'inf\\')\\n                for y in range(1, min(2 * m, len(piles) - x) + 1):\\n                    ans = min(ans, solve(0, x + y, max(y, m)))\\n\\n            return ans\\n\\n        return solve(0, 0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574760,
                "title": "c-using-memoization-t-c-o-n-3-s-c-o-n-3",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^3) \\n    */\\n    \\nprivate:\\n    int n;\\n    int dp[2][101][101];\\n    \\n    int solveForAlice(int i, int player, int M, vector<int> &piles){\\n        if(i>=n) return 0;\\n        \\n        if(dp[player][i][M] != -1) return dp[player][i][M];\\n        \\n        int stones = 0, result;\\n        result = (player == 1) ? -1 : INT_MAX;\\n        \\n        for(int X=1; X<=min(2*M, n-i); X++){\\n            if(player == 1){\\n                stones += piles[i+X-1];\\n                \\n                result = max(result, stones + solveForAlice(i+X, 0, max(M, X), piles));\\n            }else{\\n                result = min(result, solveForAlice(i+X, 1, max(M, X), piles));\\n            }\\n        }\\n        \\n        return dp[player][i][M] = result;\\n    }\\n    \\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solveForAlice(0, 1, 1, piles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^3) \\n    */\\n    \\nprivate:\\n    int n;\\n    int dp[2][101][101];\\n    \\n    int solveForAlice(int i, int player, int M, vector<int> &piles){\\n        if(i>=n) return 0;\\n        \\n        if(dp[player][i][M] != -1) return dp[player][i][M];\\n        \\n        int stones = 0, result;\\n        result = (player == 1) ? -1 : INT_MAX;\\n        \\n        for(int X=1; X<=min(2*M, n-i); X++){\\n            if(player == 1){\\n                stones += piles[i+X-1];\\n                \\n                result = max(result, stones + solveForAlice(i+X, 0, max(M, X), piles));\\n            }else{\\n                result = min(result, solveForAlice(i+X, 1, max(M, X), piles));\\n            }\\n        }\\n        \\n        return dp[player][i][M] = result;\\n    }\\n    \\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        n = piles.size();\\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solveForAlice(0, 1, 1, piles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566282,
                "title": "python-recursive-minimax-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thoughts when approaching this problem were that this is a zero-sum game. Each player would like to maximize their gains, which is the same as minimizing the opponent\\'s gains. Additionally, we will be using sums of ranges a lot, so we can use prefix sums to optimize our time complexity here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor a problem/situation like this, we can use the minimax algorithm. Essentially, we work our way from a smaller problem up, at each step asking\\n> If my opponent were to maximize their score here, how would they do it?\\n\\nWorking from the very lowest case, when there are m or less items available, we know that the optimal play is to take all of them, as they all have positive value. This is the `else` branch in our minimax function. On the other hand, if we cannot simply take all of the remaining items, we\\'ll iterate over all possible moves and pick the one which gives our opponent the lowest maximal score. We then return our score, which is essentially what the opponent did not take (the sum to the end of the list minus their score.) It might help to draw this out and follow a few executions down in recursion to see how this produces the correct sum.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is $$O(n^3)$$, I believe, as we can call the minimax function once on each set of possible parameters `idx, m`, both of which can be upper-bounded by $$n$$, and inside the function we loop over a number of values proportional to list length.\\n\\n- Space complexity:\\nThe size of the cache should be around $$O(n^2)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        # prefix sums\\n        n = len(piles)\\n        for i in range(1, n):\\n            piles[i] += piles[i - 1]\\n        piles.insert(0, 0)\\n        \\n        # lru_cache allows us to cheat and basically do dp without\\n        # the mess (it stores previous executions and results)\\n        # needs the maxsize parameter, otherwise TLE because cache\\n        # is too small\\n        @lru_cache(maxsize=None)\\n        def minimax(idx, m):\\n            if idx + m < n:\\n                opt = [0,1000000]\\n                for i in range(1, min(2 * m + 1, n - idx + 1)):\\n                    # here res is the value your opponent will have\\n                    # we\\'d like to minimize this\\n                    res = minimax(idx + i, max(m, i))\\n                    if res < opt[1]:\\n                        opt[0] = idx + i\\n                        opt[1] = res\\n                return piles[n] - piles[idx] - opt[1]\\n            else:\\n                return piles[n] - piles[idx]\\n\\n        return minimax(0, 1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        # prefix sums\\n        n = len(piles)\\n        for i in range(1, n):\\n            piles[i] += piles[i - 1]\\n        piles.insert(0, 0)\\n        \\n        # lru_cache allows us to cheat and basically do dp without\\n        # the mess (it stores previous executions and results)\\n        # needs the maxsize parameter, otherwise TLE because cache\\n        # is too small\\n        @lru_cache(maxsize=None)\\n        def minimax(idx, m):\\n            if idx + m < n:\\n                opt = [0,1000000]\\n                for i in range(1, min(2 * m + 1, n - idx + 1)):\\n                    # here res is the value your opponent will have\\n                    # we\\'d like to minimize this\\n                    res = minimax(idx + i, max(m, i))\\n                    if res < opt[1]:\\n                        opt[0] = idx + i\\n                        opt[1] = res\\n                return piles[n] - piles[idx] - opt[1]\\n            else:\\n                return piles[n] - piles[idx]\\n\\n        return minimax(0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565705,
                "title": "java-recursive-memoization",
                "content": "```\\nclass Solution {\\n    int[][][] dp = new int[2][104][105];\\n    \\n    public int solve(boolean alice,int i, int[] piles, int m ){\\n        int cx = 1 , j = i, ret = alice ? 0 : Integer.MAX_VALUE;\\n        int sum = 0, n = piles.length;\\n        if(i >= n)\\n            return 0;\\n        \\n        int zero = alice ? 0 :1;\\n        \\n        if(dp[zero][i][m] != -1)\\n            return dp[zero][i][m] ;\\n        \\n        while(j < n && cx <= 2*m){\\n            sum+=piles[j];\\n            int got = solve(!alice, j+1,piles,Math.max(m, j-i+1));\\n            if(alice)\\n                ret = Math.max(ret, sum+got);\\n            else\\n                ret = Math.min(ret, got);\\n            j++;\\n            cx++;\\n        }\\n        dp[zero][i][m]  = ret;\\n        return ret;\\n    }\\n    \\n    public int stoneGameII(int[] piles) {\\n        for(int[][] mat : dp)\\n            for(int[] ar : mat)\\n                Arrays.fill(ar, -1);\\n        int ans = solve(true,0,piles, 1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][][] dp = new int[2][104][105];\\n    \\n    public int solve(boolean alice,int i, int[] piles, int m ){\\n        int cx = 1 , j = i, ret = alice ? 0 : Integer.MAX_VALUE;\\n        int sum = 0, n = piles.length;\\n        if(i >= n)\\n            return 0;\\n        \\n        int zero = alice ? 0 :1;\\n        \\n        if(dp[zero][i][m] != -1)\\n            return dp[zero][i][m] ;\\n        \\n        while(j < n && cx <= 2*m){\\n            sum+=piles[j];\\n            int got = solve(!alice, j+1,piles,Math.max(m, j-i+1));\\n            if(alice)\\n                ret = Math.max(ret, sum+got);\\n            else\\n                ret = Math.min(ret, got);\\n            j++;\\n            cx++;\\n        }\\n        dp[zero][i][m]  = ret;\\n        return ret;\\n    }\\n    \\n    public int stoneGameII(int[] piles) {\\n        for(int[][] mat : dp)\\n            for(int[] ar : mat)\\n                Arrays.fill(ar, -1);\\n        int ans = solve(true,0,piles, 1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565600,
                "title": "c-easiest-hindi-explanation-codestorywithmik",
                "content": "YouTube Video Link : https://www.youtube.com/watch?v=9f1vzDFVnGA\\nMy Githu Treasure : [Link](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/DP/Game%20Strategy/Stone%20Game%20II.cpp)\\n\\n\\n```\\n//Recursion + Memo\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    int t[2][101][101]; //t[2][n+1][n+1] - 2*(n+1)*(n+1) ~n^2 * n ~ O(n^3)\\n    int solveForAlice(vector<int>& piles, int person, int i, int M) {\\n        \\n        if(i >= n)\\n            return 0;\\n        \\n        if(t[person][i][M] != -1)\\n            return t[person][i][M];\\n        \\n        int result = (person == 1) ? -1 : INT_MAX;\\n        \\n        int stones = 0;\\n        \\n        for(int x = 1; x <= min(2*M, n-i); x++) {\\n            \\n            stones += piles[i+x-1];\\n            \\n            if(person == 1) { //Alice\\n                result = max(result, stones + solveForAlice(piles, 0, i+x, max(M, x)));\\n            } else { //Bob\\n                result = min(result, solveForAlice(piles, 1, i+x, max(M, x)));\\n            }\\n            \\n        }\\n        \\n        return t[person][i][M] = result;\\n        \\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        n = piles.size();\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        return solveForAlice(piles, 1, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Recursion + Memo\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    int t[2][101][101]; //t[2][n+1][n+1] - 2*(n+1)*(n+1) ~n^2 * n ~ O(n^3)\\n    int solveForAlice(vector<int>& piles, int person, int i, int M) {\\n        \\n        if(i >= n)\\n            return 0;\\n        \\n        if(t[person][i][M] != -1)\\n            return t[person][i][M];\\n        \\n        int result = (person == 1) ? -1 : INT_MAX;\\n        \\n        int stones = 0;\\n        \\n        for(int x = 1; x <= min(2*M, n-i); x++) {\\n            \\n            stones += piles[i+x-1];\\n            \\n            if(person == 1) { //Alice\\n                result = max(result, stones + solveForAlice(piles, 0, i+x, max(M, x)));\\n            } else { //Bob\\n                result = min(result, solveForAlice(piles, 1, i+x, max(M, x)));\\n            }\\n            \\n        }\\n        \\n        return t[person][i][M] = result;\\n        \\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        n = piles.size();\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        return solveForAlice(piles, 1, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565364,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int fun(int idx,int m,int turn,int n,vector<int>& piles){\\n        if(idx==n) return 0;\\n        if(dp[idx][m][turn] != -1) return dp[idx][m][turn];\\n        if(turn){\\n            int res=0,sum=0;\\n            for(int i=idx;i<idx+2*m and i<n;i++){\\n                sum+=piles[i];\\n                res=max(sum+fun(i+1,max(m,i-idx+1),0,n,piles),res);\\n            }\\n            return dp[idx][m][turn]=res;\\n        }\\n        else{\\n            int res=INT_MAX;\\n            for(int i=idx;i<idx+2*m and i<n;i++){\\n                res=min(fun(i+1,max(m,i-idx+1),1,n,piles),res);\\n            }\\n            return dp[idx][m][turn]=res;\\n        }\\n    }\\n    int stoneGameII(vector<int>& piles){\\n        int n=piles.size();\\n        dp=vector<vector<vector<int>>> (n,vector<vector<int>>(n+2,vector<int>(2,-1)));\\n        return fun(0,1,1,n,piles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    int fun(int idx,int m,int turn,int n,vector<int>& piles){\\n        if(idx==n) return 0;\\n        if(dp[idx][m][turn] != -1) return dp[idx][m][turn];\\n        if(turn){\\n            int res=0,sum=0;\\n            for(int i=idx;i<idx+2*m and i<n;i++){\\n                sum+=piles[i];\\n                res=max(sum+fun(i+1,max(m,i-idx+1),0,n,piles),res);\\n            }\\n            return dp[idx][m][turn]=res;\\n        }\\n        else{\\n            int res=INT_MAX;\\n            for(int i=idx;i<idx+2*m and i<n;i++){\\n                res=min(fun(i+1,max(m,i-idx+1),1,n,piles),res);\\n            }\\n            return dp[idx][m][turn]=res;\\n        }\\n    }\\n    int stoneGameII(vector<int>& piles){\\n        int n=piles.size();\\n        dp=vector<vector<vector<int>>> (n,vector<vector<int>>(n+2,vector<int>(2,-1)));\\n        return fun(0,1,1,n,piles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565263,
                "title": "c-recursion-memoization-dynamic-programming-beginner-friendly",
                "content": "# Recursion (TLE)\\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind, int m, vector<int>& piles, int n) {\\n        if (ind >= n) return 0;\\n        int tot = 0, ans = INT_MIN;\\n        for (int x = 0; x < 2 * m; x++) {\\n            if (ind + x < n) tot += piles[ind + x];\\n            ans = max(ans, tot - dfs(ind + x + 1, max(m, x + 1), piles, n));\\n        }\\n\\n        return ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size(), sum = 0;\\n        for (auto &it : piles) sum += it;\\n        int aliceBob = dfs(0, 1, piles, n);\\n        return (sum + aliceBob) / 2;\\n    }\\n};\\n```\\n\\n# Memoization (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind, int m, vector<int>& piles, int n, vector<vector<int>>& dp) {\\n        if (ind >= n) return 0;\\n        if (dp[ind][m] != -1) return dp[ind][m];\\n        int tot = 0, ans = INT_MIN;\\n        for (int x = 0; x < 2 * m; x++) {\\n            if (ind + x < n) tot += piles[ind + x];\\n            ans = max(ans, tot - dfs(ind + x + 1, max(m, x + 1), piles, n, dp));\\n        }\\n\\n        return dp[ind][m] = ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size(), sum = 0;\\n        for (auto &it : piles) sum += it;\\n\\n        vector<vector<int>> dp(n, vector<int>(2 * n, -1));\\n        int aliceBob = dfs(0, 1, piles, n, dp);\\n        return (sum + aliceBob) / 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int ind, int m, vector<int>& piles, int n) {\\n        if (ind >= n) return 0;\\n        int tot = 0, ans = INT_MIN;\\n        for (int x = 0; x < 2 * m; x++) {\\n            if (ind + x < n) tot += piles[ind + x];\\n            ans = max(ans, tot - dfs(ind + x + 1, max(m, x + 1), piles, n));\\n        }\\n\\n        return ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size(), sum = 0;\\n        for (auto &it : piles) sum += it;\\n        int aliceBob = dfs(0, 1, piles, n);\\n        return (sum + aliceBob) / 2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind, int m, vector<int>& piles, int n, vector<vector<int>>& dp) {\\n        if (ind >= n) return 0;\\n        if (dp[ind][m] != -1) return dp[ind][m];\\n        int tot = 0, ans = INT_MIN;\\n        for (int x = 0; x < 2 * m; x++) {\\n            if (ind + x < n) tot += piles[ind + x];\\n            ans = max(ans, tot - dfs(ind + x + 1, max(m, x + 1), piles, n, dp));\\n        }\\n\\n        return dp[ind][m] = ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size(), sum = 0;\\n        for (auto &it : piles) sum += it;\\n\\n        vector<vector<int>> dp(n, vector<int>(2 * n, -1));\\n        int aliceBob = dfs(0, 1, piles, n, dp);\\n        return (sum + aliceBob) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564772,
                "title": "java-solution-beats-100-easy-to-understand",
                "content": "# PLEASE UPVOTE \\n# Code\\n```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int len = piles.length;\\n        int[] preSum = Arrays.copyOf(piles, len);\\n        for (int i = len - 2; i >= 0; i--)\\n            preSum[i] += preSum[i + 1];\\n        return dfs(preSum, 1, 0, new int[len][len]);\\n    }\\n    \\n    private int dfs(int[] preSum, int m, int p, int[][] memo) {\\n        if (p + 2 * m >= preSum.length)\\n            return preSum[p];\\n        if (memo[p][m] > 0)\\n            return memo[p][m];\\n        int result = 0, take = 0;\\n        for (int i = 1; i <= 2 * m; i++) {\\n            take = preSum[p] - preSum[p + i];\\n            result = Math.max(result, take + preSum[p + i] - dfs(preSum, Math.max(i, m), p + i, memo));\\n        }\\n        memo[p][m] = result;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int len = piles.length;\\n        int[] preSum = Arrays.copyOf(piles, len);\\n        for (int i = len - 2; i >= 0; i--)\\n            preSum[i] += preSum[i + 1];\\n        return dfs(preSum, 1, 0, new int[len][len]);\\n    }\\n    \\n    private int dfs(int[] preSum, int m, int p, int[][] memo) {\\n        if (p + 2 * m >= preSum.length)\\n            return preSum[p];\\n        if (memo[p][m] > 0)\\n            return memo[p][m];\\n        int result = 0, take = 0;\\n        for (int i = 1; i <= 2 * m; i++) {\\n            take = preSum[p] - preSum[p + i];\\n            result = Math.max(result, take + preSum[p + i] - dfs(preSum, Math.max(i, m), p + i, memo));\\n        }\\n        memo[p][m] = result;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564770,
                "title": "min-max-algorithm-dp-c",
                "content": "Alice will try to maximise her score and bob will try to minimise the score of alice,so we can simply apply recursion and then memoise it.Here is the code:\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101][300][2];\\n    int solve(int i,int m,bool b,vector<int> &piles)\\n    {\\n        int n=piles.size();\\n        if(i>=n)\\n        {\\n            return 0ll;\\n        }\\n        int mn=1e9;\\n        int mx=0;\\n        int s=0;\\n        if(dp[i][m][b]!=-1)\\n        {\\n            return dp[i][m][b];\\n        }\\n        for(int idx=i;idx<=min(i+2*m-1,n-1);idx++)\\n        {\\n            if(b)\\n            {\\n                s=s+piles[idx];\\n                mx=max(mx,s+solve(idx+1,max(idx-i+1,m),false,piles));\\n            }\\n            else\\n            {\\n                mn=min(mn,solve(idx+1,max(idx-i+1,m),true,piles));\\n            }\\n        }\\n        if(b)\\n        {\\n            return dp[i][m][b]=mx;\\n        }\\n        return dp[i][m][b]=mn;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,true,piles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][300][2];\\n    int solve(int i,int m,bool b,vector<int> &piles)\\n    {\\n        int n=piles.size();\\n        if(i>=n)\\n        {\\n            return 0ll;\\n        }\\n        int mn=1e9;\\n        int mx=0;\\n        int s=0;\\n        if(dp[i][m][b]!=-1)\\n        {\\n            return dp[i][m][b];\\n        }\\n        for(int idx=i;idx<=min(i+2*m-1,n-1);idx++)\\n        {\\n            if(b)\\n            {\\n                s=s+piles[idx];\\n                mx=max(mx,s+solve(idx+1,max(idx-i+1,m),false,piles));\\n            }\\n            else\\n            {\\n                mn=min(mn,solve(idx+1,max(idx-i+1,m),true,piles));\\n            }\\n        }\\n        if(b)\\n        {\\n            return dp[i][m][b]=mx;\\n        }\\n        return dp[i][m][b]=mn;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,true,piles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564469,
                "title": "java-naive-recursion-brute-force-approach",
                "content": "```\\n// Approach 1: Naive Recursion (Brute Force Approach) - TLE\\n\\n// Time complexity: O(2^n)\\n// Space complexity: O(2^n)\\n\\nclass Solution {\\n    int[] piles;\\n    \\n    public int stoneGameII(int[] piles) {\\n        this.piles = piles;\\n        return dfs(0, 0, 1);\\n    }\\n    \\n    private int dfs(int p, int i, int m) {\\n        if (i >= piles.length)\\n            return 0;\\n        \\n        int res = p == 0 ? 0 : 1000000;\\n        int total = 0;\\n        \\n        for (int x = 1; x <= 2 * m; x++) {\\n            if (i + x > piles.length)\\n                break;\\n            \\n            total += piles[i + x - 1];\\n            \\n            if (p == 0)\\n                res = Math.max(res, total + dfs(1, i + x, Math.max(m, x)));\\n            else\\n                res = Math.min(res, dfs(0, i + x, Math.max(m, x)));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Note:** This solution gives TLE. It\\'s provided just for understanding purpose.\\n**Please upvote if you find this solution useful. Happy Coding!**\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Approach 1: Naive Recursion (Brute Force Approach) - TLE\\n\\n// Time complexity: O(2^n)\\n// Space complexity: O(2^n)\\n\\nclass Solution {\\n    int[] piles;\\n    \\n    public int stoneGameII(int[] piles) {\\n        this.piles = piles;\\n        return dfs(0, 0, 1);\\n    }\\n    \\n    private int dfs(int p, int i, int m) {\\n        if (i >= piles.length)\\n            return 0;\\n        \\n        int res = p == 0 ? 0 : 1000000;\\n        int total = 0;\\n        \\n        for (int x = 1; x <= 2 * m; x++) {\\n            if (i + x > piles.length)\\n                break;\\n            \\n            total += piles[i + x - 1];\\n            \\n            if (p == 0)\\n                res = Math.max(res, total + dfs(1, i + x, Math.max(m, x)));\\n            else\\n                res = Math.min(res, dfs(0, i + x, Math.max(m, x)));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564367,
                "title": "js-solution-beats-100-both-time-and-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/a365f6eb-012f-4b8c-a24e-be98054f6871_1685089122.5962358.png)\\n\\n(*): The only submission whose memory was better than mine is from a cheater, he just returned every single testcase\\'s expected result from a constant array (**). Therefore, I could claim that my solution has beaten 100% legitimately.\\n\\n(**) His code:\\n![image.png](https://assets.leetcode.com/users/images/6ac16fad-96e4-4514-8e47-d7ff25f70b9d_1685089923.9541268.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```js\\n/**\\n * @param {number[]} piles\\n * @return {number}\\n */\\nvar stoneGameII = function (piles) {\\n  const n = piles.length;\\n  const dp = Array.from(Array(n + 1), () => Array(2 * (n + 1)).fill(0));\\n  let sumTilEnd = 0, minOpponent;\\n\\n  for (let i = n - 1; i >= 0; i--) {\\n    sumTilEnd += piles[i];\\n    for (let m = 1; m <= n; m++) {\\n      if (i + 2 * m >= n) {\\n        dp[i][m] = sumTilEnd;\\n        continue;\\n      }\\n\\n      minOpponent = dp[i + 1][m];\\n\\n      for (let x = 2; x <= 2 * m; x++) {\\n        minOpponent = Math.min(minOpponent, dp[i + x][Math.max(m, x)]);\\n      }\\n\\n      dp[i][m] = sumTilEnd - minOpponent;\\n    }\\n  }\\n\\n  return dp[0][1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} piles\\n * @return {number}\\n */\\nvar stoneGameII = function (piles) {\\n  const n = piles.length;\\n  const dp = Array.from(Array(n + 1), () => Array(2 * (n + 1)).fill(0));\\n  let sumTilEnd = 0, minOpponent;\\n\\n  for (let i = n - 1; i >= 0; i--) {\\n    sumTilEnd += piles[i];\\n    for (let m = 1; m <= n; m++) {\\n      if (i + 2 * m >= n) {\\n        dp[i][m] = sumTilEnd;\\n        continue;\\n      }\\n\\n      minOpponent = dp[i + 1][m];\\n\\n      for (let x = 2; x <= 2 * m; x++) {\\n        minOpponent = Math.min(minOpponent, dp[i + x][Math.max(m, x)]);\\n      }\\n\\n      dp[i][m] = sumTilEnd - minOpponent;\\n    }\\n  }\\n\\n  return dp[0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564194,
                "title": "rust-dp-total-sum-first",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![Stone_Game_Two.png](https://assets.leetcode.com/users/images/f2e09f25-54ee-423c-b28d-a8865ea5ff7c_1685090280.7729952.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn stone_game_ii(piles: Vec<i32>) -> i32 {\\n        fn get_max_at_index_with_m(\\n            sums: &Vec<i32>,\\n            m: usize,\\n            start_index: usize,\\n            store: &mut HashMap<(usize, usize), i32>,\\n        ) -> i32 {\\n            if start_index >= sums.len() {\\n                return 0;\\n            }\\n            let max_take = (2 * m) as usize;\\n            let max_take = (sums.len() - start_index).min(max_take);\\n            if let Some(&value) = store.get(&(max_take, start_index)) {\\n                return value;\\n            } else {\\n                let total_sum = sums[start_index];\\n                let min_next_turn = (1..=max_take)\\n                    .map(|take| {\\n                        get_max_at_index_with_m(sums, take.max(m), start_index + take, store)\\n                    })\\n                    .min()\\n                    .unwrap_or_default();\\n                let value = total_sum - min_next_turn;\\n                \\n                store.insert((max_take, start_index), value);\\n                value\\n            }\\n        }\\n        let last = piles[piles.len() - 1];\\n        let sum_i = (0..piles.len() - 1)\\n            .rev()\\n            .fold(vec![last; piles.len()], |mut sums, index| {\\n                sums[index] = sums[index + 1] + piles[index];\\n                sums\\n            });\\n        get_max_at_index_with_m(\\n            &sum_i,\\n            1,\\n            0,\\n            &mut HashMap::with_capacity(piles.len().pow(2)),\\n        )\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn stone_game_ii(piles: Vec<i32>) -> i32 {\\n        fn get_max_at_index_with_m(\\n            sums: &Vec<i32>,\\n            m: usize,\\n            start_index: usize,\\n            store: &mut HashMap<(usize, usize), i32>,\\n        ) -> i32 {\\n            if start_index >= sums.len() {\\n                return 0;\\n            }\\n            let max_take = (2 * m) as usize;\\n            let max_take = (sums.len() - start_index).min(max_take);\\n            if let Some(&value) = store.get(&(max_take, start_index)) {\\n                return value;\\n            } else {\\n                let total_sum = sums[start_index];\\n                let min_next_turn = (1..=max_take)\\n                    .map(|take| {\\n                        get_max_at_index_with_m(sums, take.max(m), start_index + take, store)\\n                    })\\n                    .min()\\n                    .unwrap_or_default();\\n                let value = total_sum - min_next_turn;\\n                \\n                store.insert((max_take, start_index), value);\\n                value\\n            }\\n        }\\n        let last = piles[piles.len() - 1];\\n        let sum_i = (0..piles.len() - 1)\\n            .rev()\\n            .fold(vec![last; piles.len()], |mut sums, index| {\\n                sums[index] = sums[index + 1] + piles[index];\\n                sums\\n            });\\n        get_max_at_index_with_m(\\n            &sum_i,\\n            1,\\n            0,\\n            &mut HashMap::with_capacity(piles.len().pow(2)),\\n        )\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564112,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        def dp(i,m):\\n            if (i,m) in memo:\\n                return memo[(i,m)]\\n            if i>n-1:\\n                return 0\\n            ans=-sys.maxsize\\n            if n-i<2*m:\\n                ans=pre_sum[n-1]-pre_sum[i-1]\\n            else:\\n                for k in range(1,2*m+1):\\n                    ans=max(ans,pre_sum[min(i+k-1,n-1)]-pre_sum[i-1]-dp(i+k,max(m,k)))\\n                \\n            memo[(i,m)]=ans\\n            return ans\\n        memo={}\\n        n=len(piles)\\n        pre_sum={-1:0}\\n        \\n        for i,p in enumerate(piles):\\n            pre_sum[i]=p+pre_sum[i-1]\\n            \\n        max_winning_scores=dp(0,1)\\n        \\n        return (pre_sum[n-1]+max_winning_scores)//2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        def dp(i,m):\\n            if (i,m) in memo:\\n                return memo[(i,m)]\\n            if i>n-1:\\n                return 0\\n            ans=-sys.maxsize\\n            if n-i<2*m:\\n                ans=pre_sum[n-1]-pre_sum[i-1]\\n            else:\\n                for k in range(1,2*m+1):\\n                    ans=max(ans,pre_sum[min(i+k-1,n-1)]-pre_sum[i-1]-dp(i+k,max(m,k)))\\n                \\n            memo[(i,m)]=ans\\n            return ans\\n        memo={}\\n        n=len(piles)\\n        pre_sum={-1:0}\\n        \\n        for i,p in enumerate(piles):\\n            pre_sum[i]=p+pre_sum[i-1]\\n            \\n        max_winning_scores=dp(0,1)\\n        \\n        return (pre_sum[n-1]+max_winning_scores)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563933,
                "title": "1140-stone-game-ii-java",
                "content": "```\\nclass Solution {\\n    public int solve(int [] piles,int i,int trn,int m,int [][][]dp)\\n    {\\n        int n=piles.length;\\n        if(i>=n)\\n            return 0;\\n        if(dp[trn][i][m]!=0)\\n            return dp[trn][i][m];\\n        int res=trn==1?Integer.MAX_VALUE:Integer.MIN_VALUE;\\n        int scr=0;\\n        for(int x=1;x<=Math.min(2*m,n-i);x++)\\n        {\\n            scr+=piles[i+x-1];\\n            if(trn==0)\\n                res=Math.max(res,scr+solve(piles,i+x,1,Math.max(m,x),dp));\\n            else                 \\n                res=Math.min(res,solve(piles,i+x,0,Math.max(m,x),dp));        \\n        }\\n        return dp[trn][i][m]=res;\\n    }\\n    public int stoneGameII(int[] piles) {\\n        int [][][]dp=new int[2][piles.length+1][piles.length+1];\\n        return solve(piles,0,0,1,dp);\\n    }\\n}```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(int [] piles,int i,int trn,int m,int [][][]dp)\\n    {\\n        int n=piles.length;\\n        if(i>=n)\\n            return 0;\\n        if(dp[trn][i][m]!=0)\\n            return dp[trn][i][m];\\n        int res=trn==1?Integer.MAX_VALUE:Integer.MIN_VALUE;\\n        int scr=0;\\n        for(int x=1;x<=Math.min(2*m,n-i);x++)\\n        {\\n            scr+=piles[i+x-1];\\n            if(trn==0)\\n                res=Math.max(res,scr+solve(piles,i+x,1,Math.max(m,x),dp));\\n            else                 \\n                res=Math.min(res,solve(piles,i+x,0,Math.max(m,x),dp));        \\n        }\\n        return dp[trn][i][m]=res;\\n    }\\n    public int stoneGameII(int[] piles) {\\n        int [][][]dp=new int[2][piles.length+1][piles.length+1];\\n        return solve(piles,0,0,1,dp);\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3563904,
                "title": "c-code",
                "content": "# Intuition\\n1. Find Min difference between alice and bob piles. And the diff.should be maximised.\\n2. As we got a - b and we can directly get a + b by sum all the piles.\\n3. Now we can find ((a-b)+(a+b))/2 = a. \\n4. As we have maximed the diff that is a-b so for that a should be maximum and also bob also play optimally.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int rec(vector<int> &p, int i, int m){\\n      if(i>= p.size()) return 0;\\n      if(dp[i][m]!=-1) return dp[i][m];\\n      int ans = INT_MIN;\\n      int sum = 0;\\n      for(int j=0; j<2*m; j++){\\n        if(i+j<p.size()){\\n          sum += p[i+j];\\n          ans = max(ans, sum-rec(p, i+j+1, max(m,j+1)));\\n        }\\n      }\\n      return dp[i][m] = ans;\\n    }    \\n    int stoneGameII(vector<int>& p) {\\n      memset(dp,-1,sizeof(dp));\\n      int diff =  rec(p, 0, 1);\\n      int sum = 0;\\n      for(int i=0; i<p.size(); i++) sum+= p[i];\\n      return (sum+diff)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int rec(vector<int> &p, int i, int m){\\n      if(i>= p.size()) return 0;\\n      if(dp[i][m]!=-1) return dp[i][m];\\n      int ans = INT_MIN;\\n      int sum = 0;\\n      for(int j=0; j<2*m; j++){\\n        if(i+j<p.size()){\\n          sum += p[i+j];\\n          ans = max(ans, sum-rec(p, i+j+1, max(m,j+1)));\\n        }\\n      }\\n      return dp[i][m] = ans;\\n    }    \\n    int stoneGameII(vector<int>& p) {\\n      memset(dp,-1,sizeof(dp));\\n      int diff =  rec(p, 0, 1);\\n      int sum = 0;\\n      for(int i=0; i<p.size(); i++) sum+= p[i];\\n      return (sum+diff)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563878,
                "title": "beating-84-33-python-easy-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/d3131b98-7823-4803-8845-b039fce14980_1685079502.8840265.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        @lru_cache(None)\\n        def play(i, m):\\n            s = sum(piles[i:])\\n            if i + 2 * m >= len(piles):\\n                return s\\n            return s - min(play(i + x, max(m, x)) for x in range(1, 2 * m + 1))\\n        return play(0, 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        @lru_cache(None)\\n        def play(i, m):\\n            s = sum(piles[i:])\\n            if i + 2 * m >= len(piles):\\n                return s\\n            return s - min(play(i + x, max(m, x)) for x in range(1, 2 * m + 1))\\n        return play(0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563854,
                "title": "beating-100-java-easy-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/b4529954-716a-4f2b-901f-1f8d1a6737a7_1685079218.3226051.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        int[] prefixSum = new int[n];\\n        prefixSum[n - 1] = piles[n - 1];\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            prefixSum[i] = prefixSum[i + 1] + piles[i];\\n        }\\n        \\n        int[][] memo = new int[n][n];\\n        for (int[] row : memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return dfs(piles, prefixSum, memo, 0, 1);\\n    }\\n     private int dfs(int[] piles, int[] prefixSum, int[][] memo, int i, int M) {\\n        if (i == piles.length) {\\n            return 0;\\n        }\\n        \\n        if (2 * M >= piles.length - i) {\\n            return prefixSum[i];\\n        }\\n        \\n        if (memo[i][M] != -1) {\\n            return memo[i][M];\\n        }\\n        \\n        int maxStones = 0;\\n        for (int x = 1; x <= 2 * M; x++) {\\n            int remainingStones = prefixSum[i] - dfs(piles, prefixSum, memo, i + x, Math.max(M, x));\\n            maxStones = Math.max(maxStones, remainingStones);\\n        }\\n        \\n        memo[i][M] = maxStones;\\n        return maxStones;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        int[] prefixSum = new int[n];\\n        prefixSum[n - 1] = piles[n - 1];\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            prefixSum[i] = prefixSum[i + 1] + piles[i];\\n        }\\n        \\n        int[][] memo = new int[n][n];\\n        for (int[] row : memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return dfs(piles, prefixSum, memo, 0, 1);\\n    }\\n     private int dfs(int[] piles, int[] prefixSum, int[][] memo, int i, int M) {\\n        if (i == piles.length) {\\n            return 0;\\n        }\\n        \\n        if (2 * M >= piles.length - i) {\\n            return prefixSum[i];\\n        }\\n        \\n        if (memo[i][M] != -1) {\\n            return memo[i][M];\\n        }\\n        \\n        int maxStones = 0;\\n        for (int x = 1; x <= 2 * M; x++) {\\n            int remainingStones = prefixSum[i] - dfs(piles, prefixSum, memo, i + x, Math.max(M, x));\\n            maxStones = Math.max(maxStones, remainingStones);\\n        }\\n        \\n        memo[i][M] = maxStones;\\n        return maxStones;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563639,
                "title": "simple-intuitive-solution",
                "content": "# Intuition\\n\\nWe need to maximise both player\\'s score as they are playing optimally but we need to see what is the max that we can return for alice.\\n\\nWe write a recursive function which gets the maximum value if it is current turn of alice and tries to minimise what is left after the second person is done with their turn. \\n\\nHence we compute minimum of the remaining what\\'s left during bob\\'s turn and max when it\\'s alice turn.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        @cache\\n        def calc(i, m, turn):\\n            if i >= len(piles):\\n                return 0\\n            ans = 0 if turn else float(\\'inf\\')\\n            curr = 0\\n            for j in range(i, min(i+2*m, len(piles))):\\n                if turn:\\n                    curr += piles[j]\\n                    ans = max(ans, calc(j+1, max(m, j-i+1), not turn)+curr)\\n                else:\\n                    ans = min(ans, calc(j+1, max(m, j-i+1), not turn))\\n            \\n            return ans\\n\\n        return calc(0, 1, True)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        @cache\\n        def calc(i, m, turn):\\n            if i >= len(piles):\\n                return 0\\n            ans = 0 if turn else float(\\'inf\\')\\n            curr = 0\\n            for j in range(i, min(i+2*m, len(piles))):\\n                if turn:\\n                    curr += piles[j]\\n                    ans = max(ans, calc(j+1, max(m, j-i+1), not turn)+curr)\\n                else:\\n                    ans = min(ans, calc(j+1, max(m, j-i+1), not turn))\\n            \\n            return ans\\n\\n        return calc(0, 1, True)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563625,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& a) \\n    {\\n        int dp[101][101]; \\n        int sum[101];\\n        int n = a.size(); memset(dp, 0, sizeof(dp)); memset(sum, 0, sizeof(sum));\\n        sum[n - 1] = a[n - 1]; \\n        for(int i = n - 2; i >= 0; i--) sum[i] = a[i] + sum[i + 1];\\n        for(int i = n - 1; i >= 0; i--)\\n         {\\n            for(int m = 1; m <= n; m++) \\n            {\\n                if(i + 2*m >= n) dp[i][m] = sum[i];\\n                else \\n                {\\n                    for(int x = 1; x <= 2*m; x++) dp[i][m] = max(dp[i][m], sum[i] - dp[i + x][max(m, x)]);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& a) \\n    {\\n        int dp[101][101]; \\n        int sum[101];\\n        int n = a.size(); memset(dp, 0, sizeof(dp)); memset(sum, 0, sizeof(sum));\\n        sum[n - 1] = a[n - 1]; \\n        for(int i = n - 2; i >= 0; i--) sum[i] = a[i] + sum[i + 1];\\n        for(int i = n - 1; i >= 0; i--)\\n         {\\n            for(int m = 1; m <= n; m++) \\n            {\\n                if(i + 2*m >= n) dp[i][m] = sum[i];\\n                else \\n                {\\n                    for(int x = 1; x <= 2*m; x++) dp[i][m] = max(dp[i][m], sum[i] - dp[i + x][max(m, x)]);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563519,
                "title": "c-topdown-dp-minimax-kind-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[101][(int)1e4 + 1];\\n    int suffSum[101];\\n    int totalPiles;\\n    int solve(int idx, int M) {\\n        if(idx >= totalPiles) { // all piles already covered\\n            return 0;\\n        }\\n        if(2 * M >= totalPiles - idx) {\\n            return suffSum[idx]; // it would be most optimal for current player to pick all remaining piles\\n        }\\n        if(dp[idx][M] != -1) {\\n            return dp[idx][M];\\n        }\\n\\n        int mn = INT_MAX; // pick min stones possible for the other player\\n        for(int x = 1; x <= 2 * M; x++) {\\n            mn = min(mn, solve(idx + x, max(x, M)));\\n        }\\n        return dp[idx][M] = suffSum[idx] - mn;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof(dp));\\n        memset(suffSum, 0, sizeof(suffSum));\\n        int n = piles.size();\\n        totalPiles = n;\\n        suffSum[n - 1] = piles[n - 1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            suffSum[i] = suffSum[i + 1] + piles[i];\\n        }\\n        return solve(0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[101][(int)1e4 + 1];\\n    int suffSum[101];\\n    int totalPiles;\\n    int solve(int idx, int M) {\\n        if(idx >= totalPiles) { // all piles already covered\\n            return 0;\\n        }\\n        if(2 * M >= totalPiles - idx) {\\n            return suffSum[idx]; // it would be most optimal for current player to pick all remaining piles\\n        }\\n        if(dp[idx][M] != -1) {\\n            return dp[idx][M];\\n        }\\n\\n        int mn = INT_MAX; // pick min stones possible for the other player\\n        for(int x = 1; x <= 2 * M; x++) {\\n            mn = min(mn, solve(idx + x, max(x, M)));\\n        }\\n        return dp[idx][M] = suffSum[idx] - mn;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof(dp));\\n        memset(suffSum, 0, sizeof(suffSum));\\n        int n = piles.size();\\n        totalPiles = n;\\n        suffSum[n - 1] = piles[n - 1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            suffSum[i] = suffSum[i + 1] + piles[i];\\n        }\\n        return solve(0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563493,
                "title": "very-efficient-optimized-javascript-solution-using-dynamic-programming",
                "content": "\\n# JavaScript Code\\n```\\n/**\\n * @param {number[]} piles\\n * @return {number}\\n */\\nvar stoneGameII = function(piles) {\\n  const length = piles.length;\\n  const dp = [...Array(length + 1).fill(null)].map((_) =>\\n    Array(length + 1).fill(0)\\n  );\\n  const sufsum = new Array(length + 1).fill(0);\\n  for (let i = length - 1; i >= 0; i--) {\\n    sufsum[i] = sufsum[i + 1] + piles[i];\\n  }\\n  for (let i = 0; i <= length; i++) {\\n    dp[i][length] = sufsum[i];\\n  }\\n  for (let i = length - 1; i >= 0; i--) {\\n    for (let j = length - 1; j >= 1; j--) {\\n      for (let X = 1; X <= 2 * j && i + X <= length; X++) {\\n        dp[i][j] = Math.max(dp[i][j], sufsum[i] - dp[i + X][Math.max(j, X)]);\\n      }\\n    }\\n  }\\n  return dp[0][1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} piles\\n * @return {number}\\n */\\nvar stoneGameII = function(piles) {\\n  const length = piles.length;\\n  const dp = [...Array(length + 1).fill(null)].map((_) =>\\n    Array(length + 1).fill(0)\\n  );\\n  const sufsum = new Array(length + 1).fill(0);\\n  for (let i = length - 1; i >= 0; i--) {\\n    sufsum[i] = sufsum[i + 1] + piles[i];\\n  }\\n  for (let i = 0; i <= length; i++) {\\n    dp[i][length] = sufsum[i];\\n  }\\n  for (let i = length - 1; i >= 0; i--) {\\n    for (let j = length - 1; j >= 1; j--) {\\n      for (let X = 1; X <= 2 * j && i + X <= length; X++) {\\n        dp[i][j] = Math.max(dp[i][j], sufsum[i] - dp[i + X][Math.max(j, X)]);\\n      }\\n    }\\n  }\\n  return dp[0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3137825,
                "title": "c-stone-game-memo-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSecond player work is just to reduce the sum of the first player \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][203][2];\\n    int helper(int node , int player ,  int M , vector<int>&piles)\\n    { \\n        int ans = INT_MIN;\\n        if(node >= piles.size()) return 0;\\n        else if(dp[node][M][player]!=-1) return dp[node][M][player];\\n        if(player)\\n        {\\n            int take = 0;\\n            for(int i = node ; i < node + 2 * M and i < piles.size(); i++ )\\n            {\\n                take += piles[i];\\n                ans = max(ans , take + helper(i+1 , !player , max(M , i-node + 1) , piles)); \\n            }\\n        }\\n        else\\n        {\\n            int take = 0;\\n            ans = INT_MAX;\\n            for(int i = node ; i < node + 2 * M and i < piles.size(); i++ )\\n            {\\n                ans = min (ans , helper(i + 1 , !player , max(M , i - node + 1 ) , piles ) );\\n            }\\n        }\\n        return dp[node][M][player] =  ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp , -1 , sizeof(dp));\\n        return helper(0 , true , 1 , piles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][203][2];\\n    int helper(int node , int player ,  int M , vector<int>&piles)\\n    { \\n        int ans = INT_MIN;\\n        if(node >= piles.size()) return 0;\\n        else if(dp[node][M][player]!=-1) return dp[node][M][player];\\n        if(player)\\n        {\\n            int take = 0;\\n            for(int i = node ; i < node + 2 * M and i < piles.size(); i++ )\\n            {\\n                take += piles[i];\\n                ans = max(ans , take + helper(i+1 , !player , max(M , i-node + 1) , piles)); \\n            }\\n        }\\n        else\\n        {\\n            int take = 0;\\n            ans = INT_MAX;\\n            for(int i = node ; i < node + 2 * M and i < piles.size(); i++ )\\n            {\\n                ans = min (ans , helper(i + 1 , !player , max(M , i - node + 1 ) , piles ) );\\n            }\\n        }\\n        return dp[node][M][player] =  ans;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp , -1 , sizeof(dp));\\n        return helper(0 , true , 1 , piles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916053,
                "title": "c",
                "content": "```\\nint stoneGameII(int* piles, int pilesSize){\\n    int n = pilesSize;\\n    int* sum = malloc((n + 1) * sizeof(int));\\n    int** dp = malloc((n+1) * sizeof(int*));\\n    for(int i = 0; i <= n; i++){\\n        dp[i] = calloc(n + 1 , sizeof(int));\\n    }\\n    sum[n] = 0;\\n    for(int i =  n-1; i >=0; i--){\\n        sum[i] = sum[i+1] + piles[i];\\n    }\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][n] = sum[i];\\n    }\\n    for (int i = n - 1; i >= 0; i--) {\\n        for (int m = n - 1; m >= 1; m--) {\\n            for (int x = 1; x <= 2 * m && i + x <= n; ++x) {\\n                dp[i][m] = fmax(dp[i][m], sum[i] - dp[i + x][(int)fmax(m, x)]);\\n            }\\n        }\\n    }\\n    int ans = dp[0][1];\\n    //free memory\\n    for(int i = 0; i <= n; i++){\\n        free(dp[i]);\\n    }\\n    free(dp);\\n    free(sum);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint stoneGameII(int* piles, int pilesSize){\\n    int n = pilesSize;\\n    int* sum = malloc((n + 1) * sizeof(int));\\n    int** dp = malloc((n+1) * sizeof(int*));\\n    for(int i = 0; i <= n; i++){\\n        dp[i] = calloc(n + 1 , sizeof(int));\\n    }\\n    sum[n] = 0;\\n    for(int i =  n-1; i >=0; i--){\\n        sum[i] = sum[i+1] + piles[i];\\n    }\\n    for (int i = 0; i < n; ++i) {\\n        dp[i][n] = sum[i];\\n    }\\n    for (int i = n - 1; i >= 0; i--) {\\n        for (int m = n - 1; m >= 1; m--) {\\n            for (int x = 1; x <= 2 * m && i + x <= n; ++x) {\\n                dp[i][m] = fmax(dp[i][m], sum[i] - dp[i + x][(int)fmax(m, x)]);\\n            }\\n        }\\n    }\\n    int ans = dp[0][1];\\n    //free memory\\n    for(int i = 0; i <= n; i++){\\n        free(dp[i]);\\n    }\\n    free(dp);\\n    free(sum);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2450272,
                "title": "c-using-dp-memoization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>prefix;\\n    vector<vector<vector<int>>>dp;\\n    int stoneGameII(vector<int>& piles) \\n    {   \\n        dp.resize(piles.size(),vector<vector<int>>(3,vector<int>(202,-1)));\\n        \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            if(prefix.size()==0)\\n            {\\n               prefix.push_back(piles[i]);\\n            }\\n            else\\n            {\\n                prefix.push_back(piles[i]+prefix[prefix.size()-1]);\\n            }\\n        }\\n        \\n        int idx=0;\\n        int turn=1;     //for keeping the track of the player bw the alice and bob alice->1 bob->2\\n        int m=1;\\n        \\n        return fun(piles,idx,turn,m);\\n    }\\n    int fun(vector<int>&piles,int idx,int turn,int m)\\n    {\\n       \\n        if(idx>=piles.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx][turn][m]!=-1)\\n        {\\n            return dp[idx][turn][m];\\n        }\\n        //if the alice has the turn \\n        if(turn==1)\\n        {\\n            int ans=INT_MIN;\\n            int sum=0;\\n            \\n            for(int i=0;i<(2*m);i++)\\n            {\\n                if(idx+i<(piles.size()))\\n                {\\n                    sum=sum+piles[idx+i];\\n                    \\n                    int totalsum=prefix[prefix.size()-1]-prefix[idx+i];\\n                    int x=fun(piles,idx+i+1,2,max(m,i+1));   //this will give the ans of the max bob       \\n                     \\n                    ans=max(ans,sum+(totalsum-x));\\n                }\\n            }\\n            return dp[idx][turn][m]=ans;\\n        }\\n        else if(turn==2)   //if the bob has the turn\\n        {\\n           int ans=INT_MIN;\\n           int sum=0;\\n           \\n            for(int i=0;i<(2*m) ;i++)\\n            {\\n                if(idx+i<(piles.size()))\\n                {\\n                    sum=sum+piles[idx+i];\\n                    \\n                    int totalsum=prefix[prefix.size()-1]-prefix[idx+i];\\n                    int x=fun(piles,idx+i+1,1,max(m,i+1));   //this will give the ans of the max bob       \\n                    \\n                    ans=max(ans,sum+(totalsum-x));\\n                }\\n            }\\n            return dp[idx][turn][m]=ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>prefix;\\n    vector<vector<vector<int>>>dp;\\n    int stoneGameII(vector<int>& piles) \\n    {   \\n        dp.resize(piles.size(),vector<vector<int>>(3,vector<int>(202,-1)));\\n        \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            if(prefix.size()==0)\\n            {\\n               prefix.push_back(piles[i]);\\n            }\\n            else\\n            {\\n                prefix.push_back(piles[i]+prefix[prefix.size()-1]);\\n            }\\n        }\\n        \\n        int idx=0;\\n        int turn=1;     //for keeping the track of the player bw the alice and bob alice->1 bob->2\\n        int m=1;\\n        \\n        return fun(piles,idx,turn,m);\\n    }\\n    int fun(vector<int>&piles,int idx,int turn,int m)\\n    {\\n       \\n        if(idx>=piles.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx][turn][m]!=-1)\\n        {\\n            return dp[idx][turn][m];\\n        }\\n        //if the alice has the turn \\n        if(turn==1)\\n        {\\n            int ans=INT_MIN;\\n            int sum=0;\\n            \\n            for(int i=0;i<(2*m);i++)\\n            {\\n                if(idx+i<(piles.size()))\\n                {\\n                    sum=sum+piles[idx+i];\\n                    \\n                    int totalsum=prefix[prefix.size()-1]-prefix[idx+i];\\n                    int x=fun(piles,idx+i+1,2,max(m,i+1));   //this will give the ans of the max bob       \\n                     \\n                    ans=max(ans,sum+(totalsum-x));\\n                }\\n            }\\n            return dp[idx][turn][m]=ans;\\n        }\\n        else if(turn==2)   //if the bob has the turn\\n        {\\n           int ans=INT_MIN;\\n           int sum=0;\\n           \\n            for(int i=0;i<(2*m) ;i++)\\n            {\\n                if(idx+i<(piles.size()))\\n                {\\n                    sum=sum+piles[idx+i];\\n                    \\n                    int totalsum=prefix[prefix.size()-1]-prefix[idx+i];\\n                    int x=fun(piles,idx+i+1,1,max(m,i+1));   //this will give the ans of the max bob       \\n                    \\n                    ans=max(ans,sum+(totalsum-x));\\n                }\\n            }\\n            return dp[idx][turn][m]=ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341323,
                "title": "java-top-down-memo-easy-to-understand",
                "content": "```\\n/*\\n Ex array =      2,  7,  9,  4, 4 \\n postSum Array = 26, 24, 17, 8, 4\\n We get the difference of maximum each player can get. i.e., res = max(Alice) - max(Bob) from the \\n recursive function.\\n we have the sum of max(Alice) + max(Bob) on postSum[0] which is sum of all the stones.\\n equations:  x+y = t; x-y = k; 2x = t+k; x = (t+k)/2; here t is postSum[0], k is res, x and y are \\n max(Alice) and max(Bob).\\n*/\\n\\t\\t\\nclass Solution {\\n\\n    public int stoneGameII(int[] piles) {\\n\\n        int[] postSum = new int[piles.length];\\n        Map<String,Integer> cache = new HashMap();\\n        \\n        //Calculate postFix sum\\n        postSum[piles.length-1] = piles[piles.length-1];\\n        for(int i=piles.length-2;i>=0;i--){\\n            postSum[i] = postSum[i+1]+piles[i];\\n        }\\n        \\n        int res = maxPiles(piles,0,1,postSum, cache);\\n        \\n        return (res+postSum[0])/2;\\n    }\\n    \\n\\n    private int maxPiles(int[] piles, int start, int m, int[] postSum, Map<String,Integer> cache){\\n        /*\\n            Say we have 3 stones left, but the player could pick 8 in that round, he would obviously choose all \\n            3 to maximise his score. \\n            So here range is number of stones left and x is the number of stones he can pick in this round. \\n        */\\n        if(cache.containsKey(start+\",\"+m))\\n            return cache.get(start+\",\"+m);\\n        int x = 2*m;\\n        int range = piles.length-start;\\n        if(range<=x){\\n             return postSum[start];   \\n        }\\n        \\n        /*\\n            important we CANNOT assign 0 to res because the difference of max(Alice) and max(Bob) can be a \\n            negative value.\\n        */\\n        int res = Integer.MIN_VALUE;\\n        \\n        //loop through the possible choice of (stones to pick) and maximise the chances of winning for either \\n        //player.\\n        for(int i=1;i<=x;i++){\\n            int sum = postSum[start] - postSum[start+i];\\n            res = Math.max(res, sum - maxPiles(piles, start+i, Math.max(i,m), postSum, cache));\\n        }\\n        cache.put(start+\",\"+m,res);\\n        return cache.get(start+\",\"+m);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int stoneGameII(int[] piles) {\\n\\n        int[] postSum = new int[piles.length];\\n        Map<String,Integer> cache = new HashMap();\\n        \\n        //Calculate postFix sum\\n        postSum[piles.length-1] = piles[piles.length-1];\\n        for(int i=piles.length-2;i>=0;i--){\\n            postSum[i] = postSum[i+1]+piles[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2271889,
                "title": "c-dp-memoization-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[100][100]; \\n    int sum[100];\\n    \\n    int f(int i, int m, vector<int> &a) {\\n        if(i == n - 1) return a[i];\\n        if(i == n) return 0;\\n        \\n        if(i + 2*m >= n) dp[i][m] = sum[i];\\n        if(dp[i][m] != -1) return dp[i][m];\\n        \\n        int ans = 0;\\n        for(int j = i; j < min(i + 2*m, n); j++) {\\n            ans = max(ans, sum[i] - f(j + 1, max(m, j - i + 1), a));\\n        }\\n        return dp[i][m] = ans;\\n    }\\n    int stoneGameII(vector<int>& a) {\\n        n = a.size(); memset(dp, -1, sizeof(dp)); memset(sum, 0, sizeof(sum));\\n        sum[n - 1] = a[n - 1]; \\n        \\n        for(int i = n - 2; i >= 0; i--) sum[i] = a[i] + sum[i + 1];\\n        return f(0, 1, a);\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& a) {\\n        \\n        int dp[101][101]; \\n        int sum[101];\\n        int n = a.size(); memset(dp, 0, sizeof(dp)); memset(sum, 0, sizeof(sum));\\n        sum[n - 1] = a[n - 1]; \\n        \\n        for(int i = n - 2; i >= 0; i--) sum[i] = a[i] + sum[i + 1];\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int m = 1; m <= n; m++) {\\n                if(i + 2*m >= n) dp[i][m] = sum[i];\\n                else {\\n                    for(int x = 1; x <= 2*m; x++) dp[i][m] = max(dp[i][m], sum[i] - dp[i + x][max(m, x)]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[100][100]; \\n    int sum[100];\\n    \\n    int f(int i, int m, vector<int> &a) {\\n        if(i == n - 1) return a[i];\\n        if(i == n) return 0;\\n        \\n        if(i + 2*m >= n) dp[i][m] = sum[i];\\n        if(dp[i][m] != -1) return dp[i][m];\\n        \\n        int ans = 0;\\n        for(int j = i; j < min(i + 2*m, n); j++) {\\n            ans = max(ans, sum[i] - f(j + 1, max(m, j - i + 1), a));\\n        }\\n        return dp[i][m] = ans;\\n    }\\n    int stoneGameII(vector<int>& a) {\\n        n = a.size(); memset(dp, -1, sizeof(dp)); memset(sum, 0, sizeof(sum));\\n        sum[n - 1] = a[n - 1]; \\n        \\n        for(int i = n - 2; i >= 0; i--) sum[i] = a[i] + sum[i + 1];\\n        return f(0, 1, a);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& a) {\\n        \\n        int dp[101][101]; \\n        int sum[101];\\n        int n = a.size(); memset(dp, 0, sizeof(dp)); memset(sum, 0, sizeof(sum));\\n        sum[n - 1] = a[n - 1]; \\n        \\n        for(int i = n - 2; i >= 0; i--) sum[i] = a[i] + sum[i + 1];\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int m = 1; m <= n; m++) {\\n                if(i + 2*m >= n) dp[i][m] = sum[i];\\n                else {\\n                    for(int x = 1; x <= 2*m; x++) dp[i][m] = max(dp[i][m], sum[i] - dp[i + x][max(m, x)]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939251,
                "title": "c-easy-to-understand-efficient-code-by-soujash-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& piles,int i,int m,int sum,vector<vector<int>> &memo)\\n    {\\n        int n=piles.size();\\n        if(i>=n) return 0;\\n        if(memo[i][m]!=-1)\\n        return memo[i][m];\\n        int res=0;\\n        int currsum=0;\\n        for(int x=1;x<=2*m;x++)\\n        {\\n            if(i+x>n) break;\\n            currsum+=piles[i+x-1];\\n            res=max(res,sum-fun(piles,i+x,max(x,m),sum-currsum,memo));\\n        }\\n        return memo[i][m]=res;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n=piles.size();\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        vector<vector<int>> memo(n+1,vector<int>(n+1,-1));\\n        return fun(piles,0,1,sum,memo);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& piles,int i,int m,int sum,vector<vector<int>> &memo)\\n    {\\n        int n=piles.size();\\n        if(i>=n) return 0;\\n        if(memo[i][m]!=-1)\\n        return memo[i][m];\\n        int res=0;\\n        int currsum=0;\\n        for(int x=1;x<=2*m;x++)\\n        {\\n            if(i+x>n) break;\\n            currsum+=piles[i+x-1];\\n            res=max(res,sum-fun(piles,i+x,max(x,m),sum-currsum,memo));\\n        }\\n        return memo[i][m]=res;\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n=piles.size();\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        vector<vector<int>> memo(n+1,vector<int>(n+1,-1));\\n        return fun(piles,0,1,sum,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716199,
                "title": "c-dp-stone-game-ii",
                "content": "\\n\\nWhen I call ```more_than_yours(..., int i, int M)```, that mean I want to get \\nthe max number of stones more than yours when index start from i and \\nthe piles I taken may  1,2,..., or 2M. \\n\\nYou can also use ```more_than_yours(...,  j,  xM)``` to figure out the maximal \\nstones your competitor can get when his index starting from j with xM.  With \\nthis knowledge, this DP can figure mximal stones I can get with starting index \\nas 0 and M=1 by calling ```more_than_yours(..., 0, 1); ```\\n\\nBy the way, ```(total + diff)/2``` can figure out the number of stones taken by \\ngame starter.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int> &piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp = vector<vector<int>>(n+1, vector<int>(n+1,0));\\n        int total = accumulate(piles.begin(), piles.end(), 0);\\n        int diff = more_than_yours(piles, dp, 0, 1); \\n        return (total + diff)/2; \\n    }\\n    \\n    int more_than_yours(vector<int> &piles, vector<vector<int>> &dp, int i, int M){\\n        M = M>piles.size()?piles.size():M;\\n        if(i >= piles.size()) return 0; \\n        if(dp[i][M] != 0) return dp[i][M]; \\n        int my_taken_in_turn = 0;\\n        int max_more_than_yours = INT_MIN; \\n        \\n        for(int X=1; X<=2*M; X++) {\\n            if(i-1+X < piles.size()) my_taken_in_turn += piles[i-1+X]; \\n            int competitor_more_than_mine = more_than_yours(piles, dp, i+X,  max(M,X));\\n            max_more_than_yours = max(max_more_than_yours, my_taken_in_turn - competitor_more_than_mine);\\n        }     \\n        return dp[i][M] = max_more_than_yours;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```more_than_yours(..., int i, int M)```\n```more_than_yours(...,  j,  xM)```\n```more_than_yours(..., 0, 1); ```\n```(total + diff)/2```\n```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int> &piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp = vector<vector<int>>(n+1, vector<int>(n+1,0));\\n        int total = accumulate(piles.begin(), piles.end(), 0);\\n        int diff = more_than_yours(piles, dp, 0, 1); \\n        return (total + diff)/2; \\n    }\\n    \\n    int more_than_yours(vector<int> &piles, vector<vector<int>> &dp, int i, int M){\\n        M = M>piles.size()?piles.size():M;\\n        if(i >= piles.size()) return 0; \\n        if(dp[i][M] != 0) return dp[i][M]; \\n        int my_taken_in_turn = 0;\\n        int max_more_than_yours = INT_MIN; \\n        \\n        for(int X=1; X<=2*M; X++) {\\n            if(i-1+X < piles.size()) my_taken_in_turn += piles[i-1+X]; \\n            int competitor_more_than_mine = more_than_yours(piles, dp, i+X,  max(M,X));\\n            max_more_than_yours = max(max_more_than_yours, my_taken_in_turn - competitor_more_than_mine);\\n        }     \\n        return dp[i][M] = max_more_than_yours;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624927,
                "title": "python-by-top-down-dp-w-comment",
                "content": "[Tutorial video in Chinese \\u4E2D\\u6587\\u8B1B\\u89E3\\u5F71\\u7247](https://www.youtube.com/watch?v=PAzJndHyCfk)\\n\\nPython by top-down DP \\n\\n---\\n\\n```class Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        \\n        # total length of piles\\n        N = len(piles)\\n\\n        # total stones of input array\\n        total_stone = sum(piles)\\n\\n        # Table\\n        # key :   index\\n        # value:  total number of stone after index i\\n        stone_after = [total_stone]\\n\\n        for i in range(1, len(piles)):\\n            stone_after.append( stone_after[-1] - piles[i-1] )\\n\\n        # DP Table\\n        # key: Game state of (start, M)\\n        # value: Max number of stone taken, from state (start, M)\\n        memo = {}\\n        def take(start, M):\\n            \\n            # Look-up DP table\\n            if (start, M) in memo:\\n                return memo[(start, M)]\\n\\n            # Start index is out of boundary, take nothing\\n            if start >= N :\\n                memo[(start, M)] = 0\\n                return 0\\n            \\n            # Coverage is big enough, take all remaining stones\\n            if start + 2*M >= N:\\n                memo[(start, M)] = stone_after[start]\\n                return stone_after[start]\\n            \\n            # Max current turn <=> Min opponent\\'s turn <=> Min next turn\\n            memo[(start, M)] = stone_after[start] - min( take(start+i, max(i, M)) for i in range(1, 2*M+1) )       \\n            return memo[(start, M)]\\n            \\n\\n        return take(start=0, M=1)\\n   \\n```\\n\\n---\\n\\nComplexity analysis:\\n```\\n# Time complexity: O( n^3 )\\n# O(n^3) = O( n^2 ) x O(n)\\n# O( n^2 ) : state (start, M)\\n# O( n )   : each state takes O(n)\\n\\n# Space complexity: O(n^2)\\n# O( n^2 ) : state (start, M)\\n# O( n )   : stone_after\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```class Solution:\\n    def stoneGameII(self, piles: List[int]) -> int:\\n        \\n        # total length of piles\\n        N = len(piles)\\n\\n        # total stones of input array\\n        total_stone = sum(piles)\\n\\n        # Table\\n        # key :   index\\n        # value:  total number of stone after index i\\n        stone_after = [total_stone]\\n\\n        for i in range(1, len(piles)):\\n            stone_after.append( stone_after[-1] - piles[i-1] )\\n\\n        # DP Table\\n        # key: Game state of (start, M)\\n        # value: Max number of stone taken, from state (start, M)\\n        memo = {}\\n        def take(start, M):\\n            \\n            # Look-up DP table\\n            if (start, M) in memo:\\n                return memo[(start, M)]\\n\\n            # Start index is out of boundary, take nothing\\n            if start >= N :\\n                memo[(start, M)] = 0\\n                return 0\\n            \\n            # Coverage is big enough, take all remaining stones\\n            if start + 2*M >= N:\\n                memo[(start, M)] = stone_after[start]\\n                return stone_after[start]\\n            \\n            # Max current turn <=> Min opponent\\'s turn <=> Min next turn\\n            memo[(start, M)] = stone_after[start] - min( take(start+i, max(i, M)) for i in range(1, 2*M+1) )       \\n            return memo[(start, M)]\\n            \\n\\n        return take(start=0, M=1)\\n   \\n```\n```\\n# Time complexity: O( n^3 )\\n# O(n^3) = O( n^2 ) x O(n)\\n# O( n^2 ) : state (start, M)\\n# O( n )   : each state takes O(n)\\n\\n# Space complexity: O(n^2)\\n# O( n^2 ) : state (start, M)\\n# O( n )   : stone_after\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598075,
                "title": "java-minimax-approach-with-explanation",
                "content": "When it is Alice\\'s turn, she wants to pick the option that maximizes her score, and when it is Bob\\'s turn, he wants to pick the option that minimizes Alice\\'s score. \\n\\nThe question asks us to find the maximum score that Alice can have, which means we have to return the `(sum of array + maximum score) / 2` . This is because, say, `A` and `B` stands for Alice\\'s score and Bob\\'s score respectively. Our approach will give us the maximum possible `A-B`, and the sum of the array is `A+B` . Hence, we have:  `(A-B) + (A+B) = 2A`. \\n\\n```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int sum = Arrays.stream(piles).sum();\\n        int[][][] dp = new int[piles.length][piles.length + 1][2];\\n        getMax(piles, 0, 1, dp, 0);\\n\\n        return (sum + dp[0][1][0]) / 2;\\n    }\\n\\n    private int getMax(int[] p, int start, int M, int[][][] dp, int myTurn){\\n        if (start >= p.length) return 0;\\n        if (dp[start][M][myTurn] != 0) return dp[start][M][myTurn];\\n\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i < Math.min(start + 2 * M, p.length); i++){\\n            int x = getMax(p, i + 1, Math.max(M, i - start + 1), dp, Math.abs(myTurn - 1));\\n            int sum = 0;\\n            for (int j = start; j <= i; j++) sum += p[j];\\n            if (myTurn == 0) max = Math.max(sum + x, max);\\n            else min = Math.min(-sum + x, min);\\n        }\\n\\n        dp[start][M][myTurn] = myTurn == 0? max : min;\\n        return dp[start][M][myTurn];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int sum = Arrays.stream(piles).sum();\\n        int[][][] dp = new int[piles.length][piles.length + 1][2];\\n        getMax(piles, 0, 1, dp, 0);\\n\\n        return (sum + dp[0][1][0]) / 2;\\n    }\\n\\n    private int getMax(int[] p, int start, int M, int[][][] dp, int myTurn){\\n        if (start >= p.length) return 0;\\n        if (dp[start][M][myTurn] != 0) return dp[start][M][myTurn];\\n\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i < Math.min(start + 2 * M, p.length); i++){\\n            int x = getMax(p, i + 1, Math.max(M, i - start + 1), dp, Math.abs(myTurn - 1));\\n            int sum = 0;\\n            for (int j = start; j <= i; j++) sum += p[j];\\n            if (myTurn == 0) max = Math.max(sum + x, max);\\n            else min = Math.min(-sum + x, min);\\n        }\\n\\n        dp[start][M][myTurn] = myTurn == 0? max : min;\\n        return dp[start][M][myTurn];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476104,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> piles, int m, int idx, bool aliceTurn, vector<vector<vector<int>>>& dp) {\\n        \\n        if(idx >= piles.size()) return 0;\\n        \\n        if(dp[idx][m][aliceTurn] != -1) return dp[idx][m][aliceTurn];\\n        \\n        if(aliceTurn) {     // When its Alice\\'s turn she will try to maximize her count of stones. \\n            int ans = 0, sum = 0;   \\n            for(int i=idx; (i-idx) < 2*m && i < piles.size(); i++) {\\n                sum += piles[i];\\n                ans = max(ans, sum + helper(piles, max((i-idx)+1, m), i+1, !aliceTurn, dp));\\n            }\\n            dp[idx][m][aliceTurn] = ans;\\n        } \\n        else {        // When its Bob\\'s turn he just makes sure Alice gets the minimum possible stones.\\n            int ans = INT_MAX;\\n            for(int i=idx;(i-idx) < 2*m && i < piles.size(); i++) {\\n                ans = min(ans, helper(piles, max((i-idx)+1, m), i+1, !aliceTurn, dp)); \\n            }\\n            dp[idx][m][aliceTurn] = ans;\\n        }\\n        \\n        return dp[idx][m][aliceTurn];\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int sz = piles.size();\\n        vector<vector<vector<int>>> dp(sz, vector<vector<int>>(2*sz, vector<int>(2, -1)));\\n        return helper(piles, 1, 0, true, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> piles, int m, int idx, bool aliceTurn, vector<vector<vector<int>>>& dp) {\\n        \\n        if(idx >= piles.size()) return 0;\\n        \\n        if(dp[idx][m][aliceTurn] != -1) return dp[idx][m][aliceTurn];\\n        \\n        if(aliceTurn) {     // When its Alice\\'s turn she will try to maximize her count of stones. \\n            int ans = 0, sum = 0;   \\n            for(int i=idx; (i-idx) < 2*m && i < piles.size(); i++) {\\n                sum += piles[i];\\n                ans = max(ans, sum + helper(piles, max((i-idx)+1, m), i+1, !aliceTurn, dp));\\n            }\\n            dp[idx][m][aliceTurn] = ans;\\n        } \\n        else {        // When its Bob\\'s turn he just makes sure Alice gets the minimum possible stones.\\n            int ans = INT_MAX;\\n            for(int i=idx;(i-idx) < 2*m && i < piles.size(); i++) {\\n                ans = min(ans, helper(piles, max((i-idx)+1, m), i+1, !aliceTurn, dp)); \\n            }\\n            dp[idx][m][aliceTurn] = ans;\\n        }\\n        \\n        return dp[idx][m][aliceTurn];\\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int sz = piles.size();\\n        vector<vector<vector<int>>> dp(sz, vector<vector<int>>(2*sz, vector<int>(2, -1)));\\n        return helper(piles, 1, 0, true, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472237,
                "title": "java-iterative-top-down-5ms-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        //find presum\\n        //my max score=presum-opponents lowest score\\n        if(piles.length==1)\\n            return piles[0];\\n        else if(piles.length==2)\\n            return piles[0]+piles[1];\\n\\t\\t\\t//arr is basically presum\\n        int [] arr=new int[piles.length];\\n        int [][] dp=new int[piles.length][piles.length];\\n        arr[arr.length-1]=piles[arr.length-1];\\n        for(int i=arr.length-2;i>=0;i--){\\n            arr[i]=piles[i]+arr[i+1];\\n        }\\n        Arrays.fill(dp[arr.length-1],piles[arr.length-1]);\\n        for(int row=arr.length-2;row>=0;row--){\\n            for(int m=1;m<arr.length;m++){\\n                int min=100000007;\\n                if(row+2*m>=arr.length){\\n                    dp[row][m]=arr[row];\\n                }else{\\n                     for(int x=1;x<=2*m && x+row<arr.length;x++){\\n                    min=Math.min(min,dp[row+x][Math.max(x,m)]);\\n                    }\\n                    dp[row][m]=arr[row]-min;\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        //find presum\\n        //my max score=presum-opponents lowest score\\n        if(piles.length==1)\\n            return piles[0];\\n        else if(piles.length==2)\\n            return piles[0]+piles[1];\\n\\t\\t\\t//arr is basically presum\\n        int [] arr=new int[piles.length];\\n        int [][] dp=new int[piles.length][piles.length];\\n        arr[arr.length-1]=piles[arr.length-1];\\n        for(int i=arr.length-2;i>=0;i--){\\n            arr[i]=piles[i]+arr[i+1];\\n        }\\n        Arrays.fill(dp[arr.length-1],piles[arr.length-1]);\\n        for(int row=arr.length-2;row>=0;row--){\\n            for(int m=1;m<arr.length;m++){\\n                int min=100000007;\\n                if(row+2*m>=arr.length){\\n                    dp[row][m]=arr[row];\\n                }else{\\n                     for(int x=1;x<=2*m && x+row<arr.length;x++){\\n                    min=Math.min(min,dp[row+x][Math.max(x,m)]);\\n                    }\\n                    dp[row][m]=arr[row]-min;\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472232,
                "title": "java-7ms-top-down-tabulation-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        //find presum\\n        //my max score=presum-opponents lowest score\\n        int [] arr=new int[piles.length];\\n        int [][] dp=new int[piles.length][piles.length];\\n        arr[arr.length-1]=piles[arr.length-1];\\n        for(int i=arr.length-2;i>=0;i--){\\n            arr[i]=piles[i]+arr[i+1];\\n        }\\n         return solve(piles,0,1,arr,dp);\\n    }\\n    public int solve(int [] arr,int idx,int m,int [] presum,int[][] dp){\\n        if(idx+2*m >= arr.length)\\n            return presum[idx];\\n        if(dp[idx][m]!=0) return dp[idx][m];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=idx;i<idx+2*m && i<arr.length;i++){\\n            min=Math.min(solve(arr,i+1,Math.max(i-idx+1,m),presum,dp),min);\\n        }\\n        dp[idx][m]=presum[idx]-min;\\n        return dp[idx][m];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        //find presum\\n        //my max score=presum-opponents lowest score\\n        int [] arr=new int[piles.length];\\n        int [][] dp=new int[piles.length][piles.length];\\n        arr[arr.length-1]=piles[arr.length-1];\\n        for(int i=arr.length-2;i>=0;i--){\\n            arr[i]=piles[i]+arr[i+1];\\n        }\\n         return solve(piles,0,1,arr,dp);\\n    }\\n    public int solve(int [] arr,int idx,int m,int [] presum,int[][] dp){\\n        if(idx+2*m >= arr.length)\\n            return presum[idx];\\n        if(dp[idx][m]!=0) return dp[idx][m];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=idx;i<idx+2*m && i<arr.length;i++){\\n            min=Math.min(solve(arr,i+1,Math.max(i-idx+1,m),presum,dp),min);\\n        }\\n        dp[idx][m]=presum[idx]-min;\\n        return dp[idx][m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432798,
                "title": "java-top-down-memoization-saikat-s-solution",
                "content": "```\\nclass Solution {\\n    public int [][] dp=new int [101][101];\\n    public int stoneGameII(int[] piles) {\\n        for(int []  dp_row : dp){\\n            Arrays.fill(dp_row,-1);\\n        }\\n        return stone(piles,piles.length,0,1);\\n        \\n        \\n    }\\n    public int stone(int [] arr,int n,int i,int M_alice){\\n        if(dp[i][M_alice]!=-1){\\n            return dp[i][M_alice];\\n            \\n        }\\n        //base case \\n        \\n        if(i==n){\\n            return 0;\\n        }\\n        //X-->1 to 2*M\\n        int X_alice=Math.min(2*M_alice,n-i),stones_alice=0,res=Integer.MIN_VALUE;\\n        for(int j=0;j<X_alice;j++){\\n            //j is the number of piles picled by alice 0-->2*m-1\\n            stones_alice+=arr[i+j];\\n            int M_bob=Math.max(M_alice,j+1);\\n            int X_bob=Math.min(2*M_bob,n-i-j-1);\\n            int later_stones_alice=Integer.MAX_VALUE;\\n            for(int k=0;k<X_bob;k++){\\n                //k --> number of piles picked by bob\\n                //Bob is trying to minimize the stones picked by alice\\n                later_stones_alice=Math.min(later_stones_alice,stone(arr,n,i+(j+1)+(k+1),Math.max(M_bob,k+1)));\\n            }\\n            if(later_stones_alice!=Integer.MAX_VALUE)\\n                res=Math.max(res,stones_alice+later_stones_alice);\\n            else \\n                res=Math.max(res,stones_alice);\\n        }\\n        dp[i][M_alice]=res;\\n        return res;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int [][] dp=new int [101][101];\\n    public int stoneGameII(int[] piles) {\\n        for(int []  dp_row : dp){\\n            Arrays.fill(dp_row,-1);\\n        }\\n        return stone(piles,piles.length,0,1);\\n        \\n        \\n    }\\n    public int stone(int [] arr,int n,int i,int M_alice){\\n        if(dp[i][M_alice]!=-1){\\n            return dp[i][M_alice];\\n            \\n        }\\n        //base case \\n        \\n        if(i==n){\\n            return 0;\\n        }\\n        //X-->1 to 2*M\\n        int X_alice=Math.min(2*M_alice,n-i),stones_alice=0,res=Integer.MIN_VALUE;\\n        for(int j=0;j<X_alice;j++){\\n            //j is the number of piles picled by alice 0-->2*m-1\\n            stones_alice+=arr[i+j];\\n            int M_bob=Math.max(M_alice,j+1);\\n            int X_bob=Math.min(2*M_bob,n-i-j-1);\\n            int later_stones_alice=Integer.MAX_VALUE;\\n            for(int k=0;k<X_bob;k++){\\n                //k --> number of piles picked by bob\\n                //Bob is trying to minimize the stones picked by alice\\n                later_stones_alice=Math.min(later_stones_alice,stone(arr,n,i+(j+1)+(k+1),Math.max(M_bob,k+1)));\\n            }\\n            if(later_stones_alice!=Integer.MAX_VALUE)\\n                res=Math.max(res,stones_alice+later_stones_alice);\\n            else \\n                res=Math.max(res,stones_alice);\\n        }\\n        dp[i][M_alice]=res;\\n        return res;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316649,
                "title": "c-intuitive-approach",
                "content": "Straightforward and simpler than other approaches as I was having trouble in visualizing the use of suffix array. The logic goes: if it is alice\\'s turn, he\\'ll try to maximize his score and if it\\'s bob\\'s turn, he\\'ll make sure to minimize the score alice gets.(since we are asked to find alics\\'s score, look at the prob with alice\\'s perspective).\\n\\nclass Solution {\\npublic:\\n    int turn =1; int n;\\n    vector<int> p;\\n    int dp[115][115][3];\\n    int solve(int m, int pos, int turn){\\n        if(pos==n) return 0;\\n        int tm=2*m;\\n        if(m>=n) m=n-1;\\n        int ans=0;\\n        if(dp[m][pos][turn]!=-1){\\n            return dp[m][pos][turn];\\n        }\\n        int res=0; int res1=INT_MAX;\\n        int pos1=pos;\\n        for(int i=1;i<=tm&&pos1<n;i++){\\n            ans+=p[pos1]; pos1++;\\n            if(turn==1){\\n                res=max(res,ans+solve(max(i,m),pos1,2));// alice maximizing his score\\n            }\\n            else{\\n                res1=min(res1,solve(max(i,m),pos1,1));// bob minimizing alice\\'s score\\n            }\\n            \\n        }\\n        return dp[m][pos][turn]=(turn==1?res:res1);// according to alice/bob\\n        \\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        p=piles;\\n        n=piles.size(); memset(dp,-1,sizeof(dp));\\n        return solve(1,0,1);\\n    }\\n};\\n\\n\\n\\nFeel free to ask incase you have a doubt;",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int turn =1; int n;\\n    vector<int> p;\\n    int dp[115][115][3];\\n    int solve(int m, int pos, int turn){\\n        if(pos==n) return 0;\\n        int tm=2*m;\\n        if(m>=n) m=n-1;\\n        int ans=0;\\n        if(dp[m][pos][turn]!=-1){\\n            return dp[m][pos][turn];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1235653,
                "title": "javascript-dp-with-explanation",
                "content": "**DP explain:**\\n```text\\n[4], alice can get 4\\n[4, 4] alcie can get 4 + 4 = 8\\ndp[i][m]: means starting at index i with m, the max score alice can get\\ndp[i][m] = max(score of taking x when 1<=x<=2m)\\n         = max (remainingSum[i:n-1] - next_bob_max_value )\\n         = max( remainingSum[i:n-1] - dp[i+x][max(x,m)] )\\n```\\n```\\nvar stoneGameII = function(piles) {\\n    var n = piles.length;\\n    var dp = new Array(n+1).fill(0).map(el=>new Array(n+1).fill(0));\\n    \\n    // sum[i]: sum from i to n-1\\n    var sum = new Array(n).fill(0);\\n    for(var i = n-1; i>=0 ; i--)\\n    {\\n        if(i == n-1) {\\n            sum[i] = piles[i];\\n        }\\n        else\\n        {\\n                sum[i] = piles[i] + sum[i+1];\\n        }\\n    }\\n    \\n    // DP\\n    for(var i=n-1;i>=0;i--)\\n    {\\n        for(var m=1;m<=n; m++)\\n        {\\n            // alice take x piles\\n            // then bob\\'s next value = dp[i+1][max(m,x)]\\n            // bob\\'s starting index: i+x\\n            // bob\\'s M = max(M,x)\\n            for(var x=1; x<=2*m && i+x<=n; x++)\\n            {\\n                dp[i][m] = Math.max(dp[i][m], sum[i]-dp[i+x][Math.max(m,x)]);\\n            }\\n        }\\n    }\\n    return dp[0][1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```text\\n[4], alice can get 4\\n[4, 4] alcie can get 4 + 4 = 8\\ndp[i][m]: means starting at index i with m, the max score alice can get\\ndp[i][m] = max(score of taking x when 1<=x<=2m)\\n         = max (remainingSum[i:n-1] - next_bob_max_value )\\n         = max( remainingSum[i:n-1] - dp[i+x][max(x,m)] )\\n```\n```\\nvar stoneGameII = function(piles) {\\n    var n = piles.length;\\n    var dp = new Array(n+1).fill(0).map(el=>new Array(n+1).fill(0));\\n    \\n    // sum[i]: sum from i to n-1\\n    var sum = new Array(n).fill(0);\\n    for(var i = n-1; i>=0 ; i--)\\n    {\\n        if(i == n-1) {\\n            sum[i] = piles[i];\\n        }\\n        else\\n        {\\n                sum[i] = piles[i] + sum[i+1];\\n        }\\n    }\\n    \\n    // DP\\n    for(var i=n-1;i>=0;i--)\\n    {\\n        for(var m=1;m<=n; m++)\\n        {\\n            // alice take x piles\\n            // then bob\\'s next value = dp[i+1][max(m,x)]\\n            // bob\\'s starting index: i+x\\n            // bob\\'s M = max(M,x)\\n            for(var x=1; x<=2*m && i+x<=n; x++)\\n            {\\n                dp[i][m] = Math.max(dp[i][m], sum[i]-dp[i+x][Math.max(m,x)]);\\n            }\\n        }\\n    }\\n    return dp[0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233448,
                "title": "dp-with-memoization-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][101][2];\\n    int recurs(vector<int>& piles,int m,int i,int c)\\n    {\\n        if(i>=piles.size())\\n        {\\n            return 0;\\n        }\\n        \\n        \\n        if(dp[m][i][c]!=-1)\\n        {\\n            return dp[m][i][c];\\n        }\\n        \\n        \\n        int ans=0,ans1=1000000,x1=0;\\n        for(int x=1;x<=2*m;x++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<x+i&&j<piles.size();j++)\\n            {\\n                sum+=piles[j];\\n            }\\n            int m1=max(x,m);\\n            if(c==0)\\n            {\\n               ans=max(recurs(piles,m1,x+i,1)+sum,ans);\\n            }\\n                 if(c==1)\\n            {\\n                 int m1=max(x,m);\\n                 ans1=min(recurs(piles,m1,x+i,0),ans1);\\n                   \\n            }\\n        }\\n        \\n          \\n       if(c==0)\\n        {\\n            return dp[m][i][c]=ans;\\n        }\\n        else\\n        {\\n            return dp[m][i][c]=ans1;\\n        }\\n          }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        \\n        \\n        for(int i=0;i<=2*piles.size();i++)\\n        {\\n            for(int j=0;j<=piles.size();j++)\\n            {\\n                dp[i][j][0]=-1;\\n                dp[i][j][1]=-1;\\n            }\\n        }\\n\\n    return recurs(piles,1,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][101][2];\\n    int recurs(vector<int>& piles,int m,int i,int c)\\n    {\\n        if(i>=piles.size())\\n        {\\n            return 0;\\n        }\\n        \\n        \\n        if(dp[m][i][c]!=-1)\\n        {\\n            return dp[m][i][c];\\n        }\\n        \\n        \\n        int ans=0,ans1=1000000,x1=0;\\n        for(int x=1;x<=2*m;x++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<x+i&&j<piles.size();j++)\\n            {\\n                sum+=piles[j];\\n            }\\n            int m1=max(x,m);\\n            if(c==0)\\n            {\\n               ans=max(recurs(piles,m1,x+i,1)+sum,ans);\\n            }\\n                 if(c==1)\\n            {\\n                 int m1=max(x,m);\\n                 ans1=min(recurs(piles,m1,x+i,0),ans1);\\n                   \\n            }\\n        }\\n        \\n          \\n       if(c==0)\\n        {\\n            return dp[m][i][c]=ans;\\n        }\\n        else\\n        {\\n            return dp[m][i][c]=ans1;\\n        }\\n          }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        \\n        \\n        for(int i=0;i<=2*piles.size();i++)\\n        {\\n            for(int j=0;j<=piles.size();j++)\\n            {\\n                dp[i][j][0]=-1;\\n                dp[i][j][1]=-1;\\n            }\\n        }\\n\\n    return recurs(piles,1,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229719,
                "title": "c-95-fast-solution-full-explanation-easy",
                "content": "In this question alice and bob have to pic the stones and alice starts first with m = 1\\n\\nTo win the game we have to **minimize the stone picked by the next player** . Both bob and alce follow this creteria to win as both plays optimally.\\n\\nNow comes the DP part\\n\\nI have maded a suffix array in which sufix[i] tells me the number of stones from i  to n - 1.\\n\\nI have maded a function which tells we from where to start (ind) and how many piles i can take (m).\\n\\n**In this i have itrated till ind + 2m (taking all passible solutions) and took the minimum one means the opponent bob will get the minimum from ind to ind + 2m this will continue for eash othet.**\\n\\nAt last we get the ans.\\n\\nAlso take cate of base conditions\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int recur(vector <int>& a,vector <int>& sufix, int ind, int m, vector < vector <int> >& dp) {\\n        if (ind == a.size()) return 0;\\n        if (ind + 2*m >= a.size()) return sufix[ind];\\n        if (dp[ind][m] != -1) return dp[ind][m];\\n        int t = INT_MAX;\\n        for (int k = ind + 1; k <= ind + 2*m; k++) {\\n            t = min(t, recur(a,sufix, k, max(m, k - ind), dp));\\n        }\\n        return dp[ind][m] = sufix[ind] - t;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector <int> sufix(n, 0);\\n        vector < vector <int> > dp(n+1, vector <int> (n+1, -1));\\n        sufix[n-1] = piles[n-1];\\n        for (int i = n - 2; i >-1; i--) {\\n            sufix[i] = sufix[i + 1] + piles[i];\\n        }\\n        return recur(piles, sufix, 0, 1, dp);\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int recur(vector <int>& a,vector <int>& sufix, int ind, int m, vector < vector <int> >& dp) {\\n        if (ind == a.size()) return 0;\\n        if (ind + 2*m >= a.size()) return sufix[ind];\\n        if (dp[ind][m] != -1) return dp[ind][m];\\n        int t = INT_MAX;\\n        for (int k = ind + 1; k <= ind + 2*m; k++) {\\n            t = min(t, recur(a,sufix, k, max(m, k - ind), dp));\\n        }\\n        return dp[ind][m] = sufix[ind] - t;\\n    }\\n    \\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        vector <int> sufix(n, 0);\\n        vector < vector <int> > dp(n+1, vector <int> (n+1, -1));\\n        sufix[n-1] = piles[n-1];\\n        for (int i = n - 2; i >-1; i--) {\\n            sufix[i] = sufix[i + 1] + piles[i];\\n        }\\n        return recur(piles, sufix, 0, 1, dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159170,
                "title": "easy-c-approach-top-down-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> DP;\\n\\t\\n    int stoneGameII(vector<int>& piles) {\\n        int n=piles.size();\\n        DP=vector<vector<vector<int>>> (n+1,vector<vector<int>>(n,vector<int>(2,-1)));\\n        return solve(piles,1,0,1);//piles, M, i, chance\\n    }\\n\\t\\n    int solve(vector<int>& piles, int M, int idx, int chance){\\n        if(idx>=piles.size()) \\n            return 0;\\n        if(DP[M][idx][chance]!=-1)\\n            return DP[M][idx][chance];\\n        if(chance==1)\\n        {\\n            int res=0,sum=0;\\n            for(int j=idx;j<idx+2*M && j<piles.size();j++)\\n            {\\n                sum+=piles[j];\\n                res=max(res,sum+solve(piles,max(M,j-idx+1),j+1,0));\\n            }\\n            return DP[M][idx][chance]=res;\\n        }\\n        else\\n        {\\n            int res=solve(piles,M,idx+1,1);\\n            for(int i=idx+1;i<idx+2*M && i<piles.size();i++)\\n            {\\n                res=min(res,solve(piles,max(M,i-idx+1),i+1,1));\\n            }\\n            return DP[M][idx][chance]=res;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> DP;\\n\\t\\n    int stoneGameII(vector<int>& piles) {\\n        int n=piles.size();\\n        DP=vector<vector<vector<int>>> (n+1,vector<vector<int>>(n,vector<int>(2,-1)));\\n        return solve(piles,1,0,1);//piles, M, i, chance\\n    }\\n\\t\\n    int solve(vector<int>& piles, int M, int idx, int chance){\\n        if(idx>=piles.size()) \\n            return 0;\\n        if(DP[M][idx][chance]!=-1)\\n            return DP[M][idx][chance];\\n        if(chance==1)\\n        {\\n            int res=0,sum=0;\\n            for(int j=idx;j<idx+2*M && j<piles.size();j++)\\n            {\\n                sum+=piles[j];\\n                res=max(res,sum+solve(piles,max(M,j-idx+1),j+1,0));\\n            }\\n            return DP[M][idx][chance]=res;\\n        }\\n        else\\n        {\\n            int res=solve(piles,M,idx+1,1);\\n            for(int i=idx+1;i<idx+2*M && i<piles.size();i++)\\n            {\\n                res=min(res,solve(piles,max(M,i-idx+1),i+1,1));\\n            }\\n            return DP[M][idx][chance]=res;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127440,
                "title": "python-recursive-easy-to-understand",
                "content": "\\t\\t@functools.lru_cache(None)\\n        def rec(player, index, m):\\n            \\n            if index >= len(piles):\\n                return 0 \\n\\n            if player == 1:\\n                player1 = 0 \\n                for i in range(1, m*2+1):\\n                    player1 = max(player1 , sum(piles[index:index +i]) + rec(2, index+i, max(m,i)) )\\n                \\n                return player1 \\n            \\n            elif player == 2:\\n                player2 = float(\\'INF\\') \\n                for i in range(1, m*2+1):\\n                    player2 = min(player2 , rec(1, index+i, max(m,i)) )\\n                \\n                return player2\\n        \\n        \\n        return rec(1, 0,1)",
                "solutionTags": [],
                "code": "\\t\\t@functools.lru_cache(None)\\n        def rec(player, index, m):\\n            \\n            if index >= len(piles):\\n                return 0 \\n\\n            if player == 1:\\n                player1 = 0 \\n                for i in range(1, m*2+1):\\n                    player1 = max(player1 , sum(piles[index:index +i]) + rec(2, index+i, max(m,i)) )\\n                \\n                return player1 \\n            \\n            elif player == 2:\\n                player2 = float(\\'INF\\') \\n                for i in range(1, m*2+1):\\n                    player2 = min(player2 , rec(1, index+i, max(m,i)) )\\n                \\n                return player2\\n        \\n        \\n        return rec(1, 0,1)",
                "codeTag": "Python3"
            },
            {
                "id": 1093083,
                "title": "java-solutiono-n3-using-dp",
                "content": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int n= piles.length;\\n        int [][]dp = new int [n+1][n+1];\\n        int [] sum = new int [n+1];\\n        for(int i = n-1;i>=0;i--){\\n            sum[i] += sum[i+1]+piles[i];\\n            for(int j = n;j>0;j--){\\n                int limit = i+2*j-1;\\n                for(int k  = i;k<=Math.min(limit, n-1);k++)\\n                    dp[i][j] = Math.max(dp[i][j], sum[i] - dp[k+1][Math.max(j, k-i+1)]);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameII(int[] piles) {\\n        int n= piles.length;\\n        int [][]dp = new int [n+1][n+1];\\n        int [] sum = new int [n+1];\\n        for(int i = n-1;i>=0;i--){\\n            sum[i] += sum[i+1]+piles[i];\\n            for(int j = n;j>0;j--){\\n                int limit = i+2*j-1;\\n                for(int k  = i;k<=Math.min(limit, n-1);k++)\\n                    dp[i][j] = Math.max(dp[i][j], sum[i] - dp[k+1][Math.max(j, k-i+1)]);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018581,
                "title": "c-memoization-clear",
                "content": "Edit: \\n\\nAnother way to look at it can be, to take out the maximum piles that Alice and have more than Bob. So suppose we get that Alice can have (-5) piles more than Bob, then if Bob has X piles, then Alice will have X-5 piles. But since the piles total count is conserverd, their sum will be equal to the total sum of piles. Voila! \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp; \\n    \\n    int memo(vector<int> & piles, int start, int M, int n){\\n        if(start >= n) return 0; \\n        if(dp[start][M] != -1) return dp[start][M]; \\n        \\n        int sum =0, res = INT_MIN; \\n        for(int i= start; i< min(n, start+2*M); i++){\\n            sum += piles[i]; \\n            res = max(res, sum-memo(piles, i+1, max(i+1-start, M), n)); \\n        }\\n        return dp[start][M] = res ; \\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size(); \\n        dp.resize(n+1 ,vector<int> (2*n+1, -1)) ; \\n        int sum = 0; \\n        for(auto x:piles) sum += x;\\n        return (sum + (memo(piles, 0, 1, n)))/2;\\n    }\\n};\\n```\\n\\nOr Same Idea alternate representation\\n\\n```\\nint memo(vector<vector<int>>& dp, int M, int start, int n, int leftstones, vector<int>& piles){\\n        if(dp[start][M] != -1) return dp[start][M]; \\n        int ans = 0 ; \\n        int taken = 0 ;\\n        for(int i= start; i<min(start+2*M, n); i++){\\n            taken+= piles[i];\\n            ans = max(ans, leftstones- memo(dp, max(M, i-start+1),i+1, n,leftstones-taken, piles)); \\n        }\\n        return dp[start][M] = ans; \\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size(); \\n        vector<vector<int>>  dp(n+1, vector<int>(n+1,-1)); \\n        int M = 1;\\n        \\n        return memo(dp, M, 0 , n,accumulate(piles.begin(), piles.end(),0), piles); \\n\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp; \\n    \\n    int memo(vector<int> & piles, int start, int M, int n){\\n        if(start >= n) return 0; \\n        if(dp[start][M] != -1) return dp[start][M]; \\n        \\n        int sum =0, res = INT_MIN; \\n        for(int i= start; i< min(n, start+2*M); i++){\\n            sum += piles[i]; \\n            res = max(res, sum-memo(piles, i+1, max(i+1-start, M), n)); \\n        }\\n        return dp[start][M] = res ; \\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size(); \\n        dp.resize(n+1 ,vector<int> (2*n+1, -1)) ; \\n        int sum = 0; \\n        for(auto x:piles) sum += x;\\n        return (sum + (memo(piles, 0, 1, n)))/2;\\n    }\\n};\\n```\n```\\nint memo(vector<vector<int>>& dp, int M, int start, int n, int leftstones, vector<int>& piles){\\n        if(dp[start][M] != -1) return dp[start][M]; \\n        int ans = 0 ; \\n        int taken = 0 ;\\n        for(int i= start; i<min(start+2*M, n); i++){\\n            taken+= piles[i];\\n            ans = max(ans, leftstones- memo(dp, max(M, i-start+1),i+1, n,leftstones-taken, piles)); \\n        }\\n        return dp[start][M] = ans; \\n    }\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size(); \\n        vector<vector<int>>  dp(n+1, vector<int>(n+1,-1)); \\n        int M = 1;\\n        \\n        return memo(dp, M, 0 , n,accumulate(piles.begin(), piles.end(),0), piles); \\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009376,
                "title": "c-dp-with-short-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int size = piles.size();\\n        \\n        // Pile sum from right to left\\n        vector<int> pileSum(size, piles[size - 1]);\\n        for (int i = size - 2; i >= 0; --i)\\n        {\\n            pileSum[i] = pileSum[i + 1] + piles[i];\\n        }\\n        \\n        // DP calculation, M rows and piles.size() columns. We need to start from the end until reaching dp[0][0]\\n        vector<vector<int>> dp(size, vector<int>(size, 0));\\n        for (int i = size - 1; i >= 0; --i)\\n        {\\n            for (int j = size - 1; j >= 0; --j)\\n            {\\n                int m = i + 1;\\n                if (j + 2 * m >= size)\\n                {\\n                    dp[i][j] = pileSum[j];\\n                }\\n                else\\n                {\\n                    // Find maximum amount of stones by picking from 1 to 2 * m\\n                    int maxStone = 0;\\n                    for (int k = 1; k <= 2 * m && j + k <= size; ++k)\\n                    {\\n                        // For each turn we may need to update m in case k > m\\n                        int stone = 0, newM = max(k, m);\\n                        if (newM > size)\\n                        {\\n                            break;\\n                        }\\n                        \\n                        for (int l = 0; l < k; ++l)\\n                        {\\n                            stone += piles[j + l];\\n                        }\\n                        \\n                        // Since Alice starts first, her opponent (Bob) will get maximum # of stones from next turn,\\n                        // hence we need to deduct the # of stones Bob has gotten\\n                        if (j + k < size)\\n                        {\\n                            stone += pileSum[j + k] - dp[newM - 1][j + k];\\n                        }\\n                        \\n                        maxStone = stone > maxStone ? stone : maxStone;\\n                    }\\n                    \\n                    dp[i][j] = maxStone;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int size = piles.size();\\n        \\n        // Pile sum from right to left\\n        vector<int> pileSum(size, piles[size - 1]);\\n        for (int i = size - 2; i >= 0; --i)\\n        {\\n            pileSum[i] = pileSum[i + 1] + piles[i];\\n        }\\n        \\n        // DP calculation, M rows and piles.size() columns. We need to start from the end until reaching dp[0][0]\\n        vector<vector<int>> dp(size, vector<int>(size, 0));\\n        for (int i = size - 1; i >= 0; --i)\\n        {\\n            for (int j = size - 1; j >= 0; --j)\\n            {\\n                int m = i + 1;\\n                if (j + 2 * m >= size)\\n                {\\n                    dp[i][j] = pileSum[j];\\n                }\\n                else\\n                {\\n                    // Find maximum amount of stones by picking from 1 to 2 * m\\n                    int maxStone = 0;\\n                    for (int k = 1; k <= 2 * m && j + k <= size; ++k)\\n                    {\\n                        // For each turn we may need to update m in case k > m\\n                        int stone = 0, newM = max(k, m);\\n                        if (newM > size)\\n                        {\\n                            break;\\n                        }\\n                        \\n                        for (int l = 0; l < k; ++l)\\n                        {\\n                            stone += piles[j + l];\\n                        }\\n                        \\n                        // Since Alice starts first, her opponent (Bob) will get maximum # of stones from next turn,\\n                        // hence we need to deduct the # of stones Bob has gotten\\n                        if (j + k < size)\\n                        {\\n                            stone += pileSum[j + k] - dp[newM - 1][j + k];\\n                        }\\n                        \\n                        maxStone = stone > maxStone ? stone : maxStone;\\n                    }\\n                    \\n                    dp[i][j] = maxStone;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993231,
                "title": "maximize-for-alice-and-minimize-for-bob",
                "content": "turn =1 is alice turn\\nelse bob turn\\n```\\nclass Solution {\\n    int dp[100][300][2];\\n    int cal(int i,int m,int turn,vector<int>&piles,int n)\\n    {\\n        if(i >= n) return 0;\\n        int pre_sum =  0;\\n        int &ans = dp[i][m][turn];\\n        if(ans!=-1) return ans;\\n        if(turn) ans = 0 ;\\n        else ans = INT_MAX;\\n        for(int j = 1;j<=2*m;j++)\\n        {\\n            if(i+j-1==n) break;\\n            pre_sum += piles[i+j-1];\\n            if(turn)\\n            ans = max(ans , pre_sum + cal(i+j,max(m,j),0,piles,n) );\\n            else ans = min(ans, cal(i+j,max(m,j),1,piles,n));\\n        }\\n        return ans;\\n        \\n    }\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        return cal(0,1,1,piles,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[100][300][2];\\n    int cal(int i,int m,int turn,vector<int>&piles,int n)\\n    {\\n        if(i >= n) return 0;\\n        int pre_sum =  0;\\n        int &ans = dp[i][m][turn];\\n        if(ans!=-1) return ans;\\n        if(turn) ans = 0 ;\\n        else ans = INT_MAX;\\n        for(int j = 1;j<=2*m;j++)\\n        {\\n            if(i+j-1==n) break;\\n            pre_sum += piles[i+j-1];\\n            if(turn)\\n            ans = max(ans , pre_sum + cal(i+j,max(m,j),0,piles,n) );\\n            else ans = min(ans, cal(i+j,max(m,j),1,piles,n));\\n        }\\n        return ans;\\n        \\n    }\\npublic:\\n    int stoneGameII(vector<int>& piles) {\\n        int n = piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        return cal(0,1,1,piles,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986770,
                "title": "java-top-down-dp-solution",
                "content": "```\\nclass Solution {\\n    int[] pSumArr ;\\n    int n ;\\n    int [][][] cache;\\n    public int stoneGameII(int[] piles) {\\n        n = piles.length;\\n        pSumArr = new int[n+1];\\n        cache = new int[n][n+1][2];\\n        for (int i = 0; i < n ; i++) {\\n            pSumArr[i+1] = pSumArr[i]+piles[i];\\n        }\\n        return stoneGameRec(piles,1,1,0);\\n    }\\n    \\n private int stoneGameRec(int[] piles,int M, int alice, int i) {\\n       if(i >= n) return 0;\\n       if(cache[i][M][alice] != 0) return cache[i][M][alice];\\n    \\n        int sum = 0;\\n            for (int  x = 1; x <= 2*M &&(i+x <= n); x++) {\\n             int pSum = getPrefixSum(i, i+x);\\n             int recSum = stoneGameRec(piles, Math.max(x,M), ((alice ==1)? 0:1),i+x);\\n             if(alice == 1){\\n                if(sum == 0) sum = Integer.MIN_VALUE;\\n                  sum = Math.max(sum,recSum+pSum);\\n             } else {\\n                // incase of bob, ignore the pSum and also choose such that\\n                //  alice gets minimum.\\n                 if(sum == 0) sum = Integer.MAX_VALUE; \\n                 sum =  Math.min(sum,recSum);\\n            }\\n        }\\n      cache[i][M][alice] = sum;\\n      return sum;\\n    }\\n    \\n private  int getPrefixSum(int i , int j ) {\\n        if(i <=n && j <= n) {\\n          return pSumArr[j] - pSumArr[i];    \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[] pSumArr ;\\n    int n ;\\n    int [][][] cache;\\n    public int stoneGameII(int[] piles) {\\n        n = piles.length;\\n        pSumArr = new int[n+1];\\n        cache = new int[n][n+1][2];\\n        for (int i = 0; i < n ; i++) {\\n            pSumArr[i+1] = pSumArr[i]+piles[i];\\n        }\\n        return stoneGameRec(piles,1,1,0);\\n    }\\n    \\n private int stoneGameRec(int[] piles,int M, int alice, int i) {\\n       if(i >= n) return 0;\\n       if(cache[i][M][alice] != 0) return cache[i][M][alice];\\n    \\n        int sum = 0;\\n            for (int  x = 1; x <= 2*M &&(i+x <= n); x++) {\\n             int pSum = getPrefixSum(i, i+x);\\n             int recSum = stoneGameRec(piles, Math.max(x,M), ((alice ==1)? 0:1),i+x);\\n             if(alice == 1){\\n                if(sum == 0) sum = Integer.MIN_VALUE;\\n                  sum = Math.max(sum,recSum+pSum);\\n             } else {\\n                // incase of bob, ignore the pSum and also choose such that\\n                //  alice gets minimum.\\n                 if(sum == 0) sum = Integer.MAX_VALUE; \\n                 sum =  Math.min(sum,recSum);\\n            }\\n        }\\n      cache[i][M][alice] = sum;\\n      return sum;\\n    }\\n    \\n private  int getPrefixSum(int i , int j ) {\\n        if(i <=n && j <= n) {\\n          return pSumArr[j] - pSumArr[i];    \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961089,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn stone_game_ii(piles: Vec<i32>) -> i32 {\\n        let mut cache = HashMap::new();\\n        Self::go(&piles[..], 1, &mut cache).0\\n    }\\n\\n    fn go<\\'a>(\\n        piles: &\\'a [i32],\\n        m: usize,\\n        cache: &mut HashMap<(&\\'a [i32], usize), (i32, i32)>,\\n    ) -> (i32, i32) {\\n        if let Some(result) = cache.get(&(piles, m)) {\\n            return *result\\n        }\\n        let (mut p1, mut p2) = (0, 0);\\n        for i in 1..=(2 * m).min(piles.len()) {\\n            let pick: i32 = piles[0..i].iter().sum();\\n            let (next2, next1) = Self::go(&piles[i..], m.max(i), cache);\\n            if next1 + pick > p1 {\\n                p1 = next1 + pick;\\n                p2 = next2;\\n            }\\n        }\\n        cache.insert((piles, m), (p1, p2));\\n        (p1, p2)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn stone_game_ii(piles: Vec<i32>) -> i32 {\\n        let mut cache = HashMap::new();\\n        Self::go(&piles[..], 1, &mut cache).0\\n    }\\n\\n    fn go<\\'a>(\\n        piles: &\\'a [i32],\\n        m: usize,\\n        cache: &mut HashMap<(&\\'a [i32], usize), (i32, i32)>,\\n    ) -> (i32, i32) {\\n        if let Some(result) = cache.get(&(piles, m)) {\\n            return *result\\n        }\\n        let (mut p1, mut p2) = (0, 0);\\n        for i in 1..=(2 * m).min(piles.len()) {\\n            let pick: i32 = piles[0..i].iter().sum();\\n            let (next2, next1) = Self::go(&piles[i..], m.max(i), cache);\\n            if next1 + pick > p1 {\\n                p1 = next1 + pick;\\n                p2 = next2;\\n            }\\n        }\\n        cache.insert((piles, m), (p1, p2));\\n        (p1, p2)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1905654,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905645,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905669,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1565014,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1906061,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905716,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1569731,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1567575,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905879,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905715,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905654,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905645,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905669,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1565014,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1906061,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905716,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1569731,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1567575,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905879,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905715,
                "content": [
                    {
                        "username": "naga_k",
                        "content": "Is this week\\'s theme \\'poorly written problem statements\\'?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Blatogh](/Blatogh) obviously left"
                    },
                    {
                        "username": "Blatogh",
                        "content": "[@Dionisius](/Dionisius) For example: Where will Alice start picking?\\nFrom left or right?"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@cartesPerforees](/cartesPerforees) yes i agree with you. its not a criticism, just a observation."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@naga_k](/naga_k) have you considered that a problem that is hard to understand might be a feature, not a bug?\nWhat, specifically did you find hard to understand? I don't see what information is missing or what statement is misleading"
                    },
                    {
                        "username": "naga_k",
                        "content": "[@Dionisius](/Dionisius) in the aspect that it is hard to understand from the given information."
                    },
                    {
                        "username": "Dionisius",
                        "content": "Honestly, in which aspect is it poorly written?"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "really frustating questions, demotivating af\\uD83D\\uDE25"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "That or \"Mediums that are actually Hard\", at least the past couple of days sheesh."
                    },
                    {
                        "username": "c4tdog",
                        "content": "clear as mud"
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah, the unbiased problem statement makes whether you understand English irrelevant."
                    },
                    {
                        "username": "Maang-io",
                        "content": "My brain turned into a stone after reading this problem 3 times"
                    },
                    {
                        "username": "aman1320",
                        "content": "lol !!!\\n"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "**Can any one help me to understand this question ?**\\nHow can i calculate X and M here and how they are working here ?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The problem actually states that you could take first x elements , where x is decided by  you  what you'll take given you can only choose from 1 element to 2*m elements where m is 1 initially. Now as you choose 2 elements at an instance then you update m to 2. And now in the next situation you can choose elements from 1 to 4. If you see that you can choose all elements then you 'll select all the elements ofcourse."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Bob and Alice are not playing optimally, but they are playing with us"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Some medium problems will make you feel confident, but surely not this one."
                    },
                    {
                        "username": "prudvirajkaukuntla3",
                        "content": "actually this accepted % is 63% which is impossible\\n"
                    },
                    {
                        "username": "anu_2705",
                        "content": "The description of this question is very hard to understand . I get the point where initially M =1 and the Player 1 can take two moves either 1 or 2 according to 1 <= X <= 2M . But after the first move how is M being updated ? . What is X and how do we calculate it"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "at first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,2*1]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2*m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@joncmoen](/joncmoen) It doesn\\'t help, you wrote an elongated explanation for literally the only clear sentence of the question. The part that\\'s hard to understand is what constitutes an \"optimal\" move"
                    },
                    {
                        "username": "joncmoen",
                        "content": "after the first move (and after every subsequent move) M is the maximum of the current value of M or chosen value of X. So for example if Alice decides to pick up one pile of stones, the new M would continue to be 1, but if she picked up 2 piles, then the new M would be 2 [Max(1,2) = 2]. Hope that helps."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@gpena1](/gpena1) You can\\'t, because if you do that for the first example, you can get 17 (Alice takes 2, Bob takes 1, Alice takes 2)"
                    },
                    {
                        "username": "gpena1",
                        "content": "Based on what I'm reading, I think X is arbitrarily chosen by you at any given point in the iteration, and you just recurse into each possible value of X between 1 and 2*M and take those piles of stones."
                    },
                    {
                        "username": "anmingyu11",
                        "content": "1406 is much more easier than this , but this is medium, i think it should be hard"
                    },
                    {
                        "username": "GD18",
                        "content": "this is definitely one of the harder mediums and easier hards i guess lol\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i tried dp and yes i am still trying its been 2 hrs \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104 \\nCan any one help me to understand how the output is 104?"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@user4783T](/user4783T) They said both play optimally, so when Alice has a chance to pick 1 or 2 , if she pick 2 the game is over for Alice, so she picks 1st pile. Same goes for Bob , he only picks 2 . Then Alice picks 3 and now Bob knows even when he pics 4 or (4,5) he not going to get 100 so he try to maximizes his score and takes (4,5) and then Alice gets 100. In this way, when they play optimally Alice can get 104."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "Thanks [@romegenix](/romegenix). At last, I understood the second example. I think they should have added the explanation in the question. \\n\\n[1 , 2 , 3 , 4 , 5 , 100]\\n[A, B , A , B , B , A]\\n\\nThe next task is to solve the question. lol."
                    },
                    {
                        "username": "premkumar9030",
                        "content": "[@romegenix](/romegenix) how to know they both playing optimally? how optimal strategy knows here?"
                    },
                    {
                        "username": "s_m99",
                        "content": "[@dev-null0](/dev-null0) Why do you think they don\\'t know their opponent\\'s next move if the aim is to collect as much stones as possible for themselves "
                    },
                    {
                        "username": "s_m99",
                        "content": "[@neutrino45](/neutrino45) On the basis that both of them take the maximum amount of stones possible "
                    },
                    {
                        "username": "Saitama109",
                        "content": "same question..  alice can get more than that.... if he took [1], then bob took [2,3] and then alice took [4,5,100].... 110 would have been the answer... i dont understand :-("
                    },
                    {
                        "username": "romegenix",
                        "content": "If alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "crystal11101",
                        "content": "Alice picked 1,3 & 100 while Bob picked 2,4 & 5"
                    },
                    {
                        "username": "neutrino45",
                        "content": "[@colewinfield](/colewinfield)  I didn\\'t get this. How Bob is making his move? In first testcase he picked maximum possible no. of piles and in 2nd testcase he picked only one pile. On what basis they are making optimal moves.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@dev-null0](/dev-null0) Exactly. You raised the key question of this game. We need to think backwards, from the last stone.\\nConsider both Alice and Bob are genius who can calculate large number of steps ahead in a game.\\n\\nSee the simple dp explanation:\\nhttps://leetcode.com/problems/stone-game-ii/solutions/3563516/easy-o-n-3-optimal-solution-dp-explained-in-3-sentences/"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@colewinfield](/colewinfield) How do they know what moves are optimal if they don\\'t know their opponent\\'s next move? Meaning, in your example, what if instead of 4, 5, 100 being left over, it was 4, 5, 100, **300** - Bob picking 4 & 5 would have been a huge mistake."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@hero080](/hero080) thanks i understand know : )\\n"
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) ok i got it know thanks :) "
                    },
                    {
                        "username": "colewinfield",
                        "content": "[@jai_2008](/jai_2008) It would be better for Alice, but not Bob. Remember, both players are playing optimally. You can think of Bob\\'s optimal move as minimizing Alice\\'s score (which would increase his). In this case, it was better for him to take just the second stone (+2), which would then allow him to take the fourth and fifth stone (+9). If he took the the second AND the third, he\\'d only accumulate 5 points instead of 11. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@jai_2008](/jai_2008) That means Bob made a mistake to take next two.\\n*Both* of them are playing the game optimally."
                    },
                    {
                        "username": "jai_2008",
                        "content": "[@colewinfield](/colewinfield) wouldn\\'t it be better if alice takes the first one then bob takes the next two and then alice takes all the remaining three.\\n   alice = 1+ 4+5+100= 110"
                    },
                    {
                        "username": "colewinfield",
                        "content": "Alice takes the first stone (+1). Bob takes the second. She then takes the third (+3). Then, Bob tries to maximize his play by taking as many as he can (the 4 and the 5, which is the maximum he can take because each have only taken 1 so far and the limit is 1 <= X <= 2M, so it\\'s 2 * 1 stones that Bob took). This leaves the last stone, +100, for Alice. A combined total of 104."
                    }
                ]
            },
            {
                "id": 1905914,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1905657,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1576066,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1905917,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1905688,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1905682,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1906236,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1905668,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1905985,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1574661,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "seems like description is written by ChatGPT, too ambiguous."
                    },
                    {
                        "username": "Miiza",
                        "content": "There is no ambiguity in the description...\\nSetup:\\nYou have a list representing the number of stones in separate piles.\\nA variable, M, is initially set to 1.\\nDuring each player\\'s turn, they can choose to pick up the first X piles, where: 1 <= X <= 2M\\nAfter a player chooses X piles, update M to max(M, X)\\nPlayer 1 (alice) starts to choose X piles, and after that they swap turn to choose piles\\nAssume optimal play\\n\\nGoal:\\nFind the maximum number of stones that player 1 (alice) can end up with."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "Another confusion gem by leetcode."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t understand what \"both players play optimally\" is supposed to mean for us. How can both players play optimally, assuming that they know all the possible tree of outcomes from each of their moves? How would it help?"
                    },
                    {
                        "username": "bellrat",
                        "content": "[@dev-null0](/dev-null0) Because Bob taking just pile #2 is not playing optimally. Player 1 starts by just taking pile #1 because if they take 2 the other player just takes the rest. Player 2 then has the option of taking 1 or 2 piles. So in your scenario, if bob takes just the pile of 7, he's guaranteed to be left with just a 4 pile. Which is less than the 9 pile he passed on, hence not optimal."
                    },
                    {
                        "username": "Shrey_l_l",
                        "content": "[@mehvix](/mehvix) thanks!"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@dev-null0](/dev-null0) Bob will play optimal in the second round, that means in this case Bob will choose #2 & #3 instead of just #2. It's a game theory problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@mehvix](/mehvix) But for this example:\n\n> [2,7,9,4,4]\n\nWhy is this invalid? -\n\n* Alice: Gets pile #1 (2)\n* Bob: Gets pile #2 (7)\n* Alice: Gets piles #3 & #4 (9, 4)\n* Bob: Gets last pile (4)\n\nAlice ends with 15 points. Is Bob only picking pile #2 (7) a problem? If so, why is Alice only picking pile #1 (2) and not both of the first piles *not* a problem?"
                    },
                    {
                        "username": "mehvix",
                        "content": "They choose the moves that maximizes the number of stones they can obtain, knowing that the other player is doing the same. \\n\\nI believe this is a zero-sum game: any stones for Player1 is equivalent to negative amount of stones for Player2 (and vice-versa). The objective is to maximize the number of stones Alice can get; this implies that Bob\\'s objective is to minimize the number of stones Alice can get.\\n\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "The hardest problem I\\'ve encountered here so far.\\nI\\'m really surprised it\\'s medium difficulty despite being multidimensional game theory optimization thing."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This game is not fair. If the result of a game can be predicted by a program. Why to play?"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Humans don\\'t have the same ability to predict all possible future combinations of moves and states. That\\'s why we still enjoy playing chess."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080)  My children are good go players for amateur."
                    },
                    {
                        "username": "hero080",
                        "content": "chess is sad, so is go."
                    },
                    {
                        "username": "UJ15",
                        "content": "is this medium? wtf.. too hard"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's an attempt at a simpler description: in this game, Alice and Bob take a turns to take the piles from a row of piles, going from left to right. Alice starts taking 1 or 2 piles, followed by Bob, and so on. The key is that taking x piles in your turn enables the next player to take twice as many piles, so you need to be thoughtful: taking more piles will get you a higher score, but it will also allow Bob to take many more piles in their turn!\n\nThink about this as an optimization problem: what's the optimal score you can obtain from your starting position, considering all allowed values of X?"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@namandt](/namandt) It just enables you to take 2*x piles, it doesn\\'t cap you, I would say this description is a little more clear"
                    },
                    {
                        "username": "namandt",
                        "content": "this is wrong, for next turn M gets updated by max(M, X).\\n\\nso even if M was 3 for example and you took only 1 piles that does not mean in next turn opponent can only take 1 * 2 = 2 piles. NOOO. opponent will still be able to have M = 3 so he can take upto 6 piles.\\n\\nyour simpler description is incorrect!"
                    },
                    {
                        "username": "user8228j",
                        "content": "I feel as though recently a lot of these hints are more harmful than helpful."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Streak Breaking Week is going on, EveryDay is bit more tuf then previous...if this is in interview they will think brain in not playing with stone game actually stone is playing with my brain. WTF  is medium tag."
                    },
                    {
                        "username": "jzy95310",
                        "content": "I\\'m always confused about this kind of minimax problem. What are players trying to maximize, the difference of score or the score itself? Or are they just the same thing? Since the problem is asking for \"the maximum score Alice can get\", it seems that Alice just want to get the highest score instead of maximize the score difference between him and his opponent. Can someone help clarify this a little bit?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "A common question regarding game theory problems.\\nA \"play optimally\" thing usually refers to players knowing rules of the game, and having enough time to develop the best strategy they can.\\nA strategy refers to algorithm they should take in case of ANY opponent action.\\nA best strategy is the one, that gives most score in case of ANY opponent action.\\n\\nAll of these definitions above might seems a little vague, and that\\'s because they are. There is no general formula for such strategy, nor it\\'s guaranteed to exists at all.\\nSo the most effective mindset you can use for these sort of problems -- try whatever moves you can and choose one eventually leading to the best result.\\n\\n\\nMaximizing score difference is practically the same as maximizing Alice\\'s score.\\nSay, Alice get A, Bob gets B.\\nThen, A + B = [total number of stones]\\nThen, A - B = 2 * A - [total number of stones]\\nFor larger A, you get larger A - B."
                    }
                ]
            },
            {
                "id": 1906346,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 1906227,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 1906180,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 1906115,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 1906080,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 1906010,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 1905918,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 2066248,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 1966021,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 1966015,
                "content": [
                    {
                        "username": "purvi_jha",
                        "content": "leetcode is playing with our feelings. I read this three times but not able to understand a word.\\nPeople say you cant understand the women call those people and show them this problem. "
                    },
                    {
                        "username": "motralk",
                        "content": "then how did u even solve it ;_; now I can\\'t understand u "
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Yeah good, I understood the problem statement... okay...\\n1st example - oh ! Okay good, it should be programmable...\\n(proceeds towards 2nd Example) - Hey,\\uD83E\\uDD2F we don\\'t do that here [mind blown]... I definitely can\\'t do it !!!!"
                    },
                    {
                        "username": "cursydd",
                        "content": "min/max dp"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "They need a huge table :)"
                    },
                    {
                        "username": "yogesh873",
                        "content": "I Initially thought we need to solve it from Bob's perspective . Imaging ourselves in bob shoes and try to minimise the Alex's stone count considering she will also play optimally i.e aiming to minimise ours/bob's count   . Now it looks like we need to play on both's behallf kind of need to have split persionality. #MindBlown"
                    },
                    {
                        "username": "Traversal_16",
                        "content": "hard one"
                    },
                    {
                        "username": "bbbbb8bbbbb",
                        "content": "### Visualize\n![](https://i.imgur.com/rgKoGvA.png)\n### I asked GPT generated a clear version of description:\n\nAlice and Bob are playing a game with piles of stones. The piles are arranged in a row, and each pile has a positive integer number of stones. The goal of the game is to collect the most stones.\n\nThe game proceeds as follows:\n\n1. Alice and Bob take turns, with Alice going first.\n2. Initially, M = 1.\n3. On each player's turn, they can take all the stones in the first X remaining piles, where 1 <= X <= 2M. After taking the stones, M is updated to max(M, X).\n4. The game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Below is the step by step description with the exmaple it given!\n\nSure, let's go through the example step by step:\n\nInput: piles = [2,7,9,4,4]\n\nInitially, M = 1.\n\nAlice goes first:\n\n1. If Alice takes 1 pile (X = 1), she gets 2 stones. Now, M = max(1, 1) = 1. The remaining piles are [7,9,4,4].\n\n   Bob's turn:\n   - If Bob takes 1 pile (X = 1), he gets 7 stones. Now, M = max(1, 1) = 1. The remaining piles are [9,4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 9 + 4 = 13 stones. Now, M = max(1, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 13 = 15 stones.\n\n   - If Bob takes 2 piles (X = 2), he gets 7 + 9 = 16 stones. Now, M = max(1, 2) = 2. The remaining piles are [4,4].\n   \n     Alice's turn:\n     - Alice takes 2 piles (X = 2), she gets 4 + 4 = 8 stones. Now, M = max(2, 2) = 2. The remaining piles are empty.\n     \n     In this scenario, Alice gets a total of 2 + 8 = 10 stones.\n\n2. If Alice takes 2 piles (X = 2), she gets 2 + 7 = 9 stones. Now, M = max(1, 2) = 2. The remaining piles are [9,4,4].\n\n   Bob's turn:\n   - Bob takes 3 piles (X = 3), he gets 9 + 4 + 4 = 17 stones. Now, M = max(2, 3) = 3. The remaining piles are empty.\n\n   In this scenario, Alice gets a total of 9 stones.\n\nComparing the scenarios, Alice can get a maximum of 10 stones. So the output is 10."
                    },
                    {
                        "username": "shubham5955",
                        "content": "in forst scenario Alice is getting 15 stones , in second 10 stones so how 10 is max?\\n"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "In my opinion, this description is as good as the one, provided above.\\nA problem is very hard nevertheless."
                    },
                    {
                        "username": "c4tdog",
                        "content": "still clear as mud 😁"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "i don't understand why Alice and Bob need play these games 🙂🙂\nnd let them play their game.....i don't want to judge"
                    },
                    {
                        "username": "battousai007",
                        "content": "one can pick stone only from front not form end"
                    },
                    {
                        "username": "battousai007",
                        "content": "hit me with that stone"
                    }
                ]
            },
            {
                "id": 1954478,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1917149,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1907302,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1907172,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1907083,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1907040,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1906782,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1906657,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1906560,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1906433,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Bro I have no idea how I have solved this prefix sum+dfs+dynamic programming in one problem"
                    },
                    {
                        "username": "user3688Tp",
                        "content": "Why it shows all 92 tests are passed but still solution is not accepted?!\\nTime Limit Exceeded with \\'piles = {blank}\\' input.\\n\\nIs it a bug or I am missing something?"
                    },
                    {
                        "username": "yogesh873",
                        "content": "Hi I have hard time understanding why the below approach is failing here I am checking if current indx + 2*m is greater than piles.length -1 and its alice Turn we will sum the remaining element and return since that will be optimal for alice other wise simply return alice sum since that will be optimal for bob. However after adding memo I am getting incorrect answer for input:\npiles =\n[86,11,7,6,46,37,72,67,33,25,54,45];\n\nWhat am I missing .please help\n\n `\n class Solution {\n    public int stoneGameII(int[] piles) {\n      int[][][] memo =new int[2][piles.length][2*piles.length];\n  return func(piles,0,1,0,0,1,memo);      \n    }\n    public int func(int[] piles,int indx ,int aliceTurn,int bobTurn,int aliceSum,int m,int[][][] memo){\nif(memo[aliceTurn][indx][m] != 0)\nreturn memo[aliceTurn][indx][m];\n   if((indx + 2*m) > piles.length -1)\n   {\nif(aliceTurn == 1)\n{\n  for(int i = indx; i < piles.length;i++)\n  aliceSum += piles[i];\n}\n\nreturn memo[aliceTurn][indx][m] = aliceSum;\n   }\n\n\n   int x = Integer.MIN_VALUE;\n   \nif(aliceTurn == 1)\n{int temp = aliceSum;\n\nfor(int i =1; i <= 2*m;i++)\n{temp += piles[indx+i-1];\nx = Math.max(x,func(piles, indx +i ,0,1,temp,  Math.max(m,i),memo));\n\n}\n}\nif(bobTurn == 1)\n{x = Integer.MAX_VALUE;\n\nfor(int i =1; i <= 2*m;i++)\n{\nx = Math.min(x,func(piles, indx +i ,1,0,aliceSum,  Math.max(m,i),memo));\n\n}\n\n}\nreturn memo[aliceTurn][indx][m] = x;\n}\n     }`"
                    },
                    {
                        "username": "varuns22",
                        "content": "I mean what if Bob does not play optimally here\\nlets take the first example:\\n```\\nInput: piles = [2,7,9,4,4]\\nOutput: 10\\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it\\'s larger. \\n```\\nhere, if alice chooses 1 pile, then bob chooses 1 pile, then alice chooses 2 piles, and then bob chooses 1 pile\\nalice : 2+9+4\\nbob: 7+4\\n\\nor even worse\\nwhat if alice chooses 2 piles, bob chooses 1, and then alice again chooses 2 piles\\nalice: 2+7+4+4\\nbob: 9\\n\\ncan anyone help me with these?"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "dude why will bob choose only 1 pile when he has chance to 7+9 to grab(bob can grab atmost <=2 in first game) remember they play optimally so in both cases.(1 case explation)\\nRead the question = if someone chose x stone (in you case u choose 2 + 7) 2 stones so other have choice of choosing 1 <= other <= 2*x(in ur case 4) so bob will not stop at 4 +4 he can take last one also \\n:: u need ton understand the question bro\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Tip Of the day Solve Stone3 first then this will be peace of cake!! \\nTry Solve it both by difference max"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any similar type questions list?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Is there a better solution than brute forcing the game tree?  Anyone tried alpha beta pruning?"
                    },
                    {
                        "username": "hero080",
                        "content": "The pruning you mentioned are usually for top down searching.\\nThis problem allows for bottom up searching, and the truth is, you have to get to the bottom before you know if a move is good or bad, as the last element might be so big that all previous moves do not matter for their temporary gain. You simply cannot \"win the game\" in the middle."
                    },
                    {
                        "username": "nidhidanayak",
                        "content": "Dynamic Programming should get banned!"
                    },
                    {
                        "username": "MohyCS",
                        "content": "when u get annoyed by seeing stone game problems and decide to do tackle stone game only \\uD83D\\uDC80"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "How can we even come up with a solution in interviews if this type of questions comes<<<<"
                    }
                ]
            },
            {
                "id": 1906432,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1906376,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1906353,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1906258,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1906215,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1906202,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1906185,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1906103,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1905978,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1905963,
                "content": [
                    {
                        "username": "afzaltec",
                        "content": "Am I the only one who can\\'t understand the problem statement??? "
                    },
                    {
                        "username": "chungys02",
                        "content": "My code got accepted, but I have no idea why it works..."
                    },
                    {
                        "username": "wafsinc",
                        "content": "Nice problem, but come on, this isn\\'t a medium."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I love this week\\'s problems. Looking forward to \"hard\" problem"
                    },
                    {
                        "username": "20191a0567jntucep",
                        "content": "maximum stones alice can get is 15 in example 1"
                    },
                    {
                        "username": "romegenix",
                        "content": "how bro?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "what is wrong in this code??\\n\\n\\nint stonesAliceGets(vector<int>&piles, vector<vector<int>>&dp, int m, int i, int turn)\\n    {\\n        if (i >= piles.size()) return 0;\\n        if (dp[i][m] != -1) return dp[i][m]; //use stored results\\n        \\n        int takenCount = 0;\\n        int ans = (turn == 1)? 0 : INT_MAX;\\n        for (int x = 1; x <= (2 * m); x++)\\n        {\\n            int pileIdx = i + x - 1;\\n            if(pileIdx >= piles.size())break;\\n            takenCount += piles[pileIdx]; \\n            \\n            if (turn) // ALICE TURN\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 0);\\n                int totalCount = takenCount + nextAliceCount; \\n                ans = max(ans, totalCount); //maximize what Alice will get\\n            }\\n            else   // BOB TURN,,, ALICE WILL TAKE MINIMUM HERE\\n            {\\n                int nextAliceCount = stonesAliceGets(piles, dp, max(m, x), pileIdx + 1, 1);\\n                ans = min(ans, nextAliceCount); //minimize what Alice will get\\n            }\\n        }\\n        return dp[i][m] = ans; //store the results\\n    }\\n    int stoneGameII(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(n+1, -1));\\n        int ans = stonesAliceGets(piles, dp, 1, 0, 1);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "The problem is that here you have two branches based on $$turn$$ that calculate either the minimum or the maximum, but you store them in the single $$dp$$ array. Imagine you calculated $$dp[i][j]$$ when it was Bob's turn, then we will put the minimum value to $$dp[i][j]$$, but if after that you will need $$dp[i][j]$$, when it's Alice's turn, you'll get the wrong stored value."
                    },
                    {
                        "username": "romegenix",
                        "content": "class Solution {\\npublic:\\n    int dp[101][201];\\n\\n    int helper(int i, int m, vector<int>& piles) {\\n        if (i >= piles.size())\\n            return 0;\\n\\n        if (dp[i][m] != -1)\\n            return dp[i][m];\\n\\n        int total = 0;\\n        int ans = INT_MIN;\\n\\n        for (int j = 0; j < 2 * m; j++) {\\n            if (i + j < piles.size())\\n                total += piles[i + j];\\n\\n            ans = max(ans, total - helper(i + j + 1, max(m, j + 1), piles));\\n        }\\n\\n        return dp[i][m] = ans;\\n    }\\n\\n    int stoneGameII(vector<int>& piles) {\\n        memset(dp, -1, sizeof dp);\\n        int sum = 0;\\n        for (auto x : piles)\\n            sum += x;\\n        int diff = helper(0, 1, piles);\\n\\n        return (sum + diff) / 2;\\n    }\\n};\\nUse this code , its easy ."
                    },
                    {
                        "username": "siva5271",
                        "content": "In the second test case if Alice takes st pile, Bob takes the next two piles and on the next case if Alice takes the next 3 piles won't she end up having 115 stones. Thereby isn't the given test case wrong"
                    },
                    {
                        "username": "bad_open_ai",
                        "content": "To me this seems like Minimax algorithm problem."
                    },
                    {
                        "username": "namandt",
                        "content": "the first example itself is contradicting.\n\nlets say\n `piles = [2, 7, 9, 4, 4]\n  M = 1\n`\n\nAlice's turn:\nif she needs to choose how many piles piles[i] to piles[x] to take,\nwhere X can be [1, 2M], firstly M = 1\nso for first turn X can be [1, 2]\n\nlets say she chose X = 2, so she took first two piles collecting '9' (score).\nnow for next round that is Bob's turn, M = max(M, X)\nthat is M = max(1, 2) resulting in 2. M = 2.\n\nBob's turn:\nNow for Bob X can be again [1, 2M]\nso X can be [1, 4]\nbeing optimal, he will take X = 4.\n\nso he can take first 4 piles (whatever is remaining in them).\n\nso [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles upto [0, 0, 9, 4, 4]\n\nHOW THE F******?\n\ntoo bad explanation, "
                    },
                    {
                        "username": "namandt",
                        "content": "[@EricRaw](/EricRaw) Description doesnt clearly states that.\\nIt can easily be consiered the indices. that Player can take any piles from indices 1 to X where X is 1 to 2M.\\n\\nPoor description thats my point."
                    },
                    {
                        "username": "EricRaw",
                        "content": "That's why the problem want you to assume that both Alice and Bob play optimally, carefully considering their moves rather than selecting piles randomly. \n\nAlice can strategically choose to take either 1 or 2 piles at a time, analyzing the possibilities where she can secure a win. Alice would not choose to take two stones if she knows it would result in her immediate defeat.\n\nBob can strategically choose after Alice to take (1,2) or (1, 4) depend on Alice and strategically chooses the optimal number of piles to maximize his chances of winning\n\n\"so [0, 0, 9, 4] that is 13. whereas in example explanation, it says Bob can take all the piles up to [0, 0, 9, 4, 4]\"\n\njust as [@Dzuchun](/Dzuchun) say, the piles that already taken doesn't considered as remaining piles so\n- [2, 7, 9, 4, 4] (5 piles)\nAlice take two = 9\n- [9,4,4] Remaining 3 piles\nso bob takes the remaining piles because he can take 1 to 4 piles = 17"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@namandt](/namandt) Nah, you\\'ve taken some no longer existing piles. Surely pile is not considered \"remaining\" if there are no stones left. :idk:"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Dzuchun](/Dzuchun)  you just quoted a line from description.\\nso?\\nwhat I interpret from this is that:\\nPlayer can take call the piles till X where X can be [1, 2M]. Sure thats what I have done in my comment."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"(...) player can take all the stones in the <b>first X remaining piles</b>, where 1 <= X <= 2M.\""
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "i didnt got the question can anyone explain ?"
                    },
                    {
                        "username": "namandt",
                        "content": "[@life_is_lie](/life_is_lie) he asked to understand the question. you gave him solution link?\\nwhat are the level we steeping to for views??"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "https://leetcode.com/problems/stone-game-ii/solutions/3564086/memoization-completely-explained-easy-to-understand/\\n\\ncheck here"
                    }
                ]
            },
            {
                "id": 1905954,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            },
            {
                "id": 1905877,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            },
            {
                "id": 1905860,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            },
            {
                "id": 1905855,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            },
            {
                "id": 1905833,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            },
            {
                "id": 1905827,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            },
            {
                "id": 1905815,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            },
            {
                "id": 1905814,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            },
            {
                "id": 1905787,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            },
            {
                "id": 1905767,
                "content": [
                    {
                        "username": "octothorpe27",
                        "content": "They can\\'t even give a proper explanation for the problems\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Can anyone please tell me what is wrong with this code in javaScript\\n\\n ` function stoneGameII(piles: number[]): number {\\n    // a hashmp that key has 3 values, alice, idx, M\\n    const memo = new Map();\\n\\n    const dfs = (alice: boolean, idx: number, M: number): number => {\\n        if (idx == piles.length) return 0;\\n\\n        if (memo.has([alice, idx, M])) return memo.get([alice, idx, M]);\\n\\n        let result = alice === false? 1000000 : -1,\\n            total = 0;\\n\\n        for (let x = 1; x <= 2 * M; x++) {\\n            if (idx + x > M) break;\\n\\n            total += piles[idx + x - 1];\\n            if (alice) {\\n                result = Math.max(result, total + dfs(false, idx + x, Math.max(M, x)));\\n            } else {\\n                result = Math.min(result, dfs(true, idx + x, Math.max(M, x)));\\n            }\\n        }\\n\\n        memo.set([alice, idx, M], result);\\n        return result;\\n    };\\n\\n    return dfs(true, 0, 1);\\n}\\n `"
                    },
                    {
                        "username": "EricRaw",
                        "content": "``` for (let x = 1; x <= 2 * M; x++) ```\\nIn this for loop, the condition x <= 2 * M has not considered if x exceed piles.length\\n"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "The state transition equation is simple, the boundary condition costs me 90% of time to debug. Should be considered HARD."
                    },
                    {
                        "username": "chenzhekl",
                        "content": "What the hell does M mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2M is the maximum number of piles a player can take on that turn"
                    },
                    {
                        "username": "xxxuz1",
                        "content": "Input: piles = [1,2,3,4,5,100]\\nOutput: 104\\nwhy the output is 104, we can get many answers larger than 104, like 1+4+5+100. 1+3+5+100.\\nAlso, how do we know how  Bob acts? "
                    },
                    {
                        "username": "code__HARD",
                        "content": "if alice take [1] bob has chance to take[2,3] if bob takes both 2 and 3 Alice can take [4,5,100]. So bob takes only [2]. Now alice can take[3,4]. If alice take both[3,4] then bob can take[5,100] and bob wins. As both play optimally alice take only [3]. Now bob can take [4,5]. If bob takes only 4 or both [4,5], Alice get [100] anyway and he wins. This is the optimal strategy to be followed by both players to win.\\nHope you got the idea!"
                    },
                    {
                        "username": "Andrewang492",
                        "content": "in the explanation, is Alice getting 10 piles in total or 10 stones? wtf "
                    },
                    {
                        "username": "c4tdog",
                        "content": "10 stones, there are only 5 piles (example 1)"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "a bit of explanation of m and x. \\nat first alice has m=1 so he can choose x to be [1,2]. and let say she chose 1 then bob will have M=max(1,1). then bob can choose x to be [1,21]. and he chooses 2. now updated m is max(1,2)=max(m,x). x is 2 as bob choosen 2. now alice has m=2. now alice can choose x=[1,2m=4] so she chooses 2. and so on."
                    },
                    {
                        "username": "bhishma620",
                        "content": "Can anyone explain the test case?\\n \\nInput: piles = [1,2,3,4,5,100]\\n\\nOutput: 104"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "To reach the optimal answer:\n\n* Alice takes the 1 pile at index 0. (M remains at 1.)\n* Bob takes the 2 pile at index 1. (M remains at 1.)\n* Alice takes the 3 pile at index 2. (M remains at 1.)\n* Bob takes the 4 & 5 piles at indices 3 & 4. (M becomes 2.)\n* Alice takes the 100 pile at index 5. (M remains at 2.)\n\nIn total, Alice took 104 stones (1 + 3 + 100) and Bob took 11 stones (2 + 4 + 5).\n\nNote that Bob could have taken the 2 & 3 piles at indices 1 & 2 for a total of 5 stones (2 + 3), but then Alice would be able to take all of the remaining piles for a total of 110 stones (1 + 4 + 5 + 100). So this would not be optimal for Bob."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Why the heck they are still playing the same game..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "DP come in the scene."
                    }
                ]
            }
        ]
    }
]