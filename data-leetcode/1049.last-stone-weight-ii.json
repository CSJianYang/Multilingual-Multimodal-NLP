[
    {
        "title": "Last Stone Weight II",
        "question_content": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is:\n\tIf x == y, both stones are destroyed, and\n\tIf x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\nAt the end of the game, there is at most one stone left.\nReturn the smallest possible weight of the left stone. If there are no stones left, return 0.\n&nbsp;\nExample 1:\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation:\nWe can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,\nwe can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,\nwe can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,\nwe can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.\nExample 2:\nInput: stones = [31,26,33,21,40]\nOutput: 5\n&nbsp;\nConstraints:\n\t1 <= stones.length <= 30\n\t1 <= stones[i] <= 100",
        "solutions": [
            {
                "id": 294888,
                "title": "java-c-python-easy-knapsacks-dp",
                "content": "# **Intuition**\\nSame problem as:\\nDivide all numbers into two groups,\\nwhat is the minimum difference between the sum of two groups.\\nNow it\\'s a easy classic knapsack problem.\\n<br>\\n\\n\\n# **Brief Prove**\\nAll cases of \"cancellation of rocks\" can be expressed by two knapsacks.\\nAnd the last stone value equals to the difference of these two knapsacks\\nIt needs to be noticed that the opposite proposition is wrong.\\n<br>\\n\\n# **Solution 1**\\nVery classic knapsack problem solved by DP.\\nIn this solution, I use `dp` to record the achievable sum of the smaller group.\\n`dp[x] = 1` means the sum `x` is possible.\\n\\nTime `O(NS)`,\\nSpace `O(S)` space, where `S = sum(A)`.\\n<br>\\n\\n**Java, use array:**\\n```java\\n    public int lastStoneWeightII(int[] A) {\\n        boolean[] dp = new boolean[1501];\\n        dp[0] = true;\\n        int sumA = 0;\\n        for (int a : A) {\\n            sumA += a;\\n            for (int i = Math.min(1500, sumA); i >= a; --i)\\n                dp[i] |= dp[i - a];\\n        }\\n        for (int i = sumA / 2; i >= 0; --i)\\n            if (dp[i]) return sumA - i - i;\\n        return 0;\\n    }\\n```\\n\\n**C++, use bitset:**\\n```cpp\\n    int lastStoneWeightII(vector<int> A) {\\n        bitset<1501> dp = {1};\\n        int sumA = 0;\\n        for (int a : A) {\\n            sumA += a;\\n            for (int i = min(1500, sumA); i >= a; --i)\\n                dp[i] = dp[i] + dp[i - a];\\n        }\\n        for (int i = sumA / 2; i >= 0; --i)\\n            if (dp[i]) return sumA - i - i;\\n        return 0;\\n    }\\n```\\n\\n**Python, use set:**\\n```py\\n    def lastStoneWeightII(self, A):\\n        dp = {0}\\n        sumA = sum(A)\\n        for a in A:\\n            dp |= {a + i for i in dp}\\n        return min(abs(sumA - i - i) for i in dp)\\n```\\n<br>\\n\\n\\n# **Solution 2**\\nAdapted dp to this problem.\\nIn this solution, I use `dp` to record the achievable diff of one group.\\nIf `x` in the set `dp`, it means the difference `x` is achievable currently.\\n\\nTime `O(NS)` time,\\nSpace `O(S)` space, where `S = sum(A)`.\\n<br>\\n\\n**Python, use set:**\\n```py\\n    def lastStoneWeightII(self, A):\\n        dp = {0}\\n        for a in A:\\n            dp = {a + x for x in dp} | {abs(a - x) for x in dp}\\n        return min(dp)\\n```\\n\\n**Python, 1-line version**\\n```py\\n    def lastStoneWeightII(self, A):\\n        return min(reduce(lambda dp, y: {x + y for x in dp} | {abs(x - y) for x in dp}, A, {0}))\\n```\\n<br>\\n\\n\\n# **Follow-up**\\nAs this problem will be quite boring as Q4 (if you read my post),\\nI\\'ll leave you a slightly harder problem as follow-up just for more fun.\\nQuestion: Return the **biggest** possible weight of this stone?\\n<br>\\n\\n\\n# **FAQ (Some high voted questions)**\\n**Question:** How is it a knapsack problem?\\nMy understanding of Knapsack problem is this-\\nYou are given a set of items , for each of which we have a weight `w[i]` and value `v[i]`.\\nNow we have a bag for capacity `W` and we maximize our profit.\\n**Answer:**\\n`w[i] = stones[i]`\\n`v[i] = stones[i]`\\n`W = sum(stones) / 2`\\n<br>\\n\\n**Question:** Why the minimum result of cancellation is equal to minimum knapsack partition?\\n**Answer:**\\n1. One cancellation can be represented as one grouping.\\nOne grouping can be represented as one knapsack partition.\\n2. If the grouping difference < max(A), it can be realized by a cancellation.\\nWith the 2 conclusions above,\\nwe can know that the minimum result of cancellation is equal to minimum grouping difference,\\nwhich we solved by knapsack problem.\\n<br>\\n\\n**Question:** In some version of solution, what does the magic number 1500 mean?\\n**Answer:**\\nThe `dp[i]` present if the sum of one group can be `i`.\\nSo we can only record the smaller one for less space cost,\\nwhich less than half of the upper bound of total sum 3000.\\n",
                "solutionTags": [],
                "code": "```java\\n    public int lastStoneWeightII(int[] A) {\\n        boolean[] dp = new boolean[1501];\\n        dp[0] = true;\\n        int sumA = 0;\\n        for (int a : A) {\\n            sumA += a;\\n            for (int i = Math.min(1500, sumA); i >= a; --i)\\n                dp[i] |= dp[i - a];\\n        }\\n        for (int i = sumA / 2; i >= 0; --i)\\n            if (dp[i]) return sumA - i - i;\\n        return 0;\\n    }\\n```\n```cpp\\n    int lastStoneWeightII(vector<int> A) {\\n        bitset<1501> dp = {1};\\n        int sumA = 0;\\n        for (int a : A) {\\n            sumA += a;\\n            for (int i = min(1500, sumA); i >= a; --i)\\n                dp[i] = dp[i] + dp[i - a];\\n        }\\n        for (int i = sumA / 2; i >= 0; --i)\\n            if (dp[i]) return sumA - i - i;\\n        return 0;\\n    }\\n```\n```py\\n    def lastStoneWeightII(self, A):\\n        dp = {0}\\n        sumA = sum(A)\\n        for a in A:\\n            dp |= {a + i for i in dp}\\n        return min(abs(sumA - i - i) for i in dp)\\n```\n```py\\n    def lastStoneWeightII(self, A):\\n        dp = {0}\\n        for a in A:\\n            dp = {a + x for x in dp} | {abs(a - x) for x in dp}\\n        return min(dp)\\n```\n```py\\n    def lastStoneWeightII(self, A):\\n        return min(reduce(lambda dp, y: {x + y for x in dp} | {abs(x - y) for x in dp}, A, {0}))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 295167,
                "title": "java-beat-100-with-nice-explanation",
                "content": "```\\n/**\\nThis question eaquals to partition an array into 2 subsets whose difference is minimal\\n(1) S1 + S2  = S\\n(2) S1 - S2 = diff  \\n\\n==> -> diff = S - 2 * S2  ==> minimize diff equals to  maximize S2 \\n\\nNow we should find the maximum of S2 , range from 0 to S / 2, using dp can solve this\\n\\ndp[i][j]   = {true if some subset from 1st to j\\'th has a sum equal to sum i, false otherwise}\\n    i ranges from (sum of all elements) {1..n}\\n    j ranges from  {1..n}\\n\\nsame as 494. Target Sum\\n\\n*/\\n\\n\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int S = 0, S2 = 0;\\n        for (int s : stones) S += s;\\n        int n = stones.length;\\n        boolean[][] dp = new boolean[S + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[0][i] = true;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int s = 1; s <= S / 2; s++) {\\n                if (dp[s][i - 1] || (s >= stones[i - 1] && dp[s - stones[i - 1]][i - 1])) {\\n                    dp[s][i] = true;\\n                    S2 = Math.max(S2, s);\\n                }\\n            }\\n        }\\n        return S - 2 * S2;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nThis question eaquals to partition an array into 2 subsets whose difference is minimal\\n(1) S1 + S2  = S\\n(2) S1 - S2 = diff  \\n\\n==> -> diff = S - 2 * S2  ==> minimize diff equals to  maximize S2 \\n\\nNow we should find the maximum of S2 , range from 0 to S / 2, using dp can solve this\\n\\ndp[i][j]   = {true if some subset from 1st to j\\'th has a sum equal to sum i, false otherwise}\\n    i ranges from (sum of all elements) {1..n}\\n    j ranges from  {1..n}\\n\\nsame as 494. Target Sum\\n\\n*/\\n\\n\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int S = 0, S2 = 0;\\n        for (int s : stones) S += s;\\n        int n = stones.length;\\n        boolean[][] dp = new boolean[S + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[0][i] = true;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int s = 1; s <= S / 2; s++) {\\n                if (dp[s][i - 1] || (s >= stones[i - 1] && dp[s - stones[i - 1]][i - 1])) {\\n                    dp[s][i] = true;\\n                    S2 = Math.max(S2, s);\\n                }\\n            }\\n        }\\n        return S - 2 * S2;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653550,
                "title": "trying-to-explain-a-bit-logic-behind-trick",
                "content": "int lastStoneWeightII(vector<int>& stones) {\\n        //let say array be [a,b,c,d]\\n        //answer = (a+b)-(c+d)   OR\\n        //answer = a-(b+c+d)   Or\\n        //answer = (d+b)-(a+c) and so on.. any combination could be possible\\n        //notice that in general I can say that\\n        //answer = S1-S2\\n        //where S1 is sum of some of the numbers and S2 is sum of rest of numbers\\n\\t\\t//also note that S1+S2 = SUM (sum of all numbers)\\n        //S1 >= S2 beacuse negative answer is not possible\\n        //now we have to minimise answer\\n        //answer = SUM - 2*S2 (Just substituting S1 by SUM-S2)\\n        //To minimise answer S2 has to be maximum\\n        //Now, max value of S2 is SUM/2 (bigger than this and answer would be negative which is not possible)\\n        //so the question reduces to find closest sum (sum of numbers) to (SUM/2)\\n        //now this could be understood as subset sum problem or 0/1 knapsack problem\\n        \\n        int sum = 0;\\n        int total = 0;\\n        int n = stones.size();\\n        for(int i = 0;i<n;i++) {\\n            total+=stones[i];\\n        }\\n        sum = total/2;\\n        vector<vector<int>> dp(n+1,vector<int>(sum+1,0));\\n        for(int i =1;i<=n;i++) {\\n            for(int j = 1;j<=sum;j++) {\\n                if(stones[i-1]>j) {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                else {\\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-stones[i-1]]+stones[i-1]);\\n                }\\n            }\\n        }\\n        return total-(2*dp[n][sum]);\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int lastStoneWeightII(vector<int>& stones) {\\n        //let say array be [a,b,c,d]\\n        //answer = (a+b)-(c+d)   OR\\n        //answer = a-(b+c+d)   Or\\n        //answer = (d+b)-(a+c) and so on.. any combination could be possible\\n        //notice that in general I can say that\\n        //answer = S1-S2\\n        //where S1 is sum of some of the numbers and S2 is sum of rest of numbers\\n\\t\\t//also note that S1+S2 = SUM (sum of all numbers)\\n        //S1 >= S2 beacuse negative answer is not possible\\n        //now we have to minimise answer\\n        //answer = SUM - 2*S2 (Just substituting S1 by SUM-S2)\\n        //To minimise answer S2 has to be maximum\\n        //Now, max value of S2 is SUM/2 (bigger than this and answer would be negative which is not possible)\\n        //so the question reduces to find closest sum (sum of numbers) to (SUM/2)\\n        //now this could be understood as subset sum problem or 0/1 knapsack problem\\n        \\n        int sum = 0;\\n        int total = 0;\\n        int n = stones.size();\\n        for(int i = 0;i<n;i++) {\\n            total+=stones[i];\\n        }\\n        sum = total/2;\\n        vector<vector<int>> dp(n+1,vector<int>(sum+1,0));\\n        for(int i =1;i<=n;i++) {\\n            for(int j = 1;j<=sum;j++) {\\n                if(stones[i-1]>j) {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                else {\\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-stones[i-1]]+stones[i-1]);\\n                }\\n            }\\n        }\\n        return total-(2*dp[n][sum]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 294881,
                "title": "another-kind-of-coin-change-problem",
                "content": "same as [494 target sum](https://leetcode.com/problems/target-sum/), it is recommended to look at the description(only description) of the 494 before looking at the following content.\\n\\nfor three number `a1, a2, a3`, according to the order of our choice,\\nthere are `8-2=6` different cases:\\n1. a1 - (a2 - a3) = a1 - a2 + a3\\n2. (a2 - a3) - a1 = -a1 + a2 - a3\\n3. a1 - (a3 - a2) = a1 + a2 - a3\\n4. (a3 - a2) - a1 = -a1 - a2 + a3\\n5. a2 - (a1 - a3) = -a1 + a2 + a3\\n6. (a1 - a3) - a2 = a1 - a2 - a3\\n7. a2 - (a3 - a1) = a1 + a2 - a3   `same as case 3`\\n8. (a3 - a1) - a2 = -a1 - a2 + a3  `same as case 4`\\n9. a3 - (a1 - a2) = -a1 + a2 + a3  `same as case 5`\\n10. (a1 - a2) - a3 = a1 - a2 - a3  `same as case 6`\\n11. a3 - (a2 - a1) = a1 - a2 + a3  `same as case 1`\\n12. (a2 - a1) - a3 = -a1 + a2 - a3 `same as case 2`\\n\\nfor each number, we can add \\'+\\' or \\'-\\' before it. there are totally 2^3 = 8 cases\\nbut it cannot be all positive or all negtive, so it will decrease 2 cases.\\n\\nthe answer is choose some numbers to be positive, others negtive.\\nassume `psum` is the sum of positive number.\\nOur goal is to minimize `psum - (sum(stones)-psum) = 2*psum - sum(stones)`\\n\\n```python\\n# 60ms\\nclass Solution:\\n    def lastStoneWeightII(self, stones):\\n        s = sum(stones)\\n        dp = [0] * (s + 1)\\n        dp[0] = 1\\n        for i in range(len(stones)):\\n            for j in range(len(dp)-1, -1, -1):\\n                if j - stones[i] < 0: break\\n                if dp[j-stones[i]]:\\n                    dp[j] = 1\\n        \\n        res = s + 1\\n        for psum in range(1, s+1):\\n            if dp[psum] and 2*psum-s >= 0:\\n                res = min(res, 2*psum-s)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n# 60ms\\nclass Solution:\\n    def lastStoneWeightII(self, stones):\\n        s = sum(stones)\\n        dp = [0] * (s + 1)\\n        dp[0] = 1\\n        for i in range(len(stones)):\\n            for j in range(len(dp)-1, -1, -1):\\n                if j - stones[i] < 0: break\\n                if dp[j-stones[i]]:\\n                    dp[j] = 1\\n        \\n        res = s + 1\\n        for psum in range(1, s+1):\\n            if dp[psum] and 2*psum-s >= 0:\\n                res = min(res, 2*psum-s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294995,
                "title": "c-4-lines-epic-smash",
                "content": "# Intuition\\nYou can merge stones into 2 giant ones, and do the epic smash.\\n\\nIn other words, you can split all stones into two groups by applying either plus or minus sign to each stone\\'s value.\\n# Top-Down Solution\\nRun DFS tracking the running sum, and try adding and subtracting the current stone. In the end, return the result if it\\'s not negative.\\n\\nUse memoization for the current stone ```[1, 30]``` and running sum ```[-3000, 3000]```.\\n\\nThis can be futher optimized, but the runtime of this solution is already 4 ms.\\n```cpp\\nshort dp[30][6000] = {};\\nint lastStoneWeightII(vector<int>& A, int s = 0, int i = 0) {\\n    if (i == A.size()) \\n        return s < 0 ? 100 : s;\\n    if (dp[i][s + 3000] == 0) \\n        dp[i][s + 3000] = 1 + min(lastStoneWeightII(A, s + A[i], i + 1),\\n            lastStoneWeightII(A, s - A[i], i + 1));\\n    return dp[i][s + 3000] - 1;\\n}\\n```\\n# Bottom-Up Solution\\nWe add/subtract each stone to/from all possible sums achievable after processing previous stones. In the end, we return the smallest absolute value.\\n\\nTo track possible sums, we need to use hash set to avoid duplicates (and TLE). We could also use a byte array, but the code seemed a bit more complicated to me.\\n```cpp\\nint lastStoneWeightII(vector<int>& A) {\\n  unordered_set<int> s1 = { 0 };\\n  for (auto i : A) {\\n    unordered_set<int> s2;\\n    for (auto j : s1) \\n        s2.insert({ j - i, j + i });\\n    swap(s1, s2);\\n  }\\n  return abs(*min_element(begin(s1), end(s1), [](int i, int j) { return abs(i) < abs(j); }));\\n}\\n```",
                "solutionTags": [],
                "code": "```[1, 30]```\n```[-3000, 3000]```\n```cpp\\nshort dp[30][6000] = {};\\nint lastStoneWeightII(vector<int>& A, int s = 0, int i = 0) {\\n    if (i == A.size()) \\n        return s < 0 ? 100 : s;\\n    if (dp[i][s + 3000] == 0) \\n        dp[i][s + 3000] = 1 + min(lastStoneWeightII(A, s + A[i], i + 1),\\n            lastStoneWeightII(A, s - A[i], i + 1));\\n    return dp[i][s + 3000] - 1;\\n}\\n```\n```cpp\\nint lastStoneWeightII(vector<int>& A) {\\n  unordered_set<int> s1 = { 0 };\\n  for (auto i : A) {\\n    unordered_set<int> s2;\\n    for (auto j : s1) \\n        s2.insert({ j - i, j + i });\\n    swap(s1, s2);\\n  }\\n  return abs(*min_element(begin(s1), end(s1), [](int i, int j) { return abs(i) < abs(j); }));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402213,
                "title": "python-solution-based-on-0-1-knapsack",
                "content": "The value of the final rock would be a summation of all values with +/- signs. As we are trying to minimize the size of the final rock, we need to find a partition of numbers in the array into two subsets, which have the least amount of differenc in their summations. \\nWe can reformulate this as a 0-1 Knapsack, i.e. collecting some rocks, where the weights of the rocks is maximized and  their total weight does not exceed half of the total weight of the rocks.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        \\n        Max_weight = int(total/2)\\n        \\n        current = (Max_weight+1)*[0]\\n        \\n        for v in stones:\\n            for w in range(Max_weight, -1, -1):\\n                if w-v>=0:\\n                    current[w] = max(v + current[w-v], current[w])\\n            \\n           \\n        return total-2*current[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        \\n        Max_weight = int(total/2)\\n        \\n        current = (Max_weight+1)*[0]\\n        \\n        for v in stones:\\n            for w in range(Max_weight, -1, -1):\\n                if w-v>=0:\\n                    current[w] = max(v + current[w-v], current[w])\\n            \\n           \\n        return total-2*current[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509493,
                "title": "java-many-solutions",
                "content": "**\\u2714\\uFE0F Solution 1: Bruteforce**\\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(0);\\n        for (int a : arr) {\\n            HashSet<Integer> set2 = new HashSet<>();\\n            for (int x : set) {\\n                set2.add(x - a);\\n                set2.add(x + a);\\n            }\\n            set = set2;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int x : set)\\n            min = Math.min(min, Math.abs(x));\\n        return min;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n*sum)`\\n- Space: `O(sum)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DP Solution**\\nThis question eaquals to partition an array into 2 subsets whose difference is minimal\\n(1) S1 + S2  = S\\n(2) S1 - S2 = diff  \\n==> -> diff = S - 2 * S2  ==> minimize diff equals to  maximize S2 \\n\\nNow we should find the maximum of S2 , range from 0 to S / 2, using dp can solve this\\n`dp[i][j]`   = {true if some subset from 1st to j\\'th has a sum equal to sum i, false otherwise}\\n    `i` ranges from (sum of all elements) `{1..n}`\\n    `j` ranges from  `{1..n}`\\n\\n**DP 1**\\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        int n = arr.length;\\n        int sum = 0;\\n        for (int a : arr) sum += a;\\n\\n        boolean[][] dp = new boolean[n + 1][sum + 1];\\n        for (int i = 0; i <= n; i++)\\n            dp[i][0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= sum; j++) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (j >= arr[i - 1])\\n                    dp[i][j] |= dp[i - 1][j - arr[i - 1]];\\n            }\\n        }\\n        for (int i = sum / 2; i >= 0; --i)\\n            if (dp[n][i]) return sum - i - i;\\n        return 0;\\n    }\\n```\\nComplexity:\\n- Time & Space: `O(n*sum)`\\n\\n**DP 2: Space Optimized**\\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        boolean[] dp = new boolean[1501];\\n        dp[0] = true;\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += a;\\n            for (int i = Math.min(sum, 1500); i >= a; --i) {\\n                dp[i] |= dp[i - a];\\n            }\\n        }\\n        for (int i = sum / 2; i >= 0; --i)\\n            if (dp[i]) return sum - i - 1;\\n        return 0;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n*sum)`\\n- Space: `O(sum)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(0);\\n        for (int a : arr) {\\n            HashSet<Integer> set2 = new HashSet<>();\\n            for (int x : set) {\\n                set2.add(x - a);\\n                set2.add(x + a);\\n            }\\n            set = set2;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int x : set)\\n            min = Math.min(min, Math.abs(x));\\n        return min;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        int n = arr.length;\\n        int sum = 0;\\n        for (int a : arr) sum += a;\\n\\n        boolean[][] dp = new boolean[n + 1][sum + 1];\\n        for (int i = 0; i <= n; i++)\\n            dp[i][0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= sum; j++) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (j >= arr[i - 1])\\n                    dp[i][j] |= dp[i - 1][j - arr[i - 1]];\\n            }\\n        }\\n        for (int i = sum / 2; i >= 0; --i)\\n            if (dp[n][i]) return sum - i - i;\\n        return 0;\\n    }\\n```\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] arr) {\\n        boolean[] dp = new boolean[1501];\\n        dp[0] = true;\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += a;\\n            for (int i = Math.min(sum, 1500); i >= a; --i) {\\n                dp[i] |= dp[i - a];\\n            }\\n        }\\n        for (int i = sum / 2; i >= 0; --i)\\n            if (dp[i]) return sum - i - 1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294932,
                "title": "concise-c-solution-another-way-of-thinking-of-this-problem",
                "content": "The idea is simple, we can transfer this problem to: add `+` and `-` between each number( for the first number, we can consider it as `-n` or `+n`), find the minimum result. we can solve it by using DFS, but it will `TLE`, the complexity will be O(2^n).   \\nwe can use `set` to store all possible results for the first `i` numbers, we can avoid the same results are repeated in `set`, and we use these results to calculate the new possible results with current number. Finally, we find the minimum result in the `set`, note that the negative results should be positive by using `abs`.\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> s = {0};\\n        for(int i = 0; i < stones.size(); ++i) {\\n            int n = stones[i];\\n            auto t = s;\\n            s = {};\\n            for(auto num : t) {\\n                s.insert(num + n);\\n                s.insert(num - n);\\n            }\\n        }\\n        for(auto n : s){\\n            ans = min(ans, abs(n));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> s = {0};\\n        for(int i = 0; i < stones.size(); ++i) {\\n            int n = stones[i];\\n            auto t = s;\\n            s = {};\\n            for(auto num : t) {\\n                s.insert(num + n);\\n                s.insert(num - n);\\n            }\\n        }\\n        for(auto n : s){\\n            ans = min(ans, abs(n));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725708,
                "title": "similar-to-minimum-subset-sum-difference-aditya-verma-s-style-recursion-memoization-optimized-dp",
                "content": "##### \\u2728INTUITION: \\n\\n> **for every example, actually certain elements are being added and certain elements are being subtracted\\n    - for eg: 2 7 4 1 8 1 \\n    - => (8-7)  (4-2)  (1-1) lets say in first go we smashed these stones\\n    - => 1 2 0 - in the second go we can smash 2 and 1 and weight of left stone will be 1 which is minimum\\n    - => basically this is equivalent to (8-7) - (4-2) + (1-1) = 8 + 2 + 1 - 7 - 4 - 1\\n    - => 8 + 2 + 1 - 7 - 4 - 1 this is equal to (8, 2, 1) - (7, 4, 1) \\n    - => overall it is equal to dividing the stones array such that their difference is least - which gives us least weight\\n    - therefore, this is exactly similar to minimum subset sum difference problem\\n    - approach: recursion -> memoization -> optimized dp**\\n\\n##### \\uD83C\\uDFAF1. RECURSION: \\n\\n >**recursion: TLE \\uD83E\\uDD72\\n    approach: for every element I have 2 choices, whether to give it \"+\" sign or \"-\" sign\\n    as we can either add that elemnt or subtract it\\n    then we find out by which path we get the minimum answer as we want total sum to be as least as possible\\n    so once we cover all elements we check what is the sum:\\n         => if negative: not possible as remaining stone cannot have negative weight, so we return infinity\\n         => if positive: then we return whatever the currSum was, and then check from which sign we are getting minimum answer**\\n\\t\\t \\n```\\nint lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int currSum)\\n    {\\n        if(i == n)\\n        {\\n            if(currSum < 0) return INT_MAX;\\n            else return currSum;\\n        }\\n        return min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0);\\n        return minWeight;        \\n    }\\n```\\n\\n##### \\uD83C\\uDFAF2. (a) MEMOIZATION (method 1):\\n> **memoization(Aditya Verma\\'s style):  TLE \\uD83E\\uDD72\\n    1. memo matrix\\n    2. just add 2 lines in recursive code that if we find a case which is already pre-computed, then we don\\'t do recursive calls for the same**\\n\\n```\\nint memo[30 + 1][3000 + 1];\\n    \\n    int lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int currSum)\\n    {\\n        if(i == n)\\n        {\\n            if(currSum < 0) return INT_MAX;\\n            else return currSum;\\n        }\\n        if(currSum > 0 && memo[i][currSum] != -1)\\n        {\\n            return memo[i][currSum];\\n        }\\n        if(currSum > 0) return memo[i][currSum] = min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n        else return min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        memset(memo, -1, sizeof(memo));\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0);\\n        return minWeight;        \\n    }\\n```\\n\\n##### \\uD83C\\uDFAF2. (b) MEMOIZATION (method 2):\\n> **rather than giving two choices of + and - until last index it would be better if we keep diving the sum into 2 parts and at end return absolute sum\\n> ACCEPTED\\uD83D\\uDC99**\\n    \\n\\tint memo[30 + 1][3000 + 1];\\n    \\n    int lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int sum1, int sum2)\\n    {\\n        if(i == n)\\n        {\\n            return abs(sum1-sum2);\\n        }\\n        if(memo[i][sum1] != -1)\\n        {\\n            return memo[i][sum1];\\n        }\\n        return memo[i][sum1] = min(lastStoneWeightIIRecursive(stones, n, i+1, sum1 + stones[i], sum2), lastStoneWeightIIRecursive(stones, n, i+1, sum1, sum2 + stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        memset(memo, -1, sizeof(memo));\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0, 0);\\n        return minWeight;        \\n    }\\n\\t\\n\\t\\n##### \\uD83C\\uDFAF2. (b) OPTIMIZED DP APPROACH (method 2):\\n>**optimized dp approach(aditya verma\\'s style)\\uD83C\\uDF86\\n    => converting recursive code to iterative code**\\n\\t\\n```\\nint lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        // dp part is exactly same as minimum subset sum difference problem\\n        \\n        bool dp[n + 1][totalSum + 1];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<n+1; i++)\\n        {\\n            dp[i][0] = true;\\n        }\\n        for(int j=1; j<totalSum+1; j++)\\n        {\\n            dp[0][j] = false;\\n        }\\n        // filing the matrix\\n        for(int i=1; i<n+1; i++)\\n        {\\n            for(int j=1; j<totalSum+1; j++)\\n            {\\n                if(stones[i-1] <= j)\\n                {\\n                    dp[i][j] = ((dp[i-1][j - stones[i-1]]) || dp[i-1][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n        int minWeight = INT_MAX;\\n        \\n\\t    for(int i=totalSum/2; i>=0; i--)\\n\\t    {\\n\\t        if(dp[n][i] == true) \\n\\t        {\\n\\t            minWeight = totalSum - (2*i);\\n\\t            break;\\n\\t        }\\n\\t    }\\n\\t    return minWeight;       \\n   }\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int currSum)\\n    {\\n        if(i == n)\\n        {\\n            if(currSum < 0) return INT_MAX;\\n            else return currSum;\\n        }\\n        return min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0);\\n        return minWeight;        \\n    }\\n```\n```\\nint memo[30 + 1][3000 + 1];\\n    \\n    int lastStoneWeightIIRecursive(vector<int>& stones, int n, int i, int currSum)\\n    {\\n        if(i == n)\\n        {\\n            if(currSum < 0) return INT_MAX;\\n            else return currSum;\\n        }\\n        if(currSum > 0 && memo[i][currSum] != -1)\\n        {\\n            return memo[i][currSum];\\n        }\\n        if(currSum > 0) return memo[i][currSum] = min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n        else return min(lastStoneWeightIIRecursive(stones, n, i+1, currSum + stones[i]), lastStoneWeightIIRecursive(stones, n, i+1, currSum - stones[i]));\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        memset(memo, -1, sizeof(memo));\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        int minWeight = lastStoneWeightIIRecursive(stones, n, 0, 0);\\n        return minWeight;        \\n    }\\n```\n```\\nint lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        // dp part is exactly same as minimum subset sum difference problem\\n        \\n        bool dp[n + 1][totalSum + 1];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<n+1; i++)\\n        {\\n            dp[i][0] = true;\\n        }\\n        for(int j=1; j<totalSum+1; j++)\\n        {\\n            dp[0][j] = false;\\n        }\\n        // filing the matrix\\n        for(int i=1; i<n+1; i++)\\n        {\\n            for(int j=1; j<totalSum+1; j++)\\n            {\\n                if(stones[i-1] <= j)\\n                {\\n                    dp[i][j] = ((dp[i-1][j - stones[i-1]]) || dp[i-1][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n        int minWeight = INT_MAX;\\n        \\n\\t    for(int i=totalSum/2; i>=0; i--)\\n\\t    {\\n\\t        if(dp[n][i] == true) \\n\\t        {\\n\\t            minWeight = totalSum - (2*i);\\n\\t            break;\\n\\t        }\\n\\t    }\\n\\t    return minWeight;       \\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979653,
                "title": "java-clear-explanation-dp",
                "content": "\\n\\n\\n\\n\\n**What the question says**-\"We have a collection of rocks, each rock has a positive integer weight.\\n\\nEach turn, we choose any two rocks and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:\\n\\nIf x == y, both stones are totally destroyed;\\nIf x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.\\nAt the end, there is at most 1 stone left.  Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.)\"\\n\\n **What it actually means** - \"Divide the array into two arrays such that the difference between the sums of the two individual arrays is the minimum\"\\n\\nNow,\\nOur best case scenario would be the case:\\n1>where all elements are same(so we can use the condition 1 in the question (x==y)) and everything cancels out and the answer is simply zero)\\n2>Difference of the sum of two individual arrays is equal to 0.\\n\\n**So our best case answer is 0**\\n\\n*So  , now we will try to reach as close a possible to our best case answer and try to find the array whose sum is totalSum/2(where totalSum is the sum of all array elements).*\\n\\n**One more thing  -\\nLets say S is the sum of all array elements\\nS2 is our nearest sum to S/2 that we can find ,\\nthen , our answer would be S-2*S2(why?)\\nWell because ,S-S2 is simply the sum of the other array , but we need to find the difference between the two individual  arrays.\\nIn other words :\\nS=S1+S2\\nWe need to find S1-S2\\nTherefore we return S-S2-S2, which is nothing but S-2*S2 because S-S2 gives us S1 , and hence again subtracting gives us S1-S2.**\\n\\nThe rest of the logic is pretty simple.\\nWe use DP to find this S2(standard stuff).\\n\\n**dp[i][j] = can sum \\'i\\' be found by using 0 - j-1th elements ?**\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int S=0;\\n        for(int i: stones)\\n            S+=i;\\n        int S2=0;\\n        int n=stones.length;\\n        //maximise S2\\n        boolean[][] dp = new boolean[S/2 +1][n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=true;\\n        //zero sum is always possible(just dont take any element in the array)\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int s=1;s<=S/2;s++)\\n            {\\n                if(dp[s][i-1] || (s>=stones[i-1] &&dp[s-stones[i-1]][i-1]))\\n                {\\n                    dp[s][i]=true;\\n                    S2=Math.max(s,S2);\\n                }\\n                \\n            }\\n        }\\n        return S-2*S2;\\n        \\n    }\\n}\\n```\\n\\nHope you understood the logic.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int S=0;\\n        for(int i: stones)\\n            S+=i;\\n        int S2=0;\\n        int n=stones.length;\\n        //maximise S2\\n        boolean[][] dp = new boolean[S/2 +1][n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=true;\\n        //zero sum is always possible(just dont take any element in the array)\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int s=1;s<=S/2;s++)\\n            {\\n                if(dp[s][i-1] || (s>=stones[i-1] &&dp[s-stones[i-1]][i-1]))\\n                {\\n                    dp[s][i]=true;\\n                    S2=Math.max(s,S2);\\n                }\\n                \\n            }\\n        }\\n        return S-2*S2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295209,
                "title": "stupidly-easy-python-brute-force-memorization",
                "content": "Idea: Split `S` into two sets `S1` and `S2`, such that difference `|sum(S1) - sum(S2)|` is minimal\\nApproach: Brute Force -> **Too slow** -> Memorization\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:        \\n        mem = {} #Mem\\n        \\n        def explore(a, b, stones):\\n            if len(stones) == 0:\\n                return abs(a-b)\\n            \\n            entry = (a, b, len(stones)) #Mem\\n            if entry in mem:\\n                return mem[entry]\\n            \\n            s = stones.pop()\\n            m = min(explore(a+s, b, stones), explore(a, b+s, stones))\\n            stones.append(s)\\n            \\n            mem[entry] = m #Mem\\n            return m\\n        \\n        return explore(0, 0, stones)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:        \\n        mem = {} #Mem\\n        \\n        def explore(a, b, stones):\\n            if len(stones) == 0:\\n                return abs(a-b)\\n            \\n            entry = (a, b, len(stones)) #Mem\\n            if entry in mem:\\n                return mem[entry]\\n            \\n            s = stones.pop()\\n            m = min(explore(a+s, b, stones), explore(a, b+s, stones))\\n            stones.append(s)\\n            \\n            mem[entry] = m #Mem\\n            return m\\n        \\n        return explore(0, 0, stones)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235478,
                "title": "easy-dp-solution-with-full-explanation-in-c",
                "content": "So, if you look the problem carefully you will find this is the problem of minimum subset sum difference, if you can\\'t, I\\'ll show you how. \\nSee the main line is that we have to store the value y-x where y and x are the weights of any two choosen stones. And if the weights are same both the stones will be destroyed, this sums up the problem as we have two divide the array stones in two subsets in such a way that the difference between the sums of the subsets should be minimum.\\n\\nNow in order to solve the minimum subset sum difference problem we have to find two subsets say S1 and S2 but we can write S2 as (Sum-S1) where sum is the sum of all the elements in the array stones. Now our task is to minimise abs(Sum-(2*S1)).\\nIn order to handle the absolute value we will take S2>S1.\\n\\nNow we have to find the values S1 can take and return the max of them in order to min the above equation (as S1 is +ve). In order to do that we will maintain an array dp[n+1][sum+1] and for it\\'s last row if(dp[n][j]==true) we will push the corresponding j value to a vector.\\n\\nAt the end we have to find the max value of the resultant vector say its max.\\nSo return sum-(2*max)\\nHit like if you like my approach :-).\\nAnd here is the simple code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0, n=stones.size();\\n        for(int i=0; i<n; i++){\\n            sum += stones[i];\\n        }\\n        \\n        bool dp[n+1][sum+1];\\n        for(int i=0; i<n+1; i++){\\n            for(int j=0; j<sum+1; j++){\\n                if(i==0)\\n                    dp[i][j]=false;\\n                if(j==0)\\n                    dp[i][j]=true;\\n            }\\n        }\\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<sum+1; j++){\\n                if(stones[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-stones[i-1]];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        vector<int> temp;\\n        for(int j=0; j<=(sum/2); j++){\\n            if(dp[n][j]==true){\\n                temp.push_back(j);\\n            }\\n        }\\n        int max=-1;\\n        for(int i=0; i<temp.size(); i++){\\n            if(temp[i]>max)\\n                max=temp[i];\\n        }\\n        \\n        int res = sum - (2*max);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0, n=stones.size();\\n        for(int i=0; i<n; i++){\\n            sum += stones[i];\\n        }\\n        \\n        bool dp[n+1][sum+1];\\n        for(int i=0; i<n+1; i++){\\n            for(int j=0; j<sum+1; j++){\\n                if(i==0)\\n                    dp[i][j]=false;\\n                if(j==0)\\n                    dp[i][j]=true;\\n            }\\n        }\\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<sum+1; j++){\\n                if(stones[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-stones[i-1]];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        vector<int> temp;\\n        for(int j=0; j<=(sum/2); j++){\\n            if(dp[n][j]==true){\\n                temp.push_back(j);\\n            }\\n        }\\n        int max=-1;\\n        for(int i=0; i<temp.size(); i++){\\n            if(temp[i]>max)\\n                max=temp[i];\\n        }\\n        \\n        int res = sum - (2*max);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246290,
                "title": "c-bottom-up-dp-explanation",
                "content": "```\\n//Concept Used - Minimum Subset Sum Difference\\nint lastStoneWeightII(vector<int>& stones) \\n    {\\n        //1.Mark true for all the possible subset sum\\n        //2.Check for the minimum difference out of all the marked \\n        //elements\\n        int n = stones.size();\\n        int sum = 0; \\n        for (int i = 0; i < n; i++)\\n            sum += stones[i];\\n     \\n        // Create an array to store results of subproblems\\n        bool t[n + 1][sum + 1];\\n     \\n        // Initialize first column as true. 0 sum is possible \\n        // with all elements.\\n        for (int i = 0; i <= n; i++)\\n            t[i][0] = true;\\n     \\n        // Initialize top row, except dp[0][0], as false. With\\n        // 0 elements, no other sum except 0 is possible\\n        for (int i = 1; i <= sum; i++)\\n            t[0][i] = false;\\n     \\n        // Fill the partition table in bottom up manner\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= sum; j++)\\n            {\\n                if (stones[i - 1] <= j)\\n                    t[i][j] = t[i - 1][j - stones[i - 1]] || t[i- 1][j];\\n                else\\n                     t[i][j] = t[i - 1][j];\\n             }\\n        }\\n      \\n        // Initialize difference of two sums. \\n        int diff = INT_MAX;\\n         \\n        // Find the largest j such that dp[n][j]\\n        // is true where j loops from sum/2 t0 0\\n        for (int j = sum/2; j >= 0; j--)\\n        {\\n            //Find the minimum difference\\n            if (t[n][j] == true)\\n              diff = min(diff, sum - 2*j);\\n        }\\n        \\n        return diff;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Concept Used - Minimum Subset Sum Difference\\nint lastStoneWeightII(vector<int>& stones) \\n    {\\n        //1.Mark true for all the possible subset sum\\n        //2.Check for the minimum difference out of all the marked \\n        //elements\\n        int n = stones.size();\\n        int sum = 0; \\n        for (int i = 0; i < n; i++)\\n            sum += stones[i];\\n     \\n        // Create an array to store results of subproblems\\n        bool t[n + 1][sum + 1];\\n     \\n        // Initialize first column as true. 0 sum is possible \\n        // with all elements.\\n        for (int i = 0; i <= n; i++)\\n            t[i][0] = true;\\n     \\n        // Initialize top row, except dp[0][0], as false. With\\n        // 0 elements, no other sum except 0 is possible\\n        for (int i = 1; i <= sum; i++)\\n            t[0][i] = false;\\n     \\n        // Fill the partition table in bottom up manner\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= sum; j++)\\n            {\\n                if (stones[i - 1] <= j)\\n                    t[i][j] = t[i - 1][j - stones[i - 1]] || t[i- 1][j];\\n                else\\n                     t[i][j] = t[i - 1][j];\\n             }\\n        }\\n      \\n        // Initialize difference of two sums. \\n        int diff = INT_MAX;\\n         \\n        // Find the largest j such that dp[n][j]\\n        // is true where j loops from sum/2 t0 0\\n        for (int j = sum/2; j >= 0; j--)\\n        {\\n            //Find the minimum difference\\n            if (t[n][j] == true)\\n              diff = min(diff, sum - 2*j);\\n        }\\n        \\n        return diff;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1272897,
                "title": "simple-java-implementation-knapsack",
                "content": "This question can be construed as 0/1 Knapsack problem. We can maintain 2 sacks **sumL** and **sumR**. For every stone we have two choices either we put the stone in sumL or in sumR. Once we have the recursive solution in place, its just a matter of visualising recursive tree to figure out that we are calculating same problem multiple times and can use top down dp with memoization.\\n\\nupvote if you like the solution.\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sumStWt = 0;\\n        for(int stone : stones){\\n            sumStWt += stone;\\n        }\\n        Integer[][] dp = new Integer[stones.length][sumStWt];\\n        return helper(stones, 0, 0, 0, dp);\\n    }\\n    \\n    private int helper(int[] stones, int index, int sumL, int sumR, Integer[][] dp) {\\n        if(index == stones.length){\\n            return Math.abs(sumL - sumR);\\n        }\\n        \\n        if(dp[index][sumL] != null) {\\n            return dp[index][sumL];\\n        }\\n        \\n        dp[index][sumL] = Math.min(helper(stones, index+1, sumL + stones[index], sumR, dp) , helper(stones, index+1, sumL, sumR + stones[index], dp));\\n        return dp[index][sumL];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sumStWt = 0;\\n        for(int stone : stones){\\n            sumStWt += stone;\\n        }\\n        Integer[][] dp = new Integer[stones.length][sumStWt];\\n        return helper(stones, 0, 0, 0, dp);\\n    }\\n    \\n    private int helper(int[] stones, int index, int sumL, int sumR, Integer[][] dp) {\\n        if(index == stones.length){\\n            return Math.abs(sumL - sumR);\\n        }\\n        \\n        if(dp[index][sumL] != null) {\\n            return dp[index][sumL];\\n        }\\n        \\n        dp[index][sumL] = Math.min(helper(stones, index+1, sumL + stones[index], sumR, dp) , helper(stones, index+1, sumL, sumR + stones[index], dp));\\n        return dp[index][sumL];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295063,
                "title": "screencast-of-weekly-contest-137",
                "content": "https://www.youtube.com/watch?v=jSsd3ZhGiSo",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=jSsd3ZhGiSo",
                "codeTag": "Unknown"
            },
            {
                "id": 794493,
                "title": "c-recur-memo-bottom-up-dp-using-minimum-subset-difference-concept",
                "content": "This is similar to the problem \"Minimum Subset Difference\"\\ni.e.  Split the array into two subsets (S1, S2), such that absolute difference between \\nsum(S1) and sum(S2) is minimum.\\nNOTE: sum(S1)  = sum of all elements in subset S1\\n\\n```\\n//Approach-1 (Recursion + Memo)\\nclass Solution {\\npublic:\\n    int t[31][5051];\\n    int minDiffSubset(vector<int>& stones, int n, int s1, int sum) {\\n        if(n == 0)\\n            return abs(sum-2*s1);\\n        \\n        if(t[n][s1] != -1)\\n            return t[n][s1];\\n        \\n        return t[n][s1] = min(minDiffSubset(stones, n-1, s1+stones[n-1], sum), //take\\n                              minDiffSubset(stones, n-1, s1, sum));            //don\\'t take\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        memset(t, -1, sizeof(t));\\n        int sum = accumulate(begin(stones), end(stones), 0);\\n        int n   = stones.size();\\n        return minDiffSubset(stones, n, 0, sum);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Bottom Up Dp)\\nclass Solution {\\npublic:\\n    int minDiffSubset(vector<int>& stones, int n, int sum) {\\n        vector<vector<bool>> t(n+1, vector<bool>(sum/2+1));\\n\\t\\t//It\\'s not possible to get a subset sum if we have 0 elements\\n        for(int col = 0; col<sum/2+1; col++)\\n            t[0][col] = false;\\n\\t\\t\\n\\t\\t//It\\'s always possible to get a subset sum 0 (i.e. empty subset)\\n        for(int row = 0; row<n+1; row++)\\n            t[row][0] = true;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            for(int j = 1; j<sum/2+1; j++) {\\n                if(stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j-stones[i-1]] || t[i-1][j];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int j = sum/2;\\n        while(j >= 0) {\\n            if(t[n][j])\\n                break;\\n            j--;\\n        }\\n        return sum-2*j;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(begin(stones), end(stones), 0);\\n        int n = stones.size();\\n        return minDiffSubset(stones, n, sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Recursion + Memo)\\nclass Solution {\\npublic:\\n    int t[31][5051];\\n    int minDiffSubset(vector<int>& stones, int n, int s1, int sum) {\\n        if(n == 0)\\n            return abs(sum-2*s1);\\n        \\n        if(t[n][s1] != -1)\\n            return t[n][s1];\\n        \\n        return t[n][s1] = min(minDiffSubset(stones, n-1, s1+stones[n-1], sum), //take\\n                              minDiffSubset(stones, n-1, s1, sum));            //don\\'t take\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        memset(t, -1, sizeof(t));\\n        int sum = accumulate(begin(stones), end(stones), 0);\\n        int n   = stones.size();\\n        return minDiffSubset(stones, n, 0, sum);\\n    }\\n};\\n```\n```\\n//Approach-2 (Bottom Up Dp)\\nclass Solution {\\npublic:\\n    int minDiffSubset(vector<int>& stones, int n, int sum) {\\n        vector<vector<bool>> t(n+1, vector<bool>(sum/2+1));\\n\\t\\t//It\\'s not possible to get a subset sum if we have 0 elements\\n        for(int col = 0; col<sum/2+1; col++)\\n            t[0][col] = false;\\n\\t\\t\\n\\t\\t//It\\'s always possible to get a subset sum 0 (i.e. empty subset)\\n        for(int row = 0; row<n+1; row++)\\n            t[row][0] = true;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            for(int j = 1; j<sum/2+1; j++) {\\n                if(stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j-stones[i-1]] || t[i-1][j];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int j = sum/2;\\n        while(j >= 0) {\\n            if(t[n][j])\\n                break;\\n            j--;\\n        }\\n        return sum-2*j;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(begin(stones), end(stones), 0);\\n        int n = stones.size();\\n        return minDiffSubset(stones, n, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859641,
                "title": "python3-dp-with-extensive-though-process-explanation-and-clean-code",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \"\"\"\\n        Main tricks here are to notice that:\\n        - Given stones = [y1, y2, x1, x2], let\\'s assume we pick y1 - x1 and y2 - x2 in a first pass. \\n        - The new stones array is [y1-x1, y2-x2] assuming that x1 and x2 vanished. Then in the second pass, we do (y1 - x1) - (y2 - x2) to get the final answer. \\n        - Note that we can re-write: (y1 - x1) - (y2 - x2) as (y1 + x2) - (y2 + x1).\\nWe now notice that what we want is two subarrays of stones that have minimum difference between their sums: min(sp1 - sp2)\\n        - Now note that we can write target = sum(stones) = sp1 + sp2. We can further write the min objective min(sp1 - sp2) = min((sp1 + sp2) - (sp2 + sp2)) = min(target - 2*sp2).\\n        - What value of sp2 will minimize this objective? sp2 = target // 2. So if we can partition the initial stones array into two subarrays of equal sum target // 2, then the final answer is the min = 0. \\n        - If this partitioning is not possible, partitioning so that sp2 is as close to target // 2 as possible will do.\\n        - Basically we can re-write the min objective min(target - 2 * sp2) = max(sp2) with constraint sp2 <= target // 2\\n        \"\"\"\\n        target = sum(stones)\\n        dp = [0] * (target // 2 + 1)\\n        \\n        for stonew in stones:\\n            for partition_sum in range(target // 2, 0, -1):\\n                if partition_sum >= stonew:\\n                    dp[partition_sum] = max(dp[partition_sum], dp[partition_sum - stonew] + stonew)\\n                    \\n        return target - 2* dp[target // 2]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \"\"\"\\n        Main tricks here are to notice that:\\n        - Given stones = [y1, y2, x1, x2], let\\'s assume we pick y1 - x1 and y2 - x2 in a first pass. \\n        - The new stones array is [y1-x1, y2-x2] assuming that x1 and x2 vanished. Then in the second pass, we do (y1 - x1) - (y2 - x2) to get the final answer. \\n        - Note that we can re-write: (y1 - x1) - (y2 - x2) as (y1 + x2) - (y2 + x1).\\nWe now notice that what we want is two subarrays of stones that have minimum difference between their sums: min(sp1 - sp2)\\n        - Now note that we can write target = sum(stones) = sp1 + sp2. We can further write the min objective min(sp1 - sp2) = min((sp1 + sp2) - (sp2 + sp2)) = min(target - 2*sp2).\\n        - What value of sp2 will minimize this objective? sp2 = target // 2. So if we can partition the initial stones array into two subarrays of equal sum target // 2, then the final answer is the min = 0. \\n        - If this partitioning is not possible, partitioning so that sp2 is as close to target // 2 as possible will do.\\n        - Basically we can re-write the min objective min(target - 2 * sp2) = max(sp2) with constraint sp2 <= target // 2\\n        \"\"\"\\n        target = sum(stones)\\n        dp = [0] * (target // 2 + 1)\\n        \\n        for stonew in stones:\\n            for partition_sum in range(target // 2, 0, -1):\\n                if partition_sum >= stonew:\\n                    dp[partition_sum] = max(dp[partition_sum], dp[partition_sum - stonew] + stonew)\\n                    \\n        return target - 2* dp[target // 2]",
                "codeTag": "Java"
            },
            {
                "id": 693314,
                "title": "why-won-t-a-greedy-solution-using-a-heap-work",
                "content": "Reading the problem statement, the first thing that came to my mind was to create a MAX heap of stones. Then, in each iteration take out the largest 2 stones and smash them. The result of the smash would be added to the heap.\\n\\nFollowing is the code I implemented. But, it passed for 74 / 82 test cases. The test case for which it failed for-\\n`[31,26,33,21,40]`\\n\\nCan somebody explain me why the greedy solution fails here? More importantly how do you conclude that a certain solution(especially greddy) is correct for the problem.\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int l = stones.size();\\n        if(l==0)return 0;\\n        if(l==1)return stones[0];\\n        \\n        priority_queue<int,vector<int>,less<int>> pq;\\n        for(auto& s:stones)\\n            pq.push(s);\\n        \\n        int a,b;\\n        while(!pq.empty()){\\n            a = pq.top();pq.pop();\\n            if(pq.empty())break;\\n            b = pq.top();pq.pop();\\n            a = a-b;\\n            if(a>0)pq.push(a);\\n        }\\n        return a;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int l = stones.size();\\n        if(l==0)return 0;\\n        if(l==1)return stones[0];\\n        \\n        priority_queue<int,vector<int>,less<int>> pq;\\n        for(auto& s:stones)\\n            pq.push(s);\\n        \\n        int a,b;\\n        while(!pq.empty()){\\n            a = pq.top();pq.pop();\\n            if(pq.empty())break;\\n            b = pq.top();pq.pop();\\n            a = a-b;\\n            if(a>0)pq.push(a);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558188,
                "title": "python-very-simple-recursion-memoization-solution-with-explanation",
                "content": "The secret for this question is in the hint.\\nPicking 2 stones x,y and calculating y-x is the same as summing all stones using positive or negative values (i.e. calculating the sum of every combination of + or - sign for each stone). \\nThis is trivial to solve with backtracking (recursion). Unfortunately, the time complexity is exponential O(2^n) but we can speed it up a bit using memoization.\\n\\n```\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        def dp(i, s): #arguments are stone index and current sum\\n            if i == len(stones): #end of array, return the current sum (abs)\\n                return abs(s)\\n            if (i,s) not in memo:\\n                memo[(i,s)] = min(dp(i+1,s+stones[i]),dp(i+1,s-stones[i])) #try summing or subtracting each stone value\\n            return memo[(i,s)]\\n        \\n        memo = {}\\n        return dp(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        def dp(i, s): #arguments are stone index and current sum\\n            if i == len(stones): #end of array, return the current sum (abs)\\n                return abs(s)\\n            if (i,s) not in memo:\\n                memo[(i,s)] = min(dp(i+1,s+stones[i]),dp(i+1,s-stones[i])) #try summing or subtracting each stone value\\n            return memo[(i,s)]\\n        \\n        memo = {}\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295130,
                "title": "java-iterative",
                "content": "+stones[i] or -stones[i], iterator until all stones has added.\\n\\nFor [1,2,3,6] as example:\\nthe smallest result could be the +1+2+3-6 = 0, we could not only smash 6 since it is the biggest weight.\\nbut it equivalent to -1-2-3+6, which means \\n1.smash (6,1) = 5\\n2.smash((6,1), 2) = 3\\n3.smash(((6,1), 2), 3) = 0\\n\\n```\\npublic int lastStoneWeightII(int[] stones) {\\n        Set<Integer> set = new HashSet<>();\\n        set.add(stones[0]);\\n        set.add(-stones[0]);\\n        for(int i=1;i<stones.length;i++){\\n            Set<Integer> set2 = new HashSet<>();\\n            for(int item : set){\\n                set2.add(item + stones[i]);\\n                set2.add(item - stones[i]);\\n            }\\n            set = set2;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int item : set) min = Math.min(Math.abs(item), min);\\n        return min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lastStoneWeightII(int[] stones) {\\n        Set<Integer> set = new HashSet<>();\\n        set.add(stones[0]);\\n        set.add(-stones[0]);\\n        for(int i=1;i<stones.length;i++){\\n            Set<Integer> set2 = new HashSet<>();\\n            for(int item : set){\\n                set2.add(item + stones[i]);\\n                set2.add(item - stones[i]);\\n            }\\n            set = set2;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int item : set) min = Math.min(Math.abs(item), min);\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652169,
                "title": "c-recursion-memoization-clean-code",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/432175da-6447-4694-8f49-34187b5b3d22_1664733371.5316546.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stackspace]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int val,vector<int>& st,int n){ \\n\\t\\t\\t\\tif(i==n){\\n\\t\\t\\t\\t\\tif(val<0) return 1e9;\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint pos= st[i]+f(i+1,val+st[i],st,n);\\n\\t\\t\\t\\tint neg= -st[i]+f(i+1,val-st[i],st,n);\\n\\t\\t\\t\\treturn min(pos,neg);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint lastStoneWeightII(vector<int>& st) {\\n\\t\\t\\t\\tint n=st.size();\\n\\t\\t\\t\\treturn f(0,0,st,n);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n# Method - 2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/d55483e6-32c0-4d60-9587-872e0bbd083a_1664734339.1050684.png)\\n\\n**T->O(6000 x n) && S->O(6000 x n) + O(n) [Recursion stackspace]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int val,vector<int>& st,int n,vector<vector<int>>& dp){ \\n\\t\\t\\tif(i==n){\\n\\t\\t\\t\\tif(val<0) return 1e9;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][val+3000]!=-1) return dp[i][val+3000];\\n\\t\\t\\tint pos= st[i]+f(i+1,val+st[i],st,n,dp);\\n\\t\\t\\tint neg= -st[i]+f(i+1,val-st[i],st,n,dp);\\n\\t\\t\\treturn dp[i][val+3000]=min(pos,neg);\\n\\t\\t}\\n\\n\\t\\tint lastStoneWeightII(vector<int>& st) {\\n\\t\\t\\tint n=st.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(6000,-1));\\n\\t\\t\\treturn f(0,0,st,n,dp);\\n\\t\\t}\\n\\t};\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int val,vector<int>& st,int n){ \\n\\t\\t\\t\\tif(i==n){\\n\\t\\t\\t\\t\\tif(val<0) return 1e9;\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1445462,
                "title": "python-dp-memoization-minimumm-subset-sum-difference",
                "content": "This problem can be translated to a minimum subset sum difference problem.\\na.k.a we want to split the stones into two set whoses weight sum difference is minimum.\\n\\nIf we can get a recursive implementation, it is easy to convert to a memoization question.\\nFirst let\\'s get a brute force recursive implementation.\\nEach stone will either add to first set or second set, we need to find all possible ways and get the optimal solution.\\n\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n\\t\"\"\"\\n\\tTime: O(2^N)\\n\\t\"\"\"\\n        return self.recursive(stones, 0, 0, 0)\\n\\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n\\t\\t\\n\\t\\t# Each stone will either add to first set or second set. \\n        diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n        diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n\\n        return min(diff_1, diff_2)\\n```\\n\\n\\nNow let\\'s move to second part, translate the recursive code to memoization. \\nWhile most people use memoization to describe this kind of solution, it is basically using a cache.\\n\\n\\nThe idea of memoization is caching.\\nWe need to figure out 3 things\\n1. What\\'s the key and value of cache\\n2. When to set cache key\\n3. When to get cache key\\n\\nIn fact the key will be the method signatures that we pass to the recursive function, and the value the the difference.\\nTherfore we need something like\\n```\\ncache[index][sum1][sum2] = diff\\n```\\n\\nAlthough dp usually use array or multi dimensional arrays, they are just special case of hashmap whose key is integer.\\n\\nWe can simplfiy our cache\\nto \\n```\\ncache[index][sum1#sum2] = diff\\n```\\nor \\n```\\ncache[index#sum1#sum2] = diff\\n```\\n\\n\\nIf we look at the codes below, you can find it how easy to translate a brute force implementaion by using cache.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        self.cache = [{} for i in range(len(stones) + 1)]  # key: index,  value is another map\\n        return self.recursive(stones, 0, 0, 0)\\n\\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n\\n        key = str(sum_1)+\\'#\\' + str(sum_2)  # get key\\n\\t\\t\\n        if key not in self.cache[index]:\\n            diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n            diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n            self.cache[index][key] = min(diff_1, diff_2) # set value\\n\\n        return self.cache[index][key]  # get value\\n```\\n\\nor \\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        self.cache = {}\\n        \\n        return self.recursive(stones, 0, 0, 0)\\n    \\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n        key = str(index) + \\'#\\' + str(sum_1)+\\'#\\'+ str(sum_2)\\n        if  key not in self.cache:\\n            diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n            diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n            self.cache[key] = min(diff_1, diff_2)\\n        \\n        return self.cache[key] \\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n\\t\"\"\"\\n\\tTime: O(2^N)\\n\\t\"\"\"\\n        return self.recursive(stones, 0, 0, 0)\\n\\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n\\t\\t\\n\\t\\t# Each stone will either add to first set or second set. \\n        diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n        diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n\\n        return min(diff_1, diff_2)\\n```\n```\\ncache[index][sum1][sum2] = diff\\n```\n```\\ncache[index][sum1#sum2] = diff\\n```\n```\\ncache[index#sum1#sum2] = diff\\n```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        self.cache = [{} for i in range(len(stones) + 1)]  # key: index,  value is another map\\n        return self.recursive(stones, 0, 0, 0)\\n\\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n\\n        key = str(sum_1)+\\'#\\' + str(sum_2)  # get key\\n\\t\\t\\n        if key not in self.cache[index]:\\n            diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n            diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n            self.cache[index][key] = min(diff_1, diff_2) # set value\\n\\n        return self.cache[index][key]  # get value\\n```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        self.cache = {}\\n        \\n        return self.recursive(stones, 0, 0, 0)\\n    \\n    def recursive(self, stones: List[int], index:int, sum_1, sum_2):\\n        if index == len(stones):\\n            return abs(sum_1 - sum_2)\\n        key = str(index) + \\'#\\' + str(sum_1)+\\'#\\'+ str(sum_2)\\n        if  key not in self.cache:\\n            diff_1 = self.recursive(stones, index+1, sum_1 + stones[index], sum_2)\\n            diff_2 = self.recursive(stones, index+1, sum_1, sum_2 + stones[index])\\n            self.cache[key] = min(diff_1, diff_2)\\n        \\n        return self.cache[key] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331314,
                "title": "very-very-simple-explanation-with-easy-proof-and-python3-code",
                "content": "stones = [a,b,c,d]\\n\\nlets assume optimal way to smash stones is first smash d and c, new stones becomes d-c then smash new stone with b, new stone becomes b-**(d-c)** then smash with a, last stone becomes **(b-(d-c))**-a\\n\\nsimplifying equation becomes :\\n(b+c) - (d+a), and we want to minimize this.\\n\\ninstead of previous way lets assume optimal way to smash stones is first smash d and a, new stones becomes d-a, then smash c and b, new stone becomes (c-b) then smash both new stones, last stone becomes (b-c) - (d-a)\\n\\nsimplifying equation becomes :\\n(b+a) - (c+d), and we want to minimize this.\\n\\nso problem essentiantly becomes :-\\n**divide the given set into two subsets such that difference between their sum in minimmum**.\\n\\nwhich is easier to solve.\\n\\n**Approach** : \\n\\nwe have to divide it into two parts, focus on the smaller part (sum wise), just like subset sum problem we will try to find all possible sum we can form for this part, upto sum(stones)//2, because smaller part\\'s sum will not exceed sum(stones)//2.\\n\\nthen optimal sum for this part is that which is closest to sum(stones)//2, and sum for other part is sum(stones) - sum_part_1\\nso ans = sum_part_2 - sum_part_1\\n\\nhere is the **python code** :-\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        req=sum(stones)//2\\n        \\n        dp=[False for i in range(req+1)]\\n        dp[0]=True\\n        \\n        for s in stones:\\n            for i in range(req,-1,-1):\\n                if i-s>=0 and dp[i-s]==True:\\n                    dp[i]=True\\n           \\n        for i in range(req,-1,-1):\\n            if dp[i]==True:\\n                return sum(stones)-2*i\\n            \\n```\\n\\n**Do upvote** if you feel like it, and comment for any doubts. \\nhappy coding :-)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        req=sum(stones)//2\\n        \\n        dp=[False for i in range(req+1)]\\n        dp[0]=True\\n        \\n        for s in stones:\\n            for i in range(req,-1,-1):\\n                if i-s>=0 and dp[i-s]==True:\\n                    dp[i]=True\\n           \\n        for i in range(req,-1,-1):\\n            if dp[i]==True:\\n                return sum(stones)-2*i\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 811106,
                "title": "a-dp-solution-with-1-d-dp-matrix",
                "content": "The question is based on 0-1 Knapsack algorithm. \\n\\nLets divide the whole array into two subarrays *A1* and *A2* such that in each iteration, we choose one element of A1 and another of A2 and perform the operation. \\n\\nImagine that we have [2 , 3, 4, 5] as input.\\nLet A1= [2, 3] and A2 = [4, 5]. \\nThen after two operations, we have\\nA1= [0,0], A2 = [2,2]. \\nNow we subtract one element of A2 from the other to get answer as 0. \\n\\nLets now say that since 4- 2 = 5- 3, if we have to reduce the difference betwen sum of elements in each subarrays after all the operations, thenwe swap 2 with 4 andget A1 = [0,0] and A2 = [0,0] after the two operations.\\n\\nSo our problem reduces to finding two subarrays A1 , A2 (A1 union A2 = A), such that the difference between the sum of elements in A1 and A2 is minimum.\\n\\nS1 = sum of elements in A1\\nS2 = sum of elements in A2\\n\\nS1 + S2 = total sum\\nS2 - S1 = difference\\n\\nsubtracting (2) from (1), \\n2*S1 = total - diff\\nthat is diff = total - 2*S1\\n\\nSince we are seeking the difference which is non-negative, without loss of generality S1<= S2. \\n\\nIn the best case diff = 0 = total - 2* S1\\nSo we iterate from 0 to total/2 and find the maximum sum possible with a subarray of weights.\\n\\ndp[i] represents whether the weight i can be found using some elements of the input array.\\n\\n        int total = 0;\\n        for(auto x: stones){\\n            total += x; \\n        }\\n        \\n        vector<bool> dp(total/2 + 1, false);\\n        dp[0] = true;\\n        \\n        for(auto i : stones){\\n            for(int j = total/2 - i ; j >= 0; j-- ){\\n                if(dp[j]){\\n                    dp[j + i] = true;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0; \\n        for(int i = 0; i<=total/2 ; i++){\\n            if(dp[i] == true){\\n                ans = i;\\n            }\\n        }\\n        \\n        return total - 2*ans;\\n\\t\\t\\n\\t\\t",
                "solutionTags": [],
                "code": "The question is based on 0-1 Knapsack algorithm. \\n\\nLets divide the whole array into two subarrays *A1* and *A2* such that in each iteration, we choose one element of A1 and another of A2 and perform the operation. \\n\\nImagine that we have [2 , 3, 4, 5] as input.\\nLet A1= [2, 3] and A2 = [4, 5]. \\nThen after two operations, we have\\nA1= [0,0], A2 = [2,2]. \\nNow we subtract one element of A2 from the other to get answer as 0. \\n\\nLets now say that since 4- 2 = 5- 3, if we have to reduce the difference betwen sum of elements in each subarrays after all the operations, thenwe swap 2 with 4 andget A1 = [0,0] and A2 = [0,0] after the two operations.\\n\\nSo our problem reduces to finding two subarrays A1 , A2 (A1 union A2 = A), such that the difference between the sum of elements in A1 and A2 is minimum.\\n\\nS1 = sum of elements in A1\\nS2 = sum of elements in A2\\n\\nS1 + S2 = total sum\\nS2 - S1 = difference\\n\\nsubtracting (2) from (1), \\n2*S1 = total - diff\\nthat is diff = total - 2*S1\\n\\nSince we are seeking the difference which is non-negative, without loss of generality S1<= S2. \\n\\nIn the best case diff = 0 = total - 2* S1\\nSo we iterate from 0 to total/2 and find the maximum sum possible with a subarray of weights.\\n\\ndp[i] represents whether the weight i can be found using some elements of the input array.\\n\\n        int total = 0;\\n        for(auto x: stones){\\n            total += x; \\n        }\\n        \\n        vector<bool> dp(total/2 + 1, false);\\n        dp[0] = true;\\n        \\n        for(auto i : stones){\\n            for(int j = total/2 - i ; j >= 0; j-- ){\\n                if(dp[j]){\\n                    dp[j + i] = true;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0; \\n        for(int i = 0; i<=total/2 ; i++){\\n            if(dp[i] == true){\\n                ans = i;\\n            }\\n        }\\n        \\n        return total - 2*ans;\\n\\t\\t\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 974638,
                "title": "c-easy-understanding-complete-explanation",
                "content": "```c++\\nint lastStoneWeightII(vector<int>& stones) {\\n    /*\\n        To understand the problem, here is my intuition\\n        Forget about stones colliding, we have numbers and we should put + and - in the right places\\n        to get the minimum number in the end.\\n\\n        What is the minimum number(at the end) possible?\\n        -> 0\\n\\n        What should be the condition to get zero as the end result?\\n        -> let\\'s say we have an array like [1,5,11,5] which can be split into two sets of equal sum\\n            set1 = {5, 5, 1} set2 = {11} sum of both these set is 11 so if we put all \\'-\\' to one of the set\\n            we get 0\\n            5 + 5 + 1 - 11\\n\\n        How is that related to this problem?\\n        -> We are asked to minimize the end result, so if we are able to get two sets with minimum difference\\n           that should give us the result.\\n\\n        How to get the sets?\\n        -> Our end result would be S1 - S2, which is sum of set1 - sum of set2. In the ideal case S1 == S2\\n           The Ideal case would be equal partition and also thing to notice here is, if it is ideal case then\\n            totalSum = 2 * S2 in other terms S2 = totalSum/2;\\n        -> We should try to choose elements whose sum is close to(ideally equal to) totalSum/2.\\n        -> S1 = totalSum - S2; \\n        -> diff = S1 - S2; in other terms diff = totalSum - (2 * S2); diff should be our end result\\n    */\\n\\n    int totalSum = accumulate(stones.begin(), stones.end(), totalSum);\\n    int target = totalSum/2, n = stones.size();\\n\\n    vector<int> dp(target+1, 0);\\n\\n    for(int stone: stones)\\n        for(int j = target; j >=stone; j--)\\n            dp[j] = max(dp[j] , stone + dp[j - stone]);\\n\\n    return totalSum - 2 * dp[target];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nint lastStoneWeightII(vector<int>& stones) {\\n    /*\\n        To understand the problem, here is my intuition\\n        Forget about stones colliding, we have numbers and we should put + and - in the right places\\n        to get the minimum number in the end.\\n\\n        What is the minimum number(at the end) possible?\\n        -> 0\\n\\n        What should be the condition to get zero as the end result?\\n        -> let\\'s say we have an array like [1,5,11,5] which can be split into two sets of equal sum\\n            set1 = {5, 5, 1} set2 = {11} sum of both these set is 11 so if we put all \\'-\\' to one of the set\\n            we get 0\\n            5 + 5 + 1 - 11\\n\\n        How is that related to this problem?\\n        -> We are asked to minimize the end result, so if we are able to get two sets with minimum difference\\n           that should give us the result.\\n\\n        How to get the sets?\\n        -> Our end result would be S1 - S2, which is sum of set1 - sum of set2. In the ideal case S1 == S2\\n           The Ideal case would be equal partition and also thing to notice here is, if it is ideal case then\\n            totalSum = 2 * S2 in other terms S2 = totalSum/2;\\n        -> We should try to choose elements whose sum is close to(ideally equal to) totalSum/2.\\n        -> S1 = totalSum - S2; \\n        -> diff = S1 - S2; in other terms diff = totalSum - (2 * S2); diff should be our end result\\n    */\\n\\n    int totalSum = accumulate(stones.begin(), stones.end(), totalSum);\\n    int target = totalSum/2, n = stones.size();\\n\\n    vector<int> dp(target+1, 0);\\n\\n    for(int stone: stones)\\n        for(int j = target; j >=stone; j--)\\n            dp[j] = max(dp[j] , stone + dp[j - stone]);\\n\\n    return totalSum - 2 * dp[target];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955251,
                "title": "dp-using-minimum-subset-sum-difference",
                "content": "*         we need to calculate all the possible subsequence sums\\n*         then find the difference between each possible sum to find the minimum difference\\n*         possible sum can be found by (subsequence sum equals a given target)\\n*         possible subsequence sum (s1) and (s2) needs to be found such that absolute difference : |s1 - s2| is minimum\\n*         lets assume s1 < s2 in the range of potential sum results we only consider s1 < totalSum/2 and s2 > totalSum/2\\n*         hence for ex: totalSum = 23; then s1 < 11 and s2 > 11\\n*         so we need to find all s1\\'s such that (totalSum - 2*s1) is minimum\\n\\n```\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        boolean[][] t = subsequenceSum(stones);\\n        final int totalSum = IntStream.of(stones).sum();\\n        final int N = stones.length;\\n        \\n        int diff = Integer.MAX_VALUE;\\n        \\n        int k = 0;\\n        int mid = totalSum/2;\\n        while(k <= mid) {\\n            if( t [ N ] [ k ] ) {\\n                int currDiff = (totalSum - 2*k);\\n                diff = Math.min(diff, (currDiff));\\n            }\\n            k++;\\n        }\\n        return diff;\\n    }\\n    \\n    private boolean[][] subsequenceSum(int[] stones) {\\n        final int totalSum = IntStream.of(stones).sum();\\n        boolean[][] t = new boolean[stones.length+1][totalSum+1];\\n        initialize(t);\\n        \\n        for (int i=1; i<t.length; i++) {\\n            for (int j=1; j<t[0].length; j++) {\\n                if (stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j] || t[i-1][j-(stones[i-1])];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }   \\n        }\\n        return t;\\n    }\\n    \\n    private void initialize(boolean[][] t) {\\n        for (int j = 0; j<t[0].length; j++) {t[0][j] = false;}\\n        for (int i = 0; i<t.length; i++) {t[i][0] = true;}\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        boolean[][] t = subsequenceSum(stones);\\n        final int totalSum = IntStream.of(stones).sum();\\n        final int N = stones.length;\\n        \\n        int diff = Integer.MAX_VALUE;\\n        \\n        int k = 0;\\n        int mid = totalSum/2;\\n        while(k <= mid) {\\n            if( t [ N ] [ k ] ) {\\n                int currDiff = (totalSum - 2*k);\\n                diff = Math.min(diff, (currDiff));\\n            }\\n            k++;\\n        }\\n        return diff;\\n    }\\n    \\n    private boolean[][] subsequenceSum(int[] stones) {\\n        final int totalSum = IntStream.of(stones).sum();\\n        boolean[][] t = new boolean[stones.length+1][totalSum+1];\\n        initialize(t);\\n        \\n        for (int i=1; i<t.length; i++) {\\n            for (int j=1; j<t[0].length; j++) {\\n                if (stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j] || t[i-1][j-(stones[i-1])];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }   \\n        }\\n        return t;\\n    }\\n    \\n    private void initialize(boolean[][] t) {\\n        for (int j = 0; j<t[0].length; j++) {t[0][j] = false;}\\n        for (int i = 0; i<t.length; i++) {t[i][0] = true;}\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 778403,
                "title": "javascript-solution-top-down-approach-with-memoization-and-bottom-up-approach-dp",
                "content": "**Top Down Approach with Memoization**\\n\\n```\\nvar lastStoneWeightII = function(stones) {\\n    const memo = new Map();\\n    return findMinWeight(0, 0, 0);\\n    \\n    function findMinWeight(index, weight1, weight2) {\\n        const key = `${index}#${weight1}#${weight2}`;\\n        \\n        // base case\\n        if (index == stones.length) return Math.abs(weight1 - weight2);\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        const currWeight = stones[index];\\n        const min =  Math.min(\\n            findMinWeight(index + 1, weight1 + currWeight, weight2), \\n            findMinWeight(index + 1, weight1, weight2 + currWeight\\n        ));\\n        \\n        memo.set(key, min);\\n        return min;\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n<br>\\n\\n**Bottom Up Approach (DP)**\\n\\n```\\nvar lastStoneWeightII = function(stones) {\\n    const m = stones.length;\\n    \\n    let sum = 0;\\n    \\n    for (const weight of stones) {\\n        sum += weight;\\n    }\\n    \\n    const half = Math.floor(sum / 2);\\n    \\n    const dp = [];\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i] = new Array(half + 1).fill(false);\\n        dp[i][0] = true;\\n    }\\n    \\n    let max = 0;\\n    \\n    for (let i = 1; i <= m; i++) {\\n        const weight = stones[i - 1];\\n        \\n        for (let j = 1; j <= half; j++) {\\n            const rem = j - weight;\\n        \\n            if (rem >= 0 && dp[i - 1][rem] == true) dp[i][j] = true;\\n            else dp[i][j] = dp[i - 1][j];\\n            \\n            if (dp[i][j] == true) max = Math.max(max, j);\\n        }\\n    }\\n    \\n    return sum - (2 * max);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar lastStoneWeightII = function(stones) {\\n    const memo = new Map();\\n    return findMinWeight(0, 0, 0);\\n    \\n    function findMinWeight(index, weight1, weight2) {\\n        const key = `${index}#${weight1}#${weight2}`;\\n        \\n        // base case\\n        if (index == stones.length) return Math.abs(weight1 - weight2);\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        const currWeight = stones[index];\\n        const min =  Math.min(\\n            findMinWeight(index + 1, weight1 + currWeight, weight2), \\n            findMinWeight(index + 1, weight1, weight2 + currWeight\\n        ));\\n        \\n        memo.set(key, min);\\n        return min;\\n    }\\n};\\n```\n```\\nvar lastStoneWeightII = function(stones) {\\n    const m = stones.length;\\n    \\n    let sum = 0;\\n    \\n    for (const weight of stones) {\\n        sum += weight;\\n    }\\n    \\n    const half = Math.floor(sum / 2);\\n    \\n    const dp = [];\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i] = new Array(half + 1).fill(false);\\n        dp[i][0] = true;\\n    }\\n    \\n    let max = 0;\\n    \\n    for (let i = 1; i <= m; i++) {\\n        const weight = stones[i - 1];\\n        \\n        for (let j = 1; j <= half; j++) {\\n            const rem = j - weight;\\n        \\n            if (rem >= 0 && dp[i - 1][rem] == true) dp[i][j] = true;\\n            else dp[i][j] = dp[i - 1][j];\\n            \\n            if (dp[i][j] == true) max = Math.max(max, j);\\n        }\\n    }\\n    \\n    return sum - (2 * max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612241,
                "title": "c-easy-to-understand-top-down-approach-recursive",
                "content": "```\\n// at every point,  we have two choices it will be -ve or +ve\\nclass Solution {\\n    map<pair<int,int>, int> dp;\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        dp.clear();\\n        return solve(stones, 0, stones.size(), 0);\\n    }\\n    int solve(vector<int>&a, int i, int n, int sum) {\\n        if(i >= n) {\\n            return abs(sum);\\n        }\\n        if(dp.find({i,sum}) != dp.end()) return dp[{i,sum}];\\n        \\n        int ans = INT_MAX;\\n        ans = min(ans, solve(a, i + 1, n , sum - a[i]));\\n        ans = min(ans, solve(a, i + 1, n , sum + a[i]));\\n        return dp[{i,sum}] = ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// at every point,  we have two choices it will be -ve or +ve\\nclass Solution {\\n    map<pair<int,int>, int> dp;\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        dp.clear();\\n        return solve(stones, 0, stones.size(), 0);\\n    }\\n    int solve(vector<int>&a, int i, int n, int sum) {\\n        if(i >= n) {\\n            return abs(sum);\\n        }\\n        if(dp.find({i,sum}) != dp.end()) return dp[{i,sum}];\\n        \\n        int ans = INT_MAX;\\n        ans = min(ans, solve(a, i + 1, n , sum - a[i]));\\n        ans = min(ans, solve(a, i + 1, n , sum + a[i]));\\n        return dp[{i,sum}] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616167,
                "title": "python-make-two-subsets-and-distribute",
                "content": "I looked at each element and added it either to subset 1 ```s1``` or subset 2 ```s2```.\\nWhen the array was exhausted, I return the absolute difference between the two.\\nThe function that called the base-case-hitting function chooses the minimum.\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def recurse(idx, s1, s2):\\n            if idx == len(stones):\\n                return abs(s1 - s2)\\n            a = recurse(idx + 1, s1 + stones[idx], s2)\\n            b = recurse(idx + 1, s1, s2 + stones[idx])\\n            return min(a, b)\\n        return recurse(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```s1```\n```s2```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def recurse(idx, s1, s2):\\n            if idx == len(stones):\\n                return abs(s1 - s2)\\n            a = recurse(idx + 1, s1 + stones[idx], s2)\\n            b = recurse(idx + 1, s1, s2 + stones[idx])\\n            return min(a, b)\\n        return recurse(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629918,
                "title": "attempt-to-explain-the-dp-solution",
                "content": "The idea is to split the stones into 2 groups such that sum(grp 1)-sum(grp2) is minimum.\\n\\nWHY???\\n\\nsuppose stones are (a b c d)\\n(a>b>c>d)\\nyou break a and b first...\\na-b c d\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nbreak c and d now                                                                                           \\na-b c-d                                                                                                                                                    \\nsuppose a-b>c-d                                                                                            \\nnow break both                                                                                              \\na-b-(c-d)=(a+d)-(b+c)           \\n\\n\\nif u broke in some other order\\n\\na b c d\\na-b c d\\na-b-c d\\na-b-c-d=a-(b+c+d)\\n\\npoint being...in the end final result is basically sum(grp1)-sum(grp2)\\n\\nTo get all possible sums--\\n```\\n        vector<int> dp(3001,0);\\n\\t\\t//getting sum 0 is possible(take no elements)\\n\\t\\tdp[0]=1;\\n        for (int a : A) {\\n            sum+= a;\\n            for (int i = sum; i >= a; --i)\\n\\t\\t\\t//since if sum \\'i-a\\' is possible...sum i is also possible as \\'a\\' i an element..classic dp\\n                dp[i] = dp[i]+dp[i - a];\\n        }\\n```\\nnow idea sum of grp1 is sum/2...so that difference becomes zero...so try from sum/2 to 0 and return the first possible sum found along the way.\\n\\nWHAT TO RETURN???\\n\\nsum of group1=i\\nsum of group 2=sum-i\\nsum(group2)>sum(group1)\\nSOOO return sum-i-i.\\n```\\n\\tfor (int i = sum / 2; i >= 0; --i)\\n\\t{\\n        if (dp[i]) return sum - i - i;\\n    }\\n```\\nHope i could help!\\n\\n",
                "solutionTags": [],
                "code": "```\\n        vector<int> dp(3001,0);\\n\\t\\t//getting sum 0 is possible(take no elements)\\n\\t\\tdp[0]=1;\\n        for (int a : A) {\\n            sum+= a;\\n            for (int i = sum; i >= a; --i)\\n\\t\\t\\t//since if sum \\'i-a\\' is possible...sum i is also possible as \\'a\\' i an element..classic dp\\n                dp[i] = dp[i]+dp[i - a];\\n        }\\n```\n```\\n\\tfor (int i = sum / 2; i >= 0; --i)\\n\\t{\\n        if (dp[i]) return sum - i - i;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305770,
                "title": "c-easy-understanding-solution-recursion-memoization",
                "content": "**this problem is similar as minimum diffrence b/w two partiton of array**\\n```\\nclass Solution {\\npublic:\\n    int dp[31][3001];\\n    int solve(vector<int>& s,int idx,int a,int b)\\n    {\\n        int diff=abs(a-b);\\n        \\n        if(idx==s.size())\\n            return diff ;\\n        \\n        if(dp[idx][diff]!=-1)\\n            return dp[idx][diff];\\n        \\n        int k=min(solve(s,idx+1,a+s[idx],b),solve(s,idx+1,a,b+s[idx]));\\n        \\n        return dp[idx][diff]=k;\\n    }\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(stones,0,0,0);\\n    }\\n};\\n//feel free to ask any doubt in comment section . it\\'s a good problem;\\n//if you like the solution then please upvote it :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[31][3001];\\n    int solve(vector<int>& s,int idx,int a,int b)\\n    {\\n        int diff=abs(a-b);\\n        \\n        if(idx==s.size())\\n            return diff ;\\n        \\n        if(dp[idx][diff]!=-1)\\n            return dp[idx][diff];\\n        \\n        int k=min(solve(s,idx+1,a+s[idx],b),solve(s,idx+1,a,b+s[idx]));\\n        \\n        return dp[idx][diff]=k;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1429005,
                "title": "python-one-dimensional-dp-solution-minimum-subset-difference-0-1-knapsack",
                "content": "A variation of the classical knapsack problem, the idea here is that we have to find a subset such that it\\'s sum is less than or equal to the half of the sum of the entire array. Only then will the difference of the two resulting subsets be minimum. In other words -\\n\\n\\t\\tsum(any_one_subset)  <= sum(given_array)\\n\\t\\t\\nOnce we have found this sum, the answer will simply be the twice of the subset sum subtracted from the total sum. Here\\'s the simple maths -\\n\\t\\t\\n\\t\\tsum(subset1) + sum(subset2) = sum(given_array)\\n\\t\\tsum(subset2) = sum(given_array) - sum(subset1) \\n\\t\\t\\nSo, using this relation - \\n\\t\\t\\n\\t\\t=> ans = sum(subset2) - sum(subset1)\\n\\t\\t=> ans = sum(given_array) - sum(subset1) - sum(subset1)\\n\\t\\t=> ans = sum(given_array) - sum(subset1)*2 ---------------> ANSWER\\n\\t\\t\\nSo now the problem is reduced to the following statement, how to find a subset such that it\\'s sum is less than or equal to half of the sum of given array? We will use simple knapsack logic, where the total capacity is half of the sum of given array and values of the elements are equal to their corresponding weights, i.e. the values and weights are one and the same thing. Below is the implementation in the form of a one dimensional dp array, hope this was useful!\\t\\n\\t\\n```class Solution(object):\\n    def lastStoneWeightII(self, stones):\\n\\t\\n        req = sum(stones)//2        \\n        dp = [0 for i in range(req+1)]\\n        \\n        for nums in stones:\\n            for w in range(req, nums-1, -1): \\n\\t\\t\\t\\tdp[w] = max(dp[w], dp[w-nums] + nums)\\n                \\n        return sum(stones) - 2*dp[req]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "A variation of the classical knapsack problem, the idea here is that we have to find a subset such that it\\'s sum is less than or equal to the half of the sum of the entire array. Only then will the difference of the two resulting subsets be minimum. In other words -\\n\\n\\t\\tsum(any_one_subset)  <= sum(given_array)\\n\\t\\t\\nOnce we have found this sum, the answer will simply be the twice of the subset sum subtracted from the total sum. Here\\'s the simple maths -\\n\\t\\t\\n\\t\\tsum(subset1) + sum(subset2) = sum(given_array)\\n\\t\\tsum(subset2) = sum(given_array) - sum(subset1) \\n\\t\\t\\nSo, using this relation - \\n\\t\\t\\n\\t\\t=> ans = sum(subset2) - sum(subset1)\\n\\t\\t=> ans = sum(given_array) - sum(subset1) - sum(subset1)\\n\\t\\t=> ans = sum(given_array) - sum(subset1)*2 ---------------> ANSWER\\n\\t\\t\\nSo now the problem is reduced to the following statement, how to find a subset such that it\\'s sum is less than or equal to half of the sum of given array? We will use simple knapsack logic, where the total capacity is half of the sum of given array and values of the elements are equal to their corresponding weights, i.e. the values and weights are one and the same thing. Below is the implementation in the form of a one dimensional dp array, hope this was useful!\\t\\n\\t\\n```class Solution(object):\\n    def lastStoneWeightII(self, stones):\\n\\t\\n        req = sum(stones)//2        \\n        dp = [0 for i in range(req+1)]\\n        \\n        for nums in stones:\\n            for w in range(req, nums-1, -1): \\n\\t\\t\\t\\tdp[w] = max(dp[w], dp[w-nums] + nums)\\n                \\n        return sum(stones) - 2*dp[req]",
                "codeTag": "Java"
            },
            {
                "id": 1321918,
                "title": "c-knapsack-problem-beat-100-with-explanation",
                "content": "This question equals to partition an array into 2 subsets so that their sum difference is minimum.\\nSuppose given stones array is [a,b,c,d]\\nif we select a and c stone new array=[a-c,b,d]\\nsimilarly array will change to ==> [b-a+c,d]==>[d-b+a-c]==>[(a+d)-(b+c)]==>s1-s2.\\ns1 + s2  = sum, \\ns1 - s2 = difference \\ndifference = s - 2 * s2 \\nminimize difference equals to maximize s2 \\nWe have to find s2 maximum valid value between 0 and s/2.\\n**Using 2d dp array**\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=stones[i];\\n        }\\n        int maxs=0;\\n        vector<vector<bool>> dp(n+1,vector<bool> (s/2+1,false));\\n        dp[0][0]=true;\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=s/2;j++){\\n                dp[i][j]=dp[i-1][j];\\n                if(j>=stones[i-1]){\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                if(dp[i][j]==true){\\n                    maxs=max(maxs,j);\\n                }\\n            }\\n        }\\n        return s-2*maxs;\\n        \\n    }\\n};\\n```\\n\\n**Using 1d dp array**\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=stones[i];\\n        }\\n        int maxs=0;\\n        vector<bool> dp(s/2+1,false);\\n        dp[0]=true;\\n        for(int i=0;i<n;i++){\\n            for(int j=s/2;j>=stones[i];j--){\\n                dp[j]=dp[j] || dp[j-stones[i]];\\n                if(dp[j]==true){\\n                    maxs=max(maxs,j);\\n                }\\n            }\\n        }\\n        return s-2*maxs;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=stones[i];\\n        }\\n        int maxs=0;\\n        vector<vector<bool>> dp(n+1,vector<bool> (s/2+1,false));\\n        dp[0][0]=true;\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=s/2;j++){\\n                dp[i][j]=dp[i-1][j];\\n                if(j>=stones[i-1]){\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                if(dp[i][j]==true){\\n                    maxs=max(maxs,j);\\n                }\\n            }\\n        }\\n        return s-2*maxs;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=stones[i];\\n        }\\n        int maxs=0;\\n        vector<bool> dp(s/2+1,false);\\n        dp[0]=true;\\n        for(int i=0;i<n;i++){\\n            for(int j=s/2;j>=stones[i];j--){\\n                dp[j]=dp[j] || dp[j-stones[i]];\\n                if(dp[j]==true){\\n                    maxs=max(maxs,j);\\n                }\\n            }\\n        }\\n        return s-2*maxs;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065553,
                "title": "c-dp-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    Let\\'s take an example with stones = [a,b,c,d], such that the optimal solution has the following operations:\\n    x = a - b -> stones = [x, c, d]\\n    y = c - d -> stones = [x, y]\\n    z = x - y -> stones = [z], where z is the smallest possible weight.\\n\\n    We can then write the optimal solution z in the following form:\\n    z = x - y = a - b - (c - d) = (a + d) - (b + c)\\n    This leads us to observe that we can write any optimal solution as the difference between two sums. In this case:\\n    X = a + d\\n    Y = b + c\\n    So we have X - Y = z and we also know that X + Y = sum.\\n\\n    We can then say that z = X - Y = sum - Y - Y = sum - 2Y.\\n    So if we want to minimize the solution z, we need to minimize sum - 2Y.\\n\\tThis means Y needs to be as close to sum/2 as possible, without exceeding it.\\n    \\n\\tWe can find a sum Y that satisifies this with dynamic programming.\\n\\tThe solution will then be z = X - Y = sum - 2 * Y.\\n    */\\n    int lastStoneWeightII(vector<int>& stones)\\n    {\\n        int sum = std::accumulate(stones.begin(), stones.end(), 0);\\n        int half = sum / 2;\\n        std::vector<bool> can_reach(half + 1, false);\\n        can_reach[0] = true;\\n         \\n        int max_reached = 0;\\n        for (int stone : stones)\\n        {\\n            for (int i = half; i >= stone; i--)\\n            {\\n                if (!can_reach[i])\\n                {\\n                    can_reach[i] = can_reach[i - stone];\\n                    if (can_reach[i])\\n                        max_reached = max(max_reached, i);\\n                }\\n            }\\n        }\\n\\n        return sum - 2 * max_reached;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Let\\'s take an example with stones = [a,b,c,d], such that the optimal solution has the following operations:\\n    x = a - b -> stones = [x, c, d]\\n    y = c - d -> stones = [x, y]\\n    z = x - y -> stones = [z], where z is the smallest possible weight.\\n\\n    We can then write the optimal solution z in the following form:\\n    z = x - y = a - b - (c - d) = (a + d) - (b + c)\\n    This leads us to observe that we can write any optimal solution as the difference between two sums. In this case:\\n    X = a + d\\n    Y = b + c\\n    So we have X - Y = z and we also know that X + Y = sum.\\n\\n    We can then say that z = X - Y = sum - Y - Y = sum - 2Y.\\n    So if we want to minimize the solution z, we need to minimize sum - 2Y.\\n\\tThis means Y needs to be as close to sum/2 as possible, without exceeding it.\\n    \\n\\tWe can find a sum Y that satisifies this with dynamic programming.\\n\\tThe solution will then be z = X - Y = sum - 2 * Y.\\n    */\\n    int lastStoneWeightII(vector<int>& stones)\\n    {\\n        int sum = std::accumulate(stones.begin(), stones.end(), 0);\\n        int half = sum / 2;\\n        std::vector<bool> can_reach(half + 1, false);\\n        can_reach[0] = true;\\n         \\n        int max_reached = 0;\\n        for (int stone : stones)\\n        {\\n            for (int i = half; i >= stone; i--)\\n            {\\n                if (!can_reach[i])\\n                {\\n                    can_reach[i] = can_reach[i - stone];\\n                    if (can_reach[i])\\n                        max_reached = max(max_reached, i);\\n                }\\n            }\\n        }\\n\\n        return sum - 2 * max_reached;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773257,
                "title": "hopefully-you-understand-my-comments",
                "content": "```\\nclass Solution {\\n    /*\\n    This problem is the same as if we divide the array into two subarrays and find \\n    the min difference of the two sums.\\n    \\n    Two subsets sum:\\n    S1 + S2 = S\\n    \\n    S1 - S2 = diff, we want minimize diff\\n    (S1 + S2 - S2) - S2 = diff\\n    (S1 + S2) - S2 - S2 = diff\\n    S - 2 * S2 = diff\\n    \\n    S is the total sum, and to make diff min, need to make S2 as big as possible\\n    Also, 2 * S2 = S is when diff = 0, so S2 = S / 2, which is the max S2 can be\\n    but not everytime S2 is the same as S/2\\n\\t\\n\\tUse DP like 0/1 knapsack problem,\\n\\tdp[i][j] means from stone 0 to stone i, we could fit them into a bag size of j\\n    \\n    Here is how dp looks like\\n    1 means from stone0 to stone_i, there could fit into a bag of size b_j\\n    It\\'s like 0/1 knapsack problem where stone 0 to stone i can be fit into a bag \\n\\n           0 1 2 3 4 5 ... sum/2  <-- bag size \\n    stone0 1 0 0 0 0 0 ... 0\\n    stone1 1\\n    stone2 1\\n    stone3 1\\n    .\\n    .\\n    .\\n    \\n    dp[i][0] for all i is 1 because all the sub-arrays have a sub-array that has a sum of 0.\\n    \\n    Transition function:\\n    if(dp[i-1][j] == 1) dp[i][j] = 1\\n    This means from stone 0 to stone i-1, if it is a fit, they could fit into a bag of size j\\n    at i as well\\n    \\n    Or\\n    \\n    if current bag size > curr stone && dp[i-1][j - stones[i-1]], then dp[i][j] = 1.\\n    If we decide to use current stone: stones[i-1], then what is the solution\\n    when the bag size is j - stones[i-1] ? And since we used current stone, we\\n    have i - 1 as well. Current stone is stones[i], current bag size is j. Since \\n     i stats at 1, that is why stones[i-1] but not stones[i] as stone starts at 0 index\\n    */\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        int len = stones.length;\\n        for(int s : stones) sum += s;\\n       \\n        int[][] dp = new int[len+1][sum/2+1]; // could also be a boolean matrix\\n        int S2 = 0; // need to max S2\\n        for(int i = 0; i < dp.length; i++)\\n            dp[i][0] = 1;\\n        \\n        for(int i = 1; i < dp.length; i++){\\n            for(int j = 1; j < dp[0].length; j++){\\n                if(dp[i-1][j] == 1 || (j >= stones[i-1] && dp[i-1][j-stones[i-1]] == 1)){\\n                    dp[i][j] = 1;\\n                    S2 = Math.max(S2, j);   \\n                }\\n  \\n            }\\n        }\\n      \\n        return sum - 2 * S2; // remember S - 2 * S2 = diff\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n    This problem is the same as if we divide the array into two subarrays and find \\n    the min difference of the two sums.\\n    \\n    Two subsets sum:\\n    S1 + S2 = S\\n    \\n    S1 - S2 = diff, we want minimize diff\\n    (S1 + S2 - S2) - S2 = diff\\n    (S1 + S2) - S2 - S2 = diff\\n    S - 2 * S2 = diff\\n    \\n    S is the total sum, and to make diff min, need to make S2 as big as possible\\n    Also, 2 * S2 = S is when diff = 0, so S2 = S / 2, which is the max S2 can be\\n    but not everytime S2 is the same as S/2\\n\\t\\n\\tUse DP like 0/1 knapsack problem,\\n\\tdp[i][j] means from stone 0 to stone i, we could fit them into a bag size of j\\n    \\n    Here is how dp looks like\\n    1 means from stone0 to stone_i, there could fit into a bag of size b_j\\n    It\\'s like 0/1 knapsack problem where stone 0 to stone i can be fit into a bag \\n\\n           0 1 2 3 4 5 ... sum/2  <-- bag size \\n    stone0 1 0 0 0 0 0 ... 0\\n    stone1 1\\n    stone2 1\\n    stone3 1\\n    .\\n    .\\n    .\\n    \\n    dp[i][0] for all i is 1 because all the sub-arrays have a sub-array that has a sum of 0.\\n    \\n    Transition function:\\n    if(dp[i-1][j] == 1) dp[i][j] = 1\\n    This means from stone 0 to stone i-1, if it is a fit, they could fit into a bag of size j\\n    at i as well\\n    \\n    Or\\n    \\n    if current bag size > curr stone && dp[i-1][j - stones[i-1]], then dp[i][j] = 1.\\n    If we decide to use current stone: stones[i-1], then what is the solution\\n    when the bag size is j - stones[i-1] ? And since we used current stone, we\\n    have i - 1 as well. Current stone is stones[i], current bag size is j. Since \\n     i stats at 1, that is why stones[i-1] but not stones[i] as stone starts at 0 index\\n    */\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        int len = stones.length;\\n        for(int s : stones) sum += s;\\n       \\n        int[][] dp = new int[len+1][sum/2+1]; // could also be a boolean matrix\\n        int S2 = 0; // need to max S2\\n        for(int i = 0; i < dp.length; i++)\\n            dp[i][0] = 1;\\n        \\n        for(int i = 1; i < dp.length; i++){\\n            for(int j = 1; j < dp[0].length; j++){\\n                if(dp[i-1][j] == 1 || (j >= stones[i-1] && dp[i-1][j-stones[i-1]] == 1)){\\n                    dp[i][j] = 1;\\n                    S2 = Math.max(S2, j);   \\n                }\\n  \\n            }\\n        }\\n      \\n        return sum - 2 * S2; // remember S - 2 * S2 = diff\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296441,
                "title": "simple-and-easy-to-understand-dp-solution-with-explanation-494-target-sum",
                "content": "Thanks a lot for some hint from the thread, I finally managed to AC this problem, and it is also my first time AC with harder 2D dp problem.\\n* Thought: This is equal to: partition the array into 2 independent set and try to minimize |sum_set1 - sum_set2|\\n\\t* Step 1. Build a dp array with row being the stones using [0, n] and col being all the possible sum. i.e. dp[i][j]\\nis true if we can use up to i stones making the subset sum up to j\\n\\t* Step 2. Iterate throught the DP array, and check if\\n\\t\\t* Type 1. The w of current stone already exceeds (>) the sum up to j, then we should exclude this stone, dp[i][j] = dp[i - 1][j]\\n\\t\\t* Type 2. Otherwise (<=) We can either use this stone, then we may query the position at [i][j - stones[i - 1]] to see if previously the weight sum of j - stones[i - 1] can be achieved, OR we do not use this one, and merely the stones from 0 to i - 1 already satisfies, so answer will be dp[i-1][j] || dp[i - 1][j - stones[i - 1]]\\n\\t* Step 3. If we want to minimize the difference, then the sum of 2 subsets (ans = sum_set1 - (sum - sum_set1)) should be as close as possible. Hence we iterate the last row starting from **sum / 2** to see if dp[i][j] is true and update the answer if answer  >= 0\\n```cpp\\nclass Solution {\\n    public:\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n = stones.size();\\n        if(n == 1)\\n        {\\n            return stones[0];\\n        }\\n        \\n        bool dp[102][30002] = {0}; // Step 1.\\n        int res = INT_MAX, sum = 0;\\n        for(int i = 0; i <= n; i++) // Step 1.\\n        {\\n            dp[i][0] = 1;\\n            if(i < n)\\n            {\\n                sum += stones[i];\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++) // Step 2.\\n        {\\n            for(int j = 1; j <= sum; j++)\\n            {\\n                if(j < stones[i - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j]; // S2 Type 1\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - stones[i - 1]]; // S2 Type 2\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int j = sum / 2; j <= sum; j++) // Step 3.\\n        {\\n            if(2 * j - sum >= 0 && dp[n][j])\\n            {\\n                res = min(res, 2 * j - sum);\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd here also comes the solution for [494. Target Sum](https://leetcode.com/problems/target-sum/)\\n```cpp\\nclass Solution {\\n    public:\\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        \\n        if(n == 1)\\n        {\\n            return nums[0] == abs(target) ? 1 : 0;\\n        }\\n        \\n        int dp[21][1001] = {0};\\n        int res = 0, sum = 0;\\n        sort(nums.begin(), nums.end());\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++) \\n        {\\n            dp[i][0] = nums[i - 1] == 0 ? 1 << i : dp[i - 1][0];\\n            sum += nums[i - 1];\\n        }\\n\\n        for(int i = 1; i <= n; i++) \\n\\t\\t{\\n            for(int j = 1; j <= sum; j++)\\n            {\\n                if(j < nums[i - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n                }\\n            }\\n        }\\n        \\n        for(int j = 0; j <= sum; j++)\\n        {\\n            if(j * 2 - sum == target && dp[n][j])\\n            {\\n                res = dp[n][j];\\n\\t\\t\\t\\t\\t\\tbreak;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlthough the code may seems tedious and not efficient, it is my first time solved the problem by myself without asking anyone, only query some information from CLRS book, I will keep bettering myself :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\n    public:\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n = stones.size();\\n        if(n == 1)\\n        {\\n            return stones[0];\\n        }\\n        \\n        bool dp[102][30002] = {0}; // Step 1.\\n        int res = INT_MAX, sum = 0;\\n        for(int i = 0; i <= n; i++) // Step 1.\\n        {\\n            dp[i][0] = 1;\\n            if(i < n)\\n            {\\n                sum += stones[i];\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++) // Step 2.\\n        {\\n            for(int j = 1; j <= sum; j++)\\n            {\\n                if(j < stones[i - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j]; // S2 Type 1\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - stones[i - 1]]; // S2 Type 2\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int j = sum / 2; j <= sum; j++) // Step 3.\\n        {\\n            if(2 * j - sum >= 0 && dp[n][j])\\n            {\\n                res = min(res, 2 * j - sum);\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    public:\\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        \\n        if(n == 1)\\n        {\\n            return nums[0] == abs(target) ? 1 : 0;\\n        }\\n        \\n        int dp[21][1001] = {0};\\n        int res = 0, sum = 0;\\n        sort(nums.begin(), nums.end());\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++) \\n        {\\n            dp[i][0] = nums[i - 1] == 0 ? 1 << i : dp[i - 1][0];\\n            sum += nums[i - 1];\\n        }\\n\\n        for(int i = 1; i <= n; i++) \\n\\t\\t{\\n            for(int j = 1; j <= sum; j++)\\n            {\\n                if(j < nums[i - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n                }\\n            }\\n        }\\n        \\n        for(int j = 0; j <= sum; j++)\\n        {\\n            if(j * 2 - sum == target && dp[n][j])\\n            {\\n                res = dp[n][j];\\n\\t\\t\\t\\t\\t\\tbreak;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050237,
                "title": "python-tired-of-it-me-too",
                "content": "There are three steps to see the solution:\\n* first, the problem reduces to creating two mega-stones (credits to @votrubac) between which we have the minimum weight difference. Creating them translates to the formation of two sets.\\n* then, in an ideal scenario, two stones of the same weight would result in a zero weight upon smashing. Great! Our purpose is to create two stones of roughly half the total weight.\\n* next, chasing half the total weight is the same as stealing as much as you can when you know you have half of a backpack. \\n\\nSo, in a sense, it becomes the 0/1 knapsack, but a little different. \\n\\nPresumably, you know a version of the Knapsack, and there was this idea of ***whether stealing the ith item would increase the final profit***. So, it should be the same, but with a subtle twist. We translate the question from Knapsack\\'s problem to ***whether we should add the ith stone to the current mega-stone or not***. \\n\\nThe difference that could drive you crazy is that we are not maximizing the profit. Nor are we minimizing the difference between some current weights and the half. \\n\\nWe are simply deciding ***whether a capacity could be reached with or without the ith stone***. Why? Because after that, we will look for the maximum capacity that could be reached in the interval 1 to half of the total weights. If it is precisely half of the total weight, it would be wonderful. Now, think of this. For the 0/1 knapsack, the capacity was there for us to wonder if we could somehow maximize the profit given this new volume. Unfortunately, it is not the thing here.\\n\\n### Start small, O(2^n) time\\n\\nIn the following code snippet, you can see the idea of maximizing the profit for Knapsack. It also depicts the idea of whether you want to use item i, or you don\\'t. That\\'s denoted by `with_i` and `without_i`.\\n```\\ndef og_knapsack(values, weights, i, T):\\n    \\'\\'\\' i = n,1; O(2^n) time, O(1) space \\'\\'\\'\\n    if i == -1 or T == 0:\\n        return 0\\n    if weights[i] > T:\\n        return og_knapsack(values, weights, i-1, T)\\n    else:\\n        with_i = values[i] + og_knapsack(values, weights, i-1, T-weights[i])\\n        without_i = og_knapsack(values, weights, i-1, T)\\n        return max(with_i, without_i)\\n```\\n\\nExample:\\n```\\nvalues = [60, 100, 120]\\nweights = [10, 20, 30]\\nT = 50 \\n```\\n\\nDetails:\\n* **n is the number of items**\\n* **k(n, T)** is a shortcut for og_knapsack\\n* **wi** is a shortcut for ith weight\\n* **cap** is a shortcut for the current capacity\\n* **T is the total capacity**\\n\\n![image](https://assets.leetcode.com/users/images/628835e3-d7ce-4988-a4b1-8c3b74e791f6_1652860271.2631743.png)\\n\\nGreen dots denote that we want the ith item, while the red ones that we do not. The yellow ones are for the case where T became 0, so whether we want an item or we do not want it, it does not matter because the backpack is packed.\\n\\n### Improve to O(nT) time\\n\\nGreat Alex, but why can\\'t we stop here and call it a day? Because the `og_knapsack()` has a time complexity of O(2^n). Yikes, not great for 150 stones, right? \\n\\nWe use a matrix `M` to store intermediary results. This matrix is the key to solving this problem in under 2^150 stones. \\n\\n```\\ndef knapsack(values, weights, T):\\n    \\'\\'\\' Dynamic with O(n*T) time and space. \\'\\'\\'\\n    n = len(weights)\\n    M = [[0 for x in range(T + 1)] for y in range(n + 1)]\\n\\n    for wi in range(n+1):\\n        for cap in range(T+1):\\n            if wi == 0 or cap == 0:\\n                continue\\n            if weights[wi - 1] > cap:\\n                M[wi][cap] = M[wi - 1][cap]\\n            else:\\n                with_wi = values[wi - 1] + M[wi - 1][cap - weights[wi - 1]]\\n                without_wi = M[wi - 1][cap]\\n                M[wi][cap] = max(with_wi, without_wi)\\n\\n    return M[n][T]\\n```\\n\\n## Adapt the O(nT) to the problem of the stones\\n\\nThe adaption is the solution to another problem - the minimum difference between subsets.\\n\\nDetails:\\n* **si** is a shortcut for ith stone weight\\n* **cap** is a shortcut for the current capacity\\n\\n```\\ndef solution(stones):\\n\\tT = sum(stones)\\n\\tH = T // 2\\n\\n\\tn = len(stones)\\n\\tM = [[False for _ in range(H+1)] for _ in range(n+1)]\\n\\tfor i in range(n+1):\\n\\t\\tM[i][0] = True\\n\\n\\tfor si in range(1, n+1):\\n\\t\\tfor cap in range(1, H+1):\\n\\t\\t\\tif si == 0 or cap == 0:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif stones[si-1] > cap:\\n\\t\\t\\t\\tM[si][cap] = M[si-1][cap]\\n\\t\\t\\telse:\\n\\t\\t\\t\\twithout_si = M[si-1][cap - stones[si-1]]\\n\\t\\t\\t\\twith_si = M[si-1][cap]\\n\\t\\t\\t\\tM[si][cap] = with_si | without_si\\n\\n\\tmax_cap, cap = H, 0 \\n\\twhile max_cap >= 0:\\n\\t\\tif M[n][max_cap] == True:\\n\\t\\t\\tcap = max_cap \\n\\t\\t\\tbreak\\n\\t\\tmax_cap -= 1\\n\\n\\treturn T - 2 * max_cap\\n```\\n\\nLook over the following example:\\n```\\nstones = [2, 1, 3, 7]\\n```\\n\\nDetails:\\n* the columns represent possible capacities up to half the weight of the stones (13 total, 6 half)\\n* the rows are the indexes of the stones\\n* M[si][cap] represents whether for `1 to si` there is a posibility to sum to exactly `cap`\\n\\n![image](https://assets.leetcode.com/users/images/ff7064cc-0a64-4ed8-801f-2d30feb81edf_1652863034.9182944.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef og_knapsack(values, weights, i, T):\\n    \\'\\'\\' i = n,1; O(2^n) time, O(1) space \\'\\'\\'\\n    if i == -1 or T == 0:\\n        return 0\\n    if weights[i] > T:\\n        return og_knapsack(values, weights, i-1, T)\\n    else:\\n        with_i = values[i] + og_knapsack(values, weights, i-1, T-weights[i])\\n        without_i = og_knapsack(values, weights, i-1, T)\\n        return max(with_i, without_i)\\n```\n```\\nvalues = [60, 100, 120]\\nweights = [10, 20, 30]\\nT = 50 \\n```\n```\\ndef knapsack(values, weights, T):\\n    \\'\\'\\' Dynamic with O(n*T) time and space. \\'\\'\\'\\n    n = len(weights)\\n    M = [[0 for x in range(T + 1)] for y in range(n + 1)]\\n\\n    for wi in range(n+1):\\n        for cap in range(T+1):\\n            if wi == 0 or cap == 0:\\n                continue\\n            if weights[wi - 1] > cap:\\n                M[wi][cap] = M[wi - 1][cap]\\n            else:\\n                with_wi = values[wi - 1] + M[wi - 1][cap - weights[wi - 1]]\\n                without_wi = M[wi - 1][cap]\\n                M[wi][cap] = max(with_wi, without_wi)\\n\\n    return M[n][T]\\n```\n```\\ndef solution(stones):\\n\\tT = sum(stones)\\n\\tH = T // 2\\n\\n\\tn = len(stones)\\n\\tM = [[False for _ in range(H+1)] for _ in range(n+1)]\\n\\tfor i in range(n+1):\\n\\t\\tM[i][0] = True\\n\\n\\tfor si in range(1, n+1):\\n\\t\\tfor cap in range(1, H+1):\\n\\t\\t\\tif si == 0 or cap == 0:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif stones[si-1] > cap:\\n\\t\\t\\t\\tM[si][cap] = M[si-1][cap]\\n\\t\\t\\telse:\\n\\t\\t\\t\\twithout_si = M[si-1][cap - stones[si-1]]\\n\\t\\t\\t\\twith_si = M[si-1][cap]\\n\\t\\t\\t\\tM[si][cap] = with_si | without_si\\n\\n\\tmax_cap, cap = H, 0 \\n\\twhile max_cap >= 0:\\n\\t\\tif M[n][max_cap] == True:\\n\\t\\t\\tcap = max_cap \\n\\t\\t\\tbreak\\n\\t\\tmax_cap -= 1\\n\\n\\treturn T - 2 * max_cap\\n```\n```\\nstones = [2, 1, 3, 7]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1597401,
                "title": "java-with-comments-knapsack-dp",
                "content": "```\\n public int lastStoneWeightII(int[] stones) {\\n        //sack: capacity of stones\\n        int sack = Arrays.stream(stones).sum();\\n        // sack2: half the capacity\\n        // to minize the difference betwen two sacks (e.g. sack - 2*sack2 )\\n        int sack2 = sack/2;\\n        //since it\\'s NOT un-bounded sack will use 2D matrix to avoid repetition \\n        //usually 1D array is used when repetition is allowed\\n        //(e.g. coin change problem with infinite coin sources)\\n        //There is another trick, where we can avoid this 2D array, for simplicity let\\'s stick with it\\n        int[][]dp = new int[stones.length+1][sack2+1];\\n        for(int r=1; r<dp.length; r++) {\\n            for(int c=1 ; c< dp[0].length; c++) {\\n                // in all the cases this value will be considered\\n                // an element just above current cell\\n                dp[r][c] = dp[r-1][c];\\n                //ans will be effected only when stone weight>=c\\n                //c: sum so far\\n                if(c>=stones[r-1]) {\\n                    //remaining weight after current stone is used\\n                    int remaining = c-stones[r-1];\\n                    //if current stone is used\\n                    //go to previous row and fetch value of remaining val                \\n                    int currentPlusRemaining = dp[r-1][remaining] + stones[r-1];\\n                    int valueWithoutCurrent = dp[r-1][c];\\n                    dp[r][c] = Math.max(currentPlusRemaining, valueWithoutCurrent);                    \\n                }\\n            }\\n        }\\n        // stack: full sum\\n        // dp[dp.length-1][dp[0].length-1]): half the stack\\n        \\n        return sack - (2*dp[dp.length-1][dp[0].length-1]);\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int lastStoneWeightII(int[] stones) {\\n        //sack: capacity of stones\\n        int sack = Arrays.stream(stones).sum();\\n        // sack2: half the capacity\\n        // to minize the difference betwen two sacks (e.g. sack - 2*sack2 )\\n        int sack2 = sack/2;\\n        //since it\\'s NOT un-bounded sack will use 2D matrix to avoid repetition \\n        //usually 1D array is used when repetition is allowed\\n        //(e.g. coin change problem with infinite coin sources)\\n        //There is another trick, where we can avoid this 2D array, for simplicity let\\'s stick with it\\n        int[][]dp = new int[stones.length+1][sack2+1];\\n        for(int r=1; r<dp.length; r++) {\\n            for(int c=1 ; c< dp[0].length; c++) {\\n                // in all the cases this value will be considered\\n                // an element just above current cell\\n                dp[r][c] = dp[r-1][c];\\n                //ans will be effected only when stone weight>=c\\n                //c: sum so far\\n                if(c>=stones[r-1]) {\\n                    //remaining weight after current stone is used\\n                    int remaining = c-stones[r-1];\\n                    //if current stone is used\\n                    //go to previous row and fetch value of remaining val                \\n                    int currentPlusRemaining = dp[r-1][remaining] + stones[r-1];\\n                    int valueWithoutCurrent = dp[r-1][c];\\n                    dp[r][c] = Math.max(currentPlusRemaining, valueWithoutCurrent);                    \\n                }\\n            }\\n        }\\n        // stack: full sum\\n        // dp[dp.length-1][dp[0].length-1]): half the stack\\n        \\n        return sack - (2*dp[dp.length-1][dp[0].length-1]);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430241,
                "title": "cpp-bottom-up-dp-explained-using-subset-sum-variation-of-0-1-knapsack",
                "content": "Approach: This is a very basic question of 0-1 Knapsack and is direct implementation of Subset Sum using Dynamic Programming.\\n\\nExplanation : Basically we are trying to convert this problem into Subset Sum which can easily be solved using DP. First we calculate the range of the stones array.\\n\\n![image](https://assets.leetcode.com/users/images/d6c15435-8c55-45bf-9c39-6e7f4f271929_1630132814.121952.png)\\n\\nRange = summation of all elements of array.\\n\\nWe calculate the range to then reduce the number of dependencies from 2 to 1 i.e. first there were two parameters Subset 1 and Subset 2 and after calculating the range for the same, we can then reduce the dependency from 2 to 1 because other subset sum can be calculated by subtracting the first one from the range.\\n\\nThen we apply the standard subset sum rules to 2D grid that we create to solve the problem in which we declare the first column with true and the first row with false.\\n\\nThen we simply calculate the subset sum.\\n\\nWe then check in the last row from right to left from mid searching for true. First index to give us true ( row-wise ) will be the correct ans i.e. Subset Sum1 and we can simply calculate the final ans as :\\n\\n``` Range - ( 2* index) ```\\n\\nhere index is the index on which we got ``` true```\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int range = 0 ;\\n        \\n        for(int ctr = 0 ; ctr < stones.size() ; ctr++)\\n            range+=stones[ctr];\\n        \\n        bool dp[stones.size()+1][range/2+1];\\n        \\n        for(int ctr = 0 ; ctr <= stones.size() ; ctr++)\\n            dp[ctr][0] = true;\\n        \\n        for(int ctr = 1 ; ctr <= range/2 ; ctr++)\\n            dp[0][ctr] = false;\\n        \\n        for(int row = 1 ; row <= stones.size() ; row++)\\n            for(int col = 1 ; col <= range/2 ; col ++)\\n            {\\n                if(stones[row-1]<=col)\\n                {\\n                    dp[row][col] = dp[row-1][col] || dp[row-1][col-stones[row-1]];\\n                }\\n                else\\n                {\\n                    dp[row][col] = dp[row-1][col];\\n                }\\n            }\\n        \\n        for(int ctr = range/2 ; ctr >= 0 ; ctr --)\\n        {\\n            if(dp[stones.size()][ctr] == true)\\n            {\\n                return abs(range - (2*ctr));\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```\\n\\nPS : This is the best code but still if you think that there is a better alternative than this then feel free to share in the comments. Thanks in advance for help \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "``` Range - ( 2* index) ```\n``` true```\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int range = 0 ;\\n        \\n        for(int ctr = 0 ; ctr < stones.size() ; ctr++)\\n            range+=stones[ctr];\\n        \\n        bool dp[stones.size()+1][range/2+1];\\n        \\n        for(int ctr = 0 ; ctr <= stones.size() ; ctr++)\\n            dp[ctr][0] = true;\\n        \\n        for(int ctr = 1 ; ctr <= range/2 ; ctr++)\\n            dp[0][ctr] = false;\\n        \\n        for(int row = 1 ; row <= stones.size() ; row++)\\n            for(int col = 1 ; col <= range/2 ; col ++)\\n            {\\n                if(stones[row-1]<=col)\\n                {\\n                    dp[row][col] = dp[row-1][col] || dp[row-1][col-stones[row-1]];\\n                }\\n                else\\n                {\\n                    dp[row][col] = dp[row-1][col];\\n                }\\n            }\\n        \\n        for(int ctr = range/2 ; ctr >= 0 ; ctr --)\\n        {\\n            if(dp[stones.size()][ctr] == true)\\n            {\\n                return abs(range - (2*ctr));\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162871,
                "title": "java-0-1-knapsack-dp-coin-change-explanation",
                "content": "**Idea**\\n\\n* Divide the weights into two groups and minimize the difference between those two groups.\\n* Try to maximize weight in a group with capacity `sum(stones) / 2`\\n\\nWith the above idea, the problem reduces to [322. Coin Change](https://leetcode.com/problems/coin-change/).\\n\\n**Why Knapsack?**\\n\\nKnapsack problem:\\n\\n* Given a maximum weight capacity\\n* Given item weights\\n* Given item values\\n* Maximize the values while ensuring items\\' weights sum to below the capacity\\n\\n\\n**DP recurrence**\\n\\nLet dp(i, j) be the maximum sum of weights when considering stones[0] ... stones[i - 1] with capacity j.\\n\\n`dp(i, j) = max(dp(i-1, j), dp(i-1, j - stones[i - 1]) + stones[i - 1])`\\n\\nAnother ways to think about the above is: maximum \\'value\\' between two cases:\\n\\n1. not picking the current stone at all, \\n2. picking the current stone\\n\\nActually, this recurrence is similar to that of [322. Coin Change](https://leetcode.com/problems/coin-change/):\\n\\n`dp(i, j) = min(dp(i-1, j), dp(i - 1, j - stones[i - 1]) + 1`\\n\\nThe difference is that, in that problem, we are taking the *minimum* of *number of coins*. Hence we used `min` and `+ 1` as the addition to the value.\\n\\n**Code**\\n\\n```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length;\\n        int sum = addAll(stones);\\n        int halfSum = sum / 2;\\n\\n        int[] dp = new int[halfSum + 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = halfSum; j >= stones[i-1]; j--) {\\n                dp[j] = Math.max(dp[j], dp[j - stones[i-1]] + stones[i-1]);\\n            }\\n        }\\n\\n        return sum - 2 * dp[halfSum];\\n    }\\n\\n    private int addAll(int[] arr) {\\n        int ret = 0;\\n\\n        for (int num : arr) {\\n            ret += num;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```\\n\\n**Analysis**\\n\\nLet N = |stones|, M = sum of the stone weights\\n\\n* Time complexity: ~O(NM)\\n* Space complexity: ~O(M)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length;\\n        int sum = addAll(stones);\\n        int halfSum = sum / 2;\\n\\n        int[] dp = new int[halfSum + 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = halfSum; j >= stones[i-1]; j--) {\\n                dp[j] = Math.max(dp[j], dp[j - stones[i-1]] + stones[i-1]);\\n            }\\n        }\\n\\n        return sum - 2 * dp[halfSum];\\n    }\\n\\n    private int addAll(int[] arr) {\\n        int ret = 0;\\n\\n        for (int num : arr) {\\n            ret += num;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938051,
                "title": "java-recursion-memoisation-intuitive-solution-with-explanation",
                "content": "You have the find the minValue that can be retrieved after combining all the stones.\\n\\n**How can you combine the stones ?**\\nSo basically you need to divide the contents of the array into two subgroups such that the difference of Sum of value of group1 and sumOf values of group2 is min.\\n\\nsuppose you have 5 elements in the array : a1, a2 , a3, a4, a5\\n\\nyou have created the two sub groups\\n\\n{a1,a2,a4}        and    {a3,a5}\\n\\nAnswer will be the difference of these subGroup: \\n\\n```\\nminDifference = abs ( a1+a2+a4 - a3 -a5)\\n```\\n\\nwith you look care fully basically you need to find the min of the above equation. => each element can be added as +a or -a \\nint the final computation and the absolute value of that needs to be minimised.\\n\\n\\n\\nApproach : \\nstart dfs from start index, and for each node the next possible value can be +a or -a and the sum from that will be absolute value of existing sum+a or existing sum -a.\\n\\n\\n```\\nclass Solution {\\n    public HashMap<String,Integer> cache ;\\n    public Solution() {\\n        cache = new HashMap<>();\\n    }\\n    public int findTargetSumWays(int[] nums, int target) {\\n        return dfs(nums,target,0,0);\\n    }\\n    \\n    HashMap<String,Integer> cache;\\n    public int lastStoneWeightII(int[] stones) {\\n        cache = new HashMap<>();\\n        return dfs(0,0,stones);\\n    }\\n    \\n    public int dfs(int index, int sum , int[] stones) {\\n        String key = index+\",\"+sum;\\n        if(cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        if(index== stones.length) {\\n            return sum;\\n        }\\n        int currentValue = stones[index];\\n        int left = dfs(index+1,sum+currentValue,stones);\\n        int right = dfs(index+1,Math.abs(sum-currentValue),stones);\\n        int result = Math.min(left,right);\\n        cache.put(key,result);\\n        return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nminDifference = abs ( a1+a2+a4 - a3 -a5)\\n```\n```\\nclass Solution {\\n    public HashMap<String,Integer> cache ;\\n    public Solution() {\\n        cache = new HashMap<>();\\n    }\\n    public int findTargetSumWays(int[] nums, int target) {\\n        return dfs(nums,target,0,0);\\n    }\\n    \\n    HashMap<String,Integer> cache;\\n    public int lastStoneWeightII(int[] stones) {\\n        cache = new HashMap<>();\\n        return dfs(0,0,stones);\\n    }\\n    \\n    public int dfs(int index, int sum , int[] stones) {\\n        String key = index+\",\"+sum;\\n        if(cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        if(index== stones.length) {\\n            return sum;\\n        }\\n        int currentValue = stones[index];\\n        int left = dfs(index+1,sum+currentValue,stones);\\n        int right = dfs(index+1,Math.abs(sum-currentValue),stones);\\n        int result = Math.min(left,right);\\n        cache.put(key,result);\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430221,
                "title": "cpp-dp-concise-bottom-up-approach-0ms",
                "content": "This is a classic knapsack minimum subset sum difference  problem. Just check for the maximum possible sum we can get from stones vector in between 0  and sum of stones / 2.\\n    \\n\\n```\\nclass Solution {\\npublic:\\n   \\n    bool subsetSum(vector<int>& stones, int sum, vector<vector<bool>> &dp)\\n    {\\n        for(int idx = 0; idx <= stones.size(); idx++)\\n            dp[idx][0] = true;\\n        \\n        for(int idx = 1; idx <= sum; idx++)\\n            dp[0][idx] = false;\\n        \\n        for(int row = 1; row <= stones.size(); row++)\\n        {\\n            for(int col = 1; col <= sum; col++)\\n            {\\n                if(stones[row - 1] <= col)\\n                    dp[row][col] = dp[row - 1][col] || dp[row - 1][col - stones[row - 1]];\\n                \\n                else\\n                    dp[row][col] = dp[row - 1][col];\\n            }\\n        }\\n        \\n        return dp[stones.size()][sum];\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int range = 0, sum1 = 0;\\n        \\n        for(int stone : stones)\\n            range += stone;\\n        \\n        vector<vector<bool>> dp(stones.size() + 1, vector<bool>(range / 2 + 1, false));\\n        \\n       subsetSum(stones, range / 2, dp);\\n        \\n        for(int idx = range / 2; idx >= 0; idx--)\\n            if(dp[dp.size() - 1][idx] == true)  return abs(range - (2 * idx));\\n\\n        return 0; \\n    }\\n};\\n```\\n\\nThis code gives 4ms but when we take array instead of vector, it gave 0ms i.e 100% faster.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int range = 0, sum1 = 0;\\n        \\n        for(int stone : stones)\\n            range += stone;\\n        \\n        bool dp[stones.size() + 1][range / 2 + 1];\\n        \\n        for(int idx = 0; idx <= stones.size(); idx++)\\n            dp[idx][0] = true;\\n        \\n        for(int idx = 1; idx <= range / 2; idx++)\\n            dp[0][idx] = false;\\n        \\n        for(int row = 1; row <= stones.size(); row++)\\n        {\\n            for(int col = 1; col <= range / 2; col++)\\n            {\\n                if(stones[row - 1] <= col)\\n                    dp[row][col] = dp[row - 1][col] || dp[row - 1][col - stones[row - 1]];\\n                \\n                else\\n                    dp[row][col] = dp[row - 1][col];\\n            }\\n        }\\n        \\n        for(int idx = range / 2; idx >= 0; idx--)\\n            if(dp[stones.size()][idx] == true)  return abs(range - (2 * idx));\\n        \\n        return 0; \\n    }\\n};\\n```\\n```\\nReturning (range - 2 * idx) \\n    As Range(total sum of stones) = sum2 + sum1\\n     sum2 = Range - sum1\\n\\t \\n   thereby minimum subset difference would be \\n      diff = sum2 - sum1;\\n\\t       =  range - 2 * sum1 \\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool subsetSum(vector<int>& stones, int sum, vector<vector<bool>> &dp)\\n    {\\n        for(int idx = 0; idx <= stones.size(); idx++)\\n            dp[idx][0] = true;\\n        \\n        for(int idx = 1; idx <= sum; idx++)\\n            dp[0][idx] = false;\\n        \\n        for(int row = 1; row <= stones.size(); row++)\\n        {\\n            for(int col = 1; col <= sum; col++)\\n            {\\n                if(stones[row - 1] <= col)\\n                    dp[row][col] = dp[row - 1][col] || dp[row - 1][col - stones[row - 1]];\\n                \\n                else\\n                    dp[row][col] = dp[row - 1][col];\\n            }\\n        }\\n        \\n        return dp[stones.size()][sum];\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int range = 0, sum1 = 0;\\n        \\n        for(int stone : stones)\\n            range += stone;\\n        \\n        vector<vector<bool>> dp(stones.size() + 1, vector<bool>(range / 2 + 1, false));\\n        \\n       subsetSum(stones, range / 2, dp);\\n        \\n        for(int idx = range / 2; idx >= 0; idx--)\\n            if(dp[dp.size() - 1][idx] == true)  return abs(range - (2 * idx));\\n\\n        return 0; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int range = 0, sum1 = 0;\\n        \\n        for(int stone : stones)\\n            range += stone;\\n        \\n        bool dp[stones.size() + 1][range / 2 + 1];\\n        \\n        for(int idx = 0; idx <= stones.size(); idx++)\\n            dp[idx][0] = true;\\n        \\n        for(int idx = 1; idx <= range / 2; idx++)\\n            dp[0][idx] = false;\\n        \\n        for(int row = 1; row <= stones.size(); row++)\\n        {\\n            for(int col = 1; col <= range / 2; col++)\\n            {\\n                if(stones[row - 1] <= col)\\n                    dp[row][col] = dp[row - 1][col] || dp[row - 1][col - stones[row - 1]];\\n                \\n                else\\n                    dp[row][col] = dp[row - 1][col];\\n            }\\n        }\\n        \\n        for(int idx = range / 2; idx >= 0; idx--)\\n            if(dp[stones.size()][idx] == true)  return abs(range - (2 * idx));\\n        \\n        return 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297883,
                "title": "c-dp-with-clear-explanation-and-code-comments",
                "content": "**The problem is equivalent to \"putting the stones into two groups, such that the weight sums of the two groups have minimal difference.\"**\\nFor example, given three stones with weights `A>B>C`. \\nPossible outcomes are `|A-(B-C)|`, `|(A-B)-C|`, `|(A-C)-B|`..., \\n, or simply,  `|A-B+C|`, `|A-B-C|`, `|A-C-B|` ... (Stones with positive weights are in one group and ones with negative weights are in the other).\\n\\nWithout lost of generarity, we assume that two groups have weights `P` and `N`, where `P \\u2265 N`. Moreover, the sum of all stones is `sum = P+N`.\\nThus, `P = sum-N` and the last stone weight is `P-N = sum-2N \\u2265 0`.\\nTherefore, we have the **bound of `N \\u2A7D sum/2`**.\\n\\nNow, we\\'re going find out all possible `N` such that `N \\u2A7D sum/2`.\\nWe use a table to store whether a weight `N` is possible, given a number of stones (from 0 to stones.length).\\nThe table `possible_N_table` is a 2-D boolean vector with idexes of the given stone number and `N`.\\n\\n1. Initually, all values in `possible_N_table` is `false`, except `possible_N_table[0][0] = true`. (Given no stone, the only possible `N` is 0).\\n2. Now we give the stone one-by-one (say given the stone `0...i`) and update the vector `possible_N_table[i]` by looking into every possible `N`s.\\n\\tIf current `N` is not possible to reach, skip this round. (for example, \"given no stone but N=1\" is not possible. Thus, `possible_N_table[0][1] = false` by default.)\\n\\t\\n\\tOtherwise:\\n    a. if the stone is NOT included to N, `N` remains the same and `possible_N_table[i+1][N] = true`\\n\\tb. if the stone is included to N, `new_N = N + stone[i]` and `possible_N_table[i+1][new_N] = true`\\n\\t    Meanwhile, max_N is recorded.\\n3. Finally, compute the last stone weight with `P-N = sum-2N`.\\n\\n\\n```\\nint lastStoneWeightII(vector<int>& stones) {\\n        if (stones.size() == 1)\\n            return stones[0];\\n        \\n        // Compute half sum for N < sum/2\\n        int sum = 0;\\n        for (int& stone: stones){\\n            sum += stone;\\n        }\\n        int half_sum = sum/2;    // Half sum\\n        \\n        // Compute maximum possible of N\\n        vector<vector<bool>> possible_N_table(stones.size()+1, vector<bool> (half_sum+1, false));\\n        possible_N_table[0][0] = true;           // if no stone is picked the diff = 0\\n        int max_N = 0;\\n        \\n        for (int i = 0; i < stones.size(); i++){\\n            for (int N = 0; N <= half_sum; N++){    // j is possible_N\\n                if (possible_N_table[i][N]){     // Before taking the stone, if the value is possible\\n                    \\n                    // Case 1: don\\'t take current stone i\\n                    possible_N_table[i+1][N] = true; // i+1 is the table idx in the table\\n                    \\n                    // Case 2: take current stone i\\n                    int new_N = N + stones[i];\\n                    if (new_N <= half_sum){\\n                        possible_N_table[i+1][new_N] = true; // i+1 is the table idx in the table\\n                        max_N = max(max_N, new_N);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sum - 2*max_N;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint lastStoneWeightII(vector<int>& stones) {\\n        if (stones.size() == 1)\\n            return stones[0];\\n        \\n        // Compute half sum for N < sum/2\\n        int sum = 0;\\n        for (int& stone: stones){\\n            sum += stone;\\n        }\\n        int half_sum = sum/2;    // Half sum\\n        \\n        // Compute maximum possible of N\\n        vector<vector<bool>> possible_N_table(stones.size()+1, vector<bool> (half_sum+1, false));\\n        possible_N_table[0][0] = true;           // if no stone is picked the diff = 0\\n        int max_N = 0;\\n        \\n        for (int i = 0; i < stones.size(); i++){\\n            for (int N = 0; N <= half_sum; N++){    // j is possible_N\\n                if (possible_N_table[i][N]){     // Before taking the stone, if the value is possible\\n                    \\n                    // Case 1: don\\'t take current stone i\\n                    possible_N_table[i+1][N] = true; // i+1 is the table idx in the table\\n                    \\n                    // Case 2: take current stone i\\n                    int new_N = N + stones[i];\\n                    if (new_N <= half_sum){\\n                        possible_N_table[i+1][new_N] = true; // i+1 is the table idx in the table\\n                        max_N = max(max_N, new_N);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sum - 2*max_N;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166167,
                "title": "clean-100-python-solution-self-explained-dp-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\ndp[i][t] = considering stones[0~i-1], if it can sum up to target t\\n\\nTime: O(SN), S is the sum of stone weight. N is the number of stones.\\nSpace: O(SN), can reduce to O(S).\\n\"\"\"\\n\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        total = sum(stones)\\n        target = total/2\\n        dp = [[False for _ in xrange(target+1)] for _ in xrange(len(stones)+1)]\\n        dp[0][0] = True\\n        \\n        maxSum = 0\\n        # Keep trace of the max sum that stones can sum up to.\\n        \\n        for i in xrange(1, len(stones)+1):\\n            for t in xrange(target+1):\\n                if (dp[i-1][t] or (t-stones[i-1]>=0 and dp[i-1][t-stones[i-1]])):\\n                    # it can sum up to t considering stones[0~i-2]\\n                    # OR\\n                    # it can sum up to t considering stones[0~i-1]\\n                    dp[i][t] = True\\n                    maxSum = max(maxSum, t)\\n                    if t==target: return total-maxSum*2\\n        \\n        # Two collection of stones will be total-maxSum and maxSum\\n        # (total-maxSum) - maxSum => total-maxSum*2\\n        return total-maxSum*2\\n\\n\"\"\"\\nSimilar Problems: 322, 377, 416, 494, 1043, 1049, 1220, 1230, 1262, 1269\\t\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\ndp[i][t] = considering stones[0~i-1], if it can sum up to target t\\n\\nTime: O(SN), S is the sum of stone weight. N is the number of stones.\\nSpace: O(SN), can reduce to O(S).\\n\"\"\"\\n\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        total = sum(stones)\\n        target = total/2\\n        dp = [[False for _ in xrange(target+1)] for _ in xrange(len(stones)+1)]\\n        dp[0][0] = True\\n        \\n        maxSum = 0\\n        # Keep trace of the max sum that stones can sum up to.\\n        \\n        for i in xrange(1, len(stones)+1):\\n            for t in xrange(target+1):\\n                if (dp[i-1][t] or (t-stones[i-1]>=0 and dp[i-1][t-stones[i-1]])):\\n                    # it can sum up to t considering stones[0~i-2]\\n                    # OR\\n                    # it can sum up to t considering stones[0~i-1]\\n                    dp[i][t] = True\\n                    maxSum = max(maxSum, t)\\n                    if t==target: return total-maxSum*2\\n        \\n        # Two collection of stones will be total-maxSum and maxSum\\n        # (total-maxSum) - maxSum => total-maxSum*2\\n        return total-maxSum*2\\n\\n\"\"\"\\nSimilar Problems: 322, 377, 416, 494, 1043, 1049, 1220, 1230, 1262, 1269\\t\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016005,
                "title": "bottom-up-in-0ms-beats-100-and-top-down-beats-100-in-space-recursive-bottom-up-top-down-approach",
                "content": "Recurssive approach:-\\n```\\nint las(vector<int>& st, int s1,int s2,int n){\\n        if(n==0)\\n            return abs(s1-s2);/when n==0 return the absolute diff. then\\n        return min(las(st,s1+st[n-1],s2,n-1),las(st,s1,s2+st[n-1],n-1));//add any of the one subset\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        return las(stones,0,0,n);\\n    }\\n```\\nMemoisation of DP, very simple\\n```\\n    int las(vector<int>& st, int s1,int s2,int n,vector<vector<int>> &dp){\\n        if(n==0)\\n        return dp[n][s1]=abs(s1-s2);\\n        if(dp[n][s1]!=-1)\\n            return dp[n][s1];\\n        return dp[n][s1]=min(las(st,s1+st[n-1],s2,n-1,dp),las(st,s1,s2+st[n-1],n-1,dp));\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        vector<vector<int>> vec( n+1 , vector<int> (3001, -1));\\n        return las(stones,0,0,n,vec);\\n    }\\n```\\nDynamic approach:-\\n```\\nint lastStoneWeightII(vector<int>& st) {\\n        int n=st.size();\\n        int sum=0;\\n        //find sum of all\\n        for(int i=0;i<n;i++)\\n            sum+=st[i]; \\n        //applied algo to find if given sum is present or not in the array\\n        bool dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<sum+1;i++){\\n            dp[0][i]=false;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<sum+1;j++){\\n                if(st[i-1]<=j)\\n                    dp[i][j]=dp[i-1][j-st[i-1]] || dp[i-1][j];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        //simply see the target one by one so that the absolute difference between the sum of subsets become minimum\\n        for(int x=sum%2==0?sum/2:sum/2+1;x<=sum;x++){\\n        if(dp[n][x]==true)//if find any then return that otherwise increment and check again\\n            return 2*x-sum;\\n            }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint las(vector<int>& st, int s1,int s2,int n){\\n        if(n==0)\\n            return abs(s1-s2);/when n==0 return the absolute diff. then\\n        return min(las(st,s1+st[n-1],s2,n-1),las(st,s1,s2+st[n-1],n-1));//add any of the one subset\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        return las(stones,0,0,n);\\n    }\\n```\n```\\n    int las(vector<int>& st, int s1,int s2,int n,vector<vector<int>> &dp){\\n        if(n==0)\\n        return dp[n][s1]=abs(s1-s2);\\n        if(dp[n][s1]!=-1)\\n            return dp[n][s1];\\n        return dp[n][s1]=min(las(st,s1+st[n-1],s2,n-1,dp),las(st,s1,s2+st[n-1],n-1,dp));\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        vector<vector<int>> vec( n+1 , vector<int> (3001, -1));\\n        return las(stones,0,0,n,vec);\\n    }\\n```\n```\\nint lastStoneWeightII(vector<int>& st) {\\n        int n=st.size();\\n        int sum=0;\\n        //find sum of all\\n        for(int i=0;i<n;i++)\\n            sum+=st[i]; \\n        //applied algo to find if given sum is present or not in the array\\n        bool dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<sum+1;i++){\\n            dp[0][i]=false;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<sum+1;j++){\\n                if(st[i-1]<=j)\\n                    dp[i][j]=dp[i-1][j-st[i-1]] || dp[i-1][j];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        //simply see the target one by one so that the absolute difference between the sum of subsets become minimum\\n        for(int x=sum%2==0?sum/2:sum/2+1;x<=sum;x++){\\n        if(dp[n][x]==true)//if find any then return that otherwise increment and check again\\n            return 2*x-sum;\\n            }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 305126,
                "title": "c-9line",
                "content": "```\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(stones.begin(), stones.end(),0);\\n        int minDiff = sum;\\n        vector<bool> dp(sum+1, 0);\\n        dp[0] = true;\\n        for(auto x:stones)\\n            for (int i = dp.size()-1; i >=0; i--) if(dp[i]) dp[i+x] = true;  \\n        for(int i=0;i<dp.size();i++)\\n            if(dp[i]) minDiff = min(minDiff, abs(i*2-sum));\\n        return minDiff;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(stones.begin(), stones.end(),0);\\n        int minDiff = sum;\\n        vector<bool> dp(sum+1, 0);\\n        dp[0] = true;\\n        for(auto x:stones)\\n            for (int i = dp.size()-1; i >=0; i--) if(dp[i]) dp[i+x] = true;  \\n        for(int i=0;i<dp.size();i++)\\n            if(dp[i]) minDiff = min(minDiff, abs(i*2-sum));\\n        return minDiff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 295020,
                "title": "python-solution-easy-to-understand",
                "content": "we could split the stones into two piles `A` and `B`, so that `abs( A - B )` has a minimum value.  Thus each stone is either in pile `A` or pile `B`. now we simply need to figure out how to spilt the stones. \\nas metioned above, each stone is only in one of the two piles, let\\'s denote `dp[i]` as whether to put the `i-th`(starting from 0) stone in to `A` or `B`. \\n* if we put it into `A`, then for all the results that before the `i-th` stone, we add the weight of `i-th` stone to them.\\n* if we put it into `B`, then for all the results that before the `i-th` stone, we subtract the weight of `i-th` stone from them.\\nkeep doing this until we put the last stone into calculation. at this point, we simply take a look at final results and the minimum abs value is the answer. below is the code:\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones) -> int:\\n        dp = [[]]\\n        dp[0] = [stones[0],stones[0] * (-1)]\\n        for i in range(1,len(stones)):\\n            dp.append([e + stones[i] for e in dp[i - 1]] + [e - stones[i] for e in dp[i - 1]])\\n            dp[i] = list(set(dp[i]))\\n        total = list(set(abs(e) for e in dp[-1]))\\n        total.sort()\\n        return total[0]\\n```\\nactually, we don\\'t need to keep track of dp arrays of all the stones, only the dp array of previous stone that matters.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones) -> int:\\n        dp = [[]]\\n        dp[0] = [stones[0],stones[0] * (-1)]\\n        for i in range(1,len(stones)):\\n            dp.append([e + stones[i] for e in dp[i - 1]] + [e - stones[i] for e in dp[i - 1]])\\n            dp[i] = list(set(dp[i]))\\n        total = list(set(abs(e) for e in dp[-1]))\\n        total.sort()\\n        return total[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346390,
                "title": "c-explaining-intuition-behind-dp",
                "content": "Suppose we have a list of stones as [x,y,z]\\n\\n`[x,y,z]`\\n\\n- Trial 1\\n\\n\\tIf we combine x & y, and x >= y we are left with,\\n\\t`[x-y,z]`\\n\\tThen if we combine (x-y) & z, and z >= (x-y) we are left with\\n\\t`[z-x+y]`\\n\\t\\n- Trial 2\\n\\tIf we combine x & z, and z >= x we are left with,\\n\\t`[z-x,y]`\\n\\tThen if we combine (z-x) & y, and (z-x) >= y we are left with\\n\\t`[z-x-y]`\\n\\t\\nUsing these obsevations we can deduce that our final answer would be the result of sum stones gettting added and some getting subtracted. Say all stones which are added have a sum of **positiveSum** and all stones which are subtracted have a sum **negativeSum**, our final answer is **positiveSum - negativeSum** and this value has to be minimised. This essentially breaks down the problem into the classical DP problem of dividing a set into two sets such that difference between sum of two sets is minimised.\\n\\n```\\nint lastStoneWeightII(vector<int>& stones) {\\n\\tint n = stones.size();\\n\\tint sum = accumulate(stones.begin(), stones.end(), 0);\\n\\n\\tint halfSum = sum/2, negativeSum = 0;\\n\\tvector<bool> possible(halfSum+1, false);\\n\\tpossible[0] = true;\\n\\n\\tfor(int stone : stones) {\\n\\t\\tfor(int target = halfSum ; target >= 1 ; target--) {\\n\\t\\t\\tbool exclude = possible[target];\\n\\t\\t\\tbool include = (stone <= target) ? possible[target - stone] : false;\\n\\t\\t\\tpossible[target] = exclude or include;\\n\\t\\t\\tif(possible[target]) negativeSum = max(negativeSum, target);\\n\\t\\t}\\n\\t}\\n\\n\\tint positiveSum = sum - negativeSum;\\n\\treturn positiveSum - negativeSum;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint lastStoneWeightII(vector<int>& stones) {\\n\\tint n = stones.size();\\n\\tint sum = accumulate(stones.begin(), stones.end(), 0);\\n\\n\\tint halfSum = sum/2, negativeSum = 0;\\n\\tvector<bool> possible(halfSum+1, false);\\n\\tpossible[0] = true;\\n\\n\\tfor(int stone : stones) {\\n\\t\\tfor(int target = halfSum ; target >= 1 ; target--) {\\n\\t\\t\\tbool exclude = possible[target];\\n\\t\\t\\tbool include = (stone <= target) ? possible[target - stone] : false;\\n\\t\\t\\tpossible[target] = exclude or include;\\n\\t\\t\\tif(possible[target]) negativeSum = max(negativeSum, target);\\n\\t\\t}\\n\\t}\\n\\n\\tint positiveSum = sum - negativeSum;\\n\\treturn positiveSum - negativeSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156639,
                "title": "dp-recursive-o-n-sum-stones-proof-of-why-partitioning-work-intuitive",
                "content": "![image](https://assets.leetcode.com/users/images/eb74b4c9-af93-489b-a219-5607eecbc554_1618325804.9613392.png)\\n\\nInspired by the Idea given by @shawshawwan discuss post :\\n https://leetcode.com/problems/last-stone-weight-ii/discuss/295167/Java-beat-100-with-nice-explanation\\n \\n Proof of why partitioning works: (Idea inspired by  @Pritam-Das)\\n\\n![image](https://assets.leetcode.com/users/images/3af61321-244d-4575-81c5-dd10310b22f2_1618330738.324079.png)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum = 0;\\n        for(auto ele:stones) sum+=ele;\\n        int ans = 0;\\n        \\n        int dp[n+2][2][sum+2];\\n        memset(dp,-1,sizeof(dp));\\n        \\n        std::function<int(int,int,int)> f = [&](int i, int take, int s){\\n            if(dp[i][take][s]!=-1) return dp[i][take][s];\\n            if(take){\\n                int t_s = s;\\n                t_s+=stones[i];\\n                if(i+1<n){\\n                    if(t_s+stones[i+1]<=(sum/2))\\n                        return dp[i][take][s] = stones[i] + max(f(i+1,1,t_s),f(i+1,0,t_s));\\n                    else return dp[i][take][s] = stones[i] + f(i+1,0,t_s);\\n                }\\n                else return dp[i][take][s] = stones[i];\\n            }\\n            else{\\n                if(i+1<n){\\n                    if(s+stones[i+1]<=(sum/2))\\n                        return dp[i][take][s] = max(f(i+1,1,s),f(i+1,0,s));\\n                    else return dp[i][take][s] = f(i+1,0,s);\\n                }\\n                else return dp[i][take][s] = 0;\\n            }\\n        };\\n        ans = 0;\\n        if(stones[0]<=(sum/2)){\\n            ans=max({ans,f(0,1,0),f(0,0,0)});\\n        }\\n        else ans=max(ans,f(0,0,0));\\n        \\n        return sum-(2*ans);\\n            \\n    }\\n};\\n```\\n\\nPS: I started writing blogs on some problems from Leetcode, Codeforces. Here\\u2019s the link of My blog (https://algorithmsplayground.blogspot.com/). If you are interested please check out the same.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum = 0;\\n        for(auto ele:stones) sum+=ele;\\n        int ans = 0;\\n        \\n        int dp[n+2][2][sum+2];\\n        memset(dp,-1,sizeof(dp));\\n        \\n        std::function<int(int,int,int)> f = [&](int i, int take, int s){\\n            if(dp[i][take][s]!=-1) return dp[i][take][s];\\n            if(take){\\n                int t_s = s;\\n                t_s+=stones[i];\\n                if(i+1<n){\\n                    if(t_s+stones[i+1]<=(sum/2))\\n                        return dp[i][take][s] = stones[i] + max(f(i+1,1,t_s),f(i+1,0,t_s));\\n                    else return dp[i][take][s] = stones[i] + f(i+1,0,t_s);\\n                }\\n                else return dp[i][take][s] = stones[i];\\n            }\\n            else{\\n                if(i+1<n){\\n                    if(s+stones[i+1]<=(sum/2))\\n                        return dp[i][take][s] = max(f(i+1,1,s),f(i+1,0,s));\\n                    else return dp[i][take][s] = f(i+1,0,s);\\n                }\\n                else return dp[i][take][s] = 0;\\n            }\\n        };\\n        ans = 0;\\n        if(stones[0]<=(sum/2)){\\n            ans=max({ans,f(0,1,0),f(0,0,0)});\\n        }\\n        else ans=max(ans,f(0,0,0));\\n        \\n        return sum-(2*ans);\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799933,
                "title": "c-greedy-vs-dp-a-simple-approach",
                "content": "First let\\'s talk about why greedy doesnt work here(at least for all the cases).I tried using greedy and only 72/84 cases passesd then I was pondering which are the cases that are failing.\\nSo then it struck me that whenever the larger elements sum equal to some smaller elements sum or near the values it fails because in Greedy I was sorting the array and looking for the neighbouring difference from left and right and take minimum of that but I forgot to consider the case where I had to deal with non-adjacent neighbours.\\n\\nThe idea behind this solution is to simply divide the array into two subsets such that difference of sum of subsets is minimum.\\n\\nBelow is the greedy solution which **doesnt work** because of the above reasons and it is also hard to bring out the intuition why Greedy doesnt work,But we can surely say why DP works because it looks for all Optimal solutions. \\n\\n**Greedy solution**\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        priority_queue<int> pqmax;\\n        priority_queue<int,vector<int>,greater<int> > pqmin;\\n        int n = stones.size();\\n        if(n == 1)\\n            return stones[0];\\n        for(auto &x : stones)\\n        {\\n            pqmax.push(x);\\n            pqmin.push(x);\\n        }\\n        while(pqmax.size() > 1)\\n        {\\n            int x = pqmax.top();\\n            pqmax.pop();\\n            int y = pqmax.top();\\n            pqmax.pop();\\n            if(x != y)\\n                pqmax.push(abs(x-y));\\n        }\\n        while(pqmin.size() > 1)\\n        {\\n            int x = pqmin.top();\\n            pqmin.pop();\\n            int y = pqmin.top();\\n            pqmin.pop();\\n            if(x != y)\\n                pqmin.push(abs(x-y));\\n        }\\n        if(pqmax.empty() || pqmin.empty())\\n            return 0;\\n        return min(pqmax.top(),pqmin.top());\\n    }\\n};\\n```\\n\\nHere is the **correct solution** based on dividing the subsets.\\n\\n**DP solution**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > dp;\\n    int find_ans(vector<int>& A,int i,int calsum,int sum)\\n    {\\n        if(i == 0)\\n            return abs((sum-calsum)-calsum);\\n        if(dp[i][calsum] != -1)\\n            return dp[i][calsum];\\n        return dp[i][calsum] = min(find_ans(A,i-1,calsum+A[i-1],sum),\\n                               find_ans(A,i-1,calsum,sum));\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum = 0;\\n        for(auto &x : stones)\\n            sum += x;\\n        dp.resize(n+1,vector<int>(sum+1,-1));\\n        return find_ans(stones,n,0,sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        priority_queue<int> pqmax;\\n        priority_queue<int,vector<int>,greater<int> > pqmin;\\n        int n = stones.size();\\n        if(n == 1)\\n            return stones[0];\\n        for(auto &x : stones)\\n        {\\n            pqmax.push(x);\\n            pqmin.push(x);\\n        }\\n        while(pqmax.size() > 1)\\n        {\\n            int x = pqmax.top();\\n            pqmax.pop();\\n            int y = pqmax.top();\\n            pqmax.pop();\\n            if(x != y)\\n                pqmax.push(abs(x-y));\\n        }\\n        while(pqmin.size() > 1)\\n        {\\n            int x = pqmin.top();\\n            pqmin.pop();\\n            int y = pqmin.top();\\n            pqmin.pop();\\n            if(x != y)\\n                pqmin.push(abs(x-y));\\n        }\\n        if(pqmax.empty() || pqmin.empty())\\n            return 0;\\n        return min(pqmax.top(),pqmin.top());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > dp;\\n    int find_ans(vector<int>& A,int i,int calsum,int sum)\\n    {\\n        if(i == 0)\\n            return abs((sum-calsum)-calsum);\\n        if(dp[i][calsum] != -1)\\n            return dp[i][calsum];\\n        return dp[i][calsum] = min(find_ans(A,i-1,calsum+A[i-1],sum),\\n                               find_ans(A,i-1,calsum,sum));\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int sum = 0;\\n        for(auto &x : stones)\\n            sum += x;\\n        dp.resize(n+1,vector<int>(sum+1,-1));\\n        return find_ans(stones,n,0,sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467073,
                "title": "c-solution-beats-100-in-memory-and-speed",
                "content": "```\\n/*\\n    https://leetcode.com/problems/last-stone-weight-ii/\\n    TC: O(n * S), S: total sum of elements\\n    SC: O(S)\\n    \\n    This problem can be transformed to another problem, it is 494. Target Stone problem on LC.\\n    Here we need to smash the rocks to get the min final weight. The thing to note here is the order\\n    in which the stones can be smashed. The problem looks like a simulation problem where you need to push the\\n    new smashed weight and run the simulation till we have only one or zero rock. But another way of thinking\\n    is that if we can group the stones in two groups such that diff of the two groups is min, then also the\\n    problem is solved. Everytime we get |x -y| the extra weight is nothing but the surplus diff in x and this diff\\n    is used in the next iteration of simulation. So by forming two max groups P and N, we also account for the surplus of each stone in the group only and when they are smashed the net diff gives us the same effect as simulation.\\n    \\n    So the problem in hand: P - N = Target(T)\\n    We try to maximize both P and N to get the min T.\\n    This can be done using DP.\\n    \\n    P - N = T\\n    2P - P - N = T\\n    2P = T + S, sum(S) = N + P\\n    \\n*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightTabular(vector<int>& stones){\\n        // calculate the sum of all values\\n        int total = accumulate(stones.begin(), stones.end(), 0);\\n        int min_weight = total;\\n        \\n        // dp(i): can P with sum \\'i\\' be formed \\n        vector<bool> dp(total/2 + 1, false);\\n        //getting a sum of zero is always possible\\n        dp[0] = true;\\n        \\n        for(const int& stone: stones) {\\n            for(int i = total/2; i >= stone; i--) {\\n                dp[i] = dp[i] || dp[i - stone];\\n                \\n                // 2P = T + S, we need to find min(T)\\n                int target = abs(2*i - total);\\n                if(dp[i])\\n                    min_weight = min(min_weight, target);\\n            }\\n        }\\n        \\n        return min_weight;\\n    }\\n    \\n    // driver \\n    int lastStoneWeightII(vector<int>& stones) {\\n        return lastStoneWeightTabular(stones);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    https://leetcode.com/problems/last-stone-weight-ii/\\n    TC: O(n * S), S: total sum of elements\\n    SC: O(S)\\n    \\n    This problem can be transformed to another problem, it is 494. Target Stone problem on LC.\\n    Here we need to smash the rocks to get the min final weight. The thing to note here is the order\\n    in which the stones can be smashed. The problem looks like a simulation problem where you need to push the\\n    new smashed weight and run the simulation till we have only one or zero rock. But another way of thinking\\n    is that if we can group the stones in two groups such that diff of the two groups is min, then also the\\n    problem is solved. Everytime we get |x -y| the extra weight is nothing but the surplus diff in x and this diff\\n    is used in the next iteration of simulation. So by forming two max groups P and N, we also account for the surplus of each stone in the group only and when they are smashed the net diff gives us the same effect as simulation.\\n    \\n    So the problem in hand: P - N = Target(T)\\n    We try to maximize both P and N to get the min T.\\n    This can be done using DP.\\n    \\n    P - N = T\\n    2P - P - N = T\\n    2P = T + S, sum(S) = N + P\\n    \\n*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightTabular(vector<int>& stones){\\n        // calculate the sum of all values\\n        int total = accumulate(stones.begin(), stones.end(), 0);\\n        int min_weight = total;\\n        \\n        // dp(i): can P with sum \\'i\\' be formed \\n        vector<bool> dp(total/2 + 1, false);\\n        //getting a sum of zero is always possible\\n        dp[0] = true;\\n        \\n        for(const int& stone: stones) {\\n            for(int i = total/2; i >= stone; i--) {\\n                dp[i] = dp[i] || dp[i - stone];\\n                \\n                // 2P = T + S, we need to find min(T)\\n                int target = abs(2*i - total);\\n                if(dp[i])\\n                    min_weight = min(min_weight, target);\\n            }\\n        }\\n        \\n        return min_weight;\\n    }\\n    \\n    // driver \\n    int lastStoneWeightII(vector<int>& stones) {\\n        return lastStoneWeightTabular(stones);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461955,
                "title": "python3-all-possible-sums",
                "content": "I did not see the knapsack intuition when solving this problem.\\nBut since the weight of the final stone will be a formation sum of all stones with +- signs (because any new stones is an absolute difference of two stones). So, I approach this by generating all possible sums. \\n\\n```python\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        s = {0}\\n        for st in stones:\\n            tmp = set()\\n            for i in s:\\n                tmp.add(abs(i + st))\\n                tmp.add(abs(i - st))\\n            s = tmp\\n        return min(s) if len(s) > 0 else 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        s = {0}\\n        for st in stones:\\n            tmp = set()\\n            for i in s:\\n                tmp.add(abs(i + st))\\n                tmp.add(abs(i - st))\\n            s = tmp\\n        return min(s) if len(s) > 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401408,
                "title": "c-my-second-practice-is-to-study-the-code-and-then-write-some-explanation",
                "content": "Oct. 9, 2019\\n1049. Last Stone Weight II\\n**Problem rephrase 1 minute Warmup**\\nTwo stones smash - [2, 4], after smash, x = 2 , y = 4, left: 2\\nAsking minimum left. \\nInput: [2,7,4,1,8,1]\\nOutput: 1\\n\\nIt is a good idea to learn to write more than one solution. What I did is to study the most popular post in the discussion post, and then I wrote one C# solution. \\n\\nIt is important to read the case study I prepare first, and then it will be much easy to follow the design of the solution. \\n\\n**Case study**\\nGiven the array with values [31, 26, 33, 21, 40], the sum of the array is 151, let us denote it as Sum. Sum/ 2 will be 75. We can divide into two sets, [33, 40] and [31, 26, 21], the sum of first array is 73, and the sum of second array is 78, the minimum difference is 5. \\n\\nBut if we update the loop from ascending (this is descending, (**for (int i = Math.Min(1500, prefixSum); i >= item; i--)**), one number may be used more than once, so that minimum difference can be one. Since [26, 26, 23] can be an array, but 26 is counted twice, the sum of the array is 75, so 151 - 2 * 75 = 1. \\n\\n**The challenges**\\n1. How to design the solution so that each stone will be at most counted once to the sum? \\n2. Argue to yourself, why order does not matter? We can count each stone at most once in any sum, but which goes first does not matter. \\n\\nHere are highlights:\\n1. Understand how to convert the problem to classical Knapsack problem to divide array into two sets; \\n2. Understand how to find all possible sum using all stones available, make sure that one stone can only be used at most once for each sum;\\n3. Most challenging problem is to design the search using descending order. Detail see my first practice if you have questions. [Here](https://leetcode.com/problems/last-stone-weight-ii/discuss/400758/C-Convert-to-classical-algorithm-Knapsack-problem) is the post. \\n4. Go over a test case and learn the case study before working on the solution. \\n\\nAdded on Oct. 28, 2020\\n**Warmup dynamic programming idea**\\nLet me work on test case [1, 2, 3, 4], since maximum length is 30, maximum value 100, so the length of array 4 maximum value is 200. Declare bool dp[201], default value false. \\n\\nWe know any i (1 to 4) combination of those 4 stones should be true.\\ndp[1] = true\\ndp[2] = true\\ndp[3] = true\\ndp[4] = true\\nSum of the array is 10, so dp[10] = true. \\nHow to build the value from bottom up? \\nBrute force solution to search, given any stone in the stones.\\nStone can be any order, not necessary sorted. \\nstarting from maximum value 200, for example, stone is 3, \\ndp[200] = true if dp[200 - 3] is true, simple version in programming language, dp[200] |= dp[197], | is bit manipulation OR operator in C#. \\ncontinue to work on dp[199] until dp[3], 3 >= given stone value = 3. \\nIn order to find minimum weight, go from index = 200 to search if dp[index] is true with decrement value 1. \\n\\nSimilar idea can be found in another dynamic programming algorithm, 472. Concatenated Words, [here](https://leetcode.com/problems/concatenated-words/discuss/903610/c-break-into-hashset-dp-problem) is my practice with explanation. \\n\\n**Dynamic programming algorithm Advice**\\n\\n[DP for Beginners [Problems | Patterns | Sample Solutions]](https://leetcode.com/discuss/general-discussion/662866/dp-for-beginners-problems-patterns-sample-solutions)\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1049_last_stone_weight_II___lee215\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Oct. 9, 2019\\n        /// study code\\n        /// https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP\\n        /// \\n        /// The idea is to implement the solution using time complexity O(NS), N is length of the array, S is the sum of the array. \\n        /// space complexity is O(S), where S = sum of the array stones. \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int LastStoneWeightII(int[] stones)\\n        {\\n            // length <= 30, value of stones [1, 100], maximum sum is 3000\\n            var dp = new bool[1501];\\n\\n            dp[0] = true;\\n            var sum = stones.Sum();\\n\\n            var prefixSum = 0; \\n\\n            foreach (var item in stones)\\n            {\\n                prefixSum += item;\\n                for (int i = Math.Min(1500, prefixSum); i >= item; i--)\\n                {\\n                    dp[i] |= dp[i - item];  // logical OR operator\\n                }\\n            }\\n\\n            for(int i = sum/2; i > 0; i--)\\n            {\\n                if(dp[i])\\n                {\\n                    return sum - i * 2; \\n                }\\n            }\\n\\n            return 0; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1049_last_stone_weight_II___lee215\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Oct. 9, 2019\\n        /// study code\\n        /// https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP\\n        /// \\n        /// The idea is to implement the solution using time complexity O(NS), N is length of the array, S is the sum of the array. \\n        /// space complexity is O(S), where S = sum of the array stones. \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int LastStoneWeightII(int[] stones)\\n        {\\n            // length <= 30, value of stones [1, 100], maximum sum is 3000\\n            var dp = new bool[1501];\\n\\n            dp[0] = true;\\n            var sum = stones.Sum();\\n\\n            var prefixSum = 0; \\n\\n            foreach (var item in stones)\\n            {\\n                prefixSum += item;\\n                for (int i = Math.Min(1500, prefixSum); i >= item; i--)\\n                {\\n                    dp[i] |= dp[i - item];  // logical OR operator\\n                }\\n            }\\n\\n            for(int i = sum/2; i > 0; i--)\\n            {\\n                if(dp[i])\\n                {\\n                    return sum - i * 2; \\n                }\\n            }\\n\\n            return 0; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295401,
                "title": "c-dp-inspired-by-the-hints-double-100-with-explanation",
                "content": "The normal way to break a DP question is try to think how we can solve new question with bigger scope from results of previous question of smaller scope. Take this question for example:\\n1. We will need to figure out how we can get miminum stone left for stones [a0, a1, ... , an] based on if we can somehow know the minimus stone left for stones [a0, a1, ... , an-1]\\n2. The naive thought will be if I can know all the possible left stones from [[a0, a1, ... , an-1]], say it is [L1, L2, ... Lm], then we can konw the final results based on minium of [abs(L1 - an), abs(L2 - an), ... abs(Lm - an)]\\n3. But this could be wrong, say we have stone 8 and previous stone [1, 2, 4], the possible outcome of [1, 2, 4] are [1, 3], then combine with 8 we can results from [5, 7], while the correct final result should be 1\\n4. Based on the hints \"Use dynamic programming: for every possible sum with N stones, those sums +x or -x is possible with N+1 stones, where x is the value of the newest stone.\"\\n5. We can know that we should not only get valid left stones from previous smaller scope question we should also get \"currently unvalid left stones\", which is all positive or all negative, cause they could become valid combine with the new stone. So the leftstones of [1,2,4] should be [-7, -5, -3, -1, 1, 3, 5, 7]\\n6. If we combine with 8 we can get [-15, -13, -11, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15], and the final result will be the smallest number from the possible result >= 0\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> stoneLeft;\\n        for (int& stone : stones) {\\n            if (stoneLeft.empty()) {\\n                stoneLeft.insert(stone);\\n                stoneLeft.insert(-stone);\\n            }\\n            else {\\n                unordered_set<int> temp;\\n                for (int left : stoneLeft) {\\n                    temp.insert(left + stone);\\n                    temp.insert(left - stone);\\n                }\\n                stoneLeft = temp;\\n            }\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int left : stoneLeft) {\\n            if (left >= 0) {\\n                result = min(left, result);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> stoneLeft;\\n        for (int& stone : stones) {\\n            if (stoneLeft.empty()) {\\n                stoneLeft.insert(stone);\\n                stoneLeft.insert(-stone);\\n            }\\n            else {\\n                unordered_set<int> temp;\\n                for (int left : stoneLeft) {\\n                    temp.insert(left + stone);\\n                    temp.insert(left - stone);\\n                }\\n                stoneLeft = temp;\\n            }\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int left : stoneLeft) {\\n            if (left >= 0) {\\n                result = min(left, result);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295030,
                "title": "share-my-java-solution-knapsacks-problem",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int ele: stones){\\n            sum+=ele;\\n        }\\n        int total_sum = sum;\\n        int n = stones.length;\\n        sum/=2;\\n        \\n        boolean[][] dp = new boolean[sum+1][n+1];\\n        for(int j=0;j<=n;j++){\\n            dp[0][j] = true;\\n        }\\n        int max = 0;\\n        for(int i=1;i<=sum;i++){\\n            for(int j=1;j<=stones.length;j++){\\n                if(dp[i][j-1]==true || (i>=stones[j-1] && dp[i-stones[j-1]][j-1])){\\n                    dp[i][j] = true;\\n                    max = Math.max(i, max);\\n                }\\n            }\\n        }\\n        \\n        \\n        return total_sum-max*2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int ele: stones){\\n            sum+=ele;\\n        }\\n        int total_sum = sum;\\n        int n = stones.length;\\n        sum/=2;\\n        \\n        boolean[][] dp = new boolean[sum+1][n+1];\\n        for(int j=0;j<=n;j++){\\n            dp[0][j] = true;\\n        }\\n        int max = 0;\\n        for(int i=1;i<=sum;i++){\\n            for(int j=1;j<=stones.length;j++){\\n                if(dp[i][j-1]==true || (i>=stones[j-1] && dp[i-stones[j-1]][j-1])){\\n                    dp[i][j] = true;\\n                    max = Math.max(i, max);\\n                }\\n            }\\n        }\\n        \\n        \\n        return total_sum-max*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611670,
                "title": "0-1-knapsack-variant-aditya-verma-s-approach",
                "content": "# Intuition\\nLet\\'s take the example of the array [2, 7, 4, 1, 8, 1]:\\n\\n- We start by smashing the stones in pairs: (8-7), (4-2), (1-1).\\n- This reduces the array to [1, 2, 0].\\n- In the second go, we can smash 2 and 1 together, resulting in a single stone with a weight of 1, which is the minimum weight possible.\\n- Essentially, this process can be represented as: (8-7) - (4-2) + (1-1) = 8 + 2 + 1 - 7 - 4 - 1.\\n- Further simplifying, we can express this as: (8, 2, 1) - (7, 4, 1).\\n- In essence, this operation is equivalent to dividing the stones into two subsets such that their difference is minimized, which results in the smallest weight difference.\\n- Therefore, this problem aligns with the concept of the minimum subset sum difference problem.\\n\\n# Complexity\\n- Time complexity:\\n    - The code utilizes a dynamic programming approach to solve the minimum subset sum difference problem.\\n    - Constructing the t table requires iterating over n elements and sum/2 elements, resulting in a nested loop with a time complexity of O(n * sum/2).\\n    - Finding the minimum difference by scanning the last row of the table requires iterating from sum/2 to 0, resulting in a linear time complexity of O(sum/2).\\n    - Overall, the time complexity of the minDiffSubset function is O(n * sum/2).\\n\\n- Space complexity:\\n    - The space complexity of the code is determined by the size of the t table, which is a 2D vector of dimensions (n+1) x (sum/2+1).\\n    - Therefore, the space complexity is O(n * sum/2).\\n\\n# Code\\n```\\nclass Solution {\\n    int minDiffSubset(vector<int>& stones, int n, int sum) {\\n        vector<vector<bool>> t(n+1, vector<bool>(sum/2+1));\\n        for(int col = 0; col<sum/2+1; col++)\\n            t[0][col] = false;\\n        for(int row = 0; row<n+1; row++)\\n            t[row][0] = true;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            for(int j = 1; j<sum/2+1; j++) {\\n                if(stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j-stones[i-1]] || t[i-1][j];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int i = sum/2;\\n        for(; i>=0; i--) {\\n            if(t[n][i] == true)\\n                break;\\n        }\\n        return (sum-2*i);\\n    }\\n\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        int n = stones.size();\\n        for(int i = 0;i<n;i++){\\n            sum+=stones[i];\\n        }\\n        return minDiffSubset(stones, n, sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int minDiffSubset(vector<int>& stones, int n, int sum) {\\n        vector<vector<bool>> t(n+1, vector<bool>(sum/2+1));\\n        for(int col = 0; col<sum/2+1; col++)\\n            t[0][col] = false;\\n        for(int row = 0; row<n+1; row++)\\n            t[row][0] = true;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            for(int j = 1; j<sum/2+1; j++) {\\n                if(stones[i-1] <= j) {\\n                    t[i][j] = t[i-1][j-stones[i-1]] || t[i-1][j];\\n                } else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int i = sum/2;\\n        for(; i>=0; i--) {\\n            if(t[n][i] == true)\\n                break;\\n        }\\n        return (sum-2*i);\\n    }\\n\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        int n = stones.size();\\n        for(int i = 0;i<n;i++){\\n            sum+=stones[i];\\n        }\\n        return minDiffSubset(stones, n, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435484,
                "title": "python-similar-to-knapsack-dp-top-down-recursion-only",
                "content": "At first I am actually stuck, really confuse as to finding the recurrence relation.\\n\\nAt first I thought this problem would be divide and conquer using left and right pointer, and choosing minLeft stone, rightStone and i th stone.\\n\\nAlready coded that and completely wrong. After few test cases.\\n\\nSo I give up and browsing through discussion. I found this article helpful https://leetcode.com/problems/last-stone-weight-ii/discuss/653550/Trying-to-Explain-A-bit-(logic-behind-trick)\\n\\nThis 5 lines explanation of that article give me some clue immediately also plus knapsack keyword in some of the titles\\n```\\n//let say array be [a,b,c,d]\\n//answer = (a+b)-(c+d) OR\\n//answer = a-(b+c+d) Or\\n//answer = (d+b)-(a+c) and so on.. any combination could be possible\\n//notice that in general I can say that\\n//answer = S1-S2\\n```\\n\\nSo if there are array [a,b,c,d]\\n\\nyou can combine them like this\\n+a+b+c+d = gap1\\n+a+b+c-d = gap2\\n+a+b-c+d = gap3\\n+a+b-c-d = gap3\\nso on\\n\\nSo i notice that I can propagate the sum from left to right\\n\\nwhat happen at the end?\\n\\nwe only get the absolute value of each gap and then search for minimum\\n\\nLook, we aim a result that the one closest to zero.\\n\\nHere is the full code (memoized using @cache python feature (similar to using HashMap to memoize based on params))\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        @cache\\n        def dfs(idx, curW):\\n            if idx==len(stones):\\n                return abs(curW)\\n            return min(\\n                dfs(idx+1, curW+stones[idx]),\\n                dfs(idx+1, curW-stones[idx])\\n            )\\n        return dfs(0,0)\\n```\\n\\n\\nTime Complexity = O(N * S)\\nSpace Complexity = O(N * S)\\nS is possible sum value, in my case (based on constraints) S = stones.length * stonesPossibleValue * 2 = 30 * 100 * 2 = 6000\\n\\n2 comes from minus and plus sign of curW\\n\\nUsually after you get the recursion, then you can move forward to Bottom Up, I will leave that to you as homework.\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n//let say array be [a,b,c,d]\\n//answer = (a+b)-(c+d) OR\\n//answer = a-(b+c+d) Or\\n//answer = (d+b)-(a+c) and so on.. any combination could be possible\\n//notice that in general I can say that\\n//answer = S1-S2\\n```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        @cache\\n        def dfs(idx, curW):\\n            if idx==len(stones):\\n                return abs(curW)\\n            return min(\\n                dfs(idx+1, curW+stones[idx]),\\n                dfs(idx+1, curW-stones[idx])\\n            )\\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184148,
                "title": "c-knapsack-type-dp-with-intuition",
                "content": "class Solution {\\npublic:\\n    \\n    int dp[31][3001];\\n    vector <int> stones;\\n    int sm = 0;\\n    // state - level, positive sum till now\\n    \\n    /*\\n    let a,b,c,d be the weight of stones initially\\n    all possible configurations like +a-b+c+d,-a-b-c+d etc can be achieved\\n    i.e (+/-)a (+/-)b (+/-) c (+/-)d\\n    so the problem now is by assigning a positive or neg sign in front of each number we have to get smallest positive sum\\n    after finding the soln, we can backtrack and get the number which contribute positively and which contribute negatively\\n    to simulate the process to get the answer what we can do is:\\n    take largest from positive side and from negative side, say they are x1 and x2\\n    we need x1-x2 so if x1>x2 we put x1-x2 in positive side , if x1<x2 we put x2-x1 in negative side so that it becomes x1-x2 in next step\\n    so the process can be simulated in this way to assign the correct signs\\n    */\\n    \\n    int rec(int level,int pos){\\n        if(level == stones.size()){\\n            int neg = sm-pos;\\n            if(pos<neg) return 1e9;\\n            return pos-neg;\\n        }\\n        if(dp[level][pos] != -1) return dp[level][pos];\\n        int ans = min(rec(level+1,pos),rec(level+1,pos+stones[level]));\\n        return dp[level][pos] = ans;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& _stones) {\\n        stones = _stones;\\n        for(auto val:stones) sm+=val;\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[31][3001];\\n    vector <int> stones;\\n    int sm = 0;\\n    // state - level, positive sum till now\\n    \\n    /*\\n    let a,b,c,d be the weight of stones initially\\n    all possible configurations like +a-b+c+d,-a-b-c+d etc can be achieved\\n    i.e (+/-)a (+/-)b (+/-) c (+/-)d\\n    so the problem now is by assigning a positive or neg sign in front of each number we have to get smallest positive sum\\n    after finding the soln, we can backtrack and get the number which contribute positively and which contribute negatively\\n    to simulate the process to get the answer what we can do is:\\n    take largest from positive side and from negative side, say they are x1 and x2\\n    we need x1-x2 so if x1>x2 we put x1-x2 in positive side , if x1<x2 we put x2-x1 in negative side so that it becomes x1-x2 in next step\\n    so the process can be simulated in this way to assign the correct signs\\n    */\\n    \\n    int rec(int level,int pos){\\n        if(level == stones.size()){\\n            int neg = sm-pos;\\n            if(pos<neg) return 1e9;\\n            return pos-neg;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1780759,
                "title": "c-easy-solution-minimum-subset-difference-similar-problem",
                "content": "```\\nProblem is similar or combination of 2 or more basic problems of DP\\n1. Equal Partition Sum\\n2. Minimum Diff Subset\\n```\\n\\n```\\nGiven Problem is a combination of these 2 problems\\n```\\n\\n```\\nWHAT PROBLEM WANTS OR HOW TO SOLVE ???\\n\\nBasically we have to find minimum weight of the stones which remain after striking or return 0 if non of them remains.\\nQuestion also provides some parameters for striking \\n1. if weight of two stones is equal then they both destroys.\\n2. if there is difference in weight of there stones then subtract and smaller one get removed and larger one get updated value of there difference.\\n```\\n\\n\\n```\\nIf i say we don\\'t require all these things, then it loos like quite interesting BUT how let me share with you.\\nIf you have done problem of Equal partition sum then you can realize it with it. In that problem we have partition the given array in such a way that the difference of 2 subset will be 0. \\nSo you can relate this problem with that. In this we also need to find two subset such that for there difference we get a minimum value. It can be 0 or anything.\\nFor that problem and solution it i am sharing the link [ https://leetcode.com/problems/partition-equal-subset-sum/discuss/1773198/cdp-problemusing-2-different-method-with-proper-explanation ]\\n\\nSo first part for partition is solved in that way next remaining part is to get that minimum difference.\\nSo first talk about little bit of maths and array partition.\\nI know i have to divide that array in two parts so to get subset which can provide the minimum difference.\\nIf i talk about the patition part, the basic subset if i get a maximum difference then i want one empty subset and one subset which contain all the element of array. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t { array }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /              \\\\\\n\\t\\t\\t\\t\\t\\t        subset 1          subset 2\\n\\t\\t\\t\\t\\t\\t\\t     \\t|                 |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tS1                S2\\nS1 is the sum of all element in subset 1.\\nS2 is the sum of all element of subset 2.\\nwe have to find \\n\\t\\t\\t\\tMinimum (S1 - S2) or (S2-S1).\\nSo to in more generalized form of it what i do i\\'ll make subset 1 of smaller element  and for subset 2 element.\\nWe can find it without doing anything.\\nBUT HOW ??\\nIts simple i know the value of the element will lie in range 0 to sum of all element.\\nBut most important thingh is that its not fix all the points between that range(in simple words my sum range ) will lie in my subset.\\nso don\\'t go recklessly.\\nI know my subset 1 element.\\nAnd i know \\n\\t\\t\\t\\tS1 + S2  = sum (range).\\nTherefore \\n\\t\\t\\t\\tS2 = sum - S1 ;\\nSo i can find that subset 2 element by just minus but that thing i don\\'t want.\\nMost Important thing i want the difference.\\nLets derive a formula for it\\nI know \\n\\t\\t\\tS2 - S1 = minimum\\nAnd i have \\n\\t\\t\\tS2 = Range - S1\\nBy using that 2 formula i can derive this \\n\\t\\t  Range - S1 - S1 = minimum.\\nTherefore \\n\\t\\t\\t Minimum = Range - 2*S1.\\nNow i have subset 1 element and the range (which is simply the sum of element).\\nAnd for S1 element we can traverse the last row of my DP matrix.\\nand get the minimum abs value of my difference.\\n```\\n\\n```\\nI am assuming that the viewer have a basic idea of DP with iterative method.\\n```\\n\\n```\\nIf You like this pls UpVote it helps me to stay +ve and motivated\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n\\t\\tint N=stones.size();\\n\\t\\t\\n        int sum=0,diff;\\n        \\n\\t\\tfor(int i=0;i<N;i++)\\n            sum+=stones[i];\\n\\t\\t\\t\\n        int T[N+1][sum+1];\\n        \\n\\t\\t for (int i = 0; i < N + 1; ++i)  \\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < sum + 1; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tT[i][j] = 0;          //for my first row because there is no empty error whose have any sum value other than 0. \\n\\t\\t\\t    if (j == 0)     //for my first column because there is no any non +ve empty error whose have sum value eq to 0 \\n\\t\\t\\t\\t\\tT[i][j] = 1;\\n        }\\n    }\\n\\n        for (int i = 1; i < N + 1; ++i)                   \\n        {\\n            for (int j = 1; j < sum + 1; ++j)\\n            {\\n                if (stones[i - 1] <= j)      //if my weight of stone is less than corresponding weights of sum row\\n                    T[i][j] = T[i - 1][j] || T[i - 1][j - stones[i - 1]];\\n                else\\n                    T[i][j] = T[i - 1][j];\\n            }\\n        }\\n        int mn=INT_MAX;\\n\\t\\t\\n        for(int j=0;j<=sum;j++)\\n            if(T[N][j])\\n                mn=min(mn,abs(sum-2*j));\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nProblem is similar or combination of 2 or more basic problems of DP\\n1. Equal Partition Sum\\n2. Minimum Diff Subset\\n```\n```\\nGiven Problem is a combination of these 2 problems\\n```\n```\\nWHAT PROBLEM WANTS OR HOW TO SOLVE ???\\n\\nBasically we have to find minimum weight of the stones which remain after striking or return 0 if non of them remains.\\nQuestion also provides some parameters for striking \\n1. if weight of two stones is equal then they both destroys.\\n2. if there is difference in weight of there stones then subtract and smaller one get removed and larger one get updated value of there difference.\\n```\n```\\nIf i say we don\\'t require all these things, then it loos like quite interesting BUT how let me share with you.\\nIf you have done problem of Equal partition sum then you can realize it with it. In that problem we have partition the given array in such a way that the difference of 2 subset will be 0. \\nSo you can relate this problem with that. In this we also need to find two subset such that for there difference we get a minimum value. It can be 0 or anything.\\nFor that problem and solution it i am sharing the link [ https://leetcode.com/problems/partition-equal-subset-sum/discuss/1773198/cdp-problemusing-2-different-method-with-proper-explanation ]\\n\\nSo first part for partition is solved in that way next remaining part is to get that minimum difference.\\nSo first talk about little bit of maths and array partition.\\nI know i have to divide that array in two parts so to get subset which can provide the minimum difference.\\nIf i talk about the patition part, the basic subset if i get a maximum difference then i want one empty subset and one subset which contain all the element of array. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t { array }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /              \\\\\\n\\t\\t\\t\\t\\t\\t        subset 1          subset 2\\n\\t\\t\\t\\t\\t\\t\\t     \\t|                 |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tS1                S2\\nS1 is the sum of all element in subset 1.\\nS2 is the sum of all element of subset 2.\\nwe have to find \\n\\t\\t\\t\\tMinimum (S1 - S2) or (S2-S1).\\nSo to in more generalized form of it what i do i\\'ll make subset 1 of smaller element  and for subset 2 element.\\nWe can find it without doing anything.\\nBUT HOW ??\\nIts simple i know the value of the element will lie in range 0 to sum of all element.\\nBut most important thingh is that its not fix all the points between that range(in simple words my sum range ) will lie in my subset.\\nso don\\'t go recklessly.\\nI know my subset 1 element.\\nAnd i know \\n\\t\\t\\t\\tS1 + S2  = sum (range).\\nTherefore \\n\\t\\t\\t\\tS2 = sum - S1 ;\\nSo i can find that subset 2 element by just minus but that thing i don\\'t want.\\nMost Important thing i want the difference.\\nLets derive a formula for it\\nI know \\n\\t\\t\\tS2 - S1 = minimum\\nAnd i have \\n\\t\\t\\tS2 = Range - S1\\nBy using that 2 formula i can derive this \\n\\t\\t  Range - S1 - S1 = minimum.\\nTherefore \\n\\t\\t\\t Minimum = Range - 2*S1.\\nNow i have subset 1 element and the range (which is simply the sum of element).\\nAnd for S1 element we can traverse the last row of my DP matrix.\\nand get the minimum abs value of my difference.\\n```\n```\\nI am assuming that the viewer have a basic idea of DP with iterative method.\\n```\n```\\nIf You like this pls UpVote it helps me to stay +ve and motivated\\n```\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n\\t\\tint N=stones.size();\\n\\t\\t\\n        int sum=0,diff;\\n        \\n\\t\\tfor(int i=0;i<N;i++)\\n            sum+=stones[i];\\n\\t\\t\\t\\n        int T[N+1][sum+1];\\n        \\n\\t\\t for (int i = 0; i < N + 1; ++i)  \\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < sum + 1; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tT[i][j] = 0;          //for my first row because there is no empty error whose have any sum value other than 0. \\n\\t\\t\\t    if (j == 0)     //for my first column because there is no any non +ve empty error whose have sum value eq to 0 \\n\\t\\t\\t\\t\\tT[i][j] = 1;\\n        }\\n    }\\n\\n        for (int i = 1; i < N + 1; ++i)                   \\n        {\\n            for (int j = 1; j < sum + 1; ++j)\\n            {\\n                if (stones[i - 1] <= j)      //if my weight of stone is less than corresponding weights of sum row\\n                    T[i][j] = T[i - 1][j] || T[i - 1][j - stones[i - 1]];\\n                else\\n                    T[i][j] = T[i - 1][j];\\n            }\\n        }\\n        int mn=INT_MAX;\\n\\t\\t\\n        for(int j=0;j<=sum;j++)\\n            if(T[N][j])\\n                mn=min(mn,abs(sum-2*j));\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779759,
                "title": "using-subset-sum-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        memset(dp, -1, sizeof(dp));\\n        int sum = 0;\\n        for(auto i : stones)\\n            sum += i;\\n        \\n        int mindiff = INT_MAX;\\n        for(int i = (sum/2)+1; i >= 0; i--)     // i is sum of the partation\\n            if(SubsetSum(stones, i, 0)) \\n                mindiff = min(mindiff, abs((sum - i)-i)); \\n        \\n        return mindiff;\\n    }\\n    \\n    bool SubsetSum(vector<int>& v, int target, int i) {\\n        if(target == 0)\\n            return 1;\\n        if(i >= v.size())\\n            return 0;\\n        \\n        if(dp[i][target] != -1)\\n            return dp[i][target];\\n        \\n        \\n        if(v[i] > target)\\n            return dp[i][target] = SubsetSum(v, target, i+1);\\n        return dp[i][target] = SubsetSum(v, target - v[i], i+1) || SubsetSum(v, target, i+1);\\n    }\\n    \\n    private :\\n    int dp[35][3005];\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        memset(dp, -1, sizeof(dp));\\n        int sum = 0;\\n        for(auto i : stones)\\n            sum += i;\\n        \\n        int mindiff = INT_MAX;\\n        for(int i = (sum/2)+1; i >= 0; i--)     // i is sum of the partation\\n            if(SubsetSum(stones, i, 0)) \\n                mindiff = min(mindiff, abs((sum - i)-i)); \\n        \\n        return mindiff;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1474793,
                "title": "python-multiple-recursive-and-dp-solutions",
                "content": "__Solution 1__: Recursive solution with 2 options in each state. Either add or subtract element in `stones`. Use caching: O(sum\\\\*L).\\n```\\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(csum, i):\\n            if i < 0 and csum >= 0: return csum\\n            if i < 0: return float(\\'inf\\')\\n            return min(dfs(csum+stones[i], i-1), dfs(csum-stones[i], i-1))\\n        return dfs(0, len(stones)-1)\\n```\\n__Solution 2__: Find subsequence with sum closest (and smaller) to `sum(stones)/2`. \\n```    \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(diff, i):\\n            if diff < 0: return -float(\\'inf\\')\\n            if i < 0 or diff == 0: return 0 \\n            return max(stones[i] + dfs(diff - stones[i], i-1), dfs(diff, i-1))\\n        S = sum(stones)\\n        return S - int(2*dfs(S/2, len(stones)-1))\\n```\\n__Solution 3__: (alternative to solution 2). Find subsequence with sum closest (and smaller) to `sum(stones)/2`. \\n```    \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # O(sum*len(stones)) time and space\\n        @lru_cache(None)\\n        def dfs(diff, i):\\n            if diff < 0: return float(\\'inf\\')\\n            if i < 0 or diff == 0: return diff \\n            return min(dfs(diff - stones[i], i-1), dfs(diff, i-1))\\n        return int(2*dfs(sum(stones)/2, len(stones)-1))\\n ```\\n__Solution 4__: DP. Find subsequence with sum closest (and smaller) to `sum(stones)/2`. Similar to knapsack 0-1.\\n```           \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # DP: O(sum*len(stones)) time and space\\n        L = len(stones)\\n        S = sum(stones)\\n        dp = [[0]*(S//2+1) for _ in range(L+1)]\\n        for i in range(1, L+1):\\n            for j in range(1, S//2+1):\\n                if stones[i-1] <= j:\\n                    dp[i][j] = max(dp[i-1][j], stones[i-1]+dp[i-1][j-stones[i-1]])\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return S -2*dp[L][-1]\\n```\\n__Solution 5__: DP but with O(sum) in space.\\n```\\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # DP: O(sum*len(stones)) time and O(sum) space\\n        S = sum(stones)\\n        dp = [0]*(S//2+1)\\n        for i in range(len(stones)):\\n            for j in range(S//2, stones[i]-1, -1):\\n                    dp[j] = max(dp[j], stones[i]+dp[j-stones[i]])\\n        return S-2*dp[-1]",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(csum, i):\\n            if i < 0 and csum >= 0: return csum\\n            if i < 0: return float(\\'inf\\')\\n            return min(dfs(csum+stones[i], i-1), dfs(csum-stones[i], i-1))\\n        return dfs(0, len(stones)-1)\\n```\n```    \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(diff, i):\\n            if diff < 0: return -float(\\'inf\\')\\n            if i < 0 or diff == 0: return 0 \\n            return max(stones[i] + dfs(diff - stones[i], i-1), dfs(diff, i-1))\\n        S = sum(stones)\\n        return S - int(2*dfs(S/2, len(stones)-1))\\n```\n```    \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # O(sum*len(stones)) time and space\\n        @lru_cache(None)\\n        def dfs(diff, i):\\n            if diff < 0: return float(\\'inf\\')\\n            if i < 0 or diff == 0: return diff \\n            return min(dfs(diff - stones[i], i-1), dfs(diff, i-1))\\n        return int(2*dfs(sum(stones)/2, len(stones)-1))\\n ```\n```           \\ndef lastStoneWeightII(self, stones: List[int]) -> int:\\n        # DP: O(sum*len(stones)) time and space\\n        L = len(stones)\\n        S = sum(stones)\\n        dp = [[0]*(S//2+1) for _ in range(L+1)]\\n        for i in range(1, L+1):\\n            for j in range(1, S//2+1):\\n                if stones[i-1] <= j:\\n                    dp[i][j] = max(dp[i-1][j], stones[i-1]+dp[i-1][j-stones[i-1]])\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return S -2*dp[L][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1420720,
                "title": "java-bottom-up-dp-explained-using-minimum-subset-difference",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n\\n        //  Input: a, b\\n        // Smash them, answer: (a) - (b)\\n\\n        // Input: a, b, c\\n        // Smash them, answer: (a) - (b - c)\\n\\n        // Input: a, b, c, d\\n        // Smash them, answer: (a - b) - (c - d) => (a + d) - (b + c)\\n\\n        // The same property holds true if the elements are re-ordered to \\n        //          [c, a, d, b]. \\n        // Answer: (c - a) - (d - b) => (c + b) - (a + d) : this final subtraction is the last stone left\\n\\n        //we need to divide the array into two subarrays such that their diffrence is minimum\\n        //s2-s1 is minimum\\n        //s1+s2 = sum;\\n        int sum = 0;\\n        for(int stone : stones) {\\n            sum += stone;\\n        }\\n        //so we have to minimise sum-2*s1\\n        //range of s1 is from 0 to sum\\n        //so let us find all valid values of s1 such for the given stone array\\n        //this can be found using subset sum algorithm and then we can take the bottom row of the dp table to fish out the true value\\'s from it\\n        //then we can use the true values upto sum/2 since we leave the remaining valid sums for s2\\n        boolean[] s1 = subsetSum(stones, stones.length, sum);\\n        List<Integer> validS1 = new ArrayList<Integer>();\\n        for(int i = 0; i <= sum/2; i++) {\\n            if(s1[i] == true)\\n                validS1.add(i);\\n        }\\n        //now let\\'s calculate min sum-2*s1 from this\\n        int min = Integer.MAX_VALUE;\\n        for(int sum1 : validS1) {\\n            min = Math.min(min, sum - (2*sum1));\\n        }\\n        return min;\\n    }\\n    private boolean[] subsetSum(int[] stones, int n, int target) {\\n        boolean[][] dp = new boolean[n+1][target+1];\\n        for(int i = 0; i < dp.length; i++) {\\n            for(int j = 0; j < dp[i].length; j++) {\\n                if(i == 0)\\n                    dp[i][j] = false;\\n                if(j == 0)\\n                    dp[i][j] = true;\\n            }\\n        }\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 1; j < dp[i].length; j++) {\\n                if(stones[i-1] <= j) {\\n                    dp[i][j] = dp[i-1][j-stones[i-1]] || dp[i-1][j];\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n\\n        //  Input: a, b\\n        // Smash them, answer: (a) - (b)\\n\\n        // Input: a, b, c\\n        // Smash them, answer: (a) - (b - c)\\n\\n        // Input: a, b, c, d\\n        // Smash them, answer: (a - b) - (c - d) => (a + d) - (b + c)\\n\\n        // The same property holds true if the elements are re-ordered to \\n        //          [c, a, d, b]. \\n        // Answer: (c - a) - (d - b) => (c + b) - (a + d) : this final subtraction is the last stone left\\n\\n        //we need to divide the array into two subarrays such that their diffrence is minimum\\n        //s2-s1 is minimum\\n        //s1+s2 = sum;\\n        int sum = 0;\\n        for(int stone : stones) {\\n            sum += stone;\\n        }\\n        //so we have to minimise sum-2*s1\\n        //range of s1 is from 0 to sum\\n        //so let us find all valid values of s1 such for the given stone array\\n        //this can be found using subset sum algorithm and then we can take the bottom row of the dp table to fish out the true value\\'s from it\\n        //then we can use the true values upto sum/2 since we leave the remaining valid sums for s2\\n        boolean[] s1 = subsetSum(stones, stones.length, sum);\\n        List<Integer> validS1 = new ArrayList<Integer>();\\n        for(int i = 0; i <= sum/2; i++) {\\n            if(s1[i] == true)\\n                validS1.add(i);\\n        }\\n        //now let\\'s calculate min sum-2*s1 from this\\n        int min = Integer.MAX_VALUE;\\n        for(int sum1 : validS1) {\\n            min = Math.min(min, sum - (2*sum1));\\n        }\\n        return min;\\n    }\\n    private boolean[] subsetSum(int[] stones, int n, int target) {\\n        boolean[][] dp = new boolean[n+1][target+1];\\n        for(int i = 0; i < dp.length; i++) {\\n            for(int j = 0; j < dp[i].length; j++) {\\n                if(i == 0)\\n                    dp[i][j] = false;\\n                if(j == 0)\\n                    dp[i][j] = true;\\n            }\\n        }\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 1; j < dp[i].length; j++) {\\n                if(stones[i-1] <= j) {\\n                    dp[i][j] = dp[i-1][j-stones[i-1]] || dp[i-1][j];\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241376,
                "title": "minimum-subset-problem-dp-o-n-2-aditya-verma-approch",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size(),m=0;\\n        \\n        for(int i=0;i<n;i++){\\n            m+=stones[i];\\n        }\\n        \\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        \\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=true;//as u can always have a {} subset\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(j>=stones[i-1]){//include or exclude either ways we want subset sum\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                else{//exclude\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        // s1+s2=r and s1-s2=-diff then 2s1=r-diff so differetiate u get s1=r/2  r=m in this case\\n        int s1=m/2;\\n        for(int j=s1;j>=0;j--){\\n            if (dp[n][j]){//ie j is max available s1\\n                s1=j;\\n                break;\\n            } \\n        }\\n        \\n        int s2=m-s1;\\n        \\n        return s2-s1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size(),m=0;\\n        \\n        for(int i=0;i<n;i++){\\n            m+=stones[i];\\n        }\\n        \\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        \\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=true;//as u can always have a {} subset\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(j>=stones[i-1]){//include or exclude either ways we want subset sum\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                else{//exclude\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        // s1+s2=r and s1-s2=-diff then 2s1=r-diff so differetiate u get s1=r/2  r=m in this case\\n        int s1=m/2;\\n        for(int j=s1;j>=0;j--){\\n            if (dp[n][j]){//ie j is max available s1\\n                s1=j;\\n                break;\\n            } \\n        }\\n        \\n        int s2=m-s1;\\n        \\n        return s2-s1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111561,
                "title": "my-solution-with-explanation-java-01-knapsack",
                "content": "## Explanation\\nFirst let\\'s recall what is the 01 Knapsack problem? Basically we are given two arrays weight array and value array. We are then given a MAX_CAPACITY. Our task is to find the max sum of subset of value such that the sum of weights of this subset is smaller than or equal to MAX_CAPACITY.\\n\\nNow, let\\'s come back to our [question](https://leetcode.com/problems/last-stone-weight-ii/).\\nLet\\'s say we have 4 stones, [a, b, c, d] \\n1. Smashed a and b  -->  [ a-b, c, d]\\n2. Smashed c and a-b --> [c-a+b, d]\\n3. Smashed the remaining two stones --> [c-a+b-d]\\nSo if you observe the final stone is the sum such that some of the stones have + sign and some of them have - sign. Lets say the sum1 of the stones with + sign is S1, and with - sign is S2.\\n\\nNow, \\nS1 + S2 = Total_Sum_of_Array ( say S ) ...... (1)\\nAlso our answer is S1 - S2 = diff ................... (2)\\n\\nS1 - S2 = diff ( from (2) )\\nS1 - S2 + 2xS2 - 2xS2  = diff ( adding and subtracting 2xS2)\\nS1 + S2  - 2xS2 = diff\\nS - 2xS2 = diff ( from (1) )\\nNow, our task is to minimize this diff, which is equivalent to maximizing S2 ?\\nWhat can the min value of diff be? 0 right? So what can the max value of S2 be ? S/2 !  \\n \\nWell well, isnt that the classic 01 knapsack problem? :D\\n\\n## Code\\nclass Solution {\\n    \\n\\tpublic int lastStoneWeightII(int[] stones) {\\n        \\n        int sum = 0;\\n        for(int val:stones) sum += val;\\n        \\n        return sum - 2*knapSack(sum/2, stones, stones, stones.length);\\n        \\n    }\\n    \\n    static int knapSack(int cap, int wt[], int val[], int n){ \\n         // your code here \\n         \\n        if(n == 0) return 0;\\n         \\n\\t\\tint max = 0;\\n\\t\\tint[][] dp = new int[n][cap + 1];\\n\\n\\t\\tfor (int j = wt[0]; j <= cap; j++) {\\n\\t\\t\\tdp[0][j] = val[0];\\n\\t\\t\\tmax = Math.max(dp[0][j], max);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j <= cap; j++) {\\n\\t\\t\\t\\tif (j >= wt[i])\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - wt[i]] + val[i];\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\\n\\t\\t\\t\\tmax = Math.max(dp[i][j], max);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn max;\\n        \\n    } \\n}\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int lastStoneWeightII(int[] stones) {\\n        \\n        int sum = 0;\\n        for(int val:stones) sum += val;\\n        \\n        return sum - 2*knapSack(sum/2, stones, stones, stones.length);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1013873,
                "title": "python3-top-down-dp",
                "content": "**Algo**\\nDefine `fn(i, v)` for minimum weight of `stones[i:]` given existing weight. Then, \\n\\n`fn(i, v) = min(fn(i+1, v - stones[i]), fn(i+1, v + stones[i]))`.\\n\\n**Implementation**\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i, v): \\n            \"\"\"Return minimum weight of stones[i:] given existing weight.\"\"\"\\n            if i == len(stones): return abs(v)\\n            return min(fn(i+1, v - stones[i]), fn(i+1, v + stones[i]))\\n        \\n        return fn(0, 0)\\n```\\n\\n**Analysis**\\nTime complexity `O(NS)`\\nSpace complexity `O(NS)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i, v): \\n            \"\"\"Return minimum weight of stones[i:] given existing weight.\"\"\"\\n            if i == len(stones): return abs(v)\\n            return min(fn(i+1, v - stones[i]), fn(i+1, v + stones[i]))\\n        \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971999,
                "title": "easy-to-understand-code-java",
                "content": "I think [here](https://leetcode.com/problems/last-stone-weight-ii/discuss/296350/Explaining-why-this-problem-is-equals-to-finding-the-difference-between-the-sum-of-two-groups) it\\'s properly explained why this problem is same as finding minimum difference between the sum of two groups. \\n```\\nclass Solution {\\n    int totalSum;\\n    public int lastStoneWeightII(int[] stones) {\\n        totalSum = 0;\\n        for(int x : stones)\\n            totalSum += x;\\n        return helper(stones, 0, 0, new Integer[stones.length+1][stones.length*100+1]);\\n    }\\n\\t// currWeight : current sum of first subset\\n    public int helper(int[] stones, int index, int currWeight, Integer[][] dp) {\\n        if(dp[index][currWeight] != null)\\n            return dp[index][currWeight];\\n        int ans = 0;\\n        if(index == stones.length)\\n            ans = Math.abs(2 * currWeight - totalSum);   // difference of sums of 2 sets = Math.abs(first_sum - second_sum) = Math.abs(first_sum - (totalSum - first_sum)) = Math.abs(2 * first_sum - totalSum)\\n        else \\n            ans = Math.min(\\n                            helper(stones, index+1, currWeight, dp),\\n                            helper(stones, index+1, currWeight+stones[index], dp)\\n                            );\\n        return dp[index][currWeight] = ans;\\n    }\\n}\\n```\\nTime Complexity : O(N * N * 100)\\nSpace Complexity : O(N * N * 100)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int totalSum;\\n    public int lastStoneWeightII(int[] stones) {\\n        totalSum = 0;\\n        for(int x : stones)\\n            totalSum += x;\\n        return helper(stones, 0, 0, new Integer[stones.length+1][stones.length*100+1]);\\n    }\\n\\t// currWeight : current sum of first subset\\n    public int helper(int[] stones, int index, int currWeight, Integer[][] dp) {\\n        if(dp[index][currWeight] != null)\\n            return dp[index][currWeight];\\n        int ans = 0;\\n        if(index == stones.length)\\n            ans = Math.abs(2 * currWeight - totalSum);   // difference of sums of 2 sets = Math.abs(first_sum - second_sum) = Math.abs(first_sum - (totalSum - first_sum)) = Math.abs(2 * first_sum - totalSum)\\n        else \\n            ans = Math.min(\\n                            helper(stones, index+1, currWeight, dp),\\n                            helper(stones, index+1, currWeight+stones[index], dp)\\n                            );\\n        return dp[index][currWeight] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651894,
                "title": "memoization-based-java-solution",
                "content": "The crux of the problem revolves around finding the minimum difference between 2 subsets of the given array. Used a simple recursive helper, and the intermediately calculated sum as key for memoization.\\nHope it helps\\n\\n```\\n    public int lastStoneWeightII(int[] stones)\\n    {\\n        if(stones==null || stones.length==0)\\n            return 0;\\n        int sum=0;\\n        for(int s:stones)\\n            sum+=s;\\n\\n        return helper(stones,sum,0,0,new HashMap<Integer,Integer>());\\n    }\\n    public int helper(int[] stones, int sum, int idx, int s, Map<Integer,Integer> map)\\n    {\\n        if(idx==stones.length)\\n            return Math.abs((sum-s)-s);\\n        if(map.containsKey(s))\\n            return map.get(s);\\n        int c1=helper(stones,sum,idx+1,s+stones[idx],map);\\n        int c2=helper(stones,sum,idx+1,s,map);\\n        map.put(s,Math.min(c1,c2));\\n        return Math.min(c1,c2);\\n    }\\n\\t",
                "solutionTags": [],
                "code": "The crux of the problem revolves around finding the minimum difference between 2 subsets of the given array. Used a simple recursive helper, and the intermediately calculated sum as key for memoization.\\nHope it helps\\n\\n```\\n    public int lastStoneWeightII(int[] stones)\\n    {\\n        if(stones==null || stones.length==0)\\n            return 0;\\n        int sum=0;\\n        for(int s:stones)\\n            sum+=s;\\n\\n        return helper(stones,sum,0,0,new HashMap<Integer,Integer>());\\n    }\\n    public int helper(int[] stones, int sum, int idx, int s, Map<Integer,Integer> map)\\n    {\\n        if(idx==stones.length)\\n            return Math.abs((sum-s)-s);\\n        if(map.containsKey(s))\\n            return map.get(s);\\n        int c1=helper(stones,sum,idx+1,s+stones[idx],map);\\n        int c2=helper(stones,sum,idx+1,s,map);\\n        map.put(s,Math.min(c1,c2));\\n        return Math.min(c1,c2);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 632247,
                "title": "simple-and-clear-explanation-of-c-solution-based-on-knapsack-problem",
                "content": "\\n# A CPP Implementation of above discussed solution here\\nhttps://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here/277732\\n\\nHi! I\\'ve noticed that many solutions and not easy to understand for people like me who do not have much practice in DP, So I\\'m providing an easy to understand solution based on knapsack problem.\\nKeep Practising! Cheers!\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int w = sum/2, n = stones.size();\\n        vector<vector<int>> dp(n+1, vector<int>(w+1));\\n\\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 1; j< w+1; j++){\\n                int withOutCurr = dp[i-1][j], withCurr = 0;\\n                if(j>=stones[i-1]){\\n                    withCurr = stones[i-1] + dp[i-1][j-stones[i-1]];\\n                }\\n                dp[i][j] = max(withOutCurr, withCurr);\\n            }\\n        }\\n        int sumA = dp[n][w], sumB = sum - sumA;\\n        return sumB - sumA;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int w = sum/2, n = stones.size();\\n        vector<vector<int>> dp(n+1, vector<int>(w+1));\\n\\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 1; j< w+1; j++){\\n                int withOutCurr = dp[i-1][j], withCurr = 0;\\n                if(j>=stones[i-1]){\\n                    withCurr = stones[i-1] + dp[i-1][j-stones[i-1]];\\n                }\\n                dp[i][j] = max(withOutCurr, withCurr);\\n            }\\n        }\\n        int sumA = dp[n][w], sumB = sum - sumA;\\n        return sumB - sumA;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597041,
                "title": "java-recursion-with-dp",
                "content": "The idea is to put numbers into 2 diffrrent sets and minimize the diff between the sets, and the order in which the numbers are added in the set has no consequence on the final output, it only matters which number is added to which set \\nMeanwhile the number to be added cares only about the diff between the sum of two sets and tries to minimise this diff.\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int i =0;i<stones.length;i++){\\n            sum+=stones[i];\\n        }\\n        int sum1=0;\\n        int sum2=0;\\n        Integer [][] dp =  new Integer[stones.length][sum+1];\\n        int result = aux(dp,0,0,0,stones);\\n        return result;\\n    }\\n    \\n    public int aux(Integer [][] dp,int sum1, int sum2,int i,int [] stones){\\n        if(i<stones.length){\\n            if(dp[i][Math.abs(sum1-sum2)]==null){\\n                dp[i][Math.abs(sum1-sum2)]= Math.min(aux(dp,sum1+stones[i],sum2,i+1,stones),aux(dp,sum1,sum2+stones[i],i+1,stones));\\n            }return dp[i][Math.abs(sum1-sum2)];\\n        }\\n        return Math.abs(sum1-sum2);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int i =0;i<stones.length;i++){\\n            sum+=stones[i];\\n        }\\n        int sum1=0;\\n        int sum2=0;\\n        Integer [][] dp =  new Integer[stones.length][sum+1];\\n        int result = aux(dp,0,0,0,stones);\\n        return result;\\n    }\\n    \\n    public int aux(Integer [][] dp,int sum1, int sum2,int i,int [] stones){\\n        if(i<stones.length){\\n            if(dp[i][Math.abs(sum1-sum2)]==null){\\n                dp[i][Math.abs(sum1-sum2)]= Math.min(aux(dp,sum1+stones[i],sum2,i+1,stones),aux(dp,sum1,sum2+stones[i],i+1,stones));\\n            }return dp[i][Math.abs(sum1-sum2)];\\n        }\\n        return Math.abs(sum1-sum2);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561834,
                "title": "c-extremely-easy-solution-memoisation",
                "content": "First of all boiling down the prob to  -> Dividing into 2 groups such that their difference is minimum and that min. difference is the ans\\n\\nNow How ??????\\nEx: a,b,c,d are the stones, then lets say, the sequence be (c & d) then b - ( c - d ) then with a : a - ( b - ( c - d ) ) which is equal to ( a+c ) - ( b+d )\\nNow for this case  the 2 groups will be {a,c } & {b,d} and we have our ans = ( a+c ) - ( b+d );\\n\\nTo solve this we will imagine a bag of size ( SUM / 2 )  (here SUM is sum of all stones )\\nand now we want to fill the bag to the fullest :\\n\\nFor this in our reccursive function we will make 2 decisions:\\na) including the current stone in the sum \\nb) not including it in the current sum\\nAnd out out of these 2 we will return the max out of these two.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int comp(int index,int this_sum,int req,vector<int>&stones,vector<vector<int>>&dp){\\n        if(this_sum>req)\\n            return -1;\\n        if(this_sum==req)\\n            return req;\\n        if(index<0)\\n            return this_sum;\\n        int rem = req-this_sum;\\n        if(dp[index][rem]!=INT_MIN)\\n            return dp[index][rem];\\n        \\n        int ans1 = comp(index-1,this_sum+stones[index],req,stones,dp);\\n        int ans2 = comp(index-1,this_sum,req,stones,dp);\\n        \\n        dp[index][rem]=max(ans1,ans2);\\n        \\n        return dp[index][rem];\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(auto e:stones){\\n            sum+=e;\\n        }\\n        int req = sum/2;\\n        vector<vector<int>>dp(stones.size()+1,vector<int>(req+1,INT_MIN));\\n        int max_sum  = comp(stones.size()-1,0,req,stones,dp);\\n        return abs(sum-max_sum-max_sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int comp(int index,int this_sum,int req,vector<int>&stones,vector<vector<int>>&dp){\\n        if(this_sum>req)\\n            return -1;\\n        if(this_sum==req)\\n            return req;\\n        if(index<0)\\n            return this_sum;\\n        int rem = req-this_sum;\\n        if(dp[index][rem]!=INT_MIN)\\n            return dp[index][rem];\\n        \\n        int ans1 = comp(index-1,this_sum+stones[index],req,stones,dp);\\n        int ans2 = comp(index-1,this_sum,req,stones,dp);\\n        \\n        dp[index][rem]=max(ans1,ans2);\\n        \\n        return dp[index][rem];\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(auto e:stones){\\n            sum+=e;\\n        }\\n        int req = sum/2;\\n        vector<vector<int>>dp(stones.size()+1,vector<int>(req+1,INT_MIN));\\n        int max_sum  = comp(stones.size()-1,0,req,stones,dp);\\n        return abs(sum-max_sum-max_sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497742,
                "title": "java-solution-using-1d-dp-array-run-time-1ms",
                "content": "```\\n/**\\nThis Problem is similar https://leetcode.com/problems/partition-equal-subset-sum/\\n\\nHere instead of equal subset, have to find nearly equal subsets.\\nDifference between those nearly equal subset is the final answer\\n*/\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n       \\n       int total = 0;\\n       for(int x: stones)\\n           total += x;\\n        \\n        int half = total/2;\\n        boolean[] dp = new boolean[half+1];\\n        dp[0] = true;\\n        \\n        for(int stone : stones){\\n            for(int sum=half; sum>=0;sum--){\\n                if(sum >= stone){\\n                    dp[sum] = dp[sum] || dp[sum-stone];\\n                }\\n            }\\n        }\\n        //Get the maximum possible partitionValue\\n        int partitionValue=0;\\n        for(int i=half;i>=0;i--){\\n            if(dp[i]){\\n               partitionValue = i;\\n               break;\\n            }\\n        }\\n        int secondHalf = total-partitionValue;\\n        return (secondHalf-partitionValue);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nThis Problem is similar https://leetcode.com/problems/partition-equal-subset-sum/\\n\\nHere instead of equal subset, have to find nearly equal subsets.\\nDifference between those nearly equal subset is the final answer\\n*/\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n       \\n       int total = 0;\\n       for(int x: stones)\\n           total += x;\\n        \\n        int half = total/2;\\n        boolean[] dp = new boolean[half+1];\\n        dp[0] = true;\\n        \\n        for(int stone : stones){\\n            for(int sum=half; sum>=0;sum--){\\n                if(sum >= stone){\\n                    dp[sum] = dp[sum] || dp[sum-stone];\\n                }\\n            }\\n        }\\n        //Get the maximum possible partitionValue\\n        int partitionValue=0;\\n        for(int i=half;i>=0;i--){\\n            if(dp[i]){\\n               partitionValue = i;\\n               break;\\n            }\\n        }\\n        int secondHalf = total-partitionValue;\\n        return (secondHalf-partitionValue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480969,
                "title": "java-dp-solution-with-explanation",
                "content": "To find how to split, we will convert this into two arrays, such that the sum of second array is close to sum(stones) / 2, i.e we will mold this question into a 0-1Knapsack problem, where total weight we could put in knapsack would be sum(stones_weights\\')/2.\\n\\nHere 2d matrix dp[i][j] will denote the total weight we could get with i stones, and target weight j.\\nFor every stone, we could either put it in knapsack (stones[i-1] + dp[i - 1][j - stones[i-1]]) or we wont put it (dp[i - 1][j]).\\n\\nHope this helps!\\n\\n```\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n        if (stones.length == 2) return Math.abs(stones[0] - stones[1]);\\n        int sum = 0;\\n        for (int n : stones) {\\n            sum += n;\\n        }\\n\\n        int target = sum / 2;\\n\\n        int[][] dp = new int[stones.length+1][target+1];\\n\\n        for (int i = 1; i <= stones.length; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                if (j < stones[i-1]) {\\n                    dp[i][j] = dp[i - 1][j];\\n                } else {\\n                    dp[i][j] = Math.max(stones[i-1] + dp[i - 1][j - stones[i-1]], dp[i - 1][j]);\\n                }\\n            }\\n        }\\n        return Math.abs(sum - 2*dp[stones.length][target]);\\n    }",
                "solutionTags": [],
                "code": "To find how to split, we will convert this into two arrays, such that the sum of second array is close to sum(stones) / 2, i.e we will mold this question into a 0-1Knapsack problem, where total weight we could put in knapsack would be sum(stones_weights\\')/2.\\n\\nHere 2d matrix dp[i][j] will denote the total weight we could get with i stones, and target weight j.\\nFor every stone, we could either put it in knapsack (stones[i-1] + dp[i - 1][j - stones[i-1]]) or we wont put it (dp[i - 1][j]).\\n\\nHope this helps!\\n\\n```\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n        if (stones.length == 2) return Math.abs(stones[0] - stones[1]);\\n        int sum = 0;\\n        for (int n : stones) {\\n            sum += n;\\n        }\\n\\n        int target = sum / 2;\\n\\n        int[][] dp = new int[stones.length+1][target+1];\\n\\n        for (int i = 1; i <= stones.length; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                if (j < stones[i-1]) {\\n                    dp[i][j] = dp[i - 1][j];\\n                } else {\\n                    dp[i][j] = Math.max(stones[i-1] + dp[i - 1][j - stones[i-1]], dp[i - 1][j]);\\n                }\\n            }\\n        }\\n        return Math.abs(sum - 2*dp[stones.length][target]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 385784,
                "title": "the-minimum-diffenence-can-always-be-realized-through-cancelation",
                "content": "We know this problem can be solved by grouping the stones into two groups and find the minimum difference of the two groups, which can be solved by 0/1 Knapsacks DP (See https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP by lee215).\\nEvery cancellation can be transfered to the difference between two groups but the reverse is not true: not every grouping can be realized by cancellation. So how do we prove that the minimum sum difference can be realized by cancellation? I didn\\'t find any clear explanation on this. Following is my though on this.\\nSuppose the bigger group is S2 and the smaller group is S1. S is the total sum. We have\\n```\\nS = S1 + S2\\nmin(S2 - S1) -> min(S - 2 * S1) -> max(S1) while S1 <= S / 2 and S1 <= S2\\n```\\nOur goal is to maximize the smaller group and the boundary is S/2.\\nNow suppose we\\'ve found the solution.\\n`S1 = a + b + c ... + e, S2 = x + y + z` and S1 is the maximum value we can have to satisfy the conditions. Then the question becomes whether this can be realized by cancellation. \\nBefore we do that we need to think in what condition this cannot be realized by cancellation. Every element in group S1 will have a minus sign before them in the final answer, meaning each time they are smashed with another stone in group S2. If it cannot be realized by a cancellation, it means there are more than 1 stones left after all the stones in S1 have been smashed. Suppose the last stone to be smashed in S1 is c. The stones left in S2 is a, b. (a is the masimu weight stone in S2 and b is created after smashing other stones in S2 with those from S2).\\n```\\na + b >= c\\na >= b ( we should always try to pick a lighter stone in S2 to smash with stones in S1)\\n```\\nIf b > c, then there will be two stones with positive signs left so it cannot be realized by cancellation. Otherwise it can always be smashed in the way `a - (c - b)`. But if b > c then we have\\n```\\na + c >= b\\nb > c. \\n```\\nIn other words, we can move b to the right side (group S1) to make it bigger, which is conflict with our premise that S1 is the biggest one we can have. Thus b <= c and the last step can always be a smash between two stones. \\nIt\\'s kind of tricky and I am not sure if I explain it clearly or not. But hopefully it can help you to understand the question.\\nHappy coding!",
                "solutionTags": [],
                "code": "```\\nS = S1 + S2\\nmin(S2 - S1) -> min(S - 2 * S1) -> max(S1) while S1 <= S / 2 and S1 <= S2\\n```\n```\\na + b >= c\\na >= b ( we should always try to pick a lighter stone in S2 to smash with stones in S1)\\n```\n```\\na + c >= b\\nb > c. \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347885,
                "title": "python-time-o-sum-stones-n-space-o-2-sum-stones",
                "content": "```python\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = set()\\n        res.add(stones[0])\\n        for n in stones[1:]:\\n            newres = set()\\n            for m in res:\\n                newres.add(n+m)\\n                newres.add(abs(n-m))\\n            res = newres\\n        return min(res)\\n```\\nIn the set, it represents all possibilities of sums of stones of final states and intermediate states. \\nSince the final state is always smaller than its intermediate states, the minimum final states is smaller than or equal to all final states and intermediate states.",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = set()\\n        res.add(stones[0])\\n        for n in stones[1:]:\\n            newres = set()\\n            for m in res:\\n                newres.add(n+m)\\n                newres.add(abs(n-m))\\n            res = newres\\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295759,
                "title": "java-dp-solution-with-explanation",
                "content": "```\\npublic int lastStoneWeightII(int[] stones) {\\n\\n\\tif (stones == null || stones.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t// This problem resembles 494. Target Sum\\n\\n\\t// Use the idea that we need to split array into two sets: Pos and Neg\\n\\t// and minimize the difference: Pos - Neg = diff\\n\\t// Also, we know Pos + Neg = Sum, where Sum is the sum of all elements.\\n\\t// So, we can derive diff = Sum - 2Neg. It means we need to maximize Neg.\\n\\t// Another option is diff = 2Pos - Sum and minimize Pos.\\n\\t// Note, Neg is not greater than Sum/2, let\\'s use it.\\n\\n\\t// Use dp[Sum/2 + 1] of boolean values.\\n\\t// dp[i] will hold true if this Neg value is achievable.\\n\\n\\t// calculate Sum\\n\\t// Can be combined with the next cycle\\n\\tint sum = 0;\\n\\tfor (int stone : stones) {\\n\\t\\tsum += stone;\\n\\t}\\n\\n\\tboolean[] dp = new boolean[sum/2 + 1];\\n\\tdp[0] = true; // The first achievable dp spot, but not a solution in this problem\\n\\tint minDiff = Integer.MAX_VALUE;\\n\\tfor(int stone : stones) {\\n\\t\\tfor (int j=sum/2; j>=stone; j--) {\\n\\t\\t\\tdp[j] |= dp[j-stone];\\n\\t\\t\\tif (dp[j]) {\\n\\t\\t\\t\\tminDiff = Math.min(minDiff, sum - 2*j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn minDiff;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lastStoneWeightII(int[] stones) {\\n\\n\\tif (stones == null || stones.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t// This problem resembles 494. Target Sum\\n\\n\\t// Use the idea that we need to split array into two sets: Pos and Neg\\n\\t// and minimize the difference: Pos - Neg = diff\\n\\t// Also, we know Pos + Neg = Sum, where Sum is the sum of all elements.\\n\\t// So, we can derive diff = Sum - 2Neg. It means we need to maximize Neg.\\n\\t// Another option is diff = 2Pos - Sum and minimize Pos.\\n\\t// Note, Neg is not greater than Sum/2, let\\'s use it.\\n\\n\\t// Use dp[Sum/2 + 1] of boolean values.\\n\\t// dp[i] will hold true if this Neg value is achievable.\\n\\n\\t// calculate Sum\\n\\t// Can be combined with the next cycle\\n\\tint sum = 0;\\n\\tfor (int stone : stones) {\\n\\t\\tsum += stone;\\n\\t}\\n\\n\\tboolean[] dp = new boolean[sum/2 + 1];\\n\\tdp[0] = true; // The first achievable dp spot, but not a solution in this problem\\n\\tint minDiff = Integer.MAX_VALUE;\\n\\tfor(int stone : stones) {\\n\\t\\tfor (int j=sum/2; j>=stone; j--) {\\n\\t\\t\\tdp[j] |= dp[j-stone];\\n\\t\\t\\tif (dp[j]) {\\n\\t\\t\\t\\tminDiff = Math.min(minDiff, sum - 2*j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn minDiff;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294984,
                "title": "python-randomness-is-your-friend",
                "content": "The maximum length of input is 30 and the maximum of each element is 100.\\n\\nSo it\\'s reasonable to solve by randomness.\\n\\nIt doesn\\'t guarentee the method will pass everytime.\\nBut I think 500 rounds is enough to get accepted with very little risk.\\n```\\n\\tdef lastStoneWeightII(self, stones):\\n        \\n        mini = 9999\\n        \\n        # try 500 rounds\\n        for r in range(500):\\n            s = list(stones)\\n            while len(s)>1:\\n                # pick index\\n                [x,y] = random.sample(range(len(s)), 2)\\n\\n                x = s[x]\\n                y = s[y]\\n\\n                s.remove(x)\\n                s.remove(y)\\n                if x!=y:\\n                    s.append(abs(x-y))\\n            \\n            if s:\\n                mini = min(mini,s[0])\\n            else:\\n                return 0\\n            \\n        return mini",
                "solutionTags": [],
                "code": "The maximum length of input is 30 and the maximum of each element is 100.\\n\\nSo it\\'s reasonable to solve by randomness.\\n\\nIt doesn\\'t guarentee the method will pass everytime.\\nBut I think 500 rounds is enough to get accepted with very little risk.\\n```\\n\\tdef lastStoneWeightII(self, stones):\\n        \\n        mini = 9999\\n        \\n        # try 500 rounds\\n        for r in range(500):\\n            s = list(stones)\\n            while len(s)>1:\\n                # pick index\\n                [x,y] = random.sample(range(len(s)), 2)\\n\\n                x = s[x]\\n                y = s[y]\\n\\n                s.remove(x)\\n                s.remove(y)\\n                if x!=y:\\n                    s.append(abs(x-y))\\n            \\n            if s:\\n                mini = min(mini,s[0])\\n            else:\\n                return 0\\n            \\n        return mini",
                "codeTag": "Python3"
            },
            {
                "id": 294882,
                "title": "simple-brute-force-approach",
                "content": "This question is equivalent to [Partition a set into two subsets such that the difference of subset sums is minimum.\\n](https://www.geeksforgeeks.org/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/) \\n\\nFor example, we take array [2,3,3,2,5]. We parition it into two sets  [2,3,2] and [3,5], with sum 7 and 8 respectively. If we have collision with numbers from set 1 with those of set 2, only 7~8=1 will remain.\\n\\nWe have only 30 stones with maximum weight of 100 each. So, total weight will be between 1 to 3000. Since only 3000 possible weights for set 1, so We can apply brute force approach to calculate list of all possible weights of set 1. \\n\\nWeight for set 2 is  (total weight- weight of set 1). \\n\\nThen minimum difference between set 1 and set 2 can be found iteratively.\\n\\n```\\n\\tint lastStoneWeightII(vector<int>& stones) {\\n        \\n        /* total weight of stones */\\n        int total=std::accumulate(stones.begin(),stones.end(),0);\\n        \\n        /* all possible weight of set 1 */\\n        std::unordered_set<int> weights;\\n        \\n        /* brute force approach to calculate all possible weight */\\n        for(int n:stones){\\n            std::unordered_set<int> temp=weights;\\n            temp.insert(n);\\n            \\n\\t\\t\\t/* add new stone weight to previous set of weights */\\n            for(int weight:weights){\\n                temp.insert(weight+n);\\n            }\\n            \\n            weights=std::move(temp);\\n        }\\n        \\n        \\n        int res=INT_MAX;\\n        /* calculating minimum difference of set 1 and 2 */\\n        for(int weight:weights){\\n            res=std::min(res,std::abs(weight-(total-weight))); \\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint lastStoneWeightII(vector<int>& stones) {\\n        \\n        /* total weight of stones */\\n        int total=std::accumulate(stones.begin(),stones.end(),0);\\n        \\n        /* all possible weight of set 1 */\\n        std::unordered_set<int> weights;\\n        \\n        /* brute force approach to calculate all possible weight */\\n        for(int n:stones){\\n            std::unordered_set<int> temp=weights;\\n            temp.insert(n);\\n            \\n\\t\\t\\t/* add new stone weight to previous set of weights */\\n            for(int weight:weights){\\n                temp.insert(weight+n);\\n            }\\n            \\n            weights=std::move(temp);\\n        }\\n        \\n        \\n        int res=INT_MAX;\\n        /* calculating minimum difference of set 1 and 2 */\\n        for(int weight:weights){\\n            res=std::min(res,std::abs(weight-(total-weight))); \\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638604,
                "title": "beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length;\\n        int sum = 0;\\n        for (int stone : stones) {\\n            sum += stone;\\n        }\\n        \\n        boolean[] dp = new boolean[sum / 2 + 1];\\n        dp[0] = true;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int stone = stones[i];\\n            for (int j = sum / 2; j >= stone; j--) {\\n                if (dp[j - stone]) {\\n                    dp[j] = true;\\n                }\\n            }\\n        }\\n        \\n        int i = sum / 2;\\n        while (i >= 0 && !dp[i]) {\\n            i--;\\n        }\\n        \\n        return sum - 2 * i;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length;\\n        int sum = 0;\\n        for (int stone : stones) {\\n            sum += stone;\\n        }\\n        \\n        boolean[] dp = new boolean[sum / 2 + 1];\\n        dp[0] = true;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int stone = stones[i];\\n            for (int j = sum / 2; j >= stone; j--) {\\n                if (dp[j - stone]) {\\n                    dp[j] = true;\\n                }\\n            }\\n        }\\n        \\n        int i = sum / 2;\\n        while (i >= 0 && !dp[i]) {\\n            i--;\\n        }\\n        \\n        return sum - 2 * i;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555831,
                "title": "c-dp-knapsack-variation-subset-sum-variation",
                "content": "# Approach\\nFind the maximum subset sum close to **(sum of all elements)/2**. As there will be some stones which will add their value and some which will subtract their value hence in order to minimize the final stone weight we need to divide the stones array into two subsets, one with maximum positive sum less than or equal to **(sum of all)/2**. And finally we will subtract the subset sum from total sum which will give us the negative subset sum i.e. the stones whose values will be subtracted. We will finally subtract that value from the positive subset sum which will give us the final answer.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[3001][31];\\n    int solve(int idx,int w,vector<int>& stones)\\n    {\\n        if(idx<0 || w==0)\\n        return 0;\\n        if(dp[w][idx]!=-1)\\n        return dp[w][idx];\\n        int take = 0,notTake = 0;\\n        if(w-stones[idx]>=0)\\n        take = stones[idx]+solve(idx-1,w-stones[idx],stones);\\n        notTake = solve(idx-1,w,stones);\\n        return dp[w][idx] = max(take,notTake);\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(auto &i:stones)\\n        sum+=i;\\n        int n = stones.size();\\n        memset(dp,-1,sizeof(dp));\\n        int sum1 = solve(n-1,sum/2,stones);\\n        return (sum-2*sum1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[3001][31];\\n    int solve(int idx,int w,vector<int>& stones)\\n    {\\n        if(idx<0 || w==0)\\n        return 0;\\n        if(dp[w][idx]!=-1)\\n        return dp[w][idx];\\n        int take = 0,notTake = 0;\\n        if(w-stones[idx]>=0)\\n        take = stones[idx]+solve(idx-1,w-stones[idx],stones);\\n        notTake = solve(idx-1,w,stones);\\n        return dp[w][idx] = max(take,notTake);\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        for(auto &i:stones)\\n        sum+=i;\\n        int n = stones.size();\\n        memset(dp,-1,sizeof(dp));\\n        int sum1 = solve(n-1,sum/2,stones);\\n        return (sum-2*sum1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103982,
                "title": "c-recursion-memoization-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecusion + Memoization\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will check every possible combination.\\n- take one time in a positve side. \\n- another time in a negative side.\\n- given constraints are 1 <= stones.length <= 30 & 1 <= stones[i] <= 100\\n- max. and min. value can be 30*(100) & 30*(-100) -> 3000 to -3000\\n- that is why dp vector is (n+1)*(6000)\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*(3000))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*6000 + runtime stack)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nint solve(vector<int>& stones,int idx,int value,vector<vector<int>>& dp){\\n    //base case\\n    if(idx==stones.size()){\\n        if(value<0)return 1e9;\\n        return 0;\\n    }\\n    // value can be -3000 to +3000 that is why [value + 3000] \\n    if(dp[idx][value+3000]!=-1)return dp[idx][value+3000];\\n    //condition\\n    int ans1 = stones[idx] + solve(stones,idx+1,value+stones[idx],dp);\\n    int ans2 = -stones[idx] + solve(stones,idx+1,value-stones[idx],dp);\\n    return dp[idx][value+3000] = min(ans1,ans2);\\n}\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        vector<vector<int>> dp(stones.size()+1,vector<int>(6000,-1));\\n        return solve(stones,0,0,dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nint solve(vector<int>& stones,int idx,int value,vector<vector<int>>& dp){\\n    //base case\\n    if(idx==stones.size()){\\n        if(value<0)return 1e9;\\n        return 0;\\n    }\\n    // value can be -3000 to +3000 that is why [value + 3000] \\n    if(dp[idx][value+3000]!=-1)return dp[idx][value+3000];\\n    //condition\\n    int ans1 = stones[idx] + solve(stones,idx+1,value+stones[idx],dp);\\n    int ans2 = -stones[idx] + solve(stones,idx+1,value-stones[idx],dp);\\n    return dp[idx][value+3000] = min(ans1,ans2);\\n}\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        vector<vector<int>> dp(stones.size()+1,vector<int>(6000,-1));\\n        return solve(stones,0,0,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564431,
                "title": "c-recursion-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int minWeight(vector<int> &stones, int index, int weight_one, int weight_two, vector<vector<int>> &memo) {\\n        if(index >= stones.size()) \\n            return abs(weight_one - weight_two);\\n        \\n        if(memo[index][abs(weight_one - weight_two)] != -1)\\n            return memo[index][abs(weight_one - weight_two)];\\n        \\n        int option_one = minWeight(stones, index + 1, weight_one + stones.at(index), weight_two, memo);\\n        int option_two = minWeight(stones, index + 1, weight_one, weight_two + stones.at(index), memo);\\n        \\n        return memo[index][abs(weight_one - weight_two)] = min(option_one, option_two);\\n    }\\n    \\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        vector<vector<int>> memo(stones.size(), vector<int>(stones.size() * 100 + 1, -1));\\n        \\n        return minWeight(stones, 0, 0, 0, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int minWeight(vector<int> &stones, int index, int weight_one, int weight_two, vector<vector<int>> &memo) {\\n        if(index >= stones.size()) \\n            return abs(weight_one - weight_two);\\n        \\n        if(memo[index][abs(weight_one - weight_two)] != -1)\\n            return memo[index][abs(weight_one - weight_two)];\\n        \\n        int option_one = minWeight(stones, index + 1, weight_one + stones.at(index), weight_two, memo);\\n        int option_two = minWeight(stones, index + 1, weight_one, weight_two + stones.at(index), memo);\\n        \\n        return memo[index][abs(weight_one - weight_two)] = min(option_one, option_two);\\n    }\\n    \\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        vector<vector<int>> memo(stones.size(), vector<int>(stones.size() * 100 + 1, -1));\\n        \\n        return minWeight(stones, 0, 0, 0, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221189,
                "title": "c-solution-with-explanation",
                "content": "Transfer the question into a 0/1 knapsack problem:\\n\\nThe process that we are smashing 2 stones each time and put back repeatedly, is equivalent to find difference between total weights of two subsets of stones. The smallest left stone weight is transfered to \"find the smallest difference between the 2 subsets\\' weights\".\\n\\n\\nBy knowing the total wieght of given list of stone \"*W*\", the question can be further transfer to: find a subset of stones, such that the subset\\'s total weight is closest to the *W/2* (but no larger than it).\\n\\nThe result is simply \\n> *2 x difference between the W/2 and the closest weight you just found*.\\n\\n\\n\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int total_weight = 0;\\n        for(int stone: stones) {\\n            total_weight += stone;\\n        }\\n\\t\\tint target_weight = total_weight/2;\\n\\n        int memo[stones.size() + 1][target_weight + 1];\\n        memset(memo, 0, sizeof(memo));\\n        \\n        for(int i = 1; i <= stones.size(); i++) {\\n            for(int j = 1; j <= target_weight; j++) {\\n                int curr_weight = stones[i - 1];\\n                if(curr_weight > j) { \\n                    memo[i][j] = memo[i - 1][j];\\n                    continue;\\n                }       \\n                memo[i][j] = max(memo[i - 1][j], memo[i - 1][j - curr_weight] + curr_weight);\\n            }\\n        }\\n        return total_weight - memo[stones.size() ][target_weight]*2;\\n    }\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Transfer the question into a 0/1 knapsack problem:\\n\\nThe process that we are smashing 2 stones each time and put back repeatedly, is equivalent to find difference between total weights of two subsets of stones. The smallest left stone weight is transfered to \"find the smallest difference between the 2 subsets\\' weights\".\\n\\n\\nBy knowing the total wieght of given list of stone \"*W*\", the question can be further transfer to: find a subset of stones, such that the subset\\'s total weight is closest to the *W/2* (but no larger than it).\\n\\nThe result is simply \\n> *2 x difference between the W/2 and the closest weight you just found*.\\n\\n\\n\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int total_weight = 0;\\n        for(int stone: stones) {\\n            total_weight += stone;\\n        }\\n\\t\\tint target_weight = total_weight/2;\\n\\n        int memo[stones.size() + 1][target_weight + 1];\\n        memset(memo, 0, sizeof(memo));\\n        \\n        for(int i = 1; i <= stones.size(); i++) {\\n            for(int j = 1; j <= target_weight; j++) {\\n                int curr_weight = stones[i - 1];\\n                if(curr_weight > j) { \\n                    memo[i][j] = memo[i - 1][j];\\n                    continue;\\n                }       \\n                memo[i][j] = max(memo[i - 1][j], memo[i - 1][j - curr_weight] + curr_weight);\\n            }\\n        }\\n        return total_weight - memo[stones.size() ][target_weight]*2;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2116046,
                "title": "c-easy-to-undestand-simple-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int total;\\n    int solve(vector<int> &v,int i,int n,int sum,vector<vector<int> > &memo)\\n    {\\n        if(i==n)\\n        {\\n            return abs(total-2*sum);\\n        }\\n        if(memo[i][sum]!=-1)\\n        {\\n            return memo[i][sum];\\n        }\\n        int pick,nonpick;\\n        pick=solve(v,i+1,n,sum+v[i],memo);\\n        nonpick=solve(v,i+1,n,sum,memo);\\n        return memo[i][sum]=min(pick,nonpick);\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        total=accumulate(stones.begin(),stones.end(),0);\\n        vector<vector<int> > memo(n+1,vector<int>(3001,-1));\\n        return solve(stones,0,n,0,memo);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int total;\\n    int solve(vector<int> &v,int i,int n,int sum,vector<vector<int> > &memo)\\n    {\\n        if(i==n)\\n        {\\n            return abs(total-2*sum);\\n        }\\n        if(memo[i][sum]!=-1)\\n        {\\n            return memo[i][sum];\\n        }\\n        int pick,nonpick;\\n        pick=solve(v,i+1,n,sum+v[i],memo);\\n        nonpick=solve(v,i+1,n,sum,memo);\\n        return memo[i][sum]=min(pick,nonpick);\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        total=accumulate(stones.begin(),stones.end(),0);\\n        vector<vector<int> > memo(n+1,vector<int>(3001,-1));\\n        return solve(stones,0,n,0,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833304,
                "title": "c-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        int sum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        vector <vector <int>> dp (n + 1, vector <int> (sum + 1, 0));\\n        // dp[index][target] -> maximum value <= target upto index\\n        \\n        for(int i = 1 ; i < n + 1 ; i ++){\\n            for (int j = 1 ; j < sum + 1; j ++){\\n                 \\n                    int not_consider = dp[i-1][j];\\n                    int consider = 0;\\n                    if( stones[i - 1] <= j) \\n                        consider = stones[i-1] + dp[i-1][j - stones[i- 1]];\\n                    dp[i][j] = max(consider, not_consider);\\n                \\n            }\\n        }\\n\\n        int target = sum / 2;\\n        return sum - (2 *dp[n][target]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        int sum = accumulate(stones.begin(), stones.end(), 0);\\n        \\n        vector <vector <int>> dp (n + 1, vector <int> (sum + 1, 0));\\n        // dp[index][target] -> maximum value <= target upto index\\n        \\n        for(int i = 1 ; i < n + 1 ; i ++){\\n            for (int j = 1 ; j < sum + 1; j ++){\\n                 \\n                    int not_consider = dp[i-1][j];\\n                    int consider = 0;\\n                    if( stones[i - 1] <= j) \\n                        consider = stones[i-1] + dp[i-1][j - stones[i- 1]];\\n                    dp[i][j] = max(consider, not_consider);\\n                \\n            }\\n        }\\n\\n        int target = sum / 2;\\n        return sum - (2 *dp[n][target]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668115,
                "title": "c-detail-explanation-dp-approach",
                "content": "```\\n// Idea:\\n// We can approach this question from a greedy POV.\\n//\\n// Let\\'s say we have 2 stones, to have the minimum remaining weight\\n// the two stones should have as little weight difference as possible.\\n//\\n// How about 3 stones? We should seperate the stones into 2 set so that\\n// the difference between the sets are minimal.\\n//     e.g. [1,2,3] -> [1,2] [3], result = 0\\n//\\n// Now we start to see that our goal is to divide the stones into 2 sets,\\n// let\\'s say S1 and S2, where the total weights of S1 is smaller or equal\\n// to half of the total weight. For easier implementation, we choose S1.\\n//\\n// The problem then boils down to how we can find a subset of stones that\\n// has the cloest sum to totalWeight / 2. Note that in case where totalWeight\\n// is odd, stones can never cancel out and at least have a subset weight\\n// difference of 1, so we will still take totalWeight / 2 as our goal.\\n//\\n// Let\\'s say we have a set of [1,2,3]. Our goal is to pick a subset of rocks\\n// haveing weight = 6 / 2 = 3.\\n//\\n// First we build a DP, where each slot represents a possible subset weight\\n// up to half of total weight, init slot 0 as True since we don\\'t need rocks\\n// to reach weight = 0.\\n//\\n// Note that for subsets, we care about combination rather than permutation,\\n// so the order of rocks we pick is irrelavent to the result.\\n//\\n// dp 0 1 2 3\\n//    T F F F\\n//\\n// Let\\'s throw rock with weight = 1 into the subset. Based on our initial case\\n// we know that a subset of 0 rocks have weight of zero. Based on this, we can\\n// calculate subset with 1 rock, where rock weight = 1.\\n//\\n// dp 0 1 2 3\\n//    T T F F\\n//\\n// For the second rock, we pick rock with weight = 2. We know the base case of\\n// 0 rocks = 0 weight, and 1 rock = 1 weight. Based on the calculated result\\n// we know the subset weight of 1 rock where rock weight = 2 and 2 rocks where\\n// rock weight = 1 + 2. i.e.\\n//\\n// dp 0 1 2 3\\n//    T T T T\\n//\\n// Note that our subset weight can reach totalWeight / 2. Thus our result is 0.\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n\\n        int totalWeight = 0;\\n        int halfWeight;\\n        for (int &eachS : stones) {\\n            totalWeight += eachS;\\n        }\\n        \\n        halfWeight = (totalWeight >> 1);\\n        \\n        vector<bool> dp (halfWeight + 1, false); // O(W) space\\n        dp[0] = true; // base case\\n        \\n        // O(NW) time\\n        for (int i = 0; i < stones.size(); i++) {\\n            if (stones[i] > halfWeight) continue;\\n            for (int j = halfWeight; j >= stones[i]; j--) {\\n                if (dp[j - stones[i]]) dp[j] = true;\\n            }\\n        }\\n        \\n        int cloestWeight = halfWeight;\\n        while (!dp[cloestWeight]) {\\n            cloestWeight--;\\n        }\\n        \\n        return totalWeight - (cloestWeight << 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Idea:\\n// We can approach this question from a greedy POV.\\n//\\n// Let\\'s say we have 2 stones, to have the minimum remaining weight\\n// the two stones should have as little weight difference as possible.\\n//\\n// How about 3 stones? We should seperate the stones into 2 set so that\\n// the difference between the sets are minimal.\\n//     e.g. [1,2,3] -> [1,2] [3], result = 0\\n//\\n// Now we start to see that our goal is to divide the stones into 2 sets,\\n// let\\'s say S1 and S2, where the total weights of S1 is smaller or equal\\n// to half of the total weight. For easier implementation, we choose S1.\\n//\\n// The problem then boils down to how we can find a subset of stones that\\n// has the cloest sum to totalWeight / 2. Note that in case where totalWeight\\n// is odd, stones can never cancel out and at least have a subset weight\\n// difference of 1, so we will still take totalWeight / 2 as our goal.\\n//\\n// Let\\'s say we have a set of [1,2,3]. Our goal is to pick a subset of rocks\\n// haveing weight = 6 / 2 = 3.\\n//\\n// First we build a DP, where each slot represents a possible subset weight\\n// up to half of total weight, init slot 0 as True since we don\\'t need rocks\\n// to reach weight = 0.\\n//\\n// Note that for subsets, we care about combination rather than permutation,\\n// so the order of rocks we pick is irrelavent to the result.\\n//\\n// dp 0 1 2 3\\n//    T F F F\\n//\\n// Let\\'s throw rock with weight = 1 into the subset. Based on our initial case\\n// we know that a subset of 0 rocks have weight of zero. Based on this, we can\\n// calculate subset with 1 rock, where rock weight = 1.\\n//\\n// dp 0 1 2 3\\n//    T T F F\\n//\\n// For the second rock, we pick rock with weight = 2. We know the base case of\\n// 0 rocks = 0 weight, and 1 rock = 1 weight. Based on the calculated result\\n// we know the subset weight of 1 rock where rock weight = 2 and 2 rocks where\\n// rock weight = 1 + 2. i.e.\\n//\\n// dp 0 1 2 3\\n//    T T T T\\n//\\n// Note that our subset weight can reach totalWeight / 2. Thus our result is 0.\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n\\n        int totalWeight = 0;\\n        int halfWeight;\\n        for (int &eachS : stones) {\\n            totalWeight += eachS;\\n        }\\n        \\n        halfWeight = (totalWeight >> 1);\\n        \\n        vector<bool> dp (halfWeight + 1, false); // O(W) space\\n        dp[0] = true; // base case\\n        \\n        // O(NW) time\\n        for (int i = 0; i < stones.size(); i++) {\\n            if (stones[i] > halfWeight) continue;\\n            for (int j = halfWeight; j >= stones[i]; j--) {\\n                if (dp[j - stones[i]]) dp[j] = true;\\n            }\\n        }\\n        \\n        int cloestWeight = halfWeight;\\n        while (!dp[cloestWeight]) {\\n            cloestWeight--;\\n        }\\n        \\n        return totalWeight - (cloestWeight << 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636900,
                "title": "py3-last-stone-wt",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \\n        ans = float(\\'inf\\')\\n        @cache\\n        def dp(i,A):\\n            nonlocal ans\\n            \\n            if i == len(stones):\\n                if A >= 0: ans = min(ans, A)\\n                return\\n            \\n            dp(i+1, A+stones[i])\\n            dp(i+1, A-stones[i])\\n        \\n        dp(0,0)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        \\n        ans = float(\\'inf\\')\\n        @cache\\n        def dp(i,A):\\n            nonlocal ans\\n            \\n            if i == len(stones):\\n                if A >= 0: ans = min(ans, A)\\n                return\\n            \\n            dp(i+1, A+stones[i])\\n            dp(i+1, A-stones[i])\\n        \\n        dp(0,0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631347,
                "title": "java-3-sloutions-top-down-recursive-bottom-up-dp-meet-in-the-middle-commented",
                "content": "# Time complexity comparisions-\\n**Source**- https://www.baeldung.com/cs/subset-of-numbers-closest-to-target\\n\\n![image](https://assets.leetcode.com/users/images/fb971567-79a1-4507-972b-c0878a2ed67c_1639655221.249506.png)\\n\\n*The dynamic programming may sound like the best solution with the lowest complexity. However, keep in mind that the dynamic programming solution is related to k. On the other hand, the backtracking and the meet-in-the-middle approaches are not related to k.*\\n\\n*The backtracking and the meet-in-the-middle approaches are better used when the value of k is considerable. On the contrary, if the value of k is small, the dynamic programming approach is considered a better option.*\\n\\n**For more details on meet in the middle algo please have a look at this-**https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/discuss/1622681/java-detailed-explanation-with-intuition-meet-in-the-middle-similar-questions\\n\\n# Top Down with Memoization\\n\\n```\\n// Java Top down recursive soltuion\\n// similar to knapsack problem\\n// TC - o(n*sum/2)\\n// Space- o(n*sum/2)\\nclass Solution {\\n    Integer[][] dp;\\n    private int findLowerBoundTargetSum(int[] stones,int target, int start,int currSum){\\n        if(start==stones.length){\\n            return currSum;\\n        }\\n        if(dp[start][currSum]!=null){\\n            return dp[start][currSum];\\n        }\\n        \\n        if(stones[start]+currSum>target){\\n            return dp[start][currSum]=findLowerBoundTargetSum(stones,target,start+1,currSum);\\n        }else{\\n            return dp[start][currSum]=Math.max(findLowerBoundTargetSum(stones,target,start+1,currSum+stones[start]),\\n                                          findLowerBoundTargetSum(stones,target,start+1,currSum));\\n        }\\n        \\n    }\\n    public int lastStoneWeightII(int[] stones) {\\n        int n= stones.length;\\n        int sum=0;\\n        for(int i:stones){\\n            sum+=i;\\n        }\\n        // since we have to minimize the diff bw two subset sums\\n        // ideal subset sums=sum/2, we wll try to find a sum from the subsets which is\\n        // as close to sum/2 as possible=lower bound of sum/2\\n        \\n        // then S2-S1--> we need to minimize, S1+S2=sum, S2=sum-S1 -> minimize Sum-2S1\\n        int target=(sum>>1);\\n        dp=new Integer[n][(sum>>1)+1];\\n        int maxSum=findLowerBoundTargetSum(stones,target,0,0);\\n        return sum-2*maxSum;\\n    }\\n}\\n```\\n\\n# Bottom up DP\\n```\\n// TC - o(n*sum/2)\\n// Space- o(n*sum/2)\\n// same as subset sum diff- minimize TotalSum-2S1\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n=stones.length;\\n        int sum=0;\\n        for(int i:stones){\\n            sum+=i;\\n        }\\n        // we have enumerated all the vlaues till sum/2 and find what is the\\n        // sum value we have for all our array elements which is as close to sum/2\\n        // or is sum/2\\n        boolean[][] dp=new boolean[n+1][sum/2+1];\\n        \\n        // when sum is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=true;\\n        }\\n        \\n        // here the last row tells us that if that particular sum exist for all the\\n        // elements of out array.\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=sum/2;j++){\\n                if(j<stones[i-1]){\\n                    dp[i][j]=dp[i-1][j];\\n                }else{\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<=sum/2;i++){\\n            if(dp[n][i]){// sum exixts\\n                min=Math.min(min,sum-2*i);// take the max sum\\n            }\\n        }\\n        return min;\\n    }\\n    \\n}\\n```\\n\\n# Meet in the middle\\n```\\n// meet in the middle approach\\n// 2^20~10^6, 10^8=1 sec, so 40*2^20~10^7 so good to go for n<=50\\n// Tc- o(2^n/2*n)\\n// Space-0(2^n/2+2^n/2)\\nclass Solution {\\n    // TC - 2^(n/2)*n/2\\n    // generate subset sums for a half of the given array\\n    private void createSet(int[] set, int[] nums, int n1) {\\n\\t\\tint sum = 0, setIndex = 0;\\n\\t\\tfor (int i = 0; i < n1; i++) {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif ((i & (1 << j)) > 0) {\\n\\t\\t\\t\\t\\tsum += nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tset[setIndex++] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n\\t\\tint n = stones.length;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i : stones) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\n\\t\\tint[] set1 = new int[1 << n / 2];\\n\\t\\tint[] set2 = new int[1 << (n - n / 2)];\\n\\n\\t\\t// to include from excluded\\n\\t\\tcreateSet(set1, Arrays.copyOfRange(stones, 0, n / 2), 1 << n / 2);\\n\\t\\tcreateSet(set2, Arrays.copyOfRange(stones, n / 2, n), 1 << (n - n / 2));\\n\\n\\t\\t// TC n/2*2^n/2\\n\\t\\tArrays.sort(set2);\\n\\t\\tint target = sum / 2;\\n\\n\\t\\t// lower bound using binary search\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tfor (int i : set1) {\\n\\t\\t\\t// lower bound using binary search\\n\\t\\t\\tint posi = Arrays.binarySearch(set2, target - i);\\n\\t\\t\\tif (posi < 0) {\\n\\t\\t\\t\\tint pos = -1 * (posi + 1);\\n\\t\\t\\t\\tint low = pos - 1;\\n\\t\\t\\t\\tif (low >= 0) {\\n\\t\\t\\t\\t\\tmax = Math.max(max, set2[low] + i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmax = Math.max(max, set2[posi] + i);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn sum - 2 * (max);\\n\\t}\\n}\\n```\\n\\n# Another way of using binary search for finding lower bound\\n```\\n// meet in the middle approach\\nclass Solution {\\n    \\n    // TC - 2^(n/2)*n/2\\n    // generate subset sums for a half of the given array\\n    private void createSet(int[] set, int[] nums, int n1) {\\n\\t\\tint sum = 0, setIndex = 0;\\n\\t\\tfor (int i = 0; i < n1; i++) {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif ((i & (1 << j)) > 0) {\\n\\t\\t\\t\\t\\tsum += nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tset[setIndex++] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n\\t\\tint n = stones.length;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i : stones) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\n\\t\\tint[] set1 = new int[1 << n / 2];\\n\\t\\tint[] set2 = new int[1 << (n - n / 2)];\\n\\n\\t\\t// to include from excluded\\n\\t\\tcreateSet(set1, Arrays.copyOfRange(stones, 0, n / 2), 1 << n / 2);\\n\\t\\tcreateSet(set2, Arrays.copyOfRange(stones, n / 2, n), 1 << (n - n / 2));\\n\\n\\t\\t// TC n/2*2^n/2\\n\\t\\tArrays.sort(set2);\\n\\t\\tint target = sum / 2;\\n\\n\\t\\t// lower bound using binary search\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\tfor (int set1Num : set1) {\\n\\t\\t\\tint low = 0, high = set2.length - 1;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\t\\tif (set1Num + set2[mid] <= target) {\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\tmax = Math.max(max, set1Num + set2[mid]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum - 2 * (max);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\n// Java Top down recursive soltuion\\n// similar to knapsack problem\\n// TC - o(n*sum/2)\\n// Space- o(n*sum/2)\\nclass Solution {\\n    Integer[][] dp;\\n    private int findLowerBoundTargetSum(int[] stones,int target, int start,int currSum){\\n        if(start==stones.length){\\n            return currSum;\\n        }\\n        if(dp[start][currSum]!=null){\\n            return dp[start][currSum];\\n        }\\n        \\n        if(stones[start]+currSum>target){\\n            return dp[start][currSum]=findLowerBoundTargetSum(stones,target,start+1,currSum);\\n        }else{\\n            return dp[start][currSum]=Math.max(findLowerBoundTargetSum(stones,target,start+1,currSum+stones[start]),\\n                                          findLowerBoundTargetSum(stones,target,start+1,currSum));\\n        }\\n        \\n    }\\n    public int lastStoneWeightII(int[] stones) {\\n        int n= stones.length;\\n        int sum=0;\\n        for(int i:stones){\\n            sum+=i;\\n        }\\n        // since we have to minimize the diff bw two subset sums\\n        // ideal subset sums=sum/2, we wll try to find a sum from the subsets which is\\n        // as close to sum/2 as possible=lower bound of sum/2\\n        \\n        // then S2-S1--> we need to minimize, S1+S2=sum, S2=sum-S1 -> minimize Sum-2S1\\n        int target=(sum>>1);\\n        dp=new Integer[n][(sum>>1)+1];\\n        int maxSum=findLowerBoundTargetSum(stones,target,0,0);\\n        return sum-2*maxSum;\\n    }\\n}\\n```\n```\\n// TC - o(n*sum/2)\\n// Space- o(n*sum/2)\\n// same as subset sum diff- minimize TotalSum-2S1\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n=stones.length;\\n        int sum=0;\\n        for(int i:stones){\\n            sum+=i;\\n        }\\n        // we have enumerated all the vlaues till sum/2 and find what is the\\n        // sum value we have for all our array elements which is as close to sum/2\\n        // or is sum/2\\n        boolean[][] dp=new boolean[n+1][sum/2+1];\\n        \\n        // when sum is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=true;\\n        }\\n        \\n        // here the last row tells us that if that particular sum exist for all the\\n        // elements of out array.\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=sum/2;j++){\\n                if(j<stones[i-1]){\\n                    dp[i][j]=dp[i-1][j];\\n                }else{\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<=sum/2;i++){\\n            if(dp[n][i]){// sum exixts\\n                min=Math.min(min,sum-2*i);// take the max sum\\n            }\\n        }\\n        return min;\\n    }\\n    \\n}\\n```\n```\\n// meet in the middle approach\\n// 2^20~10^6, 10^8=1 sec, so 40*2^20~10^7 so good to go for n<=50\\n// Tc- o(2^n/2*n)\\n// Space-0(2^n/2+2^n/2)\\nclass Solution {\\n    // TC - 2^(n/2)*n/2\\n    // generate subset sums for a half of the given array\\n    private void createSet(int[] set, int[] nums, int n1) {\\n\\t\\tint sum = 0, setIndex = 0;\\n\\t\\tfor (int i = 0; i < n1; i++) {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif ((i & (1 << j)) > 0) {\\n\\t\\t\\t\\t\\tsum += nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tset[setIndex++] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n\\t\\tint n = stones.length;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i : stones) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\n\\t\\tint[] set1 = new int[1 << n / 2];\\n\\t\\tint[] set2 = new int[1 << (n - n / 2)];\\n\\n\\t\\t// to include from excluded\\n\\t\\tcreateSet(set1, Arrays.copyOfRange(stones, 0, n / 2), 1 << n / 2);\\n\\t\\tcreateSet(set2, Arrays.copyOfRange(stones, n / 2, n), 1 << (n - n / 2));\\n\\n\\t\\t// TC n/2*2^n/2\\n\\t\\tArrays.sort(set2);\\n\\t\\tint target = sum / 2;\\n\\n\\t\\t// lower bound using binary search\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tfor (int i : set1) {\\n\\t\\t\\t// lower bound using binary search\\n\\t\\t\\tint posi = Arrays.binarySearch(set2, target - i);\\n\\t\\t\\tif (posi < 0) {\\n\\t\\t\\t\\tint pos = -1 * (posi + 1);\\n\\t\\t\\t\\tint low = pos - 1;\\n\\t\\t\\t\\tif (low >= 0) {\\n\\t\\t\\t\\t\\tmax = Math.max(max, set2[low] + i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmax = Math.max(max, set2[posi] + i);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn sum - 2 * (max);\\n\\t}\\n}\\n```\n```\\n// meet in the middle approach\\nclass Solution {\\n    \\n    // TC - 2^(n/2)*n/2\\n    // generate subset sums for a half of the given array\\n    private void createSet(int[] set, int[] nums, int n1) {\\n\\t\\tint sum = 0, setIndex = 0;\\n\\t\\tfor (int i = 0; i < n1; i++) {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif ((i & (1 << j)) > 0) {\\n\\t\\t\\t\\t\\tsum += nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tset[setIndex++] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int lastStoneWeightII(int[] stones) {\\n\\t\\tint n = stones.length;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i : stones) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\n\\t\\tint[] set1 = new int[1 << n / 2];\\n\\t\\tint[] set2 = new int[1 << (n - n / 2)];\\n\\n\\t\\t// to include from excluded\\n\\t\\tcreateSet(set1, Arrays.copyOfRange(stones, 0, n / 2), 1 << n / 2);\\n\\t\\tcreateSet(set2, Arrays.copyOfRange(stones, n / 2, n), 1 << (n - n / 2));\\n\\n\\t\\t// TC n/2*2^n/2\\n\\t\\tArrays.sort(set2);\\n\\t\\tint target = sum / 2;\\n\\n\\t\\t// lower bound using binary search\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\tfor (int set1Num : set1) {\\n\\t\\t\\tint low = 0, high = set2.length - 1;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\t\\tif (set1Num + set2[mid] <= target) {\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\tmax = Math.max(max, set1Num + set2[mid]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum - 2 * (max);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575298,
                "title": "knapsack-minimum-subset-sum-difference-c-commented",
                "content": "```\\nvector<int> last_row_subset_sum(vector<int>& stones, int range){\\n        int n = stones.size();\\n        bool dp[n+1][range+1];\\n        \\n        for(int i = 0; i<=n; i++){\\n            for(int j = 0; j<=range; j++){\\n                if(i == 0) dp[i][j] = false;\\n                if(j == 0) dp[i][j] = true;\\n            }\\n        }\\n        \\n        for(int i = 1; i<=n; i++){\\n            for(int j = 1; j<=range; j++){\\n                if(stones[i-1]<=j) dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                else if(stones[i-1]>j) dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        \\n        vector<int> v; //to store last row\\n        \\n        //we go to range/2 because if we go beyond range/2 we start getting redundant values for s1 as s1+s2 = range\\n        for(int i = 0; i<=range/2; i++){\\n            if(dp[n][i]) v.push_back(i);\\n        }\\n        \\n        return v;\\n        \\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n     \\n        /*Why this problem is equivalent to minimum subset sum difference?\\n        2,7,4,1,8,1 => (7-2),4,1,8,1 => (7-2-4),1,8,1 => (7-2-4-1),8,1 => (8-(7-2-4-1)),1 => (8-7+2+4+1-1) => ((8+2+4+1)-(1+7)) = 7\\n        There can be other such configurations as above. We need to find the one which gives us the minimum difference!\\n        Thus we need to partition the array in such a way so as to minimize the difference between the two subarrays*/\\n        \\n        /*  minimize(s1-s2) => minimize(range-2s1) since range = s1+s2\\n            Thus, we need to minimize s1\\n        */\\n        \\n        int range = 0 ;\\n        \\n        for(auto x : stones) range += x;\\n        \\n        //last row gives those instances from [0 to range] where it is actually possible to form a subset s1 \\n        vector<int> v = last_row_subset_sum(stones,range); \\n        \\n        //we then find at what value of s1 is the difference minimum (remember s2-s1 = range - 2s1)\\n        int mn = INT_MAX;\\n        for(auto x : v) mn = min(mn,range-2*x);\\n        \\n        return mn;\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<int> last_row_subset_sum(vector<int>& stones, int range){\\n        int n = stones.size();\\n        bool dp[n+1][range+1];\\n        \\n        for(int i = 0; i<=n; i++){\\n            for(int j = 0; j<=range; j++){\\n                if(i == 0) dp[i][j] = false;\\n                if(j == 0) dp[i][j] = true;\\n            }\\n        }\\n        \\n        for(int i = 1; i<=n; i++){\\n            for(int j = 1; j<=range; j++){\\n                if(stones[i-1]<=j) dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                else if(stones[i-1]>j) dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        \\n        vector<int> v; //to store last row\\n        \\n        //we go to range/2 because if we go beyond range/2 we start getting redundant values for s1 as s1+s2 = range\\n        for(int i = 0; i<=range/2; i++){\\n            if(dp[n][i]) v.push_back(i);\\n        }\\n        \\n        return v;\\n        \\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n     \\n        /*Why this problem is equivalent to minimum subset sum difference?\\n        2,7,4,1,8,1 => (7-2),4,1,8,1 => (7-2-4),1,8,1 => (7-2-4-1),8,1 => (8-(7-2-4-1)),1 => (8-7+2+4+1-1) => ((8+2+4+1)-(1+7)) = 7\\n        There can be other such configurations as above. We need to find the one which gives us the minimum difference!\\n        Thus we need to partition the array in such a way so as to minimize the difference between the two subarrays*/\\n        \\n        /*  minimize(s1-s2) => minimize(range-2s1) since range = s1+s2\\n            Thus, we need to minimize s1\\n        */\\n        \\n        int range = 0 ;\\n        \\n        for(auto x : stones) range += x;\\n        \\n        //last row gives those instances from [0 to range] where it is actually possible to form a subset s1 \\n        vector<int> v = last_row_subset_sum(stones,range); \\n        \\n        //we then find at what value of s1 is the difference minimum (remember s2-s1 = range - 2s1)\\n        int mn = INT_MAX;\\n        for(auto x : v) mn = min(mn,range-2*x);\\n        \\n        return mn;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524395,
                "title": "dp-python-solution-with-small-explanation-explained",
                "content": "Looking at a few examples: \\n[1, 1] => this is obviously zero 1- 1 = 0\\n[1, 4, 2, 3] => [1, 4 | 2, 3] we are doing substraction when we combine 2 stones.  \\n\\nIn general we see that we want min(sum(subset(a)) - sum(subset(b)))\\nThis degrades to:  416. Partition Equal Subset Sum.  \\n\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        target = sum(stones) // 2\\n        can_get_value = [False] * (target + 1)\\n        can_get_value [0] = True\\n\\n        for stone in stones:\\n            for i in range(target, stone - 1, -1):\\n                can_get_value[i] |= can_get_value[i - stone]\\n\\n        i = target\\n        while i > 0:\\n            if can_get_value[i]:\\n                break\\n            i -= 1\\n\\n        return (sum(stones) - i * 2)\\n\\t\\t```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        target = sum(stones) // 2\\n        can_get_value = [False] * (target + 1)\\n        can_get_value [0] = True\\n\\n        for stone in stones:\\n            for i in range(target, stone - 1, -1):\\n                can_get_value[i] |= can_get_value[i - stone]\\n\\n        i = target\\n        while i > 0:\\n            if can_get_value[i]:\\n                break\\n            i -= 1\\n\\n        return (sum(stones) - i * 2)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1441132,
                "title": "knapsack-01-maths-explained-faster-than-100-c",
                "content": "Let me break down this question for you it is nothing but finding the minimum difference of subset sum or minimum sum partitioning.\\nSo lets say we have an array {1,6,11,5}\\nwe can write on difference as {1,5,6} {11} and the difference will be out answer.\\n\\nTo get the answer we can do thing for every single subset but the time complexity will be huge.\\nLets do it using little maths and DP.\\n\\n**Math behind the problem:**\\n* let the sum of the entire array be sum.\\n* let s1 be the subset 1 and s2 be the subset 2.\\n* s1+s2 will alway be equal to sum...\\n* lets assume that s1 is smaller than s2. So i can say that s1 will always be smaller than my total sum\\'s half.(Think about it if you don\\'t agree).\\n* So if s1 is smaller value so i can say that s1 is smaller than or equal to sum/2; (equal only when sum is even)\\n* s1+s2=sum                                  (  equation:1)\\n* s2=sum-s1         (equation:2)\\n* s1+(sum-s1)=sum  (from equation 1 and 2)\\n* so now my s1=s1 and my s2 =sum-s1\\n* so s2-s1=sum-2*s1\\n\\n\\nif you understood how i got this relation **(s2-s1=sum-2*s1)** then congratulations you understood my maths otherwise please comment you doubt.\\n\\n\\nour job is to find the minimum value of this equation.\\n\\nso we need sum and s1. \\n\\nFor finding sum just use a loop super simple.\\nfor finding s1 use subset sum knapsack problem and store if it is present obviously there will be multiple values for s1.\\nUse the equation to find the min difference.\\n\\n\\nhere is the link for the explanation of the code subset sum please check it out !!! [here](https://leetcode.com/problems/partition-equal-subset-sum/discuss/1439183/recursive-memoization-top-down-all-approaches-explained-with-code-c)\\n\\nhere is the code for what i just said.\\n```\\n int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            sum+=stones[i];\\n        }\\n        vector<int> check(sum+1,0);\\n        vector<int> pr;\\n        \\n        int n=stones.size();\\n        \\n        int dp[n+1][sum+1];\\n        int rs=sum;\\n        sum=sum/2;\\n        for(int i=0;i<sum+1;i++)\\n        {\\n            dp[0][i]=0;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<sum+1;j++)\\n            {\\n                if(j>=stones[i-1])\\n                {\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<=sum;i++)\\n        {\\n            \\n            if(dp[n][i]==1)\\n            {\\n                pr.push_back(i);\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<pr.size();i++)\\n        {\\n            ans=min(ans,rs-2*pr[i]);\\n        }\\n        return ans;\\n    }\\n```\\n\\n**please upvote if i made you understand the problem.\\n#happy_coding\\n**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            sum+=stones[i];\\n        }\\n        vector<int> check(sum+1,0);\\n        vector<int> pr;\\n        \\n        int n=stones.size();\\n        \\n        int dp[n+1][sum+1];\\n        int rs=sum;\\n        sum=sum/2;\\n        for(int i=0;i<sum+1;i++)\\n        {\\n            dp[0][i]=0;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<sum+1;j++)\\n            {\\n                if(j>=stones[i-1])\\n                {\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<=sum;i++)\\n        {\\n            \\n            if(dp[n][i]==1)\\n            {\\n                pr.push_back(i);\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<pr.size();i++)\\n        {\\n            ans=min(ans,rs-2*pr[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429854,
                "title": "detailed-explain-with-math-why-this-can-be-transfer-to-0-1-knapsack-problem",
                "content": "![image](https://assets.leetcode.com/users/images/44c91bc4-cc64-49f8-a7a5-b713c1674c4b_1630108183.9865239.png)\\n\\nThen transfer this problem to a 0 - 1 knapsack problem: fill the knapsack with the capcity equal to half the total sum of stone weight.\\n\\nhttps://en.wikipedia.org/wiki/Knapsack_problem\\n\\nFor me it\\'s hard to related this to knapsack even after looking at others\\'s explains. Hope this helps.\\n\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        m = total // 2\\n        n = len(stones)\\n        \\n        note = [[False] * (m + 1) for i in range(n + 1)]\\n        note[0][0] = True\\n        \\n        s = 0\\n        for i in range(1, n + 1):\\n            note[i][0] = True\\n            temp = stones[i - 1]\\n            for j in range(1, m +1):\\n                note[i][j] = note[i - 1][j] or (j - temp >= 0 and note[i - 1][j - temp])\\n                \\n                if j > s and note[i][j]:\\n                    s = j\\n                    \\n        return total - 2 * s",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/44c91bc4-cc64-49f8-a7a5-b713c1674c4b_1630108183.9865239.png)\\n\\nThen transfer this problem to a 0 - 1 knapsack problem: fill the knapsack with the capcity equal to half the total sum of stone weight.\\n\\nhttps://en.wikipedia.org/wiki/Knapsack_problem\\n\\nFor me it\\'s hard to related this to knapsack even after looking at others\\'s explains. Hope this helps.\\n\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        m = total // 2\\n        n = len(stones)\\n        \\n        note = [[False] * (m + 1) for i in range(n + 1)]\\n        note[0][0] = True\\n        \\n        s = 0\\n        for i in range(1, n + 1):\\n            note[i][0] = True\\n            temp = stones[i - 1]\\n            for j in range(1, m +1):\\n                note[i][j] = note[i - 1][j] or (j - temp >= 0 and note[i - 1][j - temp])\\n                \\n                if j > s and note[i][j]:\\n                    s = j\\n                    \\n        return total - 2 * s",
                "codeTag": "Java"
            },
            {
                "id": 1369499,
                "title": "simple-c-0ms-beats-100-based-on-equal-subset-sum-problem",
                "content": "If we divide array elements into two subsets :\\nWe just need to find the minimum difference between sum of those suubset elements.\\ni.e : minimum of : abs(sum(subset1) - sum(subset2))\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(),stones.end(),0);\\n        int halfSum = totalSum/2;\\n        bool dp[n+1][halfSum+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=halfSum;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = true;\\n                }\\n                else if(i==0){\\n                    dp[i][j] = false;\\n                }\\n                else if(j==0){\\n                    dp[i][j] = true;\\n                }\\n                else{\\n                    if(stones[i-1] > j){\\n                        dp[i][j] = dp[i-1][j];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                    }\\n                }\\n            }\\n        }\\n        int partOne;\\n        for(int i=halfSum;i>=0;i--){\\n            if(dp[n][i] == true){\\n                partOne = i;\\n                break;\\n            }\\n        }\\n        int partTwo = totalSum - partOne;\\n        return abs(partOne-partTwo);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int totalSum = accumulate(stones.begin(),stones.end(),0);\\n        int halfSum = totalSum/2;\\n        bool dp[n+1][halfSum+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=halfSum;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = true;\\n                }\\n                else if(i==0){\\n                    dp[i][j] = false;\\n                }\\n                else if(j==0){\\n                    dp[i][j] = true;\\n                }\\n                else{\\n                    if(stones[i-1] > j){\\n                        dp[i][j] = dp[i-1][j];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                    }\\n                }\\n            }\\n        }\\n        int partOne;\\n        for(int i=halfSum;i>=0;i--){\\n            if(dp[n][i] == true){\\n                partOne = i;\\n                break;\\n            }\\n        }\\n        int partTwo = totalSum - partOne;\\n        return abs(partOne-partTwo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256526,
                "title": "c-solution-using-dp-with-memoization",
                "content": "```\\nclass Solution {\\n    unordered_map<string, int> memo;\\npublic:\\n    int helper(vector<int>& stones, int idx, int currSum) {\\n        string key = to_string(idx) + \"*\" + to_string(currSum);\\n        if (idx >= stones.size())\\n            return abs(currSum);\\n\\n        if (memo.count(key)) return memo[key];\\n\\n        int currAns = 0;\\n\\n        currAns = helper(stones, idx + 1, currSum + stones[idx]);\\n        currAns = min(currAns, helper(stones, idx + 1, currSum - stones[idx]));\\n\\n        return memo[key] = currAns;\\n\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        return helper(stones, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, int> memo;\\npublic:\\n    int helper(vector<int>& stones, int idx, int currSum) {\\n        string key = to_string(idx) + \"*\" + to_string(currSum);\\n        if (idx >= stones.size())\\n            return abs(currSum);\\n\\n        if (memo.count(key)) return memo[key];\\n\\n        int currAns = 0;\\n\\n        currAns = helper(stones, idx + 1, currSum + stones[idx]);\\n        currAns = min(currAns, helper(stones, idx + 1, currSum - stones[idx]));\\n\\n        return memo[key] = currAns;\\n\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        return helper(stones, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226779,
                "title": "javascript-dp",
                "content": "Main idea: try to split the stones into two piles of the same weight as possible, in other word, see how much weight we can get by adding stones in a bag that has sum/2 capacity. now it becomes a 0/1 knapsack problem\\n```\\nvar lastStoneWeightII = function(stones) {\\n    var sum = stones.reduce((a, b) => a + b);\\n    var target = Math.ceil(sum / 2);\\n    var dp = new Array(target + 1).fill(0);\\n    for(var i = 0; i < stones.length; i++) {\\n        for(var j = target; j >= stones[i]; j--) {\\n            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);\\n        }\\n    }\\n    return Math.abs(2 * dp[target] - sum);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lastStoneWeightII = function(stones) {\\n    var sum = stones.reduce((a, b) => a + b);\\n    var target = Math.ceil(sum / 2);\\n    var dp = new Array(target + 1).fill(0);\\n    for(var i = 0; i < stones.length; i++) {\\n        for(var j = target; j >= stones[i]; j--) {\\n            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);\\n        }\\n    }\\n    return Math.abs(2 * dp[target] - sum);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196755,
                "title": "python-0-1-knapsack-solution",
                "content": "The problem can be re-written as \"choose a subset of the stones in which the total weight of the subset of stones is as close to half of the weight of all the stones as possible\". This is essentially the 0/1 knapsack problem where the \"value\" and the \"weight\" of each item is the same and the \"max weight\" is half of the total weight of the stones \\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones):\\n        def knapsack(items, max_weight):\\n            dp = [[0 for i in range(max_weight+1)] for j in range(len(items))]\\n            for i,item in enumerate(items):\\n                for weight in range(max_weight+1):\\n                    if item <= weight:\\n                        dp[i][weight] = max(dp[i-1][weight], dp[i-1][weight-item]+item)\\n                    else:\\n                        dp[i][weight] = dp[i-1][weight]\\n            return dp[-1][-1]\\n\\t\\t\\t\\n        s = sum(stones)\\n        return s - 2*knapsack(stones,s//2) \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones):\\n        def knapsack(items, max_weight):\\n            dp = [[0 for i in range(max_weight+1)] for j in range(len(items))]\\n            for i,item in enumerate(items):\\n                for weight in range(max_weight+1):\\n                    if item <= weight:\\n                        dp[i][weight] = max(dp[i-1][weight], dp[i-1][weight-item]+item)\\n                    else:\\n                        dp[i][weight] = dp[i-1][weight]\\n            return dp[-1][-1]\\n\\t\\t\\t\\n        s = sum(stones)\\n        return s - 2*knapsack(stones,s//2) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107526,
                "title": "0-ms-faster-than-100-00-of-c-knapsack-problem-breakdown-into-subset-sum-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int range=0;\\n        for(auto a: stones){\\n            range+=a;\\n        }\\n        bool dp[n+1][range+1];\\n        for(int i=0;i<=n;i++){\\n         for(int j=0;j<=range;j++){\\n            if(i==0) dp[i][j]=false;\\n            if(j==0) dp[i][j]=true;\\n          }   \\n        }\\n        for(int i=1;i<=n;i++){\\n         for(int j=1;j<=range;j++){\\n            if(stones[i-1]<=j) dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n             else dp[i][j]=dp[i-1][j];\\n          }   \\n        }\\n        vector<int>v;\\n        for(int j=0;j<=range;j++){\\n            if(dp[n][j]==true) v.push_back(j);\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0;i<v.size();i++){\\n            mn=min(mn,abs(range-2*v[i]));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int range=0;\\n        for(auto a: stones){\\n            range+=a;\\n        }\\n        bool dp[n+1][range+1];\\n        for(int i=0;i<=n;i++){\\n         for(int j=0;j<=range;j++){\\n            if(i==0) dp[i][j]=false;\\n            if(j==0) dp[i][j]=true;\\n          }   \\n        }\\n        for(int i=1;i<=n;i++){\\n         for(int j=1;j<=range;j++){\\n            if(stones[i-1]<=j) dp[i][j]=dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n             else dp[i][j]=dp[i-1][j];\\n          }   \\n        }\\n        vector<int>v;\\n        for(int j=0;j<=range;j++){\\n            if(dp[n][j]==true) v.push_back(j);\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0;i<v.size();i++){\\n            mn=min(mn,abs(range-2*v[i]));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088727,
                "title": "javascript-easy-knapsack-dp",
                "content": "I think this is the classic problem of 0/1 knapsack called Minimum subset difference.\\nBasically we have to find two subset in such a way that the difference between the  subset is minimal.\\n```\\nvar lastStoneWeightII = function(arr) {\\n   let tar =0\\n  for(let i =0;i<arr.length;i++){\\n      tar+=arr[i]\\n  }\\n  let dp = Array(arr.length+1).fill().map(()=>Array((Math.floor(tar/2))+1))\\nfor(let i =0;i<=arr.length;i++){\\n  for(let j =0;j<=tar;j++){\\n    if(i===0){\\n      dp[i][j] = false\\n    }\\n    if(j===0){\\n      dp[i][j] = true\\n    }\\n  }\\n}\\nfor(let i =1;i<=arr.length;i++){\\n  for(let j =1;j<=Math.floor(tar/2);j++){\\n    if(arr[i-1]<=j){\\n      dp[i][j]=dp[i-1][j-arr[i-1]]||dp[i-1][j]\\n    }else{\\n      dp[i][j] = dp[i-1][j]\\n    }\\n  }\\n}\\n  for(let k= Math.floor(tar/2);k>=0;k--){\\n    if(dp[arr.length][k]===true){\\n       return tar-(2*k)\\n    }\\n  } \\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar lastStoneWeightII = function(arr) {\\n   let tar =0\\n  for(let i =0;i<arr.length;i++){\\n      tar+=arr[i]\\n  }\\n  let dp = Array(arr.length+1).fill().map(()=>Array((Math.floor(tar/2))+1))\\nfor(let i =0;i<=arr.length;i++){\\n  for(let j =0;j<=tar;j++){\\n    if(i===0){\\n      dp[i][j] = false\\n    }\\n    if(j===0){\\n      dp[i][j] = true\\n    }\\n  }\\n}\\nfor(let i =1;i<=arr.length;i++){\\n  for(let j =1;j<=Math.floor(tar/2);j++){\\n    if(arr[i-1]<=j){\\n      dp[i][j]=dp[i-1][j-arr[i-1]]||dp[i-1][j]\\n    }else{\\n      dp[i][j] = dp[i-1][j]\\n    }\\n  }\\n}\\n  for(let k= Math.floor(tar/2);k>=0;k--){\\n    if(dp[arr.length][k]===true){\\n       return tar-(2*k)\\n    }\\n  } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1077244,
                "title": "java-knapsack-like-1d-boolean-array-1-ms-99",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int s: stones) {\\n            sum += s;\\n        }\\n        int w = (sum+1)/2;\\n        boolean dp[] = new boolean[w+1];\\n        int max = 0;\\n\\n        for(int s: stones) {\\n            for(int i=w; i>s; i--) {\\n                if(dp[i-s]) {\\n                    dp[i] = true;\\n                    max = Math.max(max, i);\\n                }\\n            }\\n            max = Math.max(max, s);\\n            dp[s] = true;\\n        }\\n\\n        return Math.abs(sum-2*max);\\n    }\\n}\\n```\\nTime: O(mn)\\n\\nExplanation:\\nObjective is to split the array into 2 sub-arrays so that the difference is minimized.\\nSo, just check if half the sum or less can be achieved, i.e. `w = (sum+1)/2.`\\nWhichever sum from `0 to w`, can be achieved, make them true in the `dp`.\\nWe don\\'t need extra checks to have the minimum number of elements in the target sub-array, like knapsack, hence a boolean array is enough.\\n\\n`max` is closest weight to `w` that is true;",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int s: stones) {\\n            sum += s;\\n        }\\n        int w = (sum+1)/2;\\n        boolean dp[] = new boolean[w+1];\\n        int max = 0;\\n\\n        for(int s: stones) {\\n            for(int i=w; i>s; i--) {\\n                if(dp[i-s]) {\\n                    dp[i] = true;\\n                    max = Math.max(max, i);\\n                }\\n            }\\n            max = Math.max(max, s);\\n            dp[s] = true;\\n        }\\n\\n        return Math.abs(sum-2*max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051227,
                "title": "java-top-down-recursive",
                "content": "```\\nclass Solution {\\n    \\n    private Integer[][] cache;\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        //min(S[p1] - S[p2])\\n        //S[p1] + S[p2] = total\\n        //S[p1] = total - S[p2]\\n        //min(total - 2 * S[p2]) and total - 2 * s[p2] >= 0\\n        //s[p2] <= total / 2\\n        int total = 0;\\n        for(int i : stones) {\\n            total += i;\\n        }\\n        cache = new Integer[stones.length][(total >> 1) + 1];\\n        int maxSum = getMaxPartSum(stones, 0, total >> 1, 0);\\n        return Math.abs(total - maxSum - maxSum);\\n    }\\n    \\n    private int getMaxPartSum(int[] nums, int i, int cap, int runningSum) {\\n        //base case\\n        if(i == nums.length) {\\n            return runningSum;\\n        }\\n        if(null != cache[i][runningSum]) {\\n            return cache[i][runningSum];\\n        }\\n        if(nums[i] + runningSum <= cap) {\\n            //case1: Choose this no\\n            int t1 = getMaxPartSum(nums, i + 1, cap, runningSum + nums[i]);\\n            //case2: Don\\'t choose this no\\n            int t2 = getMaxPartSum(nums, i + 1, cap, runningSum);\\n            cache[i][runningSum] = Math.max(t1, t2);\\n        } else {\\n            //no choice but to skip this\\n            cache[i][runningSum] = getMaxPartSum(nums, i + 1, cap, runningSum);\\n        }\\n        return cache[i][runningSum];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private Integer[][] cache;\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        //min(S[p1] - S[p2])\\n        //S[p1] + S[p2] = total\\n        //S[p1] = total - S[p2]\\n        //min(total - 2 * S[p2]) and total - 2 * s[p2] >= 0\\n        //s[p2] <= total / 2\\n        int total = 0;\\n        for(int i : stones) {\\n            total += i;\\n        }\\n        cache = new Integer[stones.length][(total >> 1) + 1];\\n        int maxSum = getMaxPartSum(stones, 0, total >> 1, 0);\\n        return Math.abs(total - maxSum - maxSum);\\n    }\\n    \\n    private int getMaxPartSum(int[] nums, int i, int cap, int runningSum) {\\n        //base case\\n        if(i == nums.length) {\\n            return runningSum;\\n        }\\n        if(null != cache[i][runningSum]) {\\n            return cache[i][runningSum];\\n        }\\n        if(nums[i] + runningSum <= cap) {\\n            //case1: Choose this no\\n            int t1 = getMaxPartSum(nums, i + 1, cap, runningSum + nums[i]);\\n            //case2: Don\\'t choose this no\\n            int t2 = getMaxPartSum(nums, i + 1, cap, runningSum);\\n            cache[i][runningSum] = Math.max(t1, t2);\\n        } else {\\n            //no choice but to skip this\\n            cache[i][runningSum] = getMaxPartSum(nums, i + 1, cap, runningSum);\\n        }\\n        return cache[i][runningSum];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004976,
                "title": "c-minimum-subset-sum-difference",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=stones[i];\\n       int s=sum/2;\\n        int ans=INT_MAX;\\n        bool t[n+1][s+1];\\n        vector<int> v;\\n        \\n        for(int i=0;i<n+1;i++)\\n            t[i][0]=true;\\n        for(int i=1;i<s+1;i++)\\n            t[0][i]=false;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s+1;j++){\\n                if(stones[i-1]<=j){\\n                    t[i][j]=t[i-1][j-stones[i-1]] || t[i-1][j];\\n                }\\n                else\\n                    t[i][j]=t[i-1][j];\\n            }\\n        }\\n        \\n        \\n        for(int i=1;i<s+1;i++)\\n        {\\n         if(t[n][i] == true)\\n       \\t   v.push_back(i);\\n        }\\n        \\n        for(int i : v){\\n            ans=min(ans, sum-(2*i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=stones[i];\\n       int s=sum/2;\\n        int ans=INT_MAX;\\n        bool t[n+1][s+1];\\n        vector<int> v;\\n        \\n        for(int i=0;i<n+1;i++)\\n            t[i][0]=true;\\n        for(int i=1;i<s+1;i++)\\n            t[0][i]=false;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s+1;j++){\\n                if(stones[i-1]<=j){\\n                    t[i][j]=t[i-1][j-stones[i-1]] || t[i-1][j];\\n                }\\n                else\\n                    t[i][j]=t[i-1][j];\\n            }\\n        }\\n        \\n        \\n        for(int i=1;i<s+1;i++)\\n        {\\n         if(t[n][i] == true)\\n       \\t   v.push_back(i);\\n        }\\n        \\n        for(int i : v){\\n            ans=min(ans, sum-(2*i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984927,
                "title": "c-solution-similar-to-min-sum-partition-problem-of-dp",
                "content": "```\\n    int solve(vector<int> nums,int range)\\n{\\n\\tint sum = range/2;\\n\\tint n = nums.size();\\n\\tvector<int> candidates;\\n\\tint ans = INT_MAX;\\n\\tvector<vector<bool>> dp(n+1,vector<bool>(sum+1));\\n\\tfor(int i  = 0;i<n+1;i++)\\n\\t\\tdp[i][0] = true;\\n\\tfor(int i = 1;i<sum+1;i++)\\n\\t\\tdp[0][i] = false;\\n\\tfor(int i = 1;i<n+1;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<sum+1;j++)\\n\\t\\t{\\n           if(nums[i-1] <=j)\\n           \\tdp[i][j] = dp[i-1][j - nums[i-1]] || dp[i-1][j];\\n           else\\n           \\tdp[i][j] = dp[i-1][j];\\n\\t\\t}\\n\\t}\\n    for(int i = 1;i<sum+1;i++)\\n    {\\n       if(dp[n][i] == true)\\n       \\tcandidates.push_back(i);\\n    }\\n    for(int i:candidates)\\n    \\tans = min(ans,range - (2 * i));\\nreturn ans;\\n}\\n\\n\\n\\nint lastStoneWeightII(vector<int>& stones) {\\n   int range = 0;\\n   for(int i:stones)\\n   \\t   range+=i;\\n   \\treturn solve(stones,range);\\n}\\n",
                "solutionTags": [],
                "code": "```\\n    int solve(vector<int> nums,int range)\\n{\\n\\tint sum = range/2;\\n\\tint n = nums.size();\\n\\tvector<int> candidates;\\n\\tint ans = INT_MAX;\\n\\tvector<vector<bool>> dp(n+1,vector<bool>(sum+1));\\n\\tfor(int i  = 0;i<n+1;i++)\\n\\t\\tdp[i][0] = true;\\n\\tfor(int i = 1;i<sum+1;i++)\\n\\t\\tdp[0][i] = false;\\n\\tfor(int i = 1;i<n+1;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<sum+1;j++)\\n\\t\\t{\\n           if(nums[i-1] <=j)\\n           \\tdp[i][j] = dp[i-1][j - nums[i-1]] || dp[i-1][j];\\n           else\\n           \\tdp[i][j] = dp[i-1][j];\\n\\t\\t}\\n\\t}\\n    for(int i = 1;i<sum+1;i++)\\n    {\\n       if(dp[n][i] == true)\\n       \\tcandidates.push_back(i);\\n    }\\n    for(int i:candidates)\\n    \\tans = min(ans,range - (2 * i));\\nreturn ans;\\n}\\n\\n\\n\\nint lastStoneWeightII(vector<int>& stones) {\\n   int range = 0;\\n   for(int i:stones)\\n   \\t   range+=i;\\n   \\treturn solve(stones,range);\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 977681,
                "title": "python-solution-beat-99-using-set",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        if len(stones)==1:\\n            return stones[0]\\n        s=set()\\n        s.add(stones[0])\\n        s.add(-stones[0])\\n        dp=set()\\n        for i in range(1,len(stones)):\\n            for j in s:\\n                dp.add(abs(j-stones[i]))\\n                dp.add(abs(j+stones[i]))\\n            s=dp\\n            dp=set()\\n        return min(s)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        if len(stones)==1:\\n            return stones[0]\\n        s=set()\\n        s.add(stones[0])\\n        s.add(-stones[0])\\n        dp=set()\\n        for i in range(1,len(stones)):\\n            for j in s:\\n                dp.add(abs(j-stones[i]))\\n                dp.add(abs(j+stones[i]))\\n            s=dp\\n            dp=set()\\n        return min(s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950456,
                "title": "c-knapsack-dp-explained",
                "content": "I\\'m posting this to whomever, like me, did not grasp the fact that this problem could be reduced to the knapsack problem at first.\\n\\nThe main issue here is that, if you go and write down the expression for the problem like:\\nV = [a, b, c, d, e]\\n\\nAssuming steps to one solution are:\\nx = a-b, then y=c-d, then z=x-e, then S=y-z.\\n\\nThat is the same thing as saying:\\nS= (c-d)-(x-e) = (c-d)-((a-b)-e) = (c+b+e)-(d+a)\\n\\nWhen S is the minimun possible value. And you can rearrange any other combination like this.\\n\\nWhich reduces this problem to finding whichever subset of V with the maximum somatorium is still smaller than the half of the total.\\n\\nSay W = [a1, a2, a3 ...] is a subset of V, then Sum(W) < Sum(V), but Sum(W) must be the maximun possible, so that we have the minimun difference from it to the remaing set V[...] - W[...].\\n\\nThat is exactly the knapsack problem, but with float numbers, dont forget that part.\\nYou can definetly optimize this answer by getting rid of the floats, thought.\\n\\n```\\nclass Solution {\\npublic:\\n    #define INF 100000\\n    std::map<pair<int,float>,float> memo;\\n    int lastStoneWeightII(vector<int>& stones) {\\n        float half = accumulate(stones.begin(), stones.end(), 0)/(float)2;\\n        return remainderKnapsack(stones, 0, half)*2;\\n    }\\n    float remainderKnapsack(vector<int>& stones, int i, float capacity) {\\n        float result = 0;\\n        if (capacity < 0) {\\n            return INF;\\n        }\\n        if (i == stones.size()) {\\n            return capacity;\\n        }\\n        if (memo.count(pair<int,float>({i, capacity}))) {\\n            return memo[pair<int,float>({i, capacity})];\\n        }\\n        return memo[pair<int,float>({i, capacity})] = min(remainderKnapsack(stones, i+1, capacity), remainderKnapsack(stones, i+1, capacity -stones[i]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define INF 100000\\n    std::map<pair<int,float>,float> memo;\\n    int lastStoneWeightII(vector<int>& stones) {\\n        float half = accumulate(stones.begin(), stones.end(), 0)/(float)2;\\n        return remainderKnapsack(stones, 0, half)*2;\\n    }\\n    float remainderKnapsack(vector<int>& stones, int i, float capacity) {\\n        float result = 0;\\n        if (capacity < 0) {\\n            return INF;\\n        }\\n        if (i == stones.size()) {\\n            return capacity;\\n        }\\n        if (memo.count(pair<int,float>({i, capacity}))) {\\n            return memo[pair<int,float>({i, capacity})];\\n        }\\n        return memo[pair<int,float>({i, capacity})] = min(remainderKnapsack(stones, i+1, capacity), remainderKnapsack(stones, i+1, capacity -stones[i]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916052,
                "title": "c-beats-100-subset-sum-dp",
                "content": "**Objective:** We need to partition the array into two subsets such that the difference of their sums is minimised. \\nOf the given denominations of stones, we need to see the maximum target achievable. (0<target<=stone_sum/2)\\n**dp[i][j]** tells whether target **j** is achievable or not with atmost **i** stones.\\nSo, find the max **j** that can be achieved. let it be **s**, return **abs(2*s - stone_sum)**.\\n\\nA similar approach in Python can be found here https://www.youtube.com/watch?v=0RGxWCE2vzM&t=3s\\n\\n\\n```\\nint sum(vector<int>v)\\n    {\\n        int s=0;\\n        for(int i=0;i<v.size();i++)\\n            s+=v[i];\\n        return s;\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int stone_sum = sum(stones);\\n        int target = stone_sum%2==0? stone_sum/2 : (stone_sum +1)/2;\\n        \\n        int dp[n+1][target+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=target;j++)\\n            {\\n                if(j==0)\\n                    dp[i][j]=true;\\n                else\\n                    dp[i][j]=false;\\n            }\\n        }\\n        int s=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=target;j++)\\n            {\\n                if(j>=stones[i-1])\\n                    dp[i][j] = dp[i-1][j]|dp[i-1][j-stones[i-1]];\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n                \\n                if(dp[i][j]==true)\\n                    s = max(s,j);\\n            }\\n        }\\n        \\n        return abs(2*s-stone_sum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint sum(vector<int>v)\\n    {\\n        int s=0;\\n        for(int i=0;i<v.size();i++)\\n            s+=v[i];\\n        return s;\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n = stones.size();\\n        int stone_sum = sum(stones);\\n        int target = stone_sum%2==0? stone_sum/2 : (stone_sum +1)/2;\\n        \\n        int dp[n+1][target+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=target;j++)\\n            {\\n                if(j==0)\\n                    dp[i][j]=true;\\n                else\\n                    dp[i][j]=false;\\n            }\\n        }\\n        int s=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=target;j++)\\n            {\\n                if(j>=stones[i-1])\\n                    dp[i][j] = dp[i-1][j]|dp[i-1][j-stones[i-1]];\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n                \\n                if(dp[i][j]==true)\\n                    s = max(s,j);\\n            }\\n        }\\n        \\n        return abs(2*s-stone_sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908871,
                "title": "java-dp-solution-faster-than-90",
                "content": "```\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length, sum = 0;\\n        for (int i = 0; i < n; i++)\\n            sum += stones[i];\\n\\n        boolean[] f = new boolean[sum/2+1];\\n        Arrays.fill(f, false);\\n        f[0] = true;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = sum / 2; j >= stones[i]; j--)\\n                f[j] = f[j] || f[j - stones[i]];\\n\\n        for (int i = sum / 2; i >= 0; i--)\\n            if (f[i])\\n                return sum - i - i;\\n\\n        return sum;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length, sum = 0;\\n        for (int i = 0; i < n; i++)\\n            sum += stones[i];\\n\\n        boolean[] f = new boolean[sum/2+1];\\n        Arrays.fill(f, false);\\n        f[0] = true;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = sum / 2; j >= stones[i]; j--)\\n                f[j] = f[j] || f[j - stones[i]];\\n\\n        for (int i = sum / 2; i >= 0; i--)\\n            if (f[i])\\n                return sum - i - i;\\n\\n        return sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 897003,
                "title": "a-replica-of-divide-array-into-two-subsequences-with-min-sum-difference",
                "content": "class Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n            s+=stones[i];\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(s+1));\\n        \\n        for(int i=1;i<=s;i++)\\n            dp[0][i]=0;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=s;j++)\\n            {\\n                if(j>=stones[i-1])\\n                    dp[i][j]=dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        int i;\\n        for( i=s/2;i>=0;i--)\\n        {\\n            if(dp[n][i]==1)\\n                break;\\n        }\\n        \\n        int ans=(s-i)-i>0?s-i-i:0;\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n            s+=stones[i];\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(s+1));\\n        \\n        for(int i=1;i<=s;i++)\\n            dp[0][i]=0;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=s;j++)\\n            {\\n                if(j>=stones[i-1])\\n                    dp[i][j]=dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 802680,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        int totsum = 0;\\n        \\n        for(auto stone: stones) totsum+=stone;\\n        \\n        int sum = (totsum%2) ? totsum/2 +1 : totsum/2;\\n        \\n        bool dp[n+1][sum+1];\\n        \\n        for(int i=0;i<=sum;i++)\\n            dp[0][i] = false;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[i][0] = true;\\n        \\n        int maxx = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                dp[i][j] = dp[i-1][j];\\n                if(j>=stones[i-1])\\n                {\\n                    dp[i][j] = dp[i][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                if(dp[i][j]) maxx = max(maxx,j);\\n            }\\n        }\\n        \\n        int first = maxx;\\n        int second = totsum-maxx;\\n        \\n        return abs(first-second);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        int totsum = 0;\\n        \\n        for(auto stone: stones) totsum+=stone;\\n        \\n        int sum = (totsum%2) ? totsum/2 +1 : totsum/2;\\n        \\n        bool dp[n+1][sum+1];\\n        \\n        for(int i=0;i<=sum;i++)\\n            dp[0][i] = false;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[i][0] = true;\\n        \\n        int maxx = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                dp[i][j] = dp[i-1][j];\\n                if(j>=stones[i-1])\\n                {\\n                    dp[i][j] = dp[i][j] || dp[i-1][j-stones[i-1]];\\n                }\\n                if(dp[i][j]) maxx = max(maxx,j);\\n            }\\n        }\\n        \\n        int first = maxx;\\n        int second = totsum-maxx;\\n        \\n        return abs(first-second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749263,
                "title": "c-0ms-dp",
                "content": "see [this](https://www.***.org/0-1-knapsack-problem-dp-10/) for understandig the concept\\n```\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        int m;\\n        \\n        for(int x : stones) sum += x;\\n        m = sum/2;\\n    \\n        vector<vector<int>> dp(2,vector<int>(m+1,0));\\n        \\n        for(int x : stones){\\n            for(int i = x ; i < dp[0].size() ; i++){\\n                dp[1][i] = max(dp[0][i],dp[0][i-x]+x);\\n            }\\n            dp[0] = dp[1];\\n        }\\n        return sum-(2*dp[1][m]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0;\\n        int m;\\n        \\n        for(int x : stones) sum += x;\\n        m = sum/2;\\n    \\n        vector<vector<int>> dp(2,vector<int>(m+1,0));\\n        \\n        for(int x : stones){\\n            for(int i = x ; i < dp[0].size() ; i++){\\n                dp[1][i] = max(dp[0][i],dp[0][i-x]+x);\\n            }\\n            dp[0] = dp[1];\\n        }\\n        return sum-(2*dp[1][m]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 725095,
                "title": "well-explained-java-solution-with-diagram",
                "content": "**Solution 1**\\n\\nThis question is same as partitioning array into 2 subsets where difference is minimal. \\nWe divide the array into P & N, Let\\'s say that\\n P = sum of subset of Positive Numbers\\n N = sum of subset of Negative Numbers\\n (1) P+N = Sum\\n (2) P-N = Diff\\n   -> P+N-P+N =Sum - diff\\n    -> 2N = Sum-diff\\n    -> diff = Sum - 2N      // So, minimum diff equals maximum N.\\n\\nTo find maximum N, let\\'s assume diff is 0, since that is the minimum possible value of diff, so with this we can know the maximum possible value of N. So now with diff 0 the equation is : 2N = Sum, so N = Sum/2\\n\\nSo to find the maximum possible value of N, it can be anywhere from 0 to Sum/2;\\n\\n![image](https://assets.leetcode.com/users/images/bcc48dc0-1729-4afb-8bcf-a010e02e614c_1594179779.8837605.png)\\n\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int N = stones.length;\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int actualSumForNegativeNumbers = 0; //Sum(N)\\n        int maxSumForNegativeNumbers = sum/2; //max(N)\\n        boolean[][] dp = new boolean[N+1][maxSumForNegativeNumbers+1];\\n        \\n        for(int i=0;i<=N;i++){\\n            dp[i][0] = true;\\n        }\\n            \\n        \\n        for(int i=1;i<=N;i++){\\n            for(int j=1;j<=maxSumForNegativeNumbers;j++){\\n                if(j>=stones[i-1] && dp[i-1][j-stones[i-1]]){\\n                    dp[i][j] = true;\\n                    actualSumForNegativeNumbers = Math.max(actualSumForNegativeNumbers,j);\\n                }\\n                else if(dp[i-1][j]){\\n                    dp[i][j] = true;\\n                    actualSumForNegativeNumbers = Math.max(actualSumForNegativeNumbers,j);\\n                }\\n            }   \\n        }\\n        \\n        return sum - 2*actualSumForNegativeNumbers;\\n    }\\n}\\n```\\n\\n**Solution 2** - Similar to [Target Sum](https://leetcode.com/problems/target-sum/) (it utilizes subsetsum2d method) \\n\\n![image](https://assets.leetcode.com/users/images/d27abd5a-5350-444e-9aaf-012818bfa186_1594179817.5170486.png)\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int actualSumForNegativeNumbers = 0; //Sum(N)\\n        int maxSumForNegativeNumbers = sum/2; //max(N)\\n        \\n        actualSumForNegativeNumbers = subsetSum2d(stones,maxSumForNegativeNumbers);\\n        \\n        return sum - 2*actualSumForNegativeNumbers;\\n    }\\n    \\n    private int subsetSum2d(int[] nums, int target) {\\n        //dp[i][j]: the number of subsets that can sum to target j with the first j numbers\\n        int[][] dp = new int[nums.length + 1][target + 1];      \\n        for(int i=0;i<=nums.length;i++)\\n            dp[i][0] = 1;\\n        \\n        int N = 0;\\n\\n         for (int i = 1; i <= nums.length;  i++) {\\n             for (int j = 1; j <= target;  j++) {\\n                 if (j >= nums[i - 1]) {\\n                     dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n                 } else {\\n                     dp[i][j] = dp[i - 1][j];\\n                 }\\n                 // since we need to get the max possible value of j, which is sum of Negative subset\\n                 N = dp[i][j]!=0 ? Math.max(N,j) : N;\\n             }          \\n         }\\n\\n\\n         return N;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int N = stones.length;\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int actualSumForNegativeNumbers = 0; //Sum(N)\\n        int maxSumForNegativeNumbers = sum/2; //max(N)\\n        boolean[][] dp = new boolean[N+1][maxSumForNegativeNumbers+1];\\n        \\n        for(int i=0;i<=N;i++){\\n            dp[i][0] = true;\\n        }\\n            \\n        \\n        for(int i=1;i<=N;i++){\\n            for(int j=1;j<=maxSumForNegativeNumbers;j++){\\n                if(j>=stones[i-1] && dp[i-1][j-stones[i-1]]){\\n                    dp[i][j] = true;\\n                    actualSumForNegativeNumbers = Math.max(actualSumForNegativeNumbers,j);\\n                }\\n                else if(dp[i-1][j]){\\n                    dp[i][j] = true;\\n                    actualSumForNegativeNumbers = Math.max(actualSumForNegativeNumbers,j);\\n                }\\n            }   \\n        }\\n        \\n        return sum - 2*actualSumForNegativeNumbers;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sum = 0;\\n        for(int stone: stones)\\n            sum += stone;\\n        \\n        int actualSumForNegativeNumbers = 0; //Sum(N)\\n        int maxSumForNegativeNumbers = sum/2; //max(N)\\n        \\n        actualSumForNegativeNumbers = subsetSum2d(stones,maxSumForNegativeNumbers);\\n        \\n        return sum - 2*actualSumForNegativeNumbers;\\n    }\\n    \\n    private int subsetSum2d(int[] nums, int target) {\\n        //dp[i][j]: the number of subsets that can sum to target j with the first j numbers\\n        int[][] dp = new int[nums.length + 1][target + 1];      \\n        for(int i=0;i<=nums.length;i++)\\n            dp[i][0] = 1;\\n        \\n        int N = 0;\\n\\n         for (int i = 1; i <= nums.length;  i++) {\\n             for (int j = 1; j <= target;  j++) {\\n                 if (j >= nums[i - 1]) {\\n                     dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n                 } else {\\n                     dp[i][j] = dp[i - 1][j];\\n                 }\\n                 // since we need to get the max possible value of j, which is sum of Negative subset\\n                 N = dp[i][j]!=0 ? Math.max(N,j) : N;\\n             }          \\n         }\\n\\n\\n         return N;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719748,
                "title": "full-proof-of-why-the-dp-solution-gives-the-correct-answer",
                "content": "There are ```n!``` ways of smashing stones but only ```2^n``` ways of constructing a set with DP. Even then, it is not immediately clear that with any given set selected, we can actually reaching the final state. So I decided to show that it is indeed possible.\\n\\nNotations: uppercase letters are for sets and lowercase letters are for elements. Enclosing an element with ```{}```  makes a set with the given elements. ```+``` and ```-``` between sets means combining two sets and removing a subset to form a new set.\\n\\nDefine W(S) as a function that gives the total weight of a set of stones S. Let sets P and Q satisfy:\\n(1) ```W(P) \\u2264 W(Q)```,\\n(2) If ```W(P) < W(Q)```, there do not exist any subset P_S of P and any subset Q_S of Q, such that ```W(P) < W(P - P_S + Q_S) \\u2264 W(Q - Q_S + P_S) < W(Q)```. (In plain language, we can swap some elements in P with some elements in Q, so that we increase the total weight of P and decrease the total weight of Q, while maintaining condition (1).)\\n\\t\\t\\nOnce P and Q are selected correctly (preferrably through dynamic programming), the following pseudocode demonstrates that for any given P and Q, we can, step by step, reach the result where there is no more than one stone left in the end and the weight of that stone is the desired answer.\\n``` \\n while P is not empty:\\n     p = P.pop()\\n\\t q = Q.pop()\\n\\t if W({p}) > W({q}):\\n\\t     P.push(create_stone_with_weight(W({p})-W({q})))\\n     else if W({p}) < W({q}):\\n\\t     Q.push(create_stone_with_weight(W({q})-W({p})))\\nreturn W(Q)\\n```\\n\\t \\nFirst, we prove that the two conditions are maintained after a loop:\\n\\n(1) The first condition is maintained because the weight of two sets goes down by the same amount.\\n\\n(2) The second condition is obviously maintained if ```W({p})=W({q})``` since there is no new stone being created. Without losing generality, suppose ```W({p})>W({q})``` so that we have a new stone ```r``` in ```P``` and that there exist ```P_S``` and ```Q_S``` such that and \\n```W(P) < W(P - (P_S + {r}) + Q_S) \\u2264 W(Q - Q_S + (P_S + {r})) < W(Q)```, \\nthen we must also have \\n```W(P) < W(P - (P_S + {p}) + (Q_S + {q})) \\u2264 W(Q - (Q_S + {q}) + (P_S + {p})) < W(Q)```, \\nwhich contradicts the statement that there do not exist subsets ```P_S + {p}``` and ```Q_S + {q}``` that break the second condition before the loop.\\n\\nNotice that whichever element returned by ```pop()``` doesn\\'t matter. Firstly, it\\'s not used in the previous proof. Secondly, it always decrement the total number of stones by at least 1 so eventually the loop will exit. Therefore, at least with this pseudocode, that\\'s where the number of possibilities gets reduced from ```n!``` to ```2^n```.\\n\\nSecondly, we prove that we can safely exit the loop.\\n\\n(1) Since ```W(P)\\u2264W(Q)``` always holds throughtout the loops, Q is never empty when P is not empty and P always can be emptied, so we can\\'t get stuck in the loop.\\n\\n(2) If there exist at least two elements ```q1``` and ```q2``` in ```Q``` when the loop exits, then without losing generality, supposedly ```W({q1}) \\u2264 W({q2})```, the empty set as a subset of the empty set ```P``` and ```{q1}``` as a subset of ```Q```, break condition (2). This contradicts the statement that condition (2) is satisfied before the loops and is maintained throughout the loops.\\n\\nQ.E.D.",
                "solutionTags": [],
                "code": "```n!```\n```2^n```\n```{}```\n```+```\n```-```\n```W(P) \\u2264 W(Q)```\n```W(P) < W(Q)```\n```W(P) < W(P - P_S + Q_S) \\u2264 W(Q - Q_S + P_S) < W(Q)```\n``` \\n while P is not empty:\\n     p = P.pop()\\n\\t q = Q.pop()\\n\\t if W({p}) > W({q}):\\n\\t     P.push(create_stone_with_weight(W({p})-W({q})))\\n     else if W({p}) < W({q}):\\n\\t     Q.push(create_stone_with_weight(W({q})-W({p})))\\nreturn W(Q)\\n```\n```W({p})=W({q})```\n```W({p})>W({q})```\n```r```\n```P```\n```P_S```\n```Q_S```\n```W(P) < W(P - (P_S + {r}) + Q_S) \\u2264 W(Q - Q_S + (P_S + {r})) < W(Q)```\n```W(P) < W(P - (P_S + {p}) + (Q_S + {q})) \\u2264 W(Q - (Q_S + {q}) + (P_S + {p})) < W(Q)```\n```P_S + {p}```\n```Q_S + {q}```\n```pop()```\n```n!```\n```2^n```\n```W(P)\\u2264W(Q)```\n```q1```\n```q2```\n```Q```\n```W({q1}) \\u2264 W({q2})```\n```P```\n```{q1}```\n```Q```",
                "codeTag": "Unknown"
            },
            {
                "id": 670062,
                "title": "straightforward-c-solved-with-knapsack-algorithm",
                "content": "Based on the explanation from https://leetcode.com/problems/last-stone-weight-ii/discuss/298664/How-is-it-a-Knapsack-problem\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0, n = stones.size();\\n        for (auto s : stones) sum += s;\\n        int target = sum / 2;\\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                if (stones[i - 1] <= j)\\n                    dp[i][j] = max(dp[i - 1][j - stones[i - 1]] + stones[i - 1], dp[i - 1][j]);\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }\\n        }\\n        return sum - dp[n][target] - dp[n][target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = 0, n = stones.size();\\n        for (auto s : stones) sum += s;\\n        int target = sum / 2;\\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                if (stones[i - 1] <= j)\\n                    dp[i][j] = max(dp[i - 1][j - stones[i - 1]] + stones[i - 1], dp[i - 1][j]);\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }\\n        }\\n        return sum - dp[n][target] - dp[n][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 667324,
                "title": "python-2-approaches-dp-and-backtracking-detailed-explanation-and-thought-process",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        ## APPROACH : DP ##\\n        ## Similar to Leetcode : 416 Partition Equal Subset Sum ##\\n        \\n        ## LOGIC ##\\n        ## 1. On broader scope you have to find the combination where some stones are assigned + symbols and some stones are assigned - symbols and calculate total.\\n        ## 2. say you have 4 numbers, a,b,c,d lets say our correct answer is (a-d) - (b-c) implies ==> (a+c) - (b+d) ==> which we can put is as difference of 2 subsets in the array such that the difference is lowest possible(minimum)\\n        ## 3. Problem is now reduced to splitting of 2 groups whose difference is minimum.\\n        ## 4. For now let us assume we can equally divide into 2 subsets, so difference will be obvisouly 0. ( this can be solved by Leetcode 416.)\\n        ## 5. If we cannot divide it equally, then what is the maximum value which is close to target/2 ?? for example consider [2,5,5,7,11] total = 30, sum subet sum closest to 15 (i.e 29/2) is 14. so remaining subset will be 30 - 14 i.e 16. subset1 = 14, subset2 = 16, result = 16-14 = 2.\\n        ## 6. So we can try to divide into equal partitions, if we cannot , We find the maximum value closest to target//2 and get the subset2 value as total - subset1 and return the difference.\\n        \\n        nums = stones\\n        total = sum(nums)\\n        dp = [[ False for i in range((total//2)+1) ] for j in range(len(nums))]\\n        for i in range(len(nums)):\\n            for j in range((total//2) + 1):\\n                if(j == 0):\\n                    dp[i][j] = True         \\n                elif( j < nums[i] ):          \\n                    dp[i][j] = dp[i-1][j]\\n                elif(j == nums[i]):           \\n                    dp[i][j] = True\\n                elif( dp[i-1][j] == True or dp[i-1][j-nums[i]] == True):  \\n                    dp[i][j] = True\\n        \\n        # look the last row from backwards, to find the subset1\\n        for num in range(len(dp[-1])-1,-1,-1):\\n            if dp[-1][num]:\\n                subset1 = num\\n                subset2 = total - num\\n                return abs( subset1 - subset2 )\\n        \\n        ## APPROACH : BACKTRACKING ##\\n        def dfs(curr, remain, stones):\\n            if not stones or (curr,remain) in visited:\\n                return\\n            \\n            if( curr - remain > self.ans ):\\n                return\\n            \\n            if( curr - remain >= 0):\\n                self.ans = min( self.ans, curr - remain )\\n                \\n            visited.add((curr,remain))\\n            \\n            for i in range(len(stones)):\\n                dfs( curr + stones[i], total-(curr+stones[i]), stones[:i]+stones[i+1:] )\\n        \\n        visited = set()\\n        self.ans = float(\\'inf\\')\\n        total = sum(stones)\\n        dfs(0, total, stones)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        ## APPROACH : DP ##\\n        ## Similar to Leetcode : 416 Partition Equal Subset Sum ##\\n        \\n        ## LOGIC ##\\n        ## 1. On broader scope you have to find the combination where some stones are assigned + symbols and some stones are assigned - symbols and calculate total.\\n        ## 2. say you have 4 numbers, a,b,c,d lets say our correct answer is (a-d) - (b-c) implies ==> (a+c) - (b+d) ==> which we can put is as difference of 2 subsets in the array such that the difference is lowest possible(minimum)\\n        ## 3. Problem is now reduced to splitting of 2 groups whose difference is minimum.\\n        ## 4. For now let us assume we can equally divide into 2 subsets, so difference will be obvisouly 0. ( this can be solved by Leetcode 416.)\\n        ## 5. If we cannot divide it equally, then what is the maximum value which is close to target/2 ?? for example consider [2,5,5,7,11] total = 30, sum subet sum closest to 15 (i.e 29/2) is 14. so remaining subset will be 30 - 14 i.e 16. subset1 = 14, subset2 = 16, result = 16-14 = 2.\\n        ## 6. So we can try to divide into equal partitions, if we cannot , We find the maximum value closest to target//2 and get the subset2 value as total - subset1 and return the difference.\\n        \\n        nums = stones\\n        total = sum(nums)\\n        dp = [[ False for i in range((total//2)+1) ] for j in range(len(nums))]\\n        for i in range(len(nums)):\\n            for j in range((total//2) + 1):\\n                if(j == 0):\\n                    dp[i][j] = True         \\n                elif( j < nums[i] ):          \\n                    dp[i][j] = dp[i-1][j]\\n                elif(j == nums[i]):           \\n                    dp[i][j] = True\\n                elif( dp[i-1][j] == True or dp[i-1][j-nums[i]] == True):  \\n                    dp[i][j] = True\\n        \\n        # look the last row from backwards, to find the subset1\\n        for num in range(len(dp[-1])-1,-1,-1):\\n            if dp[-1][num]:\\n                subset1 = num\\n                subset2 = total - num\\n                return abs( subset1 - subset2 )\\n        \\n        ## APPROACH : BACKTRACKING ##\\n        def dfs(curr, remain, stones):\\n            if not stones or (curr,remain) in visited:\\n                return\\n            \\n            if( curr - remain > self.ans ):\\n                return\\n            \\n            if( curr - remain >= 0):\\n                self.ans = min( self.ans, curr - remain )\\n                \\n            visited.add((curr,remain))\\n            \\n            for i in range(len(stones)):\\n                dfs( curr + stones[i], total-(curr+stones[i]), stones[:i]+stones[i+1:] )\\n        \\n        visited = set()\\n        self.ans = float(\\'inf\\')\\n        total = sum(stones)\\n        dfs(0, total, stones)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642063,
                "title": "c-similar-to-minimum-difference-partition-of-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& a) {\\n        int s=0,i,n;\\n        for(int i:a) s+=i;\\n        n=s;\\n        s/=2;\\n        int dp[s+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[0]=1;\\n\\t    for(int i:a)\\n\\t\\t    for(int j=s;j>=i;j--) dp[j]=dp[j] or dp[j-i];\\n\\t    for(i=s;i>=0;i--)\\n            if(dp[i]) break;\\n        return n-2*i;\\n    }\\n};```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& a) {\\n        int s=0,i,n;\\n        for(int i:a) s+=i;\\n        n=s;\\n        s/=2;\\n        int dp[s+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[0]=1;\\n\\t    for(int i:a)\\n\\t\\t    for(int j=s;j>=i;j--) dp[j]=dp[j] or dp[j-i];\\n\\t    for(i=s;i>=0;i--)\\n            if(dp[i]) break;\\n        return n-2*i;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 621475,
                "title": "c-classical-0-1-knapsack-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII( vector<int>& stones ) {\\n        // Get total weight of all stones\\n        int totalWt=0;\\n        for( auto stoneWt : stones ) totalWt += stoneWt;\\n        \\n        // Divide all numbers into two groups,\\n        // minimum difference between the sum of two groups is the result\\n        \\n        /*\\n        0/1 Knapsack\\n        Possible items: 0,...,n-1 stones\\n        Possible Wt: 0,1,..., totalWt/2 */\\n        int n = stones.size();\\n        vector<vector<int>> dp( n+1, vector<int>( totalWt/2 + 1, 0 ) );\\n        for( int i=1; i<=n; i++ ) { // all items that can be picked\\n            for( int j=1; j <=totalWt/2; j++ ) {\\n                if( stones[i-1] > j ) // can\\'t pick this stone as wt > j\\n                    dp[i][j] = dp[i-1][j];\\n                else\\n                    dp[i][j] = max( dp[i-1][j], stones[i-1] + dp[i-1][j - stones[i-1]] );\\n            }\\n        }\\n        \\n        /* check the max possible wt */\\n        int maxWt = 0;\\n        for( int i=1; i<=n; i++ )\\n            if( dp[i][totalWt/2] > maxWt )\\n                maxWt = dp[i][totalWt/2];\\n        \\n        return totalWt - 2*maxWt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII( vector<int>& stones ) {\\n        // Get total weight of all stones\\n        int totalWt=0;\\n        for( auto stoneWt : stones ) totalWt += stoneWt;\\n        \\n        // Divide all numbers into two groups,\\n        // minimum difference between the sum of two groups is the result\\n        \\n        /*\\n        0/1 Knapsack\\n        Possible items: 0,...,n-1 stones\\n        Possible Wt: 0,1,..., totalWt/2 */\\n        int n = stones.size();\\n        vector<vector<int>> dp( n+1, vector<int>( totalWt/2 + 1, 0 ) );\\n        for( int i=1; i<=n; i++ ) { // all items that can be picked\\n            for( int j=1; j <=totalWt/2; j++ ) {\\n                if( stones[i-1] > j ) // can\\'t pick this stone as wt > j\\n                    dp[i][j] = dp[i-1][j];\\n                else\\n                    dp[i][j] = max( dp[i-1][j], stones[i-1] + dp[i-1][j - stones[i-1]] );\\n            }\\n        }\\n        \\n        /* check the max possible wt */\\n        int maxWt = 0;\\n        for( int i=1; i<=n; i++ )\\n            if( dp[i][totalWt/2] > maxWt )\\n                maxWt = dp[i][totalWt/2];\\n        \\n        return totalWt - 2*maxWt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619619,
                "title": "python-12ms-100-ile",
                "content": "The code is at the end; this problem confused me for an embarrassingly long time, so I want to talk about the \"trick\" first.\\n\\nAFAICT, this problem is very hard to solve if one approaches it on its own terms.  The \"trick\" to solving it is to realize that it\\'s really the optimization version of the [partition problem](https://en.wikipedia.org/wiki/Partition_problem) in disguise.  The final stone\\'s weight will always look something like w[0]+w[1]-w[2]+w[3]-w[4]...+w[n-1], where w[0],w[1],...,w[n-1] are the weights given in the problem.  This can be rearranged into a subtraction of one set of stones from their complement; minimizing this difference is a matter of making the two sets of stones as nearly equal in weight as possible.\\n\\nIt\\'s pretty clear that the answer to the problem can be no lower than such a minimized difference, but can such a minimized difference always be achieved?  Yes; the algorithm to do so is to order each set of stones by weight, and to smash the two lightest stones from each set together, replacing the heavier of the two stones with the product.\\n\\nThe optimization form of the parition problem is NP-hard, but the problem given is limited in size.  (In particular, there are at most 1500 sums of any interest.)  It\\'s amenable to either DP or recursion-with-memoization (brute-force is a little too slow), but I found the fastest approach was simple enumeration with a short-circuit:\\n\\n```\\ndef h7(a, g):\\n    available = set([0]); rv = 0\\n    for v in a:\\n        t = set(v+e for e in available if v+e <= g)\\n        if t: rv = max(rv, max(t))\\n        if rv == g: return rv\\n        available |= t\\n    return rv\\n```\\n\\nThe driver to use this is pretty simple:\\n```\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        t = sum(stones)\\n        m0 = h7(stones, t//2)\\n        return t-2*m0\\n```",
                "solutionTags": [],
                "code": "```\\ndef h7(a, g):\\n    available = set([0]); rv = 0\\n    for v in a:\\n        t = set(v+e for e in available if v+e <= g)\\n        if t: rv = max(rv, max(t))\\n        if rv == g: return rv\\n        available |= t\\n    return rv\\n```\n```\\nclass Solution(object):\\n    def lastStoneWeightII(self, stones):\\n        t = sum(stones)\\n        m0 = h7(stones, t//2)\\n        return t-2*m0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561732,
                "title": "very-easy-to-understand-top-down-dp",
                "content": "The idea is to realize that regardless of the order of rock \"match\", we will always end up with some sum = ra + rb + rc ... - rd - re - rf.....\\n```\\ndef lastStoneWeightII(self, stones: List[int]) -> int: \\n        from functools import lru_cache\\n        \\n        @lru_cache(None)\\n        def helper(ind, curr):\\n            if ind==len(stones):\\n                return abs(curr)\\n            \\n            return min(helper(ind+1, curr+stones[ind]), helper(ind+1, curr-stones[ind]))\\n        \\n        return helper(0, 0)\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "The idea is to realize that regardless of the order of rock \"match\", we will always end up with some sum = ra + rb + rc ... - rd - re - rf.....\\n```\\ndef lastStoneWeightII(self, stones: List[int]) -> int: \\n        from functools import lru_cache\\n        \\n        @lru_cache(None)\\n        def helper(ind, curr):\\n            if ind==len(stones):\\n                return abs(curr)\\n            \\n            return min(helper(ind+1, curr+stones[ind]), helper(ind+1, curr-stones[ind]))\\n        \\n        return helper(0, 0)\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 515364,
                "title": "python-solution-dp",
                "content": "the goal is to check if partial sums can be reached range from [min(stones), sum(stones)//2]\\n\\nthen to find the last possible partial sums and return abs(2*psum - total_sum)\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        start = min(stones)\\n        dp = [False] * (total//2 + 1)\\n        dp[0] = True\\n        for s in stones:\\n            for i in range(total//2, start-1, -1):\\n                if s<=i and dp[i-s]:\\n                    dp[i] = True\\n        # print(dp)\\n        for i in range(len(dp)-1, -1, -1):\\n            if dp[i]:\\n                return abs(2*i-total)\\n\\t",
                "solutionTags": [],
                "code": "the goal is to check if partial sums can be reached range from [min(stones), sum(stones)//2]\\n\\nthen to find the last possible partial sums and return abs(2*psum - total_sum)\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        start = min(stones)\\n        dp = [False] * (total//2 + 1)\\n        dp[0] = True\\n        for s in stones:\\n            for i in range(total//2, start-1, -1):\\n                if s<=i and dp[i-s]:\\n                    dp[i] = True\\n        # print(dp)\\n        for i in range(len(dp)-1, -1, -1):\\n            if dp[i]:\\n                return abs(2*i-total)\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 501310,
                "title": "clean-and-fast-python-with-explanation",
                "content": "The problem is the same as dividing the stones into two groups and make the group weight as equal as possible.\\nFind all possible weights that achievable from any combination of stones. \\nAll the possible weights are within [1, sum(stones)], inclusive.\\nUse a set to store achievable weights.\\nIterate stone s in stones and previous achievable weights pre, add pre + s to achievable set.\\nreturn min(abs(total -a*2) for a in achievable) as result.\\nThis is bottom up DP.\\nTime complexity: O(N*S), S is sum(stones)\\nSpace complexity: O(S)\\n\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        achievable = {0}\\n        for n in stones:\\n            new = set()\\n            for pre in achievable:\\n                new.add(n+pre)\\n            achievable |= new\\n        return min(abs(total -a*2) for a in achievable)\\n```\\n\\nA top down DP\\nDP[i,w] = True means from stones[0:i] we can get a sum of w.\\nDP[i, w] = DP[i-1, w] or DP[i-1, w-stone[i-1]]\\nLet target = sum(stones)//2, find DP[len(stones), target] == True or False.\\nIf True, return abs(sums(stones) - 2*target).\\nIf False, decrease target by one. and then find DP[len(stones), target].\\nTry the best case first, so if we got a True, we can return.\\nUse memorization to avoid repeat calculation.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        target = total//2\\n        mem = {(0,0):True}\\n        while target > 0:\\n            if self.DP(target, len(stones), stones, mem):\\n                return abs(total -2*target)\\n            target -= 1\\n        return total\\n    \\n    def DP(self, target, idx, stones, mem):\\n        if (idx, target) in mem:\\n            return mem[(idx, target)]\\n        good = False\\n        if idx > 0:\\n            good = self.DP(target, idx-1, stones, mem)\\n            if target >= stones[idx-1]:\\n                good = good or self.DP(target-stones[idx-1], idx-1, stones, mem)\\n        mem[(idx, target)] = good\\n        return good\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        achievable = {0}\\n        for n in stones:\\n            new = set()\\n            for pre in achievable:\\n                new.add(n+pre)\\n            achievable |= new\\n        return min(abs(total -a*2) for a in achievable)\\n```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        total = sum(stones)\\n        target = total//2\\n        mem = {(0,0):True}\\n        while target > 0:\\n            if self.DP(target, len(stones), stones, mem):\\n                return abs(total -2*target)\\n            target -= 1\\n        return total\\n    \\n    def DP(self, target, idx, stones, mem):\\n        if (idx, target) in mem:\\n            return mem[(idx, target)]\\n        good = False\\n        if idx > 0:\\n            good = self.DP(target, idx-1, stones, mem)\\n            if target >= stones[idx-1]:\\n                good = good or self.DP(target-stones[idx-1], idx-1, stones, mem)\\n        mem[(idx, target)] = good\\n        return good\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477560,
                "title": "simple-explanation-of-converting-problem-to-knapsack-problem",
                "content": "The problem boils down to: \\n\\n* How do you partition the elements into two sets to minimise the absolute difference\\n\\nWhich can be stated as a knapsack problem:\\n\\n* Given a collection of elements, for each element, select either {**e**,**-e**} in order to minimise the sum of the new collection.\\n\\nWe don\\'t care about properties of a reachable sum, just whether it\\'s reachable, so we can use a HashSet\\n\\n```csharp\\npublic int LastStoneWeightII(int[] stones) \\n{\\n\\tHashSet<int> a = new HashSet<int>(new[] { 0 });\\n\\tforeach(var num in stones)\\n\\t{\\n\\t\\tvar next = new HashSet<int>();\\n\\n\\t\\tforeach(var k in a.ToList())\\n\\t\\t{\\n\\t\\t\\tnext.Add(k - num);\\n\\t\\t\\tnext.Add(k + num);\\n\\t\\t}\\n\\t\\ta = next;\\n\\t}\\n\\treturn a.Select(Math.Abs).Min();\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```csharp\\npublic int LastStoneWeightII(int[] stones) \\n{\\n\\tHashSet<int> a = new HashSet<int>(new[] { 0 });\\n\\tforeach(var num in stones)\\n\\t{\\n\\t\\tvar next = new HashSet<int>();\\n\\n\\t\\tforeach(var k in a.ToList())\\n\\t\\t{\\n\\t\\t\\tnext.Add(k - num);\\n\\t\\t\\tnext.Add(k + num);\\n\\t\\t}\\n\\t\\ta = next;\\n\\t}\\n\\treturn a.Select(Math.Abs).Min();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 397862,
                "title": "java-top-down-dp-easy-to-undestand-3-ms",
                "content": "There are other posts that which explain why this becomes a knapsack problem which is about dividing the stones into 2 groups which have the minimum amount of difference between them.\\nI couldn\\'t find any top down dp solutions so here it is. I think personally top down is much more intuitive.\\n```\\nclass Solution {\\n    int total;\\n    Integer[][] memo;\\n    Deque<Integer> stoneDeq;\\n    public int lastStoneWeightII(int[] stones) {\\n        if (stones == null || stones.length == 0) return 0;\\n        total = 0;\\n        stoneDeq = new ArrayDeque<>(stones.length);\\n        for (int stone : stones) {\\n            total += stone;\\n            stoneDeq.add(stone);\\n        }\\n        memo = new Integer[total + 1][stones.length + 1];\\n        return topDown(0);\\n    }\\n    private int topDown(int sum) {\\n        if (stoneDeq.size() == 0) return Math.abs(sum - (total - sum));\\n        if (memo[sum][stoneDeq.size()] != null) return memo[sum][stoneDeq.size()];\\n\\n        int curVal = stoneDeq.pop(); // process from head\\n\\n        int mergeCurSum = topDown(sum + curVal);\\n        int dontMergeCurSum = topDown(sum);\\n        int minSum = Math.min(mergeCurSum, dontMergeCurSum);\\n\\n        // doesn\\'t matter whether we put back to head or tail but tail seems to run faster\\n        // not sure why if any can explain would really appreciate\\n        stoneDeq.add(curVal);\\n\\n        return memo[sum][stoneDeq.size()] = minSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int total;\\n    Integer[][] memo;\\n    Deque<Integer> stoneDeq;\\n    public int lastStoneWeightII(int[] stones) {\\n        if (stones == null || stones.length == 0) return 0;\\n        total = 0;\\n        stoneDeq = new ArrayDeque<>(stones.length);\\n        for (int stone : stones) {\\n            total += stone;\\n            stoneDeq.add(stone);\\n        }\\n        memo = new Integer[total + 1][stones.length + 1];\\n        return topDown(0);\\n    }\\n    private int topDown(int sum) {\\n        if (stoneDeq.size() == 0) return Math.abs(sum - (total - sum));\\n        if (memo[sum][stoneDeq.size()] != null) return memo[sum][stoneDeq.size()];\\n\\n        int curVal = stoneDeq.pop(); // process from head\\n\\n        int mergeCurSum = topDown(sum + curVal);\\n        int dontMergeCurSum = topDown(sum);\\n        int minSum = Math.min(mergeCurSum, dontMergeCurSum);\\n\\n        // doesn\\'t matter whether we put back to head or tail but tail seems to run faster\\n        // not sure why if any can explain would really appreciate\\n        stoneDeq.add(curVal);\\n\\n        return memo[sum][stoneDeq.size()] = minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375492,
                "title": "ruby-dp-solution",
                "content": "```Ruby\\n# @param {Integer[]} stones\\n# @return {Integer}\\ndef last_stone_weight_ii(stones)\\n  stones_sum = stones.reduce(:+)\\n  target_sum = stones_sum / 2\\n  dp = Array.new(target_sum + 1, 0)\\n  stones.each do |stone|\\n    target_sum.step(stone, -1).each do |i|\\n      dp[i] = [dp[i], dp[i - stone] + stone].max\\n    end\\n  end\\n  stones_sum - dp[target_sum] * 2\\nend\\n```",
                "solutionTags": [],
                "code": "```Ruby\\n# @param {Integer[]} stones\\n# @return {Integer}\\ndef last_stone_weight_ii(stones)\\n  stones_sum = stones.reduce(:+)\\n  target_sum = stones_sum / 2\\n  dp = Array.new(target_sum + 1, 0)\\n  stones.each do |stone|\\n    target_sum.step(stone, -1).each do |i|\\n      dp[i] = [dp[i], dp[i - stone] + stone].max\\n    end\\n  end\\n  stones_sum - dp[target_sum] * 2\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 331803,
                "title": "c-100-runtime-memory-dp-solution",
                "content": "The idea is to partition the array into two parts with sum of each subsets as close to totalSum/2 to minimize the difference. Also we need to only go till sum/2 as the sum of the other subset will be totalSum - sum of subset1. Then we just see which is the closest sum possible of subset1 and return totalSum-2*possibleSum\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int sum = 0;\\n        for (int i = 0; i < stones.size(); i++) {\\n            sum += stones[i];\\n        }\\n        bool dp[31][3100];\\n        for (int i = 0; i < stones.size(); i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i < sum/2; i++) {\\n            dp[0][i] = false;\\n        }\\n        \\n        for (int i = 1; i < stones.size()+1; i++) {\\n            for (int j = 1; j <= sum/2; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (stones[i-1] <= j) {\\n                    dp[i][j] |= dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        \\n        \\n        int ans = 0;\\n        for (int j = sum/2; j >=0; j--) {\\n            if (dp[stones.size()][j]) {\\n                ans = (sum - 2*j);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        \\n        int sum = 0;\\n        for (int i = 0; i < stones.size(); i++) {\\n            sum += stones[i];\\n        }\\n        bool dp[31][3100];\\n        for (int i = 0; i < stones.size(); i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i < sum/2; i++) {\\n            dp[0][i] = false;\\n        }\\n        \\n        for (int i = 1; i < stones.size()+1; i++) {\\n            for (int j = 1; j <= sum/2; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (stones[i-1] <= j) {\\n                    dp[i][j] |= dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        \\n        \\n        int ans = 0;\\n        for (int j = sum/2; j >=0; j--) {\\n            if (dp[stones.size()][j]) {\\n                ans = (sum - 2*j);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310915,
                "title": "very-simple-to-understand-solution",
                "content": "The following solution is very simple to understand but it will fail because we do a lot of re-computations:\\n1. When you visit a number, you have two options. You can either add a +ve sign to it or a -ve sign to it.\\n2. The decision is based on whichever gives you a value that is closer to 0.\\n\\n```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        return solve(stones, 0, 0);\\n    }\\n    \\n    private int solve(int[] stones, int i, int sum) {\\n        if(i == stones.length) {\\n            return sum;\\n        }\\n        \\n        return Math.min(Math.abs(solve(stones, i+1, sum+stones[i])-0), \\n                        Math.abs(solve(stones, i+1, sum-stones[i])-0));\\n    }\\n}\\n```\\n\\nThe following solution does exactly the things described above but adds memoization on top of it so that we can avoid the re-computations.\\n```\\nclass Solution {\\n    Map<Integer, Map<Integer,Integer>> map = new HashMap<Integer, Map<Integer,Integer>>();\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        return solve(stones, 0, 0);\\n    }\\n    \\n    private int solve(int[] stones, int i, int sum) {\\n        if(i == stones.length) {\\n            return sum;\\n        }\\n        \\n        if(map.containsKey(i) && map.get(i).containsKey(sum)) return map.get(i).get(sum);\\n        \\n        int val = Math.min(Math.abs(solve(stones, i+1, sum+stones[i])-0), \\n                        Math.abs(solve(stones, i+1, sum-stones[i])-0));\\n        Map<Integer, Integer> subMap = map.getOrDefault(i, new HashMap<Integer, Integer>());\\n        subMap.put(sum, val);\\n        map.put(i, subMap);\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        return solve(stones, 0, 0);\\n    }\\n    \\n    private int solve(int[] stones, int i, int sum) {\\n        if(i == stones.length) {\\n            return sum;\\n        }\\n        \\n        return Math.min(Math.abs(solve(stones, i+1, sum+stones[i])-0), \\n                        Math.abs(solve(stones, i+1, sum-stones[i])-0));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer, Map<Integer,Integer>> map = new HashMap<Integer, Map<Integer,Integer>>();\\n    \\n    public int lastStoneWeightII(int[] stones) {\\n        return solve(stones, 0, 0);\\n    }\\n    \\n    private int solve(int[] stones, int i, int sum) {\\n        if(i == stones.length) {\\n            return sum;\\n        }\\n        \\n        if(map.containsKey(i) && map.get(i).containsKey(sum)) return map.get(i).get(sum);\\n        \\n        int val = Math.min(Math.abs(solve(stones, i+1, sum+stones[i])-0), \\n                        Math.abs(solve(stones, i+1, sum-stones[i])-0));\\n        Map<Integer, Integer> subMap = map.getOrDefault(i, new HashMap<Integer, Integer>());\\n        subMap.put(sum, val);\\n        map.put(i, subMap);\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306815,
                "title": "python-knapsack-simple-solution-using-recursion-memoization",
                "content": "```\\ndef lastStoneWeightII(self, stones):        \\n\\tdef maximize(i, space_left):\\n\\t\\tif (i, space_left) in memory:\\n\\t\\t\\treturn memory[i, space_left]\\n\\t\\telif i == len(stones) or space_left == 0:\\n\\t\\t\\treturn 0\\n\\t\\telif space_left < stones[i]:\\n\\t\\t\\treturn maximize(i+1, space_left)\\n\\t\\telse:\\n\\t\\t\\ttake_stone_i = stones[i] + maximize(i+1, space_left-stones[i])\\n\\t\\t\\tnot_take_stone_i = maximize(i+1, space_left)\\n\\t\\t\\tmax_sum_i = max(take_stone_i, not_take_stone_i)\\n\\t\\t\\tmemory[i, space_left] = max_sum_i\\n\\t\\t\\treturn max_sum_i\\n\\tmemory = {}\\n\\t# Fill up the knapsack of size floor(sum(stones)/2) as fully as possible\\n\\tmax_sum = maximize(0, sum(stones) / 2)\\n\\treturn sum(stones)-2*max_sum\\n```",
                "solutionTags": [],
                "code": "```\\ndef lastStoneWeightII(self, stones):        \\n\\tdef maximize(i, space_left):\\n\\t\\tif (i, space_left) in memory:\\n\\t\\t\\treturn memory[i, space_left]\\n\\t\\telif i == len(stones) or space_left == 0:\\n\\t\\t\\treturn 0\\n\\t\\telif space_left < stones[i]:\\n\\t\\t\\treturn maximize(i+1, space_left)\\n\\t\\telse:\\n\\t\\t\\ttake_stone_i = stones[i] + maximize(i+1, space_left-stones[i])\\n\\t\\t\\tnot_take_stone_i = maximize(i+1, space_left)\\n\\t\\t\\tmax_sum_i = max(take_stone_i, not_take_stone_i)\\n\\t\\t\\tmemory[i, space_left] = max_sum_i\\n\\t\\t\\treturn max_sum_i\\n\\tmemory = {}\\n\\t# Fill up the knapsack of size floor(sum(stones)/2) as fully as possible\\n\\tmax_sum = maximize(0, sum(stones) / 2)\\n\\treturn sum(stones)-2*max_sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 295743,
                "title": "c-dp-solution-based-on-hints",
                "content": "```\\npublic int LastStoneWeightII(int[] stones) {\\n        var sums = new HashSet<int>();\\n\\t\\tsums.Add(0);\\n\\t\\t\\n\\t\\tforeach (var stone in stones) {\\n\\t\\t\\tvar nextSums = new HashSet<int>();\\t\\t\\t\\n\\t\\t\\tforeach (var s in sums) {\\n\\t\\t\\t\\tif (!nextSums.Contains(s+stone)) {\\n\\t\\t\\t\\t\\tnextSums.Add(s+stone);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!nextSums.Contains(s-stone)) {\\n\\t\\t\\t\\t\\tnextSums.Add(s-stone);\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tsums = nextSums;\\n\\t\\t}\\t\\t\\n\\t\\t\\n\\t\\treturn sums.Where(s => s>=0).Min();\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int LastStoneWeightII(int[] stones) {\\n        var sums = new HashSet<int>();\\n\\t\\tsums.Add(0);\\n\\t\\t\\n\\t\\tforeach (var stone in stones) {\\n\\t\\t\\tvar nextSums = new HashSet<int>();\\t\\t\\t\\n\\t\\t\\tforeach (var s in sums) {\\n\\t\\t\\t\\tif (!nextSums.Contains(s+stone)) {\\n\\t\\t\\t\\t\\tnextSums.Add(s+stone);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!nextSums.Contains(s-stone)) {\\n\\t\\t\\t\\t\\tnextSums.Add(s-stone);\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tsums = nextSums;\\n\\t\\t}\\t\\t\\n\\t\\t\\n\\t\\treturn sums.Where(s => s>=0).Min();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 295621,
                "title": "c-dp-balanced-partition-problem-beats-100",
                "content": "Problem can be modified into another problem: **Partition the weights into 2 subsets such that the sum of the 2 subsets are as close to each other as possible**\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        if (stones.empty())\\n            return 0;\\n        \\n        int sum = 0;\\n        for (int n : stones) sum += n;\\n        int target = sum / 2;\\n        bool dp[target + 1] = {false};\\n        dp[0] = true;\\n        for (int n : stones) {\\n            for (int j = target; j >= n; j--)\\n                dp[j] = dp[j] || dp[j - n];\\n        }\\n        for (int i = target; i > 0; i--) {\\n            if (dp[i])\\n                return abs(sum - 2*i);\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Complexity:** `O(nS)` time, `O(S)` space (`S` = sum of all weights)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        if (stones.empty())\\n            return 0;\\n        \\n        int sum = 0;\\n        for (int n : stones) sum += n;\\n        int target = sum / 2;\\n        bool dp[target + 1] = {false};\\n        dp[0] = true;\\n        for (int n : stones) {\\n            for (int j = target; j >= n; j--)\\n                dp[j] = dp[j] || dp[j - n];\\n        }\\n        for (int i = target; i > 0; i--) {\\n            if (dp[i])\\n                return abs(sum - 2*i);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294999,
                "title": "c-convert-to-assignment",
                "content": "Change the problem to be +/- (coin change) problem.\\nTop down with memoization.\\nSince we want to get the final min residue (non-negative), we just take the min of abs() on each recursion returns.\\n\\n```\\nclass Solution {\\n  vector<unordered_map<int, int>> memo_;\\n  \\npublic:\\n  int lastStoneWeightII(vector<int>& stones) {\\n    memo_.resize(50);\\n    return doDFS(stones, 0, 0);\\n  }\\n  \\n  int doDFS(vector<int>& stones, int idx, int curSum) {\\n    if(idx == stones.size()) return curSum;\\n    if(memo_[idx].count(curSum)) return memo_[idx][curSum];\\n    \\n    return memo_[idx][curSum] =  min(abs(doDFS(stones, idx+1, curSum+stones[idx])), \\n                                     abs(doDFS(stones, idx+1, curSum-stones[idx])));\\n  }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  vector<unordered_map<int, int>> memo_;\\n  \\npublic:\\n  int lastStoneWeightII(vector<int>& stones) {\\n    memo_.resize(50);\\n    return doDFS(stones, 0, 0);\\n  }\\n  \\n  int doDFS(vector<int>& stones, int idx, int curSum) {\\n    if(idx == stones.size()) return curSum;\\n    if(memo_[idx].count(curSum)) return memo_[idx][curSum];\\n    \\n    return memo_[idx][curSum] =  min(abs(doDFS(stones, idx+1, curSum+stones[idx])), \\n                                     abs(doDFS(stones, idx+1, curSum-stones[idx])));\\n  }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294979,
                "title": "based-on-question-40",
                "content": "This question can be intepreted as the follwoing: Take any two rocks x and y, chang their values to 0 and ```y-x```. What is the smallest possible remaining non-zero value? \\nObviously this is asking us to split the list into two, with sum of each sublists as close as possible. \\nSo we calculate the sum, and get half of it, let ```half``` be either sum/2 or (sum-1)/2.\\nReduce  ```half``` from its original value down to 1. During this process, if we find a possible way get ```half``` from these stones, we easily know it\\'s possible to divide all stones into two sublists with sum of the first list = ```half``` and sum of the second one = ```sum - half```. Then the difference becomes ```sum - half - half```. \\n\\n// Note I have to modify my solution for Q40 a little bit to avoid TLE. Q40 wants ALL possible ways to get to target number. And here I want to return as soon as I find ONE way to get to target number ```half```\\n\\n```\\npublic int lastStoneWeightII(int[] stones) {\\n        if (stones == null || stones.length < 1) return 0;\\n        int sum = 0;\\n        for(int i : stones)\\n            sum += i;\\n        Arrays.sort(stones);\\n        \\n        int half = 0;\\n        if (sum % 2 == 0) {\\n            half = sum / 2;\\n        } else {\\n            half = (sum - 1) / 2;\\n        }\\n        for (int test = half; test > 0; test--) {\\n            if (findSum(stones, test)) {\\n                return sum - 2 * test;\\n            } else {\\n                \\n            }\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    private boolean findSum(int[] stones, int target) {\\n        List<List<Integer>> result = combinationSum2(stones, target);\\n        if (result.size() > 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    // See Q40\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        // if (candidates == null || candidates.length == 0)\\n        //     return result;\\n        \\n        // Arrays.sort(candidates);\\n        int len = candidates.length;\\n        if (target < candidates[0]) // all positive\\n            return result;\\n        \\n        List<Integer> tuple = new ArrayList<>();\\n        int startIndex = 0;\\n        backtrack(result, tuple, candidates, startIndex, 0, target);\\n        \\n        return result;\\n    }\\n    \\n    boolean backtrack(List<List<Integer>> res, List<Integer> tuple, int[] cand, int index, int sum, int target) {\\n        if (sum == target) {\\n            List<Integer> temp = new ArrayList<>(tuple);\\n            res.add(temp);\\n            return true;\\n        } else if (sum > target) {\\n            // simply step back\\n            // System.out.println(\"exclude \" + tuple);\\n            return false;\\n        } else {\\n            // do normal backtracking\\n            for (int j = index; j < cand.length; j++) {\\n                \\n                // example [1,1,2,5,6,7,10], 8\\n                // 1,1,6 should be good, \\n                // first 1,2,5 is good, \\n                // second 1,2,5 is NOT good\\n                \\n                if (j != index && cand[j] == cand[j - 1])\\n                    continue; // skip duplicates\\n                \\n                tuple.add(cand[j]);\\n                \\n                if (backtrack(res, tuple, cand, j + 1, sum + cand[j], target)) {\\n                    return true;\\n                }\\n                \\n                tuple.remove(tuple.size() - 1);\\n            }\\n            return false;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```y-x```\n```half```\n```half```\n```half```\n```half```\n```sum - half```\n```sum - half - half```\n```half```\n```\\npublic int lastStoneWeightII(int[] stones) {\\n        if (stones == null || stones.length < 1) return 0;\\n        int sum = 0;\\n        for(int i : stones)\\n            sum += i;\\n        Arrays.sort(stones);\\n        \\n        int half = 0;\\n        if (sum % 2 == 0) {\\n            half = sum / 2;\\n        } else {\\n            half = (sum - 1) / 2;\\n        }\\n        for (int test = half; test > 0; test--) {\\n            if (findSum(stones, test)) {\\n                return sum - 2 * test;\\n            } else {\\n                \\n            }\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    private boolean findSum(int[] stones, int target) {\\n        List<List<Integer>> result = combinationSum2(stones, target);\\n        if (result.size() > 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    // See Q40\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        // if (candidates == null || candidates.length == 0)\\n        //     return result;\\n        \\n        // Arrays.sort(candidates);\\n        int len = candidates.length;\\n        if (target < candidates[0]) // all positive\\n            return result;\\n        \\n        List<Integer> tuple = new ArrayList<>();\\n        int startIndex = 0;\\n        backtrack(result, tuple, candidates, startIndex, 0, target);\\n        \\n        return result;\\n    }\\n    \\n    boolean backtrack(List<List<Integer>> res, List<Integer> tuple, int[] cand, int index, int sum, int target) {\\n        if (sum == target) {\\n            List<Integer> temp = new ArrayList<>(tuple);\\n            res.add(temp);\\n            return true;\\n        } else if (sum > target) {\\n            // simply step back\\n            // System.out.println(\"exclude \" + tuple);\\n            return false;\\n        } else {\\n            // do normal backtracking\\n            for (int j = index; j < cand.length; j++) {\\n                \\n                // example [1,1,2,5,6,7,10], 8\\n                // 1,1,6 should be good, \\n                // first 1,2,5 is good, \\n                // second 1,2,5 is NOT good\\n                \\n                if (j != index && cand[j] == cand[j - 1])\\n                    continue; // skip duplicates\\n                \\n                tuple.add(cand[j]);\\n                \\n                if (backtrack(res, tuple, cand, j + 1, sum + cand[j], target)) {\\n                    return true;\\n                }\\n                \\n                tuple.remove(tuple.size() - 1);\\n            }\\n            return false;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294906,
                "title": "variant-of-956-tallest-billboard-time-o-ns-python-dp-with-explanation",
                "content": "The question is equivilant to: Divide the stoens into two groups. Calculate the total weight of each group. Try to make the two groups\\' weights as closer as possible.\\n\\nThis question is a variant of https://leetcode.com/problems/tallest-billboard/\\n\\n`dp(i, diff)` is a boolean value. It means whether using stons[0...i] (inclusive) can crash and results a remaining stone of weight `diff`. Both `i` and `diff` are non-negative numbers.\\n\\nThen search for `possible_result` from 0 increasingly. find the first `possible_result` such that `dp(n - 1, possible_result)` is true.\\n\\nThe time and space complexity are `O(NS)` where `S <= sum(stones)`\\n\\n```\\nimport functools\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n\\n        @functools.lru_cache(None)\\n        def dp(i, diff):\\n            if i == 0:\\n                return diff == stones[0]\\n            return dp(i - 1, abs(diff - stones[i])) or dp(i - 1, diff + stones[i])\\n\\n        for possible_diff in range(max(stones) + 1):\\n            if dp(len(stones) - 1, possible_diff):\\n                return possible_diff\\n        assert(0)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n\\n        @functools.lru_cache(None)\\n        def dp(i, diff):\\n            if i == 0:\\n                return diff == stones[0]\\n            return dp(i - 1, abs(diff - stones[i])) or dp(i - 1, diff + stones[i])\\n\\n        for possible_diff in range(max(stones) + 1):\\n            if dp(len(stones) - 1, possible_diff):\\n                return possible_diff\\n        assert(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800369,
                "title": "how-i-approched-3d-dp-2d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNormally just make two variables s1 and s2 two store sum of individual subsets. \\nDo a proper knapsack by taking an element and by not taking it.\\nIt will give you a mle.\\n\\nTo make it working switch to 2d one by eliminating the s2 variable by calculating the total sum of the array and thus using it to calculate the s2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nfor 1. \\nO(n*s*s)\\nFor 2.\\nO(n*s)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solve(int i, int s1, int s2, vector<int>& nums,vector<vector<vector<int>>>&dp){\\n    if(i==nums.size()) return abs(s1-s2);\\n    if(dp[i][s1][s2]!=-1) return dp[i][s1][s2];\\n\\n    int take=solve(i+1, s1+nums[i], s2,nums, dp);\\n    int nottake=solve(i+1, s1, s2+nums[i], nums,dp);\\n    return dp[i][s1][s2]=min(take,nottake);\\n}\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n= stones.size();\\n       int sum= accumulate(stones.begin(), stones.end(), 0);\\n        //memset(dp,-1, sizeof(dp));\\n        vector<vector<vector<int>>>dp(n+1, vector<vector<int>>(sum+1,vector<int>(sum+1,-1)));\\n        return solve(0,0,0, stones,dp);\\n    }\\n};\\nWORKING SOLUTION\\n---------------------------------------------------------------------\\nclass Solution {\\npublic:\\nint dp[31][3001];\\nint mini(vector<int>&nums,int i,int n, int subsetsum, int sum){\\n      if(i==n) return abs(sum-2*subsetsum);\\n      if(dp[i][subsetsum]!=-1) return dp[i][subsetsum];\\n      int ans=0;\\n      ans=min(mini(nums,i+1,n, subsetsum+nums[i],sum),mini(nums,i+1,n,subsetsum,sum));\\n      return dp[i][subsetsum]=ans;\\n  }\\n    int lastStoneWeightII(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        int sum=0;\\n        for(int x: nums){\\n            sum+=x;\\n        }\\n        int n=nums.size();\\n        return mini(nums,0,n,0,sum);\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint solve(int i, int s1, int s2, vector<int>& nums,vector<vector<vector<int>>>&dp){\\n    if(i==nums.size()) return abs(s1-s2);\\n    if(dp[i][s1][s2]!=-1) return dp[i][s1][s2];\\n\\n    int take=solve(i+1, s1+nums[i], s2,nums, dp);\\n    int nottake=solve(i+1, s1, s2+nums[i], nums,dp);\\n    return dp[i][s1][s2]=min(take,nottake);\\n}\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n= stones.size();\\n       int sum= accumulate(stones.begin(), stones.end(), 0);\\n        //memset(dp,-1, sizeof(dp));\\n        vector<vector<vector<int>>>dp(n+1, vector<vector<int>>(sum+1,vector<int>(sum+1,-1)));\\n        return solve(0,0,0, stones,dp);\\n    }\\n};\\nWORKING SOLUTION\\n---------------------------------------------------------------------\\nclass Solution {\\npublic:\\nint dp[31][3001];\\nint mini(vector<int>&nums,int i,int n, int subsetsum, int sum){\\n      if(i==n) return abs(sum-2*subsetsum);\\n      if(dp[i][subsetsum]!=-1) return dp[i][subsetsum];\\n      int ans=0;\\n      ans=min(mini(nums,i+1,n, subsetsum+nums[i],sum),mini(nums,i+1,n,subsetsum,sum));\\n      return dp[i][subsetsum]=ans;\\n  }\\n    int lastStoneWeightII(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        int sum=0;\\n        for(int x: nums){\\n            sum+=x;\\n        }\\n        int n=nums.size();\\n        return mini(nums,0,n,0,sum);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550854,
                "title": "c-unique-solution-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    unordered_set<int> helper(vector<int>& stones,int i,int j){\\n        if(j>i){\\n            if(j==i+1){\\n                return {abs(stones[j]-stones[i]),stones[j]+stones[i]};\\n            }\\n            int mid=(i+j)/2;\\n            unordered_set<int> p1=helper(stones,i,mid);\\n            unordered_set<int> p2=helper(stones,mid+1,j);\\n            unordered_set<int> ans;\\n            int maxi=0;\\n            for(int num1:p1){\\n                for(int num2:p2){\\n                    ans.insert(num1+num2);\\n                    ans.insert(abs(num1-num2));\\n                }\\n            }\\n            return ans;\\n        }\\n        return {stones[i]};\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> ans=helper(stones,0,stones.size()-1);\\n        int sol=INT_MAX;\\n        for(int num:ans)sol=min(sol,num);\\n        return sol;\\n    }\\n};\\n// [89,23,100,93,82,98,91,85,33,95,72,98,63,46,17,91,92,72,77,79,99,96,55,72,24,98,79,93,88,92]\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> helper(vector<int>& stones,int i,int j){\\n        if(j>i){\\n            if(j==i+1){\\n                return {abs(stones[j]-stones[i]),stones[j]+stones[i]};\\n            }\\n            int mid=(i+j)/2;\\n            unordered_set<int> p1=helper(stones,i,mid);\\n            unordered_set<int> p2=helper(stones,mid+1,j);\\n            unordered_set<int> ans;\\n            int maxi=0;\\n            for(int num1:p1){\\n                for(int num2:p2){\\n                    ans.insert(num1+num2);\\n                    ans.insert(abs(num1-num2));\\n                }\\n            }\\n            return ans;\\n        }\\n        return {stones[i]};\\n    }\\n    int lastStoneWeightII(vector<int>& stones) {\\n        unordered_set<int> ans=helper(stones,0,stones.size()-1);\\n        int sol=INT_MAX;\\n        for(int num:ans)sol=min(sol,num);\\n        return sol;\\n    }\\n};\\n// [89,23,100,93,82,98,91,85,33,95,72,98,63,46,17,91,92,72,77,79,99,96,55,72,24,98,79,93,88,92]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146270,
                "title": "knapsack-bottom-up-dp-c",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int knapsack(vector<int> &wt, int w, int n)\\n    {\\n        int dp[n+1][w+1];\\n        for (int i=0; i<=n; i++)\\n        {\\n            for (int j=0; j<=w; j++)\\n            {\\n                if(i==0 || j==0) dp[i][j]=0;\\n                else if (wt[i - 1] <= j)\\n                {\\n                    int val1=wt[i-1]+dp[i-1][j-wt[i-1]];\\n                    int val2=dp[i-1][j];\\n                    dp[i][j]=max(val1,val2);\\n                }\\n                else if(wt[i-1]>j) dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[n][w];\\n    }\\n    int lastStoneWeightII(vector<int> &stones)\\n    {\\n        int sum = 0, n=stones.size();\\n        for (auto stone : stones) sum += stone;\\n        return sum-2*knapsack(stones,sum/2,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int knapsack(vector<int> &wt, int w, int n)\\n    {\\n        int dp[n+1][w+1];\\n        for (int i=0; i<=n; i++)\\n        {\\n            for (int j=0; j<=w; j++)\\n            {\\n                if(i==0 || j==0) dp[i][j]=0;\\n                else if (wt[i - 1] <= j)\\n                {\\n                    int val1=wt[i-1]+dp[i-1][j-wt[i-1]];\\n                    int val2=dp[i-1][j];\\n                    dp[i][j]=max(val1,val2);\\n                }\\n                else if(wt[i-1]>j) dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[n][w];\\n    }\\n    int lastStoneWeightII(vector<int> &stones)\\n    {\\n        int sum = 0, n=stones.size();\\n        for (auto stone : stones) sum += stone;\\n        return sum-2*knapsack(stones,sum/2,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444405,
                "title": "easy-c-solution",
                "content": "[![image](https://assets.leetcode.com/users/images/032dafef-ee91-467f-b2d9-8eedfc7d1380_1660825349.0208166.jpeg)\\n![image](https://assets.leetcode.com/users/images/a8102f3b-2fc7-4b68-aabe-1c87849ecfa8_1660825372.8207896.jpeg)\\n\\nFor the Detailed explanation of the code see the video of \"minimum subset sum difference\" problem.\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(auto i:stones) s+=i;\\n        bool dp[n+1][s+1];\\n        for(int i=0;i<=s;i++) dp[0][i]=false;\\n        for(int i=0;i<=n;i++)\\n        {\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=s;j++)\\n            {\\n                if(stones[i-1]>j) dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n            }\\n        }\\n        int mi=INT_MAX;\\n        for(int i=0;i<=s;i++)\\n        {\\n            if(dp[n][i]==true)\\n            {\\n                mi=min(mi,abs(s-2*i));\\n            }\\n        }\\n        return mi;\\n    }\\n};\\n\\n\\n````\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int n=stones.size();\\n        int s=0;\\n        for(auto i:stones) s+=i;\\n        bool dp[n+1][s+1];\\n        for(int i=0;i<=s;i++) dp[0][i]=false;\\n        for(int i=0;i<=n;i++)\\n        {\\n            dp[i][0]=true;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=s;j++)\\n            {\\n                if(stones[i-1]>j) dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n            }\\n        }\\n        int mi=INT_MAX;\\n        for(int i=0;i<=s;i++)\\n        {\\n            if(dp[n][i]==true)\\n            {\\n                mi=min(mi,abs(s-2*i));\\n            }\\n        }\\n        return mi;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424787,
                "title": "c-similar-to-equal-sum-partition",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n       \\n        int n = stones.size();\\n        int sum = 0;\\n        for(int i = 0;i<n;i++){\\n            sum = sum + stones[i];\\n           \\n        }\\n         int dp[n+1][sum/2+1];\\n        dp[0][0] = 1;\\n        for(int i = 1;i<=n;i++){\\n            dp[i][0] = 1;\\n        }\\n        for(int j = 1;j<=sum/2+1;j++){\\n            dp[0][j] = 0;\\n        }\\n        \\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=sum/2;j++){\\n                dp[i][j] = dp[i-1][j];\\n                if(stones[i-1]<=j){\\n                    dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int j = sum/2;j>=0;j--){\\n            if(dp[n][j]){\\n            ans = min(ans,sum-2*j);\\n\\t\\t\\treturn ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n       \\n        int n = stones.size();\\n        int sum = 0;\\n        for(int i = 0;i<n;i++){\\n            sum = sum + stones[i];\\n           \\n        }\\n         int dp[n+1][sum/2+1];\\n        dp[0][0] = 1;\\n        for(int i = 1;i<=n;i++){\\n            dp[i][0] = 1;\\n        }\\n        for(int j = 1;j<=sum/2+1;j++){\\n            dp[0][j] = 0;\\n        }\\n        \\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=sum/2;j++){\\n                dp[i][j] = dp[i-1][j];\\n                if(stones[i-1]<=j){\\n                    dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int j = sum/2;j>=0;j--){\\n            if(dp[n][j]){\\n            ans = min(ans,sum-2*j);\\n\\t\\t\\treturn ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382121,
                "title": "python-dp-solution-with-explanation-0-1-knapsack-problem",
                "content": "the problem can be transfer to spliting the ```stones``` and making difference of the two subset\\'s sum is smallest.\\n\\nex. stones =```[2,7,4,1,8,1]```\\nthere have two sets, namely addition and substraction\\n```1 = (4-2)-(8-7)-1+1```\\nit mean when two stones combine together, and if there have a remain stone after combine together, the remain stone will combine again, and we can add plus sign or minus sign to remain stone, it mean that the set where the two original stones are located is exchanged if we use minus sign\\n\\n```\\nsum(A) + sum(B) = sum(stones)\\nsum(A) - sum(B) = diff, diff >= 0\\n\\n2 * sum(B) = sum(stones) - diff\\ndiff = sum(stones) - 2 * sum(B)\\nminimize diff to 0\\nsum(stones) - 2 * sum(B) >= 0\\nsum(B) as close to the half of sum(stones) as possible \\n```\\n\\nthe problem is similar to [494. target sum solution](https://leetcode.com/problems/target-sum/discuss/2377796/python-dp-and-top-down-solution-with-explanation), it also is 0/1 Knapsack Problem\\n\\n```dp[i][j]``` means that ```stones[:i]``` can be put into a bag of size ```j```, the maximum value of the sum in the bag\\nif the stone can be put into the bag, we have two choice, one is to put it to the bag```dp[i-1][j - stones[i-1]] + stones[i-1]```, another is not```dp[i-1][j]```, choose the option with a larger value.\\n\\ntc is ```O((sum(stones) // 2) * len(stones))```, sc is the same as tc\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        if len(stones) == 1: return stones[0]\\n        total = sum(stones)\\n        half, leng =  total// 2, len(stones)\\n        dp = [[0] *  (half + 1) for _ in  range(leng + 1)]\\n        \\n        for i in range(1, leng+1):\\n            for j in range(1, half+1):\\n                if j - stones[i-1] >= 0:\\n                    dp[i][j] = max(dp[i-1][j], dp[i-1][j - stones[i-1]] + stones[i-1])\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return total - 2 * dp[leng][half]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```stones```\n```[2,7,4,1,8,1]```\n```1 = (4-2)-(8-7)-1+1```\n```\\nsum(A) + sum(B) = sum(stones)\\nsum(A) - sum(B) = diff, diff >= 0\\n\\n2 * sum(B) = sum(stones) - diff\\ndiff = sum(stones) - 2 * sum(B)\\nminimize diff to 0\\nsum(stones) - 2 * sum(B) >= 0\\nsum(B) as close to the half of sum(stones) as possible \\n```\n```dp[i][j]```\n```stones[:i]```\n```j```\n```dp[i-1][j - stones[i-1]] + stones[i-1]```\n```dp[i-1][j]```\n```O((sum(stones) // 2) * len(stones))```\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        if len(stones) == 1: return stones[0]\\n        total = sum(stones)\\n        half, leng =  total// 2, len(stones)\\n        dp = [[0] *  (half + 1) for _ in  range(leng + 1)]\\n        \\n        for i in range(1, leng+1):\\n            for j in range(1, half+1):\\n                if j - stones[i-1] >= 0:\\n                    dp[i][j] = max(dp[i-1][j], dp[i-1][j - stones[i-1]] + stones[i-1])\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return total - 2 * dp[leng][half]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296191,
                "title": "0-1-knapsack",
                "content": "divide the sum into two half to get the min. diff.  \\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ks(vector<int> &w ,int c)\\n    {\\n        int n = w.size();\\n        vector<vector<int>> cache(n+1,vector<int> (c+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j = 1;j<=c;j++)\\n            {\\n                cache[i][j] = max(cache[i][j],cache[i-1][j]);\\n                if(j>=w[i-1])\\n                {\\n                    cache[i][j] = max(cache[i][j],w[i-1]+cache[i-1][j-w[i-1]]);\\n                }\\n            }\\n        }\\n        return cache[n][c];\\n            \\n    }\\n    \\n    int lastStoneWeightII(vector<int>& a) {\\n        int s  = accumulate(a.begin(),a.end(),0);\\n        int val   = s/2;\\n        int res = ks(a,val);\\n        int  resi = s-res;          \\n        return abs(resi-res);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ks(vector<int> &w ,int c)\\n    {\\n        int n = w.size();\\n        vector<vector<int>> cache(n+1,vector<int> (c+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j = 1;j<=c;j++)\\n            {\\n                cache[i][j] = max(cache[i][j],cache[i-1][j]);\\n                if(j>=w[i-1])\\n                {\\n                    cache[i][j] = max(cache[i][j],w[i-1]+cache[i-1][j-w[i-1]]);\\n                }\\n            }\\n        }\\n        return cache[n][c];\\n            \\n    }\\n    \\n    int lastStoneWeightII(vector<int>& a) {\\n        int s  = accumulate(a.begin(),a.end(),0);\\n        int val   = s/2;\\n        int res = ks(a,val);\\n        int  resi = s-res;          \\n        return abs(resi-res);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263634,
                "title": "c-min-subset-diff-dp-explained-with-intuition",
                "content": "```\\n/*\\nthis is a variation of targte sum (leetcode 494) ,\\nbecause if u\\'ll see , here one one side we are adding elemnts \\nand , on the other side we are subtracting them,\\n\\ne.g-> stones = [2,7,4,1,8,1]\\n4-2=2;\\n8-7=1;\\n2-1=1;\\n1-1=1;\\n\\n\\nnow :\\n2-1=1;\\n1-1=0;\\n\\ntherefore 1 is left., which is our answer\\n\\n\\nthis is nothing but (4+7+1) - (2+8+1) =1\\n\\ntherefore we are calculating minimum subset differnce in the array\\n*/\\nclass Solution {\\npublic:\\n    int minSubsetDiff(vector<int>& stones,int range){\\n        int n=stones.size();\\n        vector<vector<int>> t(n+1,vector<int>(range+1));\\n        vector<int> check;\\n       for(int i=0;i<n+1;i++)\\n           t[i][0]=1;\\n        \\n        for(int i=1;i<range+1;i++)\\n           t[0][i]=0;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<range+1;j++){\\n                if(stones[i-1]<=j)\\n                    t[i][j]=t[i-1][j-stones[i-1]] || t[i-1][j];\\n                \\n                else\\n                     t[i][j]=t[i-1][j];\\n            }\\n        }\\n        \\n        for(int j=0;j<=range/2;j++){\\n            if(t[n][j])\\n                check.push_back(j);\\n        }\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<check.size();i++){\\n            ans=min(ans,range-(2*check[i]));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int lastStoneWeightII(vector<int>& stones) {\\n         int n=stones.size();\\n         int sum=0;\\n         for(int i=0;i<n;i++){\\n             sum+=stones[i];\\n         }\\n        \\n        return minSubsetDiff(stones,sum);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minSubsetDiff(vector<int>& stones,int range){\\n        int n=stones.size();\\n        vector<vector<int>> t(n+1,vector<int>(range+1));\\n        vector<int> check;\\n       for(int i=0;i<n+1;i++)\\n           t[i][0]=1;\\n        \\n        for(int i=1;i<range+1;i++)\\n           t[0][i]=0;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<range+1;j++){\\n                if(stones[i-1]<=j)\\n                    t[i][j]=t[i-1][j-stones[i-1]] || t[i-1][j];\\n                \\n                else\\n                     t[i][j]=t[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2249240,
                "title": "dp-solution-explained-with-comments-and-compared-to-minimum-subset-sum-difference",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& arr) {\\n        //take any two group of stones , if there will be equal stones they will cancel out each other \\n        // else they will create diff, we have to find minimum possible difference \\n        //it is equivalent to minimum subset sum difference problem \\n        \\n        int n=arr.size() ;\\n        int sum = 0 ; \\n\\t    for(int i=0;i<n;i++)\\n\\t        sum+=arr[i] ;\\n\\t    \\n\\t    //now create the table for subset SUm DP  ; \\n\\t    \\n\\t    bool dp[n+1][sum+1] ;\\n\\t    \\n\\t    \\n\\t    //initialization\\n\\t    for(int j=0 ; j<sum+1 ;j++)\\n\\t        dp[0][j] = false; \\n\\t    \\n\\t    for(int i=0;i<n+1;i++)\\n\\t        dp[i][0] = true ;\\n\\t        \\n\\t\\t\\t//subset Sum code to create the DDP table\\n\\t    \\n\\t    for(int i=1 ;i<n+1;i++){\\n\\t        for(int j=1;j<sum+1;j++){\\n\\t            \\n\\t            if(arr[i-1]<=j)\\n\\t                dp[i][j] = dp[i-1][j-arr[i-1]] or dp[i-1][j] ; \\n\\t            else\\n\\t                dp[i][j] = dp[i-1][j] ; \\n\\t        }\\n\\t    }\\n\\t    \\n\\t    //initializing a variable to store minimum difference from last  row of DP to find possible sum  \\n\\t    int minima = INT_MAX ; \\n\\t    for(int j=0 ;j<= sum/2 ;j++)\\n\\t    {\\n\\t        if(dp[n][j]==true) \\n\\t            minima = min(minima , sum - 2*j) ;\\n\\t    }\\n\\t    return minima ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& arr) {\\n        //take any two group of stones , if there will be equal stones they will cancel out each other \\n        // else they will create diff, we have to find minimum possible difference \\n        //it is equivalent to minimum subset sum difference problem \\n        \\n        int n=arr.size() ;\\n        int sum = 0 ; \\n\\t    for(int i=0;i<n;i++)\\n\\t        sum+=arr[i] ;\\n\\t    \\n\\t    //now create the table for subset SUm DP  ; \\n\\t    \\n\\t    bool dp[n+1][sum+1] ;\\n\\t    \\n\\t    \\n\\t    //initialization\\n\\t    for(int j=0 ; j<sum+1 ;j++)\\n\\t        dp[0][j] = false; \\n\\t    \\n\\t    for(int i=0;i<n+1;i++)\\n\\t        dp[i][0] = true ;\\n\\t        \\n\\t\\t\\t//subset Sum code to create the DDP table\\n\\t    \\n\\t    for(int i=1 ;i<n+1;i++){\\n\\t        for(int j=1;j<sum+1;j++){\\n\\t            \\n\\t            if(arr[i-1]<=j)\\n\\t                dp[i][j] = dp[i-1][j-arr[i-1]] or dp[i-1][j] ; \\n\\t            else\\n\\t                dp[i][j] = dp[i-1][j] ; \\n\\t        }\\n\\t    }\\n\\t    \\n\\t    //initializing a variable to store minimum difference from last  row of DP to find possible sum  \\n\\t    int minima = INT_MAX ; \\n\\t    for(int j=0 ;j<= sum/2 ;j++)\\n\\t    {\\n\\t        if(dp[n][j]==true) \\n\\t            minima = min(minima , sum - 2*j) ;\\n\\t    }\\n\\t    return minima ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202929,
                "title": "easy-c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int s = 0;\\n        for(auto a:stones) s+=a;\\n        int ans, i, j;\\n        if(s%2==0) ans=0;\\n        else ans=1;\\n        s /= 2;\\n        vector<vector<bool>> dp(stones.size()+1, vector<bool>(s+1, false));\\n        dp[0][0] = true;\\n        sort(stones.begin(), stones.end());\\n        for(i=1; i<=stones.size(); ++i)\\n            for(j=0; j<=s; ++j){\\n                if(j==0) dp[i][j] = true;\\n                else if(j<stones[i-1]) dp[i][j] = dp[i-1][j];\\n                else dp[i][j] = dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n             }\\n        while(!dp[i-1][s--]) ans+=2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int s = 0;\\n        for(auto a:stones) s+=a;\\n        int ans, i, j;\\n        if(s%2==0) ans=0;\\n        else ans=1;\\n        s /= 2;\\n        vector<vector<bool>> dp(stones.size()+1, vector<bool>(s+1, false));\\n        dp[0][0] = true;\\n        sort(stones.begin(), stones.end());\\n        for(i=1; i<=stones.size(); ++i)\\n            for(j=0; j<=s; ++j){\\n                if(j==0) dp[i][j] = true;\\n                else if(j<stones[i-1]) dp[i][j] = dp[i-1][j];\\n                else dp[i][j] = dp[i-1][j] or dp[i-1][j-stones[i-1]];\\n             }\\n        while(!dp[i-1][s--]) ans+=2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166581,
                "title": "simple-java-dp-solution",
                "content": "class Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int dp[] = new int[15000];\\n        int sum = 0;\\n        for(int i=0;i<stones.length;i++){\\n            sum += stones[i];\\n        }\\n        int target = sum / 2;\\n        for(int i=0;i<stones.length;i++){\\n            for(int j=target;j>=stones[i];j--){\\n                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);\\n            }\\n        }\\n        return sum - dp[target] - dp[target];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int dp[] = new int[15000];\\n        int sum = 0;\\n        for(int i=0;i<stones.length;i++){\\n            sum += stones[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2161416,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def lastStoneWeightII(self, A):\\n        ans = _sum = sum(A)\\n        n = _sum // 2 + 1\\n        dp = [False] * n\\n        dp[0] = True\\n        for i in A:\\n            for j in range(n-1,i-1,-1):\\n                dp[j] = dp[j] | dp[j-i]\\n                if dp[j]: ans = min(ans,_sum - 2*j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeightII(self, A):\\n        ans = _sum = sum(A)\\n        n = _sum // 2 + 1\\n        dp = [False] * n\\n        dp[0] = True\\n        for i in A:\\n            for j in range(n-1,i-1,-1):\\n                dp[j] = dp[j] | dp[j-i]\\n                if dp[j]: ans = min(ans,_sum - 2*j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078876,
                "title": "explanation-of-logic-why-it-can-be-treat-as-an-01-knapsack-problem",
                "content": "This is what I think to understand this problem, hope it is useful for those who can\\'t accept other explanations.\\n\\n\\nExample:\\n\\nAssume that we have 3 stones a, b, c, and the best order is a crush b then crush c\\n\\nWe have 4 possibilities\\n\\n1:  a > b and c >= a-b  => the result will be c - (a - b) = c - a + b\\n\\n2:  a < b and c >= b-a => the result will be c - (b - a) = c - b + a\\n\\n3: a > b and c < a-b => the result will be a - b - c\\n\\n4: a < b and c < b-a=> the result will be b - a - c\\n\\nFor multiple elements, they eventually can be crushed to this base case.\\n\\nIn fact, after every crush is equal to performing a \"+\" or \"-\" to the crushed stone.\\n\\n\\nSo this problem is actually asking:\\n\\n\"Put +/- between these elements such that the absolute value of the result is minimum\"\\n\\n=> make abs(s1 + s2 +... + sn - sn+1 - sn+2 -... -sm) as small as possible, and we can seperate this into 2 groups\\n\\n=> abs(sum(s1, s2, ..., sn) - sum(sn+1, sn+2, ..., sm))\\n\\nLet s1 + s2+... + sn <= sn+1 + ... + sm\\n\\n=>\\n\\nminimum diff = sn+1 + ... + sm - s1 - ... - sn = sn+1+...+sm+s1+...+sn - 2*(s1+...+sn) = sum(all stones) - 2*(s1 + ... + sn)\\n\\n\\nNow here is the conclusion,\\n\\n01 knapsack :\\n volume of bag: sum(all stones) // 2 \\n (here, we want to find s1, ..., sn, don\\'t forget that we assume the sum of this group <= another group, so this set will not be larger than sum(all stones)//2)\\n objects s1, ..., sm \\n the value is equal to the weight\\n \\n According to above, we can finally write some codes.\\n\\n\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        SUM = sum(stones)\\n        target =  SUM // 2\\n        table = [0] * (target + 1)\\n        for stone in stones:\\n            for remain_weight in range(target, stone-1, -1):\\n                table[remain_weight] = max(table[remain_weight], table[remain_weight-stone] + stone)\\n        return SUM - 2*table[target]\\n\\n\\nHope this can help you!",
                "solutionTags": [
                    "Python"
                ],
                "code": "This is what I think to understand this problem, hope it is useful for those who can\\'t accept other explanations.\\n\\n\\nExample:\\n\\nAssume that we have 3 stones a, b, c, and the best order is a crush b then crush c\\n\\nWe have 4 possibilities\\n\\n1:  a > b and c >= a-b  => the result will be c - (a - b) = c - a + b\\n\\n2:  a < b and c >= b-a => the result will be c - (b - a) = c - b + a\\n\\n3: a > b and c < a-b => the result will be a - b - c\\n\\n4: a < b and c < b-a=> the result will be b - a - c\\n\\nFor multiple elements, they eventually can be crushed to this base case.\\n\\nIn fact, after every crush is equal to performing a \"+\" or \"-\" to the crushed stone.\\n\\n\\nSo this problem is actually asking:\\n\\n\"Put +/- between these elements such that the absolute value of the result is minimum\"\\n\\n=> make abs(s1 + s2 +... + sn - sn+1 - sn+2 -... -sm) as small as possible, and we can seperate this into 2 groups\\n\\n=> abs(sum(s1, s2, ..., sn) - sum(sn+1, sn+2, ..., sm))\\n\\nLet s1 + s2+... + sn <= sn+1 + ... + sm\\n\\n=>\\n\\nminimum diff = sn+1 + ... + sm - s1 - ... - sn = sn+1+...+sm+s1+...+sn - 2*(s1+...+sn) = sum(all stones) - 2*(s1 + ... + sn)\\n\\n\\nNow here is the conclusion,\\n\\n01 knapsack :\\n volume of bag: sum(all stones) // 2 \\n (here, we want to find s1, ..., sn, don\\'t forget that we assume the sum of this group <= another group, so this set will not be larger than sum(all stones)//2)\\n objects s1, ..., sm \\n the value is equal to the weight\\n \\n According to above, we can finally write some codes.\\n\\n\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        SUM = sum(stones)\\n        target =  SUM // 2\\n        table = [0] * (target + 1)\\n        for stone in stones:\\n            for remain_weight in range(target, stone-1, -1):\\n                table[remain_weight] = max(table[remain_weight], table[remain_weight-stone] + stone)\\n        return SUM - 2*table[target]\\n\\n\\nHope this can help you!",
                "codeTag": "Python3"
            },
            {
                "id": 2024273,
                "title": "easy-java-solution-with-few-lines-of-code-similar-to-coin-change",
                "content": "\\xB4\\xB4\\xB4\\xB4\\nclass Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n       int sum = 0;\\n        \\n        for(int stone : stones){\\n            sum += stone;    \\n        }\\n        \\n        int half = sum / 2;\\n        int[] dp = new int[half+1];\\n        \\n        for(int stone : stones){\\n            for(int i=half;i>=0; i--){\\n                if(i-stone >= 0){\\n                    dp[i] = Math.max(dp[i], dp[i-stone] + stone);\\n                }\\n            }\\n        }\\n        \\n        return sum- 2*dp[half];\\n    }\\n}\\n\\xB4\\xB4\\xB4\\xB4",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n       int sum = 0;\\n        \\n        for(int stone : stones){\\n            sum += stone;    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2007036,
                "title": "dp-again-01-knapsack-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(stones.begin(), stones.end(), 0);\\n        int target = sum >> 1;\\n        vector<int> dp(target + 1, 0);\\n        for (int stone : stones)\\n            for (int i = target; i >= stone; i--)\\n                dp[i] = max(dp[i], dp[i - stone] + stone);\\n        int res = sum - dp[target] * 2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum = accumulate(stones.begin(), stones.end(), 0);\\n        int target = sum >> 1;\\n        vector<int> dp(target + 1, 0);\\n        for (int stone : stones)\\n            for (int i = target; i >= stone; i--)\\n                dp[i] = max(dp[i], dp[i - stone] + stone);\\n        int res = sum - dp[target] * 2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976119,
                "title": "is-the-problem-description-incorrect",
                "content": "Bit confused. The problem states that `x <= y` and to destory `x` and replace `y` with `y - x`.\\n\\nCool, totally makes sense, but then why does your explanation show...\\n\\n```\\nInput: stones = [2,7,4,1,8,1]\\nOutput: 1\\nExplanation:\\nWe can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1]\\n```\\n\\nGoing by the problem description, yes we can combine 2 and 4 to get 2 BUT that would mean our resultant array should be (assuming `x` is less than `y`)...\\n\\n```\\nstones = [7,2,1,8,1]\\n```\\n\\nAm I missing something?",
                "solutionTags": [],
                "code": "```\\nInput: stones = [2,7,4,1,8,1]\\nOutput: 1\\nExplanation:\\nWe can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1]\\n```\n```\\nstones = [7,2,1,8,1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966490,
                "title": "python-knapsack",
                "content": "\\n    def lastStoneWeightII(self, stone):\\n        @lru_cache(None)\\n        def dp(index, capacity):\\n            if index == 0:\\n                return 0\\n            \\n            if capacity <= 0:\\n                return 0\\n            \\n            if capacity >= stone[index-1]:\\n                return max(dp(index-1, capacity), dp(index-1, capacity - stone[index-1]) + stone[index-1])\\n            else:\\n                return dp(index-1, capacity)\\n            \\n        return abs(sum(stone) - 2*dp(len(stone), sum(stone)//2))",
                "solutionTags": [],
                "code": "\\n    def lastStoneWeightII(self, stone):\\n        @lru_cache(None)\\n        def dp(index, capacity):\\n            if index == 0:\\n                return 0\\n            \\n            if capacity <= 0:\\n                return 0\\n            \\n            if capacity >= stone[index-1]:\\n                return max(dp(index-1, capacity), dp(index-1, capacity - stone[index-1]) + stone[index-1])\\n            else:\\n                return dp(index-1, capacity)\\n            \\n        return abs(sum(stone) - 2*dp(len(stone), sum(stone)//2))",
                "codeTag": "Python3"
            },
            {
                "id": 1959682,
                "title": "python3-converted-to-knapsack-problem",
                "content": "Essentially, this problem is to find two subsequences with minimun difference in term of sequence sum\\nFor instance, the stones array are divided into seq1 and seq2, regardless of how to pick  stones from seq1 and seq2 and smash them, finally either seq1 or seq2 is empty.\\nIf seq1 and seq2 are not empty, you can continue smash until one of them is empty.\\nSo the problem became how to make the sum of seq1 and the sum of seq2 are as close as possible. seq1 and seq2 should be close to half sum of total array.\\nThen it\\'s easy to convert it to a 0/1 knapsack problem. The volume of knapsack is sum(stones)//2\\npick a sequence whose sum is closest to the volume of the knapsack.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        total_sum =  sum(stones)\\n        V = total_sum//2\\n        @cache\\n        def knapsack(i:int, v:int) -> int:\\n            if v <= 0:\\n                return 0\\n            if i < 0:\\n                return 0\\n            if stones[i] > v:\\n                return knapsack(i-1, v)\\n            else:\\n                return max(knapsack(i-1, v), stones[i] + knapsack(i-1, v - stones[i]))\\n        return abs(total_sum - 2*knapsack(n-1, V))",
                "solutionTags": [],
                "code": "Essentially, this problem is to find two subsequences with minimun difference in term of sequence sum\\nFor instance, the stones array are divided into seq1 and seq2, regardless of how to pick  stones from seq1 and seq2 and smash them, finally either seq1 or seq2 is empty.\\nIf seq1 and seq2 are not empty, you can continue smash until one of them is empty.\\nSo the problem became how to make the sum of seq1 and the sum of seq2 are as close as possible. seq1 and seq2 should be close to half sum of total array.\\nThen it\\'s easy to convert it to a 0/1 knapsack problem. The volume of knapsack is sum(stones)//2\\npick a sequence whose sum is closest to the volume of the knapsack.\\n```\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        total_sum =  sum(stones)\\n        V = total_sum//2\\n        @cache\\n        def knapsack(i:int, v:int) -> int:\\n            if v <= 0:\\n                return 0\\n            if i < 0:\\n                return 0\\n            if stones[i] > v:\\n                return knapsack(i-1, v)\\n            else:\\n                return max(knapsack(i-1, v), stones[i] + knapsack(i-1, v - stones[i]))\\n        return abs(total_sum - 2*knapsack(n-1, V))",
                "codeTag": "Java"
            },
            {
                "id": 1935289,
                "title": "dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[34][3010];\\n    int func(vector<int>&arr,int i,int sum,int mer,int n)\\n    {\\n        if(i>=n)\\n        {\\n            return abs(sum-mer);\\n        }\\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n        int x=min(func(arr,i+1,sum,mer,n),func(arr,i+1,sum-arr[i],mer+arr[i],n));\\n        return dp[i][sum]=x;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0;\\n        memset(dp,-1,sizeof dp);\\n        for(auto i : stones)\\n        {\\n            sum+=i;\\n        }\\n        \\n        return func(stones,0,sum,0,stones.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[34][3010];\\n    int func(vector<int>&arr,int i,int sum,int mer,int n)\\n    {\\n        if(i>=n)\\n        {\\n            return abs(sum-mer);\\n        }\\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n        int x=min(func(arr,i+1,sum,mer,n),func(arr,i+1,sum-arr[i],mer+arr[i],n));\\n        return dp[i][sum]=x;\\n    }\\n    \\n    int lastStoneWeightII(vector<int>& stones) {\\n        int sum=0;\\n        memset(dp,-1,sizeof dp);\\n        for(auto i : stones)\\n        {\\n            sum+=i;\\n        }\\n        \\n        return func(stones,0,sum,0,stones.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929171,
                "title": "python-o-1-memory-random-search",
                "content": "Considering the small size constraint of 30, a random shuffle bruteforce passes all cases with constant space\\n```\\nimport functools as ft\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        ans = 999\\n        for i in range(len(stones) * 50):\\n            random.shuffle(stones)\\n            ans = min(ans, ft.reduce(lambda a,v: v if a==0 else abs(a-v), stones))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools as ft\\nclass Solution:\\n    def lastStoneWeightII(self, stones: List[int]) -> int:\\n        ans = 999\\n        for i in range(len(stones) * 50):\\n            random.shuffle(stones)\\n            ans = min(ans, ft.reduce(lambda a,v: v if a==0 else abs(a-v), stones))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834336,
                "title": "javascript-solution-dp",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeightII = function(stones) {\\n    if (stones.length === 1) { return stones.pop(); }\\n    let sum = 0;\\n    for (let stone of stones) {\\n        sum += stone;\\n    }\\n    \\n    let candidates = [];\\n    for (let stone of stones) {\\n        let newCandidates = [];\\n        newCandidates.push(stone);\\n        \\n        candidates.forEach((n) => {\\n            if (!candidates.includes(n + stone)) {\\n                newCandidates.push(n + stone);\\n            }\\n        });\\n        \\n        candidates = [...candidates, ...newCandidates.filter((a) => a <= sum/2)];   \\n    }\\n    \\n    candidates.sort((a, b) => Number(a) - Number(b));\\n    \\n    let s = candidates.pop()\\n    return (sum - s) - s;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeightII = function(stones) {\\n    if (stones.length === 1) { return stones.pop(); }\\n    let sum = 0;\\n    for (let stone of stones) {\\n        sum += stone;\\n    }\\n    \\n    let candidates = [];\\n    for (let stone of stones) {\\n        let newCandidates = [];\\n        newCandidates.push(stone);\\n        \\n        candidates.forEach((n) => {\\n            if (!candidates.includes(n + stone)) {\\n                newCandidates.push(n + stone);\\n            }\\n        });\\n        \\n        candidates = [...candidates, ...newCandidates.filter((a) => a <= sum/2)];   \\n    }\\n    \\n    candidates.sort((a, b) => Number(a) - Number(b));\\n    \\n    let s = candidates.pop()\\n    return (sum - s) - s;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564755,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564607,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564937,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565168,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565453,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1566623,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565911,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1567726,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1567685,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1568313,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564755,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564607,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1564937,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565168,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565453,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1566623,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1565911,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1567726,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1567685,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1568313,
                "content": [
                    {
                        "username": "apun_ko_level_badhane_ka",
                        "content": "Say you have four stones a,b,c,d.\\nfirst you smash b against c, you get (b-c)\\nnow you smash (b-c) against a\\nyou get a-(b-c) which is same as (a+c)-(b)\\nnow you smash d against (a+c)-b\\nyou get d-((a+c)-b) which is same as (d+b)-(a+c).\\nBasically for the given stones we can create two sets,the sum of  second set of stones to be subtracted from sum of first one.\\nideally we want sum of each set to be sum(stones)/2 so that they cancel each other out.\\n\\nSo to solve the problem we try to select a set of stones such that their sum comes as close as possible to sum(stones)/2 from the lower side.\\nClearly this subproblem is analogous to the knapsack problem.\\n\\nSince we went from the lower side we have created the second set, that is the set to be subtracted. The first set then becomes sum-dp\\\\[n\\\\]\\\\[sum/2\\\\].\\nTherefore the answer becomes sum-2*(dp\\\\[n\\\\]\\\\[sum/2\\\\])\\n"
                    },
                    {
                        "username": "renato4",
                        "content": "**NOTE**: I previously explained this in another post. But I\\'m posting it now as a standalone post to help others finding this answer easily. [Link to the post where I answered this in the form of reply](https://leetcode.com/problems/last-stone-weight-ii/discuss/295325/Why-DP-is-applicable-here)\\n\\nSuppose you have rock a, b, c and d.\\nIf you subtract them in the following order: b-c, then d-(b-c). Then it is the same as doing d-b+c.\\nThen doing (d-b+c)-a is the same as -a+d-b+c, which is d+c-a-b, which is (d+c)-(a+b). So doing things in that order will lead to this shortcut.\\n\\nLets try another order.\\nSuppose you have rock a, b, c and d.\\nIf you do a-d, then b-c, then (a-d)-(b-c).\\nThen (a-d)-(b-c) is the same as a-d-b+c, which is the same as -d-b+a+c, which is -(d+b)+(a+c), which is (a+c)-(d+b). Another shortcut.\\n\\nThen you can see that depending on the order of the subtractions, we get a different setting of difference between two groups."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you managed to come up with intuition of knapsack ?? "
                    },
                    {
                        "username": "sharathnarayan",
                        "content": "I am sure that greedy algorithm doesn\\'t work here. But how to prove that it doesn\\'t work?\\n\\nDuring contest I came up with a solution to pop out the largest two elements calculate their difference and push it back in. Using a heap to pop the largest two elements.\\n\\nI was sure that this wouldn\\'t work but I didn\\'t know how to write a test case to prove that it doesn\\'t work. Can somone please help me with understanding on how to prove greedy doesn\\'t work and how you guys/gals confirm that greedy doesn\\'t work during contest?"
                    },
                    {
                        "username": "Anuj_vanced",
                        "content": "101 100 99 98 1 \\nTry Greedy !\\'"
                    },
                    {
                        "username": "2f317609",
                        "content": "How to prove that we can achieve any sum with +/- in front of every number  with the process from the problem description? It\\'s not obvious, at least to me."
                    },
                    {
                        "username": "abhishek_108",
                        "content": "My understanding of Knapsack problem is this-\\n\\nYou are given a set of items , for each of which we have a weight w[i] and value v[i] . Now we have a bag for capcaity W and we have to select items in such a way that we can maximize our profit and the total weight of items that we select should be <W.\\n\\nCan somebody explain to me now that how does the Last Stone Weight II problem boils down to Knapsack as many have claimed in their Articles?"
                    },
                    {
                        "username": "hmygrace",
                        "content": "It really took me sometime to think it through, so I want to share my understanding with you.\\n\\nSay we have 3 stones: a, b, c. We could do following steps as one possible solution\\n\\ni. smash a, b, get new stone x = |a-b|\\nii. smash x, c, get one result = |x-c|\\n\\nIn this case, the result we get is ||a-b|-c|, and we can look at it closer.\\na.\\ta>b & a-b>c  => a-b-c = a-(b+c)\\nb.\\ta>b & a-b<c  => c-(a-b) = (b+c)-a\\nc.\\ta<b & a-b>c  => b-a-c = b-(a+c)\\nd.\\ta<b & a-b<c  => c-(b-a) = (a+c)-b\\n\\nYou could easily noticed the result would be the weight different of two group of stones, but this is not happened by accident. \\n\\nNo matter what ||a-b|-c| is, it can always be presented as (+/-)a(+/-)b(+/-)c, there is no other symbols. And you can always separate the stones to two groups by their symbols. Then you would get something as sum(group1)-sum(group2), and what makes the result closer to zero would be the correct answer.\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Lets suppose we have [a,b,c,d,e]\\nSuppose we smash a&b, our new array is [a-b,c,d,e]\\nSuppose we smash c&d, our new array is [a-b,c-d,e]\\nSuppose we smash (a-b)&e, our new array is [a-b-e,c-d]\\nNow we smash remaining two, our answer is ( (a-b-e) - (c-d) ) == (a-b-e-c+d) = (a+d) - (b+c+e)\\nSince we subtract lighter stone from heavier one we can\\'t get negative answer,\\nso goal is to partition the array in two sets whose absolute difference is minimum.\\n(It\\'s the question TARGET SUM which is variation of SUBSET SUM which is variation of KNAPSACK)"
                    },
                    {
                        "username": "michaelkogan987777",
                        "content": "Let\\'s assume we have a set of stones, for the purposes of this example say 5. Our stones array would be [s1, s2, s3, s4, s5]. We will smash the stones in some order such that the result is optimal.\\n\\nWe can look at the second example to understand this formulation. In that example, stones = [31, 26, 33, 21, 40].\\n\\nThe optimal order is:\\n\\n1. stones[4] smash stones[3] = 19 = res1\\n2. stones[1] smash res1 = 7 = res2\\n3. stones[2] smash stones[0] = 2 = res3\\n4. res2 smash res3 = 5 = ans\\n\\nWe can express this using the following equation:\\n\\nans = stones[1] - (stones[4] - stones[3]) - (stones[2] - stones[0])\\n\\nWe can then simplify this equation by breaking apart the brackets, and grouping positive and negative stone values:\\n\\nans = stones[1] - stones[4] + stones[3] - stones[2] + stones[0]\\nans = (stones[1] + stones[3] + stones[0]) - (stones[4] + stones[2])\\n\\nSo it turns out that the answer can be expressed as the difference between two complimentary sums of stones. This will apply to any arbitrary array of stones.\\n\\nIt took me a while to understand exactly why so I wanted to share this logic in case anyone else is struggling. Needless to say, from here this can be solved as a 0/1 knapsack problem."
                    },
                    {
                        "username": "kuailema9089",
                        "content": "Assume we already got two groups that has the minimum difference. Now we have to prove it is **constructible** based on the rule.\\n\\nIf we use x_i to represent elements in the group with \\'+\\', and to use y_j to represent elements in the group with \\'-\\'. And we compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', if y_j\\' > x_i\\', we could assume we first smashed these two, and put the result into group \\'-\\'. now the new stone y_j\\'\\' = y_j\\' - x_i\\' has smaller size than y_j\\'. \\n\\nLoop:\\nWe could continue to do this, which is always to compare the largest stone y_j\\' in group \\'-\\' with the smallest stone x_i\\' in group \\'+\\', until:\\n* case 1: y_j\\' <= x_i\\', which means all stones in group \\'-\\' are smaller or of the same size of stones in group \\'+\\', we could simply combine stones from two groups one-by-one, like (x_i, y_j), and x_i >= y_j, so we smash them, and put the result x_i\\'\\' = x_i - y_j into group \\'+\\'. \\nThen we have two scenarios:\\n\\t* if there were more stones in group \\'+\\' than group \\'-\\', then there will be no more stones left in group \\'-\\' (could be no more stone left in any group, then proof is done);\\n\\t* else, we have stones left in both groups, while some of stones in group \\'+\\' has smaller size than before, because of the smash. Then we could go back to do the loop before.\\n* case 2: there are no more stones left in group \\'+\\' (could be no more stone left in any group, then proof is done).\\n\\nSo eventually, we will have only stones left in at most one of the groups. (could be no more stone left in any group, then proof is done)\\n\\nIf there are more than two stones in this one group, as each stone is a linear combination of multiple stones +/-, then we could flip some of them, to make the sum of the size of the left stones smaller, which is against the assumption that the two groups we began with have the minimum difference. \\nSo, there will be at most one stone left in the group. And it\\'s the minimum different. Proof is done.\\n\\nExample:\\nstones = [2,7,4,1,8,1]\\nAnd after using knapsack method, we got two groups: (1 = -2 -7 + 4 -1 + 8 -1)\\n\\'+\\': 4, 8 \\n\\'-\\': 2, 7, 1, 1\\n\\nstep 1:\\nreorder two groups:\\n\\'+\\': 8, 4\\n\\'-\\': 7, 2, 1, 1\\n\\nstep 2:\\n1. 7 > 4, so remove 4 from \\'+\\', remove 7 from \\'-\\', and add 3 = (7 - 4) to \\'-\\'.\\nso far, 3 = (7 - 4)\\n\\'+\\': 8\\n\\'-\\': 3, 2, 1, 1\\n2. 3 < 8, so pair (8, 3), remove 8 from \\'+\\', remove 3 from \\'-\\', and add 5 = (8 - 3) to \\'+\\'.\\nso far, 5 = (8 - (7 - 4))\\n\\'+\\': 5\\n\\'-\\': 2, 1, 1\\n3. 2 < 5, so pair (5, 2), remove 5 from \\'+\\', remove 2 from \\'-\\', and add 3 = (5 - 2) to \\'+\\'.\\nso far, 3 = ((8 - (7 - 4)) - 2)\\n\\'+\\': 3\\n\\'-\\': 1, 1\\n4. 1 < 3, so pair (3, 1), remove 3 from \\'+\\', remove 1 from \\'-\\', and add 2 = (3 - 1) to \\'+\\'.\\nso far, 2 = (((8 - (7 - 4)) - 2) - 1)\\n\\'+\\': 2\\n\\'-\\': 1\\n5. 1 < 2, so pair (2, 1), remove 2 from \\'+\\', remove 1 from \\'-\\', and add 1 = (2 - 1) to \\'+\\'.\\nso far, 1 = ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\'+\\': 1\\n\\'-\\': empty\\n\\nDone.\\nSo, one of the possible solutions to get difference == 1 is: ((((8 - (7 - 4)) - 2) - 1) - 1)\\n\\n\\n"
                    },
                    {
                        "username": "user2620D",
                        "content": "https://link.medium.com/jyTLe5qTE5"
                    }
                ]
            },
            {
                "id": 1568257,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1568141,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1570737,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1570720,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1575053,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1574931,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1574880,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1573608,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 2056739,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            },
            {
                "id": 1934811,
                "content": [
                    {
                        "username": "b_pritam",
                        "content": "Can some body please help me to get the intuition for this problems?\\xA0 why this problem is related to knapsack problem?  And how knapsack solution works h?"
                    },
                    {
                        "username": "pangeneral",
                        "content": "This problem can be solved in dp after we transfer it into \"finding the minimum difference between the sum of two groups\". But why can it be transformed?"
                    },
                    {
                        "username": "kmr_shubh",
                        "content": "https://joseiciano.medium.com/last-stone-weight-ii-a-leetcode-problem-a37f49e55d13"
                    },
                    {
                        "username": "user3808W",
                        "content": "i dont understand how can we group into two sets everytime.\\nlet say, stones = [a, b, c] (sorted in inc. order)\\ni want, set1 = [b, c] , set2 = [a]\\nhow can i do that?"
                    },
                    {
                        "username": "kryvokrysenko",
                        "content": "What logic process can be used during the interview to come from the problem statement to \"diff between 2 set of rocks\" if you never seen this problem before? This seems like a big jump and it\\'s not intuitive at all.\\n\\nIf you figured out this problem yourself, please share your thought process."
                    },
                    {
                        "username": "kromatic",
                        "content": "\\nSo recognizing this problem to be a Knapsack problem relies on recognizing that the last stone weight w = +/-w_1 +/- w_2 .... +/- w_n, where the w_i are the original stones. From here you just group the stones with the + signs and subtract from them the sum of the stones with the - signs.\\n\\nNote: This proof alone is not enough to establish the equivalence between minimizing last stone weight and minimizing the sum as written above. This proof just establishes that every last stone weight can be expresed as such a sum (and this actually can easily be observed by simply writing out what is happening in the stone smashing process in terms of the original weights). For a proof of the fact that the minimum final stone weight equals the minimum sum +/-w_1 +/- .... +/- w_n >= 0, please read alreadydone\\'s proof (2nd comment from top under https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC%2B%2BPython-Easy-Knapsacks-DP).\\n\\nBut I was confused for a while as to why this observation is correct, until I was able to come up with the following proof (by induction). The proposition I will prove is the following: Let w_1, ..., w_n be the original stones, and let v_1, ... , v_m be the stones at some arbitrary stage of the smashing process. Then the original stone weights\\' indices {1, ..., n} can be partitioned into subsets P_1, ..., P_m such that for all 1 <= j <= m, we have v_j = sum +/- w_i where i is in P_j. (By definition a partition of a set is a collection of disjoint subsets whose union is the entire set. So essentially, this says that we are able to uniquely assign each w_i to be in a +/- sum which equals some v_j, and that each v_j can be expressed as such a sum.) This proposition can only hold if we retain the 0 weights resulting from smashing two identical rocks (but only allow the smashing of nonzero rocks in order to retain equivalence to the original simulation).*(***)*\\n\\nProving the above proposition will imply the result we wanted to begin with (that the final weight w = +/w_1 +/- w_2 ... +/- w_n). The reasoning for this is as follows. Before the final smashing our collection of stones will consist of two nonzero stones and maybe some 0s. Smashing the nonzero stones together will change our collection into the final weight and whatever 0s there might have been. Now, the proposition states that the original stones\\' indices {1, ..., n} can be paritioned into subsets P_1, ..., P_m such that the final weight w = sum +/- w_i where i is in some P_j and each of the 0s similarly corresponds to a subset P_j. But w + 0 + ... + 0 = w, so we can just take the union of all the subsets P_j to get a summation of w in terms of *all* of the original weights. (Since the P_j are disjoint, we will not have any w_i repeat in the sum.)\\n\\nBase case (prior to having smashed any rocks): at this point, the remaining stones are the original stones, and since each stone equals itself, the statement is trivially satisfied (the weights are partitioned into singleton sets in this case).\\n\\nInductive step: Suppose the statement holds for the previous collection of remaining weights v_1, ..., v_m. During the smashing step, we will choose two rocks from this collection, say v_k != 0 and v_j != 0 with k != j, and smash them. Let\\'s call the resulting collection of remaining stones u_1, ... , u_p (p = m-1). This collection will consist of all the v_i with i != k and i != j, since these rocks were not smashed, and u_r = abs(v_j-v_k) = +/-(v_j-v_k). Since order of rocks does not matter, we can just say that u_1, ... , u_(p-1) are the unchanged v_i and that u_p = +/-(v_j-v_k). Now, since we assume the statement holds for the v_i, there exists a partition P_1, ..., P_m of {1, ..., n} such that each v_s = sum +/- w_i where i is in P_s (1 <= s <= m). In particular, v_j and v_k can each be expressed as the summation of +/-w_i where the w_i belong to exactly one of the disjoint sets P_j and P_k . Now, let\\'s create a new partition Q_1, ..., Q_p of {1, ... , n}, where for all 1 <= j < p, Q_j = P_i such that u_j = v_i and Q_p = P_j union P_k. So, essentially, we are just joining the two subsets corresponding to the smashed rocks and keeping the other ones the same.  Since u_p = +/-(v_j-v_k), it is easy to see how to express u_p  = sum +/- w_i where i is in Q_p = P_j union P_k: we just write v_j and v_k in terms of w_i from P_j and P_k, respectively, substitute these expressions into u_p = +/-(v_j-v_k), and distribute the signs. (Since P_j and P_k are disjoint, the same w_i will not be repeated.) For the u_s with 1 <= s < p, we have u_s = v_i and Q_s = P_i for some 1 <= i <= m. So here we just keep the summations from the previous collection of rocks. Thus, our new partition satisfies the requirements for u_1, ..., u_p, the new collection of rocks.\\n\\nThis completes the proof.\\n\\nI don\\'t know how many people will read this, and I am sorry if this is not clear enough. I may have also messed up the indices and made this overly pedantic. I could have expressed this much better using LaTeX, but idk if leetcode supports it.\\n\\n*(***)* I need to do this for the sake of this proof since the proposition requires a partition of *all* the original weight\\'s indices, and retaining the 0\\'s ensures that this is possible. Also, this does not change the overall smashing process since we will still only smash nonzero rocks together."
                    },
                    {
                        "username": "kwi_t",
                        "content": "This might be a little bit too late but still want to share my proof on why this problem can be translated to partioning the array to two parts with the min sum difference. To prove that, we need to show that the eventual result can be represented as the sum of stone weights with sign. Let\\'s do that by using induction.\\n\\nFirst thing we need to do is to extend the definition of this problem a little bit, we are going to allow stone of weights 0 to exist. Now let\\'s start our induction process.\\n1. If there\\'s only one stone, it\\'s obvious that the final result can be represented as stones[0]\\n2. Assume the final result any a k-stone problem can be represented as the sum of stone weights with sign:\\n    stones[x1]-stones[x2]+stones[x3]-...+stones[xk]\\n3. For a (k+1)-stone problem, we always need to make a move to smash two stones, transferring it to a k-stone problem, with one stone\\'s weight being either stones[s1] - stones[s2] or stones[s2] - stones[s1], s1 and s2 are the two stones first picked.\\n\\n    According to 2, the new k-stone problem can be represented as sum of stone weights with sign. Therefore this (k+1)-stone problem can be represented as sum of stone weights with sign as well.\\n\\nAccording to the rule of induction, any such problem can be represented as sum of stone weights with sign.\\n\\nNow don\\'t forget that we extend the definition to allow 0 weight stone to exist because at 3, smashing two stones can lead to cancellation.\\n\\nIt\\'s very trivial that 0 weight stone doesn\\'t impact final result. So finally, we prove that the result of the original problem can be represented as the sum of stone weights with sign. Hence, to achieve the min results, we need to partition stones to two groups with min sum difference."
                    },
                    {
                        "username": "lnicoletti",
                        "content": "Hello,\\n\\nAfter submitting my solution I get a wrong answer on the input [31, 26, 33, 21, 40]. My solution returns 9, whereas the expected is 5. But how is it possible?\\n\\nStep by step:\\n\\n1. [31, 26, 33, 21, 40] -> initial\\n2. [31, 26, 21, 7] -> as 40 - 33 = 7\\n3. [21, 7, 5] -> as 31 - 26 = 5\\n4. [5, 14] -> as 21 - 7 = 14\\n5. [9] -> as 14 - 5 = 9\\n\\nWhat am I doing wrong here?\\n"
                    },
                    {
                        "username": "akshat_ag",
                        "content": "31 26 33 21 40 - initial\\n9 26 33 21 -from 31 & 40\\n9 7 21 -from 26 & 33\\n12 7 - from 9 & 21\\n5"
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "If you observe carefully, the problem actually ask you to divide the array into 2 halves such that the both halves' sums' difference should be minimum.\nTake for example there are only 2 elements, you would be really happy if these 2 elements have the closest weight for eg 3,2 so that the stone left would only be 1.\nNow apply this on a bigger array."
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "I have\\'nt found any post actually proving beyond quoting some examples that Given any specific assignments of +/- signs to stones s.t the evaluation of the expression = minimum, it is possible to form this expression using the provided pick and smash method. \\n\\nYes, I get that by tinkering around which and the order of stones to pick and smash, we can get different +/- expressions, but can we prove that we can get at least one optimal expression given any input of stones?"
                    }
                ]
            }
        ]
    }
]